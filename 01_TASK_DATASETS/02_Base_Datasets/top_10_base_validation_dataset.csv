problem_link,problem_name,problem_statement,problem_solution,tags,dificulty
https://codeforces.com//contest/286/problem/E,E. Ladies  Shop,A ladies shop has recently opened in the city of Ultima Thule To get ready for the opening the shop bought bags Each bag is characterised by the total weight of the items you can put there The weird thing is you use these bags to put a set of items with the total weight strictly less than However the weights of the items that will be sold in the shop haven t yet been defined That s what you should determine right now Your task is to find the set of the items weights such that Any bag will be used That is for any there will be such set of items that their total weight will equal We assume that there is the infinite number of items of any weight You can put multiple items of the same weight in one bag For any set of items that have total weight less than or equal to there is a bag into which you can put this set Similarly a set of items can contain multiple items of the same weight Of all sets of the items weights that satisfy points 1 and 2 find the set with the minimum number of weights In other words value should be as small as possible Find and print the required set ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nstruct base{\n\tdouble a,b;\n\tbase(){}\n\tbase(double a,double b):a(a),b(b){}\n\tbase operator+(const base &x)const{\n\t\treturn base(a+x.a,b+x.b);\n\t}\n\tbase operator-(const base &x)const{\n\t\treturn base(a-x.a,b-x.b);\n\t}\n\tbase operator*(const base &x)const{\n\t\treturn base(a*x.a-b*x.b,a*x.b+b*x.a);\n\t}\n\tbase operator/(double d)const{\n\t\treturn base(a/d,b/d);\n\t}\n};\n\nconst int lim=1<<21;\nint src[lim + 100];\nbase ar[lim + 100];\n\nvoid fft (bool invert) {\n\tint n = lim;\n\t\n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (ar[i], ar[j]);\n\t}\n\t\n\tfor (int len=2; len<=n; len<<=1) {\n\t\tdouble ang = 2*PI/len * (invert ? -1 : 1);\n\t\tbase wlen (cos(ang), sin(ang));\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tbase w (1, 0);\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tbase u = ar[i+j],  v = ar[i+j+len/2] * w;\n\t\t\t\tar[i+j] = u + v;\n\t\t\t\tar[i+j+len/2] = u - v;\n\t\t\t\tw = w * wlen;\n\t\t\t}\n\t\t}\n\t}\n\tif (invert)\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tar[i] = ar[i] / n;\n}\n\nvoid square(){\n\tfft(false);\n\tforn(i,lim){\n\t\tar[i] = ar[i] * ar[i];\n\t}\n\tfft(true);\n}\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tint n,m;\n\tcin>>n>>m;\n\tforn(i,n){\n\t\tint a;\n\t\tscanf(""%d"",&a);\n\t\tsrc[a]=1;\n\t\tar[a].a=1;\n\t}\n\tforn(a,m+1){\n\t\tif(!src[a])\n\t\t\tcontinue;\n\t\tfor(int b=a+a;b<=m;b+=a){\n\t\t\tif(!src[b]){\n\t\t\t\tcout<<""NO"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tsquare();\n\tvector<int> res;\n\tforn(a,m+1){\n\t\t//cout<<ar[a].a<<\' \'<<ar[a].b<<endl;\n\t\tbool t=fabs(ar[a].a)>.5;\n\t\tif(t){\n\t\t\tif(!src[a]){\n\t\t\t\tcout<<""NO"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(src[a])\n\t\t\t\tres.pb(a);\n\t\t}\n\t}\n\t\n\tcout<<""YES\\n""<<sz(res)<<\'\\n\';\n\tforv(i,res){\n\t\tprintf(""%d "",res[i]);\n\t}\n\n\treturn 0;\n}\n']","['constructive algorithms', 'fft', 'math']",2800
https://codeforces.com//contest/1782/problem/H1,H1. Window Signals  easy version ,A house at the sea has h floors all of the same height The side of the house facing the sea has w windows at equal distances from each other on every floor Thus the windows are positioned in cells of a rectangular grid of size h times w In every window the light can be turned either on or off except for the given k at most 2 windows In these k windows the light can not be turned on because it is broken In the dark we can send a signal to a ship at sea using a configuration of lights turned on and off However the ship can not see the position of the lights with respect to the house Thus if one configuration of windows with lights on can be transformed into another using parallel translation these configurations are considered equal Note that only parallel translation is allowed but neither rotations nor flips are Moreover a configuration without any light at all is not considered valid Find how many different signals the ship can receive and print this number modulo 998 244 353 ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1607, mod = 998244353;\nint n, m, xn, xm, k, r[N], c[N], pw[N];\nbool vis[N][N];\nint msk[N];\nint ok[N];\nvi e[N];\ninline int getid(pair < int, int > o) {\n\treturn (o.first - 1) * xm + o.second;\n}\nvi T;\nbool use[N];\nvoid getlen(int u) {\n\tif(use[u]) return ;\n\tuse[u] = true;\n\tT.emplace_back(u);\n\tfor(auto v : e[u]) \n\t\tgetlen(v);\n}\nint dp[1 << 4];\nint ndp[1 << 4];\nvoid clear() {\n\tme(dp, 0);\n\tdp[0] = 1;\n}\nvoid push(vi msk, vi cnt) {\n\t\n\tme(ndp, 0);\n\tL(t, 0, sz(msk) - 1) {\n\t\tint v = msk[t];\n\t\tint c = cnt[t];\n\t\tL(i, 0, 15)\n\t\t\t(ndp[i | v] += (ll) c * dp[i] % mod) %= mod; \n\t}\n\tswap(dp, ndp);\n}\nint F[2][16], G[2][16];\nvoid Main() {\n\tcin >> n >> m >> k;\n\tpw[0] = 1;\n\tL(i, 1, n * m) pw[i] = (ll) pw[i - 1] * 2 % mod; \n\tL(i, 1, k) {\n\t\tcin >> r[i] >> c[i]; \n\t}\n\t\n\tint ns = 0;\n\tfor(xn = 1; xn <= n; ++xn) {\n\t\tfor(xm = 1; xm <= m; ++xm) {\n\t\t\tme(use, 0);\n\t\t\tL(i, 1, xn) \n\t\t\t\tL(j, 1, xm) \n\t\t\t\t\tvis[i][j] = true;\n\t\t\tL(i, 1, xn) {\n\t\t\t\tL(j, 1, xm) {\n\t\t\t\t\tint Msk = 0;\n\t\t\t\t\tif(i == 1) {\n\t\t\t\t\t\tMsk += 1;\n\t\t\t\t\t} \n\t\t\t\t\tif(i == xn) {\n\t\t\t\t\t\tMsk += 2;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == 1) {\n\t\t\t\t\t\tMsk += 4;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == xm) {\n\t\t\t\t\t\tMsk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tmsk[(i - 1) * xm + j] = Msk;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tclear();\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tpush(vi{0, msk[i]}, vi{1, 1});\n\t\t\t(ns += dp[15]) %= mod;\n\t\t\t\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tok[i] = true, e[i].clear();\n\t\t\tbool okay = false;\n\t\t\tL(lx, 1, n - xn + 1) if(!okay) {\n\t\t\t\tL(ly, 1, m - xm + 1) if(!okay) {\n\t\t\t\t\tint rx = lx + xn - 1;\n\t\t\t\t\tint ry = ly + xm - 1;\n\t\t\t\t\tvector < pair < int, int > > vc; \n\t\t\t\t\tL(i, 1, k) {\n\t\t\t\t\t\tif(lx <= r[i] && r[i] <= rx) {\n\t\t\t\t\t\t\tif(ly <= c[i] && c[i] <= ry) {\n\t\t\t\t\t\t\t\tvc.emplace_back(r[i] - lx + 1, c[i] - ly + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!sz(vc)) {\n\t\t\t\t\t\tokay = true;\n\t\t\t\t\t} else if(sz(vc) == 1) {\n\t\t\t\t\t\tok[getid(vc[0])] = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint u = getid(vc[0]);\n\t\t\t\t\t\tint v = getid(vc[1]);\n\t\t\t\t\t\te[u].emplace_back(v);\n\t\t\t\t\t\te[v].emplace_back(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(okay) continue;\n\t\t\t\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tif(sz(e[i]) > 2) {\n\t\t\t\t\tfor(auto v : e[i]) cout << v << \' \';\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\n\t\t\tclear();\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tif(!use[i]) {\n//\t\t\t\t\tif(sz(e[i]) == 1) {\n//\t\t\t\t\t\tpush(vi{0, msk[i]}, vi{ok[i], 1});\n//\t\t\t\t\t\tcontinue; \n//\t\t\t\t\t}\n\t\t\t\t\tT.clear();\n\t\t\t\t\tgetlen(i);\n\t\t\t\t\t\t\n\t\t\t\t\tme(F, 0);\n\t\t\t\t\tF[1][0] = 1;\n\t\t\t\t\tfor(auto u : T) {\n\t\t\t\t\t\tme(G, 0);\n\t\t\t\t\t\tL(x, 0, 1) {\n\t\t\t\t\t\t\tL(y, 0, 1) if(x || y) {\n\t\t\t\t\t\t\t\tif(!ok[u] && !y) continue;\n\t\t\t\t\t\t\t\tint t = msk[u];\n\t\t\t\t\t\t\t\tif(!y) t = 0;\n\t\t\t\t\t\t\t\tL(i, 0, 15) (G[y][i | t] += F[x][i]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(F, G);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvi A, B;\n\t\t\t\t\tL(i, 0, 15) {\n\t\t\t\t\t\tint s = (F[0][i] + F[1][i]) % mod; \n\t\t\t\t\t\tif(s) A.emplace_back(i), B.emplace_back(s);\n\t\t\t\t\t}\n\t\t\t\t\tpush(A, B);\n//\t\t\t\t\tcout << ok[i] << \' \' << msk[i] << \'\\n\';\n//\t\t\t\t\tL(i, 0, sz(A) - 1) cout << A[i] << "" : "" << B[i] << \'\\n\';\n//\t\t\t\t\tcout << \'\\n\';\n\t\t\t\t}\n\t\t\t(ns += mod - dp[15]) %= mod;\n\t\t}\n\t}\n\tcout << ns << \'\\n\';\n} \nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} \n/*\n1\n40 40 2\n10 11\n20 23\n\n1\n40 40 2\n10 11\n11 12\n*/']","['brute force', 'combinatorics', 'math']",3200
https://codeforces.com//contest/362/problem/A,A. Two Semiknights Meet,A boy Petya loves chess very much He even came up with a chess piece of his own a semiknight The semiknight can move in any of these four directions squares forward and squares to the right squares forward and squares to the left squares backward and to the right and squares backward and to the left Naturally the semiknight cannot move beyond the limits of the chessboard Petya put two semiknights on a standard chessboard Petya simultaneously moves with both semiknights The squares are rather large so after some move the semiknights can meet that is they can end up in the same square After the meeting the semiknights can move on so it is possible that they meet again Petya wonders if there is such sequence of moves when the semiknights meet Petya considers some squares bad That is they do not suit for the meeting The semiknights can move through these squares but their meetings in these squares don t count Petya prepared multiple chess boards Help Petya find out whether the semiknights can meet on some good square for each board Please see the test case analysis ,"['#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <sstream>\n#include <assert.h>\n#include <complex>\n\n#include <time.h>\n#pragma comment(linker, ""/STACK:20000000"")\n\n#define fr(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define fd(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nusing namespace std;\n\nint ri(){int x;scanf(""%d"",&x);return x;}\nll rll(){ll x;scanf(""%lld"",&x);return x;}\n\nint dx[] = {2,2,-2,-2};\nint dy[] = {2,-2,2,-2};\n\nint used[3][10][10];\n\nvoid solve()\n{\n\tint test = ri();\n\tfr(testin,1,test)\n\t{\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<string> mas;\n\t\tfr(i,0,7)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tmas.pb(s);\n\t\t}\n\t\tint cnt = 0;\n\t\tvector<pair<int,int> > omg;\n\t\tfr(i,0,7)\n\t\t{\n\t\t\tfr(j,0,7)\n\t\t\t\tif (mas[i][j] == \'K\')\n\t\t\t\t{\n\t\t\t\t\tomg.pb(mp(i,j));\n\t\t\t\t\t\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[cnt][i][j] = 1;\n\t\t\t\t\tqueue<pair<int,int> > st;\n\t\t\t\t\tst.push(mp(i,j));\n\t\t\t\t\twhile(!st.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint x = st.front().first;\n\t\t\t\t\t\tint y = st.front().second;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tfr(k,0,3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint xx = x + dx[k],yy = y + dy[k];\n\t\t\t\t\t\t\tif (xx >= 0 && xx < 8 && yy >= 0 && yy < 8 && !used[cnt][xx][yy])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tused[cnt][xx][yy] = used[cnt][x][y] + 1;\n\t\t\t\t\t\t\t\tst.push(mp(xx,yy));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t}\n\t\tbool yes = false;\n\t\tfr(i,0,7)\n\t\t\tfr(j,0,7)\n\t\t\tif (used[1][i][j] && used[2][i][j] && ((used[1][i][j] % 2) == (used[2][i][j]%2)) &&  mas[i][j] !=\'#\')\n\t\t\t\t{\n\t\t\t\t\tyes = true;\n\t\t\t\t}\n\t\t//int cnt = abs(omg[0].first - omg[1].first) + abs(omg[1].second - omg[0].second);\n\t\tif (yes)\n\t\t\tcout << ""YES"" << endl;\n\t\telse\n\t\t\tcout << ""NO"" << endl;\n\t}\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/input.txt"",""rt"",stdin);\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/output.txt"",""wt"",stdout);\n\t#else\n\t\t//freopen(""cubroot.in"",""rt"",stdin);\n\t\t//freopen(""cubroot.out"",""wt"",stdout);\n\t#endif\n\n\tsolve();\n\n\t#ifndef ONLINE_JUDGE\n\t\tprintf(""\\n\\ntime-%.3lf"",clock()*1e-3);\n\t#endif\n\n\treturn 0;\n}']","['greedy', 'math']",1500
https://codeforces.com//contest/864/problem/D,D. Make a Permutation ,Ivan has an array consisting of elements Each of the elements is an integer from to Recently Ivan learned about permutations and their lexicographical order Now he wants to change replace number of elements in his array in such a way that his array becomes a i e each of the integers from to was encountered in his array exactly once If there are multiple ways to do it he wants to find the permutation among them Thus minimizing the number of changes has the first priority lexicographical minimizing has the second priority In order to determine which of the two permutations is lexicographically smaller we compare their first elements If they are equal compare the second and so on If we have two permutations and then is lexicographically smaller if where is the first index in which the permutations and differ Determine the array Ivan will obtain after performing all the changes ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint n;\nint a[200010];\nint b[200010];\nint c[200010];\nint d[200010];\nint e[200010];\nint ans[200010];\nint main()\n{\n\tmemset(c,0,sizeof c);\n\tmemset(e,0,sizeof e);\n\tscanf(""%d"",&n);\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d"",&a[i]);\n\t\tb[i]=a[i];\n\t\tc[a[i]]++;\n\t}\n\tsort(b+1,b+n+1);\n\tint m=unique(b+1,b+n+1)-b-1;\n\tprintf(""%d\\n"",n-m);\n\tint j=1;\n\tint k=0;\n\tfor(i=1;i<=n;i++)\n\t\tif(!c[i])\n\t\t\td[++k]=i;\n\tfor(i=1;i<=n;i++)\n\t\tif(!e[a[i]])\n\t\t{\n\t\t\tif(c[a[i]]==1)\n\t\t\t{\n\t\t\t\tc[a[i]]--;\n\t\t\t\te[a[i]]=1;\n\t\t\t\tans[i]=a[i];\n\t\t\t}\n\t\t\telse if(d[j]<a[i])\n\t\t\t{\n\t\t\t\tans[i]=d[j++];\n\t\t\t\tc[a[i]]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\te[a[i]]=1;\n\t\t\t\tans[i]=a[i];\n\t\t\t\tc[a[i]]--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i]=d[j++];\n\t\t\tc[a[i]]--;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tprintf(""%d "",ans[i]);\n\treturn 0;\n}']","['greedy', 'implementation', 'math']",1500
https://codeforces.com//contest/1854/problem/D,D. Michael and Hotel,Michael and Brian are stuck in a hotel with n rooms numbered from 1 to n and need to find each other But this hotel s doors are all locked and the only way of getting around is by using the teleporters in each room Room i has a teleporter that will take you to room a i it might be that a i i But they don t know the values of a 1 a 2 dots a n Instead they can call up the front desk to ask queries In one query they give a room u a positive integer k and a set of rooms S The hotel concierge answers whether a person starting in room u and using the teleporters k times ends up in a room in S Brian is in room 1 Michael wants to know the set A of rooms so that if he starts in one of those rooms they can use the teleporters to meet up He can ask at most 2000 queries The values a 1 a 2 dots a n are fixed before the start of the interaction and do not depend on your queries In other words the interactor is not adaptive ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\n\nint n;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint jeszcze=2000;\n\nint pyt(int v, int k, vi wek)\n{\n\tjeszcze--;\n\tif (jeszcze<0)\n\t\twhile(1);\n\tprintf(""? %d %d %d"", v, k, (int)wek.size());\n\tfor (int i : wek)\n\t\tprintf("" %d"", i);\n\tprintf(""\\n"");\n\tff();\n\tint ret;\n\tscanf(""%d"", &ret);\n\treturn ret;\n}\n\nvoid ans(vi wek)\n{\n\tprintf(""! %d"", (int)wek.size());\n\tfor (int i : wek)\n\t\tprintf("" %d"", i);\n\tprintf(""\\n"");\n\tff();\n\texit(0);\n}\n\nvi przedzial(int a, int b)\n{\n\tvi ret;\n\tfor (int i=a; i<=b; i++)\n\t\tret.push_back(i);\n\treturn ret;\n}\n\nint dobre[nax];\n\nvi daj_dobre()\n{\n\tvi ret;\n\tfor (int i=1; i<=n; i++)\n\t\tif (dobre[i])\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tint bsa=1;\n\tint bsb=n;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb)/2;\n\t\tvi tu=przedzial(bsa, bss);\n\t\tif (pyt(1, n, tu))\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\tint c=bsa;\n\tdobre[c]=1;\n\tint u=c;\n\tint urwane=0;\n\tfor (int h=1; h<=130; h++)\n\t{\n\t\tbsa=1;\n\t\tbsb=n;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb)/2;\n\t\t\tvi tu=przedzial(bsa, bss);\n\t\t\tif (pyt(u, 1, tu))\n\t\t\t\tbsb=bss;\n\t\t\telse\n\t\t\t\tbsa=bss+1;\n\t\t}\n\t\tdobre[bsa]=1;\n\t\tu=bsa;\n\t\t//~ debug() << imie(u);\n\t\tif (u==c)\n\t\t{\n\t\t\turwane=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tif (!dobre[i] && pyt(i, 128, daj_dobre()))\n\t\t\tdobre[i]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!dobre[i] && pyt(i, urwane ? n : 253, daj_dobre()))\n\t\t\tdobre[i]=1;\n\tans(daj_dobre());\n\treturn 0;\n}\n']","['binary search', 'interactive', 'trees']",3000
https://codeforces.com//contest/1260/problem/D,D. A Game with Traps,You are playing a computer game where you lead a party of m soldiers Each soldier is characterised by his agility a i The level you are trying to get through can be represented as a straight line segment from point 0 where you and your squad is initially located to point n 1 where the boss is located The level is filled with k traps Each trap is represented by three numbers l i r i and d i l i is the location of the trap and d i is the danger level of the trap whenever a soldier with agility lower than d i steps on a trap that is moves to the point l i he gets instantly killed Fortunately you can disarm traps if you move to the point r i you disarm this trap and it no longer poses any danger to your soldiers Traps don t affect you only your soldiers You have t seconds to complete the level that is to bring some soldiers from your squad to the boss Before the level starts you choose which soldiers will be coming with you and which soldiers won t be After that you have to bring to the boss To do so you may perform the following actions if your location is x you may move to x 1 or x 1 This action consumes one second if your location is x and the location of your squad is x you may move to x 1 or to x 1 with your squad in one second You may not perform this action if it puts some soldier in danger i e the point your squad is moving into contains a non disarmed trap with d i greater than agility of some soldier from the squad This action consumes one second if your location is x and there is a trap i with r i x you may disarm this trap This action is done instantly it consumes no time Note that after each action both your coordinate and the coordinate of your squad should be integers You have to choose the maximum number of soldiers such that they all can be brought from the point 0 to the point n 1 where the boss waits in no more than t seconds ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint m, n, k, t;\nint A[200005];\nint L[200005];\nint R[200005];\nint D[200005];\n\nint ok(int x) {\n    int a = A[m - x];\n    vector<pii> P;\n    for (int i = 1; i <= k; i++) {\n        if (D[i] <= a) continue;\n        P.emplace_back(L[i], R[i]);\n    }\n    sort(P.begin(), P.end());\n    int sum = 0, ed = 0;\n    for (auto i : P) {\n        if (i.second <= ed) continue;\n        if (ed < i.first) ed = i.first - 1;\n        sum += i.second - ed;\n        ed = i.second;\n    }\n    ll need = (n + 1) + sum * 2ll;\n    return need <= t;\n}\n\nint main() {\n    scanf(""%d %d %d %d"", &m, &n, &k, &t);\n    for (int i = 0; i < m; i++) scanf(""%d"", &A[i]);\n    for (int i = 1; i <= k; i++) {\n        scanf(""%d %d %d"", &L[i], &R[i], &D[i]);\n    }\n    sort(A, A + m);\n    int st = 0, ed = m;\n    while (st < ed) {\n        int md = st + ed + 1 >> 1;\n        if (ok(md)) st = md;\n        else ed = md - 1;\n    }\n    printf(""%d\\n"", st);\n}']","['binary search', 'dp', 'greedy', 'sortings']",1900
https://codeforces.com//contest/1092/problem/A,A. Uniform String,You are given two integers n and k Your task is to construct such a string s of length n that for each i from 1 to k there is at least one i th letter of the Latin alphabet in this string the first letter is a the second is b and so on and there are no other letters except these You have to of some letter the frequency of a letter is the number of occurrences of this letter in a string If there are several possible answers you can print You have to answer t queries ,"['#include<cstdio>\nint main(){\n    int T;\n    scanf(""%d"",&T);\n    while(T--){\n        int n,k;\n        scanf(""%d%d"",&n,&k);\n        for(int i=0;i<n;i++){\n            printf(""%c"",\'a\'+(i%k));\n        }\n        puts("""");\n    }\n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/698/problem/A,A. Vacations,Vasya has days of vacations So he decided to improve his IT skills and do sport Vasya knows the following information about each of this days whether that gym opened and whether a contest was carried out in the Internet on that day For the th day there are four options on this day the gym is closed and the contest is not carried out on this day the gym is closed and the contest is carried out on this day the gym is open and the contest is not carried out on this day the gym is open and the contest is carried out On each of days Vasya can either have a rest or write the contest if it is carried out on this day or do sport if the gym is open on this day Find the minimum number of days on which Vasya will have a rest it means he will not do sport and write the contest at the same time The only limitation that Vasya has ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,v[1010],dp[1010][4];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",v+i);\n\trep(i,1,n+1) {\n\t\tdp[i][0]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+1;\n\t\tif (v[i]==1||v[i]==3) dp[i][1]=min(dp[i-1][0],dp[i-1][2]);\n\t\telse dp[i][1]=1<<30;\n\t\tif (v[i]==2||v[i]==3) dp[i][2]=min(dp[i-1][0],dp[i-1][1]);\n\t\telse dp[i][2]=1<<30;\n\t}\n\tprintf(""%d\\n"",min(dp[n][0],min(dp[n][1],dp[n][2])));\n}\n']",['dp'],1400
https://codeforces.com//contest/1354/problem/G,G. Find a Gift,There are n gift boxes in a row numbered from 1 to n from left to right It s known that exactly k of them contain valuable gifts other boxes contain just lucky stones All boxes look the same and differ only in weight All than boxes with valuable items But valuable gifts may be different so the boxes with valuable items may have different weights You can ask no more than 50 queries printing an answer doesn t count By each query you can compare total weights of two non intersecting subsets of boxes a 1 a 2 dots a k a and b 1 b 2 dots b k b In return you ll get one of four results if subset a 1 a 2 dots a k a is strictly if subset b 1 b 2 dots b k b is strictly if subsets have equal total weights if the query is incorrect or the limit of queries is exceeded Using such queries or maybe intuition find the box with a valuable gift with ,"['#include <random>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(2005171937);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> choose(int N, int K) {\n\tvector<bool> used(N, false);\n\tvector<int> seq;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint p = -1;\n\t\twhile (p == -1 || used[p]) {\n\t\t\tp = rand_rng(0, N);\n\t\t}\n\t\tused[p] = true;\n\t\tseq.push_back(p);\n\t}\n\tsort(seq.begin(), seq.end());\n\treturn seq;\n}\nbool debug = false;\nvector<int> hidden;\nint min_index;\nvoid gen_array(int N, int K) {\n\tvector<int> g = choose(N, K);\n\thidden.resize(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (binary_search(g.begin(), g.end(), i)) {\n\t\t\thidden[i] = rand_rng(1, 100);\n\t\t}\n\t\telse {\n\t\t\thidden[i] = 100;\n\t\t}\n\t}\n\tmin_index = g[0];\n}\nstring ask(vector<int> a, vector<int> b) {\n\tcout << ""? "" << a.size() << \' \' << b.size() << endl;\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tif (i) cout << \' \';\n\t\tcout << a[i] + 1;\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < b.size(); ++i) {\n\t\tif (i) cout << \' \';\n\t\tcout << b[i] + 1;\n\t}\n\tcout << endl;\n\tstring res;\n\tif (!debug) {\n\t\tcin >> res;\n\t}\n\telse {\n\t\tint sa = 0, sb = 0;\n\t\tfor (int i : a) sa += hidden[i];\n\t\tfor (int i : b) sb += hidden[i];\n\t\tif (sa > sb) res = ""FIRST"";\n\t\tif (sa < sb) res = ""SECOND"";\n\t\tif (sa == sb) res = ""EQUAL"";\n\t}\n\treturn res;\n}\nvoid answer(int x) {\n\tcout << ""! "" << x + 1 << endl;\n\tif (debug) {\n\t\tassert(x == min_index);\n\t}\n}\nint main() {\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint N, K;\n\t\tif (!debug) {\n\t\t\tcin >> N >> K;\n\t\t}\n\t\telse {\n\t\t\tN = 4, K = 1;\n\t\t\tgen_array(N, K);\n\t\t}\n\t\tif (N <= 4) {\n\t\t\tint curmax = 0;\n\t\t\tfor (int i = 1; i < N; ++i) {\n\t\t\t\tstring res = ask({ curmax }, { i });\n\t\t\t\tif (res == ""SECOND"") curmax = i;\n\t\t\t}\n\t\t\tint ans = -1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i != curmax) {\n\t\t\t\t\tstring res = ask({ curmax }, { i });\n\t\t\t\t\tif (res == ""FIRST"") {\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer(ans);\n\t\t}\n\t\telse {\n\t\t\t// step #1. find one stone (fail probability <= (1/2)^threshold)\n\t\t\tconst int threshold = 23;\n\t\t\tvector<int> g = choose(N - 2, min(N - 2, threshold));\n\t\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\t\tg[i] += 2;\n\t\t\t}\n\t\t\tint stone = g[0];\n\t\t\tfor (int i = 1; i < g.size(); ++i) {\n\t\t\t\tstring res = ask({ stone }, { g[i] });\n\t\t\t\tif (res == ""SECOND"") {\n\t\t\t\t\tstone = g[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring resp0 = ask({ stone }, { 0 });\n\t\t\tstring resp1 = ask({ stone }, { 1 });\n\t\t\tif (resp0 == ""FIRST"") {\n\t\t\t\tanswer(0);\n\t\t\t}\n\t\t\telse if (resp1 == ""FIRST"") {\n\t\t\t\tanswer(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = 2;\n\t\t\t\twhile (t * 2 <= N) {\n\t\t\t\t\tvector<int> lc(t), rc(t);\n\t\t\t\t\tfor (int i = 0; i < t; ++i) {\n\t\t\t\t\t\tlc[i] = i;\n\t\t\t\t\t\trc[i] = i + t;\n\t\t\t\t\t}\n\t\t\t\t\tstring res = ask(lc, rc);\n\t\t\t\t\tif (res != ""EQUAL"") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt *= 2;\n\t\t\t\t}\n\t\t\t\tint lp = t, rp = min(2 * t, N);\n\t\t\t\twhile (rp - lp > 1) {\n\t\t\t\t\tint m = (lp + rp) >> 1;\n\t\t\t\t\tvector<int> lc(m - t), rc(m - t);\n\t\t\t\t\tfor (int i = 0; i < m - t; ++i) {\n\t\t\t\t\t\tlc[i] = i;\n\t\t\t\t\t\trc[i] = i + t;\n\t\t\t\t\t}\n\t\t\t\t\tstring res = ask(lc, rc);\n\t\t\t\t\tif (res != ""EQUAL"") {\n\t\t\t\t\t\trp = m;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlp = m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tanswer(lp);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']","['binary search', 'interactive', 'probabilities']",2600
https://codeforces.com//contest/1428/problem/G1,G1. Lucky Numbers  Easy Version ,Zookeeper has been teaching his q sheep how to write and how to add The i th sheep has to write exactly k with the sum n i Strangely sheep have superstitions about digits and believe that the digits 3 6 and 9 are lucky To them the fortune of a number depends on the decimal representation of the number the fortune of a number is equal to the sum of fortunes of its digits and the fortune of a digit depends on its value and position and can be described by the following table For example the number 319 has fortune F 2 3F 0 Each sheep wants to maximize the among all its k written integers Can you help them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int vax=9;\nconst ll inf=1e18;\nconst int d=6;\nconst int m=1000*1000;\n\nint k;\nll fort[vax];\n\nll dp[vax][nax];\n\nll pom[nax];\n\ndeque<int> kol[3];\n\nint przej(int v)\n{\n\tif (v<=(k-1)*9)\n\t\treturn (v/3);\n\tif (v%3)\n\t\treturn (k-1)*3;\n\treturn v/3;\n}\n\nvoid przejscia(int v)\n{\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tif (!(i%10))\n\t\t\tpom[i]=dp[v+1][i/10];\n\t\telse\n\t\t\tpom[i]=-inf;\n\t}\n\t//~ for (int i=0; i<m; i++)\n\t//~ {\n\t\t//~ dp[v][i]=-inf;\n\t\t//~ for (int j=i-k*9; j<=i; j++)\n\t\t\t//~ if (j>=0)\n\t\t\t\t//~ dp[v][i]=max(dp[v][i], pom[j]+przej(i-j)*fort[v]);\n\t//~ }\n\t//~ debug() << v << "" "" << range(dp[v], dp[v]+60) << "" "" << imie(pom[30]) << imie(przej(27));\n\tfor (int i=0; i<3; i++)\n\t\tkol[i].clear();\n\tll f=fort[v];\n\tconst int lim=(k-1)*9;\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tint p=i%3;\n\t\tif (!kol[p].empty() && kol[p].front()<i-lim)\n\t\t\tkol[p].pop_front();\n\t\twhile(!kol[p].empty() && pom[i]-(i/3)*f>=pom[kol[p].back()]-(kol[p].back()/3)*f)\n\t\t\tkol[p].pop_back();\n\t\tkol[p].push_back(i);\n\t\tdp[v][i]=-inf;\n\t\tfor (int j=0; j<3; j++)\n\t\t\tif (!kol[j].empty())\n\t\t\t\tdp[v][i]=max(dp[v][i], pom[kol[j].front()]+przej(i-kol[j].front())*f);\n\t\tfor (int j=i-k*9; j<=i-lim; j++)\n\t\t\tif (j>=0)\n\t\t\t\tdp[v][i]=max(dp[v][i], pom[j]+przej(i-j)*f);\n\t}\n}\n\nint main()\n{\n\tscanf(""%d"", &k);\n\tfor (int i=0; i<d; i++)\n\t\tscanf(""%lld"", &fort[i]);\n\tif (k>1)\n\t{\n\t\tfor (int i=0; i<=d; i++)\n\t\t\tfor (int j=0; j<m; j++)\n\t\t\t\tdp[i][j]=-inf;\n\t\tdp[d][0]=0;\n\t\tfor (int h=d-1; h>=0; h--)\n\t\t\tprzejscia(h);\n\t}\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tif (k==1)\n\t\t{\n\t\t\tll w=0;\n\t\t\tfor (int i=0; i<d; i++)\n\t\t\t{\n\t\t\t\tint p=x%10;\n\t\t\t\tx/=10;\n\t\t\t\tif (!(p%3))\n\t\t\t\t\tw+=fort[i]*(p/3);\n\t\t\t}\n\t\t\tprintf(""%lld\\n"", w);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(""%lld\\n"", dp[0][x]);\n\t\t}\n\t}\n\treturn 0;\n}\n']","['dp', 'greedy']",2900
https://codeforces.com//contest/1679/problem/C,C. Rooks Defenders,You have a square chessboard of size n times n Rows are numbered from top to bottom with numbers from 1 to n and columns from left to right with numbers from 1 to n So each cell is denoted with pair of integers x y 1 le x y le n where x is a row number and y is a column number You have to perform q queries of three types Put a new rook in cell x y Remove a rook from cell x y It s guaranteed that the rook was put in this cell before Check if each cell of x 1 y 1 x 2 y 2 of the board is attacked by at least one rook is a set of cells x y such that for each cell two conditions are satisfied x 1 le x le x 2 and y 1 le y le y 2 Recall that cell a b is attacked by a rook placed in cell c d if either a c or b d In particular the cell containing a rook is attacked by this rook ,"['#include<algorithm>\n#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#define lc(x) (x<<1)\n#define rc(x) (x<<1|1)\n#define mid (l+r>>1)\nusing namespace std;\nconst int maxn=500005,maxt=maxn<<2;\nint n,m,T,ans;\nint t[maxn][2],mn[maxt][2];\nvoid update(int l,int r,int now,int p,int v,int tp){\n\tif(l==r){\n\t\tmn[now][tp]+=v;\n\t\treturn ;\n\t}\n\tif(p<=mid)\n\t\tupdate(l,mid,lc(now),p,v,tp);\n\telse update(mid+1,r,rc(now),p,v,tp);\n\tmn[now][tp]=min(mn[lc(now)][tp],mn[rc(now)][tp]);\n}\nint query(int l,int r,int now,int L,int R,int tp){\n\tif(L<=l&&r<=R)\n\t\treturn mn[now][tp];\n\tint res=2;\n\tif(L<=mid)\n\t\tres=min(res,query(l,mid,lc(now),L,R,tp));\n\tif(mid<R)\n\t\tres=min(res,query(mid+1,r,rc(now),L,R,tp));\n\treturn res;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\twhile(m--){\n\t\tint t,x,y,a,b;\n\t\tscanf(""%d%d%d"",&t,&x,&y);\n\t\tif(t==1)\n\t\t\tupdate(1,n,1,x,1,0),update(1,n,1,y,1,1);\n\t\tif(t==2)\n\t\t\tupdate(1,n,1,x,-1,0),update(1,n,1,y,-1,1);\n\t\tif(t==3){\n\t\t\tscanf(""%d%d"",&a,&b);\n\t\t\tif(query(1,n,1,x,a,0)||query(1,n,1,y,b,1))\n\t\t\t\tputs(""Yes"");\n\t\t\telse puts(""No"");\n\t\t}\n\t}\n\treturn 0;\n}\n']","['data structures', 'implementation']",1400
https://codeforces.com//contest/630/problem/D,D. Hexagons ,After a probationary period in the game development company of IT City Petya was included in a group of the programmers that develops a new turn based strategy game resembling the well known Heroes of Might Magic A part of the game is turn based fights of big squadrons of enemies on infinite fields where every cell is in form of a hexagon Some of magic effects are able to affect several field cells at once cells that are situated not farther than cells away from the cell in which the effect was applied The distance between cells is the minimum number of cell border crosses on a path from one cell to another It is easy to see that the number of cells affected by a magic effect grows rapidly when increases so it can adversely affect the game performance That s why Petya decided to write a program that can given determine the number of cells that should be repainted after effect application so that game designers can balance scale of the effects and the game performance Help him to do it Find the number of hexagons situated not farther than cells away from a given cell ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    ll n, t;\n\n    cin >> n;\n    cout << n * (n + 1) * 3 + 1;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']",['math'],1100
https://codeforces.com//contest/1499/problem/G,G. Graph Coloring,You are given a bipartite graph consisting of n 1 vertices in the first part n 2 vertices in the second part and m edges numbered from 1 to m You have to color each edge into one of two colors red and blue You have to minimize the following value sum limits v in V r v b v where V is the set of vertices of the graph r v is the number of red edges incident to v and b v is the number of blue edges incident to v Sounds classical and easy right Well you have to process q queries of the following format 1 v 1 v 2 add a new edge connecting the vertex v 1 of the first part with the vertex v 2 of the second part This edge gets a new index as follows the first added edge gets the index m 1 the second m 2 and so on After adding the edge you have to print the of the current optimal coloring if there are multiple optimal colorings print the of any of them 2 print the optimal coloring of the graph with the same you printed while processing the previous query The query of this type will only be asked after a query of type 1 and there will be at most 10 queries of this type If there are multiple optimal colorings corresponding to this print any of them Note that if an edge was red or blue in some coloring it may change its color in next colorings The of the coloring is calculated as follows let R be the set of indices of red edges then the is sum limits i in R 2 i bmod 998244353 Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,"['#line 1 ""a.cpp""\n#include<cstdio>\n#include<vector>\nusing namespace std;\n#line 2 ""/home/kotatsugame/library/tool/FastIO.cpp""\n#include<cctype>\n#include<string>\nconst int buffer_size=1<<20;\n//input\nint rd_char()\n{\n\tstatic char buf[buffer_size];\n\tstatic int l=buffer_size,r=buffer_size;\n\tif(l==r&&r==buffer_size)\n\t{\n\t\tr=fread(buf,sizeof(char),1<<20,stdin);\n\t\tl=0;\n\t}\n\tif(l==r)return EOF;\n\treturn buf[l++];\n}\nunsigned int rd_uint()\n{\n\tint c;\n\tunsigned int x=0;\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn x;\n}\nint rd_int()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c==\'-\')neg=true;\n\telse x=c-\'0\';\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn neg?-x:x;\n}\nunsigned long long rd_ull()\n{\n\tint c;\n\tunsigned long long x=0;\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn x;\n}\nlong long rd_ll()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c==\'-\')neg=true;\n\telse x=c-\'0\';\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn neg?-x:x;\n}\nstring rd_str()\n{\n\tstring ret;\n\tint c;\n\twhile((c=rd_char())!=\'\\n\'&&c!=\' \'&&c!=EOF)ret+=c;\n\treturn ret;\n}\n//output\nstruct writer_struct{\n\tchar buf[buffer_size];\n\tint l=0;\n\t~writer_struct(){fwrite(buf,sizeof(char),l,stdout);}\n}writer;\nvoid flush()\n{\n\tfwrite(writer.buf,sizeof(char),writer.l,stdout);\n\twriter.l=0;\n}\nvoid wt(char c)\n{\n\tif(writer.l==buffer_size)\n\t{\n\t\tfwrite(writer.buf,sizeof(char),buffer_size,stdout);\n\t\twriter.l=0;\n\t}\n\twriter.buf[writer.l++]=c;\n}\nvoid wt(unsigned int x)\n{\n\tif(x==0)wt(\'0\');\n\telse\n\t{\n\t\tchar f[10];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+\'0\';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(int x)\n{\n\tif(x<0)wt(\'-\'),x=-x;\n\twt((unsigned int)x);\n}\nvoid wt(unsigned long long x)\n{\n\tif(x==0)wt(\'0\');\n\telse\n\t{\n\t\tchar f[20];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+\'0\';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(long long x)\n{\n\tif(x<0)wt(\'-\'),x=-x;\n\twt((unsigned long long)x);\n}\nvoid wt(const char*s){while(*s!=\'\\0\')wt(*s++);}\nvoid wt(const string&s){for(char c:s)wt(c);}\n#line 5 ""a.cpp""\nconst long long mod=998244353;\nint N1,N2,M;\nint pr[4<<17],hs[4<<17],hn[4<<17],pe[4<<17],pc[4<<17];\nint ai[4<<17][2];\nint ans,eh=1,id;\nvector<int>es;\nbool usd[4<<17];\nvoid adj(int ei,vector<int>&a,int j)\n{\n\tint pei=-1;\n\tint cnt=0;\n\twhile(ei!=-1)\n\t{\n\t\tusd[ei]=true;\n\t\tif(cnt==j)a.push_back(ei);\n\t\tint tei=ei;\n\t\tif(pei==ai[ei][0])ei=ai[ei][1];\n\t\telse ei=ai[ei][0];\n\t\tpei=tei;\n\t\tcnt=1-cnt;\n\t}\n}\nvoid add(int ei,int ni)\n{\n\tif(ai[ei][0]==-1)ai[ei][0]=ni;\n\telse ai[ei][1]=ni;\n}\nvoid add_edge(int u,int v)\n{\n\tid++;\n\tai[id][0]=ai[id][1]=-1;\n\tv+=N1;\n\teh=eh*2%mod;\n\tif(pr[u]!=-1)\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tif(pr[v]==u&&pr[u]==v)\n\t\t\t{\n\t\t\t\tif(pc[u]==0)\n\t\t\t\t{\n\t\t\t\t\tadj(pe[u],es,0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tes.push_back(id);\n\t\t\t\t\tadj(pe[u],es,1);\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(pc[u]!=pc[v])\n\t\t\t\t{\n\t\t\t\t\tint rv=pr[v];\n\t\t\t\t\tpc[v]=1-pc[v];\n\t\t\t\t\tpc[rv]=1-pc[rv];\n\t\t\t\t\tans=(ans+mod-hn[v])%mod;\n\t\t\t\t\thn[v]=hn[rv]=(hs[v]-hn[v]+mod)%mod;\n\t\t\t\t\tans=(ans+hn[v])%mod;\n\t\t\t\t}\n\t\t\t\tint ru=pr[u],rv=pr[v];\n\t\t\t\tpr[ru]=rv;pr[rv]=ru;\n\t\t\t\ths[ru]=hs[rv]=((hs[ru]+hs[rv])%mod+eh)%mod;\n\t\t\t\thn[ru]=hn[rv]=(hn[ru]+hn[rv])%mod;\n\t\t\t\tif(pc[u]==1)\n\t\t\t\t{\n\t\t\t\t\thn[ru]=hn[rv]=(hn[ru]+eh)%mod;\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t\tadd(pe[u],id);\n\t\t\t\tadd(id,pe[u]);\n\t\t\t\tadd(pe[v],id);\n\t\t\t\tadd(id,pe[v]);\n\t\t\t}\n\t\t\tpr[u]=pr[v]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ru=pr[u];\n\t\t\tpr[ru]=v;\n\t\t\ths[ru]=(hs[ru]+eh)%mod;\n\t\t\tif(pc[u]==1)\n\t\t\t{\n\t\t\t\thn[ru]=(hn[ru]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[u]=-1;\n\t\t\tpr[v]=ru;\n\t\t\ths[v]=hs[ru];\n\t\t\thn[v]=hn[ru];\n\t\t\tpe[v]=id;\n\t\t\tpc[v]=1-pc[u];\n\t\t\tadd(pe[u],id);\n\t\t\tadd(id,pe[u]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tint rv=pr[v];\n\t\t\tpr[rv]=u;\n\t\t\ths[rv]=(hs[rv]+eh)%mod;\n\t\t\tif(pc[v]==1)\n\t\t\t{\n\t\t\t\thn[rv]=(hn[rv]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[v]=-1;\n\t\t\tpr[u]=rv;\n\t\t\ths[u]=hs[rv];\n\t\t\thn[u]=hn[rv];\n\t\t\tpe[u]=id;\n\t\t\tpc[u]=1-pc[v];\n\t\t\tadd(pe[v],id);\n\t\t\tadd(id,pe[v]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpr[u]=v;\n\t\t\tpr[v]=u;\n\t\t\ths[u]=hs[v]=eh;\n\t\t\thn[u]=hn[v]=eh;\n\t\t\tpe[u]=pe[v]=id;\n\t\t\tpc[u]=pc[v]=0;\n\t\t\tans=(ans+eh)%mod;\n\t\t}\n\t}\n}\nmain()\n{\n\tscanf(""%d%d%d"",&N1,&N2,&M);\n\tfor(int i=0;i<N1+N2;i++)pr[i]=-1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;scanf(""%d%d"",&u,&v);\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\tint Q;\n\tscanf(""%d"",&Q);\n\tfor(int ccc=0;ccc<Q;ccc++)\n\t{\n\t\tint t;scanf(""%d"",&t);\n\t\tif(t==1)\n\t\t{\n\t\t\tint u,v;scanf(""%d%d"",&u,&v);\n\t\t\tu--,v--;\n\t\t\tadd_edge(u,v);\n\t\t\twt(ans);\n\t\t\twt(\'\\n\');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<int>ret=es;\n\t\t\tfor(int i=0;i<=id;i++)usd[i]=false;\n\t\t\tfor(int i=0;i<N1+N2;i++)if(pr[i]!=-1&&!usd[pe[i]])\n\t\t\t{\n\t\t\t\tadj(pe[i],ret,pc[i]);\n\t\t\t}\n\t\t\twt((unsigned int)ret.size());\n\t\t\tfor(int id:ret)wt(\' \'),wt(id);\n\t\t\twt(\'\\n\');\n\t\t}\n\t\tflush();\n\t\tfflush(stdout);\n\t}\n}\n']","['data structures', 'graphs', 'interactive']",3100
https://codeforces.com//contest/1842/problem/D,D. Tenzing and His Animal Friends ,Tenzing has n animal friends He numbers them from 1 to n One day Tenzing wants to play with his animal friends To do so Tenzing will host several games In one game he will choose a set S which is a subset of 1 2 3 n and choose an integer t Then he will play the game with the animals in S for t minutes But there are some restrictions Tenzing loves friend 1 very much so 1 must be an element of S Tenzing doesn t like friend n so n must not be an element of S There are m additional restrictions The i th special restriction is described by integers u i v i and y i suppose x is the time that one of u i and v i is playing with Tenzing Tenzing must ensure that x is less or equal to y i Otherwise there will be unhappiness Tenzing wants to know the maximum total time that he can play with his animal friends Please find out the maximum total time that Tenzing can play with his animal friends and a way to organize the games that achieves this maximum total time or report that he can play with his animal friends for an infinite amount of time Also Tenzing does not want to host so many games so he will host at most n 2 games ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:31:38       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  const long long inf = (long long) 1e18;\n  vector<vector<long long>> g(n, vector<long long>(n, inf));\n  for (int i = 0; i < n; i++) {\n    g[i][i] = 0;\n  }\n  dsu d(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    d.unite(x, y);\n    g[x][y] = z;\n    g[y][x] = z;\n  }\n  if (d.get(0) != d.get(n - 1)) {\n    cout << ""inf"" << \'\\n\';\n    return 0;\n  }\n  vector<pair<string, long long>> res;\n  long long ans = 0;\n  while (true) {\n    string s(n, \'0\');\n    s[0] = \'1\';\n    vector<int> que(1, 0);\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int to = 0; to < n; to++) {\n        if (s[to] == \'0\' && g[que[b]][to] == 0) {\n          que.push_back(to);\n          s[to] = \'1\';\n        }\n      }\n    }\n    if (s[n - 1] == \'1\') {\n      break;\n    }\n    long long T = inf;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == \'1\') {\n        for (int j = 0; j < n; j++) {\n          if (s[j] == \'0\') {\n            T = min(T, g[i][j]);\n          }\n        }\n      }\n    }\n    ans += T;\n    res.emplace_back(s, T);\n    for (int i = 0; i < n; i++) {\n      if (s[i] == \'1\') {\n        for (int j = 0; j < n; j++) {\n          if (s[j] == \'0\') {\n            g[i][j] -= T;\n            g[j][i] -= T;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << "" "" << res.size() << \'\\n\';\n  for (auto& p : res) {\n    cout << p.first << "" "" << p.second << \'\\n\';\n  }\n  return 0;\n}\n']","['constructive algorithms', 'graphs', 'greedy']",1900
https://codeforces.com//contest/165/problem/D,D. Beard Graph,Let s define a non oriented connected graph of vertices and edges as a if all of its vertices except perhaps one have the degree of 2 or 1 that is there exists no more than one vertex whose degree is more than two Let us remind you that the degree of a vertex is the number of edges that connect to it Let each edge be either black or white Initially all edges are black You are given the description of the beard graph Your task is to analyze requests of the following types paint the edge number black The edge number is the edge that has this number in the description It is guaranteed that by the moment of this request the th edge is white paint the edge number white It is guaranteed that by the moment of this request the th edge is black find the length of the shortest path going between vertices and or indicate that no such path exists between them a path s length is the number of edges in it The vertices are numbered with integers from to and the edges are numbered with integers from to ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\n\n#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n\n#define maxn 110000\n\n\nstruct Node{\n\tbool all;\n\t//\n\tint l,r;\n\tNode *ls,*rs; //���Ҷ���\n\tvoid init(int _l,int _r){\n\t\tl=_l,r=_r; ls=rs=NULL; all=true;\n\t}\n\tint mid(){ return (l+r)>>1; }\n\tint len(){ return (r-l+1); }\n\t\n\tvoid update(){ //��֤�ж���\n\t\tif( ls->all && rs->all ) all=true;\n\t\telse all=false;\n\t}\n\tvoid modify(int id){\n\t\tif( l==r){\n\t\t\tall=!all;\n\t\t\treturn;\n\t\t}\n\t\tif( id<=mid() ) ls->modify(id);\n\t\telse rs->modify(id);\n\t\t\n\t\tupdate();\n\t}\n\tbool query(int a,int b){\n\t\tif( l==a && r==b ) return all;\n\t\t\n\t\tif( b<=mid() ) return ls->query(a,b);\n\t\telse if( a>mid() ) return rs->query(a,b);\n\t\telse {\n\t\t\treturn ls->query(a,mid()) && rs->query(mid()+1,b);\n\t\t}\n\t}\n}dd[maxn*10];\n\nint e; \nNode* _alloc(int l,int r) { dd[e].init(l,r); return &dd[e++]; }\nNode* _make(int l,int r){\n\tNode* p=_alloc(l,r);\n\tif( l==r ) \n\t\treturn p; \n\tp->ls=_make(l,p->mid());\n\tp->rs=_make(p->mid()+1,r);\n\tp->update();\n\treturn p;\n}\n\nPII edges[maxn];\nVI adj[maxn];\nbool vst[maxn];\n\n\nint rt, dep[maxn];\nNode* bel[maxn];\n\nVI path;\nvoid dfs(int u){\n\twhile( true ){\n\t\tpath.PB(u);\n\t\tvst[u]=true;\n\t\tint ttt=u;\n\t\trepv(i, adj[u] ){\n\t\t\tint v=adj[u][i];\n\t\t\tif( vst[v] ) continue;\n\t\t\tu=v; break;\n\t\t}\n\t\tif( u==ttt ) break;\n\t}\n}\nint main(){\n\tint n, Q;\n\twhile( scanf(""%d"",&n)!=EOF ){\n\t\te=0; //\n\t\trep(i, 1, n+1) adj[i].clear();\n\t\t\n\t\trep(i, 1, n){\n\t\t\tint a, b;\n\t\t\tscanf(""%d %d"", &a, &b);\n\t\t\tedges[i]=MP(a, b);\n\t\t\tadj[a].PB(b);\n\t\t\tadj[b].PB(a);\n\t\t}\n\t\tint ma=0;\n\t\trep(i, 1, n+1){\n\t\t\tif( sz(adj[i]) > ma ){\n\t\t\t\tma=sz(adj[i]);\n\t\t\t\trt=i;\n\t\t\t}\n\t\t}\n\t\t//printf(""rt=%d\\n"", rt);\n\t\tclr(vst, false);\n\t\tvst[rt]=true; dep[rt]=0;\n\t\trepv(i, adj[rt] ){\n\t\t\tpath.clear();\n\t\t\tdfs( adj[rt][i] );\n\t\t\tNode *root=_make(1, sz(path));\n\t\t\trepv(j, path){\n\t\t\t\t//printf(""%d "", path[j]);\n\t\t\t\tdep[ path[j] ]=j+1;\n\t\t\t\tbel[ path[j] ]=root;\n\t\t\t}\n\t\t\t//puts("""");\n\t\t}\n\t\tscanf(""%d"", &Q);\n\t\twhile( Q-- ){\n\t\t\tint op;\n\t\t\tscanf(""%d"", &op);\n\t\t\tif( op<=2 ){\n\t\t\t\tint eid; scanf(""%d"", &eid);\n\t\t\t\tint a=edges[ eid ].ff;\n\t\t\t\tint b=edges[ eid ].ss;\n\t\t\t\tif( dep[a]<dep[b] ) swap(a, b);\n\t\t\t\tbel[a]->modify(dep[a]);\n\t\t\t}else{\n\t\t\t\tint u, v; scanf(""%d%d"", &u, &v);\n\t\t\t\tif( u==v ){\n\t\t\t\t\tputs(""0"");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( dep[u]>dep[v] ) swap(u, v);\n\t\t\t\tif( u==rt ){\n\t\t\t\t\tif( bel[v]->query(1, dep[v]) ){\n\t\t\t\t\t\tprintf(""%d\\n"", dep[v]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(""-1"");\n\t\t\t\t\t}\n\t\t\t\t}else if( bel[u]==bel[v] ){\n\t\t\t\t\tif( bel[v]->query(dep[u]+1, dep[v]) ){\n\t\t\t\t\t\tprintf(""%d\\n"", dep[v]-dep[u]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(""-1"");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( bel[u]->query(1, dep[u]) && bel[v]->query(1, dep[v]) ){\n\t\t\t\t\t\tprintf(""%d\\n"", dep[u]+dep[v]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(""-1"");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n']","['data structures', 'dsu', 'trees']",2100
https://codeforces.com//contest/1881/problem/A,A. Don't Try to Count,Given a string x of length n and a string s of length m n cdot m le 25 consisting of lowercase Latin letters you can apply any number of operations to the string x In one operation you append the current value of x to the end of the string x Note that the value of x will change after this For example if x then after applying operations x will change as follows rightarrow rightarrow After what number of operations s will appear in x as a substring A substring of a string is defined as a segment of it ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,m,k,a[N];\nstring s,t;\nvoid prep(){\n\n}\nvoid solve()\n{\n    cin>>n>>m>>s>>t;\n    k=0;\n    while (sz(s)<sz(t)) k++,s+=s;\n    rep(i,0,sz(s)-sz(t)) if (s.substr(i,sz(t))==t){\n        cout<<k;\n        return;\n    }\n    k++;\n    s+=s;\n    rep(i,0,sz(s)-sz(t)) if (s.substr(i,sz(t))==t){\n        cout<<k;\n        return;\n    }\n    cout<<-1;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']","['brute force', 'strings']",800
https://codeforces.com//contest/34/problem/A,A. Reconnaissance 2,soldiers stand in a circle For each soldier his height is known A reconnaissance unit can be made of such two soldiers whose heights difference is minimal i e is minimal So each of them will be less noticeable with the other Output any pair of soldiers that can form a reconnaissance unit ,"['#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair <int,int> ii;\n#define sz(a) int((a).size())\n#define pb push_back\nconst int INF = 2147483647;\nconst double PI = 3.141592653589793;\n\nint n,m,i,tab[105];\n\nint main () {\nscanf (""%d"",&n);\nfor (i=0;i<n;i++) scanf (""%d"",&tab[i]);\nm=INF;\nfor (i=0;i<n;i++) m = min(m,abs(tab[(i+1)%n]-tab[i]));\nfor (i=0;i<n;i++) if (abs(tab[(i+1)%n]-tab[i]) == m) {\n    printf(""%d %d\\n"",i+1,(i+1)%n+1);\n    i=n+1;\n}\nreturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1917/problem/F,F. Construct Tree,You are given an array of integers l 1 l 2 dots l n and an integer d Is it possible to construct a tree satisfying the following three conditions The tree contains n 1 nodes The length of the i th edge is equal to l i The weighted diameter of the tree is equal to d ,"['#pragma GCC diagnostic error ""-std=c++11""\n#pragma GCC target(""avx"")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""inline"")\n#pragma GCC optimize(""-fgcse"")\n#pragma GCC optimize(""-fgcse-lm"")\n#pragma GCC optimize(""-fipa-sra"")\n#pragma GCC optimize(""-ftree-pre"")\n#pragma GCC optimize(""-ftree-vrp"")\n#pragma GCC optimize(""-fpeephole2"")\n#pragma GCC optimize(""-ffast-math"")\n#pragma GCC optimize(""-fsched-spec"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC optimize(""-falign-jumps"")\n#pragma GCC optimize(""-falign-loops"")\n#pragma GCC optimize(""-falign-labels"")\n#pragma GCC optimize(""-fdevirtualize"")\n#pragma GCC optimize(""-fcaller-saves"")\n#pragma GCC optimize(""-fcrossjumping"")\n#pragma GCC optimize(""-fthread-jumps"")\n#pragma GCC optimize(""-funroll-loops"")\n#pragma GCC optimize(""-fwhole-program"")\n#pragma GCC optimize(""-freorder-blocks"")\n#pragma GCC optimize(""-fschedule-insns"")\n#pragma GCC optimize(""inline-functions"")\n#pragma GCC optimize(""-ftree-tail-merge"")\n#pragma GCC optimize(""-fschedule-insns2"")\n#pragma GCC optimize(""-fstrict-aliasing"")\n#pragma GCC optimize(""-fstrict-overflow"")\n#pragma GCC optimize(""-falign-functions"")\n#pragma GCC optimize(""-fcse-skip-blocks"")\n#pragma GCC optimize(""-fcse-follow-jumps"")\n#pragma GCC optimize(""-fsched-interblock"")\n#pragma GCC optimize(""-fpartial-inlining"")\n#pragma GCC optimize(""no-stack-protector"")\n#pragma GCC optimize(""-freorder-functions"")\n#pragma GCC optimize(""-findirect-inlining"")\n#pragma GCC optimize(""-fhoist-adjacent-loads"")\n#pragma GCC optimize(""-frerun-cse-after-loop"")\n#pragma GCC optimize(""inline-small-functions"")\n#pragma GCC optimize(""-finline-small-functions"")\n#pragma GCC optimize(""-ftree-switch-conversion"")\n#pragma GCC optimize(""-foptimize-sibling-calls"")\n#pragma GCC optimize(""-fexpensive-optimizations"")\n#pragma GCC optimize(""-funsafe-loop-optimizations"")\n#pragma GCC optimize(""inline-functions-called-once"")\n#pragma GCC optimize(""-fdelete-null-pointer-checks"")\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxn=2005;\nint T,n,d,p[maxn];\nbitset<maxn> g[maxn],dp;\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>d;\n\t\tfor(int i=1;i<=n;++i)cin>>p[i];\n\t\tsort(p+1,p+n+1);\n\t\tif(p[n]+p[n-1]>d){\n\t\t\tcout<<""No\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tif(p[n]>d/2){\n\t\t\tdp.reset();\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=1;i<n;++i)dp|=(dp<<p[i]);\n\t\t\tif(dp[d-p[n]]){\n\t\t\t\tcout<<""Yes\\n"";\n\t\t\t}\n\t\t\telse cout<<""No\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<=d;++i)g[i].reset();\n\t\tg[0][0]=1;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tfor(int j=d;j>=0;--j){\n\t\t\t\tg[j]|=(g[j]<<p[i]);\n\t\t\t\tif(j>=p[i])g[j]|=g[j-p[i]];\n\t\t\t}\n\t\t}\n\t\tint flag=0;\n\t\tfor(int i=p[n];i<=d/2;++i)if(g[i][d-i]){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(flag)cout<<""Yes\\n"";\n\t\telse cout<<""No\\n"";\n\t}\n\treturn 0;\n}']","['bitmasks', 'constructive algorithms', 'dp', 'trees']",2500
https://codeforces.com//contest/1027/problem/C,C. Minimum Value Rectangle,You have n sticks of the given lengths Your task is to choose exactly four of them in such a way that they can form a rectangle No sticks can be cut to pieces each side of the rectangle must be formed by a single stick No stick can be chosen multiple times It is guaranteed that it is always possible to choose such sticks Let S be the area of the rectangle and P be the perimeter of the rectangle The chosen rectangle should have the value frac P 2 S minimal possible The value is taken without any rounding If there are multiple answers print any of them Each testcase contains several lists of sticks for each of them you are required to solve the problem separately ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = (int)1e6 + 7;\nint n;\nll a[N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tsort(a, a + n);\n\tll bp = (ll)1e9, bq = 1;\n\tll bx = -1, by = -1;\n\tll lst = -1;\n\tint L = 0;\n\twhile(L < n) {\n\t\tint R = L + 1;\n\t\twhile(R < n && a[L] == a[R]) R++;\n\t\tif (R - L >= 4) {\n\t\t\tprintf(""%lld %lld %lld %lld\\n"", a[L], a[L], a[L], a[L]);\n\t\t\treturn;\n\t\t}\n\t\tif (R - L >= 2) {\n\t\t\tll x = a[L];\n\t\t\tif (lst != -1) {\n\t\t\t\tll p = (x + lst) * (x + lst);\n\t\t\t\tll q = x * lst;\n\t\t\t\t//eprintf(""! %lld %lld %lld %lld\\n"", lst, x, p, q);\n\t\t\t\tif (p * bq < q * bp) {\n\t\t\t\t\tbp = p;\n\t\t\t\t\tbq = q;\n\t\t\t\t\tbx = lst;\n\t\t\t\t\tby = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlst = x;\n\t\t}\n\t\tL = R;\n\t}\n\tprintf(""%lld %lld %lld %lld\\n"", bx, bx, by, by);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']",['greedy'],1600
https://codeforces.com//contest/1722/problem/G,G. Even-Odd XOR,Given an integer n find any array a of n nonnegative integers less than 2 31 such that the bitwise XOR of the elements on odd indices equals the bitwise XOR of the elements on even indices ,"['#include <bits/stdc++.h>\n#ifdef LOCAL\n#include ""txm/debug.h""\n#endif\n#define int long long\nusing namespace std;\nusing ll=long long;\nconst int N=200005;\nint n,a[N];\nvoid solve()\n{\n\tcin>>n;\n\tif(n==3) {cout<<""2 1 3\\n""; return;}\n\tbool bj=0;\n\tif(n%2) n--,bj=1;\n\tfor(int i=1;i<=n;i+=2) a[i]=i/2+1;\n\tfor(int i=2;i<=n;i+=2) a[i]=i/2;\n\tif(n%4==0)\n\t{\n\t\tfor(int i=2;i<=n;i+=2) a[i]|=(1<<30);\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<n;i+=2) a[i]|=(1<<30);\n\t\tfor(int i=n;i>=4;i-=2) a[i]|=(1<<29);\n\t}\n\tif(bj) a[++n]=0;\n\tfor(int i=1;i<=n;i++) cout<<a[i]<<"" \\n""[i==n];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}\n']","['bitmasks', 'constructive algorithms', 'greedy']",1500
https://codeforces.com//contest/1582/problem/D,"D. Vupsen, Pupsen and 0",Vupsen and Pupsen were gifted an integer array Since Vupsen doesn t like the number 0 he threw away all numbers equal to 0 from the array As a result he got an array a of length n Pupsen on the contrary likes the number 0 and he got upset when he saw the array without zeroes To cheer Pupsen up Vupsen decided to come up with another array b of length n such that sum i 1 n a i cdot b i 0 Since Vupsen doesn t like number 0 Also the numbers in that array must not be huge so Please help Vupsen to find any such array b ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve(int a, int b, int c, int& x, int &y, int &z) {\n\tif (a == b) {\n\t\tx = c; y = -2 * c;\n\t\tz = a;\n\t\treturn;\n\t}\n\tif (a + b == 0) {\n\t\tx = c; y = 2 * c;\n\t\tz = a;\n\t\treturn;\n\t}\n\tif (b + c == 0 || b == c || c + a == 0 || c == a) {\n\t\tsolve(b, c, a, y, z, x);\n\t\treturn;\n\t}\n\tx = b + c;\n\ty = -(a + c);\n\tz = b - a;\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""d.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> r(n);\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\t\tr[i + 1] = -a[i];\n\t\t\t\tr[i] = a[i + 1];\n\t\t\t}\n\t\t} else {\n\t\t\tsolve(a[0], a[1], a[2], r[0], r[1], r[2]);\n\t\t\tfor (int i = 3; i < n; i += 2) {\n\t\t\t\tr[i + 1] = -a[i];\n\t\t\t\tr[i] = a[i + 1];\n\t\t\t}\n\t\t}\n\t\tlong long s = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tassert(r[i]);\n\t\t\ts += (long long)a[i] * r[i];\n\t\t}\n\t\tassert(s == 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tprintf(""%d "", r[i]);\n\t\t}\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'math']",1600
https://codeforces.com//contest/483/problem/B,B. Friends and Presents,You have two friends You want to present each of them several positive integers You want to present numbers to the first friend and numbers to the second friend Moreover you want all presented numbers to be distinct that also means that no number should be presented to both friends In addition the first friend does not like the numbers that are divisible without remainder by prime number The second one does not like the numbers that are divisible without remainder by prime number Of course you re not going to present your friends numbers they don t like Your task is to find such minimum number that you can form presents using numbers from a set Of course you may choose not to present some numbers at all A positive integer number greater than 1 is called if it has no positive divisors other than 1 and itself ,"['#include <bits/stdc++.h>\nusing namespace std;\nlong long a, b, x, y;\n\nlong long ok(long long n) {\n    long long oa = n / x;\n    long long ob = n / y;\n    long long oab = n / x / y;\n\n    long long com = n - oa - ob + oab;\n    long long ca = n - oa;\n    long long cb = n - ob;\n    return ca >= a && cb >= b && ca + cb - com >= a + b;\n}\n\nint main() {\n    cin >> a >> b >> x >> y;\n    long long l = max(a, b), r = 1e13;\n    while(l < r) {\n        long long m = (l + r) >> 1;\n        if(!ok(m)) l = m + 1;\n        else r = m;\n    }\n    cout << r << endl;\n    return 0;\n}']","['binary search', 'math']",1800
https://codeforces.com//contest/677/problem/C,C. Vanya and Label,While walking down the street Vanya saw a label Hide Seek Because he is a programmer he used as a bitwise AND for these two words represented as a integers in base and got new word Now Vanya thinks of some string and wants to know the number of pairs of words of length length of such that their bitwise AND is equal to As this number can be large output it modulo To represent the string as a number in numeral system with base Vanya uses the following rules digits from to correspond to integers from to letters from to correspond to integers from to letters from to correspond to integers from to letter correspond to integer letter correspond to integer ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,h,k;\nint a[1000000];\nlong long ans;\nlong long cnt[1000];\nstring s;\n\nint make(char q)\n{\n    if(q==\'-\')\n        return 62;\n    if(q==\'_\')\n        return 63;\n    if(q>=\'0\' && q<=\'9\')\n        return q-\'0\';\n    else\n    if(q>=\'A\' && q<=\'Z\')\n        return 10+q-\'A\';\n    else\n    if(q>=\'a\' && q<=\'z\')\n    {\n        return 10+\'z\'-\'a\'+1+q-\'a\';\n    }\n}\n\nint main()\n{\n    for(int i=0;i<64;i++)\n        for(int j=0;j<64;j++)\n            cnt[i&j]++;\n    cin>>s;\n    long long ans=1;\n    const int md=1e9+7;\n    for(int i=0;i<s.size();i++)\n    {\n        int cur=make(s[i]);\n        ans=(ans*cnt[cur])%md;\n    }\n    cout<<ans<<""\\n"";\n}\n']","['bitmasks', 'combinatorics', 'implementation', 'strings']",1500
https://codeforces.com//contest/861/problem/B,B. Which floor ,In a building where Polycarp lives there are number of flats on each floor Unfortunately Polycarp don t remember how many flats are on each floor but he remembers that the flats are numbered from from lower to upper floors That is the first several flats are on the first floor the next several flats are on the second and so on Polycarp don t remember the total number of flats in the building so you can consider the building to be infinitely high i e there are infinitely many floors Note that the floors are numbered from Polycarp remembers on which floors several flats are located It is guaranteed that this information is not self contradictory It means that there exists a building with equal number of flats on each floor so that the flats from Polycarp s memory have the floors Polycarp remembers Given this information is it possible to restore the exact floor for flat ,"['#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(""%d"",&num1)\n#define sll(num1) scanf(""%lld"",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define TRACE\n \n//FILE *fin = freopen(""in"",""cc"",stdin);\n//FILE *fout = freopen(""out"",""s2numx"",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << "": "" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << "" | "" << #nn3 << "": "" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << endl;\n#define trace5(num1, bin, ch, d, txx)    cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #txx << "": "" << txx << endl;\n#define trace6(num1, bin, ch, d, txx, det) cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #txx << "": "" << txx << "" | "" << #det << "": "" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, txx)\n#define trace6(num1, bin, ch, d, txx, det)\n \n#endif\n\n#define pi(numx) printf(""%d\\num1"",numx)\n#define ff first\n#define ss second\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ll long long\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n\n#define lb lower_bound\n#define ub upper_bound\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define freq first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\nbool don[105];\nVI idxx;\nint main(){\n    fast\n    int num1,num2;\n    cin>>num1>>num2;\n    int cc[num2];\n    int freq[num2];\n    for(int i = 0 ; i < num2 ;i++){\n        cin >> cc[i] >> freq[i];\n        \n    }\n    if(num1==1){\n        cout << 1;\n    }\n    else{\n    for(int i=1;i<=100;i++){\n    \tfor(int j=0;j<num2;j++){\n    \t\tif(ceil((double)cc[j]/i)==freq[j]&& j!=num2-1){\n    \t\t\tcontinue;\n    \t\t}\n    \t\telse if(ceil((double)cc[j]/i)==freq[j] && j==num2-1){\n    \t\t\tdon[i]==true;\n    \t\t\tidxx.pb((int)ceil((double)num1/i));\n    \t\t}\n    \t\telse{\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    }\n    if(idxx.size()!=0){\n        sort(idxx.begin(),idxx.end());\n        if(idxx[0]==idxx[idxx.size()-1])\n            cout<<idxx[0];\n        else\n            cout<<-1;\n        }\n        else\n            cout<<-1;\n    }\n}']","['brute force', 'implementation']",1500
https://codeforces.com//contest/518/problem/D,D. Ilya and Escalator,Ilya got tired of sports programming left university and got a job in the subway He was given the task to determine the escalator load factor Let s assume that people stand in the queue for the escalator At each second one of the two following possibilities takes place either the first person in the queue enters the escalator with probability or the first person in the queue doesn t move with probability paralyzed by his fear of escalators and making the whole queue wait behind him Formally speaking the th person in the queue cannot enter the escalator until people with indices from to inclusive enter it In one second only one person can enter the escalator The escalator is infinite so if a person enters it he never leaves it that is he will be standing on the escalator at any following second Ilya needs to count the expected value of the number of people standing on the escalator after seconds Your task is to help him solve this complicated task ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\ndouble dp[2111][2111];//i-th day, j people\nint main()\n{\n\tint i,j,k;\n\tdp[0][0]=1;\n\tint n,t;\n\tdouble p;\n\tcin>>n>>p>>t;\n\tfor (i=0;i<=t;i++)\n\t{\n\t\tfor (j=0;j<=n;j++)\n\t\t{\n\t\t\tif (j==n)\n\t\t\t{\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i+1][j+1]+=dp[i][j]*p;\n\t\t\tdp[i+1][j]+=dp[i][j]*(1-p);\n\t\t}\n\t}\n\tdouble ans=0;\n\tfor (i=0;i<=n;i++)\n\t{\n\t\tans+=i*dp[t][i];\n\t}\n\tprintf(""%.10lf\\n"",ans);\n\treturn 0;\n}\n\t\t\t']","['combinatorics', 'dp', 'math', 'probabilities']",1700
https://codeforces.com//contest/1789/problem/C,C. Serval and Toxel s Arrays,Toxel likes arrays Before traveling to the Paldea region Serval gave him an array a as a gift This array has n elements In order to get more arrays Toxel performed m operations with the initial array In the i th operation he modified the p i th element of the i 1 th array to v i resulting in the i th array the initial array a is numbered as 0 During modifications Toxel guaranteed that the elements of each array are still after each operation Finally Toxel got m 1 arrays and denoted them as A 0 a A 1 ldots A m For each pair i j 0 le i j le m Toxel defines its value as the number of distinct elements of the concatenation of A i and A j Now Toxel wonders what is the sum of the values of all pairs Please help him to calculate the answer ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> last(n, -1);\n    vector<int> a(n);\n    vector<int> cnt(n + m + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        last[i] = 0;\n    }\n    for (int i = 1; i <= m; ++i) {\n        int p, v;\n        cin >> p >> v;\n        p--;\n        cnt[a[p]] += i - last[p];\n        a[p] = v;\n        last[p] = i;\n    }\n    for (int i = 0; i < n; ++i) {\n        cnt[a[i]] += m + 1 - last[i];\n    }\n    ll ans = 1ll * (m + 1) * m * n;\n    for(int i = 1; i <= n + m; ++i) {\n        ans -= 1ll * cnt[i] * (cnt[i] - 1) / 2;\n    }\n    cout << ans << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}']","['combinatorics', 'dp', 'implementation', 'math']",1500
https://codeforces.com//contest/1850/problem/B,B. Ten Words of Wisdom,In the game show Ten Words of Wisdom there are n participants numbered from 1 to n each of whom submits one response The i th response is a i words long and has quality b i No two responses have the same quality and at least one response has length at most 10 The winner of the show is the response which has the highest quality out of all responses that are not longer than 10 words Which response is the winner ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tint n;  cin >> n;\n\tvector<array<int, 2>> a;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x, y;  cin >> x >> y;\n\t\tif (x <= 10) {\n\t\t\ta.push_back({y, i});\n\t\t}\n\t}\n\tsort(a.rbegin(), a.rend());\n\tcout << a[0][1] << ""\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","['implementation', 'sortings']",800
https://codeforces.com//contest/1732/problem/C2,C2. Sheikh  Hard Version ,You are given an array of integers a 1 a 2 ldots a n The cost of a subsegment of the array l r 1 leq l leq r leq n is the value f l r operatorname sum l r operatorname xor l r where operatorname sum l r a l a l 1 ldots a r and operatorname xor l r a l oplus a l 1 oplus ldots oplus a r oplus stands for bitwise XOR You will have q queries Each query is given by a pair of numbers L i R i where 1 leq L i leq R i leq n You need to find the subsegment l r L i leq l leq r leq R i with maximum value f l r If there are several answers then among them you need to find a subsegment with the minimum length that is the minimum value of r l 1 ,"[""#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n,q,a[100005],nxt[100005];\nLL s[100005],s2[100005];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n),gi(q);\n\t\tfor(int i=1;i<=n;i++)gi(a[i]),s[i]=s[i-1]^a[i],s2[i]=s2[i-1]+a[i];\n\t\tnxt[n+1]=n+1;\n\t\tfor(int i=n;i;i--){\n\t\t\tif(a[i])nxt[i]=i;\n\t\t\telse nxt[i]=nxt[i+1];\n\t\t}\n\t\twhile(q--){\n\t\t\tint L,R;\n\t\t\tgi(L),gi(R);\n\t\t\tif(nxt[L]>R){pi(L,' ');pi(L,'\\n');continue;}\n\t\t\tint ansl=-1,ansr=-1;\n\t\t\tLL mx=s2[R]-s2[L-1]-(s[R]^s[L-1]);\n\t\t\tfor (int x=nxt[L];x<=R;x=nxt[x+1]){\n\t\t\t\tLL now=s2[R]-s2[x-1]-(s[R]^s[x-1]);\n    \t\t\tif (now!=mx) break;\n\t\t\t\tint l=x,r=R,ans=-1;\n\t\t\t\twhile(l<=r){\n\t\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\t\tLL val=s2[mid]-s2[x-1]-(s[mid]^s[x-1]);\n\t\t\t\t\tif(val==mx)ans=mid,r=mid-1;\n\t\t\t\t\telse l=mid+1;\n\t\t\t\t}\n\t\t\t\tif(ans!=-1){\n\t\t\t\t\tif(ansl==-1)ansl=x,ansr=ans;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ans-x+1<ansr-ansl+1)\n\t\t\t\t\t\t\tansl=x,ansr=ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpi(ansl,' ');\n\t\t\tpi(ansr,'\\n');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/""]","['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'two pointers']",2100
https://codeforces.com//contest/381/problem/B,B. Sereja and Stairs,Sereja loves integer sequences very much He especially likes stairs Sequence is the length of the sequence is stairs if there is such index that the following condition is met For example sequences 1 2 3 2 and 4 2 are stairs and sequence 3 1 2 isn t Sereja has cards with numbers He wants to put some cards on the table in a row to get a stair sequence What maximum number of cards can he put on the table ,"['#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector> \n#include<cstring>\n#include<string>\n#define mp make_pair\n#define scn second\n#define frs first\n#define pb push_back\n#define NAME ""a""\n#define fop freopen(NAME "".in"", ""r"", stdin); freopen(NAME "".out"", ""w"", stdout); \nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pi;\nvoid dout() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n  cerr << H << \' \';\n  dout(T...);\n}\nint was[100010], n, a[100100];\nint ans[500000];\n\nint main(){\n\t#ifdef LocalHost\n\t\tfop;\n\t#endif\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tint l = 100001, r = 100001;\n\tans[l] = a[n - 1];\n\t--l, ++r;\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\tif (ans[l + 1] != a[i])\n\t\t\tans[l] = a[i], --l;\n\t\telse {\n\t\t\tif (ans[r - 1] != a[i])\n\t\t\t\tans[r] = a[i], ++r;\n\t\t}\t\n\t}\n\t\n\tprintf(""%d\\n"", r - l - 1);\n\tfor (int i = l + 1; i < r; ++i)\n\t\tprintf(""%d "", ans[i]);\n\treturn 0;\n}']","['greedy', 'implementation', 'sortings']",1100
https://codeforces.com//contest/1074/problem/F,F. DFS,Let T be a tree on n vertices Consider a graph G 0 initially equal to T You are given a sequence of q updates where the i th update is given as a pair of two distinct integers u i and v i For every i from 1 to q we define the graph G i as follows If G i 1 contains an edge u i v i then remove this edge to form G i Otherwise add this edge to G i 1 to form G i Formally G i G i 1 triangle u i v i where triangle denotes the set symmetric difference Furthermore it is guaranteed that T is always a subgraph of G i In other words an update never removes an edge of T Consider a connected graph H and run a depth first search on it One can see that the tree edges i e the edges leading to a not yet visited vertex at the time of traversal form a spanning tree of the graph H This spanning tree is not generally fixed for a particular graph it depends on the starting vertex and on the order in which the neighbors of each vertex are traversed We call vertex w if one can order the neighbors of each vertex in such a way that the depth first search started from w produces T as the spanning tree For every i from 1 to q find and report the number of good vertices ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1100*1007;\nconst int n1=(1<<18);\n\nint n, q;\nvi graf[nax];\n\nvector <int> drz[nax];\nint roz[nax], jump[nax], pre[nax], post[nax], fad[nax];\nint l;\n\nvoid dfs_roz(int v)\n{\n\troz[v]=1;\n\tfor (int &i : drz[v])\n\t{\n\t\tfad[i]=v;\n\t\tdfs_roz(i);\n\t\troz[v]+=roz[i];\n\t\tif (roz[i]>roz[drz[v][0]])\n\t\t\tswap(i, drz[v][0]);\n\t}\n}\n\nvoid dfs_pre(int v)\n{\n\tif (!jump[v])\n\t\tjump[v]=v;\n\tl++;\n\tpre[v]=l;\n\tif (!drz[v].empty())\n\t\tjump[drz[v][0]]=jump[v];\n\tfor (int i : drz[v])\n\t\tdfs_pre(i);\n\tpost[v]=l;\n}\n\nint lca(int v, int u)\n{\n\twhile(jump[v]!=jump[u])\n\t{\n\t\tif (pre[v]<pre[u])\n\t\t\tswap(v, u);\n\t\tv=fad[jump[v]];\n\t}\n\treturn (pre[v]<pre[u] ? v : u);\n}\n\nvector < pair <int,int> > path_up(int v, int u)\n{\n\tvector < pair <int,int> > ret;\n\twhile(jump[v]!=jump[u])\n\t{\n\t\tret.push_back({pre[jump[v]], pre[v]});\n\t\tv=fad[jump[v]];\n\t}\n\tret.push_back({pre[u], pre[v]});\n\treturn ret;\n}\n\nvector < pair <int,int> > get_path(int v, int u)\n{\n\tint w=lca(v, u);\n\tauto ret=path_up(v, w);\n\tauto pom=path_up(u, w);\n\tfor (auto &i : ret)\n\t\tswap(i.first, i.second);\n\twhile(!pom.empty())\n\t{\n\t\tret.push_back(pom.back());\n\t\tpom.pop_back();\n\t}\n\treturn ret;\n}\n\nint odl[nax];\nvi jumpp[nax];\n\nvoid dfs1(int v, int oj)\n{\n\tjumpp[v].push_back(oj);\n\twhile(jumpp[v].back())\n\t{\n\t\tint p1=jumpp[v].back();\n\t\tint p2=min(jumpp[v].size(), jumpp[p1].size())-1;\n\t\tjumpp[v].push_back(jumpp[p1][p2]);\n\t}\n\tfor (int i : graf[v])\n\t{\n\t\tif (i!=oj)\n\t\t{\n\t\t\todl[i]=odl[v]+1;\n\t\t\tdrz[v].push_back(i);\n\t\t\tdfs1(i, v);\n\t\t}\n\t}\n}\n\nint skocz(int v, int ile)\n{\n\tfor (int i=0; (1<<i)<=ile; i++)\n\t\tif (ile&(1<<i))\n\t\t\tv=jumpp[v][i];\n\treturn v;\n}\n\nint dod[nax];\npii maxi[nax];\n\npii lacz(pii a, pii b)\n{\n\tif (a.first==b.first)\n\t\treturn {a.first, a.second+b.second};\n\treturn max(a, b);\n}\n\npii daj(int v)\n{\n\treturn {dod[v]+maxi[v].first, maxi[v].second};\n}\n\nvoid upd(int v)\n{\n\tmaxi[v]=lacz(daj(v*2), daj(v*2+1));\n}\n\nvoid pisz(int v, int a, int b, int graa, int grab, int w)\n{\n\t//~ if (v==1)\n\t\t//~ debug() << ""pisze "" << graa << "" "" << grab << ""  "" << w;\n\tif (a>=graa && b<=grab)\n\t{\n\t\tdod[v]+=w;\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tpisz((v<<1), a, (a+b)>>1, graa, grab, w);\n\tpisz((v<<1)^1, (a+b+2)>>1, b, graa, grab, w);\n\tupd(v);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\todl[1]=1;\n\tdfs1(1, 0);\n\tdfs_roz(1);\n\tdfs_pre(1);\n\tset <pii> jest;\n\tfor (int i=1; i<=n; i++)\n\t\tmaxi[i+n1-1]={0, 1};\n\tfor (int i=n1-1; i; i--)\n\t\tupd(i);\n\tpisz(1, 1, n1, n+1, n1, -1);\n\twhile(q--)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tif (a>b)\n\t\t\tswap(a, b);\n\t\tint w;\n\t\tif (jest.count({a, b}))\n\t\t{\n\t\t\tw=-1;\n\t\t\tjest.erase({a, b});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tw=1;\n\t\t\tjest.insert({a, b});\n\t\t}\n\t\tint l=lca(a, b);\n\t\t//~ debug() << a << "" "" << b << "" "" << l;\n\t\tif (a!=l && b!=l)\n\t\t{\n\t\t\tpisz(1, 1, n1, pre[a], post[a], w);\n\t\t\tpisz(1, 1, n1, pre[b], post[b], w);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l==b)\n\t\t\t\tswap(a, b);\n\t\t\tpisz(1, 1, n1, 1, n, w);\n\t\t\tint p=skocz(b, odl[b]-odl[a]-1);\n\t\t\tpisz(1, 1, n1, pre[p], post[p], -w);\n\t\t\tpisz(1, 1, n1, pre[b], post[b], w);\n\t\t}\n\t\tpii v=daj(1);\n\t\tif (v.first!=(int)jest.size())\n\t\t\tv.second=0;\n\t\t//~ debug() << v;\n\t\tprintf(""%d\\n"", v.second);\n\t}\n\treturn 0;\n}\n']","['data structures', 'trees']",2700
https://codeforces.com//contest/1651/problem/C,C. Fault-tolerant Network,There is a classroom with two rows of computers There are n computers in each row and each computer has its own grade Computers in the first row has grades a 1 a 2 dots a n and in the second row b 1 b 2 dots b n Initially all pairs of computers in each row are connected by wire pairs i i 1 for all 1 le i n so two rows form two independent computer networks Your task is to combine them in one common network by connecting one or more pairs of computers from rows Connecting the i th computer from the first row and the j th computer from the second row costs a i b j You can connect one computer to several other computers but you need to provide at least a basic fault tolerance you need to connect computers in such a way that the network stays connected despite one of its computer failing In other words if one computer is broken no matter which one the network won t split in two or more parts That is the minimum total cost to make a fault tolerant network ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    vl A(N); F0R(i, N) cin >> A[i];\n    vl B(N); F0R(i, N) cin >> B[i];\n    ll ans = min(abs(A[0] - B[0]) + abs(A[N-1] - B[N-1]), abs(A[0] - B[N-1]) + abs(A[N-1] - B[0]));\n\n    ll cost[4]; F0R(i, 4) cost[i] = 1e12;\n    F0R(i, N) {\n        ckmin(cost[0], abs(A[0] - B[i]));\n        ckmin(cost[1], abs(A[N-1] - B[i]));\n        ckmin(cost[2], abs(A[i] - B[0]));\n        ckmin(cost[3], abs(A[i] - B[N-1]));\n    }\n\n    ckmin(ans, abs(A[0] - B[0]) + cost[1] + cost[3]);\n    ckmin(ans, abs(A[0] - B[N-1]) + cost[1] + cost[2]);\n    ckmin(ans, abs(A[N-1] - B[0]) + cost[0] + cost[3]);\n    ckmin(ans, abs(A[N-1] - B[N-1]) + cost[0] + cost[2]);\n\n    ckmin(ans, cost[0] + cost[1] + cost[2] + cost[3]);\n\n    cout << ans << nl;\n    \n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']","['brute force', 'data structures', 'implementation']",1500
https://codeforces.com//contest/1805/problem/B,B. The String Has a Target,You are given a string s You can apply this operation to the string exactly once choose index i and move character s i to the beginning of the string removing it at the old position For example if you apply the operation with index i 4 to the string with numbering from 1 you get the string What is the lexicographically minimal dagger string you can obtain by this operation dagger A string a is lexicographically smaller than a string b of the same length if and only if the following holds in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(""YES"");\n\telse\n\t\tputs(""NO"");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(""yes"");\n\telse\n\t\tputs(""no"");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(""Yes"");\n\telse\n\t\tputs(""No"");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<\'0\'||c>\'9\')\n\t{\n\t\tif(c==\'-\')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>=\'0\'&&c<=\'9\')\n\t{\n\t\tx=x*10+c-\'0\';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar(\'-\'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+\'0\');\n//\tputchar(\'\\n\');\n}\ninline void fre()\n{\n\tfreopen("".in"",""r"",stdin);\n\tfreopen("".out"",""w"",stdout);\n}\nvoid work()\n{\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\tchar mn=\'z\';\n\tfor(int i=0;i<n;i++)\n\t\tmn=min(mn,s[i]);\n\tfor(int i=n-1;~i;i--)\n\t\tif(s[i]==mn)\n\t\t{\n\t\t\tcout<<mn<<s.substr(0,i)<<s.substr(i+1)<<endl;\n\t\t\treturn;\n\t\t}\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n\tcases();\n//\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n']","['greedy', 'strings']",800
https://codeforces.com//contest/1301/problem/A,A. Three Strings,You are given three strings a b and c of the same length n The strings consist of lowercase English letters only The i th letter of a is a i the i th letter of b is b i the i th letter of c is c i For every i 1 leq i leq n you swap i e exchange c i with either a i or b i So in total you ll perform exactly n swap operations each of them either c i leftrightarrow a i or c i leftrightarrow b i i iterates over all integers between 1 and n inclusive For example if a is b is and c is you can make c equal to taking the 1 st and the 4 th letters from a and the others from b In this way a becomes and b becomes Is it possible that after these swaps the string a becomes exactly the same as the string b ,"['#include <bits/stdc++.h>\n\nint T, n;\nstd::string a, b, c;\n\nbool solve() {\n    for (int i = 0; i < n; i++) {\n        if (a[i] == b[i]) {\n            if (a[i] != c[i]) { return false; }\n        } else if (a[i] == c[i] || b[i] == c[i]) {\n            \n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for (std::cin >> T; T; T--) {\n        std::cin >> a >> b >> c; n = a.size();\n        printf(""%s\\n"", solve() ? ""YES"" : ""NO"");\n    }\n    return 0;\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/1437/problem/D,D. Minimal Height Tree,Monocarp had a tree which consisted of n vertices and was rooted at vertex 1 He decided to study BFS Breadth first search so he ran BFS on his tree starting from the root BFS can be described by the following pseudocode a the order in which vertices were processedq Queue q put 1 place the root at the end of the queuewhile not q empty k q pop retrieve the first vertex from the queue a append k append k to the end of the sequence in which vertices were visited for y in g k g k is the list of all children of vertex k sorted in ascending order q put y Monocarp was fascinated by BFS so much that in the end he lost his tree Fortunately he still has a sequence of vertices in which order vertices were visited by the BFS algorithm the array from the pseudocode Monocarp knows that each vertex was visited exactly once since they were put and taken from the queue exactly once Also he knows that all children of each vertex were viewed Monocarp knows that there are many trees in the general case with the same visiting order a so he doesn t hope to restore his tree Monocarp is okay with any tree that of a tree is the maximum depth of the tree s vertices and the depth of a vertex is the number of edges in the path from the root to it For example the depth of vertex 1 is 0 since it s the root and the depth of all root s children are 1 Help Monocarp to find any tree with given visiting order a and minimum height ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint b[N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tb[0] = 1;\n\tint m = 1;\n\tint l = 1;\n\twhile(l < n) {\n\t\tint k = b[m - 1];\n\t\tb[m] = 0;\n\t\twhile(k > 0) {\n\t\t\tk--;\n\t\t\tif (l == n) continue;\n\t\t\tl++;\n\t\t\tb[m]++;\n\t\t\twhile(l < n && a[l] > a[l - 1]) {\n\t\t\t\tl++;\n\t\t\t\tb[m]++;\n\t\t\t}\n\t\t}\n\t\tm++;\n\t}\n\tprintf(""%d\\n"", m - 1);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['graphs', 'greedy', 'shortest paths', 'trees']",1600
https://codeforces.com//contest/1658/problem/F,F. Juju and Binary String,The of a binary string is the number of texttt 1 s divided by the length of the string For example the of texttt 01101 is frac 3 5 Juju has a binary string s of length n She wants to choose some non intersecting subsegments of s such that their concatenation has length m and it has the same as the string s More specifically she wants to find two arrays l and r of equal length k such that 1 leq l 1 leq r 1 l 2 leq r 2 ldots l k leq r k leq n and also sum limits i 1 k r i l i 1 m The of s l 1 r 1 s l 2 r 2 ldots s l k r k is equal to the of s where s x y denotes the subsegment s x s x 1 ldots s y and denotes string concatenation Juju does not like splitting the string into many parts so she also wants to the value of k Find the minimum value of k such that there exist l and r that satisfy the constraints above or determine that it is impossible to find such l and r for any k ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint sum[500005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint cnt1=0,cnt0=0;\n\t\tfor(auto t:s)\n\t\t\tcnt1+=t==\'1\',cnt0+=t==\'0\';\n\t\tcnt1*=m,cnt0*=m;\n\t\tif(cnt1%n||cnt0%n)\n\t\t{\n\t\t\tcout << ""-1\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\ts=\' \'+s+s;\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t{\n\t\t\tif(s[i]==\'1\') sum[i]=cnt0;\n\t\t\telse sum[i]=-cnt1;\n\t\t}\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t\tsum[i]+=sum[i-1];\n\t\tint pos=0;\n\t\tfor(int i=m;i<=n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << ""1\\n"";\n\t\t\tcout << pos-m+1 << "" "" << pos << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=n+1;i<=n+n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << ""2\\n"";\n\t\t\tint l=pos-m+1,r=pos;\n\t\t\tcout << 1 << "" "" << r-n << ""\\n"";\n\t\t\tcout << l << "" "" << n << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\texit(1);\n\t}\n\treturn 0;\n}']","['brute force', 'constructive algorithms', 'greedy', 'math']",2700
https://codeforces.com//contest/898/problem/A,A. Rounding,Vasya has a non negative integer He wants to round it to nearest integer which ends up with If already ends up with Vasya considers it already rounded For example if answer is If Vasya can round it to or to Both ways are correct For given find out to which integer will Vasya round it ,"['#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define ll long long\n\nusing namespace std;\n\nconst int N = (3e5), mod = (1e9) + 7;\n\nint n;\n\nint main(){\n\tcin >> n;\n\tif(n % 10 <= 5){\n\t\tn -= n % 10;\n\t}\n\telse{\n\t\tn += (10 - n % 10);\n\t}\n\tcout << n;\n\t\n \treturn 0;\n}             ']","['implementation', 'math']",800
https://codeforces.com//contest/1715/problem/F,F. Crop Squares,Farmer Stanley grows corn on a rectangular field of size n times m meters with corners in points 0 0 0 m n 0 n m This year the harvest was plentiful and corn covered the whole field The night before harvest aliens arrived and poisoned the corn in a single 1 times 1 square with sides parallel to field borders The corn inside the square must not be eaten but you cannot distinguish it from ordinary corn by sight Stanley can only collect a sample of corn from an arbitrary polygon and bring it to the laboratory where it will be analyzed and Stanley will be told the amount of corn in the sample that was poisoned Since the harvest will soon deteriorate such a study can be carried out no more than 5 times More formally it is allowed to make no more than 5 queries each of them calculates the area of intersection of a chosen polygon with a square of poisoned corn It is necessary to find out the coordinates of the lower left corner of the drawn square the vertex of the square with the smallest x and y coordinates ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db eps=1e-15;\nmt19937 rd(time(0));\nint n,m,o,flag;\ndb a[200];\nvector<pair<db,db> > b;\nvoid out(db x,db y){\n\tif(flag)swap(x,y);\n\tb.push_back(make_pair(x,y));\n}\nvoid print(){\n\tprintf(""? %u\\n"",b.size());\n\tfor(auto p:b)printf(""%.15lf %.15lf\\n"",p.first,p.second);\n\tfflush(stdout);\t\n}\ndb ask(){\n\tb.clear();\n\tout(0,0),out(n,0);\n\tfor(int i=1;i<=o;i++){\n\t\tif(i&1)out(n,a[i]),out(eps,a[i]);\n\t\telse out(eps,a[i]),out(n,a[i]);\t\n\t}\n\tif(o%2==0)out(n,m),out(0,m);\n\tprint();\n\tdb res;cin>>res;\n\treturn res;\n}\ndb solve(){\n\ta[1]=((long long)rd()+1000)*1e-10;\n\tfor(o=1;a[o]+1<m;o++)a[o+1]=a[o]+1;\n\tdb res1=ask();\n\tfor(int i=1;i<=o;i++)a[i]-=i*1e-10;\n\tdb res2=ask();\n\tint x=abs(res1-res2)*1e10+0.5;\n\tif(x&1)return a[x]-res1;\n\telse return a[x]-(1-res1);\n}\nint main(){\n\tcin>>n>>m;\n\tdb Y=solve();\n\tflag=1,swap(n,m);\n\tdb X=solve();\n\tprintf(""! %.15lf %.15lf"",X,Y);\n\tfflush(stdout);\n\treturn 0;\n}\n']","['constructive algorithms', 'geometry', 'interactive', 'math']",2700
https://codeforces.com//contest/1280/problem/C,C. Jeremy Bearimy,Welcome Everything is fine You have arrived in The Medium Place the place between The Good Place and The Bad Place You are assigned a task that will either make people happier or torture them for eternity You have a list of k pairs of people who have arrived in a new inhabited neighborhood You need to assign each of the 2k people into one of the 2k houses Each person will be the resident of exactly one house and each house will have exactly one resident Of course in the neighborhood it is possible to visit friends There are 2k 1 roads each of which connects two houses It takes some time to traverse a road We will specify the amount of time it takes in the input The neighborhood is designed in such a way that from anyone s house there is exactly one sequence of distinct roads you can take to any other house In other words the graph with the houses as vertices and the roads as edges is a tree The truth is these k pairs of people are actually soulmates We index them from 1 to k We denote by f i the amount of time it takes for the i th pair of soulmates to go to each other s houses As we have said before you will need to assign each of the 2k people into one of the 2k houses You have two missions one from the entities in The Good Place and one from the entities of The Bad Place Here they are The first mission from The Good Place is to assign the people into the houses such that the sum of f i over all pairs i is minimized Let s define this minimized sum as G This makes sure that soulmates can easily and efficiently visit each other The second mission from The Bad Place is to assign the people into the houses such that the sum of f i over all pairs i is maximized Let s define this maximized sum as B This makes sure that soulmates will have a difficult time to visit each other What are the values of G and B ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<vector<pair<int,ll> > > edges;\n\nll a1, a2;\nint n;\n\nint dfs(int v, int p){\n\tint sz = 1;\n\tfor(pair<int,ll> e : edges[v]){\n\t\tif(e.first == p) continue;\n\t\tint csz = dfs(e.first, v);\n\t\tsz += csz;\n\t\tif(csz & 1){\n\t\t\ta1 += e.second;\n\t\t}\n\t\ta2 += e.second * min(n - csz, csz);\n\t}\n\treturn sz;\n}\nvoid solve(){\n\ta1 = a2 = 0;\n\tcin >> n;\n\tn *= 2;\n\tedges.assign(n, {});\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tll t;\n\t\tcin >> a >> b >> t;\n\t\ta--; b--;\n\t\tedges[a].push_back({b, t});\n\t\tedges[b].push_back({a, t});\n\t}\n\tdfs(0, -1);\n\tcout << a1 << ' ' << a2 << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['dfs and similar', 'graphs', 'greedy', 'trees']",2000
https://codeforces.com//contest/1648/problem/C,C. Tyler and Strings,While looking at the kitchen fridge the little boy Tyler noticed magnets with symbols that can be aligned into a string s Tyler likes strings and especially those that are lexicographically smaller than another string t After playing with magnets on the fridge he is wondering how many distinct strings can be composed out of letters of string s by rearranging them so that the resulting string is lexicographically smaller than the string t Tyler is too young so he can t answer this question The alphabet Tyler uses is very large so for your convenience he has already replaced the same letters in s and t to the same integers keeping that different letters have been replaced to different integers We call a string x lexicographically smaller than a string y if one of the followings conditions is fulfilled There exists such position of symbol m that is presented in both strings so that before m th symbol the strings are equal and the m th symbol of string x is smaller than m th symbol of string y String x is the prefix of string y and x neq y Because the answer can be too large print it modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\n\nconstexpr int N = 2E5;\n\ntemplate <typename T>\nstruct Fenwick {\n    const int n;\n    std::vector<T> a;\n    Fenwick(int n) : n(n), a(n) {}\n    void add(int x, T v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] += v;\n        }\n    }\n    T sum(int x) {\n        T ans = 0;\n        for (int i = x; i > 0; i -= i & -i) {\n            ans += a[i - 1];\n        }\n        return ans;\n    }\n    T rangeSum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> s(n), t(m);\n    for (int i = 0; i < n; i++) {\n        std::cin >> s[i];\n        s[i]--;\n    }\n    for (int i = 0; i < m; i++) {\n        std::cin >> t[i];\n        t[i]--;\n    }\n    \n    std::vector<int> cnt(N);\n    \n    Fenwick<Z> fen(N);\n    \n    std::vector<Z> fac(n + 1), invfac(n + 1), inv(n + 1);\n    fac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fac[i] = fac[i - 1] * i;\n    }\n    invfac[n] = fac[n].inv();\n    for (int i = n; i; i--) {\n        invfac[i - 1] = invfac[i] * i;\n        inv[i] = invfac[i] * fac[i - 1];\n    }\n    \n    for (auto x : s) {\n        cnt[x]++;\n        fen.add(x, 1);\n    }\n    Z cur = 1;\n    for (int i = 0; i < N; i++) {\n        cur *= invfac[cnt[i]];\n    }\n    \n    Z ans = 0;\n    for (int i = 0; i < std::min(n, m); i++) {\n        ans += cur * fen.sum(t[i]) * fac[n - i - 1];\n        if (cnt[t[i]] == 0) {\n            break;\n        }\n        cur *= cnt[t[i]];\n        cnt[t[i]]--;\n        fen.add(t[i], -1);\n    }\n    \n    if (n < m && cnt == std::vector(N, 0)) {\n        ans += 1;\n    }\n    \n    std::cout << ans.val() << ""\\n"";\n    \n    return 0;\n}']","['combinatorics', 'data structures', 'implementation']",1900
https://codeforces.com//contest/1374/problem/D,D. Zero Remainder Array,You are given an array a consisting of n positive integers Initially you have an integer x 0 During one move you can do one of the following two operations Choose i from 1 to n and increase a i by x a i a i x then increase x by 1 x x 1 Just increase x by 1 x x 1 The first operation can be applied to each i from 1 to n Your task is to find the minimum number of moves required to obtain such an array that each its element is k the value k is given You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << "" is "" << x << endl\n#define int ll\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7;\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tmap<int, int> cnt;\n\t\tint mx = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint tt;\n\t\t\tcin >> tt;\n\t\t\tif(tt % k == 0) continue;\n\t\t\ttt %= k;\n\t\t\tcnt[tt]++;\n\t\t\tmx = max(mx, cnt[tt] * k - tt);\n\t\t}\n\t\tcout << mx + 1 << endl;\n\t}\n\n}\n\n\n\n']","['math', 'sortings', 'two pointers']",1400
https://codeforces.com//contest/1073/problem/C,C. Vasya and Robot,Vasya has got a robot which is situated on an infinite Cartesian plane initially in the cell 0 0 Robot can perform the following four kinds of operations move from x y to x y 1 move from x y to x y 1 move from x y to x 1 y move from x y to x 1 y Vasya also has got a sequence of n operations Vasya wants to modify this sequence so after performing it the robot will end up in x y Vasya wants to change the sequence so the length of changed subsegment is minimum possible This length can be calculated as follows maxID minID 1 where maxID is the maximum index of a changed operation and minID is the minimum index of a changed operation For example if Vasya changes to then the operations with indices 2 5 and 7 are changed so the length of changed subsegment is 7 2 1 6 Another example if Vasya changes to then the length of changed subsegment is 1 Help Vasya Tell him the minimum length of subsegment that he needs to change so that the robot will go from 0 0 to x y or tell him that it s impossible ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool can(int x, int y, int n) {\n  x = abs(x);\n  y = abs(y);\n  return (x + y) % 2 == n % 2 && x + y <= n;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  int x, y;\n  cin >> x >> y;\n  if (!can(x, y, n)) {\n    cout << ""-1"" << endl;\n    return 0;\n  }\n  int r = n;\n  int l = -1;\n  while (r - l > 1) {\n    int m = (l + r) / 2;\n    int lx = 0;\n    int ly = 0;\n    int rx = 0;\n    int ry = 0;\n    for (int i = m; i < n; i++) {\n      if (s[i] == \'U\') ry++;\n      if (s[i] == \'D\') ry--;\n      if (s[i] == \'L\') rx--;\n      if (s[i] == \'R\') rx++;\n    }\n    bool ok = false;\n    for (int i = 0; i + m <= n; i++) {\n      ok |= can(x - lx - rx, y - ly - ry, m);\n      if (s[i] == \'U\') ly++;\n      if (s[i] == \'D\') ly--;\n      if (s[i] == \'L\') lx--;\n      if (s[i] == \'R\') lx++;\n      if (i + m < n) {\n        if (s[i+m] == \'U\') ly--;\n        if (s[i+m] == \'D\') ly++;\n        if (s[i+m] == \'L\') lx++;\n        if (s[i+m] == \'R\') lx--;\n      }\n    }\n    if (ok) {\n      r = m;\n    } else {\n      l = m;\n    }\n  }\n  cout << r << endl;\n}\n\n']","['binary search', 'two pointers']",1800
https://codeforces.com//contest/1902/problem/E,E. Collapsing Strings,You are given n strings s 1 s 2 dots s n consisting of lowercase Latin letters Let x be the length of string x Let a C a b of two strings a and b be the following operation if a is empty C a b b if b is empty C a b a if the last letter of a is equal to the first letter of b then C a b C a 1 a 1 b 2 b where s l r is the substring of s from the l th letter to the r th one otherwise C a b a b i e the concatenation of two strings Calculate sum limits i 1 n sum limits j 1 n C s i s j ,"[""#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nstruct Trie {\n    char a_init;\n    int D;\n    int INVALID = -1;\n    std::vector<std::vector<int>> child;\n    std::vector<int> par;\n\n    using T_NODE = int;\n    std::vector<T_NODE> v_info;\n\n    Trie(char a_init = 'a', int D = 26)\n        : a_init(a_init), D(D), child(1, std::vector<int>(D, INVALID)), par(1, -1), v_info(1) {}\n\n    int step(int now, char c) const {\n        if (now == INVALID) return INVALID;\n        return child.at(now).at(c - a_init);\n    }\n\n    int add_word(const std::string &str, T_NODE info) {\n        int now = 0;\n        for (auto &c : str) {\n            if (child[now][c - a_init] == INVALID) {\n                par.push_back(now);\n                child[now][c - a_init] = child.size();\n                child.emplace_back(D, INVALID);\n                v_info.resize(child.size());\n            }\n            now = child[now][c - a_init];\n        }\n        v_info[now] += info;\n        return now;\n    }\n};\n\n\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    vector<string> S(N);\n    for (auto &s : S) cin >> s;\n\n    Trie trie;\n    for (auto s : S) trie.add_word(s, 1);\n\n    for (int i = (int)trie.par.size() - 1; i; --i) trie.v_info.at(trie.par.at(i)) += trie.v_info.at(i);\n\n    long long ret = 0;\n    for (const auto &s : S) ret += (long long)s.size() * N * 2;\n\n    for (auto t : S) {\n        reverse(t.begin(), t.end());\n        int now = 0;\n        for (char c : t) {\n            now = trie.step(now, c);\n            if (now < 0) break;\n            ret -= trie.v_info.at(now) * 2;\n        }\n    }\n\n    cout << ret << '\\n';\n}\n""]","['data structures', 'strings', 'trees']",1900
https://codeforces.com//contest/1630/problem/F,F. Making It Bipartite,You are given an undirected graph of n vertices indexed from 1 to n where vertex i has a value a i assigned to it and all values a i are There is an edge between two vertices u and v if either a u divides a v or a v divides a u Find the minimum number of vertices to remove such that the remaining graph is bipartite when you remove a vertex you remove all the edges incident to it ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst int INF = (int)1e6;\nstruct Dinic {\n\tstruct Edge {\n\t\tint v, to;\n\t\tint cap;\n\n\t\tEdge() : v(), to(), cap() {}\n\t\tEdge (int _v, int _to, int _cap) : v(_v), to(_to), cap(_cap) {}\n\t};\n\tvector<Edge> ed;\n\tvector<vector<int>> g;\n\tint S, T;\n\tint n;\n\tvector<int> dist;\n\tvector<int> idx;\n\n\tDinic() : ed(), g(), S(), T() {}\n\tDinic(int _n, int _S, int _T) {\n\t\tn = _n;\n\t\tS = _S;\n\t\tT = _T;\n\t\tg.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i].clear();\n\t\ted = vector<Edge>();\n\t}\n\n\tvoid addEdge(int v, int to, int cap) {\n\t\tg[v].push_back((int)ed.size());\n\t\ted.push_back(Edge(v, to, cap));\n\t\tg[to].push_back((int)ed.size());\n\t\ted.push_back(Edge(to, v, 0));\n\t}\n\n\tbool BFS() {\n\t\tdist.resize(n);\n\t\tvector<int> q;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tdist[i] = n;\n\t\tq.push_back(S);\n\t\tdist[S] = 0;\n\t\tfor (int i = 0; i < (int)q.size(); i++) {\n\t\t\tint v = q[i];\n\t\t\tfor (int id : g[v]) {\n\t\t\t\tEdge e = ed[id];\n\t\t\t\tif (e.cap <= 0) continue;\n\t\t\t\tint u = e.to;\n\t\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\tq.push_back(u);\n\t\t\t}\n\t\t}\n\t\treturn dist[T] < n;\n\t}\n\n\tll dfs(int v, int flow) {\n\t\tif (v == T || flow == 0) return flow;\n\t\tint res = 0;\n\t\tfor (int &i = idx[v]; i < (int)g[v].size(); i++) {\n\t\t\tint id = g[v][i];\n\t\t\tEdge e = ed[id];\n\t\t\tint to = e.to;\n\t\t\tif (dist[to] != dist[v] + 1) continue;\n\t\t\tll df = dfs(to, min(flow, e.cap));\n\t\t\tflow -= df;\n\t\t\tres += df;\n\t\t\ted[id].cap -= df;\n\t\t\ted[id ^ 1].cap += df;\n\t\t\tif (flow == 0) return res;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint Flow() {\n\t\tidx.resize(n);\n\t\tint res = 0;\n\t\twhile(BFS()) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tidx[i] = 0;\n\t\t\tres += dfs(S, INF);\n\t\t}\n\t\treturn res;\n\t}\n} G;\n\nconst int N = 50500;\nint id[N];\nvector<int> d[N];\nint s, t, n;\nint a[N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tid[a[i]] = i;\n\t}\n\ts = 4 * n;\n\tt = s + 1;\n\tG = Dinic(4 * n + 2, s, t);\n\tfor (int i = 0; i < n; i++) {\n\t\tG.addEdge(s, 4 * i, 1);\n\t\tG.addEdge(4 * i + 1, 4 * i + 2, 1);\n\t\tG.addEdge(4 * i + 3, t, 1);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int x : d[a[i]]) {\n\t\t\tint v = id[x];\n\t\t\tif (v == -1) continue;\n\t\t\tG.addEdge(4 * i, 4 * v + 1, 1);\n\t\t\tG.addEdge(4 * i + 2, 4 * v + 3, 1);\n\t\t}\n\tint ans = G.Flow();\n\tfor (int i = 0; i < n; i++)\n\t\tid[a[i]] = -1;\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int i = 0; i < N; i++)\n\t\tid[i] = -1;\n\tfor (int x = 1; x < N; x++)\n\t\tfor (int y = 2 * x; y < N; y += x)\n\t\t\td[y].push_back(x);\n\n\tint z;\n\tscanf(""%d"", &z);\n\twhile(z--) solve();\n\n\treturn 0;\n}\n']","['flows', 'graph matchings', 'graphs', 'number theory']",3400
https://codeforces.com//contest/1282/problem/E,E. The Cake Is a Lie,It is known that the cake was originally a regular n sided polygon each vertex of which had a unique number from 1 to n The vertices were numbered in random order Each piece of the cake is a triangle The cake was cut into n 2 pieces as follows each time one cut was made with a knife from one vertex to another such that exactly one triangular piece was separated from the current cake and the rest continued to be a convex polygon In other words each time three consecutive vertices of the polygon were selected and the corresponding triangle was cut off A possible process of cutting the cake is presented in the picture below You are given a set of n 2 triangular pieces in random order The vertices of each piece are given in random order clockwise or counterclockwise Each piece is defined by three numbers the numbers of the corresponding n sided cake vertices For example for the situation in the picture above you could be given a set of pieces 3 6 5 5 2 4 5 4 6 6 3 1 You are interested in two questions What was the enumeration of the n sided cake vertices In what order were the pieces cut Formally you have to find two permutations p 1 p 2 dots p n 1 le p i le n and q 1 q 2 dots q n 2 1 le q i le n 2 such that if the cake vertices are numbered with the numbers p 1 p 2 dots p n in order clockwise or counterclockwise then when cutting pieces of the cake in the order q 1 q 2 dots q n 2 always cuts off a triangular piece so that the remaining part forms one convex polygon For example in the picture above the answer permutations could be p 2 4 6 1 3 5 or any of its cyclic shifts or its reversal and after that any cyclic shift and q 2 4 1 3 Write a program that based on the given triangular pieces finds any suitable permutations p and q ,"['#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nset<pii> f;\nset<vector<ll> > g[205000];\nvector<ll> ff;\nvector<vector<ll> > ans;\nmap<vector<ll>, ll> num;\nvector<ll> ans1;\nll p[MAXN], nt[MAXN];\nvoid solve() {\n    f.clear();\n    num.clear();\n    ans.clear();\n    ans1.clear();\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        g[i].clear();\n    }\n    for (int i = 0; i < n - 2; i++) {\n        ll x;\n        ff.clear();\n        for (int j = 0; j < 3; j++) {\n            cin >> x;\n            ff.push_back(x);\n        }\n\n        sort(ff.begin(), ff.end());\n        num[ff] = i + 1;\n        for (int j = 0; j < 3; j++) {\n            g[ff[j]].insert(ff);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        f.insert(mp((ll)g[i].size(), i));\n    }\n    while (!f.empty()) {\n        auto it = f.begin();\n        if (it->X == 0) {\n            f.erase(it);\n            continue;\n        }\n        ll v = it->Y;\n        f.erase(it);\n        auto it2 = g[v].begin();\n        ff.clear();\n        for (auto x : *it2) {\n            ff.push_back(x);\n        }\n        for (auto x : ff) {\n            f.erase(mp((ll)g[x].size(), x));\n            g[x].erase(ff);\n            if (!g[x].empty()) {\n                f.insert(mp((ll)g[x].size(), x));\n            }\n        }\n        ans1.push_back(num[ff]);\n        for (int j = 0; j < 3; j++) {\n            if (ff[j] == v) {\n                swap(ff[j], ff[1]);\n                break;\n            }\n        }\n        ans.push_back(ff);\n    }\n    reverse(ans.begin(), ans.end());\n    for (int i = 1; i <= n; i++) {\n        p[i] = i;\n    }\n    p[ans[0][0]] = nt[ans[0][0]] = ans[0][2];\n    p[ans[0][2]] = nt[ans[0][2]] = ans[0][0];\n    for (int i = 0; i < n-2; i++) {\n        ll mid = ans[i][1];\n        ll l = ans[i][0];\n        ll r = ans[i][2];\n        if (nt[l] != r) {\n            swap(l, r);\n        }\n        nt[l] = mid;\n        nt[mid] = r;\n    }\n    ll x = 1;\n    do {\n        cout << x << "" "";\n        x = nt[x];\n    } while (x != 1);\n    cout << ""\\n"";\n    for (auto x : ans1) {\n        cout << x << "" "";\n    }\n    cout << ""\\n"";\n\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n\n    return 0;\n}']","['constructive algorithms', 'data structures', 'dfs and similar', 'graphs']",2400
https://codeforces.com//contest/356/problem/C,C. Compartments,A team of students from the city S is sent to the All Berland Olympiad in Informatics Traditionally they go on the train All students have bought tickets in one carriage consisting of compartments each compartment has exactly four people We know that if one compartment contain one or two students then they get bored and if one compartment contain three or four students then the compartment has fun throughout the entire trip The students want to swap with other people so that no compartment with students had bored students To swap places with another person you need to convince him that it is really necessary The students can not independently find the necessary arguments so they asked a sympathetic conductor for help The conductor can use her life experience to persuade any passenger to switch places with some student However the conductor does not want to waste time persuading the wrong people so she wants to know what is the minimum number of people necessary to persuade her to change places with the students Your task is to find the number After all the swaps each compartment should either have no student left or have a company of three or four students ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nint start[42], finish[42];\nint dstart[42], dfinish[42];\nint c[42], d[42];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i <= 4; i++) c[i] = 0;\n  int tot = 0;\n  for (int i = 0; i < n; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    c[foo]++;\n    tot += foo;\n  }\n  int sum = 0;\n  for (int i = 4; i >= 0; i--) {\n    start[i] = sum + 1;\n    finish[i] = sum + c[i];\n    sum += c[i];\n  }\n  int ans = inf;\n  for (int k4 = 0; 4 * k4 <= tot; k4++) {\n    int k3 = (tot - 4 * k4);\n    if (k3 % 3 != 0) continue;\n    k3 /= 3;\n    if (k4 + k3 > n) continue;\n    for (int i = 0; i <= 4; i++) d[i] = 0;\n    d[4] = k4;\n    d[3] = k3;\n    d[0] = n - k4 - k3;\n    int sum = 0;\n    for (int i = 4; i >= 0; i--) {\n      dstart[i] = sum + 1;\n      dfinish[i] = sum + d[i];\n      sum += d[i];\n    }\n    int cur = 0;\n    for (int i = 0; i <= 4; i++)\n      for (int j = 0; j <= 4; j++) {\n        int low = start[i];\n        if (dstart[j] > low) low = dstart[j];\n        int high = finish[i];\n        if (dfinish[j] < high) high = dfinish[j];\n        if (low <= high) {\n          int diff = i - j;\n          if (diff < 0) diff = -diff;\n          cur += (high - low + 1) * diff;\n        }\n      }\n    cur /= 2;\n    if (cur < ans) ans = cur;\n  }\n  printf(""%d\\n"", ans == inf ? -1 : ans);\n  return 0;\n}\n']","['combinatorics', 'constructive algorithms', 'greedy', 'implementation']",2100
https://codeforces.com//contest/434/problem/C,C. Tachibana Kanade s Tofu,Tachibana Kanade likes Mapo Tofu very much One day the canteen cooked all kinds of tofu to sell but not all tofu is Mapo Tofu only those spicy enough can be called Mapo Tofu Each piece of tofu in the canteen is given a based number all numbers are in the range and being based numbers and for every based integer in the range there exists a piece of tofu with that number To judge what tofu is Mapo Tofu Tachibana Kanade chose based number strings and assigned a value to each string If a string appears in the number of a tofu the value of the string will be added to the value of that tofu If a string appears multiple times then the value is also added that many times Initially the value of each tofu is zero Tachibana Kanade considers tofu with values no more than to be Mapo Tofu So now Tachibana Kanade wants to know how many pieces of tofu are Mapo Tofu ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 200 + 10;\nconst int MAX_M = 20 + 1;\nconst int MAX_K = 500 + 10;\nconst int MOD = 1000000007;\nint n, m, k;\n\nconst int CHARSET = 20;\nconst int MAX_N_NODES = int(3e5) + 10;\n\nint pointer;\nstruct Node {\n\tNode*ch[CHARSET], *fail, *par;\n\tNode*jump[CHARSET];\n\n\tint end;\n\tNode() {\n\t\tmemset(ch, 0, sizeof ch);\n\t\tfail = 0;\n\t\tend = 0;\n\t}\n\tNode*go(int w);\n}*root;\n\nNode nodePool[MAX_N_NODES], *cur;\nconst int MAX_ID = 400 + 10;\n\nint getId(Node*u) {\n\treturn u - nodePool;\n}\n\nNode*newNode() {\n\tNode*t = cur++;\n\tmemset(t->ch, 0, sizeof t->ch);\n\tt->fail = 0;\n\treturn t;\n}\n\nNode* Node::go(int w) {\n\tif (ch[w] == 0) {\n\t\tch[w] = newNode();\n\t\tch[w]->par = this;\n\t}\n\treturn ch[w];\n}\n\nvoid init() {\n\tcur = nodePool;\n\troot = newNode();\n\troot->par = 0;\n}\n\nvoid build() {\n\tstatic Node*que[MAX_N_NODES];\n\tint qh = 0, qt = 0;\n\tque[qt++] = root;\n\twhile (qh < qt) {\n\t\tNode*t = que[qh++];\n\t\tfor (int c = 0; c < CHARSET; ++c) {\n\t\t\tNode*v = t->ch[c];\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tNode*f = t->fail;\n\t\t\twhile (f && f->ch[c] == 0)\n\t\t\t\tf = f->fail;\n\t\t\tif (f == 0)\n\t\t\t\tv->fail = root;\n\t\t\telse\n\t\t\t\tv->fail = f->ch[c];\n\t\t\tque[qt++] = v;\n\t\t}\n\t}\n\t//calculate JUMP\n\tfor (int j = 0; j < m; ++j) {\n\t\troot->jump[j] = root->ch[j] ? root->ch[j] : root;\n//\t\tif (root->jump[j] == 0)\n//\t\t\troot->jump[j] = root;\n\t}\n\n\tfor (int i = 1; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (u->ch[j])\n\t\t\t\tu->jump[j] = u->ch[j];\n\t\t\telse\n\t\t\t\tu->jump[j] = u->fail->jump[j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tif (u->fail)\n\t\t\tu->end += u->fail->end;\n\t}\n}\n\nvector<int> L, R;\n\nvector<int> str[MAX_N];\nint v[MAX_N];\n\nvoid read(vector<int>&arr) {\n\tint n;\n\tcin >> n;\n\tarr.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i];\n\t}\n}\n\nint memo[202][410][501];\n\nint rec(int at, bool leadingZero, bool sameL, bool sameR, Node*u, int have) {\n\thave += u->end;\n\tif (have > k)\n\t\treturn 0;\n\n\tif (at == L.size()) {\n\t\treturn 1;\n\t}\n\n\tbool save = !(sameL || sameR);\n\tint ret = 0;\n\tif (save) {\n\t\tret = memo[at][getId(u)][have];\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t\tret = 0;\n\t}\n\n\tfor (int nxt = 0; nxt < m; ++nxt) { //nxt digit\n\t\tif (sameL && nxt < L[at])\n\t\t\tcontinue;\n\t\tif (sameR && nxt > R[at])\n\t\t\tcontinue;\n\t\tNode*nu = u;\n\t\tif (!leadingZero || nxt > 0)\n\t\t\tnu = u->jump[nxt];\n\n\t\tret += rec(at + 1, leadingZero && (nxt == 0), sameL && (nxt == L[at]),\n\t\t\t\tsameR && (nxt == R[at]), nu, have);\n\t\tif (ret >= MOD)\n\t\t\tret -= MOD;\n\t}\n\n\tif (save) {\n\t\tmemo[at][getId(u)][have] = ret;\n\t}\n\n\treturn ret;\n}\n\nint main() {\n//\tcout << sizeof(memo) / (1024 * 1024.0) << endl;\n\tcin >> n >> m >> k;\n\tread(L), read(R);\n\twhile (L.size() < R.size())\n\t\tL.insert(L.begin(), 0);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tread(str[i]);\n\t\tcin >> v[i];\n\t}\n\tinit();\n\tfor (int i = 0; i < n; ++i) {\n\t\tNode*u = root;\n\t\tfor (int j = 0; j < str[i].size(); ++j) {\n\t\t\tu = u->go(str[i][j]);\n\t\t}\n\t\tu->end += v[i];\n\t}\n\tbuild();\n\tmemset(memo, -1, sizeof memo);\n\tint ans = rec(0, true, true, true, root, 0);\n\tcout << ans << endl;\n}\n']",['dp'],2500
https://codeforces.com//contest/1213/problem/F,F. Unstable String Sort,Authors have come up with the string s consisting of n lowercase Latin letters You are given two permutations of its indices not necessary equal p and q both of length n Recall that the permutation is the array of length n which contains each integer from 1 to n exactly once For all i from 1 to n 1 the following properties hold s p i le s p i 1 and s q i le s q i 1 It means that if you will write down all characters of s in order of permutation indices the resulting string will be sorted in the non decreasing order Your task is to restore such string s of length n consisting of which suits the given permutations If there are multiple answers you can print any of them ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint p[N], q[N], idx[N];\n\nint dsu[N], rmax[N];\n\nint root(int u) {\n    return ((u == dsu[u]) ? u : dsu[u] = root(dsu[u]));\n}\n\nvoid uni(int u,int v) {\n    u = root(u), v = root(v);\n    if(u == v) return;\n    dsu[v] = u;\n}\n\nvoid connect(int i1,int i2) {\n    while(i2 > i1) {\n        uni(i2 - 1, i2);\n        i2 = dsu[i2];\n    }\n}\n\nchar val[N], ans[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n, k;\n    cin >> n >> k;\n    fr(i, 1, n) {\n        dsu[i] = i;\n    }\n    fr(i, 1, n) {\n        cin >> p[i];\n        idx[p[i]] = i;\n    }\n    fr(i, 1, n) {\n        cin >> q[i];\n    }\n    fr(i, 1, n - 1) {\n        int i1 = idx[q[i]], i2 = idx[q[i + 1]];\n        if(i2 < i1) {\n            connect(i2, i1);\n        }\n    }\n    int c = 0;\n    char ch = \'a\';\n    fr(i ,1, n) {\n        if(dsu[i] == i) {\n            c++;\n            val[i] = ch;\n            if(ch < \'z\') ch++;\n        }\n    }\n    if(c < k) {\n        cout << ""NO"";\n        return 0;\n    }\n    fr(i, 1, n) {\n        ans[p[i]] = val[root(i)];\n    }\n    cout << ""YES"" << endl;\n    fr(i, 1, n) {\n        cout << ans[i];\n    }\n    return 0;\n}']","['data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'strings']",2100
https://codeforces.com//contest/1598/problem/G,G. The Sum of Good Numbers,Let s call a positive integer if there is no digit in its decimal representation For an array of a numbers a one found out that the sum of some two neighboring elements is equal to x i e x a i a i 1 for some i x had turned out to be a number as well Then the elements of the array a were written out one after another without separators into one string s For example if a 12 5 6 133 then s 1256133 You are given a string s and a number x Your task is to determine the positions in the string that correspond to the adjacent elements of the array that have sum x If there are several possible answers you can print any of them ,"['/**\n *    author:  tourist\n *    created: 10.10.2021 12:49:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nvector<int> z_function(int n, const T &s) {\n  vector<int> z(n, n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; i++) {\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\n\ntemplate <typename T>\nvector<int> z_function(const T &s) {\n  return z_function((int) s.size(), s);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s_;\n  cin >> s_;\n  string x_;\n  cin >> x_;\n  int n = (int) s_.size();\n  int m = (int) x_.size();\n  vector<int> s(n);\n  for (int i = 0; i < n; i++) {\n    s[i] = (int) (s_[i] - \'0\');\n  }\n  vector<int> x(m);\n  for (int i = 0; i < m; i++) {\n    x[i] = (int) (x_[i] - \'0\');\n  }\n  vector<int> seq = x;\n  seq.insert(seq.end(), s.begin(), s.end());\n  auto z = z_function(seq);\n  auto Check = [&](int l1, int r1, int l2, int r2) {\n    int i = r1;\n    int j = r2;\n    int c = 0;\n    for (int q = m - 1; q >= 0; q--) {\n      if (i >= l1) {\n        c += s[i];\n        i -= 1;\n      }\n      if (j >= l2) {\n        c += s[j];\n        j -= 1;\n      }\n      int nc = 0;\n      if (c >= 10) {\n        c -= 10;\n        nc = 1;\n      }\n      if (x[q] != c) {\n        return;\n      }\n      c = nc;\n    }\n    if (c != 0 || i >= l1 || j >= l2) {\n      return;\n    }\n    cout << l1 + 1 << "" "" << r1 + 1 << \'\\n\';\n    cout << l2 + 1 << "" "" << r2 + 1 << \'\\n\';\n    exit(0);\n  };\n  {\n    mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n    while (true) {\n      md = (int) 1e8 + rng() % (int) 9e8;\n      bool pr = true;\n      for (int i = 2; i * i <= md; i++) {\n        if (md % i == 0) {\n          pr = false;\n          break;\n        }\n      }\n      if (pr) {\n        break;\n      }\n    }\n  }\n  vector<Mint> p10(n + 1);\n  p10[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    p10[i] = p10[i - 1] * 10;\n  }\n  Mint inv_10 = 1 / Mint(10);\n  vector<Mint> inv_p10(n + 1);\n  inv_p10[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    inv_p10[i] = inv_p10[i - 1] * inv_10;\n  }\n  vector<Mint> suf(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suf[i] = suf[i + 1] + p10[n - 1 - i] * s[i];\n  }\n  vector<pair<int, int>> all_suf(n + 1);\n  for (int i = 0; i <= n; i++) {\n    all_suf[i] = make_pair(suf[i](), i);\n  }\n  sort(all_suf.begin(), all_suf.end());\n/*  vector<Mint> pref(n + 1);\n  for (int i = 0; i < n; i++) {\n    pref[i + 1] = pref[i] * 10 + s[i];\n  }\n  vector<pair<int, int>> all_pref(n + 1);\n  for (int i = 0; i <= n; i++) {\n    all_pref[i] = make_pair(pref[i](), i);\n  }\n  sort(all_pref.begin(), all_pref.end());*/\n  Mint x_val = 0;\n  for (int i = 0; i < m; i++) {\n    x_val = x_val * 10 + x[i];\n  }\n  for (int k = m; k >= m - 1 && k >= 1; k--) {\n    for (int i = 0; i <= n - k; i++) {\n      Mint me = (suf[i] - suf[i + k]) * inv_p10[n - (i + k)];\n      Mint goal = x_val - me;\n      { // pref[j] - pref[i + k] * p10[j - (i + k)] == goal\n        // pref[j] * inv_p10[j] - pref[i + k] * inv_p10[i + k] == goal * inv_p10[j]\n        // (suf[i + k] - suf[j]) * inv_p10[n - j] == goal\n        // (suf[i + k] - suf[j]) * inv_p10[n - j] + (suf[i] - suf[i + k]) * inv_p10[n - (i + k)] == x_val\n        // sad...\n        auto Test = [&](int len) {\n          if (len >= 1 && len <= m) {\n            int j = i + k + len;\n            if (j <= n) {\n              if ((suf[i + k] - suf[j]) * inv_p10[n - j] == goal) {\n                Check(i, i + k - 1, i + k, j - 1);\n              }\n            }\n          }\n        };\n        if (k == m - 1) {\n          Test(m - 1);\n          Test(m);\n        } else {\n          int match = min(m, z[m + i]);\n          Test(m - match);\n          Test(m - match - 1);\n        }\n      }\n      { // (suf[j] - suf[i]) * inv_p10[n - i] == goal\n        Mint needle = goal * p10[n - i] + suf[i];\n        auto it = lower_bound(all_suf.begin(), all_suf.end(), make_pair(needle(), -1));\n        while (it != all_suf.end() && it->first == needle) {\n          int j = it->second;\n          if (j < i && i - j <= m) {\n            Check(j, i - 1, i, i + k - 1);\n          }\n          ++it;\n        }\n      }\n    }\n  }\n  assert(false);\n  return 0;\n}\n']","['hashing', 'math', 'string suffix structures', 'strings']",3200
https://codeforces.com//contest/915/problem/C,C. Permute Digits,You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>haveInt;\nvector<int>need;\nvector<int>answer;\n\nvoid prnt() {\n\tfor (auto x : answer)cout << x;\n\texit(0);\n}\n\nvoid formAll() {\n\twhile (!haveInt.empty()) {\n\t\tmap<int, int>::iterator it = haveInt.end();\n\t\tit--;\n\t\tanswer.push_back(it->first);\n\t\tit->second -= 1;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t}\n\tprnt();\n}\n\nvoid tryNum(int a) {\n\tif (haveInt.size()==0)\n\t\tprnt();\n\tmap<int, int>::iterator it = haveInt.lower_bound(need[a]);\n\tif (it != haveInt.end() && it->first == need[a]) {\n\t\tint x = it->first;\n\t\tit->second--;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t\tanswer.push_back(x);\n\t\ttryNum(a + 1);\n\t\thaveInt[x]++;\n\t\tanswer.pop_back();\n\t}\n\tit = haveInt.lower_bound(need[a]);\n\tif (it == haveInt.begin())return;\n\tit--;\n\tanswer.push_back(it->first);\n\tit->second--;\n\tif (it->second == 0)\n\t\thaveInt.erase(it);\n\tformAll();\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tswap(s1, s2);\n\tfor (auto x : s2)\n\t\thaveInt[x - \'0\']++;\n\tif (s2.length() < s1.length())\n\t\tformAll();\n\tfor (auto x : s1)\n\t\tneed.push_back(x - \'0\');\n\ttryNum(0);\n\n\t\n\treturn 0;\n}']","['dp', 'greedy']",1700
https://codeforces.com//contest/1520/problem/F2,F2. Guess the K-th Zero  Hard version ,Polycarp is playing a computer game In this game an array consisting of zeros and ones is hidden Polycarp wins if he guesses the position of the k th zero from the left t times Polycarp can make no more than 6 cdot 10 4 requests totally of the following type l r find out the sum of all elements in positions from l to r 1 le l le r le n inclusive To make the game more interesting each guessed zero turns into one and the game continues on the changed array More formally if the position of the k th zero was x then after Polycarp guesses this position the x th element of the array will be replaced from 0 to 1 Help Polycarp win the game ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n#define sz(x) int((x).size())\n\nconst int bsize = 16;\n\nint n;\nrt<int> used;\nvector<array<int, 3>> cache;\n\nint query(int l, int r) {\n\tcout << ""? "" << l + 1 << "" "" << r + 1 << endl;\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nvoid pcache() {\n\tfor(int i = 0; i < n; i += bsize) {\n\t\tint r = min(n, i + bsize) - 1;\n\t\tcache.push_back({i, r, query(0, r)});\n\t}\n}\n\nint solve(int k) {\n\tint l = 0, r = sz(cache) - 1;\n\tauto get = [&](int x) {\n\t\tint ret = cache[x][2];\n\t\tret = (cache[x][1] - 0 + 1) - ret;\n\t\tret -= used.order_of_key(cache[x][1] + 1);\n\t\treturn ret;\n\t};\n\twhile(l < r) {\n\t\tint mid = (l + r) / 2;\n\t\tif(k < get(mid)) {\n\t\t\tr = mid;\n\t\t}else {\n\t\t\tl = mid + 1;\n\t\t}\n\t}\n\tauto[cl, cr, _] = cache[l];\n\tif(l) {\n\t\tk -= get(l - 1);\n\t}\n\tdbg(k);\n\tint bl = cl, br = cr;\n\twhile(bl < br) {\n\t\tint mid = (bl + br) / 2;\n\t\tint ccnt = query(cl, mid);\n\t\tccnt = (mid - cl + 1) - ccnt;\n\t\tif(k < ccnt) {\n\t\t\tbr = mid;\n\t\t}else {\n\t\t\tbl = mid + 1;\n\t\t}\n\t}\n\treturn bl;\n}\n\nvoid solve() {\n\tint t;\n\tcin >> n >> t;\n\twhile(t--) {\n\t\tint k;\n\t\tcin >> k;\n\t\tif(cache.empty()) {\n\t\t\tdbg(""caches"");\n\t\t\tpcache();\n\t\t\tdbg(""cachee"");\n\t\t}\n\t\tk--;\n\t\tint ans = solve(k);\n\t\tused.insert(ans);\n\t\tcout << ""! "" << ans + 1 << endl;\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tint t = 1;\n//\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']","['binary search', 'constructive algorithms', 'data structures', 'interactive']",2200
https://codeforces.com//contest/574/problem/B,B. Bear and Three Musketeers,Do you know a story about the three musketeers Anyway you will learn about its origins now Richelimakieu is a cardinal in the city of Bearis He is tired of dealing with crime by himself He needs three brave warriors to help him to fight against bad guys There are warriors Richelimakieu wants to choose three of them to become musketeers but it s not that easy The most important condition is that musketeers must know each other to cooperate efficiently And they shouldn t be too well known because they could be betrayed by old friends For each musketeer his is the number of warriors he knows excluding other two musketeers Help Richelimakieu Find if it is possible to choose three musketeers knowing each other and what is minimum possible sum of their recognitions ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vpi> vvpi;\n\nint main(){\n  vvi T(4000,vi(4000,0));\n  int n,m;\n  cin>>n>>m;\n  vvi G(n);\n  vi P(n,0);\n  for(int i = 0;i < m;++i){\n    int x,y;\n    cin>>x>>y;\n    --x;\n    --y;\n    T[x][y] = T[y][x] = 1;\n    P[x]++;\n    P[y]++;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  int r = 4000;\n  for(int i = 0;i < n;++i){\n    for(int j = 0;j < G[i].size();++j){\n      for(int w = j+1;w < G[i].size();++w){\n\tint x = G[i][j];\n\tint y = G[i][w];\n\tif(T[x][y]){\n\t  r = min(r,P[i]+P[x]+P[y]-6);\n\t}\n      }\n    }\n  }\n  if(r == 4000) cout<<-1<<endl;\n  else cout<<r<<endl;\n}']","['brute force', 'dfs and similar', 'graphs', 'hashing']",1500
https://codeforces.com//contest/609/problem/E,E. Minimum spanning tree for each edge,Connected undirected weighted graph without self loops and multiple edges is given Graph contains vertices and edges For each edge find the minimal possible weight of the spanning tree that contains the edge The weight of the spanning tree is the sum of weights of all edges included in spanning tree ,"['/*\nTake me back\nBack to the scene\nIt\'s coming back\nI remember her screams\n\nThe fear in her eye\nThe night she died\nIt left me empty\nHollow inside\n\nDead to the world\nI see only black\nThere\'s blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n\nFeelings deep inside\nI don\'t understand\nCan\'t fall asleep at night\nI try and wake in fright\n\nTouch of her skin\nNext to mine\nWarm and wet\nDeep inside\n\nDead to the world\nI see only black\nThere\'s blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n\nI wrapped my hands around her neck\nSqueezing out her breath\nEyes rolled back in her head\nClawing at my skin\nI know now it\'s not my fault\nShe was asking for it\n\nMemories\nCame back to me\nIn the night\n\nI hear her screams\nWaiting\nIn the grave\nCalling out\n\nCome to me\nI hear her screaming\nWaiting in the grave\nCalling out but she\'s buried\n\nWaiting in the grave\nCome to me\nI hear her screaming\nWaiting\n\nI wrapped my hands around her neck\nSqueezing out her breath\nEyes rolled back in her head\nClawing at my skin\nI know now it\'s not my fault\nShe was asking for it\n\nMemories\nCame back to me\nIn the night\n\nI hear her screams\nWaiting\nIn the grave\nCalling out\n\nI remember her screams\nThe night she died\nI left her empty\nHollow inside\n\nDead to the world\nI see only black\nThere\'s blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nconst int l = 17;\n\nusing namespace std;\n\nint n, m;\nvector<pair<int, int> > g[N];\nvector<pair<int, pair<int, int> > > edges, edges2,mst;\nint w[N];\nlong long COST;\nint timer;\nint up[N][l + 1];\nint bedge[N][l + 1];\nint tin[N];\nint tout[N];\nint dep[N];\n\nvoid dfs(int v, int p = 1,int pcost=0)\n{\n\ttin[v] = timer;\n\t++timer;\n\tup[v][0] = p;\n\tbedge[v][0] = pcost;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tup[v][i] = up[up[v][i - 1]][i - 1];\n\t\tbedge[v][i] = max(bedge[v][i - 1], bedge[up[v][i-1]][i - 1]);\n\t}\n\tfor (int i = 0; i < g[v].size(); i++)\n\t{\n\t\tint to = g[v][i].first;\n\t\tint cost = g[v][i].second;\n\t\tif (to == p)\n\t\t\tcontinue;\n\t\tdep[to] = dep[v] + 1;\n\t\tdfs(to, v, cost);\n\t}\n\ttout[v] = timer;\n\t++timer;\n}\n\nbool upper(int a, int b)\n{\n\treturn (tin[a] <= tin[b] && tout[a] >= tout[b]);\n}\n\nint lca(int a, int b)\n{\n\tif (upper(a, b))\n\t\treturn a;\n\tif (upper(b, a))\n\t\treturn b;\n\tfor (int i = l; i >= 0; --i)\n\t{\n\t\tif (!upper(up[a][i], b))\n\t\t\ta = up[a][i];\n\t}\n\treturn up[a][0];\n}\n\nint get(int x)\n{\n\tif (x == w[x])\n\t\treturn x;\n\treturn w[x] = get(w[x]);\n}\n\nvoid merge(int a, int b)\n{\n\tif (rand() % 2)\n\t\tswap(a, b);\n\ta = get(a);\n\tb = get(b);\n\tw[a] = b;\n}\n\nint get_best(int v, int span)\n{\n\tint ret = 0;\n\tfor (int i = l; i >= 0; --i)\n\t{\n\t\tif (span&(1 << i))\n\t\t{\n\t\t\tret = max(ret, bedge[v][i]);\n\t\t\tv = up[v][i];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tedges.push_back(make_pair(c, make_pair(a, b)));\n\t\tedges2.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(edges.begin(), edges.end());\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tw[i] = i;\n\t}\n\n\tfor (int i = 0; i < edges.size(); i++)\n\t{\n\t\tint a, b, c;\n\t\ta = edges[i].second.first;\n\t\tb = edges[i].second.second;\n\t\tint ta, tb;\n\t\tc = edges[i].first;\n\t\tta = get(a);\n\t\ttb = get(b);\n\t\tif (ta == tb)\n\t\t\tcontinue;\n\t\tmerge(ta, tb);\n\t\tmst.push_back(make_pair(c, make_pair(a, b)));\n\t\tCOST += c;\n\t}\n\n\tfor (int i = 0; i < mst.size(); i++)\n\t{\n\t\tint v1 = mst[i].second.first;\n\t\tint v2 = mst[i].second.second;\n\t\tint cost = mst[i].first;\n\t\tg[v1].push_back(make_pair(v2, cost));\n\t\tg[v2].push_back(make_pair(v1, cost));\n\t}\n\t\n\tdfs(1);\n\n\tfor (int i = 0; i < edges2.size(); i++)\n\t{\n\t\tint v1 = edges2[i].second.first;\n\t\tint v2 = edges2[i].second.second;\n\t\tint L = lca(v1, v2);\n\t\tint bst = 0;\n\t\tbst = max(bst, get_best(v1, dep[v1] - dep[L]));\n\t\tbst = max(bst, get_best(v2, dep[v2] - dep[L]));\n\t\tcout << COST + edges2[i].first - bst << ""\\n"";\n\t}\n\n\tcin.get();cin.get();\n\n\treturn 0;\n}']","['data structures', 'dfs and similar', 'dsu', 'graphs', 'trees']",2100
https://codeforces.com//contest/181/problem/D,D. Word Cut,Let s consider one interesting word game In this game you should transform one word into another through special operations Let s say we have word let s split this word into two non empty parts and so that A operation is transforming word into word For example a operation can transform word into word You are given two words and Count in how many ways we can transform word into word if we apply exactly operations consecutively to word Two ways are considered different if the sequences of applied operations differ Two operation sequences are different if exists such number that in the th operation of the first sequence the word splits into parts and in the th operation of the second sequence the word splits into parts and and additionally holds ,"['#include<cstdio>s\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long i64;\ntypedef unsigned long long ui64;\n\nconst int intINF=999999999;\nconst i64 i64INF=99999999999999999ll;\nconst double doubleINF=9999999999.;\n\nusing namespace std;\n\nint al,bl;\nchar A[1111],B[1111];\ni64 res=0,md=1000000007;\ni64 F[3][100011];\n\nbool eq(int p){\n\tbool eqq=true;\n\tfor(int i=0;i<al;i++)\n\t\tif(A[(p+i)%al]!=B[i]) eqq=false;\n\treturn eqq;\n}\n\nint main(){\n\tchar c;\n\twhile(scanf(""%c"",&c),c!=\'\\n\') A[al++]=c;\n\twhile(scanf(""%c"",&c),c!=\'\\n\') B[bl++]=c;\n\tint k,cc;\n\tscanf(""%d"",&k);\n\tF[0][0]=1;\n\tF[1][0]=0;\n\tF[2][0]=1;\n\tfor(int i=1;i<=k;i++){\n\t\tF[0][i]=F[2][i-1]-F[0][i-1]; if(F[0][i]<0) F[0][i]+=md;\n\t\tF[1][i]=F[2][i-1]-F[1][i-1]; if(F[1][i]<0) F[1][i]+=md;\n\t\tF[2][i]=(F[0][i]+(al-1)*F[1][i])%md;\n\t}\n\tfor(int i=0;i<al;i++)\n\t\tif(eq(i)){\n\t\t\tif(i==0) cc=0;\n\t\t\telse cc=1;\n\t\t\tres+=F[cc][k];\n\t\t\tres%=md;\n\t\t}\n\tprintf(""%I64d\\n"",res);\n\treturn 0;\n}\n']",['dp'],1700
https://codeforces.com//contest/276/problem/E,E. Little Girl and Problem on Trees,A little girl loves problems on trees very much Here s one of them A tree is an undirected connected graph not containing cycles The degree of node in the tree is the number of nodes of the tree such that each of them is connected with node by some edge of the tree Let s consider a tree that consists of nodes We ll consider the tree s nodes indexed from 1 to The cosidered tree has the following property each node except for node number 1 has the degree of at most 2 Initially each node of the tree contains number 0 Your task is to quickly process the requests of two types Request of form In reply to the request you should add to all numbers that are written in the nodes that are located at the distance of at most from node The distance between two nodes is the number of edges on the shortest path between them Request of form In reply to the request you should print the current number that is written in node ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 200010\nint he[N],ne[N*2],ad[N*2],d[N],n,m,st[N],le[N],bl[N],w[N],a[N],L,S1;\nint f[N*2],g[N];\nvoid addE(int x,int y)\n{\n    static int t=0;\n    ++t,ne[t]=he[x],he[x]=t,ad[t]=y;\n    ++t,ne[t]=he[y],he[y]=t,ad[t]=x;\n}\ninline int lb(int x){return x&(x^(x-1));}\nvoid add(int *f,int n,int x,int y)\n{\n    x=n-x+1;\n    while(x<=n)f[x]+=y,x+=lb(x);\n}\nint ask(int *f,int n,int x)\n{\n    x=n-x+1;\n    int S=0;\n    while(x>0)S+=f[x],x-=lb(x);\n    return S;\n}\nint main()\n{\n    scanf(""%d%d"",&n,&m);\n    for(int i=1,x,y;i<n;i++)\n        scanf(""%d%d"",&x,&y),addE(x,y);\n    int la=0;\n    for(int p=he[1];p;p=ne[p])\n    {\n        int c=ad[p];\n        st[L]=la;bl[c]=L,w[c]=la,a[la++]=c;le[L]=1;\n        int law=1;\n        while(true)\n        {\n            bool F=1;\n            for(int p=he[c];p;p=ne[p])\n                if(ad[p]!=law)\n                {\n                    int d=ad[p];law=c;c=d;\n                    le[L]++;w[c]=la,a[la++]=c;bl[c]=L;\n                    F=0;\n                    break;\n                }\n            if(F)break;\n        }\n        L++;la++;\n    }\n    for(int i=2;i<=n;i++)d[i]=w[i]-st[bl[i]]+1;\n    //for(int i=1;i<=n;i++)printf(""%d %d\\n"",i,d[i]);\n    /*\n    for(int i=0;i<L;i++)\n        for(int j=st[i];j<st[i]+le[i];j++)\n            printf(""%d%c"",a[j],j==st[i]+le[i]-1?\'\\n\':\' \');\n    */\n    while(m--)\n    {\n        int z;scanf(""%d"",&z);\n        if(z==0)\n        {\n            int x,y;scanf(""%d%d%d"",&x,&y,&z);\n            if(z>=d[x])S1+=y;\n            if(z>d[x])add(g,n,z-d[x],y);\n            int l=max(d[x]-z,1),r=min(d[x]+z,le[bl[x]]);\n            add(f+st[bl[x]],le[bl[x]],l-1,-y);\n            add(f+st[bl[x]],le[bl[x]],r,y);\n            if(z>d[x])add(f+st[bl[x]],le[bl[x]],min(z-d[x],le[bl[x]]),-y);\n        }else\n        if(z==1)\n        {\n            int x;scanf(""%d"",&x);\n            if(x==1){printf(""%d\\n"",S1);continue;}\n            printf(""%d\\n"",ask(g,n,d[x])+ask(f+st[bl[x]],le[bl[x]],d[x]));\n        }\n    }\n    return 0;\n}']","['data structures', 'graphs', 'trees']",2100
https://codeforces.com//contest/29/problem/A,A. Spit Problem,In a Berland s zoo there is an enclosure with camels It is known that camels like to spit Bob watched these interesting animals for the whole day and registered in his notepad where each animal spitted Now he wants to know if in the zoo there are two camels which spitted at each other Help him to solve this task The trajectory of a camel s spit is an arc i e if the camel in position spits meters right he can hit only the camel in position if such a camel exists ,"['/*\nID: espr1t\nLANG: C++\nTASK: Demo\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 1024\n\nusing namespace std;\nFILE *in; FILE *out;\n\nint n;\nint a[MAX][2];\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(""A.in"", ""rt""); out = fopen(""A.out"", ""wt"");\n\t\n\tfscanf(in, ""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tfscanf(in, ""%d %d"", &a[i][0], &a[i][1]);\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int c = 0; c < n; c++)\n\t\t\tif (a[i][0] + a[i][1] == a[c][0])\n\t\t\t\tif (a[c][0] + a[c][1] == a[i][0])\n\t\t\t\t\tans = 1;\n\tfprintf(out, ""%s\\n"", ans ? ""YES"" : ""NO"");\n\t\n\treturn 0;\n}\n']",['brute force'],1000
https://codeforces.com//contest/1451/problem/C,C. String Equality,Ashish has two strings a and b each of length n and an integer k The strings only contain lowercase English letters He wants to convert string a into string b by performing some possibly zero operations on a In one move he can either choose an index i 1 leq i leq n 1 and swap a i and a i 1 or choose an index i 1 leq i leq n k 1 and if a i a i 1 ldots a i k 1 are to some character c c neq replace each one with the next character c 1 that is is replaced by is replaced by and so on Note that he can perform any number of operations and the operations can only be performed on string a Help Ashish determine if it is possible to convert string a into b after performing some possibly zero operations on it ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nint ca[30];\nint cb[30];\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tint n,k; cin>>n>>k;\n\t\tmemset(ca,0,sizeof(ca));\n\t\tmemset(cb,0,sizeof(cb));\n\t\tstring a,b; cin>>a>>b;\n\t\tfor(char c:a)\n\t\t{\n\t\t\tca[c-\'a\']++;\n\t\t}\n\t\tfor(char c:b)\n\t\t{\n\t\t\tca[c-\'a\']--;\n\t\t}\n\t\tbool pos=1;\n\t\tfor(int i=0;i<25;i++)\n\t\t{\n\t\t\twhile(ca[i]>=k)\n\t\t\t{\n\t\t\t\tca[i]-=k; ca[i+1]+=k;\n\t\t\t}\n\t\t\tif(ca[i]<0){pos=0; break;}\n\t\t}\n\t\tif(ca[25]<0) pos=0;\n\t\tif(pos) cout<<""Yes\\n"";\n\t\telse cout<<""No\\n"";\n\t}\n}\n']","['dp', 'greedy', 'hashing', 'implementation', 'strings']",1400
https://codeforces.com//contest/624/problem/B,B. Making a String,You are given an alphabet consisting of letters your task is to make a string of the maximum possible length so that the following conditions are satisfied the th letter occurs in the string no more than times the number of occurrences of each letter in the string must be for all the letters that occurred in the string at least once ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\n\nint n, a[30];\nint main()  {\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++)scanf(""%d"",&a[i]);\n\tsort(a+1,a+1+n);\n\tlong long ans=a[n];\n\tfor (int i=n-1;i>0;i --){\n\t\twhile (a[i] != 0 && a[i] >= a[i + 1]) {\n\t\t\ta[i] --;\n\t\t}\n\t\tans+=a[i];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}']","['greedy', 'sortings']",1100
https://codeforces.com//contest/723/problem/B,B. Text Document Analysis,Modern text editors usually show some information regarding the document being edited For example the number of words the number of pages or the number of characters In this problem you should implement the similar functionality You are given a string which only consists of uppercase and lowercase English letters underscore symbols they are used as separators parentheses both opening and closing It is guaranteed that each opening parenthesis has a succeeding closing parenthesis Similarly each closing parentheses has a preceding opening parentheses matching it For each pair of matching parentheses there are no other parenthesis between them In other words each parenthesis in the string belongs to a matching opening closing pair and such pairs can t be nested For example the following string is valid is a maximal sequence of consecutive letters i e such sequence that the first character to the left and the first character to the right of it is an underscore a parenthesis or it just does not exist For example the string above consists of seven words and Write a program that finds the length of the longest word outside the parentheses print if there is no word outside the parentheses the number of words inside the parentheses print if there is no word inside the parentheses ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tstring st, cur;\n\tcin >> st;\n\tint inp(0);\n\tint ans1(0), ans2(0);\n\tst.push_back('(');\n\tfor(int i(0); i < (int)st.size(); i++) {\n\t\tif(st[i] == '_' || st[i] == '(' || st[i] == ')') {\n\t\t\tif(!cur.empty()) {\n\t\t\t\tif(inp) {\n\t\t\t\t\tans2++;\n\t\t\t\t}else {\n\t\t\t\t\tans1 = max(ans1, (int)cur.size());\n\t\t\t\t}\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t\tif(st[i] == '(') {\n\t\t\t\tinp = true;\n\t\t\t}else if(st[i] == ')') {\n\t\t\t\tinp = false;\n\t\t\t}\n\t\t}else {\n\t\t\tcur.push_back(st[i]);\n\t\t}\n\t}\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n""]","['expression parsing', 'implementation', 'strings']",1100
https://codeforces.com//contest/670/problem/A,A. Holidays,On the planet Mars a year lasts exactly days there are no leap years on Mars But Martians have the same weeks as earthlings 5 work days and then 2 days off Your task is to determine the minimum possible and the maximum possible number of days off per year on Mars ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nint main() {\n\n  //  freopen(""input.txt"", ""r"", stdin);\n   // freopen(""output.txt"", ""w"", stdout);\n\n    int n;\n    cin >> n;\n    int mx = 0, mn = INF;\n    for (int i = 0; i < 7; ++i) {\n        int a = 0;\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 7 >= 5) a++;\n        }\n        mx = max(mx, a);\n        mn = min(mn, a);\n    }\n    cout << mn << \' \' << mx << \'\\n\';\n    return 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'math']",900
https://codeforces.com//contest/1418/problem/F,F. Equal Product,You are given four integers n m l and r Let s name a tuple x 1 y 1 x 2 y 2 as if 1 le x 1 x 2 le n 1 le y 2 y 1 le m x 1 cdot y 1 x 2 cdot y 2 l le x 1 cdot y 1 le r Find any good tuple ,"[""#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\n\nconst int N=200005;\n\nset<int>now;\nset<int>::iterator it;\nVI g[N];\nint cnt[N];\nint n,m,lasL,lasR;LL l,r;\n\nsigned main(){\n\trd(n);rd(m);rd(l);rd(r);\n\trep(i,1,200000)for(int j=i;j<=200000;j+=i)g[j].PB(i);\n\tlasL=m+1;lasR=m;\n\trep(i,1,n){\n\t\tLL L=(l-1)/i+1,R=r/i;\n\t\twhile(lasL>L){\n\t\t\t--lasL;\n\t\t\trep(j,0,SZ(g[lasL])-1){\n\t\t\t\tint d=g[lasL][j];\n\t\t\t\tif(cnt[d]==0)now.insert(d);\n\t\t\t\t++cnt[d];\n\t\t\t}\n\t\t}\n\t\twhile(lasR>R){\n\t\t\trep(j,0,SZ(g[lasR])-1){\n\t\t\t\tint d=g[lasR][j];\n\t\t\t\t--cnt[d];\n\t\t\t\tif(cnt[d]==0)now.erase(d);\n\t\t\t}\n\t\t\t--lasR;\n\t\t}\n\t\tbool ok=0;\n\t\trep(j,0,SZ(g[i])-1){\n\t\t\tint d=g[i][j],t1=i/d;\n\t\t\tit=now.upper_bound(t1);\n\t\t\tif(it!=now.end()&&*it<=n/d){\n\t\t\t\tok=1;\n\t\t\t\tint tmp=((L-1)/(*it)+1)*(*it);\n\t\t\t\tpt(i,' ');pt(tmp,' ');pt(d*(*it),' ');pt(1ll*i*tmp/d/(*it),'\\n');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)pt(-1,'\\n');\n\t}\n\treturn 0;\n}""]","['data structures', 'math', 'number theory', 'two pointers']",3000
https://codeforces.com//contest/1467/problem/C,C. Three Bags,You are given bags Each bag contains a non empty multiset of numbers You can perform a number of operations on these bags In one operation you can choose any two non empty bags and choose one number from each of the bags Let s say that you choose number a from the first bag and number b from the second bag Then you remove b from the second bag and replace a with a b in the first bag Note that if there are multiple occurrences of these numbers then you shall only remove replace exactly one occurrence You have to perform these operations in such a way that you have exactly one number remaining in exactly one of the bags the other two bags being empty It can be shown that you can always apply these operations to receive such a configuration in the end Among all these configurations find the one which has the maximum number left in the end ,"['// author: xay5421\n// created: Fri Jan  8 23:21:46 2021\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\ntypedef long long LL;\nint n[3];\nvector<int>v[3];\nLL sum[3],ans;\nint main(){\n\trep(i,0,2)scanf(""%d"",&n[i]);\n\trep(i,0,2){\n\t\tv[i].resize(n[i]);\n\t\trep(j,0,n[i]-1)scanf(""%d"",&v[i][j]),sum[i]+=v[i][j];\n\t\tsort(v[i].begin(),v[i].end());\n\t}\n\trep(i,0,2)rep(j,i+1,2){\n\t\tans=max(ans,sum[0]+sum[1]+sum[2]-v[i][0]*2-v[j][0]*2);\n\t}\n\trep(i,0,2){\n\t\tans=max(ans,sum[0]+sum[1]+sum[2]-sum[i]*2);\n\t}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy']",1900
https://codeforces.com//contest/1722/problem/E,E. Counting Rectangles,You have n rectangles the i th rectangle has height h i and width w i You are asked q queries of the form h s w s h b w b For each query output the total area of rectangles you own that a rectangle of height h s and width w s while also a rectangle of height h b and width w b In other words print sum h i cdot w i for i such that h s h i h b and w s w i w b Also note that you rotate rectangles Please note that the answer for some test cases won t fit into 32 bit integer type so you should use at least 64 bit integer type in your programming language like for C ,"['#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define int long long\n#define md(a) a=(a%mod+mod)%mod\n#define file(a) freopen(#a"".in"",""r"",stdin);freopen(#a"".out"",""w"",stdout)\nint T;int n,Q;\nint a[1005][1005],sum[1005][1005];\nint ask(int xa,int ya,int xb,int yb)\n{\n\tif(xa>xb||ya>yb)return 0;\n\treturn sum[xb][yb]-sum[xa-1][yb]-sum[xb][ya-1]+sum[xa-1][ya-1];\n}\nvoid solve()\n{\n\tscanf(""%lld%lld"",&n,&Q);\n\tfor(int i=1;i<=1000;i++)for(int j=1;j<=1000;j++)a[i][j]=sum[i][j]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x,y;scanf(""%lld%lld"",&x,&y);\n\t\ta[x][y]+=x*y;\n\t}\n\tfor(int i=1;i<=1000;i++)\n\t{\n\t\tfor(int j=1;j<=1000;j++)\n\t\t{\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];\n\t\t}\n\t}\n\twhile(Q--)\n\t{\n\t\tint xa,ya,xb,yb;scanf(""%lld%lld%lld%lld"",&xa,&ya,&xb,&yb);\n\t\tprintf(""%lld\\n"",ask(xa+1,ya+1,xb-1,yb-1));\n\t}\n}\nsigned main()\n{\n\tscanf(""%lld"",&T);\n\twhile(T--)solve();\n\treturn 0;\n}\n']","['brute force', 'data structures', 'dp', 'implementation']",1600
https://codeforces.com//contest/380/problem/A,A. Sereja and Prefixes,Sereja loves number sequences very much That s why he decided to make himself a new one following a certain algorithm Sereja takes a blank piece of paper Then he starts writing out the sequence in stages Each time he either adds a new number to the end of the sequence or takes first elements of the current sequence and adds them times to the end More formally if we represent the current sequence as then after we apply the described operation the sequence transforms into the block in the square brackets must be repeated times A day has passed and Sereja has completed the sequence He wonders what are the values of some of its elements Help Sereja ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint N;\nint type[100010],x[100010],len[100010],repeat[100010];\nint init[100010];\nll dp[100010];\n\nvoid pre(void){\n    int i,j,k;\n    \n    dp[0] = 0;\n    REP(i,N){\n        if(type[i] == 1){\n            dp[i+1] = dp[i] + 1;\n        } else {\n            dp[i+1] = dp[i] + (ll)len[i]* (ll)repeat[i];\n        }\n    }\n    \n    int n = 0;\n    REP(i,N){\n        if(type[i] == 1){\n            init[n] = x[i];\n            n++;\n            if(n == 100005) return;\n        } else {\n            REP(j,repeat[i]) REP(k,len[i]){\n                init[n] = init[k];\n                n++;\n                if(n == 100005) return;\n            }\n        }\n    }\n}\n\nint group = 0;\n\nint query(ll pos){\n    int i;\n    \n    pos--;\n    while(pos >= dp[group+1]) group++;\n    \n    if(type[group] == 1) return x[group];\n    \n    ll tmp = (pos - dp[group]) % len[group];\n    return init[(int)tmp];\n}\n\nint main(void){\n    int Q,i;\n    \n    cin >> N;\n    REP(i,N){\n        scanf(""%d"", &type[i]);\n        if(type[i] == 1){\n            scanf(""%d"", &x[i]);\n        } else {\n            scanf(""%d%d"", &len[i], &repeat[i]);\n        }\n    }\n    \n    pre();\n    \n    cin >> Q;\n    REP(i,Q){\n        ll pos;\n        scanf(""%I64d"", &pos);\n        ll ans = query(pos);\n        printf(""%I64d\\n"", ans);\n        if(i == Q-1) printf(""\\n""); else printf("" "");\n    }\n    \n    return 0;\n}\n']","['binary search', 'brute force']",1600
https://codeforces.com//contest/318/problem/B,B. Strings of Power,Volodya likes listening to heavy metal and occasionally reading No wonder Volodya is especially interested in texts concerning his favourite music style Volodya calls a string powerful if it starts with and ends with Finding all powerful substrings by substring Volodya means a subsequence of consecutive characters in a string in a given text makes our hero especially joyful Recently he felt an enormous fit of energy while reading a certain text So Volodya decided to count all powerful substrings in this text and brag about it all day long Help him in this difficult task Two substrings are considered different if they appear at the different positions in the text For simplicity let us assume that Volodya s text can be represented as a single string ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1000010;\nint a[N],b[N];\nchar s[N];\n\nint main()\n{\n\tscanf(""%s"",s + 1);\n\tint n = strlen(s + 1);\n\tmemset(a,0,sizeof(a));\n\tfor(int i = 1; i <= n; i ++) {\n\t\tif(s[i] == \'m\' && s[i + 1] == \'e\' && s[i + 2] == \'t\' && s[i + 3] == \'a\' && s[i + 4] == \'l\') \n\t\t\ta[i] = 1;\n\t}\n\tfor(int i = n; i >= 1; i --) \n\t\ta[i] += a[i + 1];\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(s[i] == \'h\' && s[i + 1] == \'e\' && s[i + 2] == \'a\' && s[i + 3] == \'v\' && s[i + 4] == \'y\')\n\t\t\tans += a[i];\n\tcout << ans << endl;\n\treturn 0;\n}\n']","['implementation', 'strings', 'two pointers']",1300
https://codeforces.com//contest/516/problem/E,E. Drazil and His Happy Friends,Drazil has many friends Some of them are happy and some of them are unhappy Drazil wants to make all his friends become happy So he invented the following plan There are boys and girls among his friends Let s number them from to and to separately In th day Drazil invites th boy and th girl to have dinner together as Drazil is programmer starts from If one of those two people is happy the other one will also become happy Otherwise those two people remain in their states Once a person becomes happy or if it is happy originally he stays happy forever Drazil wants to know on which day all his friends become happy or to determine if they won t become all happy at all ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<61)\n\nll func(ll cycle, ll cost, vector <pair <int, int> > init){\n    int i,j;\n    \n//  cout << cycle << \' \' << cost << endl;\n//  REP(i,init.size()) cout << init[i].first << \' \' << init[i].second << endl;\n//  cout << endl;\n    \n    sort(init.begin(),init.end());\n    \n    vector <pair <ll, ll> > v;\n    int sz = init.size();\n    i = 0;\n    while(i < sz){\n        ll best = INF;\n        for(j=i;j<sz;j++){\n            if(init[j].first != init[i].first) break;\n            best = min(best, (ll)init[j].second);\n        }\n        v.push_back(make_pair((ll)init[i].first, best));\n        i = j;\n    }\n    \n    ll ans = 0;\n    \n    sz = v.size();\n    REP(i,sz){\n        ll tmp;\n        if(i == sz-1){\n            tmp = v[0].first - v[sz-1].first + cycle;\n        } else {\n            tmp = v[i+1].first - v[i].first;\n        }\n        ans = max(ans, (tmp - 1) * cost + v[i].second);\n    }\n    \n    return ans;\n}\n\nint gcd(int x, int y){\n    return x ? gcd(y%x, x) : y;\n}\n\nll power(ll x, ll n, ll mod){\n    if(n == 0) return 1;\n    ll y = power(x, n/2, mod);\n    y = y * y % mod;\n    if(n%2 == 1) y = y * x % mod;\n    return y;\n}\n\nll phi(ll n){\n    ll ans = n;\n    ll x = n;\n    \n    for(ll p=2;p*p<=x;p++) if(x % p == 0){\n        while(x % p == 0) x /= p;\n        ans -= ans / p;\n    }\n    \n    if(x != 1) ans -= ans / x;\n    \n    return ans;\n}\n\nvector <pair <int, int> > v[200010];\n\nll func(int X, int Y, vector <int> vx, vector <int> vy){\n    int i;\n    \n    int g = gcd(X, Y);\n    if(g > 200005) return INF;\n    \n    ll r = Y / g;\n    ll mod = X / g;\n    ll yinv = 1;\n    if(mod != 1) yinv = power(r, phi(mod) - 1, mod);\n    \n    REP(i,g) v[i].clear();\n    \n    REP(i,vx.size()){\n        int x = vx[i];\n        int t = vx[i];\n        ll id = (x/g) * yinv % (X/g);\n        v[x%g].push_back(make_pair((int)id, t));\n    }\n    \n    REP(i,vy.size()){\n        int x = vy[i] % X;\n        int t = vy[i];\n        ll id = (x/g) * yinv % (X/g);\n        v[x%g].push_back(make_pair((int)id, t));\n    }\n    \n    REP(i,g) if(v[i].empty()) return INF;\n    \n    ll ans = 0;\n    REP(i,g){\n        ll tmp = func(X / g, Y, v[i]);\n        ans = max(ans, tmp);\n    }\n    \n    return ans;\n}\n\nint tx[1000010];\nint ty[1000010];\n\nvector <int> input(void){\n    int sz,x,i;\n    cin >> sz;\n    vector <int> v;\n    REP(i,sz){\n        scanf(""%d"", &x);\n        v.push_back(x);\n    }\n    return v;\n}\n\nint main(void){\n    int X,Y,i;\n    \n    cin >> X >> Y;\n    vector <int> vx = input();\n    vector <int> vy = input();\n    \n    int M = 1000000;\n    \n    if(max(X, Y) <= M){\n        REP(i,X) tx[i] = (1<<29);\n        REP(i,Y) ty[i] = (1<<29);\n        REP(i,vx.size()) tx[vx[i]] = -1;\n        REP(i,vy.size()) ty[vy[i]] = -1;\n        \n        REP(i,M) if(tx[i%X] < i || ty[i%Y] < i){\n            tx[i%X] = min(tx[i%X], i);\n            ty[i%Y] = min(ty[i%Y], i);\n        }\n        \n        int ans = 0;\n        REP(i,X) ans = max(ans, tx[i]);\n        REP(i,Y) ans = max(ans, ty[i]);\n        \n    //  REP(i,X) cout << tx[i] << \' \'; cout << endl;\n    //  REP(i,Y) cout << ty[i] << \' \'; cout << endl;\n        \n        if(ans != (1<<29)){\n            cout << ans << endl;\n            return 0;\n        }\n    }\n    \n    ll ans1 = func(X, Y, vx, vy);\n    ll ans2 = func(Y, X, vy, vx);\n    ll ans = max(ans1, ans2);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    \n    // cout << ans1 << \' \' << ans2 << endl;\n    \n    return 0;\n}\n']","['math', 'number theory']",3100
https://codeforces.com//contest/1685/problem/D1,D1. Permutation Weight  Easy Version , You are given a permutation p 1 p 2 ldots p n of integers from 1 to n Let s define the weight of the permutation q 1 q 2 ldots q n of integers from 1 to n as q 1 p q 2 q 2 p q 3 ldots q n 1 p q n q n p q 1 You want your permutation to be as lightweight as possible Find any permutation q with the smallest possible weight ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 205;\nint n;\nint p[maxn];\nint fl[maxn];\nvi mg(vi a, vi b, int k) {\n    int p[2];\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == k)  p[0] = i;\n    }\n    for (int i = 0; i < b.size(); i++)\n        if (b[i] == k + 1)\n            p[1] = i;\n    //cout << p[0] << \' \' << p[1] << endl;\n    vi res;\n    for (int i = 0; i + 1 < a.size(); i++)\n        res.pb(a[(p[0] + 1 + i) % a.size()]);\n    for (int i = 0; i < b.size(); i++)\n        res.pb(b[(p[1] + i) % b.size()]);\n    res.pb(k);\n    return res;\n}\nvi fd(int x) {\n    vi res;\n    while (1) {\n        res.pb(x); fl[x] = 1;\n        //cout << x << \' \' << p[x] << endl;\n        x = p[x];\n        if (fl[x]) break;\n    }\n    return res;\n}\n\nint main() {\n    int t;\n    cin >> t;\n   //cout << ""AA"" << endl;\n    while (t--) {\n        cin >> n;\n        memset(fl, 0, sizeof(fl));\n        for (int i = 1; i <= n; i++)\n            cin >> p[i];\n        vi cur = fd(1);\n        for (int i = 2; i <= n; i++) {\n            if (fl[i]) continue;\n            else {\n                vi h = fd(i);\n                cur = mg(cur, h, i - 1);\n            }\n        }\n        reverse(cur.begin(), cur.end());\n        for (int i = 0; i < n; i++)\n            cout << cur[i] << "" "";\n    }\n    return (0-0); //<3\n}']","['constructive algorithms', 'dfs and similar', 'dsu']",2800
https://codeforces.com//contest/1073/problem/E,E. Segment Sum,You are given two integers l and r l le r Your task is to calculate the sum of numbers from l to r including l and r such that each number contains k different digits and print this sum modulo 998244353 For example if k 1 then you have to calculate all numbers from l to r such that each number is formed using only one digit For l 10 r 50 the answer is 11 22 33 44 110 ,"[""#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nmint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nmint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nmint dp[20][2][2][2][1 << 10];\nmint dp2[20][2][2][2][1 << 10];\n\nint popcnt(int n) {\n  int res = 0;\n  while (n > 0) {\n    res++;\n    n &= n - 1;\n  }\n  return res;\n}\n\nint main() {\n  string L, R;\n  int K;\n  cin >> L >> R >> K;\n  while (L.size() < R.size()) L = '0' + L;\n  while (L.size() > R.size()) R = '0' + R;\n  int n = L.size();\n  dp[0][0][0][0][0] = 1;\n  dp2[0][0][0][0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 2; l++) {\n          for (int m = 0; m < 1 << 10; m++) {\n            int x = j ? 0 : L[i] - '0';\n            int y = k ? 9 : R[i] - '0';\n            for (int d = x; d <= y; d++) {\n              int mm = l == 0 && d == 0 ? 0 : (m | 1 << d);\n              dp[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp[i][j][k][l][m];\n              dp2[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp2[i][j][k][l][m] * 10 + dp[i][j][k][l][m] * d;\n            }\n          }\n        }\n      }\n    }\n  }\n  mint ans;\n  for (int j = 0; j < 2; j++) {\n    for (int k = 0; k < 2; k++) {\n      for (int m = 0; m < 1 << 10; m++) {\n        if (popcnt(m) <= K) {\n          ans += dp2[n][j][k][1][m];\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n""]","['bitmasks', 'combinatorics', 'dp', 'math']",2300
https://codeforces.com//contest/1158/problem/D,D. Winding polygonal line,Vasya has n different points A 1 A 2 ldots A n on the plane No three of them lie on the same line He wants to place them in some order A p 1 A p 2 ldots A p n where p 1 p 2 ldots p n some permutation of integers from 1 to n After doing so he will draw oriented polygonal line on these points drawing oriented segments from each point to the next in the chosen order So for all 1 leq i leq n 1 he will draw oriented segment from point A p i to point A p i 1 He wants to make this polygonal line satisfying 2 conditions it will be non self intersecting so any 2 segments which are not neighbors don t have common points it will be Vasya has a string s consisting of n 2 symbols or Let s call an oriented polygonal line if its i th turn left if s i and right if s i More formally i th turn will be in point A p i 1 where oriented segment from point A p i to point A p i 1 changes to oriented segment from point A p i 1 to point A p i 2 Let s define vectors overrightarrow v 1 overrightarrow A p i A p i 1 and overrightarrow v 2 overrightarrow A p i 1 A p i 2 Then if in order to rotate the vector overrightarrow v 1 by the smallest possible angle so that its direction coincides with the direction of the vector overrightarrow v 2 we need to make a turn counterclockwise then we say that i th turn is to the left and otherwise to the right For better understanding look at this pictures with some examples of turns You are given coordinates of the points A 1 A 2 ldots A n on the plane and string s Find a permutation p 1 p 2 ldots p n of the integers from 1 to n such that the polygonal line drawn by Vasya satisfy two necessary conditions ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Point {\n  int x, y;\n\n  Point operator-(const Point &P) const { return {x-P.x, y-P.y}; }\n  LL CrossProd(const Point &P) const {\n    return (LL)x * P.y - (LL)y * P.x;\n  }\n};\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  string s;\n  int N;\n  cin >> N;\n  vector<Point> pts(N);\n  for (Point &pt : pts) { cin >> pt.x >> pt.y; }\n  cin >> s;\n\n  vector<bool> avail(N, true);\n  int fst = 0;\n  for (int i = 0; i < N; ++i) {\n    if (pts[i].x < pts[fst].x) { fst = i; }\n  }\n\n  VI order{fst};\n  avail[fst] = false;\n\n  for (int step = 0; step < N - 2; ++step) {\n    const bool is_right = s[step] == \'R\';\n    const int last = order.back();\n\n    int cand = 0;\n    while (!avail[cand]) { ++cand; }\n\n    for (int i = cand + 1; i < N; ++i) {\n      if (!avail[i]) { continue; }\n      const bool right = (pts[cand] - pts[last]).CrossProd(pts[i] - pts[last]) > 0;\n      if (is_right == right) {\n        cand = i;\n      }\n    }\n\n    order.PB(cand);\n    avail[cand] = false;\n  }\n\n  int lst = 0;\n  while (!avail[lst]) { ++lst; }\n  order.PB(lst);\n\n  for (int x : order) { cout << x + 1 << "" ""; }\n  cout << ""\\n"";\n}\n\n']","['constructive algorithms', 'geometry', 'greedy', 'math']",2600
https://codeforces.com//contest/1787/problem/C,C. Remove the Bracket,RSJ has a sequence a of n integers a 1 a 2 ldots a n and an integer s For each of a 2 a 3 ldots a n 1 he chose a pair of x i and y i such that x i y i a i and x i s cdot y i s geq 0 Now he is interested in the value F a 1 cdot x 2 y 2 cdot x 3 y 3 cdot x 4 ldots y n 2 cdot x n 1 y n 1 cdot a n Please help him find the minimum possible value F he can get by choosing x i and y i optimally It can be shown that there is always at least one valid way to choose them ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, s;\n\t\tcin >> n >> s;\n\t\tvector<pi> a(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif (x >= 2 * s)\n\t\t\t\ta[i] = {x - s, s};\n\t\t\telse\n\t\t\t\ta[i] = {x - min(x, s), min(x, s)};\n\t\t}\n\t\tvector<pi> dp(n + 1);\n\t\tdp[1][0] = (a[0][0] + a[0][1]) * a[1][0];\n\t\tdp[1][1] = (a[0][0] + a[0][1]) * a[1][1];\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tdp[i][j] = min(dp[i - 1][0] + a[i - 1][1] * a[i][j], dp[i - 1][1] + a[i - 1][0] * a[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << min(dp[n - 2][0] + a[n - 2][1] * (a[n - 1][0] + a[n - 1][1]), dp[n - 2][1] + a[n - 2][0] * (a[n - 1][0] + a[n - 1][1])) << ""\\n"";\n\t}\n}\n']","['dp', 'greedy', 'math']",1600
https://codeforces.com//contest/1487/problem/G,G. String Counting,You have c 1 letters c 2 letters c 26 letters You want to build a string of length n from them obviously you cannot use the i th letter more than c i times A string is called if there are no palindromic contiguous substrings of odd length greater than 1 in it For example the string is not beautiful it has several palindromic substrings of odd length greater than 1 for example Another example the string is Calculate the number of different strings you can build and print the answer modulo 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid solve() {\n\n    int N; cin >> N;\n    int A[26]; F0R(i, 26) cin >> A[i];\n    mi dp[N+1][N+1][3][3];\n    mi nxt[N+1][N+1][3][3];\n    dp[0][0][2][2] = 1;\n    F0R(iter, N) {\n        F0R(i, N+1) {\n            F0R(j, N+1) {\n                F0R(k, 3) {\n                    F0R(l, 3) {\n                        if (i < N && k != 0) {\n                            nxt[i+1][j][l][0]+=dp[i][j][k][l];\n                        }\n                        if (j < N && k != 1) {\n                            nxt[i][j+1][l][1] += dp[i][j][k][l];\n                        } \n                        if (k != 2 || iter < 2)  {\n                            nxt[i][j][l][2] += dp[i][j][k][l];\n                        }\n                        nxt[i][j][l][2] += dp[i][j][k][l] * 23;\n                    }\n                }\n            }\n        }\n        F0R(i, N+1) F0R(j, N+1) F0R(k, 3) F0R(l, 3) dp[i][j][k][l] = nxt[i][j][k][l];\n        F0R(i, N+1) F0R(j, N+1) F0R(k, 3) F0R(l, 3) nxt[i][j][k][l] = 0;\n    }\n\n    mi wayOne[N+1], wayTwo[N+1][N+1];\n    F0R(i, N+1) {\n        F0R(j, N+1) {\n            F0R(k, 3) {\n                F0R(l, 3) {\n                    wayOne[i] += dp[i][j][k][l];\n                    wayTwo[i][j] += dp[i][j][k][l];\n                }\n            }\n        }\n    }\n    F0Rd(i, N) wayOne[i] += wayOne[i+1];\n    F0Rd(i, N+1) {\n        F0Rd(j, N+1) {\n            if (i < N) {\n                wayTwo[i][j] += wayTwo[i+1][j];\n            }\n            if (j < N) {\n                wayTwo[i][j] += wayTwo[i][j+1];\n            }\n            if (i < N && j < N) wayTwo[i][j] -= wayTwo[i+1][j+1];\n        }\n    }\n    mi ans = pow(mi(25), N-2) * 26 * 26;\n    F0R(i, 26) {\n        if (A[i] < N) ans -= wayOne[A[i]+1];\n        FOR(j, i+1, 26) {\n            if (A[i] + A[j] + 2 <= N) ans += wayTwo[A[i]+1][A[j]+1];\n        }\n    }\n    cout << ans << nl;\n    \n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['combinatorics', 'dp', 'fft', 'math']",2700
https://codeforces.com//contest/322/problem/A,A. Ciel and Dancing,Fox Ciel and her friends are in a dancing room There are boys and girls here and they never danced before There will be some songs during each song there must be exactly one boy and one girl are dancing Besides there is a special rule either the boy in the dancing pair must dance for the first time so he didn t dance with anyone before or the girl in the dancing pair must dance for the first time Help Fox Ciel to make a schedule that they can dance as many songs as possible ,"['#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\n#define inf 1023456789\n#define linf 1023456789123456789ll\n#define pii pair<int,int>\n#define pipii pair<int, pii >\n#define pll pair<long long,long long>\n#define vint vector<int>\n#define vvint vector<vector<int> >\n\n#define DEBUG\n#ifdef DEBUG\n#define db(x) cerr << #x << "" = "" << x << endl\n#else\n#define db(x)\n#endif\n\nint main()\n{\n\tint n,m;\n\tscanf(""%d %d"",&n,&m);\n\tprintf(""%d\\n"",n+m-1);\n\tfor(int i=1; i<=n; i++)printf(""%d 1\\n"",i);\n\tfor(int i=2; i<=m; i++)printf(""1 %d\\n"",i);\n\treturn 0;\n}']",['greedy'],1000
https://codeforces.com//contest/1675/problem/G,G. Sorting Pancakes,Nastya baked m pancakes and spread them on n dishes The dishes are in a row and numbered from left to right She put a i pancakes on the dish with the index i Seeing the dishes Vlad decided to bring order to the stacks and move some pancakes In one move he can shift one pancake from any dish to the closest one that is select the dish i a i 0 and do one of the following if i 1 put the pancake on a dish with the previous index after this move a i a i 1 and a i 1 a i 1 1 if i n put the pancake on a dish with the following index after this move a i a i 1 and a i 1 a i 1 1 Vlad wants to make the array a after moving as few pancakes as possible Help him find the minimum number of moves needed for this The array a a 1 a 2 dots a n is called non increasing if a i ge a i 1 for all i from 1 to n 1 ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nconst int N = 255,INF = 0x3f3f3f3f;\nint ans,n,m,inp[N + 1],dp[2][N + 1][(N << 1) + 10],minn[2][N + 1][(N << 1) + 10],sum[N + 1];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tans = INF;\n\tn = read(),m = read();\n\tfor (int i = 1;i <= n;i++) inp[i] = read(),sum[i] = sum[i - 1] + inp[i];\n\tif (n == 1) {puts(""0"");return 0;}\n\tmemset(dp,63,sizeof(dp)),memset(minn,63,sizeof(minn));\n\tfor (int j = 0;j <= m;j++){\n\t\tdp[1][j][j - inp[1] + m] = abs(j - inp[1]);\n\t\tminn[1][j][j - inp[1] + m] = abs(j - inp[1]);\n\t}\n\tfor (int k = 0;k <= (m << 1);k++){\n\t\tfor (int j = m;j >= 0;j--){\n\t\t\tminn[1][j][k] = min(dp[1][j][k],minn[1][j + 1][k]);\n\t\t}\n\t}\n\tfor (int i = 2;i <= n;i++){\n\t\tfor (int j = 0;j <= m;j++){\n\t\t\tfor (int k = 0;k <= (m << 1);k++) dp[i & 1][j][k] = minn[i & 1][j][k] = INF;\n\t\t}\n\t\tfor (int j = 0;j <= m;j++){\n\t\t\tfor (int k = 0;k <= (m << 1);k++){\n\t\t\t\tif (k - j + inp[i] >= 0 && k - j + inp[i] <= (m << 1)){\n\t\t\t\t\tdp[i & 1][j][k] = min(dp[i & 1][j][k],minn[(i & 1) ^ 1][j][k - j + inp[i]] + abs(k - m));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0;k <= (m << 1);k++){\n\t\t\tfor (int j = m;j >= 0;j--){\n\t\t\t\tminn[i & 1][j][k] = min(minn[i & 1][j + 1][k],dp[i & 1][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0;j <= m;j++) ans = min(ans,dp[n & 1][j][m]);\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']",['dp'],2300
https://codeforces.com//contest/567/problem/B,B. Berland National Library,Berland National Library has recently been built in the capital of Berland In addition in the library you can take any of the collected works of Berland leaders the library has a Today was the pilot launch of an automated reading room visitors accounting system The scanner of the system is installed at the entrance to the reading room It records the events of the form reader entered room reader left room Every reader is assigned a during the registration procedure at the library it s a unique integer from to Thus the system logs events of two forms the reader with registration number entered the room the reader with registration number left the room The first launch of the system was a success it functioned for some period of time and at the time of its launch and at the time of its shutdown the reading room may already have visitors Significant funds of the budget of Berland have been spent on the design and installation of the system Therefore some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring Now the developers of the system need to urgently come up with reasons for its existence Help the system developers to find the minimum possible capacity of the reading room in visitors using the log of the system available to you ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define ull unsigned long long\n#define pll pair < ll, ll >\n#define forit(s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it ++)\n#define all(s) s.begin(), s.end()\n\nconst int inf = (1ll << 31) - 1;\nconst int maxn = (int) 1e5 + 10;\n\nusing namespace std;\n\n\n\nset < int > S[111];\nint main () {\n    #ifdef LOCAL\n    freopen (""a.in"", ""r"", stdin);\n    freopen (""a.out"", ""w"", stdout);\n    #endif\n    int n = 0;\n    cin >> n;\n    int mini = 0;\n    int cal = 0;\n    for(int i = 1; i <= n; i++){\n        string x;\n        int t;\n        cin >> x >> t;\n        forit(S[i-1])S[i].insert(*it);\n        if(x == ""+""){\n            S[i].insert(t); \n        }\n        else {\n            if(S[i].find(t) != S[i].end()){\n                S[i].erase(t);\n            }\n            else {\n                for(int j = 0; j < i; j++)\n                    S[j].insert(t);\n            }\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        mini = max(mini, (int) S[i].size());\n    }\n    cout << mini << endl;\n\n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n    #endif\n    return 0;\n}\n\n']",['implementation'],1300
https://codeforces.com//contest/1157/problem/E,E. Minimum Array,You are given two arrays a and b both of length n All elements of both arrays are from 0 to n 1 You can reorder elements of the array b if you want you may leave the order of elements as it is After that let array c be the array of length n the i th element of this array is c i a i b i ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tprintf(""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n\n// Optimize\n#define abs(a) ((a)<0?(~(a)+1):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) {a=a^b;b=a^b;a=a^b;}\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define MOD 998244353\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 262144\n\nint n;\nint cnt[MAXN];\nint a[MAXN];\nint nxtnum[MAXN];\n\nint Nxt( int x ){\n\treturn nxtnum[x] == x ? x : nxtnum[x] = Nxt(nxtnum[x]);\n}\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) Read(a[i]);\n\tFor(i,n){\n\t\tiRead(x);\n\t\t++cnt[x];\n\t}\n\n\tFor0(i,n) nxtnum[i] = cnt[i] ? i : (i+1)%n;\n\n\tFor(i,n){\n\t\tint u = a[i];\n\t\tint v = Nxt((n-u)%n);\n\t\tprintf(""%d "",(u+v)%n);\n\t\t--cnt[v];\n\t\tif(!cnt[v]) nxtnum[v] = (v+1)%n;\n\t}\n\tputchar(10);\n\n\tEND();\n}\n']","['binary search', 'data structures', 'greedy']",1700
https://codeforces.com//contest/1608/problem/C,C. Game Master,n players are playing a game There are two different maps in the game For each player we know his strength on each map When two players fight on a specific map the player with higher strength on that map always wins No two players have the same strength on the same map You are the game master and want to organize a tournament There will be a total of n 1 battles While there is more than one player in the tournament choose any map and any two remaining players to fight on it The player who loses will be eliminated from the tournament In the end exactly one player will remain and he is declared the winner of the tournament For each player determine if he can win the tournament ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvi unko(int n){\n\tvi a=readvi(n);\n\tvi vs=a;sort(all(vs));\n\trep(i,n)a[i]=lwb(vs,a[i]);\n\treturn a;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=unko(n);\n\tvi b=unko(n);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\tvi ans(n);\n\tint mn=inf;\n\tper(i,n){\n\t\tassert(a[idx[i]]==i);\n\t\tchmin(mn,b[idx[i]]);\n\t\tif(mn==i){\n\t\t\trng(j,i,n){\n\t\t\t\tans[idx[j]]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trep(i,n)cout<<ans[i];\n\tcout<<""\\n"";\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'two pointers']",1700
https://codeforces.com//contest/922/problem/D,D. Robot Vacuum Cleaner,Pushok the dog has been chasing Imp for a few hours already Fortunately Imp knows that Pushok is afraid of a robot vacuum cleaner While moving the robot generates a string consisting of letters and that produces a lot of noise We define of string as the number of occurrences of string as a in it in other words the number of such pairs that and and The robot is off at the moment Imp knows that it has a sequence of strings in its memory and he can arbitrary change their order When the robot is started it generates the string as a concatenation of these strings in the given order The noise of the resulting string equals the noise of this concatenation Help Imp to find the maximum noise he can achieve by changing the order of the strings ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, a[MAXN];\nstring s[MAXN];\n\nll get(string t){\n\tll res = 0;\n\tint c = 0;\n\tfor (int i = 0; i < t.size(); i++){\n\t\tif (t[i] == 's')\n\t\t\tc++;\n\t\telse\n\t\t\tres += c;\n\t}\n\treturn res;\n}\n\nbool cmp(int u, int v){\n\treturn get(s[u]+s[v]) > get(s[v]+s[u]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> s[i];\n\tiota(a, a + n, 0);\n\tsort(a, a + n, cmp);\n\tstring t;\n\tfor (int i = 0; i < n; i++)\n\t\tt += s[a[i]];\n\tcout << get(t) << endl;\n}\n""]","['greedy', 'sortings']",1800
https://codeforces.com//contest/558/problem/C,C. Amr and Chemistry,Amr loves Chemistry and specially doing experiments He is preparing for a new interesting experiment Amr has different types of chemicals Each chemical has an initial volume of liters For this experiment Amr has to mix all the chemicals together but all the chemicals volumes must be equal first So his task is to make all the chemicals volumes equal To do this Amr can do two different kind of operations Choose some chemical and double its current volume so the new volume will be Choose some chemical and divide its volume by two integer division so the new volume will be Suppose that each chemical is contained in a vessel of infinite volume Now Amr wonders what is the minimum number of operations required to make all the chemicals volumes equal ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\nint i, j, k, n, m, a[N], x, y, h[N], temp, t, tt, c;\n\npii b[N];\n\nint main(){\n    \n    scanf(""%d"",&n);\n\n    FOR(i,1,n) {\n        scanf(""%d"",&a[i]);\n    \n    }\n\n    memset(h, -1, sizeof h);\n   \n    int t = a[1], ans = inf;\n    \n    vector< int > v;\n    \n    FOR(i,1,n) {\n        \n        v.clear();\n        \n        t = a[i], c = 0;\n        \n        while(1) {\n                    \n            temp = c;\n            \n            if(t == 0) {\n                h[0] = c;\n                v.pb(0);\n                break;\n            }\n               \n               \n            tt = t;\n                    \n            while(tt < 500000) {\n                if(h[tt] != -1 && h[tt] > temp) h[tt] = temp;\n               // else if(h[tt] != -1) break;\n                else if(h[tt] == -1){ h[tt] = temp; v.pb(tt); }\n                tt *= 2; temp++;\n            } c++; t /= 2; \n         \n        }\n        \n        foreach(it, v) {\n            b[*it].st++;b[*it].nd += h[*it];\n            h[*it] = -1;\n        }\n      }\n    \n    FOR(i,0,N-1) if(b[i].st == n) { ans = min(ans, b[i].nd); } \n    \n    cout << ans << endl;\n\n   return 0;\n}']","['brute force', 'graphs', 'greedy', 'math', 'shortest paths']",1900
https://codeforces.com//contest/843/problem/E,E. Maximum Flow,You are given a directed graph consisting of vertices and edges The vertices and are marked as source and sink correspondingly Additionally there are no edges ending at and there are no edges beginning in The graph was constructed in a following way initially each edge had capacity A maximum flow with source at and sink at was constructed in this flow network Let s denote as the value of flow passing through edge with index Next all capacities and flow value were erased Instead indicators were written on edges if flow value passing through edge was positive i e if and otherwise Using the graph and values find out what is the possible number of edges in the initial flow network that could be saturated the passing flow is equal to capacity i e Also construct the corresponding flow network with maximum flow in it A flow in directed graph is described by flow values on each of the edges so that the following conditions are satisfied for each vertex except source and sink total incoming flow and total outcoming flow are equal for each edge A flow is maximum if the difference between the sum of flow values on edges from the source and the sum of flow values on edges to the source there are no such in this problem is maximum possible ,"['#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\n// ========================================================================= //\nnamespace dinic {\n    int const INF = 100 + (int) 1e9;\n    ll const INFL = 100 + (ll) 1e18;\n    int const N = 200200;\n\n    struct edge_t {\n        int to, cap, flow;\n        \n        edge_t(int to, int cap)\n            : to(to)\n            , cap(cap)\n            , flow(0)\n        {}\n    };\n\n    vector<edge_t> all;\n    vector<int> g[N];\n    int index[N], dist[N];\n\n    void add_edge(int from, int to, int cap1, int cap2) {\n        g[from].push_back(all.size());\n        all.emplace_back(to, cap1);\n        g[to].push_back(all.size());\n        all.emplace_back(from, cap2);\n    }\n\n    void init_graph(int n) {\n        all.clear();\n        for (int i = 0; i < n; ++i) {\n            g[i].clear();\n        }\n    }\n\n    void clear_flow() {\n        for (auto& edge : all) {\n            edge.flow = 0;\n        }\n    }\n\n    int dfs(int v, int sink, int flow) {\n        if (v == sink || flow == 0) {\n            return flow;\n        }\n        for (int& i = index[v]; i < (int)g[v].size(); ++i) {\n            int x = g[v][i];\n            auto& e = all[x];\n            int to = e.to;\n            int diff = e.cap - e.flow;\n            if (diff > 0 && dist[v] - 1 == dist[to]) {\n                int now = dfs(to, sink, min(flow, diff));\n                if (now > 0) {\n                    e.flow += now;\n                    all[x ^ 1].flow -= now;\n                    return now;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(int source, int sink, int n) {\n        clear_flow();\n        ll ret = 0;\n        while (true) {\n            static int q[N];\n            memset(dist, 63, sizeof(int) * n);\n            int tail = 0;\n            dist[q[tail++] = sink] = 0;\n            for (int i = 0; i < tail; ++i) {\n                int v = q[i];\n                for (int x : g[v]) {\n                    int to = all[x].to;\n                    if (all[x ^ 1].flow < all[x ^ 1].cap && dist[to] > INF) {\n                        dist[q[tail++] = to] = dist[v] + 1;\n                    }\n                }\n            }\n            if (dist[source] > INF) {\n                break;\n            }\n            memset(index, 0, n * sizeof(int));\n            while (int flow = dfs(source, sink, INF)) {\n                ret += flow;\n            }\n        }\n        return ret;\n    }\n}\n\n//void add_edge(int from, int to, int cap1, int cap2) {\n//void init_graph(int n) {\n//ll max_flow(int source, int sink, int n) {\n\nconst int N = 111;\n\nstruct Edge {\n    bool g;\n    int x, y;\n    int cap = 0, flow = 0;\n};\n\nint n, m, s1, s2;\nvector < int > e[N], eb[N];\nvector < Edge > es;\n\nbool vis[N];\nbool vis11[N];\n\nvoid dfs1(int v) {\n    if (vis11[v])\n        return;\n    vis11[v] = true;\n    for (int i : dinic::g[v]) {\n        dinic::edge_t edge = dinic::all[i];\n        if (edge.cap != edge.flow)\n            dfs1(edge.to);\n    }\n}\n\nbool dfs2(int v, int fin) {\n    if (v == fin)\n        return true;\n    if (vis[v])\n        return false;\n    vis[v] = true;\n    for (int i : e[v]) {\n        Edge &ee = es[i];\n        if (!ee.g)\n            continue;\n        ++ee.cap;\n        ++ee.flow;\n        if (dfs2(ee.y, fin))\n            return true;\n        --ee.cap;\n        --ee.flow;\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    scanf(""%d%d%d%d"", &n, &m, &s1, &s2);\n    --s1; --s2;\n    dinic::init_graph(n);\n    for (int i = 0; i < m; ++i) {\n        int x, y, g;\n        scanf(""%d%d%d"", &x, &y, &g);\n        --x;\n        --y;\n        e[x].push_back(sz(es));\n        Edge ce;\n        ce.x = x;\n        ce.y = y;\n        ce.g = g;\n        es.push_back(ce);\n        if (g) {\n            dinic::add_edge(x, y, 1, 0);\n            dinic::add_edge(y, x, dinic::INF, 0);\n        } else {\n            dinic::add_edge(x, y, dinic::INF, 0);\n        }\n    }\n\n    int flw = dinic::max_flow(s1, s2, n);\n\n    dfs1(s1);\n    for (Edge &ee : es) {\n        if (ee.g) {\n            ++ee.flow;\n            ++ee.cap;\n            memset(vis, 0, sizeof(vis));\n            dfs2(s1, ee.x);\n            memset(vis, 0, sizeof(vis));\n            dfs2(ee.y, s2);\n            if (!(vis11[ee.x] && !vis11[ee.y])) {\n                ++ee.cap;\n            }\n        } else\n            ee.cap = 1;\n    }\n\n    cout << flw << ""\\n"";\n    for (Edge const& ee : es)\n        cout << ee.flow << "" "" << ee.cap << ""\\n"";\n    return 0;\n}\n']","['flows', 'graphs']",3000
https://codeforces.com//contest/1497/problem/E2,E2. Square-Free Division  hard version ,There is an array a 1 a 2 ldots a n of n positive integers You should divide it into a minimal number of continuous segments such that in each segment there are no two numbers on different positions whose product is a perfect square Moreover it is allowed to do at most k such operations before the division choose a number in the array and change its value to any positive integer What is the minimum number of continuous segments you should use if you will make changes optimally ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    vector<int> h(1e7 + 5);\n    vector<int> e(1e7 + 5, 1);\n    vector<int> minD(1e7 + 5, -1);\n    minD[1] = 1;\n    for (ll i = 2; i < 1e7 + 5; ++i) {\n        if (e[i]) {\n            minD[i] = i;\n            for (ll j = i; j * i < 1e7 + 5; ++j) {\n                e[i * j] = 0;\n                if (minD[i * j] == -1) {\n                    minD[i * j] = i;\n                } else {\n                    minD[i * j] = min(minD[i * j], (int)i);\n                }\n\n            }\n        }\n    }\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            int ans = 1;\n            map<int, int> cnt;\n            while (minD[a[i]] != 1) {\n                ++cnt[minD[a[i]]];\n                a[i] /= minD[a[i]];\n            }\n            for (auto &elem : cnt) {\n                if (elem.se % 2) {\n                    ans *= elem.fi;\n                }\n            }\n            a[i] = ans;\n        }\n        vector<vector<int>> sameSegment(k + 1, vector<int>(n));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) h[a[j]] = 0;\n            int l = 0, cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                ++h[a[j]];\n                if (h[a[j]] > 1) {\n                    ++cnt;\n                }\n                while (cnt > i) {\n                    if (h[a[l]] > 1) {\n                        --cnt;\n                    }\n                    --h[a[l]];\n                    ++l;\n                }\n                sameSegment[i][j] = l;\n            }\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(n, 1e9));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int z = 0; z <= i; ++z) {\n                    int ans = 1;\n                    if (sameSegment[i - z][j] - 1 != -1) {\n                        ans += dp[z][sameSegment[i - z][j] - 1];\n                    }\n                    dp[i][j] = min(dp[i][j], ans);\n                }\n            }\n        }\n        int res = 1e9;\n        for (int j = 0; j <= k; ++j) {\n            res = min(res, dp[j][n - 1]);\n        }\n        cout << res << \'\\n\';\n    }\n}\n/*\n*/\n']","['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",2500
https://codeforces.com//contest/1367/problem/D,D. Task On The Board,Polycarp wrote on the board a string s containing only lowercase Latin letters This string is known for you and given in the input After that he erased some letters from the string s and he rewrote the remaining letters in order As a result he got some new string t You have to find it with some additional information Suppose that the string t has length m and the characters are numbered from left to right from 1 to m You are given a sequence of m integers b 1 b 2 ldots b m where b i is the sum of the distances i j from the index i to all such indices j that t j t i consider that In other words to calculate b i Polycarp finds all such indices j that the index j contains a letter that is later in the alphabet than t i and sums all the values i j For example if t then since t 1 all other indices contain letters which are later in the alphabet that is b 1 1 2 1 3 1 4 1 2 3 6 since t 2 only the index j 3 contains the letter which is later in the alphabet that is b 2 2 3 1 since t 3 then there are no indexes j such that t j t i thus b 3 0 since t 4 only the index j 3 contains the letter which is later in the alphabet that is b 4 4 3 1 Thus if t then b 6 1 0 1 Given the string s and the array b find any possible string t for which the following two requirements are fulfilled simultaneously t is obtained from s by erasing some letters possibly zero and then writing the rest in order the array constructed from the string t according to the rules above equals to the array b specified in the input data ,"[""#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nint h[26];\nchar findmin(int val)\n{\n\tfor(int i = 26; i >= 0; i--)\n\t{\n\t\tif(h[i] >= val)\n\t\t{\n\t\t\th[i] = 0;\n\t\t\treturn char(i + 'a');\n\t\t}\n\t\th[i] = 0;\n\t}\n}\nvoid f()\n{\n\tstring s;\n\tcin >> s;\n\tfl(i,0,26)\n\t{\n\t\th[i] = 0;\n\t}\n\tfl(i,0,s.size())\n\t{\n\t\th[s[i] - 'a']++;\n\t}\n\tint m;\n\tcin >> m;\n\tint arr[m];\n\tint ans[m] = {0};\n\tchar res[m];\n\tint vis[m] = {0};\n\tfl(i,0,m)\n\t{\n\t\tcin >> arr[i];\n\t}\n\tint cnt = 0;\n\twhile(1)\n\t{\n\t\tcnt++;\n\t\t\n\t\tbool f = 1;\n\t\tint val = 0;\n\t\tfl(i,0,m)\n\t\t{\n\t\t\tif(vis[i] == 0 && arr[i] == 0)\n\t\t\t{\n\t\t\t\tval++;\n\t\t\t}\n\t\t}\n\t\tchar c = findmin(val);\n\t\tfl(i,0,m)\n\t\t{\n\t\t\tif(vis[i] == 0 && arr[i] == 0)\n\t\t\t{\n\t\t\t\tf = 0;\n\t\t\t\tvis[i] = cnt;\n\t\t\t\tres[i] = c;\n\t\t\t}\n\t\t}\n\t\tfl(i,0,m)\n\t\t{\n\t\t\tfl(j,0,m)\n\t\t\t{\n\t\t\t\tif(vis[i] == 0 && vis[j] == cnt)\n\t\t\t\t{\n\t\t\t\t\tarr[i] -= abs(i - j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t}\n\tfl(i,0,m)\n\t{\n\t\tcout << res[i];\n\t}\n\tcout << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}""]","['constructive algorithms', 'greedy', 'implementation', 'sortings']",1800
https://codeforces.com//contest/238/problem/D,D. Tape Programming,There is a programming language in which every program is a non empty sequence of and signs and digits Let s explain how the interpreter of this programming language works A program is interpreted using movement of instruction pointer IP which consists of two parts Current character pointer CP Direction pointer DP which can point left or right Initially CP points to the leftmost character of the sequence and DP points to the right We repeat the following steps until the first moment that CP points to somewhere outside the sequence If CP is pointing to a digit the interpreter prints that digit then CP moves one step according to the direction of DP After that the value of the printed digit in the sequence decreases by one If the printed digit was then it cannot be decreased therefore it s erased from the sequence and the length of the sequence decreases by one If CP is pointing to or then the direction of DP changes to left or right correspondingly Then CP moves one step according to DP If the new character that CP is pointing to is or then the previous character will be erased from the sequence If at any moment the CP goes outside of the sequence the execution is terminated It s obvious the every program in this language terminates after some steps We have a sequence of and digits You should answer queries Each query gives you and and asks how many of each digit will be printed if we run the sequence as an independent program in this language ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define REP(i,m) for(int i=0;i<m;++i)\n#define REPN(i,m,in) for(int i=in;i<m;++i)\n#define ALL(t) (t).begin(),(t).end()\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define dump(x)  cerr << #x << "" = "" << (x) << endl\n#define prl cerr<<""called:""<< __LINE__<<endl\nusing namespace std;\nstatic const int INF =500000000; \ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<\' \';cerr<<endl;}\ntypedef long long int lint;\ntypedef pair<int,int> pi;\nint n,q;\nstruct list{\n\tint next[100005],back[100005];\n\tlist(){\n\t\tREP(i,100005) next[i]=i+1,back[i]=i-1;\n\t}\n\tint get(int a,int t){\n\t\t++a;\n\t\tif(t==0) return next[a]-1;\n\t\telse return back[a]-1;\n\t}\n\tvoid erase(int a){\n\t\t++a;\n\t\tnext[back[a]]=next[a];\n\t\tback[next[a]]=back[a];\n\t}\n};\nlist move;\n\nint vised[100005];\nchar buf[100005];\nint putted[3000005][10];\nint passed[100005],backtime[100005];\nvector<int> stk;\nint main(){\n\tcin>>n>>q;\n\tscanf(""%s"",buf);\n\tint cp=0,dp=0,last=0;//0:forward 1:backward\n\tint start=0;\n\tint t;\n\tmemset(backtime,-1,sizeof(backtime));\n\tmemset(vised,-1,sizeof(vised));\n\tfor(t=0;;++t){\n\n\t\tif(cp==-1){\n\t\t\tREP(i,n) if(!passed[i]){\n\t\t\t\tstart=cp=i;break;\n\t\t\t}\n\t\t\tif(cp==-1) break;\n\t\t\tdp=0;\n\t\t\tlast=0;\n\t\t}\n\t\tif(vised[cp]==-1){\n\t\t\tvised[cp]=t;\n\t\t\tstk.pb(cp);\n\t\t}\n\t\tREP(i,10) putted[t+1][i]=putted[t][i];\n\t\tpassed[cp]=1;\n\t\tif(buf[cp]>=\'0\' && buf[cp]<=\'9\'){\n\t\t\tputted[t+1][buf[cp]-\'0\']++;\n\t\t\tif(buf[cp]==\'0\'){\n\t\t\t\tmove.erase(cp);\n\t\t\t\tif(start==cp) ++start;\n\t\t\t}else{\n\t\t\t\t--buf[cp];\n\t\t\t}\n\t\t\tlast=0;\n\t\t}else if(buf[cp]==\'<\'){\n\t\t\tdp=1;\n\t\t\tlast=1;\n\t\t}else{\n\t\t\tdp=0;\n\t\t\tlast=1;\n\t\t}\n\t\tint prev=cp;\n\t\tcp=move.get(cp,dp);\n\t\twhile(!stk.empty() && stk.back()>cp){\n\t\t\tbacktime[stk.back()]=t+1;\n\t\t\tstk.pop_back();\n\t\t}\n\t\tif(cp<start){\n\t\t\tcp=-1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(cp>=n){\n\t\t\t++t;\n\t\t\tbreak;\n\t\t}\n\t\tif(last && (buf[cp]==\'<\' || buf[cp]==\'>\')){\n\t\t\tmove.erase(prev);\n\t\t}\n\t}\n\tREP(hoge,q){\n\t\tint l,r;cin>>l>>r;\n\t\t--l;\n\t\tint begin=vised[l],end=t;\n\t\tif(backtime[l]>=0){\n\t\t\tend=min(end,backtime[l]);\n\t\t}\n\t\tif(r<n) end=min(end,vised[r]);\n\t\tREP(i,10){\n\t\t\tprintf(""%d%c"",putted[end][i]-putted[begin][i],i==9?\'\\n\':\' \');\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n']","['data structures', 'implementation']",2900
https://codeforces.com//contest/1487/problem/B,B. Cat Cycle,Suppose you are living with two cats A and B There are n napping spots where both cats usually sleep Your cats like to sleep and also like all these spots so they change napping spot each hour cyclically Cat A changes its napping place in order n n 1 n 2 dots 3 2 1 n n 1 dots In other words at the first hour it s on the spot n and then goes in decreasing order cyclically Cat B changes its napping place in order 1 2 3 dots n 1 n 1 2 dots In other words at the first hour it s on the spot 1 and then goes in increasing order cyclically The cat B is much younger so they have a strict hierarchy A and B don t lie together In other words if both cats d like to go in spot x then the A takes this place and B moves to the next place in its order if x n then to x 1 but if x n then to 1 Cat B follows his order so Calculate where cat B will be at hour k ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    ll N, K; cin >> N >> K;\n    if (N % 2 == 0) {\n        ll ans = K%N; if (ans == 0) ans = N;\n        cout << ans << nl;\n        return;\n    }\n    ll skip = (K - 1) / (N/2);\n    ll ans = (K+skip)%N; if (ans == 0) ans = N;\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['math', 'number theory']",1200
https://codeforces.com//contest/1538/problem/C,C. Number of Pairs,You are given an array a of n integers Find the number of pairs i j 1 le i j le n where the sum of a i a j is greater than or equal to l and less than or equal to r that is l le a i a j le r For example if n 3 a 5 1 2 l 4 and r 7 then two pairs are suitable i 1 and j 2 4 le 5 1 le 7 i 1 and j 3 4 le 5 2 le 7 ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nll n,m,i,j,k,t,t1,u,v,a,b,l,r;\nll arr[200001];\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n>>l>>r;\n        for (i=0;i<n;i++) cin>>arr[i];\n        sort(arr,arr+n);\n        b=0;\n        for (i=0;i<n;i++)\n        {\n            u=lower_bound(arr,arr+n,l-arr[i])-arr;\n            u=max(u,i+1);\n            v=upper_bound(arr,arr+n,r-arr[i])-arr;\n            if (v-u>=0) b+=v-u;\n        }\n        cout<<b<<endl;\n    }\n}\n']","['binary search', 'data structures', 'math', 'two pointers']",1300
https://codeforces.com//contest/1120/problem/E,E. The very same Munchhausen,A positive integer a is given Baron Munchausen claims that he knows such a positive integer n that if one multiplies n by a the sum of its digits decreases a times In other words S an S n a where S x denotes the sum of digits of the number x Find out if what Baron told can be true ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\nconst int vax=1007;\n//~ const int vax=3;\n\nint n;\n\nvi stos;\n\nbitset <2*vax> bylo[nax];\n\nconst int lim=500*1000;\n//~ const int lim=1e3;\n\nbool mniej(pair<pii,int> a, pair<pii,int> b)\n{\n\treturn abs(a.first.second)<abs(b.first.second);\n}\n\nvoid rek(int v, int roz, int juz, int gle)\n{\n\tif (abs(roz)>vax || gle>lim)\n\t\treturn;\n\tif (!v && !roz && juz)\n\t{\n\t\twhile((int)stos.size()>1 && !stos.back())\n\t\t\tstos.pop_back();\n\t\treverse(stos.begin(), stos.end());\n\t\tfor (int i : stos)\n\t\t\tprintf(""%d"", i);\n\t\tprintf(""\\n"");\n\t\texit(0);\n\t}\n\tif (bylo[v][roz+vax])\n\t\treturn;\n\tbylo[v][roz+vax]=1;\n\tvi szaf(10-(!juz));\n\tfor (int i=(!juz); i<10; i++)\n\t\tszaf[i-(!juz)]=i;\n\trandom_shuffle(szaf.begin(), szaf.end());\n\tfor (int i : szaf)\n\t{\n\t\tint x=(v+i*n);\n\t\tstos.push_back(i);\n\t\trek(x/10, roz+(x%10)*n-i, 1, gle+1);\n\t\tstos.pop_back();\n\t}\n}\n\nint main()\n{\n\t//~ srand(time(0));\n\tscanf(""%d"", &n);\n\tfor (int h=0; h<10; h++)\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tbylo[i].reset();\n\t\trek(0, 0, 0, 0);\n\t}\n\tprintf(""-1\\n"");\n\treturn 0;\n}\n']",['brute force'],2600
https://codeforces.com//contest/1140/problem/B,B. Good String,You have a string s of length n consisting of only characters and You may do some operations with this string for each operation you have to choose some character that still remains in the string If you choose a character the character that comes right after it is deleted if the character you chose was the last one nothing happens If you choose a character the character that comes right before it is deleted if the character you chose was the first one nothing happens For example if we choose character in string the string will become to And if we choose character in string the string will become to The string is good if there is a sequence of operations such that after performing it only one character will remain in the string For example the strings are good you may remove any number of characters from the given string possibly none possibly up to n 1 but not the whole string You need to calculate the minimum number of characters to be deleted from string s so that it becomes good ,"['#include<cstdio>\n#include<iostream>\nusing namespace std;\n#define N 122\nchar s[N];\nint main()\n{\n\tint T,n,ans;\n\tscanf(""%d"",&T);\n\twhile(T--)\n\t{\n\t\tscanf(""%d%s"",&n,s+1);\n\t\tfor (int i=1;i<=n;++i) if (s[i]==\'>\') {ans=i-1;break;}\n\t\tfor (int i=n;i;--i) if (s[i]==\'<\') {ans=min(ans,n-i);break;}\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}']","['implementation', 'strings']",1200
https://codeforces.com//contest/195/problem/C,C. Try and Catch,Vasya is developing his own programming language VPL Vasya Programming Language Right now he is busy making the system of exceptions He thinks that the system of exceptions must function like that The exceptions are processed by try catch blocks There are two operators that work with the blocks The operator It opens a new try catch block The operator It closes the try catch block that was started last and haven t yet been closed This block can be activated only via exception of type exception type When we activate this block the screen displays the message If at the given moment there is no open try catch block then we can t use the operator The exceptions can occur in the program in only one case when we use the operator The operator creates the exception of the given type Let s suggest that as a result of using some operator the program created an exception of type In this case a try catch block is activated such that this block s operator was described in the program earlier than the used operator Also this block s operator was given an exception type as a parameter and this block s operator is described later that the used operator If there are several such try catch blocks then the system activates the block whose operator occurs earlier than others If no try catch block was activated then the screen displays message To test the system Vasya wrote a program that contains only and operators one line contains no more than one operator the whole program contains exactly one operator Your task is given a program in VPL determine what message will be displayed on the screen ,"['#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N >> ws;\n\n    stack<int> es;\n    int th = -1;\n    string tp;\n    for (int i = 0; i < N; i++)\n    {\n        string line;\n        getline(cin, line);\n        replace(RA(line), \'(\', \' \');\n        replace(RA(line), \')\', \' \');\n        replace(RA(line), \',\', \' \');\n        istringstream toks(line);\n\n        string cmd;\n        toks >> cmd;\n        if (cmd == ""try"")\n        {\n            es.push(i);\n        }\n        else if (cmd == ""throw"")\n        {\n            toks >> tp;\n            th = i;\n        }\n        else if (cmd == ""catch"")\n        {\n            string t;\n            toks >> t;\n            if (t == tp && es.top() < th)\n            {\n                string msg;\n                getline(toks, msg);\n                msg.erase(0, msg.find(\'""\') + 1);\n                msg.erase(msg.find(\'""\'), msg.size());\n                cout << msg << \'\\n\';\n                return 0;\n            }\n            es.pop();\n        }\n    }\n    cout << ""Unhandled Exception\\n"";\n\n    return 0;\n}\n']","['expression parsing', 'implementation']",1800
https://codeforces.com//contest/1740/problem/F,F. Conditional Mix,Pak Chanek is given an array a of n integers For each i 1 leq i leq n Pak Chanek will write the one element set a i on a whiteboard After that in one operation Pak Chanek may do the following Choose two different sets S and T on the whiteboard such that S cap T varnothing S and T do not have any common elements Erase S and T from the whiteboard and write S cup T the union of S and T onto the whiteboard After performing zero or more operations Pak Chanek will construct a multiset M containing the sizes of all sets written on the whiteboard In other words each element in M corresponds to the size of a set after the operations How many distinct dagger multisets M can be created by this process Since the answer may be large output it modulo 998 244 353 dagger Multisets B and C are different if and only if there exists a value k such that the number of elements with value k in B is different than the number of elements with value k in C ,"['#include <bits/stdc++.h>\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        a[x - 1]++;\n    }\n    \n    std::vector<int> c(n + 1);\n    for (int i = 0; i < n; i++) {\n        c[a[i]]++;\n    }\n    \n    std::vector<int> lim(n + 1);\n    int v = 0, res = n;\n    for (int i = 0; i <= n; i++) {\n        v += i * c[i];\n        res -= c[i];\n        lim[i] = v + res * i;\n    }\n    \n    std::vector dp(n + 1, std::vector<Z>(n + 1));\n    dp[0][0] = 1;\n    for (int x = n; x; x--) {\n        for (int i = 0; i + x <= n; i++) {\n            for (int j = 0; j * x <= i; j++) {\n                if (i + x <= lim[j + 1]) {\n                    dp[i + x][j + 1] += dp[i][j];\n                }\n            }\n        }\n    }\n    \n    auto ans = std::accumulate(dp[n].begin(), dp[n].end(), Z(0));\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}\n']","['combinatorics', 'dp', 'math']",2600
https://codeforces.com//contest/713/problem/C,C. Sonya and Problem Wihtout a Legend,Sonya was unable to think of a story for this problem so here comes the formal description You are given the array containing positive integers At one turn you can pick any element and increase or decrease it by The goal is the make the array strictly increasing by making the minimum possible number of operations You are allowed to change elements in any way they can become negative or equal to ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nlong long ans;\nmultiset < int > S;\n\nint main ()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nscanf (""%d"", &N);\nfor (int i=1; i<=N; i++)\n{\n    int ai;\n    scanf (""%d"", &ai), ai -= i;\n//    printf (""%d%c"", ai, "" \\n""[i==N]);\n    if (S.empty () || (*S.rbegin ()) <= ai) S.insert (ai);\n    else\n    {\n        auto it = S.end (); it --;\n        ans += (*it) - ai, S.erase (it), S.insert (ai), S.insert (ai);\n    }\n}\nprintf (""%I64d\\n"", ans);\n\nreturn 0;\n}\n']","['dp', 'sortings']",2300
https://codeforces.com//contest/1805/problem/F1,F1. Survival of the Weakest  easy version ,Let a 1 a 2 ldots a n be an array of non negative integers Let F a 1 a 2 ldots a n be the sorted in the non decreasing order array of n 1 smallest numbers of the form a i a j where 1 le i j le n In other words F a 1 a 2 ldots a n is the sorted in the non decreasing order array of n 1 smallest sums of all possible pairs of elements of the array a 1 a 2 ldots a n For example F 1 2 5 7 1 2 1 5 2 5 3 6 7 You are given an array of non negative integers a 1 a 2 ldots a n Determine the single element of the array underbrace F F F ldots F n 1 a 1 a 2 ldots a n ldots Since the answer can be quite large output it modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(""YES"");\n\telse\n\t\tputs(""NO"");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(""yes"");\n\telse\n\t\tputs(""no"");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(""Yes"");\n\telse\n\t\tputs(""No"");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<\'0\'||c>\'9\')\n\t{\n\t\tif(c==\'-\')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>=\'0\'&&c<=\'9\')\n\t{\n\t\tx=x*10+c-\'0\';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar(\'-\'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+\'0\');\n//\tputchar(\'\\n\');\n}\ninline void fre()\n{\n\tfreopen("".in"",""r"",stdin);\n\tfreopen("".out"",""w"",stdout);\n}\nconstexpr int mod=1000000007;\nstruct node\n{\n\tint px,py,v;\n\tfriend bool operator<(node x,node y)\n\t{\n\t\treturn x.v>y.v;\n\t}\n};\nint ans=0;\nvector<int>f(vector<int>a)\n{\n\tvector<int>res;\n\tpriority_queue<node>q;\n\tfor(int i=1;i<a.size();i++)\n\t\tq.push({i-1,i,a[i-1]+a[i]});\n\tint t=a.size()-1;\n\twhile(t--)\n\t{\n\t\tres.push_back(q.top().v);\n\t\tnode x=q.top();\n\t\tq.pop();\n\t\tif(x.py+1<a.size())\n\t\t\tq.push({x.px,x.py+1,a[x.px]+a[x.py+1]});\n\t}\n\tans=(ans*2+res[0])%mod;\n\tint x=res[0];\n\tfor(int i=0;i<res.size();i++)\n\t\tres[i]-=x;\n\treturn res;\n}\nvoid work()\n{\n\tint n;\n\tvector<int>v;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tv.push_back(x);\n\t}\n\tsort(v.begin(),v.end());\n\twhile(v.size()>1)\n\t\tv=f(v);\n\tcout<<(ans)%mod;\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n//\tcases();\n\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n']","['binary search', 'brute force', 'implementation', 'math', 'sortings']",2600
https://codeforces.com//contest/1508/problem/C,C. Complete the MST,As a teacher Riko Hakozaki often needs to help her students with problems from various subjects Today she is asked a programming task which goes as follows You are given an undirected complete graph with n nodes where some edges are pre assigned with a positive weight while the rest aren t You need to assign all unassigned edges with so that in the resulting fully assigned complete graph the XOR sum of all weights would be equal to 0 Define the of a fully assigned complete graph the weight of its minimum spanning tree where the weight of a spanning tree equals the sum of weights of its edges You need to assign the weights so that the ugliness of the resulting graph is as small as possible As a reminder an undirected complete graph with n nodes contains all edges u v with 1 le u v le n such a graph has frac n n 1 2 edges She is not sure how to solve this problem so she asks you to solve it for her ,"[""#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, M; cin >> N >> M;\n\tstruct edge_t {\n\t\tarray<int, 2> V;\n\t\tint W;\n\t};\n\tvector<edge_t> edges(M);\n\tvector<set<int>> adj(N);\n\tint totW = 0;\n\tfor (auto& e : edges) {\n\t\tcin >> e.V[0] >> e.V[1] >> e.W; e.V[0]--, e.V[1]--;\n\t\ttotW ^= e.W;\n\t\tadj[e.V[0]].insert(e.V[1]);\n\t\tadj[e.V[1]].insert(e.V[0]);\n\t}\n\tsort(edges.begin(), edges.end(), [&](const auto& a, const auto& b) { return a.W < b.W; });\n\n\tint64_t num_unassigned = int64_t(N) * int64_t(N-1) / 2 - M;\n\n\tvector<int> par(N, -1);\n\tauto reset_par = [&]() -> void { fill(par.begin(), par.end(), -1); };\n\tauto get_par = [&](int a) -> int {\n\t\twhile (par[a] >= 0) {\n\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\n\t\t\ta = par[a];\n\t\t}\n\t\treturn a;\n\t};\n\tauto merge = [&](int a, int b) -> bool {\n\t\ta = get_par(a), b = get_par(b);\n\t\tif (a == b) return false;\n\t\tif (par[a] > par[b]) swap(a, b);\n\t\tpar[a] += par[b];\n\t\tpar[b] = a;\n\t\treturn true;\n\t};\n\n\t{\n\t\tint nm = 0;\n\t\tfor (int z = 0; z < M; z++) {\n\t\t\tedge_t e = edges[z];\n\t\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\t\tedges[nm++] = e;\n\t\t\t}\n\t\t}\n\t\tM = nm;\n\t\tedges.resize(M);\n\t}\n\n\treset_par();\n\n\tvector<int> unvis(N); iota(unvis.begin(), unvis.end(), 0);\n\tvector<int> q; q.reserve(N);\n\twhile (!unvis.empty()) {\n\t\tq.push_back(unvis.back()); unvis.pop_back();\n\t\tfor (int z = int(q.size())-1; z < int(q.size()); z++) {\n\t\t\tint cur = q[z];\n\t\t\tint b = 0;\n\t\t\tfor (int a = 0; a < int(unvis.size()); a++) {\n\t\t\t\tint nxt = unvis[a];\n\t\t\t\tif (adj[cur].count(nxt)) {\n\t\t\t\t\tunvis[b++] = nxt;\n\t\t\t\t} else {\n\t\t\t\t\tmerge(cur, nxt);\n\t\t\t\t\tnum_unassigned--;\n\t\t\t\t\tq.push_back(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunvis.resize(b);\n\t\t}\n\t}\n\n\tint64_t ans = 0;\n\tfor (auto e : edges) {\n\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\tans += e.W;\n\t\t} else if (num_unassigned == 0) {\n\t\t\tans += min(totW, e.W);\n\t\t\tnum_unassigned = -1;\n\t\t}\n\t}\n\n\tif (num_unassigned == 0) {\n\t\tans += totW;\n\t\tnum_unassigned = -1;\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n""]","['bitmasks', 'brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'trees']",2500
https://codeforces.com//contest/612/problem/C,C. Replace To Make Regular Bracket Sequence,You are given string consists of opening and closing brackets of four kinds There are two types of brackets opening and closing You can replace any bracket by another of the same type For example you can replace by the bracket but you can t replace it by or The following definition of a regular bracket sequence is well known so you can be familiar with it Let s define a regular bracket sequence RBS Empty string is RBS Let and be a RBS then the strings are also RBS For example the string is RBS but the strings and are not Determine the least number of replaces to make the string RBS ,"['/*\nHide from the public eye, choose to appear when it suits you\nClaim you\'re just, killing women and children\nFight, when you choose to fight, hide in a cave when you\'re hunted\nLike a beast spawned from hell, utilizing fear\n\nChosen by god or a coward insane?\nStand up and show me your face!\n\nSuicidal, in a trance\nA religious army\nFight without a uniform and hide in the crowd\nCall it holy, call it just\nAuthorized by heaven\nLeave your wounded as they die, and call it gods will\n\nRun when its time to pay, fear consequence of your action\nReappear, when you\'re almost forgotten\nDream of a world in peace, yet you cause pain and destruction\nKill your own, a response of your actions\n\nCaptured in all you lies, fear is in your eyes\nCreature who\'s gone insane, your war is in vain\nTrapped in a cage of stone, we\'ll destroy your home\nConsequence of your action\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nstring st;\nstack<char> S;\nint ans;\n\nint get_type(char c)\n{\n\tif (c == \'<\' || c == \'{\' || c == \'[\' || c == \'(\')\n\t\treturn 1;\n\treturn 2;\n}\n\nbool paired(char a, char b)\n{\n\tif (a == \'<\'&&b == \'>\')\n\t\treturn true;\n\tif (a == \'(\'&&b == \')\')\n\t\treturn true;\n\tif (a == \'[\'&&b == \']\')\n\t\treturn true;\n\tif (a == \'{\'&&b == \'}\')\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> st;\n\n\tfor (int i = 0; i < st.size(); i++)\n\t{\n\t\tif (get_type(st[i]) == 1)\n\t\t{\n\t\t\tS.push(st[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S.size() == 0)\n\t\t{\n\t\t\tcout << ""Impossible"" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tchar val = S.top();\n\t\tif (!paired(val, st[i]))\n\t\t\t++ans;\n\t\tS.pop();\n\t}\n\n\tif (S.size())\n\t{\n\t\tcout << ""Impossible"" << endl;\n\t\treturn 0;\n\t}\n\telse\n\n\t\tcout << ans << endl;\n\tcin.get(); cin.get();\n\treturn 0;\n}']","['data structures', 'expression parsing', 'math']",1400
https://codeforces.com//contest/1244/problem/E,E. Minimizing Difference,You are given a sequence a 1 a 2 dots a n consisting of n integers You may perform the following operation on this sequence choose any element and either increase or decrease it by one Calculate the minimum possible difference between the maximum element and the minimum element in the sequence if you can perform the aforementioned operation k times ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n, k;\nll a[100010];\nint l, r;\nvoid done() {\n\tputs(""0"");\n\texit(0);\n}\nvoid move_left() {\n\twhile(1) {\n\t\tif(l == r) done();\n\t\tif(a[l] != a[l + 1]) break;\n\t\tl++;\n\t}\n}\nvoid move_right(){\n\twhile(1) {\n\t\tif(r == l) done();\n\t\tif(a[r] != a[r - 1]) break;\n\t\tr--;\n\t}\n}\nint main() {\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tl = 0;\n\tr = n - 1;\n\twhile(k > 0) {\n\t\tmove_left();\n\t\tmove_right();\n\t\tint lc = l + 1;\n\t\tint rc = n - r;\n\t\tif(lc < rc) {\n\t\t\tll c = a[l + 1] - a[l];\n\t\t\tif(k < c * lc){\n\t\t\t\ta[0] += k / lc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk -= c * lc;\n\t\t\ta[0] = a[l] = a[l + 1];\n\t\t}\n\t\telse{\n\t\t\tll c = a[r] - a[r - 1];\n\t\t\tif(k < c * rc){\n\t\t\t\ta[n - 1] -= k / rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk -= c * rc;\n\t\t\ta[n - 1] = a[r] = a[r - 1];\n\t\t}\n\t}\n\tcout << (a[n - 1] - a[0]) << endl;\n\treturn 0;\n}']","['binary search', 'constructive algorithms', 'greedy', 'sortings', 'ternary search', 'two pointers']",2000
https://codeforces.com//contest/1658/problem/B,B. Marin and Anti-coprime Permutation,Marin wants you to count number of permutations that are A permutation of length n is a permutation that has the following property gcd 1 cdot p 1 2 cdot p 2 dots n cdot p n 1 where gcd is the greatest common divisor A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint a[1000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n&1) cout << ""0\\n"";\n\t\telse\n\t\t{\n\t\t\tint ans=1;\n\t\t\tfor(int i=1;i<=n/2;i++)\n\t\t\t\tans=(ans*i%mod*i)%mod;\n\t\t\tcout << ans << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","['combinatorics', 'math', 'number theory']",800
https://codeforces.com//contest/1933/problem/E,E. Turtle vs. Rabbit Race  Optimal Trainings,Isaac begins his training There are n running tracks available and the i th track 1 le i le n consists of a i equal length sections Given an integer u 1 le u le 10 9 finishing each section can increase Isaac s ability by a certain value described as follows Finishing the 1 st section increases Isaac s performance by u Finishing the 2 nd section increases Isaac s performance by u 1 Finishing the 3 rd section increases Isaac s performance by u 2 ldots Finishing the k th section k ge 1 increases Isaac s performance by u 1 k The value u 1 k can be negative which means finishing an extra section decreases Isaac s performance You are also given an integer l You must choose an integer r such that l le r le n and Isaac will finish section of track l l 1 dots r that is a total of sum i l r a i a l a l 1 ldots a r sections Answer the following question what is the optimal r you can choose that the increase in Isaac s performance is maximum possible If there are multiple r that maximize the increase in Isaac s performance output the r To increase the difficulty you need to answer the question for q different values of l and u ,"['/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e5+10;\nint n,a[N];\nvoid leeminhduc2()\n{\n    cin >> n;\n    for (int i=1;i<=n;i++)\n    {\n        cin >> a[i];\n        a[i]+=a[i-1];\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int l,u;\n        cin >> l >> u;\n        int lf=l,rg=n;\n        int pos=upper_bound(a+1,a+n+1,a[l-1]+u)-a;\n        if (pos==n+1) cout << n << "" "" ;\n        else if (pos==l) cout << l << "" "";\n        else\n            if (1ll*(u+u-(a[pos-1]-a[l-1])+1)*(a[pos-1]-a[l-1])/2>=1ll*(1+u)*u/2-1ll*(a[pos]-a[l-1]-u)*(a[pos]-a[l-1]-u-1)/2)\n                cout << pos-1 << "" "";\n            else\n                cout << pos << "" "";\n    }\n    cout << ""\\n"";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n']","['binary search', 'implementation', 'math', 'ternary search']",1500
https://codeforces.com//contest/351/problem/C,C. Jeff and Brackets,Jeff loves regular bracket sequences Today Jeff is going to take a piece of paper and write out the regular bracket sequence consisting of brackets Let s number all brackets of this sequence from to from left to right Jeff knows that he is going to spend liters of ink on the th bracket of the sequence if he paints it opened and liters if he paints it closed You ve got sequences and numbers What minimum amount of ink will Jeff need to paint a regular bracket sequence of length Operation means taking the remainder after dividing number by number ,"[""#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1<<29)\n\nint N;\nint open[30],clos[30];\nint dp1[30][30];\nint dp2[30][30];\nint diff[30];\n\nll func(ll M, ll cnt){\n    int i;\n    \n    ll ans = 0;\n    REP(i,N){\n        ll tmp = min(cnt, M);\n        cnt -= tmp;\n        ans += diff[i] * tmp;\n    }\n    \n    REP(i,N) ans += M * clos[i];\n    \n    return ans;\n}\n\nint main(void){\n    int M,i,j;\n    \n    cin >> N >> M;\n    REP(i,N) cin >> open[i];\n    REP(i,N) cin >> clos[i];\n    \n    REP(i,N) diff[i] = open[i] - clos[i];\n    sort(diff, diff + N);\n    \n    REP(i,N+1) REP(j,N+1) dp1[i][j] = dp2[i][j] = INF;\n    dp1[0][0] = 0;\n    REP(i,N) REP(j,N+1) if(dp1[i][j] != INF){\n        dp1[i+1][j+1] = min(dp1[i+1][j+1], dp1[i][j] + open[i]);\n        if(j > 0) dp1[i+1][j-1] = min(dp1[i+1][j-1], dp1[i][j] + clos[i]);\n    }\n    dp2[N][0] = 0;\n    for(i=N;i>0;i--) REP(j,N+1) if(dp2[i][j] != INF){\n        dp2[i-1][j+1] = min(dp2[i-1][j+1], dp2[i][j] + clos[i-1]);\n        if(j > 0) dp2[i-1][j-1] = min(dp2[i-1][j-1], dp2[i][j] + open[i-1]);\n    }\n    \n    ll ans = (1ll<<60);\n    \n    REP(i,N+1) REP(j,N+1) if(dp1[N][i] != INF && dp2[0][j] != INF){\n        ll tmp = dp1[N][i] + dp2[0][j];\n        int cnt_open = N * M / 2;\n        cnt_open -= (N + i) / 2;\n        cnt_open -= (N - j) / 2;\n        if(cnt_open >= 0 && cnt_open <= N * (M - 2)){\n        //  cout << i << ' ' << j << ' ' << tmp << endl;\n            tmp += func(M - 2, cnt_open);\n        //  cout << i << ' ' << j << ' ' << tmp << endl;\n            ans = min(ans, tmp);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n""]","['dp', 'matrices']",2500
https://codeforces.com//contest/1083/problem/D,D. The Fair Nut s getting crazy,The Fair Nut has found an array a of n integers We call subarray l ldots r a sequence of consecutive elements of an array with indexes from l to r i e a l a l 1 a l 2 ldots a r 1 a r No one knows the reason but he calls a pair of subsegments good if and only if the following conditions are satisfied These subsegments should not be nested That is each of the subsegments should contain an element as an index that does not belong to another subsegment Subsegments intersect and each element that belongs to the intersection belongs each of segments only once For example a 1 2 3 5 5 Pairs 1 ldots 3 2 ldots 5 and 1 ldots 2 2 ldots 3 are good but 1 dots 3 2 ldots 3 and 3 ldots 4 4 ldots 5 are not subsegment 1 ldots 3 contains subsegment 2 ldots 3 integer 5 belongs both segments but occurs twice in subsegment 4 ldots 5 Help the Fair Nut to find out the number of pairs of good subsegments The answer can be rather big so print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 1234567;\nconst i64 mod = 1000000007;\n\nstruct atom {\n\ti64 s0, sa, sb, sab;\n\ti64 taga, tagb;\n} t[maxN << 2];\n\nmap<int, int> num;\nstack<pair<int, int>> seg, sega;\nint n, m;\nint ocr[maxN], pos[maxN], a[maxN];\ni64 s0, s1, ans;\n\nvoid pushup(int p) {\n\tt[p].sa = (t[p + p].sa + t[p + p + 1].sa) % mod;\n\tt[p].sb = (t[p + p].sb + t[p + p + 1].sb) % mod;\n\tt[p].sab = (t[p + p].sab + t[p + p + 1].sab) % mod;\n}\n\nvoid apply(int p, i64 taga, i64 tagb) {\n\tt[p].taga = (t[p].taga + taga) % mod;\n\tt[p].tagb = (t[p].tagb + tagb) % mod;\n\tt[p].sab = (t[p].sab + taga * t[p].sb + tagb * t[p].sa + taga * tagb * t[p].s0) % mod;\n\tt[p].sa = (t[p].sa + taga * t[p].s0) % mod;\n\tt[p].sb = (t[p].sb + tagb * t[p].s0) % mod;\n}\nvoid build(int p, int l, int r) {\n\tt[p].s0 = r - l + 1;\n\tif (l == r) {\n\t\tt[p]. sa = l - 1;\n\t} else {\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(p + p, l, mid);\n\t\tbuild(p + p + 1, mid + 1, r);\n\t\tpushup(p);\n\t}\n}\n\nvoid pushdown(int p) {\n\tif (t[p].taga || t[p].tagb) {\n\t\tapply(p + p, t[p].taga, t[p].tagb);\n\t\tapply(p + p + 1, t[p].taga, t[p].tagb);\n\t\tt[p].taga = 0;\n\t\tt[p].tagb = 0;\n\t}\n}\n\ni64 query(int p, int l, int r, int segl, int segr) {\n\tif (segl > segr) return 0;\n\tif (segl == l && segr == r) {\n\t\treturn t[p].sab;\n\t} else {\n\t\tpushdown(p);\n\t\tint mid = (l + r) >> 1;\n\t\treturn (query(p + p, l, mid, segl, min(mid, segr)) +\n\t\t        query(p + p + 1, mid + 1, r, max(mid + 1, segl), segr)) % mod;\n\t}\n}\nvoid modify(int p, int l, int r, int segl, int segr, int taga, int tagb) {\n\tif (segl == l && segr == r) {\n\t\tapply(p, taga, tagb);\n\t} else {\n\t\tpushdown(p);\n\t\tint mid = (l + r) >> 1;\n\t\tif (segl <= mid) modify(p + p, l, mid, segl, min(mid, segr), taga, tagb);\n\t\tif (segr > mid) modify(p + p + 1, mid + 1, r, max(mid + 1, segl), segr, taga, tagb);\n\t\tpushup(p);\n\t}\n}\n\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tif (!num.count(x)) {\n\t\t\tnum[x] = ++m;\n\t\t}\n\t\ta[i] = num[x];\n\t}\n\tfor (int i = 1; i <= m; i++) ocr[i] = n + 1;\n\tfor (int i = n; i >= 1; i--) {\n\t\tpos[i] = ocr[a[i]];\n\t\tocr[a[i]] = i;\n\t}\n\tbuild(1, 1, n);\n\tfor (int i = 1; i <= m; i++) ocr[i] = 0;\n\tint posl = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint posr = ocr[a[i]];\n\t\tposl = max(posl, ocr[a[i]]);\n\t\tocr[a[i]] = i;\n\t\tint p = i;\n\t\twhile (!seg.empty() && seg.top().second > pos[i]) {\n\t\t\tmodify(1, 1, n, seg.top().first, p - 1, 0, -seg.top().second);\n\t\t\tp = seg.top().first;\n\t\t\tseg.pop();\n\t\t}\n\t\tmodify(1, 1, n, p, i, 0, pos[i]);\n\t\tseg.push(make_pair(p, pos[i]));\n\t\tp = i;\n\t\twhile (!sega.empty() && sega.top().second < posr) {\n\t\t\tmodify(1, 1, n, sega.top().first, p - 1, sega.top().second, 0);\n\t\t\tp = sega.top().first;\n\t\t\tsega.pop();\n\t\t}\n\t\tmodify(1, 1, n, p, i, -posr, 0);\n\t\tsega.push(make_pair(p, posr));\n\t\tmodify(1, 1, n, posl + 1, i, 0, -i - 1);\n\t\tans = (ans + query(1, 1, n, posl + 1, i)) % mod;\n\t\tmodify(1, 1, n, posl + 1, i, 0, i + 1);\n\t}\n\tif (ans < 0) ans += mod;\n\tprintf(""%lld\\n"", ans);\n}']","['data structures', 'implementation']",3500
https://codeforces.com//contest/1701/problem/A,A. Grass Field,There is a field of size 2 times 2 Each cell of this field can either contain grass or be empty The value a i j is 1 if the cell i j contains grass or 0 otherwise In one move you can choose and and cut all the grass in this row and this column In other words you choose the row x and the column y then you cut the grass in all cells a x i and all cells a i y for all i from 1 to 2 After you cut the grass from a cell it becomes empty i e its value is replaced by 0 Your task is to find the minimum number of moves required to cut the grass in all non empty cells of the field i e make all a i j zeros You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:34:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a + b + c + d == 0) {\n      cout << 0 << \'\\n\';\n    } else {\n      if (a + b + c + d == 4) {\n        cout << 2 << \'\\n\';\n      } else {\n        cout << 1 << \'\\n\';\n      }\n    }\n  }\n  return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1671/problem/F,F. Permutation Counting,Calculate the number of permutations p of size n with exactly k inversions pairs of indices i j such that i j and p i p j and exactly x indices i such that p i p i 1 Yep that s the whole problem Good luck ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:46:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n\n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    for (int i = n - 1; i >= m - 1; i--) {\n      Mint c = a.back() / b.back();\n      for (int j = 0; j < m; j++) {\n        a[i - (m - 1) + j] -= b[j] * c;\n      }\n      a.pop_back();\n    }\n/*    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }*/\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<T> BM(vector<T> a) {\n  vector<T> p = {1};\n  vector<T> q = {1};\n  int l = 0;\n  for (int r = 1; r <= (int) a.size(); r++) {\n    T delta = 0;\n    for (int j = 0; j <= l; j++) {\n      delta += a[r - 1 - j] * p[j];\n    }\n    q.insert(q.begin(), 0);\n    if (delta != 0) {\n      vector<T> t = p;\n      if (q.size() > t.size()) {\n        t.resize(q.size());\n      }\n      for (int i = 0; i < (int) q.size(); i++) {\n        t[i] -= delta * q[i];\n      }\n      if (2 * l <= r - 1) {\n        q = p;\n        T od = 1 / delta;\n        for (T& x : q) {\n          x *= od;\n        }\n        l = r - l;\n      }\n      swap(p, t);\n    }\n  }\n  assert((int) p.size() == l + 1);\n//  assert(l * 2 + 30 < (int) a.size());\n  reverse(p.begin(), p.end());\n  return p;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = 111;\n  vector<vector<vector<vector<Mint>>>> f(N, vector<vector<vector<Mint>>>(N, vector<vector<Mint>>(12, vector<Mint>(12))));\n  f[1][0][0][0] = 1;\n  for (int n = 1; n < N - 1; n++) {\n    for (int p = 0; p < n; p++) {\n      for (int k = 0; k <= 11; k++) {\n        for (int x = 0; x <= 11; x++) {\n          for (int t = 0; t <= n; t++) {\n            int nk = k + (n - t);\n            int nx = x + (t <= p);\n            if (nk <= 11 && nx <= 11) {\n              f[n + 1][t][nk][nx] += f[n][p][k][x];\n            }\n          }\n        }\n      }\n    }\n  }\n  vector<vector<vector<Mint>>> r(12, vector<vector<Mint>>(12));\n  vector<vector<vector<Mint>>> vecs(12, vector<vector<Mint>>(12));\n  for (int k = 1; k <= 11; k++) {\n    for (int x = 1; x <= 11; x++) {\n      vector<Mint>& vec = vecs[k][x];\n      for (int n = 1; n < N; n++) {\n        Mint s = 0;\n        for (int p = 0; p < n; p++) {\n          s += f[n][p][k][x];\n        }\n        vec.push_back(s);\n      }\n      r[k][x] = BM(vec);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k, x;\n    cin >> n >> k >> x;\n    auto y = power(vector<Mint>{0, 1}, n - 1, r[k][x]);\n    Mint ans = 0;\n    for (int i = 0; i < (int) y.size(); i++) {\n      ans += y[i] * vecs[k][x][i];\n    }\n    cout << ans << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']","['brute force', 'combinatorics', 'dp', 'fft', 'math']",2700
https://codeforces.com//contest/785/problem/D,D. Anton and School - 2,As you probably know Anton goes to school One of the school subjects that Anton studies is Bracketology On the Bracketology lessons students usually learn different sequences that consist of round brackets characters and without quotes On the last lesson Anton learned about the regular simple bracket sequences RSBS A bracket sequence of length is an RSBS if the following conditions are met It is not empty that is The length of the sequence is even First charactes of the sequence are equal to Last charactes of the sequence are equal to For example the sequence is an RSBS but the sequences and are not RSBS Elena Ivanovna Anton s teacher gave him the following task as a homework Given a bracket sequence Find the number of its distinct subsequences such that they are RSBS Note that a subsequence of is a string that can be obtained from by deleting some of its elements Two subsequences are considered distinct if distinct sets of positions are deleted Because the answer can be very big and Anton s teacher doesn t like big numbers she asks Anton to find the answer modulo Anton thought of this task for a very long time but he still doesn t know how to solve it Help Anton to solve this task and write a program that finds the answer for it ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst LL md=1000000007LL;\nconst int MX=400111;\nLL fac[MX],facinv[MX],inv[MX];\ninline LL C(LL x,LL y){\n\treturn fac[x]*facinv[y]%md*facinv[x-y]%md;\n}\nvoid ini(){\n\tfac[0]=1LL,facinv[0]=1LL;\n\tinv[1]=1LL;\n\tfor(LL i=2;i<=400000;i++)inv[i]=(md-md/i)*inv[md%i]%md;\n\tfor(LL i=1;i<=400000;i++)fac[i]=fac[i-1]*i%md;\n\tfor(LL i=1;i<=400000;i++)facinv[i]=facinv[i-1]*inv[i]%md;\n}\nchar s[MX];\nint n;LL lc,rc;\nint main(){\n\tini();\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\tfor(int i=0;i<n;i++)if(s[i]==\'(\')lc++;else rc++;\n\tLL tx=0LL,ty=rc,ans=0LL;\n\tfor(LL i=0;i<n;i++){\n\t\tif(!ty)break;\n\t\tif(s[i]==\'(\'){\n\t\t\ttx++;ans=(ans+C(tx+ty-1,ty-1))%md;\n\t\t}else ty--;\n\t}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math', 'number theory']",2300
https://codeforces.com//contest/223/problem/C,C. Partial Sums,You ve got an array consisting of integers The array elements are indexed from 1 to Let s determine a two step operation like that First we build by the array an array of partial sums consisting of elements Element number of array equals The operation means that we take the remainder of the division of number by number Then we write the contents of the array to the array Element number of the array becomes the th element of the array You task is to find array after exactly described operations are applied ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint c[2010];\nconst int mod=(int)1e9+7;\ninline int add(int a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n    return a;\n}\ninline int mul(int a,int b){\n    return ((long long)a*(long long)b)%mod;\n}\nint in[2010];\ninline int rev(long long a,long long b){\n    if(a==1)return 1;\n    return (((1-rev(b%a,a)*b)/a)%b+b)%b;\n}\nint out[2010];\nint main(){\n    int n,k,i,j;\n    scanf(""%d%d"",&n,&k);\n    for(i=0;i<n;i++)scanf(""%d"",&in[i]);\n    if(k==0){\n        for(i=0;i<n;i++)out[i]=in[i];\n    }else{\n        k--;\n        c[0]=1;\n        for(i=1;i<n;i++){\n            c[i]=mul(mul(c[i-1],add(k,i)),rev(i,mod));\n        }\n        for(i=0;i<n;i++){\n            out[i]=0;\n            for(j=0;j<=i;j++)out[i]=add(out[i],mul(in[j],c[i-j]));\n        }\n    }\n    for(i=0;i<n;i++){\n        printf(""%d%c"",out[i],(i==n-1?\'\\n\':\' \'));\n    }\n\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","['combinatorics', 'math', 'number theory']",1900
https://codeforces.com//contest/914/problem/C,C. Travelling Salesman and Special Numbers,The Travelling Salesman spends a lot of time travelling so he tends to get bored To pass time he likes to perform operations on numbers One such operation is to take a positive integer and reduce it to the number of bits set to in the binary representation of For example for number it s true that so it has bits set and will be reduced to in one operation He calls a number if the minimum number of operations to reduce it to is He wants to find out how many special numbers exist which are not greater than Please help the Travelling Salesman as he is about to reach his destination Since the answer can be large output it modulo ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=1005;\nconst int P=1000000007;\ninline int Pow(int a,int b){\n\tint c=1;\n\tfor(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;\n\treturn c;\n}\nint cnt[N];\nint n,k;\nchar a[N];\nint num[N];\nint f[N][N][2];\nint main(){\n\trep(i,1,1000)cnt[i]=cnt[i>>1]+(i&1);\t\n\tscanf(""%s"",a+1);\n\tn=strlen(a+1);\n\tscanf(""%d"",&k);\n\tif(k==0){\n\t\tprintf(""1\\n"");\n\t\treturn 0;\n\t}\n\t--k;\n\trep(i,2,n){\n\t\tnum[i]=num[cnt[i]]+1;\n\t}\n\tf[1][0][1]=1;\n\trep(i,1,n)rep(j,0,n)rep(d,0,1){\n\t\trep(c,0,1){\n\t\t\tif((c>(a[i]-\'0\'))&&d)continue;\n\t\t\tf[i+1][j+c][d&(c==(a[i]-\'0\'))]=(f[i+1][j+c][d&(c==(a[i]-\'0\'))]+f[i][j][d])%P;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,1,n)rep(d,0,1)if(num[i]==k)ans=(ans+f[n+1][i][d])%P;\n\tif(!k){\n\t\tans=(ans+P-1)%P;\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n']","['brute force', 'combinatorics', 'dp']",1800
https://codeforces.com//contest/1373/problem/D,D. Maximum Sum on Even Positions,You are given an array a consisting of n integers Indices of the array start from zero i e the first element is a 0 the second one is a 1 and so on You can reverse subarray continuous subsegment of this array Recall that the subarray of a with borders l and r is a l r a l a l 1 dots a r Your task is to reverse such a subarray that the sum of elements on positions of the resulting array is i e the sum of elements a 0 a 2 dots a 2k for integer k lfloor frac n 1 2 rfloor should be maximum possible You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        vl A(N); F0R(i, N) cin >> A[i];\n        ll P = 0;\n        ll pre[N+1];\n        pre[0] = 0;\n        ll lo2 = 0;\n        ll lo1 = 1e15;\n        ll ans = 0;\n        F0R(i, N) {\n            if (i % 2 == 0) {\n                P += A[i];\n                pre[i+1] = pre[i] - A[i];\n            } else {\n                pre[i+1] = pre[i] + A[i];\n            }\n            if ((i+1) % 2) {\n                ckmin(lo1, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo1);\n            } else {\n                ckmin(lo2, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo2);\n            }\n\n        }\n//        cout << P << "" "" << pre[N] << nl;\n\n        cout << ans+P << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['divide and conquer', 'dp', 'greedy', 'implementation']",1600
https://codeforces.com//contest/1884/problem/E,E. Hard Design,Consider an array of integers b 0 b 1 ldots b n 1 Your goal is to make all its elements equal To do so you can perform the following operation several possibly zero times Pick a pair of indices 0 le l le r le n 1 then for each l le i le r increase b i by 1 i e replace b i with b i 1 After performing this operation you receive r l 1 2 coins The value f b is defined as a pair of integers cnt cost where cnt is the number of operations required to make all elements of the array equal and cost is the total number of coins you can receive among all possible ways to make all elements equal within cnt operations In other words first you need to minimize the number of operations second you need to maximize the total number of coins you receive You are given an array of integers a 0 a 1 ldots a n 1 Please find the value of f for all cyclic shifts of a Formally for each 0 le i le n 1 you need to do the following Let c j a j i pmod n for each 0 le j le n 1 Find f c Since cost can be very large output it modulo 10 9 7 Please note that under a fixed cnt you need to maximize the total number of coins cost not its remainder modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 65536, stdin), p1 == p2) ? EOF : *p1 ++)\n#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++\n#define putchar(x) (p3 - obuf < 1000000) ? (*p3++ = x) : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x)\nusing namespace std;\nstatic char buf[29999999], *p1 = buf, *p2 = buf, obuf[29999999], *p3 = obuf;\ntemplate <typename item>\ninline void read (register item &x) {\n    x = 0;\n\tregister char c = getchar();\n    while (c < \'0\' || c > \'9\') c = getchar();\n    while (c >= \'0\' && c <= \'9\') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n}\nstatic char cc[15];\ntemplate <typename item>\ninline void print (register item x) {\n\tregister int len = 0;\n\tdo cc[len++] = x % 10 + \'0\', x /= 10; while (x);\n\twhile (len--) putchar(cc[len]);\n}\nint N;ll A[2000006];\nconst ll inf=1e16,mod=1e9+7;\nstruct node{int x,y;ll cnt;}B[4000006];\nint tot;ll d[2000006];\nint stk[2000005],tail;\nvoid add(ll &x,const ll y){\n\tif((x+=y)>=mod)x-=mod;\n}\nbool cmp(node a,node b){\n\treturn a.x<b.x;\n}\nbool cmp1(node a,node b){\n\treturn a.y>b.y;\n}\nstruct BIT{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tv%=mod;\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))add(val[i],v);\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))add(res,val[i]);\n\t\treturn res;\n\t}\n}b0,b2,b3;\nstruct BIT1{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))val[i]+=v;\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))res+=val[i];\n\t\treturn res;\n\t}\n}B1;\nll res1[1000005],res2[1000005],sum[2000005];\nvoid solve(){\n\tread(N);ll mx=0ll;tot=0;\n\tfor(int i=1;i<=N;++i)read(A[i]),mx=max(mx,A[i]),res1[i]=res2[i]=0ll;\n\tif(N==1){print(0);putchar(\' \');print(0);putchar(\'\\n\');return ;}\n\tA[0]=inf;for(int i=N+1;i<=2*N;++i)A[i]=A[i-N];\n\tfor(int i=1;i<2*N;++i){\n\t\tsum[i]=sum[i-1];\n\t\tif(A[i+1]<A[i])sum[i]+=A[i]-A[i+1];\n\t}\n    for(int i=0;i<2*N;++i)d[i]=A[i]-A[i+1];tail=0;\n    for(int i=0;i<2*N;++i){\n    \tif(d[i]<0ll){\n    \t\twhile(d[i]<0ll){\n    \t\t\tif(d[stk[tail]]<-d[i]){\n    \t\t\t\tB[++tot]=node{stk[tail],i,d[stk[tail]]};\n    \t\t\t\td[i]+=d[stk[tail]];d[stk[tail--]]=0ll;\n\t\t\t\t}else {\n\t\t\t\t\tB[++tot]=node{stk[tail],i,-d[i]};\n\t\t\t\t\td[stk[tail]]+=d[i];d[i]=0ll;\n\t\t\t\t\tif(!d[stk[tail]])--tail;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d[i]>0ll)stk[++tail]=i; \n\t}\n\twhile(tail){\n\t\tB[++tot]=node{stk[tail],2*N,d[stk[tail]]};\n\t\td[stk[tail--]]=0ll;\n\t}\n    for(int i=1;i<=N;++i)res1[i]=sum[i+N-2]-sum[i-1]+mx-A[i];\n    b0.init();b2.init();b3.init();B1.init();\n\tsort(B+1,B+tot+1,cmp);int nd=1;\n    for(int i=0;i<=2*N;++i){\n    \twhile(nd<=tot&&B[nd].x<=i){\n    \t\tb0.modify(B[nd].y,1ll*(B[nd].y-B[nd].x)*(B[nd].y-B[nd].x)%mod*(B[nd].cnt%mod)%mod);\n    \t\tB1.modify(B[nd].y,B[nd].cnt);b2.modify(B[nd].y,1ll*B[nd].y*B[nd].cnt%mod);\n    \t\tb3.modify(B[nd].y,1ll*B[nd].y*B[nd].y%mod*B[nd].cnt%mod); ++nd;\n\t\t}\n    \tif(i+1<=N){\n    \t\tres2[i+1]=(res2[i+1]+mod-(b0.query(i+N-1)+mod-b0.query(i))%mod)%mod;\n    \t\tll allcnt=B1.query(i+N-1)-B1.query(i);res2[i+1]=(res2[i+1]+1ll*N*N%mod*((mx-A[i+1]-allcnt)%mod)%mod)%mod;\n\t\t\tallcnt%=mod;res2[i+1]=(res2[i+1]+1ll*i*i%mod*allcnt)%mod;\n\t\t\tll c3=b3.query(i+N-1)-b3.query(i)+mod,c2=b2.query(i+N-1)-b2.query(i)+mod;c3%=mod;c2%=mod;\n\t\t\tres2[i+1]=(res2[i+1]+mod-2ll*i*c2%mod)%mod;\n\t\t\tres2[i+1]=(res2[i+1]+c3)%mod;   \n\t\t} \n\t\tif(i-(N-2)<=N&&i-(N-2)>=1)res2[i-(N-2)]=(res2[i-(N-2)]+b0.query(i)-b0.query(i-(N-2)-1)+mod)%mod;\n\t} nd=1;B1.init();b2.init();b3.init();sort(B+1,B+tot+1,cmp1);\n\tfor(int i=2*N;i>=1;--i){\n\t\twhile(nd<=tot&&B[nd].y>=i){\n\t\t\tif(B[nd].x){\n\t\t\t\tB1.modify(B[nd].x,B[nd].cnt); b2.modify(B[nd].x,1ll*B[nd].x*B[nd].cnt%mod);\n\t\t\t    b3.modify(B[nd].x,1ll*B[nd].x*B[nd].x%mod*B[nd].cnt%mod);\n\t\t\t}\n\t\t\t++nd; \n\t\t}\n\t\tif(i-(N-1)<=N&&i-(N-1)>=1){\n\t\t\tint l=i-(N-1);\n\t\t\tll c1=B1.query(i-1)-B1.query(l-1),c2=b2.query(i-1)-b2.query(l-1)+mod,c3=b3.query(i-1)-b3.query(l-1)+mod;\n\t\t//\tcout<<l<<"" ""<<c1<<endl;\n\t\t\tc2%=mod;c3%=mod;c1%=mod;\n\t\t    res2[l]=(res2[l]+1ll*i*i%mod*c1%mod)%mod;\n\t\t    res2[l]=(res2[l]-2ll*i*c2%mod+mod)%mod;\n\t\t    res2[l]=(res2[l]+c3)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tprint(res1[i]);putchar(\' \');\n\t\tprint(res2[i]);putchar(\'\\n\');\n\t}\n}\nint main(){\n\tint t;read(t);\n\twhile(t--)solve(); \n\tfwrite(obuf, p3 - obuf, 1, stdout);\n    return 0;\n}']","['greedy', 'implementation', 'math']",2800
https://codeforces.com//contest/734/problem/C,C. Anton and Making Potions,Anton is playing a very interesting computer game but now he is stuck at one of the levels To pass to the next level he has to prepare potions Anton has a special kettle that can prepare one potions in seconds Also he knows spells of two types that can faster the process of preparing potions Spells of this type speed up the preparation time of one potion There are spells of this type the th of them costs manapoints and changes the preparation time of each potion to instead of Spells of this type immediately prepare some number of potions There are such spells the th of them costs manapoints and instantly create potions Anton can use spell of the first type and spell of the second type and the total number of manapoints spent should not exceed Consider that all spells are used instantly and right before Anton starts to prepare potions Anton wants to get to the next level as fast as possible so he is interested in the minimum number of time he needs to spent in order to prepare at least potions ,"['#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 200500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\npair < int, int > a[maxn];\npair < int, int > b[maxn];\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( ""input.txt"", ""r"", stdin );\n    // freopen( ""output.txt"", ""w"", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n, m, k;\n    scanf ( ""%d%d%d"", &n, &m, &k );\n    int x, S;\n    scanf ( ""%d%d"", &x, &S );\n    for ( int j = 1; j <= m; j++ )\n    \tscanf ( ""%d"", &a[j].s );\n    for ( int j = 1; j <= m; j++ )\n    \tscanf ( ""%d"", &a[j].f );\n\n    for ( int j = 1; j <= k; j++ )\n    \tscanf ( ""%d"", &b[j].s );\n    for ( int j = 1; j <= k; j++ )\n    \tscanf ( ""%d"", &b[j].f );\n    a[0] = mp( 0, x );\n    b[0] = mp( 0, 0 );\n    sort( a, a + m + 1 );\n    sort( b, b + k + 1 );\n    reverse( b, b + k + 1 );\n    int it = 0;\n    ll ans = 1LL * x * n;\n    pair < int, int > curMax = mp( 0, x );\n    for ( int j = 0; j <= k; j++ ) {\n    \tif ( b[j].f > S )\n    \t\tcontinue;\n    \twhile ( it <= m && a[it].f <= S - b[j].f ) {\n    \t\tif ( curMax.s > a[it].s )\n    \t\t\tcurMax = a[it];\n    \t\t++it;\n    \t}\n    \tll curAns = 1LL * curMax.s * ( max( 0, n - b[j].s ) );\n    \tans = min( curAns, ans );\n    }\n    cout << ans << endl;\n    return 0;\n}\n']","['binary search', 'dp', 'greedy', 'two pointers']",1600
https://codeforces.com//contest/1634/problem/D,D. Finding Zero,We picked an array of whole numbers a 1 a 2 ldots a n 0 le a i le 10 9 and concealed zero in it Your goal is to find the location of this zero that is to find i such that a i 0 You are allowed to make several queries to guess the answer For each query you can think up three distinct indices i j k and we will tell you the value of max a i a j a k min a i a j a k In other words we will tell you the difference between the maximum and the minimum number among a i a j and a k You are allowed to make no more than 2 cdot n 2 queries and after that you have two tries to guess where the zero is That is you have to tell us two numbers i and j and you win if a i 0 or a j 0 Can you guess where we hid the zero Note that the array in each test case is fixed beforehand and will not change during the game In other words the interactor is not adaptive ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nconst int mxn=1e3+3;\nint n;\nint a[mxn],b[mxn];\ninline int ask(int x,int y,int z){\n\tcout<<""? ""<<x<<\' \'<<y<<\' \'<<z<<endl;\n\tfflush(stdout);\n\tint rt;cin>>rt;\n\treturn rt;\n}\ninline void print(int x,int y){\n\tcout<<""! ""<<x<<\' \'<<y<<endl;\n\tfflush(stdout);\n\treturn;\n}\ninline void solve(){\n\tcin>>n;\n\tmemset(a,0,sizeof(a));\n\tmemset(b,0,sizeof(b));\n\tint pos1=1;\n\tint allsame=1;\n\tint lst=-1;\n\tfor(int i=3;i<=n;++i){\n\t\ta[i]=ask(1,2,i);\n\t\tif(a[i]>a[pos1])pos1=i;\n\t\tif(lst==-1)lst=a[i];\n\t\telse{\n\t\t\tif(a[i]!=lst){\n\t\t\t\tlst=a[i];\n\t\t\t\tallsame=0;\n\t\t\t}\n\t\t}\n\t}\n\tint allsame2=1,lst2=-1;\n\tint pos2=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(i==pos1)continue;\n\t\tb[i]=ask(1,i,pos1);\n\t\tif(b[i]>=b[pos2])pos2=i;\n\t\tif(lst2==-1)lst2=b[i];\n\t\telse if(lst2!=b[i])allsame2=0;\n\t}\n\tif(pos2==2)++pos2;\n\tif(pos2==pos1)++pos2;\n\n\tif(allsame==1){//this can all be x[1]-x[2]\n\t\tint t=ask(1,pos1,pos2);\n\t\tif(t<lst){\n\t\t\tprint(1,2);\n\t\t\treturn;\n\t\t}\n\t}\n//\tcerr<<""! wtf ""<<pos1<<\' \'<<pos2<<\'\\n\';\n\t//now if both x[1] and x[2] isn\'t 0 this is okay\n\t//if x[2] is 0? what will happen?\n\t//a[i] will be x[i]. How to ensure it?\n\t//we can ask(2,pos1,pos2) to check\n\t//if x[1] is 0: it is smaller than either a[pos1] or a[pos2] we can return [1,1]\n\t//if x[2] is 0: this returns a[pos1 or pos2] then we can return [2,pos1 or pos2]\n\t//otherwise we can return [pos1,pos2]\n\t//oops,there still can be x[1] is max and pos1 is zero\n\tif(allsame2==1){\n\t\tprint(1,pos1);\n\t\treturn;\n\t}\n\tint t=ask(2,pos1,pos2);\n\tif((t<a[pos1] and t<=a[pos2]) or (t<=a[pos1] and t<a[pos2])){\n\t\tprint(1,2);\n\t\treturn;\n\t}\n\tif(t==a[pos1]){\n\t\tprint(2,pos1);\n\t\treturn;\n\t}\n\tif(t==a[pos2]){\n\t\tprint(2,pos2);\n\t\treturn;\n\t}\n\n\tprint(pos1,pos2);\n\treturn;\n}\nint main(){\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}']","['constructive algorithms', 'interactive', 'math']",2000
https://codeforces.com//contest/1797/problem/B,B. Li Hua and Pattern,Li Hua has a pattern of size n times n each cell is either blue or red He can perform operations In each operation he chooses a cell and changes its color from red to blue or from blue to red Each cell can be chosen as many times as he wants Is it possible to make the pattern that matches its rotation by 180 circ Suppose you were Li Hua please solve this problem ,"['// LUOGU_RID: 110066180\n#include<bits/stdc++.h>\n#define int long long\nconst int N=1e5+5,M=1005;\nusing namespace std;\nint n,a[M][M],k,sum;\nvoid solve()\n{\n\tcin>>n>>k;sum=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tcin>>a[i][j];\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(a[i][j]!=a[n-i+1][n-j+1]){sum++;a[n-i+1][n-j+1]=a[i][j];}\n\tif(sum>k||(((k-sum)&1)&&n%2==0))cout<<""No\\n"";\nelse cout<<""Yes\\n"";\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}']","['constructive algorithms', 'greedy']",1100
https://codeforces.com//contest/1041/problem/A,A. Heist,There was an electronic store heist last night All keyboards which were in the store yesterday were numbered in ascending order from some integer number x For example if x 4 and there were 3 keyboards in the store then the devices had indices 4 5 and 6 and if x 10 and there were 7 of them then the keyboards had indices 10 11 12 13 14 15 and 16 After the heist only n keyboards remain and they have indices a 1 a 2 dots a n Calculate the minimum possible number of keyboards that have been stolen The staff remember neither x nor the number of keyboards in the store before the heist ,"['#include<bits/stdc++.h>\nusing namespace std;\nint a[100009];\nmain(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n    }\n    sort(a, a+n);\n    cout << (a[n-1] - a[0] + 1)-n << endl;\n\n}\n']","['greedy', 'implementation', 'sortings']",800
https://codeforces.com//contest/547/problem/C,C. Mike and Foam,Mike is a bartender at Rico s bar At Rico s they put beer glasses in a special shelf There are kinds of beer at Rico s numbered from to th kind of beer has milliliters of foam on it Maxim is Mike s boss Today he told Mike to perform queries Initially the shelf is empty In each request Maxim gives him a number If beer number is already in the shelf then Mike should remove it from the shelf otherwise he should put it in the shelf After each query Mike should tell him the score of the shelf Bears are geeks So they think that the score of a shelf is the number of pairs of glasses in the shelf such that and where is the greatest common divisor of numbers and Mike is tired So he asked you to help him in performing these requests ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 500001;\n// template end here\nvector<int> fac[SIZE];\nvector<int> p_fac[SIZE];\nint num[SIZE],a[SIZE];\nbool v[SIZE];\nLL an;\nvoid build(){\n    REPP(i,1,SIZE){\n        bool pp=0;\n        if(SZ(fac[i])==1)pp=1;\n        for(int j=i;j<SIZE;j+=i)fac[j].PB(i);\n        if(pp&&i!=1){\n            for(int j=i;j<SIZE;j+=i)p_fac[j].PB(i);\n        }\n    }\n}\nint me;\nvoid dfs(int x,int v,int ty){\n    if(x==SZ(p_fac[me])){\n        an+=ty*num[v];\n        return;\n    }\n    dfs(x+1,v*p_fac[me][x],-ty);\n    dfs(x+1,v,ty);\n}\nint main(){\n    build();\n    DRII(n,q);\n    REP(i,n)RI(a[i]);\n    REP(i,q){\n        DRI(x);\n        x--;\n        me=a[x];\n        if(v[x]){\n            REP(i,SZ(fac[me])){\n                num[fac[me][i]]--;\n            }\n            dfs(0,1,-1);\n        }\n        else{\n            dfs(0,1,1);\n            REP(i,SZ(fac[me])){\n                num[fac[me][i]]++;\n            }\n        }\n        v[x]=!v[x];\n        printf(""%I64d\\n"",an);\n    }\n    return 0;\n}\n']","['bitmasks', 'combinatorics', 'dp', 'math', 'number theory']",2300
https://codeforces.com//contest/256/problem/E,E. Lucky Arrays,Little Maxim loves interesting problems He decided to share one such problem with you Initially there is an array consisting of zeroes The elements of the array are indexed starting from 1 Then follow queries to change array Each query is characterized by two integers In the answer to the query we should make the th array element equal Maxim thinks that some pairs of integers are good and some are not Maxim thinks that array consisting of integers is lucky if for all integer the pair of integers is good Note that the order of numbers in the pairs is important that is specifically After each query to change array Maxim wants to know how many ways there are to replace all zeroes in array with integers from one to three so as to make the resulting array without zeroes lucky Of course distinct zeroes can be replaced by distinct integers Maxim told you the sequence of queries and all pairs of integers he considers lucky Help Maxim solve this problem for him ,"['/*\n * cd2.cpp\n *\n *  Created on: 2012-12-17\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 77777 + 10;\nconst int MOD = 777777777;\n\nint n, nQ;\nint w[3][3];\n\ntypedef long long int64;\n\nstruct Tree {\n\tint c[3][3];\n\tTree*pl, *pr;\n\tint l, r;\n\n\tvoid update() {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tint64 k = 0;\n\t\t\t\tfor (int pi = 0; pi < 3; ++pi) {\n\t\t\t\t\tfor (int pj = 0; pj < 3; ++pj)\n\t\t\t\t\t\tif (w[pi][pj]) {\n\t\t\t\t\t\t\tk += 1LL * pl->c[i][pi] * pr->c[pj][j];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i][j] = k % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tTree(int l, int r) :\n\t\t\tl(l), r(r) {\n\t\tmemset(c, 0, sizeof c);\n\t\tif (l + 1 == r) {\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tc[i][i] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl = new Tree(l, l + r >> 1);\n\t\tpr = new Tree(l + r >> 1, r);\n\t\tupdate();\n\t}\n\n\tvoid change(int i, int x) {\n\t\tif (i < l || i >= r)\n\t\t\treturn;\n\t\tif (l + 1 == r) {\n\t\t\tif (x == 0) {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\tc[j][j] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tc[x - 1][x - 1] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl->change(i, x);\n\t\tpr->change(i, x);\n\t\tupdate();\n\t}\n}*root;\n\nint main() {\n\tcin >> n >> nQ;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tcin >> w[i][j];\n\t\t}\n\t}\n\troot = new Tree(0, n);\n\tfor (int i = 0; i < nQ; ++i) {\n\t\tint a, x;\n\t\tscanf(""%d%d"", &a, &x);\n\t\t--a;\n\t\troot->change(a, x);\n\t\tint ans = 0;\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tans += root->c[j][k];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}\n']",['data structures'],2400
https://codeforces.com//contest/777/problem/A,A. Shell Game,Bomboslav likes to look out of the window in his room and watch lads outside playing famous shell game The game is played by two persons operator and player Operator takes three similar opaque shells and places a ball beneath one of them Then he shuffles the shells by swapping some pairs and the player has to guess the current position of the ball Bomboslav noticed that guys are not very inventive so the operator always swaps the left shell with the middle one during odd moves first third fifth etc and always swaps the middle shell with the right one during even moves second fourth etc Let s number shells from to from left to right Thus the left shell is assigned number the middle shell is and the right shell is Bomboslav has missed the moment when the ball was placed beneath the shell but he knows that exactly movements were made by the operator and the ball was under shell at the end Now he wonders what was the initial position of the ball ,"[""#include <bits/stdc++.h>\n#define REP(i, a, b) for (register int i = a; i <= b; ++i)\n#define PER(i, a, b) for (register int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n\ninline LL read() {\n\tLL x = 0; int ch = getchar(), f = 1;\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x * f;\n}\n\nint main(){\n\tLL n = read() % 6;\n\tLL x = read();\n\tif (n == 1 && x == 1) cout << 0;\n\tif (n == 2 && x == 2) cout << 0;\n\tif (n == 3 && x == 2) cout << 0;\n\tif (n == 4 && x == 1) cout << 0;\n\tif (n == 5 && x == 0) cout << 0;\n\tif (n == 0 && x == 0) cout << 0;\n\n\tif (n == 1 && x == 0) cout << 1;\n\tif (n == 2 && x == 0) cout << 1;\n\tif (n == 3 && x == 1) cout << 1;\n\tif (n == 4 && x == 2) cout << 1;\n\tif (n == 5 && x == 2) cout << 1;\n\tif (n == 0 && x == 1) cout << 1;\n\t\n\tif (n == 1 && x == 2) cout << 2;\n\tif (n == 2 && x == 1) cout << 2;\n\tif (n == 3 && x == 0) cout << 2;\n\tif (n == 4 && x == 0) cout << 2;\n\tif (n == 5 && x == 1) cout << 2;\n\tif (n == 0 && x == 2) cout << 2;\n\treturn 0;\n}""]","['constructive algorithms', 'implementation', 'math']",1000
https://codeforces.com//contest/920/problem/A,A. Water The Garden,It is winter now and Max decided it s about time he watered the garden The garden can be represented as consecutive garden beds numbered from to beds contain water taps th tap is located in the bed which if turned on start delivering water to neighbouring beds If the tap on the bed is turned on then after one second has passed the bed will be watered after two seconds have passed the beds from the segment will be watered if they exist after seconds have passed the beds from the segment will be watered if they exist The garden from test White colour denotes a garden bed without a tap red colour a garden bed with a tap The garden from test after seconds have passed after turning on the tap White colour denotes an unwatered garden bed blue colour a watered bed Max wants to and now he wonders what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered Help him to find the answer ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nbool chk[205];\nbool tchk[205];\nint main() {\n\tint T;\n\tscanf(""%d"", &T);\n\twhile (T--) {\n\t\tint N, K, i, j;\n\t\tscanf(""%d %d"", &N, &K);\n\n\t\tfor (i = 0; i <= N + 1; i++) chk[i] = false;\n\t\tfor (i = 1; i <= K; i++) {\n\t\t\tint t;\n\t\t\tscanf(""%d"", &t);\n\t\t\tchk[t] = true;\n\t\t}\n\t\tfor (i = 0;; i++) {\n\t\t\tint c = 0;\n\t\t\tfor (j = 1; j <= N; j++) if (chk[j]) c++;\n\t\t\tif (c == N) break;\n\n\t\t\tfor (j = 1; j <= N; j++) tchk[j] = chk[j - 1] | chk[j] | chk[j + 1];\n\t\t\tfor (j = 1; j <= N; j++) chk[j] = tchk[j];\n\t\t}\n\t\tprintf(""%d\\n"", i + 1);\n\t}\n\treturn 0;\n}\n//*/']",['implementation'],1000
https://codeforces.com//contest/449/problem/D,D. Jzzhu and Numbers,Jzzhu have non negative integers We will call a sequence of indexes a group of size Jzzhu wonders how many groups exists such that Help him and print this number modulo Operation denotes bitwise AND operation of two numbers ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64;\n\nint N;\nint A[1000000];\nint cnt[1 << 20];\ni64 pows[1100000];\n\nint main()\n{\n\tscanf(""%d"", &N);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(""%d"", A+i);\n\t}\n\tpows[0] = 1;\n\tfor(int i=1;i<=N;i++) pows[i] = (pows[i-1] * 2) % MOD;\n\n\tfor(int i=0;i<(1<<20);i++) cnt[i] = 0;\n\tfor(int i=0;i<N;i++) {\n\t\tcnt[1048575 ^ A[i]]++;\n\t}\n\tfor(int i=0;i<20;i++) {\n\t\tfor(int j=0;j<(1<<20);j++) {\n\t\t\tif(0 == (j & (1<<i))) {\n\t\t\t\tcnt[j | (1<<i)] += cnt[j];\n\t\t\t}\n\t\t}\n\t}\n\ti64 ret = 0;\n\tfor(int i=0;i<(1<<20);i++) {\n\t\tint mask = 20 % 2;\n\t\tfor(int j=0;j<20;j++) if(i & (1<<j)) mask ^= 1;\n\n\t\tif(mask == 0) ret = (ret + pows[cnt[i]]) % MOD;\n\t\telse ret = (ret + MOD - pows[cnt[i]]) % MOD;\n\t}\n\tprintf(""%d\\n"", (int) ret);\n\n\treturn 0;\n}\n']","['bitmasks', 'combinatorics', 'dp']",2400
https://codeforces.com//contest/1497/problem/B,B. M-arrays,You are given an array a 1 a 2 ldots a n consisting of n positive integers and a positive integer m You should divide elements of this array into some arrays You can order the elements in the new arrays as you want Let s call an array m divisible if for each two adjacent numbers in the array two numbers on the positions i and i 1 are called adjacent for each i their sum is divisible by m An array of one element is m divisible Find the smallest number of m divisible arrays that a 1 a 2 ldots a n is possible to divide into ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n, m;\n        cin >> n >> m;\n        vector<ll> a(n);\n        map<ll, ll> q;\n        ll ans = 0;\n        bool k = 0;\n        for (int i = 0; i < n; ++i) {\n            ll x;\n            cin >> x;\n            x %= m;\n            if (!x) {\n                k = 1;\n                continue;\n            }\n            ++q[x];\n            ++q[m - x];\n            --q[m - x];\n        }\n        if (k) ++ans;\n        for (auto &elem : q) {\n            ll c = m - elem.fi;\n            if (elem.fi <= c) {\n                if (elem.fi == c) ans += 1;\n                else ans += max(1ll, (max(elem.se, q[c]) - min(elem.se, q[c])));\n            }\n        }\n        cout << ans << \'\\n\';\n    }\n}\n']","['constructive algorithms', 'greedy', 'math']",1200
https://codeforces.com//contest/317/problem/C,C. Balance,A system of vessels with water is given Several pairs of vessels are connected by tubes with transfusion mechanisms One may transfer an integer amount of liters of water between two vessels connected by such tube tube works in both directions There might be multiple tubes between two vessels Total number of tubes equals Volume of each vessel equals liters Of course the amount of the water in any vessel cannot exceed liters in the process of transfusions Given the initial amounts of water in the vessels and the desired amounts find a sequence of transfusions that deals with the task Total number of transfusions must not exceed ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nint sk[305];\n\nLL sum_sk[305];\n\nbool is_path[305][305];\nint nx[305][305];\n\nint current[305];\nint desired[305];\n\nint n, volume, m;\n\nvector<int> x;\nvector<int> y;\nvector<int> d;\n\nvoid dom(int a, int b, int c) {\n    x.PB(a);\n    y.PB(b);\n    d.PB(c);\n    current[a] -= c;\n    current[b] += c;\n}\n\nvoid move(vector<int>& v, int l, int r, int val) {\n    if (l + 1 == r) {\n        dom(v[l], v[r], val);\n        return;\n    }\n    if (current[v[r - 1]] >= val) {\n        dom(v[r - 1], v[r], val);\n        move(v, l, r - 1, val);\n    } else {\n        dom(v[r - 1], v[r], current[v[r - 1]]);\n        move(v, l, r - 1, val);\n        dom(v[r - 1], v[r], val - desired[v[r - 1]]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> volume >> m;\n    for (int i = 1; i <= n; ++i) {\n        cin >> current[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        cin >> desired[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        is_path[i][i] = true;\n    }\n    memset(nx, -1, sizeof(nx));\n    for (int i = 1; i <= m; ++i) {\n        int x, y;\n        cin >> x >> y;\n        is_path[x][y] = true;\n        nx[x][y] = y;\n        is_path[y][x] = true;\n        nx[y][x] = x;\n    }\n    for (int k = 1; k <= n; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (!is_path[i][j] && is_path[i][k] && is_path[k][j]) {\n                    is_path[i][j] = true;\n                    nx[i][j] = nx[i][k];\n                }\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        sk[i] = 1;\n        while (!is_path[i][sk[i]]) {\n            ++sk[i];\n        }\n        sum_sk[sk[i]] += current[i] - desired[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (sum_sk[i] != 0) {\n            cout << ""NO"" << endl;\n            return 0;\n        }\n    }\n    while (true) {\n        int l = 1;\n        while (l <= n && current[l] <= desired[l]) {\n            ++l;\n        }\n        if (l > n) {\n            break;\n        }\n        int r = 1;\n        while (!is_path[l][r] || current[r] >= desired[r]) {\n            ++r;\n        }\n        vector<int> path;\n        for (int c = l; c != -1; c = nx[c][r]) {\n            path.PB(c);\n        }\n        for (int i = (int) path.size() - 1; ; --i) {\n            if (current[path[i]] > desired[path[i]]) {\n                l = i;\n                break;\n            }\n        }\n        for (int i = l; ; ++i) {\n            if (current[path[i]] < desired[path[i]]) {\n                r = i;\n                break;\n            }\n        }\n        int transferred = min(current[path[l]] - desired[path[l]], desired[path[r]] - current[path[r]]);\n        move(path, l, r, transferred);\n    }\n    cout << x.size() << endl;\n    for (int i = 0; i < (int) x.size(); ++i) {\n        cout << x[i] << "" "" << y[i] << "" "" << d[i] << ""\\n"";\n    }\n}\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'trees']",2500
https://codeforces.com//contest/1934/problem/E,E. Weird LCM Operations,Given an integer n you construct an array a of n integers where a i i for all integers i in the range 1 n An operation on this array is defined as follows Select three distinct indices i j and k from the array and let x a i y a j and z a k Update the array as follows a i operatorname lcm y z a j operatorname lcm x z and a k operatorname lcm x y where operatorname lcm represents the least common multiple Your task is to provide a possible sequence of operations containing at most lfloor frac n 6 rfloor 5 operations such that after executing these operations if you create a set containing the greatest common divisors GCDs of all subsequences with a then all numbers from 1 to n should be present in this set After all the operations a i le 10 18 should hold for all 1 le i le n We can show that an answer always exists ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define int long long\n\nconst int N=2e3+5;\n\nvoid solve() {\n    int n;\n    cin>>n;\n    vector<tuple<int,int,int>>ans;\n    int now=n,low=n/2+2;\n    while(now!=2){\n        if(now<=low){\n            ans.emplace_back(1,now-1,now);\n            break;\n        }\n        if(now%4==0)ans.emplace_back(now/2-1,now-1,now);\n        else if(now%2==0)ans.emplace_back(now/2,now-2,now-1);\n        else ans.emplace_back(now-2,now-1,now);\n        now-=3;\n    }\n    cout<<ans.size()<<endl;\n    for(auto [i,j,k]:ans)cout<<i<<' '<<j<<' '<<k<<endl;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int T=1;\n    cin>>T;\n    while(T--){\n        solve();\n    }\n}""]","['brute force', 'constructive algorithms', 'number theory']",3000
https://codeforces.com//contest/1557/problem/E,E. Assiut Chess,ICPC Assiut Community decided to hold a unique chess contest and you were chosen to control a queen and hunt down the hidden king while a member of ICPC Assiut Community controls this king You compete on an 8 times8 chessboard the rows are numerated from top to bottom and the columns are numerated left to right and the cell in row x and column y is denoted as x y In one turn you can move the queen to any of the squares on the same horizontal line vertical line or any of the diagonals For example if the queen was on square 4 5 you can move to q 1 5 4 q 1 q 1 9 q 1 or q 2 q 2 1 where 1 le q 1 le 8 q 1 ne 4 1 le q 2 le 7 q 2 ne 4 Note that the queen stay on its current cell In one turn the king can move Right Left Up Down Down Right Down Left Up Left or Up Right such that he doesn t get out of the board The king move into a cell that is on the same row column or diagonal with the queen including the position of the queen itself For example if the king was on square 4 5 he can move to 4 k 1 5 k 2 where 1 le k 1 k 2 le 1 k 1 k 2 ne 0 0 At the start of the game you should place the queen at any location on the board and this is done once per game After that the king is secretly placed at any cell different from the queen s location You do not know the position of the king Then the king and the queen take turns with the king moving first The king moves to one of the possible directions Right Down Up Left etc and you are only given the direction it moves to After that you should move your queen by declaring the square to which your queen will move The game follows like this until you win the game or run out of moves You win if the king has no valid moves You lose if after 130 moves of the queen the king still has valid moves ,"['#include<bits/stdc++.h>\nusing namespace std;\nint cx,cy,is[10][10],cnt,F=0;\nstring res;\nvoid Move(int dx,int dy){\n\tint tmp[10][10]={0};\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)tmp[i+dx][j+dy]=is[i][j];\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=tmp[i][j];\n}\nvoid Make(int x,int y){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)if(i==x||j==y||i+j==x+y||i-j==x-y)is[i][j]=0;\n}\nvoid MoveKing(){\n\tcin>>res;\n\tif(res==""Left"")Move(0,-1);\n\tif(res==""Right"")Move(0,1);\n\tif(res==""Up"")Move(-1,0);\n\tif(res==""Down"")Move(1,0);\n\tif(res==""Down-Right"")Move(1,1);\n\tif(res==""Down-Left"")Move(1,-1);\n\tif(res==""Up-Right"")Move(-1,1);\n\tif(res==""Up-Left"")Move(-1,-1);\n\tif(res==""Done"")F=1;\n}\nvoid Min(int &x,int &y,int tox,int toy){\n\tint mn=1e9;\n\tfor(int i=1;i<=8;i++)\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tif(i==cx||j==cy||i+j==cx+cy||i-j==cx-cy){\n\t\t\t\tif(!(i==cx&&j==cy)){\n\t\t\t\t\tif(abs(i-tox)+abs(j-toy)<mn)mn=abs(i-tox)+abs(j-toy),x=i,y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nvoid Solve(){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=(i-1)*8+j;\n\tcx=1,cy=1,cnt=0,F=0;\n\tcout<<cx<<\' \'<<cy<<endl,cnt++,MoveKing();\n\tif(F)return ;\n\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<\' \';\n//\t\t\t\t}\n//\t\t\t\tputs("""");\n//\t\t\t}\n\twhile(1){\n\t\tint w=0;\n\t\tfor(int i=1;i<=8;i++){\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tif(is[i][j])w=is[i][j];\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint p=0,q=0;\n\t\t\tfor(int i=1;i<=8;i++){\n\t\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\t\tif(is[i][j]==w)p=i,q=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!p)break;\n\t\t\tint tx,ty;\n\t\t\tMin(tx,ty,p,q);\n\t\t\tcx=tx,cy=ty;\n\t\t\t//cout<<""w:""<<w<<endl;\n\t\t\tcout<<cx<<\' \'<<cy<<endl,cnt++,assert(cnt<=130),MoveKing();\n\t\t\tif(F)return ;\n\t\t\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<\' \';\n//\t\t\t\t}\n//\t\t\t\tputs("""");\n//\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--)Solve();\n}']","['brute force', 'constructive algorithms', 'interactive']",2800
https://codeforces.com//contest/1542/problem/C,C. Strange Function,Let f i denote the minimum positive integer x such that x is a divisor of i Compute sum i 1 n f i modulo 10 9 7 In other words compute f 1 f 2 dots f n modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=1000000007;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=205;\n\nint k;\nll lcm[MAXN];\nvoid solve()\n{\n\tll n;readint(n);\n\tint ans=n%MOD;\n\tfor(int i=1;i<=k;++i)inc(ans,(n/lcm[i])%MOD);\n\tprintf(""%d\\n"",ans);\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tlcm[1]=1;\n\tfor(k=2;lcm[k-1]<=10000000000000000ll;++k)lcm[k]=lcm[k-1]/__gcd(lcm[k-1],(ll)k)*k;\n\t--k;\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}\n']","['math', 'number theory']",1600
https://codeforces.com//contest/1418/problem/G,G. Three Occurrences,You are given an array a consisting of n integers We denote the subarray a l r as the array a l a l 1 dots a r 1 le l le r le n A subarray is considered if every integer that occurs in this subarray occurs there For example the array 1 2 2 2 1 1 2 2 2 has three good subarrays a 1 6 1 2 2 2 1 1 a 2 4 2 2 2 a 7 9 2 2 2 Calculate the number of good subarrays of the given array a ,"['#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n//#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar(\'-\'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nconst int N=500005;\nint n,a[N],pre[N],lst[N];\nLL ans;\nint mn[N*4],cnt[N*4],tg[N*4];\nvoid upd(int k1){\n\tmn[k1]=min(mn[k1*2],mn[k1*2+1]);\n\tcnt[k1]=0;\n\tif(mn[k1]==mn[k1*2])cnt[k1]+=cnt[k1*2];\n\tif(mn[k1]==mn[k1*2+1])cnt[k1]+=cnt[k1*2+1];\n}\nvoid pst(int k1,int k2){\n\ttg[k1]+=k2,mn[k1]+=k2;\n}\nvoid psd(int k1){\n\tif(tg[k1]){\n\t\tpst(k1*2,tg[k1]);\n\t\tpst(k1*2+1,tg[k1]);\n\t\ttg[k1]=0;\n\t}\n}\nvoid bud(int k1,int k2,int k3){\n\tif(k2==k3){\n\t\tmn[k1]=N;\n\t\tcnt[k1]=1;\n\t\treturn;\n\t}\n\tint mid=(k2+k3)>>1;\n\tbud(k1*2,k2,mid),bud(k1*2+1,mid+1,k3);\n\tupd(k1);\n}\nvoid mdf(int k1,int k2,int k3,int k4,int k5,int k6){\n\tif(k2>k5||k3<k4)return;\n\tif(k4<=k2&&k3<=k5){\n\t\tpst(k1,k6);\n\t\treturn;\n\t}\n\tpsd(k1);\n\tint mid=(k2+k3)>>1;\n\tmdf(k1*2,k2,mid,k4,k5,k6),mdf(k1*2+1,mid+1,k3,k4,k5,k6);\n\tupd(k1);\n}\nsigned main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\trd(n);\n\trep(i,1,n){\n\t\trd(a[i]);\n\t\tpre[i]=lst[a[i]];\n\t\tlst[a[i]]=i;\n\t}\n\tbud(1,1,n);\n\trep(i,1,n){\n\t\tmdf(1,1,n,i,i,-N);\n\t\tint k1=pre[i];\n\t\tint k2=pre[k1];\n\t\tint k3=pre[k2];\n\t\tint k4=pre[k3];\n\t\tif(k1){\n\t\t\tmdf(1,1,n,1,k1,-1);\n\t\t}\n\t\tif(k3){\n\t\t\tmdf(1,1,n,k4+1,k3,1);\n\t\t}\n\t\tif(k2){\n\t\t\tmdf(1,1,n,k3+1,k2,-1);\n\t\t}\n\t\tmdf(1,1,n,1,i,1);\n\t\tif(mn[1]==0){\n\t\t\tans+=cnt[1];\n\t\t\tD(""%d %d\\n"",i,cnt[1]);\n\t\t}\n\t}\n\tpt(ans,\'\\n\');\n\treturn 0;\n}\n\n']","['data structures', 'divide and conquer', 'hashing', 'two pointers']",2500
https://codeforces.com//contest/185/problem/A,A. Plant,Dwarfs have planted a very interesting plant which is a triangle directed upwards This plant has an amusing feature After one year a triangle plant directed upwards divides into four triangle plants three of them will point upwards and one will point downwards After another year each triangle plant divides into four triangle plants three of them will be directed in the same direction as the parent plant and one of them will be directed in the opposite direction Then each year the process repeats The figure below illustrates this process Help the dwarfs find out how many triangle plants that point upwards will be in years ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007ll\n\nll power(ll n){\n    if(n == 0) return 1;\n    ll ans = power(n/2);\n    return ans * ans % MOD * ((n%2 == 1) ? 2 : 1) % MOD;\n}\n\nint main(void){\n    ll n;\n    \n    cin >> n;\n    ll t = power(n);\n    ll ans = t * (t + 1) % MOD * ((MOD + 1) / 2) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']",['math'],1300
https://codeforces.com//contest/1095/problem/D,D. Circular Dance,There are n kids numbered from 1 to n dancing in a circle around the Christmas tree Let s enumerate them in a clockwise direction as p 1 p 2 p n all these numbers are from 1 to n and are distinct so p is a permutation Let the next kid for a kid p i be kid p i 1 if i n and p 1 otherwise After the dance each kid remembered two kids the next kid let s call him x and the next kid for x Each kid told you which kids he she remembered the kid i remembered kids a i 1 and a i 2 However the order of a i 1 and a i 2 can differ from their order in the circle You have to restore the order of the kids in the circle using this information If there are several answers you may print any It is guaranteed that at least one solution exists ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint main(){\n\tfast_io;\n\tint n;\n\tcin>>n;\n\tint a[n+2][2];\n\tfo(i,1,n){\n\t\tcin>>a[i][0]>>a[i][1];\n\t}\n\tvi ans;\n\tans.push_back(1);\n\tbool temp=1;\n\t\tint x=a[1][0];\n\t\tint y=a[1][1];\n\t\tif(a[x][0]==y or a[x][1]==y) temp=0;\n\tif(!temp){\n\t\tans.push_back(x);\n\t\tans.push_back(y);\n\t}\n\telse{\n\t\tans.push_back(y);\n\t\tans.push_back(x);\n\t\tswap(x,y);\n\t}\n\twhile((int)ans.size()<n){\n\t\tint curr=a[x][0];\n\t\tif(curr==y) curr=a[x][1];\n\t\tans.push_back(curr);\n\t\tx=y;\n\t\ty=curr;\n\t}\n\tfor(auto i:ans){\n\t\tdisp(i);\n\t}\n\tcout<<endl;\n\treturn 0;\n}']",['implementation'],1600
https://codeforces.com//contest/1023/problem/A,A. Single Wildcard Pattern Matching,You are given two strings s and t The string s consists of lowercase Latin letters and wildcard character the string t consists only of lowercase Latin letters The length of the string s equals n the length of the string t equals m The wildcard character in the string s if any can be replaced with an arbitrary sequence possibly empty of lowercase Latin letters No other character of s can be replaced with anything If it is possible to replace a wildcard character in s to obtain a string t then the string t matches the pattern s For example if s then the following strings match it and but the following strings do not match If the given string t matches the given string s print otherwise print ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nstring s1, s2;\n\nint main(){\n\tcin >> n >> m;\n\tcin >> s1 >> s2;\n\tint idx = -1;\n\tfor(int i=0; i<n; i++){\n\t\tif(s1[i] == \'*\') idx = i;\n\t}\n\tif(idx == -1){\n\t\tputs(s1 == s2 ? ""YES"" : ""NO"");\n\t\treturn 0;\n\t}\n\tint rem = m - (n - 1);\n\tif(rem < 0){\n\t\tputs(""NO"");\n\t\treturn 0;\n\t}\n\ts1 = s1.substr(0, idx) + s2.substr(idx, rem) + s1.substr(idx + 1, n - idx - 1);\n\tputs(s1 == s2 ? ""YES"" : ""NO"");\n\treturn 0;\n}\n']","['brute force', 'implementation', 'strings']",1200
https://codeforces.com//contest/128/problem/B,B. String,One day in the IT lesson Anna and Maria learned about the lexicographic order String is lexicographically less than string if either is a prefix of and or there exists such that and for any Here denotes the length of the string The lexicographic comparison of strings is implemented by operator in modern programming languages The teacher gave Anna and Maria homework She gave them a string of length They should write out all substrings of the given string including the whole initial string and the equal substrings for example one should write out the following substrings from the string The resulting strings should be sorted in the lexicographical order The cunning teacher doesn t want to check all these strings That s why she said to find only the th string from the list Help Anna and Maria do the homework ,"['#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double real;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf (stderr, __VA_ARGS__)\n#else\n#define eprintf(...) assert (true)\n#endif\n\n#ifdef WIN32\n#define INT64 ""%I64d""\n#else\n#define INT64 ""%lld""\n#endif\n\nusing namespace std;\n\nconst int MaxN = 100005, NA = -1, MaxC = 0x3F3F3F3F;\n\nchar s [MaxN];\nbool b [MaxN];\nint k, n;\n\nvoid solve (vector <int> v)\n{\n int i, j;\n int64 p, q;\n char c;\n\n vector <int> w;\n for (c = \'a\'; c <= \'z\'; c++)\n {\n  p = q = 0;\n  w.clear ();\n  for (j = 0; j < (int) v.size (); j++)\n  {\n   i = v[j];\n   if (s[i] == c)\n   {\n    w.push_back (i + 1);\n    p++;\n    q += n - i;\n   }\n  }\n  if (k < q)\n   break;\n  k -= q;\n }\n assert (c <= \'z\');\n\n putchar (c);\n if (k < p)\n  return;\n k -= p;\n solve (w);\n}\n\nint main (void)\n{\n int i;\n\n while (scanf ("" %s %d"", s, &k) != EOF)\n {\n  n = (int) strlen (s);\n  if (k > ((((int64) n) * (int64) (n + 1)) >> 1LL))\n  {\n   printf (""No such line.\\n"");\n   continue;\n  }\n  k--;\n\n  vector <int> v;\n  for (i = 0; i < n; i++)\n   v.push_back (i);\n  solve (v);\n  putchar (\'\\n\');\n }\n return 0;\n}\n']","['brute force', 'constructive algorithms', 'hashing', 'implementation', 'string suffix structures', 'strings']",2100
https://codeforces.com//contest/31/problem/E,E. TV Game,There is a new TV game on BerTV In this game two players get a number consisting of digits Before each turn players determine who will make the next move Each player should make exactly moves On it s turn th player takes the leftmost digit of and appends it to his or her number After that this leftmost digit is erased from Initially the numbers of both players and are empty Leading zeroes in numbers are allowed In the end of the game the first player gets dollars and the second gets dollars One day Homer and Marge came to play the game They managed to know the number beforehand They want to find such sequence of their moves that both of them makes exactly moves and which maximizes their total prize Help them ,"['#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 32 + 1;\nconst int MAXL = 64 + 1;\n\nint n;\nbool path[MAXN][MAXN];\nlong long dp[MAXN][MAXN], pow[MAXN];\nchar num[MAXL], ans[MAXL];\n\nint main() {\n\tpow[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) pow[i] = pow[i - 1] * 10;\n\tmemset(dp, 0xFF, sizeof(dp));\n\tscanf(""%d%s"", &n, num);\n\tdp[n][n] = 0;\n\tfor (int o = 0; o < n << 1; o++) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint j = (n << 1) - o - i;\n\t\t\tif (j < 0 || j > n) continue;\n//printf(""o = %d i = %d j = %d\\n"", o, i, j);\n\t\t\t// H\n\t\t\tif (i && dp[i - 1][j] < dp[i][j] + (num[o] - \'0\') * pow[i - 1]) {\n\t\t\t\tdp[i - 1][j] = dp[i][j] + (num[o] - \'0\') * pow[i - 1];\n\t\t\t\tpath[i - 1][j] = true;\n\t\t\t}\n\t\t\t// M\n\t\t\tif (j && dp[i][j - 1] < dp[i][j] + (num[o] - \'0\') * pow[j - 1]) {\n\t\t\t\tdp[i][j - 1] = dp[i][j] + (num[o] - \'0\') * pow[j - 1];\n\t\t\t\tpath[i][j - 1] = false;\n\t\t\t}\n\t\t}\n\t}\n/*for (int i = 0; i <= n; i++) {\n\tfor (int j = 0; j <= n; j++) {\n\t\tprintf(""%d "", path[i][j]);\n\t}\n\tputchar(\'\\n\');\n}\nputs("""");\nfor (int i = 0; i <= n; i++) {\n\tfor (int j = 0; j <= n; j++) {\n\t\tprintf(""%lld "", dp[i][j]);\n\t}\n\tputchar(\'\\n\');\n}*/\n\tans[n << 1] = \'\\0\';\n\tint x = 0, y = 0;\n\twhile (x != n || y != n) {\n\t\tif (path[x][y]) {\n\t\t\tans[(n << 1) - x - y - 1] = \'H\';\n\t\t\tx++;\n\t\t} else {\n\t\t\tans[(n << 1) - x - y - 1] = \'M\';\n\t\t\ty++;\n\t\t}\n\t}\n\tputs(ans);\n\treturn 0;\n}\n']",['dp'],2400
https://codeforces.com//contest/707/problem/B,B. Bakery,Masha wants to open her own bakery and bake muffins in one of the cities numbered from to There are bidirectional roads each of whose connects some pair of cities To bake muffins in her bakery Masha needs to establish flour supply from some storage There are only storages located in different cities numbered Unforunately the law of the country Masha lives in prohibits opening bakery in any of the cities which has storage located in it She can open it only in one of another cities and of course flour delivery should be paid for every kilometer of path between storage and bakery Masha should pay ruble Formally Masha will pay roubles if she will open the bakery in some city for every and choose a storage in some city for some and and are connected by some path of roads of summary length if there are more than one path Masha is able to choose which of them should be used Masha is very thrifty and rational She is interested in a city where she can open her bakery and choose one of storages and one of the paths between city with bakery and city with storage and pay minimum possible amount of rubles for flour delivery Please help Masha find this amount ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nconst int maxn = 200005;\n\ntypedef long long ll;\ntypedef pair<ll,int> P;\n\npriority_queue<P,vector<P>,greater<P> > Q;\nll d[maxn];\nbool fal[maxn];\nint to[maxn],next[maxn],cost[maxn],final[maxn],tot,n,m,k;\n\nvoid link(int u,int v,int l)\n{\n\tto[++ tot] = v,next[tot] = final[u],cost[tot] = l,final[u] = tot;\n}\n\nint main()\n{\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor(int i = 1;i <= m;i ++)\n\t{\n\t\tint u,v,l;\n\t\tscanf(""%d%d%d"", &u, &v, &l);\n\t\tlink(u,v,l),link(v,u,l);\n\t}\n\tfor(int i = 1;i <= n;i ++) d[i] = (1ll << 60);\n\tfor(int i = 1;i <= k;i ++)\n\t{\n\t\tint u;\n\t\tscanf(""%d"", &u),fal[u] = 1;\n\t\td[u] = 0;\n\t\tQ.push(P(0ll,u));\n\t}\n\twhile (!Q.empty())\n\t{\n\t\tP u = Q.top();Q.pop();\n\t\tif (u.first != d[u.second]) continue;\n\t\tfor(int i = final[u.second];i;i = next[i])\n\t\t{\n\t\t\tll w = u.first + cost[i];\n\t\t\tif (w < d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = w;\n\t\t\t\tQ.push(P(d[to[i]],to[i]));\n\t\t\t}\n\t\t}\n\t}\n\tll mi = (1ll << 60);\n\tfor(int i = 1;i <= n;i ++)\n\t\tif (!fal[i]) mi = min(mi,d[i]);\n\tif (mi == (1ll << 60)) printf(""-1\\n""); else\n\t\tprintf(""%I64d\\n"", mi);\n\treturn 0;\n}']",['graphs'],1300
https://codeforces.com//contest/1316/problem/E,E. Team Building,Alice the president of club FCB wants to build a team for the new volleyball tournament The team should consist of p players playing in p different positions She also recognizes the importance of audience support so she wants to select k people as part of the audience There are n people in Byteland Alice needs to select exactly p players one for each position and exactly k members of the audience from this pool of n people Her ultimate goal is to maximize the total strength of the club The i th of the n persons has an integer a i associated with him the strength he adds to the club if he is selected as a member of the audience For each person i and for each position j Alice knows s i j the strength added by the i th person to the club if he is selected to play in the j th position Each person can be selected at most once as a player or a member of the audience You have to choose exactly one player for each position Since Alice is busy she needs you to help her find the maximum possible strength of the club that can be achieved by an optimal choice of players and the audience ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nvoid upd(long long& a, long long b) {\n\ta = max(a, b);\n}\nint bx[10001];\nint a[200001];\nint s[200001][8];\nlong long f[100005][130];\nint n, p, k;\nint b[100005];\nbool cmp(const int& x, const int& y) {\n\treturn a[x] < a[y];\n}\n\n\nint main( ) {\n\tscanf(""%d %d %d"", &n, &p, &k);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf(""%d"", &a[i]);\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= p; j ++)\n\t\t\tscanf(""%d"", &s[i][j]);\n\tfor (int i = 1; i <= n; i ++) b[i] = i;\t\n\tsort(b + 1, b + 1 + n, cmp);\n\treverse(b + 1, b + 1 + n);\n\t\n\tfor (int i = 1; i < (1 << p); i ++)\n\t\tbx[i] = bx[i - (i & -i)] + 1;\n\tlong long ans = 0;\n\tfor (int r = 0; r <= n; ++ r)\n\t\tfor (int S = 0; S < (1 << p); ++ S)\n\t\t\tf[r][S] = -0x3f3f3f3f3f3f3f3fLL;\n\tf[0][0] = 0;\n\tfor (int r = 1; r <= n; ++ r) {\n\t\tfor (int S = 0; S < (1 << p); ++ S) {\n\t\t\tfor (int j = 1; j <= p; j ++) {\n\t\t\t\tif ((S >> (j - 1)) & 1) continue;\n\t\t\t\tint i = b[r];\n\t\t\t\tupd(f[r][S | (1 << (j - 1))], f[r - 1][S] + s[i][j]);\n\t\t\t}\n\t\t\tint N = r - 1 - bx[S];\n\t\t\tif (N < k) upd(f[r][S], f[r - 1][S] + a[b[r]]);\n\t\t\telse upd(f[r][S], f[r - 1][S]);\n\t\t}\n\t}\n\tfor (int r = 1; r <= n; ++ r) \n\t\tfor (int S = 0; S < (1 << p); ++ S) {\n\t\t\tans = max(ans, f[r][S]);\n\t\t}\n\tprintf(""%lld\\n"", ans);\n\treturn 0;\n}\n\n']","['bitmasks', 'dp', 'greedy', 'sortings']",2300
https://codeforces.com//contest/240/problem/D,D. Merging Two Decks,There are two decks of cards lying on the table in front of you some cards in these decks lay face up some of them lay face down You want to merge them into one deck in which each card is face down You re going to do it in two stages The first stage is to merge the two decks in such a way that the relative order of the cards from the same deck doesn t change That is for any two different cards and in one deck if card lies above card then after the merge card must also be above card The second stage is performed on the deck that resulted from the first stage At this stage the executed operation is the turning operation In one turn you can take a few of the top cards turn all of them and put them back Thus each of the taken cards gets turned and the order of these cards is reversed That is the card that was on the bottom before the turn will be on top after it Your task is to make sure that all the cards are lying face down Find such an order of merging cards in the first stage and the sequence of turning operations in the second stage that make all the cards lie face down and the number of turns is minimum ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nconst int MAX_N = int(1e5) + 10;\nint n, a[MAX_N], m, b[MAX_N];\n\nvector<pair<int, pair<int, int> > > parse(int a[], int n, int st) {\n\tvector<pair<int, pair<int, int> > > ret;\n\tfor (int i = 0, j; i < n; i = j) {\n\t\tfor (j = i; j < n && a[i] == a[j]; ++j)\n\t\t\t;\n\t\tret.push_back(make_pair(a[i], make_pair(i + st, j + st - 1)));\n\t}\n\treturn ret;\n}\n\nvoid push(vector<int>&order, vector<int>&color, pair<int, int> p,int c) {\n\tfor (int i = p.first; i <= p.second; ++i) {\n\t\torder.push_back(i);\n\t\tcolor.push_back(c);\n\t}\n}\n\nint main() {\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(""%d"", a + i);\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(""%d"", b + i);\n\t}\n\n\tvector<pair<int, pair<int, int> > > pa = parse(a, n, 1);\n\tvector<pair<int, pair<int, int> > > pb = parse(b, m, n + 1);\n\tif (pa.size() < pb.size())\n\t\tswap(pa, pb);\n\t//|pa|>=|pb|\n\t//insert pb into pa\n\tvector<int> order;\n\tvector<int> color;\n\tif (pa[0].first == pb[0].first) {\n\t\tfor (int i = 0; i < pa.size(); ++i) {\n\t\t\tpush(order, color, pa[i].second, pa[i].first);\n\t\t\tif (i < pb.size())\n\t\t\t\tpush(order, color, pb[i].second, pb[i].first);\n\t\t}\n\t} else if (pb.size() < pa.size()) {\n\t\tfor (int i = 0; i < pa.size() || i < pb.size(); ++i) {\n\t\t\tif (i < pa.size())\n\t\t\t\tpush(order, color, pa[i].second, pa[i].first);\n\t\t\tif (i < pb.size())\n\t\t\t\tpush(order, color, pb[i].second, pb[i].first);\n\t\t}\n\t} else {\n\t\t//who go first?\n\t\tint n = pa.size();\n\t\tint first;\n\t\tif (n % 2 == 0) {\n\t\t\t//0\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tfirst = 1;\n\t\t}\n\t\tif (pa[0].first != first)\n\t\t\tswap(pa, pb);\n\t\tfor (int i = 0; i < pa.size() || i < pb.size(); ++i) {\n\t\t\tif (i < pa.size())\n\t\t\t\tpush(order, color, pa[i].second, pa[i].first);\n\t\t\tif (i < pb.size())\n\t\t\t\tpush(order, color, pb[i].second, pb[i].first);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < order.size(); ++i) {\n\t\tprintf(""%d "", order[i]);\n\t}\n\tputs("""");\n\tvector<int> opts;\n//\tcopy(color.begin(), color.end(), ostream_iterator<int>(cout, "" ""));\n//\tputs("""");\n\tfor (int i = 0, j; i < color.size(); i = j) {\n\t\tfor (j = i; j < color.size() && color[i] == color[j]; ++j)\n\t\t\t;\n\t\t//[i,j)\n\t\tif (color[i] == 1) {\n\t\t\tif (i > 0)\n\t\t\t\topts.push_back(i - 1);\n\t\t\topts.push_back(j - 1);\n\t\t}\n\t}\n\tcout << opts.size() << endl;\n\tfor (int i = 0; i < opts.size(); ++i) {\n\t\tprintf(""%d "", opts[i] + 1);\n\t}\n\tputs("""");\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy']",2000
https://codeforces.com//contest/1000/problem/B,B. Light It Up,Recently you bought a brand new smart lamp with programming features At first you set up a schedule to the lamp Every day it will turn power on at moment 0 and turn power off at moment M Moreover the lamp allows you to set a program of switching its state states are lights on and lights off Unfortunately some program is already installed into the lamp The lamp allows only programs Good program can be represented as a non empty array a where 0 a 1 a 2 dots a a M All a i must be integers Of course preinstalled program is a good program The lamp follows program a in next manner at moment 0 turns power and light on Then at moment a i the lamp flips its state to opposite if it was lit it turns off and vice versa The state of the lamp flips instantly for example if you turn the light off at moment 1 and then do nothing the total time when the lamp is lit will be 1 Finally at moment M the lamp is turning its power off regardless of its state Since you are not among those people who read instructions and you don t understand the language it s written in you realize after some testing the only possible way to alter the preinstalled program You can element into the program a so it still should be a program after alteration Insertion can be done between any pair of consecutive elements of a or even at the begining or at the end of a Find such a way to alter the program that the total time when the lamp is lit is maximum possible Maybe you should leave program untouched If the lamp is lit from x till moment y then its lit for y x units of time Segments of time when the lamp is lit are summed up ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 100100;\nconst long long Q = 2e18;\nconst long long mod = 1e9 + 7;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint m;\nint d[N][2][2];\n\nvoid solve()\n{\n        vector < int > a;\n        a.push_back(0);\n        cin >> n >> m;\n        for(int i = 1; i <= n; i++){\n                int x;\n                cin >> x;\n                a.push_back(x);\n                d[i][0][0] = -1e9;\n                d[i][1][0] = -1e9;\n                d[i][0][1] = -1e9;\n                d[i][1][1] = -1e9;\n        }\n        d[0][0][0] = -1e9;\n        d[0][1][0] = -1e9;\n        a.push_back(m);\n        for(int i = 1; i <= n + 1; i++){\n                d[i][0][0] = d[i - 1][0][1] + a[i] - a[i - 1];\n                d[i][0][1] = d[i - 1][0][0];\n                d[i][1][0] = d[i - 1][1][1] + a[i] - a[i - 1];\n                if(a[i - 1] + 1 < a[i]) d[i][1][0] = max(d[i][1][0], d[i - 1][0][0] + a[i] - a[i - 1] - 1);\n                d[i][1][1] = d[i - 1][1][0];\n                if(a[i - 1] + 1 < a[i]) d[i][1][1] = max(d[i][1][1], d[i - 1][0][1] + a[i] - a[i - 1] - 1);\n        }\n        n++;\n        int ans = d[n][0][0];\n        ans = max(ans, d[n][0][1]);\n        ans = max(ans, d[n][1][0]);\n        ans = max(ans, d[n][1][1]);\n        cout << ans << ""\\n"";\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']",['greedy'],1500
https://codeforces.com//contest/1257/problem/F,F. Make Them Similar,Let s call two numbers if their binary representations contain the same number of digits equal to 1 For example 2 and 4 are similar binary representations are 10 and 100 1337 and 4213 are similar binary representations are 10100111001 and 1000001110101 3 and 2 are not similar binary representations are 11 and 10 42 and 13 are similar binary representations are 101010 and 1101 You are given an array of n integers a 1 a 2 a n You may choose a non negative integer x and then get another array of n integers b 1 b 2 b n where b i a i oplus x oplus denotes bitwise XOR Is it possible to obtain an array b where all numbers are similar to each other ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int BITS = 30;\nconst int HALF = BITS / 2;\n\nint N;\nvector<int> A;\n\nvoid normalize(vector<int> &counts) {\n    assert((int) counts.size() == N);\n\n    for (int i = N - 1; i >= 0; i--)\n        counts[i] -= counts[0];\n}\n\nint main() {\n    cin >> N;\n    A.resize(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    map<vector<int>, int> possible;\n\n    for (int mask = 0; mask < 1 << HALF; mask++) {\n        vector<int> counts(N, 0);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = __builtin_popcount((A[i] & ((1 << HALF) - 1)) ^ mask);\n\n        normalize(counts);\n\n        if (possible.find(counts) == possible.end())\n            possible[counts] = mask;\n    }\n\n    for (int mask = 0; mask < 1 << HALF; mask++) {\n        vector<int> counts(N, 0);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = __builtin_popcount(A[i] >> HALF ^ mask);\n\n        normalize(counts);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = -counts[i];\n\n        if (possible.find(counts) != possible.end()) {\n            int other = possible[counts];\n            cout << (mask << HALF) + other << '\\n';\n            return 0;\n        }\n    }\n\n    cout << -1 << '\\n';\n}\n""]","['bitmasks', 'brute force', 'hashing', 'meet-in-the-middle']",2400
https://codeforces.com//contest/1686/problem/B,B. Odd Subarrays,For an array b 1 b 2 ldots b m define its number of inversions as the number of pairs i j of integers such that 1 le i j le m and b i b j Let s call array b if its number of inversions is odd For example array 4 2 7 is odd as its number of inversions is 1 while array 2 1 4 3 isn t as its number of inversions is 2 You are given a permutation p 1 p 2 ldots p n of integers from 1 to n each of them appears exactly once in the permutation You want to split it into several consecutive subarrays maybe just one so that the number of the subarrays among them is as large as possible What largest number of these subarrays may be ,"['/********************************************************************************************************************\n*                                                                                                                   *\n*   lmqzzz : ILS 21 - 24                                                                                            *\n*                                                                                                                   *\n*                                                                                                                   *\n*       lllllll                                                                                                     *\n*       l:::::l                                                                                                     *\n*       l:::::l                                                                                                     *\n*       l:::::l                                                                                                     *\n*        l::::l    mmmmmmm    mmmmmmm      qqqqqqqqq   qqqqqzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz    *\n*        l::::l  mm:::::::m  m:::::::mm   q:::::::::qqq::::qz:::::::::::::::zz:::::::::::::::zz:::::::::::::::z     *\n*        l::::l m::::::::::mm::::::::::m q:::::::::::::::::qz::::::::::::::z z::::::::::::::z z::::::::::::::z      *\n*        l::::l m::::::::::::::::::::::mq::::::qqqqq::::::qqzzzzzzzz::::::z  zzzzzzzz::::::z  zzzzzzzz::::::z       *\n*        l::::l m:::::mmm::::::mmm:::::mq:::::q     q:::::q       z::::::z         z::::::z         z::::::z        *\n*        l::::l m::::m   m::::m   m::::mq:::::q     q:::::q      z::::::z         z::::::z         z::::::z         *\n*        l::::l m::::m   m::::m   m::::mq:::::q     q:::::q     z::::::z         z::::::z         z::::::z          *\n*        l::::l m::::m   m::::m   m::::mq::::::q    q:::::q    z::::::z         z::::::z         z::::::z           *\n*       l::::::lm::::m   m::::m   m::::mq:::::::qqqqq:::::q   z::::::zzzzzzzz  z::::::zzzzzzzz  z::::::zzzzzzzz     *\n*       l::::::lm::::m   m::::m   m::::m q::::::::::::::::q  z::::::::::::::z z::::::::::::::z z::::::::::::::z     *\n*       l::::::lm::::m   m::::m   m::::m  qq::::::::::::::q z:::::::::::::::zz:::::::::::::::zz:::::::::::::::z     *\n*       llllllllmmmmmm   mmmmmm   mmmmmm    qqqqqqqq::::::qzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz     *\n*                                                   q:::::q                                                         *\n*                                                   q:::::q                                                         *\n*                                                  q:::::::q                                                        *\n*                                                  q:::::::q                                                        *\n*                                                  q:::::::q                                                        *\n*                                                  qqqqqqqqq                                                        *\n*                                                                                                                   *\n********************************************************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define          int    long long\n\n#define           fi    first\n#define           se    second\n#define           pb    push_back\n#define           ep    emplace\n#define           eb    emplace_back\n#define           lb    lower_bound\n#define           ub    upper_bound\n#define       all(x)    x.begin(), x.end()\n#define      rall(x)    x.rbegin(), x.rend()\n#define   uniquev(v)    v.resize(unique(all(v)) - v.begin())\n#define     mem(f,x)    memset(f , x , sizeof(f))\n#define        sz(x)    (int32_t)(x).size()\n#define   rep(i,a,b)    for(int i = a ; i <= b ; i++)\n#define  repp(i,a,b)    for(int i = a ; i < b ; i++)\n#define   per(i,a,b)    for(int i = a ; i >= b ; i--)\n#define  perr(i,a,b)    for(int i = a ; i > b ; i--)\n#define          mxx    *max_element\n#define          mnn    *min_element\n#define    cntbit(x)    __builtin_popcountll(x)\n#define      MASK(x)    ( 1ll << (x) )\n#define          Yes    cout << ""Yes""\n#define          YES    cout << ""YES""\n#define           No    cout << ""No""\n#define           NO    cout << ""NO""\n#define           AA    cout << ""Alice""\n#define           BB    cout << ""Bob""\n\ntemplate <typename T> inline void read (T &x) { bool b = 0; char c; while (!isdigit (c = getchar()) && c != \'-\'); if (c == \'-\') { c = getchar(); b = 1; } x = c - 48; while (isdigit(c = getchar())) {x = x * 10 + (c - 48); } if (b) { x=-x; } }\ntemplate <typename T> inline T min(const T &a, const T &b, const T &c) { return min(a, min(b, c)); }\ntemplate <typename T> inline T max(const T &a, const T &b, const T &c) { return max(a, max(b, c)); }\ntemplate <typename T, typename U> inline void mini(T &a, const U &b) { if(a > b) a = b; }\ntemplate <typename T, typename U> inline void maxi(T &a, const U &b) { if(a < b) a = b; }\n\ntypedef           long double    ld;\ntypedef             long long    ll;\ntypedef       const long long    cll;\ntypedef             const int    cint;\ntypedef        pair<int, int>    ii;\ntypedef  tuple<int, int, int>    iii;\ntypedef         pair<ii, int>    piii;\ntypedef         pair<int, ii>    ipii;\ntypedef         pair<ll, int>    li;\ntypedef          pair<ll, ll>    pll;\ntypedef           vector<int>    vi;\ntypedef            vector<ll>    vll;\ntypedef            vector<vi>    vvi;\ntypedef           vector<vll>    vvl;\ntypedef            vector<ii>    vii;\ntypedef           vector<iii>    viii;\ntypedef           vector<vii>    vvii;\ntypedef           vector<vii>    vvii;\ntypedef         array<int, 3>    ar3;\ntypedef         array<int, 4>    ar4;\ntypedef         array<int, 5>    ar5;\n\nconstexpr   long double PI  =  acos( -1 );\nconstexpr  long double eps  =  1e-9;\nconstexpr     int32_t base  =  277;\nconstexpr     int16_t dr[]  =  {1, 0, -1, 0};\nconstexpr     int16_t dc[]  =  {0, -1, 0, 1};\nconstexpr      int64_t MOD  =  1e9 + 7;\nconstexpr     int32_t MAXN  =  1e6 + 10;\n\nint a[MAXN];\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    rep(i, 1, n) cin >> a[i];\n    int cnt = 0;\n    rep(i, 2, n)\n    {\n        if(a[i] < a[i - 1])\n            cnt++,i++;\n    }\n    cout << cnt;\n}\n\nvoid init()\n{\n\n}\n\n/// TASK\n/// -----------------------------\n#define TASK ""C""\n///------------------------------\n\nvoid gentest()\n{\n    if (fopen(TASK "".inp"", ""r""))\n        freopen(TASK "".inp"",""w"",stdout);\n    srand(time(0));\n//    int n = 0;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    if (fopen(TASK "".inp"", ""r"")) {\n        freopen(TASK "".inp"", ""r"", stdin);\n        freopen(TASK "".out"", ""w"", stdout);\n    }\n//    gentest();\n//    return 0;\n//    init();\n    int32_t TT = 1;\n    cin >> TT;\n    for(int32_t TTT = 1 ; TTT <= TT ; TTT++)\n    {\n        solve();\n        cout << \'\\n\';\n    }\n\n}\n']","['dp', 'greedy']",800
https://codeforces.com//contest/1680/problem/F,F. Lenient Vertex Cover,You are given a simple connected undirected graph consisting of n vertices and m edges The vertices are numbered from 1 to n A vertex cover of a graph is a set of vertices such that each edge has at least one of its endpoints in the set Let s call a vertex cover such a vertex cover that edge in it has both endpoints in the set Find a vertex cover of a graph or report that there is none If there are multiple answers then print any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nnamespace ecnerwala {\n\nusing std::swap;\n\nstruct level_ancestor {\n\tint N;\n\tstd::vector<int> preorder;\n\tstd::vector<int> idx;\n\tstd::vector<std::pair<int, int>> heavyPar; // heavy parent, distance\n\tlevel_ancestor() : N(0) {}\n\n\tlevel_ancestor(const std::vector<int>& par) : N(int(par.size())), preorder(N), idx(N), heavyPar(N) {\n\t\tstd::vector<std::vector<int>> ch(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] != -1) ch[par[i]].push_back(i);\n\t\t}\n\t\tstd::vector<int> sz(N);\n\t\tint nxt_idx = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] == -1) {\n\t\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\t\t\tsz[cur] = 1;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt);\n\t\t\t\t\t\tsz[cur] += sz[nxt];\n\t\t\t\t\t}\n\t\t\t\t\tif (!ch[cur].empty()) {\n\t\t\t\t\t\tauto mit = max_element(ch[cur].begin(), ch[cur].end(), [&](int a, int b) { return sz[a] < sz[b]; });\n\t\t\t\t\t\tswap(*ch[cur].begin(), *mit);\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t\tstd::y_combinator([&](auto self, int cur, int isRoot = true) -> void {\n\t\t\t\t\tpreorder[idx[cur] = nxt_idx++] = cur;\n\t\t\t\t\tif (isRoot) {\n\t\t\t\t\t\theavyPar[idx[cur]] = {par[cur] == -1 ? -1 : idx[par[cur]], 1};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(idx[par[cur]] == idx[cur]-1);\n\t\t\t\t\t\theavyPar[idx[cur]] = heavyPar[idx[cur]-1];\n\t\t\t\t\t\theavyPar[idx[cur]].second++;\n\t\t\t\t\t}\n\t\t\t\t\tbool chRoot = false;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt, chRoot);\n\t\t\t\t\t\tchRoot = true;\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint get_ancestor(int a, int k) const {\n\t\tassert(k >= 0);\n\t\ta = idx[a];\n\t\twhile (a != -1 && k) {\n\t\t\tif (k >= heavyPar[a].second) {\n\t\t\t\tk -= heavyPar[a].second;\n\t\t\t\tassert(heavyPar[a].first <= a - heavyPar[a].second);\n\t\t\t\ta = heavyPar[a].first;\n\t\t\t} else {\n\t\t\t\ta -= k;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tif (a == -1) return -1;\n\t\telse return preorder[a];\n\t}\n\n\tint lca(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\treturn preorder[a];\n\t\t\t}\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t}\n\n\tint dist(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\tres += b - a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres += heavyPar[b].second;\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n} // namespace ecnerwala\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > edges(n);\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tvector<int> par(n, -1);\n\tvector<int> vis(n, 0);\n\tint root = 0;\n\tvector<int> e;\n\ty_combinator(\n\t\t[&](auto self, int v, int p) -> void {\n\t\t\tpar[v] = p;\n\t\t\tvis[v] = 1;\n\t\t\tfor(int w : edges[v]){\n\t\t\t\tif(vis[w]) continue;\n\t\t\t\te.push_back(w);\n\t\t\t\tself(w, v);\n\t\t\t}\n\t\t}\n\t)(root, -1);\n\tecnerwala::level_ancestor la(par);\n\tint nbad = 0;\n\tvector<int> upd(n, 0);\n\tvector<int> upd2(n, 0);\n\tfor(int u = 0; u < n; u++){\n\t\tfor(int v : edges[u]){\n\t\t\tint clen = la.dist(u, v) + 1;\n\t\t\tif(clen & 1){\n\t\t\t\tnbad++;\n\t\t\t\tupd[u]++;\n\t\t\t\tupd[v]++;\n\t\t\t\tupd[la.lca(u, v)] -= 2;\n\t\t\t} else if(clen > 2){\n\t\t\t\tupd2[u]++;\n\t\t\t\tupd2[v]++;\n\t\t\t\tupd2[la.lca(u, v)] -= 2;\n\t\t\t}\n\t\t}\n\t}\n\treverse(e.begin(), e.end());\n\tfor(int v : e){\n\t\tupd[par[v]] += upd[v];\n\t\tupd2[par[v]] += upd2[v];\n\t}\n\tint bu = -1, bv = -1;\n\tif(nbad == 0){\n\t\tbu = 0;\n\t\tbv = 0;\n\t} else if(nbad == 2){\n\t\tfor(int u = 0; u < n; u++){\n\t\t\tfor(int v : edges[u]){\n\t\t\t\tint parity = la.dist(u, v) + 1;\n\t\t\t\tif(parity & 1){\n\t\t\t\t\tbu = u;\n\t\t\t\t\tbv = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(int x = 0; x < n; x++){\n\t\t\tif(upd[x] == nbad && upd2[x] == 0){\n\t\t\t\tbu = x;\n\t\t\t\tbv = par[x];\n\t\t\t}\n\t\t}\n\t}\n\tif(bu == -1){\n\t\tcout << ""NO"" << \'\\n\';\n\t\treturn;\n\t}\n\tvector<int> color(n, -1);\n\tvis = vector<int>(n, 0);\n\ty_combinator([&](auto self, int v, int c) -> void {\n\t\tcolor[v] = c;\n\t\tvis[v] = 1;\n\t\tfor(int w : edges[v]){\n\t\t\tif(v == bu && w == bv) continue;\n\t\t\tif(v == bv && w == bu) continue;\n\t\t\tif(vis[w]) continue;\n\t\t\tself(w, c ^ 1);\n\t\t}\n\t})(bu, 1);\n\tcout << ""YES"" << \'\\n\';\n\tfor(int i = 0; i < n; i++) cout << color[i];\n\tcout << \'\\n\';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","['dfs and similar', 'divide and conquer', 'dsu', 'graphs', 'trees']",2600
https://codeforces.com//contest/1717/problem/B,B. Madoka and Underground Competitions,Madoka decided to participate in an underground sports programming competition And there was exactly one task in it A square table of size n times n where is called if only the characters and are written in it as well as in any subtable of size 1 times k or k times 1 there is at least one character In other words among any k consecutive vertical or horizontal cells there must be at least one containing the character Output any table that has the possible number of characters and also the symbol is written in the cell r c Rows are numbered from 1 to n from top to bottom columns are numbered from 1 to n from left to right ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n, k, r, c;\n    cin >> n >> k >> r >> c;\n    --r;\n    --c;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << "".X""[(j - i + n) % k == (c - r + n) % k];\n        }\n        cout << ""\\n"";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}']","['constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/990/problem/D,D. Graph And Its Complement,Given three numbers n a b You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to a and the number of components in its complement is b The matrix must be symmetric and all digits on the main diagonal must be zeroes In an undirected graph loops edges from a vertex to itself are not allowed It can be at most one edge between a pair of vertices The adjacency matrix of an undirected graph is a square matrix of size n consisting only of 0 and 1 where n is the number of vertices of the graph and the i th row and the i th column correspond to the i th vertex of the graph The cell i j of the adjacency matrix contains 1 if and only if the i th and j th vertices in the graph are connected by an edge A connected component is a set of vertices X such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices but adding any other vertex to X violates this rule The complement or inverse of a graph G is a graph H on the same vertices such that two distinct vertices of H are adjacent if and only if they are not adjacent in G ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 1005;\n\nint n, a, b;\nchar B[Maxn][Maxn];\n\nint main()\n{\n\tscanf(""%d %d %d"", &n, &a, &b);\n\tif (a != 1 && b != 1) { printf(""NO\\n""); return 0; }\n\tif ((n == 2 || n == 3) && a == 1 && b == 1) { printf(""NO\\n""); return 0; }\n\tprintf(""YES\\n"");\n\tfor (int i = 0; i < n; i++)\n\t\tB[i][i] = \'0\';\n\tchar cola = \'1\', colb = \'0\';\n\tif (b != 1) { swap(cola, colb); swap(a, b); }\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++) if (i != j)\n\t\t\tB[i][j] = B[j][i] = colb;\n\tfor (int i = a - 1; i + 1 < n; i++)\n\t\tB[i][i + 1] = B[i + 1][i] = cola;\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i][n] = \'\\0\';\n\t\tprintf(""%s\\n"", B[i]);\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'graphs', 'implementation']",1700
https://codeforces.com//contest/1000/problem/D,D. Yet Another Problem On a Subsequence,The sequence of integers a 1 a 2 dots a k is called a good array if a 1 k 1 and a 1 0 For example the sequences 3 1 44 0 1 99 are good arrays and the sequences 3 7 8 2 5 4 1 0 are not A sequence of integers is called good if it can be divided into a positive number of good arrays Each good array should be a subsegment of sequence and each element of the sequence should belong to exactly one array For example the sequences 2 3 0 1 4 1 2 3 3 9 4 are good and the sequences 2 3 0 1 1 2 3 3 9 4 1 are not For a given sequence of numbers count the number of its that are good sequences and print the number of such subsequences modulo ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 1010;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint a[N];\nint d[N];\nint c[N][N];\n\nvoid solve()\n{\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        for(int i = 1; i < N; i++){\n                for(int j = 0; j <= i; j++){\n                        if(j == 0 || i == j){\n                                c[i][j] = 1;\n                        }\n                        else{\n                                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n                                if(c[i][j] >= mod){\n                                        c[i][j] -= mod;\n                                }\n                        }\n                }\n        }\n        int ans = 0;\n        for(int i = 1; i <= n; i++){\n                if(a[i] < 1){\n                        continue;\n                }\n                d[i] = 1;\n                for(int j = 1; j < i; j++){\n                        if(a[j] < 1){\n                                continue;\n                        }\n                        int col = i - j - 1;\n                        if(a[j] <= col){\n                                d[i] += 1ll * d[j] * c[col][a[j]] % mod;\n                                if(d[i] >= mod){\n                                        d[i] -= mod;\n                                }\n                        }\n                }\n                int col = n - i;\n                if(a[i] <= col){\n                        ans += 1ll * d[i] * c[col][a[i]] % mod;\n                        if(ans >= mod){\n                                ans -= mod;\n                        }\n                }\n        }\n        cout << ans << ""\\n"";\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","['combinatorics', 'dp']",1900
https://codeforces.com//contest/961/problem/F,F. k-substrings,You are given a string consisting of lowercase Latin letters Let s denote substring of as a string Obviously and there are exactly such substrings Let s call some string an of a string iff the following conditions are met is an odd number is simultaneously a prefix and a suffix of For evey substring of you have to calculate the maximum length of its odd proper suprefix ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint P[3] = { 359, 1039, 2797 };\nll MO[3] = { MOD, MOD + 2, 1000000087 };\n\nchar in[1000050];\nll po[3][1000050];\nll sum[3][1000050];\nbool isEqual(int s1, int e1, int s2, int e2) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tll v1 = (sum[i][e1] - sum[i][s1 - 1]) % MO[i];\n\t\tv1 = (v1 + MO[i]) % MO[i];\n\t\tv1 = v1 * po[i][1000000 - e1] % MO[i];\n\n\t\tll v2 = (sum[i][e2] - sum[i][s2 - 1]) % MO[i];\n\t\tv2 = (v2 + MO[i]) % MO[i];\n\t\tv2 = v2 * po[i][1000000 - e2] % MO[i];\n\t\tif (v1 != v2) return false;\n\t}\n\treturn true;\n}\nint main() {\n\tint N, i, j;\n\tscanf(""%d"", &N);\n\tscanf(""%s"", in + 1);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tpo[i][0] = P[i];\n\t\tfor (j = 1; j <= 1000000; j++) po[i][j] = po[i][j - 1] * P[i] % MO[i];\n\t\tfor (j = 1; j <= N; j++) sum[i][j] = (sum[i][j - 1] + po[i][j] * in[j]) % MO[i];\n\t}\n\n\tvector <int> Va;\n\tint prv = -1;\n\tfor (i = (N + 1) / 2; i >= 1; i--) {\n\t\tint st = i, en = N + 1 - st;\n\t\tint L = en - st + 1;\n\t\tint mx = min(L - 1, prv + 2);\n\t\tif (mx % 2 == 0) mx--;\n\t\tfor (j = mx; j >= 1; j-=2) {\n\t\t\tif (isEqual(st, st + j - 1, en - j + 1, en)) break;\n\t\t}\n\t\tif (j >= 1) Va.push_back(j);\n\t\telse Va.push_back(-1);\n\t\tprv = j;\n\t}\n\treverse(all(Va));\n\tfor (auto it : Va) printf(""%d "", it);\n\treturn !printf(""\\n"");\n}']","['binary search', 'hashing', 'string suffix structures']",2700
https://codeforces.com//contest/1740/problem/A,A. Factorise N+M,Pak Chanek has a prime number dagger n Find a prime number m such that n m is not prime dagger A prime number is a number with 2 factors The first few prime numbers are 2 3 5 7 11 13 ldots In particular 1 is a prime number ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::cout << n << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['constructive algorithms', 'number theory']",800
https://codeforces.com//contest/460/problem/D,D. Little Victor and Set,Little Victor adores the sets theory Let us remind you that a set is a group of numbers where all numbers are pairwise distinct Today Victor wants to find a set of integers that has the following properties for all the following inequality holds lets denote the th element of the set as value must be as small as possible Help Victor find the described set ,"[""#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\nusing namespace std;\n\nvoid f4(long long l,long long r,int k)\n{\n    long long minn=1,minj;\n    int num;\n    long long s;\n    long long i,j;\n\n    for (i=1;i<(  (1LL)<<(r-l+1)  );i++)\n    {\n        s=0;\n        num=0;\n        for (j=0;j<= r-l ;j++)\n           if ( ( ((1LL)<<j) & i )!=0  )\n           {\n              num++;\n              s^=(l+j);\n           }\n        if (num<=k && s<=minn)\n                minn=s,minj=i;\n    }\n\n    cout<<minn<<endl;\n\n    num=0;\n      for (j=0;j<= r-l ;j++)\n        if ( ( ((1LL)<<j) &minj)!=0  )\n          num++;\n\n    cout<<num<<endl;\n\n    int flag=0;\n      for (j=0;j<= r-l ;j++)\n        if ( ( ((1LL)<<j) &minj)!=0  )\n        {\n            if (flag) cout<<' ';\n            cout<<l+j;\n            flag=1;\n        }\n\n     cout;\n\n    return ;\n}\n\nvoid f3(long long l,long long r,int k)\n{\n    int n;\n    int i;\n    long long s=1;\n    for (n=1;n<=40;n++)\n    {\n        s<<=1;\n        if (s>l && s<r) break;\n    }\n    if ( (((1LL)<<n)+((1LL)<<(n-1))) > r )\n    {\n        if (r-l+1>2)\n        {\n            l=l%2==0?l:l+1;\n        }\n        cout<<(l^(l+1))<<endl<<2<<endl<<l<<' '<<l+1;\n        return;\n    }\n    else\n    {\n        long long x1,x2,x3;\n        x1=((1LL)<<n)-1;\n        x2=((1LL)<<n)+((1LL)<<(n-1))-1;\n        x3=x2+1;\n\n        cout<<(x1^x2^x3)<<endl<<3<<endl<<x1<<' '<<x2<<' '<<x3;\n        return;\n    }\n\n\n\n}\n\n\nint main()\n{\n    long long l,r,k;\n\n\n     cin>>l>>r>>k;\n\n     if (k==1)\n    {\n        cout<<l<<endl<<1<<endl<<l;\n    }\n    else if (k==2)\n    {\n        long long ll=l;\n        if (r-l+1>2)\n        {\n            ll=l%2==0?l:l+1;\n        }\n        if ((ll^(ll+1))>l) cout<<l<<endl<<1<<endl<<l;\n        else cout<<(ll^(ll+1))<<endl<<2<<endl<<ll<<' '<<ll+1;\n    }\n    else if (k>=4 && r-l+1>=7)\n    {\n        l=(l-1)/4*4+4;\n        cout<<0<<endl<<4<<endl<<l<<' '<<l+1<<' '<<l+2<<' '<<l+3;\n    }\n    else\n    {\n        if (k>=4) f4(l,r,k);\n        else f3(l,r,k);\n    }\n\n\n\n    return 0;\n}\n""]","['brute force', 'constructive algorithms', 'math']",2300
https://codeforces.com//contest/248/problem/A,A. Cupboards,One foggy Stockholm morning Karlsson decided to snack on some jam in his friend Lillebror Svantenson s house Fortunately for Karlsson there wasn t anybody in his friend s house Karlsson was not going to be hungry any longer so he decided to get some food in the house Karlsson s gaze immediately fell on wooden cupboards standing in the kitchen He immediately realized that these cupboards have hidden jam stocks Karlsson began to fly greedily around the kitchen opening and closing the cupboards doors grab and empty all the jars of jam that he could find And now all jars of jam are empty Karlsson has had enough and does not want to leave traces of his stay so as not to let down his friend Each of the cupboards has two doors the left one and the right one Karlsson remembers that when he rushed to the kitchen all the cupboards left doors were in the same position open or closed similarly all the cupboards right doors were in the same position open or closed Karlsson wants the doors to meet this condition as well by the time the family returns Karlsson does not remember the position of all the left doors also he cannot remember the position of all the right doors Therefore it does not matter to him in what position will be all left or right doors It is important to leave all the left doors in the same position and all the right doors in the same position For example all the left doors may be closed and all the right ones may be open Karlsson needs one second to open or close a door of a cupboard He understands that he has very little time before the family returns so he wants to know the minimum number of seconds in which he is able to bring all the cupboard doors in the required position Your task is to write a program that will determine the required number of seconds ,"['#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint main()\n{\n    int n;\n    scanf(""%d"",&n);\n    int ll=0,rr=0;\n    for (int i=0;i<n;i++)\n    {\n        int l,r;\n        scanf(""%d%d"",&l,&r);\n        if (l) ll++;\n        if (r) rr++;\n    }\n    if (ll*2>n) ll=n-ll;\n    if (rr*2>n) rr=n-rr;\n    printf(""%d\\n"",ll+rr);\n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1528/problem/A,A. Parsa s Humongous Tree,Parsa has a humongous tree on n vertices On each vertex v he has written two integers l v and r v To make Parsa s tree look even more majestic Nima wants to assign a number a v l v le a v le r v to each vertex v such that the beauty of Parsa s tree is maximized Nima s sense of the beauty is rather bizarre He defines the beauty of the tree as the sum of a u a v over all edges u v of the tree Since Parsa s tree is too large Nima can t maximize its beauty on his own Your task is to find the possible beauty for Parsa s tree ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nusing ll = int64_t;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > edges(n);\n\tvector<ll> l(n), r(n);\n\tfor(int i = 0; i < n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tpair<ll, ll> res = y_combinator(\n\t\t[&](auto self, int v, int p) -> pair<ll, ll> {\n\t\t\tll lcost = 0;\n\t\t\tll rcost = 0;\n\t\t\tfor(int w : edges[v]){\n\t\t\t\tif(w == p) continue;\n\t\t\t\tauto [a, b] = self(w, v);\n\t\t\t\tlcost += max(abs(l[v] - l[w]) + a, abs(l[v] - r[w]) + b);\n\t\t\t\trcost += max(abs(r[v] - l[w]) + a, abs(r[v] - r[w]) + b);\n\t\t\t}\n\t\t\treturn {lcost, rcost};\n\t\t}\n\t)(0, -1);\n\tcout << max(res.first, res.second) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","['dfs and similar', 'divide and conquer', 'dp', 'greedy', 'trees']",1600
https://codeforces.com//contest/1921/problem/D,D. Very Different Array,Petya has an array a i of n integers His brother Vasya became envious and decided to make his own array of n integers To do this he found m integers b i m ge n and now he wants to choose some n integers of them and arrange them in a certain order to obtain an array c i of length n To avoid being similar to his brother Vasya wants to make his array as different as possible from Petya s array Specifically he wants the total difference D sum i 1 n a i c i to be as large as possible Help Vasya find the maximum difference D he can obtain ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,m,ans=0;\n    cin>>n>>m;\n    ll a[n+1],b[m+1];\n    for(ll i=1;i<=n;i++) cin>>a[i];\n    for(ll i=1;i<=m;i++) cin>>b[i];\n    sort(a+1,a+n+1);\n    reverse(a+1,a+n+1);\n    sort(b+1,b+m+1);\n    ll s=0;\n    for(ll i=1;i<=n;i++) s+=abs(a[i]-b[i]);\n    ans=s;\n    for(ll i=n;i>=1;i--){\n        s-=abs(a[i]-b[i]);\n        s+=abs(a[i]-b[m-n+i]);\n        ans=max(ans,s);\n    }\n    cout<<ans;\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","['data structures', 'greedy', 'sortings', 'two pointers']",1100
https://codeforces.com//contest/1690/problem/A,A. Print a Pedestal  Codeforces logo  ,Given the integer n the number of available blocks You must use blocks to build a The consists of 3 platforms for 2 nd 1 st and 3 rd places respectively The platform for the 1 st place must be higher than for the 2 nd place and the platform for the 2 nd place must be higher than for the 3 rd place Also the height of each platform must be greater than zero that is each platform must contain at least one block Among all possible pedestals of n blocks deduce one such that the platform height for the 1 st place as possible If there are several of them output any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1\'000\'000\'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nvoid solve(){\n    int n;\n    cin >> n;\n    int on = n;\n    n -= 3 * ((n - 3) / 3);\n    vector<int> ans = {inf, inf, inf};\n    for (int f = 0; f <= n; f++){\n        for (int s = 0; s <= n; s++){\n            for (int t = 0; t <= n; t++){\n                if (f + s + t != n){\n                    continue;\n                }\n                vector<int> a(3);\n                a[0] = a[1] = a[2] = (on - 3) / 3;\n                a[0] += f, a[1] += s, a[2] += t;\n                if (a[1] > a[0] && a[0] > a[2] && a[1] < ans[1]){\n                    ans = a;\n                }\n            }\n        }\n    }\n    cout << ans[0] << "" "" << ans[1] << "" "" << ans[2] << ""\\n"";\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}']","['constructive algorithms', 'greedy']",800
https://codeforces.com//contest/558/problem/A,A. Lala Land and Apple Trees,Amr lives in Lala Land Lala Land is a very beautiful country that is located on a coordinate line Lala Land is famous with its apple trees growing everywhere Lala Land has exactly apple trees Tree number is located in a position and has apples growing on it Amr wants to collect apples from the apple trees Amr currently stands in position At the beginning he can choose whether to go right or left He ll continue in his direction until he meets an apple tree he didn t visit before He ll take all of its apples and then reverse his direction continue walking in this direction until he meets another apple tree he didn t visit before and so on In the other words Amr reverses his direction when visiting each new apple tree Amr will stop collecting apples when there are no more trees he didn t visit in the direction he is facing What is the maximum number of apples he can collect ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 1e5+5;\n\nint i, j, k, n, m;\n\nint x, y;\n\nvector< pii > l, r;\n\nint main(){\n\n\tcin >> n;\n\n\tFOR(i,1,n) {\n\t\t\n\t\tcin >> x >> y;\n\t\t\n\t\tif(x < 0) l.pb(mp(x,y));\n\t\telse r.pb(mp(x,y));\n\n\t}\n\n\tsort(l.begin(),l.end(),greater< pii > ());\n\n\tsort(r.begin(),r.end());\n\n\tint mn = min(l.size(), r.size());\n\n\tmn--;\n\n\tint ans = 0;\n\n\tFOR(i,0,mn) ans += l[i].nd + r[i].nd;\n\n\tint t = 0;\n\n\tif(l.size() > mn + 1) t = max(t, l[mn + 1].nd);\n\tif(r.size() > mn + 1) t = max(t, r[mn + 1].nd);\n\n\tcout << ans + t << endl;\n\n   return 0;\n}\n']","['brute force', 'implementation', 'sortings']",1100
https://codeforces.com//contest/1811/problem/D,D. Umka and a Long Flight,The girl Umka loves to travel and participate in math olympiads One day she was flying by plane to the next olympiad and out of boredom explored a huge checkered sheet of paper Denote the n th Fibonacci number as F n begin cases 1 n 0 1 n 1 F n 2 F n 1 n ge 2 end cases A checkered rectangle with a height of F n and a width of F n 1 is called a Fibonacci rectangle n Umka has a Fibonacci rectangle n Someone colored a cell in it at the intersection of the row x and the column y It is necessary to cut this rectangle into n 1 squares in such way that the painted cell was in a square with a side of 1 there was pair of squares with equal sides the side of each square was equal to a Fibonacci number Will Umka be able to cut this rectangle in that way ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint64_t f[55];\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n  f[0] = f[1] = 1;\n  for (int i = 2; i <= 50; i++) {\n    f[i] = f[i - 1] + f[i - 2];\n  }\n  int tt; cin >> tt;\n  while (tt--) {\n    int n;\n    int64_t x, y;\n    cin >> n >> x >> y;\n    bool ok = true;\n    for (int i = n; i >= 1; i--) {\n      int64_t need = f[i + 1] - f[i];\n      y = min(y, f[i + 1] - y + 1);\n      if (y > need) {\n        ok = false;\n        break;\n      }\n      swap(x, y);\n    }\n    cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n  }\n  return 0;\n}\n']","['constructive algorithms', 'implementation', 'math']",1600
https://codeforces.com//contest/1673/problem/C,C. Palindrome Basis,You are given a positive integer n Let s call some positive integer a without leading zeroes palindromic if it remains the same after reversing the order of its digits Find the number of distinct ways to express n as a sum of positive palindromic integers Two ways are considered different if the frequency of at least one palindromic integer is different in them For example 5 4 1 and 5 3 1 1 are considered different but 5 3 1 1 and 5 1 3 1 are considered the same Formally you need to find the number of distinct multisets of positive palindromic integers the sum of which is equal to n Since the answer can be quite large print it modulo 10 9 7 ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nconst int N=40005;\nconst int mod=1e9+7;\n\nint dp[N],n=40000;\n\nbool check(int x){\n    static int a[10],len;\n    len=0;while(x)a[++len]=x%10,x/=10;\n    for(int i=1,j=len;i<j;i++,j--)if(a[i]!=a[j])return false;\n    return true;\n}\n\nint main(){\n    dp[0]=1;\n    for(int i=1;i<=n;i++){\n        if(check(i)){\n            for(int j=i;j<=n;j++)\n                dp[j]=(dp[j]+dp[j-i])%mod;\n        }\n    }\n    int T=read();\n    while(T--)print(dp[read()],'\\n');\n    return 0;\n}""]","['brute force', 'dp', 'math', 'number theory']",1500
https://codeforces.com//contest/1706/problem/B,B. Making Towers,You have a sequence of n colored blocks The color of the i th block is c i an integer between 1 and n You will place the blocks down in sequence on an infinite coordinate grid in the following way Initially you place block 1 at 0 0 For 2 le i le n if the i 1 th block is placed at position x y then the i th block can be placed at one of positions x 1 y x 1 y x y 1 as long no previous block was placed at that position A is formed by s blocks such that they are placed at positions x y x y 1 ldots x y s 1 for some position x y and integer s The of the tower is s the number of blocks in it A is a tower such that all blocks in it have the color r For each color r from 1 to n solve the following problem Find the maximum size of a tower of color r that you can form by placing down the blocks according to the rules ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1e5 + 5;\n\nint a[N], ans[N], las[N];\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\trep(i, 1, n) ans[i] = las[i] = 0;\n\t\trep(i, 1, n) {\n\t\t\ta[i] = read();\n\t\t\tif (!las[a[i]])\n\t\t\t\tlas[a[i]] = i, ans[a[i]] = 1;\n\t\t\telse {\n\t\t\t\tif (i % 2 != las[a[i]] % 2) {\n\t\t\t\t\tlas[a[i]] = i;\n\t\t\t\t\t++ans[a[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 1, n) printf(""%d%c"", ans[i], i == n ? \'\\n\' : \' \');\n\t}\n}']","['dp', 'greedy', 'math']",1100
https://codeforces.com//contest/456/problem/B,B. Fedya and Maths,Fedya studies in a gymnasium Fedya s maths hometask is to calculate the following expression for given value of Fedya managed to complete the task Can you Note that given number can be extremely large e g it can exceed any integer type of your programming language ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n\nusing namespace std;\n\nchar A[100005];\nint res=0, mide, es;\n\nint main()\n{\n    scanf(""%s"",A);\n    for(mide=0; A[mide]!=\'\\0\'; mide++);\n    mide-=2;\n    for(int i=1; i<=2; i++){\n        if(mide>=0){\n            es*=10;\n            es+=A[mide]-\'0\';\n        }\n        ++mide;\n    }\n    if(es%4==0){\n        res+=4;\n    }\n    else if(es%4==1){\n        res+=0;\n    }\n    else if(es%4==2){\n        res+=0;\n    }\n    else if(es%4==3){\n        res+=0;\n    }\n    printf(""%d\\n"",res);\n    return 0;\n}\n']","['math', 'number theory']",1200
https://codeforces.com//contest/219/problem/B,B. Special Offer  Super Price 999 Bourles ,Polycarpus is an amateur businessman Recently he was surprised to find out that the market for paper scissors is completely free Without further ado Polycarpus decided to start producing and selling such scissors Polycaprus calculated that the optimal celling price for such scissors would be bourles However he read somewhere that customers are attracted by prices that say something like Special Offer Super price 999 bourles So Polycarpus decided to lower the price a little if it leads to the desired effect Polycarpus agrees to lower the price by no more than bourles so that the number of nines at the end of the resulting price is maximum If there are several ways to do it he chooses the maximum possible price Note Polycarpus counts only the nines in a price ,"['#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nint main()\n{\n    LL a,b,ans;\n    cin >> a >> b;\n    b=a-b;\n    ans=a;\n    for (int i=0;i<=18;++i){\n        LL tail=0,base=1;\n        for (int j=0;j<i;++j){\n            tail=tail*10LL+9;\n            base*=10;\n        }\n        LL front=a/base;\n        if (tail>a%base) --front;\n        if (front<0) continue;\n        LL cur=front*base+tail;\n        if (cur>=b){\n            ans=cur;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n']",['implementation'],1400
https://codeforces.com//contest/947/problem/F,F. Public Service,There are cities in Bob s country connected by roads Some pairs of cities are connected by public transport There are two competing transport companies operating buses and running trains When traveling from to a passenger always first selects the mode of transport either bus or train and then embarks on a journey For every pair of cities there are exactly two ways of how to travel between them without visiting any city more than once one using only bus routes and the second using only train routes Furthermore there is no pair of cities that is directly connected by both a bus route and a train route You obtained the plans of each of the networks Unfortunately each of the companies uses different names for the same cities More precisely the bus company numbers the cities using integers from to while the train company uses integers between and Find one possible mapping between those two numbering schemes such that no pair of cities is connected directly by both a bus route and a train route Note that this mapping has to map different cities to different cities ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 10000;\n\nstruct T {\n\tint n;\n\tvector<int> adj[MAXN];\n\n\tbool alive[MAXN]; int nalive;\n\tint deg[MAXN];\n\tint afst[MAXN], alst[MAXN], anxt[MAXN], aprv[MAXN]; // doubly-linked lists for leaves adjacent to a node\n\tint bfst, blst, bnxt[MAXN], bprv[MAXN]; // doubly-linked lists for nodes adjacent to at least one leaf\n\tpriority_queue<pair<int, int> > pq;\n\n\tvoid init() {\n\t\tnalive = n; REP(i, n) alive[i] = true, deg[i] = SZ(adj[i]), afst[i] = alst[i] = -1; bfst = blst = -1;\n\t\tREP(at, n) if (deg[at] == 1) aappend(at, adj[at][0]);\n\t\tREP(at, n) if (afst[at] != -1) bappend(at);\n\t\tpq = priority_queue<pair<int, int> >(); REP(i, n) pq.push(MP(deg[i], i));\n\t}\n\tvoid killleaf(int at) {\n\t\tassert(deg[at] == 1); alive[at] = false; --nalive;\n\t\tint to = -1; REPSZ(i, adj[at]) if (alive[adj[at][i]]) { assert(to == -1); to = adj[at][i]; } assert(to != -1);\n\t\t--deg[at]; if (deg[at] == 0) { aremove(at, to); if (afst[to] == -1) bremove(to); }\n\t\t--deg[to]; pq.push(MP(deg[to], to)); if (deg[to] == 0) { aremove(to, at); if (afst[at] == -1) bremove(at); }\n\t\tif (deg[to] == 1) {\n\t\t\tint oth = -1; REPSZ(i, adj[to]) if (alive[adj[to][i]]) { assert(oth == -1); oth = adj[to][i]; } assert(oth != -1);\n\t\t\taappend(to, oth);\n\t\t\tif (afst[oth] == to&&anxt[to] == -1) bappend(oth);\n\t\t}\n\t}\n\tvoid aappend(int at, int to) {\n\t\taprv[at] = alst[to], anxt[at] = -1; if (aprv[at] == -1) afst[to] = at; else anxt[aprv[at]] = at; alst[to] = at;\n\t}\n\tvoid aremove(int at, int to) {\n\t\tif (aprv[at] == -1) afst[to] = anxt[at]; else anxt[aprv[at]] = anxt[at];\n\t\tif (anxt[at] == -1) alst[to] = aprv[at]; else aprv[anxt[at]] = aprv[at];\n\t}\n\tvoid bappend(int at) {\n\t\tbprv[at] = blst, bnxt[at] = -1; if (bprv[at] == -1) bfst = at; else bnxt[bprv[at]] = at; blst = at;\n\t}\n\tvoid bremove(int at) {\n\t\tif (bprv[at] == -1) bfst = bnxt[at]; else bnxt[bprv[at]] = bnxt[at];\n\t\tif (bnxt[at] == -1) blst = bprv[at]; else bprv[bnxt[at]] = bprv[at];\n\t}\n\tbool getleavesatleastthreeapart(pair<int,int> &u, pair<int,int> &v) {\n\t\tif (bfst == -1 || bnxt[bfst] == -1) return false;\n\t\tint x = bfst, y = bnxt[bfst], r = maxdeg().second; if (afst[r] != -1 && x != r) y = r;\n\t\tu = MP(afst[x], x), v = MP(afst[y], y); assert(u.first != -1 && v.first != -1); return true;\n\t}\n\tpair<int, int> maxdeg() { while (!pq.empty() && (!alive[pq.top().second] || deg[pq.top().second] != pq.top().first)) pq.pop(); return !pq.empty() ? pq.top() : MP(0, -1); }\n\tbool isstar() { return maxdeg().first == nalive - 1; }\n\tbool issemistar() { return maxdeg().first == nalive - 2; }\n\tbool ispath() { return maxdeg().first <= 2; }\n\tbool getsemistar1(vector<int> &rem) {\n\t\tif (!issemistar()) return false; assert(bfst != -1 && bnxt[bfst] != -1 && bnxt[bnxt[bfst]] == -1);\n\t\tint w = maxdeg().second; assert(bfst == w || bnxt[bfst] == w); int v = bfst + bnxt[bfst] - w; assert(afst[v] != -1 && anxt[afst[v]] == -1); int u = afst[v];\n\t\trem.clear(); rem.PB(u); rem.PB(v); rem.PB(w); REP(i, n) if (alive[i] && i != u&&i != v&&i != w) rem.PB(i); return true;\n\t}\n\tbool getsemistar2(vector<int> &rem) {\n\t\tif (isstar()) return false; assert(bfst != -1 && bnxt[bfst] != -1); int u = bfst, w = afst[u], v = afst[bnxt[bfst]]; assert(w != -1 && u != -1);\n\t\trem.clear(); rem.PB(u); rem.PB(v); rem.PB(w); REP(i, n) if (alive[i] && i != u&&i != v&&i != w) rem.PB(i); return true;\n\t}\n\tbool getpath1(vector<int> &rem) {\n\t\tif (!ispath()) return false;\n\t\tint at = -1; REP(i, n) if (alive[i] && deg[i] <= 1) { at = i; break; } assert(at != -1);\n\t\trem.PB(at); while (true) { int to = -1; REPSZ(i, adj[at]) if (alive[adj[at][i]] && (SZ(rem) == 1 || adj[at][i] != rem[SZ(rem) - 2])) { assert(to == -1); to = adj[at][i]; } if (to == -1) break; at = to; rem.PB(at); } return SZ(rem) == 5;\n\t}\n\tbool getpath2(vector<int> &rem) {\n\t\tif (!getpath1(rem)) return false;\n\t\tswap(rem[0], rem[2]); swap(rem[0], rem[4]); swap(rem[0], rem[3]); swap(rem[0], rem[1]); return true;\n\t}\n};\n\nint n;\nT a, b;\nint mp[MAXN];\nstruct Op { pair<int, int> au, av, bu, bv; };\nvector<Op> ops;\n\n\nvoid run() {\n\tscanf(""%d"", &n);\n\ta.n = n; REP(i, n - 1) { int u, v; scanf(""%d%d"", &u, &v); --u, --v; a.adj[u].PB(v); a.adj[v].PB(u); } a.init();\n\tb.n = n; REP(i, n - 1) { int u, v; scanf(""%d%d"", &u, &v); --u, --v; u -= n; v -= n; b.adj[u].PB(v); b.adj[v].PB(u); } b.init();\n\n\tif (a.isstar() || b.isstar()) { printf(""No\\n""); return; }\n\tREP(i, n) mp[i] = -1; ops.clear();\n\twhile (true) {\n\t\t//printf(""maxdeg: (%d,%d) (%d,%d)\\n"", a.maxdeg().first, a.maxdeg().second + 1, b.maxdeg().first, b.maxdeg().second + 1 + n);\n\t\tif (a.issemistar()) {\n\t\t\t//printf(""a semistar\\n"");\n\t\t\tvector<int> arem; assert(a.getsemistar1(arem));\n\t\t\tvector<int> brem; assert(b.getsemistar2(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (b.issemistar()) {\n\t\t\t//printf(""b semistar\\n"");\n\t\t\tvector<int> arem; assert(a.getsemistar2(arem));\n\t\t\tvector<int> brem; assert(b.getsemistar1(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (a.nalive == 5 || b.nalive == 5) {\n\t\t\tassert(a.nalive == 5 && b.nalive == 5 && a.ispath() && b.ispath());\n\t\t\t//printf(""5 path\\n"");\n\t\t\tvector<int> arem; assert(a.getpath1(arem));\n\t\t\tvector<int> brem; assert(b.getpath2(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tassert(a.nalive >= 6 && b.nalive >= 6);\n\t\t//printf(""general case: "");\n\t\tpair<int,int> au, av; assert(a.getleavesatleastthreeapart(au, av));\n\t\tpair<int,int> bu, bv; assert(b.getleavesatleastthreeapart(bu, bv));\n\t\t//printf(""(%d,%d) and (%d,%d)\\n"", au.first + 1, av.first + 1, bu.first + n + 1, bv.first + n + 1);\n\t\ta.killleaf(au.first); a.killleaf(av.first);\n\t\tb.killleaf(bu.first); b.killleaf(bv.first);\n\t\tOp op; op.au = au, op.av = av, op.bu = bu, op.bv = bv; ops.PB(op);\n\t}\n\tfor (int i = SZ(ops) - 1; i >= 0; --i) {\n\t\tpair<int, int> au = ops[i].au, av = ops[i].av, bu = ops[i].bu, bv = ops[i].bv;\n\t\tif (mp[au.second] != bu.second&&mp[av.second] != bv.second) { mp[au.first] = bu.first; mp[av.first] = bv.first; continue; }\n\t\tif (mp[au.second] != bv.second&&mp[av.second] != bu.second) { mp[au.first] = bv.first; mp[av.first] = bu.first; continue; }\n\t\tassert(false);\n\t}\n\tprintf(""Yes\\n"");\n\tREP(i, n) { if (i != 0) printf("" ""); printf(""%d"", mp[i] == -1 ? -1 : mp[i] + n + 1); } puts("""");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']","['constructive algorithms', 'graphs', 'trees']",3200
https://codeforces.com//contest/1586/problem/A,A. Windblume Ode,You have obtained the elegant bow known as the Windblume Ode Inscribed in the weapon is an array of n n ge 3 positive integers i e different no duplicates are allowed Find the largest subset i e having the maximum number of elements of this array such that its sum is a composite number A positive integer x is called composite if there exists a positive integer y such that 1 y x and x is divisible by y If there are multiple subsets with this largest size with the composite sum you can output any of them It can be proven that under the constraints of the problem such a non empty subset always exists ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[105];\nbool isp(int x)\n{\n\tfor(int i = 2; i * i <= x; i ++) if(x % i == 0) return false;\n\treturn true;\n}\nvoid solve()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%d"", &a[i]);\n\tint sum = 0;\n\trep(i, n) sum += a[i];\n\tif(isp(sum)) {\n\t\tint mn = MOD;\n\t\trep(i, n) if(a[i] & 1) mn = min(mn, a[i]);\n\t\tprintf(""%d\\n"", n - 1);\n\t\trep(i, n) if(mn != a[i]) printf(""%d "", i + 1); printf(""\\n"");\n\t} else {\n\t\tprintf(""%d\\n"", n);\n\t\trep(i, n) printf(""%d "", i + 1); printf(""\\n"");\n\t}\n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']","['brute force', 'constructive algorithms', 'greedy', 'math', 'number theory']",800
https://codeforces.com//contest/1759/problem/D,D. Make It Round,Inflation has occurred in Berlandia so the store needs to change the price of goods The current price of good n is given It is allowed to increase the price of the good by k times with 1 le k le m k is an integer Output the roundest possible new price of the good That is the one that has the maximum number of zeros at the end For example the number is more round than the number three zeros at the end of and only one at the end of If there are several possible variants output the one in which the new price is maximal If it is impossible to get a rounder price output n cdot m that is the maximum possible price ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nint cnt(ll x) {\n    int c = 0;\n    while(x % 10 == 0) {\n        x /= 10, ++c;\n    }\n    return c;\n}\n\nvoid solve(){\n    ll n, m;\n    cin >> n >> m;\n    ll sN = n;\n    int c1 = 0, c2 = 0;\n    while(n % 2 == 0) {\n        n /= 2;\n        c1++;\n    }\n    while(n % 5 == 0) {\n        n /= 5;\n        c2++;\n    }\n\n    ll d = 1;\n    while(c1 < c2 and d * 2 <= m) d *= 2, c1++;\n    while(c2 < c1 and d * 5 <= m) d *= 5, c2++;\n    while(d * 10 <= m) d *= 10;\n    ll h = m / d;\n    d *= h;\n    cout << d * sN << endl;\n\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']","['brute force', 'number theory']",1400
https://codeforces.com//contest/577/problem/B,B. Modulo Sum,You are given a sequence of numbers and a number Check if it is possible to choose a non empty subsequence such that the sum of numbers in this subsequence is divisible by ,"['#include<cstdio>\n\nint S[10000];\nint F[10000];\nint P[10000];\n\nint main()\n{\n    int n1, n2, i, j, l, x, y, z;\n    scanf(""%d%d"", &n1, &n2);\n    for (i = 1 ; i <= n1 ; ++i)\n    {\n        scanf(""%d"", &j);\n        j %= n2;\n        F[j]++;\n    }\n    for (i = 0 ; i < n2 ; ++i)\n    {\n        x = 1;\n        while (F[i] > 0)\n        {\n            y = x < F[i] ? x : F[i];\n            F[i]-=y; x*=2;\n            z = (i*y) % n2;\n            for (l = 0 ; l < n2 ; ++l)\n                if (S[l]) P[(l+z)%n2]=1;\n            for (l = 0 ; l < n2 ; ++l)\n                S[l] += P[l], P[l] = 0;\n            S[z] = 1;\n        }\n        if (S[0]) break;\n    }\n    if (S[0]) printf(""YES\\n"");\n    else printf(""NO\\n"");\n}\n']","['combinatorics', 'data structures', 'dp', 'two pointers']",1900
https://codeforces.com//contest/954/problem/E,E. Water Taps,Consider a system of water taps all pouring water into the same container The th water tap can be set to deliver any amount of water from to ml per second this amount may be a real number The water delivered by th tap has temperature If for every you set th tap to deliver exactly ml of water per second then the resulting temperature of water will be if then to avoid division by zero we state that the resulting water temperature is You have to set all the water taps in such a way that the resulting temperature is exactly What is the maximum amount of water you may get per second if its temperature has to be ,"['#include<bits/stdc++.h>\n#define pa pair<int,int>\n#define MN 200000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\ndouble ans=0;\nint n,T,aa[MN+5],tt[MN+5],num1,num2;\npa a[MN+5],b[MN+5];\nlong long big,sml;\nint main()\n{\n\tn=read();T=read();\n\tfor(int i=1;i<=n;++i) aa[i]=read();\n\tfor(int i=1;i<=n;++i) \n\t{\n\t\ttt[i]=read();\n\t\tif(tt[i]==T) ans+=aa[i];\n\t\telse if(tt[i]>T) a[++num1]=make_pair(tt[i],aa[i]),big+=1LL*aa[i]*(tt[i]-T);\n\t\telse if(tt[i]<T) b[++num2]=make_pair(tt[i],aa[i]),sml+=1LL*aa[i]*(T-tt[i]);\n\t}\n\tsort(a+1,a+num1+1);\n\tsort(b+1,b+num2+1,greater<pa>());\n\tif(big>sml)\n\t{\n\t\tfor(int i=1;i<=n;++i) \n\t\t\tswap(a[i],b[i]),\n\t\t\ta[i].first=T*2-a[i].first,\n\t\t\tb[i].first=T*2-b[i].first;\n\t\tswap(big,sml);swap(num1,num2);\n\t}\n\tlong long now=0;\n\tfor(int i=1;i<=num1;++i) ans+=a[i].second;\n\tfor(int i=1;i<=num2;++i)\n\t{\n\t\tnow+=1LL*b[i].second*(T-b[i].first);\n\t\tif(now<big) ans+=b[i].second;\n\t\telse \n\t\t{\n\t\t\tnow-=1LL*b[i].second*(T-b[i].first);\n\t\t\tdouble l=0,r=b[i].second,mid,res=0;\n\t\t\tfor(int tms=1;tms<=60;++tms)\n\t\t\t{\n\t\t\t\tmid=(l+r)/2.0;\n\t\t\t\tif(now+mid*(T-b[i].first)<=big) res=mid,l=mid;\n\t\t\t\telse r=mid;\n\t\t\t}\n\t\t\treturn 0*printf(""%.10lf"",ans+res); \n\t\t}\n\t}\n\tprintf(""%.10lf"",ans);\n\treturn 0;\n}']","['binary search', 'greedy', 'sortings']",2000
https://codeforces.com//contest/1154/problem/C,C. Gourmet Cat,Polycarp has a cat and his cat is a real gourmet Dependent on a day of the week he eats certain type of food on Mondays Thursdays and Sundays he eats on Tuesdays and Saturdays he eats on other days of week he eats Polycarp plans to go on a trip and already packed his backpack His backpack contains a daily rations of b daily rations of c daily rations of Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible Print the maximum number of days the cat can eat in a trip without additional food purchases if Polycarp chooses the day of the week to start his trip optimally ,"[""// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  vector<int> cnt(3);\n  generate_n(cnt.begin(), 3, read);\n  const vector<int> eat = {0, 1, 2, 0, 2, 1, 0};\n  int ans = 0;\n  for (int i = 0; i < 7; ++i) {\n    vector<int> cur = cnt;\n    int days = 0;\n    for (int j = i; j < 7; ++j) {\n      if (!cur[eat[j]]) break;\n      --cur[eat[j]]; ++days;\n    }\n    int week = min(cur[0] / 3, min(cur[1] / 2, cur[2] / 2));\n    cur[0] -= week * 3;\n    cur[1] -= week * 2;\n    cur[2] -= week * 2;\n    days += week * 7;\n    for (int j = 0; j < 7; ++j) {\n      if (!cur[eat[j]]) break;\n      --cur[eat[j]]; ++days;\n    }\n    ans = max(ans, days);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","['implementation', 'math']",1400
https://codeforces.com//contest/1010/problem/E,E. Store,Natasha was already going to fly back to Earth when she remembered that she needs to go to the Martian store to buy Martian souvenirs for her friends It is known that the Martian year lasts x max months month lasts y max days day lasts z max seconds Natasha also knows that this store works according to the following schedule 2 months in a year were selected x l and x r 1 le x l le x r le x max 2 days in a month y l and y r 1 le y l le y r le y max and 2 seconds in a day z l and z r 1 le z l le z r le z max The store works at all such moments month x day y second z when simultaneously x l le x le x r y l le y le y r and z l le z le z r Unfortunately Natasha does not know the numbers x l x r y l y r z l z r One Martian told Natasha I went to this store n m times n times of them it was opened and m times closed He also described his every trip to the store the month day second of the trip and whether the store was open or closed at that moment Natasha can go to the store k times For each of them determine whether the store at the time of the trip is open closed or this information is unknown ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin » t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nstruct SegTree {\n  int shift;\n  vector<int> tree;\n  vector<int> xs;\n  void build() {\n    make_unique(xs);\n    shift = 1;\n    while (shift < xs.size()) {\n      shift *= 2;\n    }\n    tree.assign(2 * shift, 0);\n  }\n  int get_lower_bound(int coord) {\n    return lower_bound(all(xs), coord) - xs.begin();\n  }\n  int get_sum(int l, int r) {\n    l = get_lower_bound(l);\n    r = get_lower_bound(r);\n    l += shift;\n    r += shift;\n    int res = 0;\n    while (l < r) {\n      if (l & 1) {\n        res += tree[l++];\n        continue;\n      }\n      if (r & 1) {\n        res += tree[--r];\n        continue;\n      }\n      l /= 2;\n      r /= 2;\n    }\n    return res;\n  }\n  void update(int x, int val) {\n    int v = get_lower_bound(x);\n    assert(xs[v] == x);\n    v += shift;\n    while (v) {\n      tree[v] += val;\n      v /= 2;\n    }\n  }\n};\n\nstruct LargeTree {\n  int shift;\n  vector<SegTree> trees;\n  LargeTree(int n) {\n    shift = 1;\n    while (shift < n) {\n      shift *= 2;\n    }\n    trees.resize(2 * shift);\n  }\n  void build() {\n    for (int i = 0; i < trees.size(); ++i) {\n      trees[i].build();\n    }\n  }\n  void raw_insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].xs.push_back(y);\n      x /= 2;\n    }\n  }\n  void insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].update(y, 1);\n      x /= 2;\n    }\n  }\n  int count(int lx, int rx, int ly, int ry) {\n    lx += shift;\n    rx += shift;\n    int res = 0;\n    while (lx < rx) {\n      if (lx & 1) {\n        res += trees[lx++].get_sum(ly, ry);\n        continue;\n      }\n      if (rx & 1) {\n        res += trees[--rx].get_sum(ly, ry);\n        continue;\n      }\n      lx /= 2;\n      rx /= 2;\n    }\n    return res;\n  }\n};\n\nconst int C = 100500;\n\nstruct Query {\n  int z;\n  int lx, rx;\n  int ly, ry;\n  int sign;\n  int id;\n};\n\nint pidorand() {\n  return (rand() << 16) | rand();\n}\n\n#ifndef AIM\n#define rand pidorand\n#endif\n\nvoid solve(bool read) {\n  //read = false;\n  LargeTree tree(C);\n  vector<int> borders(3);\n  for (int i = 0; i < 3; ++i) {\n    if (read) {\n      cin >> borders[i];\n    } else {\n      borders[i] = 100000;\n    }\n  }\n  int n, m, k;\n  if (read) {\n    cin >> n >> m >> k;\n  } else {\n    n = 1;\n    m = 100000;\n    k = 100000;\n  }\n  vector<int> mins(3, C), maxes(3, 0);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      int cur;\n      if (read) {\n        cin >> cur;\n      } else {\n        cur = rand() % borders[j] + 1;\n      }\n      relax_min(mins[j], cur);\n      relax_max(maxes[j], cur);\n    }\n  }\n  auto is_into = [&] (const vector<int>& cur) {\n    for (int i = 0; i < 3; ++i) {\n      if (cur[i] < mins[i] || cur[i] > maxes[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  vector<vector<vector<int>>> not_visited(C);\n  for (int i = 0; i < m; ++i) {\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n    }\n    if (is_into(cur)) {\n      cout << ""INCORRECT\\n"";\n      return;\n    }\n    not_visited[cur[2]].push_back({cur[0], cur[1]});\n    tree.raw_insert(cur[0], cur[1]);\n  }\n  tree.build();\n\n  cout << ""CORRECT\\n"";\n\n  vector<int> res(k, 0);\n  vector<bool> is_inside(k, false);\n  vector<vector<Query>> queries(C);\n  for (int i = 0; i < k; ++i) {\n    auto cur_mins = mins;\n    auto cur_maxes = maxes;\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n      relax_min(cur_mins[j], cur[j]);\n      relax_max(cur_maxes[j], cur[j]);\n    }\n    if (is_into(cur)) {\n      is_inside[i] = true;\n      continue;\n    }\n    Query cur_q = {cur_maxes[2], cur_mins[0], cur_maxes[0] + 1, cur_mins[1], cur_maxes[1] + 1, 1, i};\n    queries[cur_q.z].push_back(cur_q);\n    cur_q.z = cur_mins[2] - 1;\n    cur_q.sign = -1;\n    if (cur_q.z >= 0) {\n      queries[cur_q.z].push_back(cur_q);\n    }\n  }\n\n  for (int z = 0; z < C; ++z) {\n    for (auto& vec : not_visited[z]) {\n      tree.insert(vec[0], vec[1]);\n    }\n    for (auto& q : queries[z]) {\n      res[q.id] += q.sign * tree.count(q.lx, q.rx, q.ly, q.ry);\n    }\n  }\n\n  for (int i = 0; i < k; ++i) {\n    if (is_inside[i]) {\n      cout << ""OPEN\\n"";\n      continue;\n    }\n    if (res[i] > 0) {\n      cout << ""CLOSED\\n"";\n      continue;\n    }\n    cout << ""UNKNOWN\\n"";\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",['data structures'],2700
https://codeforces.com//contest/1438/problem/D,D. Powerful Ksenia,Ksenia has an array a consisting of n positive integers a 1 a 2 ldots a n In one operation she can do the following choose three distinct indices i j k and then change all of a i a j a k to a i oplus a j oplus a k simultaneously where oplus denotes the bitwise XOR operation She wants to make all a i equal or to determine that it is impossible to do so She wouldn t ask for your help but please help her ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1e5 + 3;\n\nvector<array<int, 3>> ans;\nint a[N];\n\nvoid solve(int n){\n    for(int i = 1; i <= n - 2; i += 2)\n        ans.push_back({i, i + 1, i + 2});\n    for(int i = n - 4; i >= 1; i -= 2)\n        ans.push_back({i, i + 1, i + 2});\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    for(int i = 0; i < n; ++i)\n        cin >> a[i];\n\n    if(n % 2 == 0){\n        int x = 0;\n        for(int i = 0; i < n; ++i)\n            x ^= a[i];\n        if(x){\n            cout << ""NO\\n"";\n            return 0;\n        }\n            \n        solve(n - 1);\n    }\n    else solve(n);\n\n    cout << ""YES\\n"";\n    cout << ans.size() << ""\\n"";\n    for(int i = 0; i < ans.size(); ++i)\n        cout << ans[i][0] << "" "" << ans[i][1] << "" "" << ans[i][2] << ""\\n"";\n\n    return 0;\n}']","['bitmasks', 'constructive algorithms', 'math']",2200
https://codeforces.com//contest/1438/problem/E,E. Yurii Can Do Everything,Yurii is sure he can do everything Can he solve this task though He has an array a consisting of n positive integers Let s call a subarray a l r if the following conditions are simultaneously satisfied l 1 leq r 1 i e the subarray has length at least 3 a l oplus a r a l 1 a l 2 ldots a r 2 a r 1 where oplus denotes the bitwise XOR operation In other words a subarray is good if the bitwise XOR of the two border elements is equal to the sum of the rest of the elements Yurii wants to calculate the total number of good subarrays What is it equal to An array c is a subarray of an array d if c can be obtained from d by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e5 + 3;\nconst int LOG_N = 30;\n\nint a[N], n;\nll prefix[N];\n\nll get_sum(int l, int r){\n    if(!l) return prefix[r];\n    return prefix[r] - prefix[l - 1];\n}\n\nbool check(int l, int r){\n    //cout << ""check "" << l << "" "" << r << endl; \n    if(r - l + 1 < 3) return false;\n    if(get_sum(l + 1, r - 1) != (a[l] ^ a[r])) return false;\n    return true;\n}\n\nint solve(int l, int r){\n    if(r - l + 1 < 3) return 0;\n    //cout << ""solve "" << l << "" "" << r << endl; \n\n    int mx = 0;\n    for(int i = l; i <= r; ++i)\n        mx = max(mx, a[i]);\n\n    int bit = LOG_N - 1;\n    while(!((mx >> bit) & 1)) bit--;\n\n    vector<int> pos;\n    for(int i = l; i <= r; ++i)\n        if((a[i] >> bit) & 1)\n            pos.push_back(i);\n\n    int ans = 0;\n    for(int i = 0; i < (int)pos.size() - 1; ++i)\n        ans += check(pos[i], pos[i + 1]);\n\n    for(int i = 0; i < (int)pos.size(); ++i){\n        int from;\n        int to;\n\n        if(i) from = pos[i - 1] + 1;\n        else from = l;\n\n        if(i != (int)pos.size() - 1) to = pos[i + 1] - 1;\n        else to = r;\n\n        for(int j = from; j <= to; ++j){\n            if(j == pos[i]) continue;\n            if(j < pos[i]) ans += check(j, pos[i]);\n            else ans += check(pos[i], j);\n        }\n    }\n\n    for(int i = 0; i < (int)pos.size(); ++i){\n        if(i){\n            int to;\n            if(i != (int)pos.size() - 1) to = pos[i + 1] - 1;\n            else to = r;\n\n            for(int j = pos[i] + 1; j <= to; ++j)\n                ans += check(pos[i - 1], j);\n        }\n        if(i != (int)pos.size() - 1){\n            int to;\n            if(i) to = pos[i - 1] + 1;\n            else to = l;\n\n            for(int j = pos[i] - 1; j >= to; --j)\n                ans += check(j, pos[i + 1]);\n        }\n    }\n\n    pos.insert(pos.begin(), l - 1);\n    pos.push_back(r + 1);\n    for(int i = 0; i < (int)pos.size() - 1; ++i)\n        ans += solve(pos[i] + 1, pos[i + 1] - 1);\n\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i)\n        cin >> a[i];\n\n    prefix[0] = a[0];\n    for(int i = 1; i < n; ++i)\n        prefix[i] = prefix[i - 1] + a[i];\n\n    cout << solve(0, n - 1) << ""\\n"";\n}']","['binary search', 'bitmasks', 'brute force', 'constructive algorithms', 'divide and conquer', 'two pointers']",2500
https://codeforces.com//contest/741/problem/C,C. Arpa’s overnight party and Mehrdad’s silent entering,Arpa loves overnight parties In the middle of one of these parties Mehrdad suddenly appeared He saw pairs of friends sitting around a table th pair consisted of a boy sitting on the th chair and his girlfriend sitting on the th chair The chairs were numbered through in clockwise direction There was exactly one person sitting on each chair There were two types of food Kooft and Zahre mar Now Mehrdad wonders was there any way to serve food for the guests such that Each person had exactly one type of food No boy had the same type of food as his girlfriend Among any three guests sitting on consecutive chairs there was two of them who had different type of food Note that chairs and are considered consecutive Find the answer for the Mehrdad question If it was possible find some arrangement of food types that satisfies the conditions ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,u,v,lab[N],vis[N];\nPII f[N];\nVI e[N];\nvoid dfs(int u,int d) {\n\tlab[u]=d; vis[u]=1;\n\tfor (auto v:e[u]) {\n\t\tif (vis[v]) continue;\n\t\tdfs(v,d^1);\n\t}\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\tf[i]=mp(u,v);\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\trep(i,1,n+1) {\n\t\te[2*i-1].pb(2*i);\n\t\te[2*i].pb(2*i-1);\n\t}\n\trep(i,1,2*n+1) if (!vis[i]) dfs(i,0);\n\trep(i,1,n+1) printf(""%d %d\\n"",lab[f[i].fi]+1,lab[f[i].se]+1);\n}']","['constructive algorithms', 'dfs and similar', 'graphs']",2600
https://codeforces.com//contest/822/problem/E,E. Liar,The first semester ended You know after the end of the first semester the holidays begin On holidays Noora decided to return to Vi kopolis As a modest souvenir for Leha she brought a sausage of length from Pavlopolis Everyone knows that any sausage can be represented as a string of lowercase English letters the length of which is equal to the length of the sausage Leha was very pleased with the gift and immediately ate the sausage But then he realized that it was a quite tactless act because the sausage was a souvenir So the hacker immediately went to the butcher shop Unfortunately there was only another sausage of length in the shop However Leha was not upset and bought this sausage After coming home he decided to cut the purchased sausage into several pieces and number the pieces starting from from left to right Then he wants to select several pieces and glue them together so that the obtained sausage is equal to the sausage that Noora gave But the hacker can glue two pieces together only when the number of the left piece is less than the number of the right piece Besides he knows that if he glues more than pieces Noora will notice that he has falsified souvenir sausage and will be very upset Of course Leha doesn t want to upset the girl The hacker asks you to find out whether he is able to cut the sausage he bought and then glue some of the pieces so that Noora doesn t notice anything Formally you are given two strings and The length of the string is the length of the string is It is required to select several pairwise non intersecting substrings from so that their concatenation in the same order as these substrings appear in is equal to the string Denote by the minimal number of substrings to be chosen so that their concatenation is equal to the string If it is impossible to choose such substrings then Leha really wants to know whether it s true that ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n//suffix array with lcp query\nstruct suff_arr {\n\tint n;\n\tvector<int> A,I;\n\tvector<vector<int> > rmq;\n\tstatic inline int lg(int a){return 31-__builtin_clz(a);}\n\n\tvoid kasai(const string& s) {\n\t\trmq = vector<vector<int> >(lg(n)+1,vector<int>(n));\n\t\tint k = 0,j;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(I[i]==n-1) {\n\t\t\t\tk = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(j = A[I[i]+1];i+k<n && j+k<n && s[i+k] == s[j+k]; ++k);\n\t\t\trmq[0][I[i]] = k;\n\t\t\tif(k) --k;\n\t\t}\n\t\tfor(k = 0, j = 1; k+1 < rmq.size(); j<<=1,++k)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\trmq[k+1][i] = (i+j<n)?min(rmq[k][i],rmq[k][i+j]):rmq[k][i];\n\t}\n\n\tsuff_arr(const string& s):n(s.size()),A(s.size()+1) {\n\t\tfor(int i = 0; i < n; ++i) A[i] = s[i]+1;\n\t\tvector<int> T(n),L(n),F(n+1);\n\t\tI = A;\n\t\tfor(int i = 0; i < n; ++i) L[i] = i;\n\t\tA[n] = I[n] = 0;\n\t\tsort(L.begin(),L.end(),[this](int i, int j) {return (A[i]!=A[j])?A[i]<A[j]:A[min(i+1,n)]<A[min(j+1,n)];});\n\t\tfor(int g = 1;;) {\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tI[L[i]] = (i && A[L[i]]==A[L[i-1]] && A[min(L[i]+g,n)]==A[min(L[i-1]+g,n)]) ? I[L[i-1]] : i+1;\n\t\t\tif((g <<= 1) < n) {\n\t\t\t\tfill(F.begin(),F.end(),0);\n\t\t\t\tF[0] = g;\n\t\t\t\tfor(int i = n-1; i >= g; --i) ++F[I[min(i,n)]];\n\t\t\t\tfor(int i = 1; i <= n; ++i) F[i] += F[i-1];\n\t\t\t\tfor(int i = 0; i < n; ++i) T[--F[I[min(i+g,n)]]] = i;\n\t\t\t\tfill(F.begin(),F.end(),0);\n\t\t\t\tfor(int i = 0; i < n; ++i) ++F[I[i]];\n\t\t\t\tfor(int i = 1; i <= n; ++i) F[i] += F[i-1];\n\t\t\t\tfor(int i = n-1; i >= 0; --i) L[--F[I[T[i]]]] = T[i];\n\t\t\t\tswap(A,I);\n\t\t\t} else break;\n\t\t}\n\t\tA.pop_back(), I.pop_back();\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tA[--I[i]] = i;\n\t\tkasai(s); //can be removed if not needed\n\t}\t\n\n\tint lcp(int i, int j) const {\n\t\tif(i == j) return n-i;\n\t\ti=I[i],j=I[j];\n\t\tif(j<i) swap(i,j);\t\n\t\tint l = lg(j-i);\n\t\treturn min(rmq[l][i],rmq[l][j-(1<<l)]);\n\t}\n};\n\nconst int N = 1e5+5;\nint dp[N][33];\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint n,m,x;\n\tstring s,t;\n\tcin >> n >> s >> m >> t >> x;\n\tsuff_arr S(s + ""$"" + t);\n\tfor(int i = 0; i <= n; ++i) {\n\t\tfor(int r = 0; r <= x; ++r) {\n\t\t\tif(dp[i][r] == m) {\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[i+1][r] = max(dp[i+1][r],dp[i][r]);\n\t\t\tif(dp[i][r] == m || i == n || s[i] != t[dp[i][r]]) continue;\n\t\t\tint lcp = S.lcp(i,n+1+dp[i][r]);\n\t\t\tdp[i+lcp][r+1] = max(dp[i+lcp][r+1],dp[i][r]+lcp);\n\t\t}\n\t}\n\tcout << ""NO\\n"";\n}']","['binary search', 'dp', 'hashing', 'string suffix structures']",2400
https://codeforces.com//contest/1400/problem/B,B. RPG Protagonist,You are playing one RPG from the 2010s You are planning to raise your smithing skill so you need as many resources as possible So how to get resources By stealing of course You decided to rob a town s blacksmith and you take a follower with you You can carry at most p units and your follower at most f units In the blacksmith shop you found cnt s swords and cnt w war axes Each sword weights s units and each war axe w units You don t care what to take since each of them will melt into one steel ingot What is the maximum number of weapons both swords and war axes you and your follower can carry out from the shop ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << \'{\'; string sep; for (const auto &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << \'{\'; string sep; for (const auto &x : arr) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nint64_t can_take(int64_t S, int64_t W, int64_t CS, int64_t CW, int64_t P) {\n    if (S > W)\n        return can_take(W, S, CW, CS, P);\n\n    if (S * CS >= P)\n        return P / S;\n\n    return CS + min((P - S * CS) / W, CW);\n}\n\nvoid run_case() {\n    int64_t P, F, CS, CW, S, W;\n    cin >> P >> F >> CS >> CW >> S >> W;\n    int64_t best = 0;\n\n    for (int64_t cs = 0; cs <= CS; cs++)\n        if (cs * S <= P) {\n            int64_t cw = min((P - cs * S) / W, CW);\n            best = max(best, cs + cw + can_take(S, W, CS - cs, CW - cw, F));\n        }\n\n    cout << best << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","['brute force', 'greedy', 'math']",1700
https://codeforces.com//contest/618/problem/E,E. Robot Arm,Roger is a robot He has an arm that is a series of segments connected to each other The endpoints of the th segment are initially located at points and The endpoint at is colored red and the endpoint at is colored blue for all segments Thus the blue endpoint of the th segment is touching the red endpoint of the th segment for all valid Roger can move his arm in two different ways He can choose some segment and some value This is denoted as choosing the segment number and picking some positive This change happens as follows the red endpoint of segment number and segments from to are all fixed in place Imagine a ray from the red endpoint to the blue endpoint The blue endpoint and segments through are translated units in the direction of this ray In this picture the red point labeled and segments before stay in place while the blue point labeled and segments after gets translated He can choose a segment and rotate it This is denoted as choosing the segment number and an angle The red endpoint of the th segment will stay fixed in place The blue endpoint of that segment and segments to will rotate clockwise by an angle of degrees around the red endpoint In this picture the red point labeled and segments before stay in place while the blue point labeled and segments after get rotated around point Roger will move his arm times These transformations are a bit complicated and Roger easily loses track of where the blue endpoint of the last segment is Help him compute the coordinates of the blue endpoint of the last segment after applying each operation Note that these operations are cumulative and Roger s arm may intersect itself arbitrarily during the moves ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 4 * atan(1);\nconst int N = 1 << 19;\nint n;\nint q;\n\nstruct Matrix\n{\n\tdouble a[3][3];\n\n\tMatrix()\n\t{\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\ta[i][j] = (int)(i == j);\n\t}\n\n\tMatrix operator * (const Matrix &A) const\n\t{\n\t\tMatrix R = Matrix();\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tR.a[i][j] = 0;\n\t\t\t\tfor (int h = 0; h < 3; h++)\n\t\t\t\t\tR.a[i][j] += a[i][h] * A.a[h][j];\n\t\t\t}\n\t\treturn R;\n\t}\n};\n\nMatrix getShift(double dx, double dy)\n{\n\tMatrix R = Matrix();\n\tR.a[0][0] = R.a[1][1] = R.a[2][2] = 1;\n\tR.a[2][0] = dx;\n\tR.a[2][1] = dy;\n\treturn R;\n}\nMatrix getRotate(double x, double y, double ang)\n{\n\tMatrix R = Matrix();\n\tR.a[2][0] = R.a[2][1] = R.a[0][2] = R.a[1][2] = 0;\n\tR.a[2][2] = 1;\n\tR.a[0][0] = cos(ang);\n\tR.a[1][0] = -sin(ang);\n\tR.a[0][1] = sin(ang);\n\tR.a[1][1] = cos(ang);\n\treturn getShift(-x, -y) * R * getShift(x, y);\n}\n\nstruct Node\n{\n\tint l, r;\n\tMatrix A;\n\n\tNode () : l(), r(), A() {}\n\tNode(int _l, int _r) : l(_l), r(_r) {}\n};\n\nNode tree[2 * N];\n\nvoid buildTree()\n{\n\tfor (int i = 0; i < N; i++)\n\t\ttree[N + i] = Node(i, i + 1);\n\tfor (int i = N - 1; i > 0; i--)\n\t\ttree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n\treturn;\n}\n\nvoid push(int v)\n{\n\tif (v >= N) throw;\n\tfor (int i = 0; i < 2; i++)\n\t\ttree[2 * v + i].A = tree[2 * v + i].A * tree[v].A;\n\ttree[v].A = Matrix();\n\treturn;\n}\n\nvoid apply(int v, int l, int r, Matrix A)\n{\n\tif (l <= tree[v].l && tree[v].r <= r)\n\t{\n\t\ttree[v].A = tree[v].A * A;\n\t\treturn;\n\t}\n\tif (l >= tree[v].r || tree[v].l >= r) return;\n\tpush(v);\n\tfor (int i = 0; i < 2; i++)\n\t\tapply(2 * v + i, l, r, A);\n\treturn;\n}\n\nMatrix getVal(int p)\n{\n\tint v = 1;\n\twhile(v < N)\n\t{\n\t\tpush(v);\n\t\tv *= 2;\n\t\tif (p >= tree[v].r) v++;\n\t}\n\treturn tree[v].A;\n}\n\nvoid query1(int p, double L)\n{\n\tMatrix A = getVal(p);\n\tMatrix B = getVal(p + 1);\n\tdouble x = B.a[0][0] - A.a[0][0], y = B.a[0][1] - A.a[0][1];\n\tL /= sqrt(x * x + y * y);\n\tx *= L;\n\ty *= L;\n\tapply(1, p + 1, n + 1, getShift(x, y));\n\treturn;\n}\nvoid query2(int p, double ang)\n{\n\tMatrix A = getVal(p);\n\tapply(1, p + 1, n + 1, getRotate(A.a[0][0], A.a[0][1], ang));\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &q);\n\tbuildTree();\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\ttree[N + i].A.a[x][y] = 0;\n\t\ttree[N + i].A.a[0][0] = i;\n\t\ttree[N + i].A.a[0][2] = 1;\n\t}\n\twhile(q--)\n\t{\n\t\tint t, pos;\n\t\tscanf(""%d%d"", &t, &pos);\n\t\tif (t == 1)\n\t\t{\n\t\t\tdouble len;\n\t\t\tscanf(""%lf"", &len);\n\t\t\tquery1(pos - 1, len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble ang;\n\t\t\tscanf(""%lf"", &ang);\n\t\t\tang = (360. - ang) / 180. * PI;\n\t\t\tquery2(pos - 1, ang);\n\t\t}\n\t\tMatrix R = getVal(n);\n\t\tprintf(""%.10lf %.10lf\\n"", R.a[0][0], R.a[0][1]);\n\t}\n\n\treturn 0;\n}']","['data structures', 'geometry']",2500
https://codeforces.com//contest/600/problem/F,F. Edge coloring of bipartite graph,You are given an undirected bipartite graph without multiple edges You should paint the edges of graph to minimal number of colours so that no two adjacent edges have the same colour ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define MP make_pair\n#define A first\n#define B second\n\nint n = 1000,m;\nint ans = 0;\nint deg[2][1013];\npair<int,int> has[2][1013][1013];\nint color[100013];\n\nint c[2];\nvoid dfs(int x, int p) {\n\tauto i = has[p][x][c[!p]];\n\tif (has[!p][i.A][c[p]].B) dfs(i.A,!p);\n\telse has[!p][i.A][c[!p]] = MP(0,0);\n\thas[p][x][c[p]] = i;\n\thas[!p][i.A][c[p]] = MP(x,i.B);\n\tcolor[i.B] = c[p];\n}\n\nint main() {\n\tscanf(""%*d%*d%d"",&m);\n\tfor (int i=1;i<=m;i++) {\n\t\tint x[2];\n\t\tscanf(""%d%d"",&x[0],&x[1]);\n\t\tfor (int d=0;d<2;d++) {\n\t\t\tdeg[d][x[d]]+=1;\n\t\t\tans = max(ans,deg[d][x[d]]);\n\t\t\tfor (c[d]=1;has[d][x[d]][c[d]].B;c[d]++);\n\t\t}\n\t\tif (c[0]!=c[1]) dfs(x[1],1);\n\t\tfor (int d=0;d<2;d++) has[d][x[d]][c[0]] = MP(x[!d],i);\n\t\tcolor[i] = c[0];\n\t}\n\tprintf(""%d\\n"",ans);\n\tfor (int i=1;i<=m;i++) printf(""%d "",color[i]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}']",['graphs'],2800
https://codeforces.com//contest/794/problem/C,C. Naming Company,Oleg the client and Igor the analyst are good friends However sometimes they argue over little things Recently they started a new company but they are having trouble finding a name for the company To settle this problem they ve decided to play a game The company name will consist of letters Oleg and Igor each have a set of letters which might contain multiple copies of the same letter the sets can be different Initially the company name is denoted by question marks Oleg and Igor takes turns to play the game Oleg moves first In each turn a player can choose one of the letters in his set and replace any of the question marks with Then a copy of the letter is removed from his set The game ends when all the question marks has been replaced by some letter For example suppose Oleg has the set of letters and Igor has the set of letters One possible game is as follows Initially the company name is Oleg replaces the second question mark with The company name becomes The set of letters Oleg have now is Igor replaces the third question mark with The company name becomes The set of letters Igor have now is Finally Oleg replaces the first question mark with The company name becomes The set of letters Oleg have now is In the end the company name is Oleg wants the company name to be as lexicographically small as possible while Igor wants the company name to be as lexicographically large as possible What will be the company name if Oleg and Igor always play optimally A string is called lexicographically smaller than a string where if where is the smallest index such that so for all ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\n\nint n;\nstring s;\n\nvoid parse(int* arr) {\n\tcin >> s;\n\tfor (int i = 0; i < 26; i++) arr[i] = 0;\n\tn = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tarr[s[i] - \'a\']++;\n}\n\nint a[26];\nint b[26];\n\nint pa, pb;\n\nvoid calc() {\n\tpa = 0;\n\twhile (a[pa] == 0) pa++;\n\tpb = 25;\n\twhile (b[pb] == 0) pb--;\n}\n\nstring ans;\n\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\t\n\tparse(a);\n\tparse(b);\n\tans.resize(n);\n\tint pl = 0, pr = n - 1;\n\tfor (int iter = 1; iter <= n; iter++) {\n\t\tcalc();\n\t\tif (pa < pb) {\n\t\t\tif (iter & 1) {\n\t\t\t\ta[pa]--;\n\t\t\t\tans[pl++] = \'a\' + pa;\n\t\t\t} else {\n\t\t\t\tb[pb]--;\n\t\t\t\tans[pl++] = \'a\' + pb;\n\t\t\t}\n\t\t} else {\n\t\t\tint sa = pr;\n\t\t\twhile (sa - 2 >= pl) sa -= 2;\n\t\t\tint sb = pr + 1;\n\t\t\twhile (sb - 2 >= pl) sb -= 2;\n\t\t\tif (iter & 1) {\n\t\t\t\tfor (int i = sa; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = \'a\' + pa;\n\t\t\t\t\ta[pa]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = sb; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = \'a\' + pb;\n\t\t\t\t\tb[pb]--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = sa; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = \'a\' + pb;\n\t\t\t\t\tb[pb]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = sb; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = \'a\' + pa;\n\t\t\t\t\ta[pa]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']","['games', 'greedy', 'sortings']",1800
https://codeforces.com//contest/1648/problem/D,D. Serious Business,Dima is taking part in a show organized by his friend Peter In this show Dima is required to cross a 3 times n rectangular field Rows are numbered from 1 to 3 and columns are numbered from 1 to n The cell in the intersection of the i th row and the j th column of the field contains an integer a i j Initially Dima s score equals zero and whenever Dima reaches a cell in the row i and the column j his score changes by a i j Note that the score can become negative Initially all cells in the first and the third row are marked as available and all cells in the second row are marked as unavailable However Peter offered Dima some help there are q special offers in the show the i th special offer allows Dima to mark cells in the second row between l i and r i as available though Dima s score reduces by k i whenever he accepts a special offer Dima is allowed to use as many special offers as he wants and might mark the same cell as available multiple times Dima starts his journey in the cell 1 1 and would like to reach the cell 3 n He can move either down to the next row or right to the next column meaning he could increase the current row or column by 1 thus making n 1 moves in total out of which exactly n 1 would be horizontal and 2 would be vertical Peter promised Dima to pay him based on his final score so the sum of all numbers of all visited cells minus the cost of all special offers used Please help Dima to maximize his final score ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class Info,\n    class Merge = std::plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}\n    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n};\n\nstruct Max {\n    i64 x;\n    Max(i64 x = -1E18) : x(x) {};\n};\n\nMax operator+(const Max &a, const Max &b) {\n    return std::max(a.x, b.x);\n}\n\nstruct Pair {\n    i64 ans;\n    i64 a;\n    i64 b;\n    Pair() : ans(-1E18), a(-1E18), b(-1E18) {}\n    Pair(i64 a, i64 b) : ans(a + b), a(a), b(b) {}\n};\n\nPair operator+(const Pair &a, const Pair &b) {\n    Pair c;\n    c.ans = std::max({a.ans, b.ans, a.a + b.b});\n    c.a = std::max(a.a, b.a);\n    c.b = std::max(a.b, b.b);\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector c(3, std::vector<int>(n));\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < n; j++) {\n            std::cin >> c[i][j];\n        }\n    }\n    \n    std::vector<i64> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        a[i] += c[0][i];\n        if (i > 0) {\n            a[i] += a[i - 1];\n            a[i] -= c[1][i - 1];\n        }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        b[i] += c[2][i];\n        if (i < n - 1) {\n            b[i] += b[i + 1];\n            b[i] -= c[1][i + 1];\n        }\n    }\n    \n    i64 ans = -1E18;\n    \n    SegmentTree<Max> seg(n);\n    for (int i = 0; i < n; i++) {\n        seg.modify(i, a[i]);\n    }\n    \n    std::vector<std::array<int, 3>> ranges(q);\n    for (int i = 0; i < q; i++) {\n        int l, r, k;\n        std::cin >> l >> r >> k;\n        l--;\n        ranges[i] = {l, r, k};\n    }\n    std::sort(ranges.begin(), ranges.end());\n    \n    for (auto [l, r, k] : ranges) {\n        auto v = seg.rangeQuery(l, r).x;\n        if (r < n) {\n            a[r] = std::max(a[r], v - k);\n            seg.modify(r, a[r]);\n        }\n    }\n    \n    SegmentTree<Pair> seg2(n);\n    for (int i = 0; i < n; i++) {\n        seg2.modify(i, Pair(a[i], b[i]));\n    }\n    \n    for (auto [l, r, k] : ranges) {\n        ans = std::max(ans, seg2.rangeQuery(l, r).ans - k);\n    }\n    \n    ans += std::accumulate(c[1].begin(), c[1].end(), 0LL);\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['data structures', 'divide and conquer', 'dp', 'implementation', 'shortest paths']",2800
https://codeforces.com//contest/1096/problem/A,A. Find Divisible,You are given a range of positive integers from l to r Find such a pair of integers x y that l le x y le r x ne y and x divides y If there are multiple answers print any of them You are also asked to answer T independent queries ,"['#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint T,l,r;\nint main()\n{\n    scanf(""%d"",&T);\n    while(T--)\n    {\n        scanf(""%d%d"",&l,&r);\n        if(l*2>r) puts(""-1""); else printf(""%d %d\\n"",l,l*2);\n    }\n    return 0;\n}\n\n']","['greedy', 'implementation', 'math']",800
https://codeforces.com//contest/498/problem/B,B. Name That Tune,It turns out that you are a great fan of rock band AC PE Peter learned that and started the following game he plays the first song of the list of songs of the group and you have to find out the name of the song After you tell the song name Peter immediately plays the following song in order and so on The th song of AC PE has its recognizability This means that if the song has not yet been recognized by you you listen to it for exactly one more second and with probability of percent you recognize it and tell it s name Otherwise you continue listening it Note that you can only try to guess it only when it is integer number of seconds after the moment the song starts playing In all AC PE songs the first words of chorus are the same as the title so when you ve heard the first seconds of th song and its chorus starts you immediately guess its name for sure For example in the song Highway To Red the chorus sounds pretty late but the song has high recognizability In the song Back In Blue on the other hand the words from the title sound close to the beginning of the song but it s hard to name it before hearing those words You can name both of these songs during a few more first seconds Determine the expected number songs of you will recognize if the game lasts for exactly seconds i e you can make the last guess on the second after that the game stops ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n\n  int n, maxt;\n  while (scanf(""%d%d"", &n, &maxt) == 2) {\n    vector<ld> ps(n);\n    vi ts(n);\n    forn (i, n) {\n      int p;\n      scanf(""%d%d"", &p, &ts[i]);\n      ps[i] = p / 100.0;\n    }\n\n    vector<ld> cdyn(maxt + 1, 0);\n    cdyn[maxt] = 1;\n\n    vector<ld> ndyn(maxt + 1, 0);\n    vector<ld> toadd(maxt + 2, 0);\n\n    ld ans = 0;\n    forn (id, n) {\n      fill(ndyn.begin(), ndyn.end(), 0);\n      fill(toadd.begin(), toadd.end(), 0);\n\n/*      ld toCur = 1;\n      for (int was = 1; was < ts[id]; was++) {\n        ld cprob = toCur * ps[id];\n\n        for (int olt = was; olt <= maxt; olt++) {\n          ndyn[olt - was] += cprob * cdyn[olt];\n        }\n\n        toCur *= 1 - ps[id];\n      }*/\n      ld toCur = 1;\n      for (int was = 1; was < ts[id]; was++) toCur *= 1 - ps[id];\n      for (int olt = 1; olt <= maxt; olt++) {\n        toadd[olt - 1] += ps[id] * cdyn[olt];\n        if (olt >= ts[id]) {\n          toadd[olt - ts[id]] -= toCur * ps[id] * cdyn[olt];\n        }\n      }\n      \n      for (int i = maxt; i >= 0; i--) {\n        ndyn[i] = toadd[i];\n        if (i < maxt) ndyn[i] += ndyn[i + 1] * (1 - ps[id]);\n      }\n      for (int olt = ts[id]; olt <= maxt; olt++) {\n        ndyn[olt - ts[id]] += toCur * cdyn[olt];\n      }\n\n      {\n        ld csum = 0;\n        for (ld x : ndyn) csum += x;\n        ans += csum;\n      }\n      cdyn.swap(ndyn);\n    }\n    printf(""%.18f\\n"", (double)ans);\n  }\n\n  return 0;\n}\n']","['dp', 'probabilities', 'two pointers']",2400
https://codeforces.com//contest/1909/problem/C,C. Heavy Intervals,You have n intervals l 1 r 1 l 2 r 2 dots l n r n such that l i r i for each i and all the endpoints of the intervals are distinct The i th interval has weight c i per unit length Therefore the of the i th interval is c i cdot r i l i You don t like large weights so you want to make the sum of weights of the intervals as small as possible It turns out you can perform all the following three operations rearrange the elements in the array l in any order rearrange the elements in the array r in any order rearrange the elements in the array c in any order However after performing all of the operations the intervals must still be valid i e for each i l i r i must hold What s the minimum possible sum of weights of the intervals after performing the operations ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> qs;\n\trep(i,n){\n\t\tint v;cin>>v;\n\t\tqs.eb(v,1);\n\t}\n\trep(i,n){\n\t\tint v;cin>>v;\n\t\tqs.eb(v,-1);\n\t}\n\tsoin(qs);\n\tvi lens;\n\tvi cur;\n\tfor(auto [v,d]:qs){\n\t\tif(d==1){\n\t\t\tcur.pb(v);\n\t\t}else{\n\t\t\tlens.pb(v-gpp(cur));\n\t\t}\n\t}\n\tsoin(lens);\n\tvi c=readvi(n);\n\tsoin(c,greater<int>());\n\tint ans=0;\n\trep(i,n)ans+=lens[i]*c[i];\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['constructive algorithms', 'data structures', 'dsu', 'greedy', 'math', 'sortings']",1400
https://codeforces.com//contest/788/problem/D,D. Finding lines,After some programming contest Roma decided to try himself in tourism His home country Uzhlyandia is a Cartesian plane He wants to walk along each of the Main Straight Lines in Uzhlyandia It is known that each of these lines is a straight line parallel to one of the axes i e it is described with the equation or where is integer called the coordinate of this line Roma lost his own map so he should find out the coordinates of all lines at first Uncle Anton agreed to help him using the following rules Initially Roma doesn t know the number of vertical and horizontal lines and their coordinates Roma can announce integer coordinates of some point in Uzhlandia and Anton then will tell him the minimum among the distances from the chosen point to each of the lines However since the coordinates of the lines don t exceed by absolute value Roma can t choose a point with coordinates exceeding by absolute value Uncle Anton is in a hurry to the UOI Uzhlandian Olympiad in Informatics so he can only answer no more than questions The problem is that Roma doesn t know how to find out the coordinates of the lines Write a program that plays Roma s role and finds the coordinates ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxc = (int) 1e8;\n\nint rot;\nint check(int x, int y) {\n  if (rot) {\n    swap(x, y);\n  }\n  assert(abs(x) <= maxc && abs(y) <= maxc);\n  printf(""0 %d %d\\n"", x, y);\n  fflush(stdout);\n  int res;\n  assert(scanf(""%d"", &res) == 1);\n  assert(res >= 0);\n  return res;\n}\n\nset<int> xs, ys;\n\nset<pair<int, int> > deltay;\n\nconst int K = 9995;\n\nvoid update0(int x, int y) {\n  assert(!xs.count(x));\n  assert(!ys.count(y));\n\n  for (int iter = 0; iter < 3; ++iter) {\n    int cy = rnd(2 * maxc + 1) - maxc;\n    if (check(x, cy)) {\n      auto iter = ys.lower_bound(y);\n      int mx = ((iter == ys.end()) ? maxc : *iter);\n      int mn = -maxc;\n      if (iter != ys.begin()) {\n        --iter;\n        mn = *iter;\n      }\n      deltay.erase(mp(mx - mn, mn));\n      deltay.insert(mp(y - mn, mn));\n      deltay.insert(mp(mx - y, y));\n      ys.insert(y);\n      return;\n    }\n  }\n  xs.insert(x);\n}\n\nvoid update(int x, int y, int got) {\n  assert(got >= 0);\n  if (x - got >= -maxc) {\n    if (check(x - got, y) == 0) {\n      update0(x - got, y);\n      return;\n    }\n  }\n  if (x + got <= maxc) {\n    if (check(x + got, y) == 0) {\n      update0(x + got, y);\n      return;\n    }\n  }\n  if (y - got >= -maxc) {\n    if (check(x, y - got) == 0) {\n      update0(x, y - got);\n      return;\n    }\n  }\n  update0(x, y + got);\n}\n\nvoid solve() {\n  xs.clear(), ys.clear();\n  rot = 0;\n\n  for (int iter = 0; iter < 2; ++iter) {\n    deltay.clear();\n    int lasty = -maxc;\n    for (int y : ys) {\n      deltay.insert(mp(y - lasty, lasty));\n      lasty = y;\n    }\n    deltay.insert(mp(maxc - lasty, lasty));\n\n    int x = -maxc - 1;\n    while (x < maxc) {\n      auto iter = xs.lower_bound(x + 1);\n      if (iter != xs.end() && *iter == x + 1) {\n        ++x;\n        continue;\n      }\n      int delta = K;\n      delta = min(delta, maxc - x);\n      if (iter != xs.end()) {\n        delta = min(delta, (*iter - x) / 2);\n      }\n      assert(delta > 0);\n\n      auto diter = deltay.end();\n      --diter;\n      assert(diter->first >= delta * 2);\n      int y1 = diter->second;\n      int y2 = y1 + diter->first;\n\n      int y = (y1 + y2) / 2;\n\n      int got = check(x + delta, y);\n      if (got >= delta) {\n        x += delta + got - 1;\n        continue;\n      }\n\n      update(x + delta, y, got);\n    }\n\n    swap(xs, ys);\n    rot ^= 1;\n  }\n\n  printf(""1 %d %d\\n"", sz(xs), sz(ys));\n  {\n    bool was = 0;\n    for (int x : xs) {\n      if (was) {\n        printf("" "");\n      }\n      printf(""%d"", x);\n      was = 1;\n    }\n    printf(""\\n"");\n  }\n  {\n    bool was = 0;\n    for (int x : ys) {\n      if (was) {\n        printf("" "");\n      }\n      printf(""%d"", x);\n      was = 1;\n    }\n    printf(""\\n"");\n  }\n}\n\nint main() {\n  precalc();\n\n  solve();\n  return 0;\n}\n']","['constructive algorithms', 'divide and conquer', 'interactive']",3000
https://codeforces.com//contest/1848/problem/D,D. Vika and Bonuses,A new bonus system has been introduced at Vika s favorite cosmetics store Golden Pear The system works as follows suppose a customer has b bonuses Before paying for the purchase the customer can choose one of two options Get a discount equal to the current number of bonuses while the bonuses are not deducted Accumulate an additional x bonuses where x is the last digit of the number b As a result the customer s account will have b x bonuses For example if a customer had 24 bonuses he can either get a discount of 24 or accumulate an additional 4 bonuses after which his account will have 28 bonuses At the moment Vika has already accumulated s bonuses The girl knows that during the remaining time of the bonus system she will make k more purchases at the Golden Pear store network After familiarizing herself with the rules of the bonus system Vika became interested in the maximum total discount she can get Help the girl answer this question ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int mod = 998244353, N = 100005;\n\nll solve(ll a, ll b, ll c, ll d, ll k) {\n    auto f = [&](ll x) {return (a + b * x) * (c - d * x);};\n    ll res = max(f(0), f(k));\n    if (b * c - a * d < 0) return res;\n    ll pos1 = (b * c - a * d) / (2 * b * d);\n    if (pos1 >= 0 && pos1 <= k) res = max(res, f(pos1));\n    pos1++;\n    if (pos1 >= 0 && pos1 <= k) res = max(res, f(pos1));\n    return res;\n}\n \nvoid frank() {\n    int s, k; cin >> s >> k;\n    ll res = 1ll * s * k;\n    if (k == 0) {\n        cout << res << ""\\n"";\n        return;\n    }\n    s += s % 10, k--;\n    int de = 0; ll ss = s;\n    for (int i = 0; i < 4; ++i) ss += ss % 10;\n    de = ss - s;\n    if (de == 0) {\n        res = max(res, 1ll * s * k);\n        cout << res << ""\\n"";\n        return;\n    }\n    for (int i = 0; i < 4 && k >= 0; ++i) {\n        res = max(res, solve(s, de, k, 4, k / 4));\n        s += s % 10, k--;\n    }\n    cout << res << ""\\n"";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        frank();\n    }\n}']","['binary search', 'brute force', 'math', 'ternary search']",2200
https://codeforces.com//contest/1239/problem/B,B. The World Is Just a Programming Task  Hard Version ,This is a harder version of the problem In this version n le 300 000 Vasya is an experienced developer of programming competitions problems As all great minds at some time Vasya faced a creative crisis To improve the situation Petya gifted him a string consisting of opening and closing brackets only Petya believes that the beauty of the bracket string is a number of its cyclical shifts which form a correct bracket sequence To digress from his problems Vasya decided to select two positions of the string and swap characters located at this positions with each other Vasya will apply this operation exactly once He is curious what is the maximum possible beauty he can achieve this way Please help him We remind that bracket sequence s is called correct if s is empty s is equal to t where t is correct bracket sequence s is equal to t 1 t 2 i e concatenation of t 1 and t 2 where t 1 and t 2 are correct bracket sequences For example are correct while and are not The cyclical shift of the string s of length n by k 0 leq k n is a string formed by a concatenation of the last k symbols of the string s with the first n k symbols of string s For example the cyclical shift of string by 2 equals Cyclical shifts i and j are considered different if i ne j ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n, mini;\nint mcnt, ans, ta=1, tb=1;\nchar str[300100];\nint sum[600100];\n\nvoid solve(int s, int e) {\n    int cnt1 = 0;\n    for (int i=s;i<e;i++) {\n        if (sum[i]==mini+1) cnt1++;\n    }\n    if (ans<cnt1) {\n        ta=s;tb=e;\n        ans=cnt1;\n    }\n    int cnt2 = 0, p=s, tcnt = 0;\n    for (int i=s+1;i<e;i++) {\n        if (sum[i]==mini+1) {\n            if (ans<tcnt+mcnt) {\n                ans=tcnt+mcnt;\n                ta=p+1;\n                tb=i;\n            }\n            p=i;\n            tcnt=0;\n        }\n        if (sum[i]==mini+2) tcnt++;\n    }\n}\n\nint main() {\n    scanf(""%d"",&n);\n    scanf(""%s"",str+1);\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(str[i]==\'(\'?1:-1);\n    if (sum[n]) {\n        puts(""0"");\n        puts(""1 1"");\n        return 0;\n    }\n    for (int i=1;i<=n;i++) mini = min(mini,sum[i]);\n    for (int i=n+1;i<=2*n;i++) sum[i]=sum[i-n];\n    for (int i=1;i<=n;i++) {\n        if (sum[i]==mini)mcnt++;\n    }\n    if (ans<mcnt) {\n        ans=mcnt;\n    }\n    int ploc = -1;\n    for (int i=1;i<=n*2;i++) {\n        if (sum[i]==mini) {\n            if (~ploc) {\n                solve(ploc+1,i);\n            }\n            ploc = i;\n        }\n    }\n    printf(""%d\\n"",ans);\n    printf(""%d %d\\n"",(ta>n?ta-n:ta),(tb>n?tb-n:tb));\n\n\treturn 0;\n}\n']",['implementation'],2500
https://codeforces.com//contest/932/problem/A,A. Palindromic Supersequence,You are given a string Find a string where is a palindrome and is a subsequence of A subsequence of a string is a string that can be derived from it by deleting some not necessarily consecutive characters without changing the order of the remaining characters For example is a subsequence of A palindrome is a string that reads the same forward or backward The length of string should be at most It is guaranteed that there always exists such string You do not need to find the shortest answer the only restriction is that the length of string should not exceed ,"['//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tstring p=s;\n\treverse(p.begin(), p.end());\n\tcout << s << p << endl;\n\treturn 0;\n}\n']",['constructive algorithms'],800
https://codeforces.com//contest/708/problem/E,E. Student s Camp,Alex studied well and won the trip to student camp Alushta located on the seashore Unfortunately it s the period of the strong winds now and there is a chance the camp will be destroyed Camp building can be represented as the rectangle of concrete blocks height and blocks width Every day there is a breeze blowing from the sea Each block except for the blocks of the upper and lower levers such that there is no block to the left of it is destroyed with the probability Similarly each night the breeze blows in the direction to the sea Thus each block again except for the blocks of the upper and lower levers such that there is no block to the right of it is destroyed with the same probability Note that blocks of the upper and lower level are so there are only blocks that can be destroyed The period of the strong winds will last for days and nights If during this period the building will split in at least two connected components it will collapse and Alex will have to find another place to spend summer Find the probability that Alex won t have to look for other opportunities and will be able to spend the summer in this camp ,"[""// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\n#define int long long\n\nconst int N = (int) 2e5 + 5, mod = (int) 1e9 + 7, M = 3005;\nint pw(int a, int b) { return b != 0? pw(a * a % mod, b >> 1) * (b & 1? a: 1) % mod: 1; }\nint f[N], invf[N], pickp[N], pickn[N], sd[N], dest[N], lp[M], rp[M], olp[M], orp[M], lps[M];\nint comb(int n, int r) {\n    if (n < 0 || r < 0 || n - r < 0) return 0;\n    return f[n] * invf[r] % mod * invf[n - r] % mod;\n}\nint mul(int x, int y) { return x * y % mod; }\nint add(int x, int y) { return (x + y + 100 * mod) % mod; }\nint sadd(int &x, int y) { return x = add(x, y); }\n\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    f[0] = invf[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * i % mod, invf[i] = pw(f[i], mod - 2);\n    int n, m;\n    cin >> n >> m;\n    int pa, pb;\n    cin >> pa >> pb;\n    for (int i = 0; i < N; ++i)\n        pickp[i] = pw(pa, i) * pw(pw(pb, mod - 2), i) % mod, pickn[i] = pw(pb - pa, i) * pw(pw(pb, mod - 2), i) % mod;\n    int k;\n    cin >> k;\n    for (int j = 0; j < N; ++j) {\n        dest[j] = comb(k, j) * pickp[j] % mod * pickn[k - j] % mod;\n        sadd(sd[j], add(j == 0? 0: sd[j - 1], dest[j]));\n    }\n    lp[0] = 1;\n    rp[m - 1] = 1;\n    for (int d = 0; d < n + 1; ++d) {\n        memcpy(olp, lp, sizeof lp);\n        memcpy(orp, rp, sizeof rp);\n        memset(lp, 0, sizeof lp);\n        memset(lps, 0, sizeof lps);\n        memset(rp, 0, sizeof rp);\n        int sumrp = 0, all = 0, cur_val = 0;\n        for (int j = 0; j < m; ++j)\n            sadd(all, olp[j]);\n        if (d == n) {\n            cout << all;\n            return 0;\n        }\n        for (int j = m - 1; j >= 0; --j)\n            lps[j] = add(lps[j + 1], olp[j]);\n        for (int j = 0; j < m; ++j) {\n            sadd(rp[j], -mul(cur_val, dest[m - j - 1]));\n            sadd(rp[j], -mul(lps[j + 1], mul(sd[j], dest[m - j - 1])));\n            sadd(rp[j], mul(mul(all, sd[j]), dest[m - j - 1]));\n//            cout << j << ' ' << all << ' ' << cnt << ' ' << sd[j] << ' ' << dest[m - j - 1] << ' ' << cur_val << ' ' << lps[j + 1] << endl;\n            sadd(sumrp, orp[j]);\n            sadd(cur_val, mul(sumrp, dest[j + 1]));\n        }\n        for (int j = 0; j < m; ++j) {\n            lp[j] = rp[m - j - 1];\n        }\n    }\n\n\n\n\n\n}\n\n\n\n\n\n\n\n""]","['dp', 'math']",3100
https://codeforces.com//contest/1874/problem/A,A. Jellyfish and Game,Jellyfish has n green apples with values a 1 a 2 dots a n and Gellyfish has m green apples with values b 1 b 2 ldots b m They will play a game with k rounds For i 1 2 ldots k in this order they will perform the following actions If i is odd Jellyfish can choose to swap one of her apples with one of Gellyfish s apples or do nothing If i is even Gellyfish can choose to swap one of his apples with one of Jellyfish s apples or do nothing Both players want to maximize the sum of the values of their apples Since you are one of the smartest people in the world Jellyfish wants you to tell her the final sum of the value of her apples after all k rounds of the game Assume that both Jellyfish and Gellyfish play optimally to maximize the sum of values of their apples ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint n, m, k, a[N], b[N];\nvoid Main() {\n\tcin >> n >> m >> k;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tL(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tk -= max(k - 10, 0) / 2 * 2;\n\tint op = 0;\n\twhile(k--) {\n\t\tsort(a + 1, a + n + 1);\n\t\tsort(b + 1, b + m + 1);\n\t\tif(!op) {\n\t\t\tif(a[1] < b[m])\n\t\t\t\tswap(a[1], b[m]);\n\t\t} else {\n\t\t\tif(b[1] < a[n])\n\t\t\t\tswap(b[1], a[n]);\n\t\t}\n\t\top ^= 1;\n\t} \n\tcout << accumulate(a + 1, a + n + 1, 0LL) << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]","['brute force', 'games', 'greedy', 'implementation']",1200
https://codeforces.com//contest/1761/problem/D,D. Carry Bit,Let f x y be the number of of x y in binary i e f x y g x g y g x y where g x is the number of ones in the binary representation of x Given two integers n and k find the number of ordered pairs a b such that 0 leq a b 2 n and f a b equals k Note that for a ne b a b and b a are considered as two different pairs As this number may be large output it modulo 10 9 7 ,"['/**\n *    author:  tourist\n *    created: 20.11.2022 18:39:36       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  Mint ans = 0;\n  for (int vf = 0; vf <= 1; vf++) {\n    for (int p = 1; p <= n; p++) {\n      int k0 = p / 2;\n      int k1 = p / 2;\n      if (p % 2 == 1) {\n        k0 += (vf == 0);\n        k1 += (vf == 1);\n      }\n      int vb = (p % 2 == 1 ? vf : 1 - vf);\n      if (k >= k1 && n - k >= k0) {\n        if (k > 0 && k1 == 0) {\n          continue;\n        }\n        if (n - k > 0 && k0 == 0) {\n          continue;\n        }\n        Mint ways = (k1 == 0 ? 1 : C((k - k1) + (k1 - 1), k1 - 1));\n        ways *= (k0 == 0 ? 1 : C((n - k - k0) + (k0 - 1), k0 - 1));\n        ways *= power(Mint(3), n - p + (vf == 0));\n        ans += ways;\n      }\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","['combinatorics', 'math']",2100
https://codeforces.com//contest/613/problem/A,A. Peter and Snow Blower,Peter got a new snow blower as a New Year present Of course Peter decided to try it immediately After reading the instructions he realized that it does not work like regular snow blowing machines In order to make it work you need to tie it to some point that it does not cover and then switch it on As a result it will go along a circle around this point and will remove all the snow from its path Formally we assume that Peter s machine is a polygon on a plane Then after the machine is switched on it will make a circle around the point to which Peter tied it this point lies strictly outside the polygon That is each of the points lying within or on the border of the polygon will move along the circular trajectory with the center of the circle at the point to which Peter tied his machine Peter decided to tie his car to point and now he is wondering what is the area of the region that will be cleared from snow Help him ,"['#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point (double x = 0, double y = 0) : x(x), y(y) {}\n\n    void in() {\n        scanf(""%lf%lf"", &x, &y);\n    }\n\n    Point operator - (const Point &b) const {\n        return Point(x - b.x, y - b.y);\n    }\n\n    double dis() const {\n        return sqrt(x * x + y * y);\n    }\n};\n\nint sign(const double &x, const double EPS = 1e-9) {\n    return x < -EPS ? -1 : x > EPS;\n}\n\ndouble dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble det(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nconst int N = 100005;\n\nint n;\n\nPoint o, p[N];\n\nconst double PI = acos(-1);\n\nint main() {\n    scanf(""%d"", &n);\n    o.in();\n    double mins = 1e100, maxs = 0;\n    for (int i = 0; i < n; ++i) {\n        p[i].in();\n    }\n    p[n] = p[0];\n    for (int i = 0; i < n; ++i) {\n        maxs = max(maxs, (p[i] - o).dis());\n        mins = min(mins, (p[i] - o).dis());\n        if (sign(dot(o - p[i], p[i + 1] - p[i])) >= 0 && sign(dot(o - p[i + 1], p[i] - p[i + 1])) >= 0) {\n            mins = min(mins, fabs(det(p[i + 1] - p[i], o - p[i]) / (p[i] - p[i + 1]).dis()));\n        }\n    }\n    printf(""%.12f\\n"", PI * (maxs * maxs - mins * mins));\n    return 0;\n}']","['binary search', 'geometry', 'ternary search']",1900
https://codeforces.com//contest/350/problem/C,C. Bombs,You ve got a robot its task is destroying bombs on a square plane Specifically the square plane contains bombs the th bomb is at point with coordinates We know that no two bombs are at the same point and that no bomb is at point with coordinates Initially the robot is at point with coordinates Also let s mark the robot s current position as In order to destroy all the bombs the robot can perform three types of operations Operation has format To perform the operation robot have to move in direction times There are only directions the robot can move in R L U D During one move the robot can move from the current point to one of following points corresponding to directions It is forbidden to move from point if at least one point on the path besides the destination point contains a bomb Operation has format To perform the operation robot have to pick a bomb at point and put it in a special container Thus the robot can carry the bomb from any point to any other point The operation cannot be performed if point has no bomb It is forbidden to pick a bomb if the robot already has a bomb in its container Operation has format To perform the operation robot have to take a bomb out of the container and destroy it You are allowed to perform this operation only if the robot is at point It is forbidden to perform the operation if the container has no bomb Help the robot and find the shortest possible sequence of operations he can perform to destroy all bombs on the coordinate plane ,"['#include <cstdio>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\nconst int NMax=100000;\nint N;\npair<int,int> A[NMax];\nbool comp(pair<int,int> a,pair<int,int> b){\n    return abs(a.first)+abs(a.second)<abs(b.first)+abs(b.second);\n}\nint main()\n{\n    scanf(""%d"",&N);\n    for (int i=0;i<N;i++)\n        scanf(""%d%d"",&(A[i].first),&(A[i].second));\n    sort(A,A+N,comp);\n    int c=0;\n    for (int i=0;i<N;i++){\n        if (A[i].first==0 || A[i].second==0)\n            c+=4;\n        else\n            c+=6;\n    }\n    printf(""%d\\n"",c);\n    for (int i=0;i<N;i++){\n        if (A[i].first>0)\n            printf(""1 %d R\\n"",A[i].first);\n        if (A[i].first<0)\n            printf(""1 %d L\\n"",-A[i].first);\n        if (A[i].second>0)\n            printf(""1 %d U\\n"",A[i].second);\n        if (A[i].second<0)\n            printf(""1 %d D\\n"",-A[i].second);\n        printf(""2\\n"");\n        if (A[i].first>0)\n            printf(""1 %d L\\n"",A[i].first);\n        if (A[i].first<0)\n            printf(""1 %d R\\n"",-A[i].first);\n        if (A[i].second>0)\n            printf(""1 %d D\\n"",A[i].second);\n        if (A[i].second<0)\n            printf(""1 %d U\\n"",-A[i].second);\n        printf(""3\\n"");\n    }\n    return 0;\n}\n']","['greedy', 'implementation', 'sortings']",1600
https://codeforces.com//contest/1580/problem/D,D. Subsequence,Alice has an integer sequence a of length n and She will choose a subsequence of a of length m and defines the value of a subsequence a b 1 a b 2 ldots a b m as sum i 1 m m cdot a b i sum i 1 m sum j 1 m f min b i b j max b i b j where f i j denotes min a i a i 1 ldots a j Alice wants you to help her to maximize the value of the subsequence she choose A sequence s is a subsequence of a sequence t if s can be obtained from t by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nint n, m, a[4005], cnt;\nLL dp[4005][4005];\n\nint solve(int l, int r, int id)\n{\n\tint mid = l;\n\tfor(int i = l + 1; i <= r; i ++) if(a[i] < a[mid]) mid = i;\n\tint siz;\n\tif(l == r) {\n\t\tsiz = 0;\n\t\tdp[id][0] = 0;\n\t} else if(mid == l) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(mid + 1, r, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else if(mid == r) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(l, mid - 1, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else {\n\t\tint tl = cnt;\n\t\tint ls = solve(l, mid - 1, cnt ++);\n\t\tint tr = cnt;\n\t\tint rs = solve(mid + 1, r, cnt ++);\n\t\tsiz = ls + rs;\n\t\tfor(int i = 0; i <= siz; i ++) dp[id][i] = -INF;\n\t\tfor(int i = 0; i <= ls; i ++) for(int j = 0; j <= rs; j ++)\n\t\tdp[id][i + j] = max(dp[id][i + j], dp[tl][i] + dp[tr][j] - 2LL * i * j * a[mid]);\n\t}\n\t\n\tsiz ++; dp[id][siz] = -INF;\n\tfor(int i = siz; i >= 1; i --) dp[id][i] = max(dp[id][i], dp[id][i - 1] + 1LL * (m + 1 - 2 * i) * a[mid]);\n\treturn siz;\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, n) scanf(""%d"", &a[i]);\n\t\n\tcnt = 1;\n\tsolve(0, n - 1, 0);\n\tprintf(""%lld\\n"", dp[0][m]);\n\treturn 0;\n}']","['brute force', 'divide and conquer', 'dp', 'greedy', 'trees']",2900
https://codeforces.com//contest/1638/problem/F,F. Two Posters,You want to advertise your new business so you are going to place two posters on a billboard in the city center The billboard consists of n vertical panels of width 1 and varying integer heights held together by a horizontal bar The i th of the n panels has height h i Initially all panels hang down from the bar their top edges lie on it but before placing the two posters you are allowed to move each panel up by any integer length as long as it is still connected to the bar its bottom edge lies below or on it After the moves are done you will place two posters one below the bar and one above it They are not allowed to go over the bar and they must be positioned completely inside of the panels What is the maximum total area the two posters can cover together if you make the optimal moves ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i, s, e) for (int i = s; i <= e; ++i)\n#define drep(i, s, e) for (int i = s; i >= e; --i)\n#define file(a) freopen(#a"".in"", ""r"", stdin), freopen(#a"".out"", ""w"", stdout)\n#define pv(a) cout << #a << "" = "" << a << endl\n#define pa(a, l, r) cout << #a "" : ""; rep(_, l, r) cout << a[_] << \' \'; cout << endl\n\nconst int N = 1e4 + 10;\n\nint read() {\n  int x = 0, f = 1; char c = getchar();\n  for (; c < \'0\' || c > \'9\'; c = getchar()) if (c == \'-\') f = -1;\n  for (; c >= \'0\' && c <= \'9\'; c = getchar()) x = x * 10 + c - 48;\n  return x * f;\n}\n\nint n, a[N], L[N], R[N], pre[N], suf[N], st[N], top, ans;\n\nsigned main() {\n  n = read();\n  rep(i, 1, n) a[i] = read();\n  rep(i, 1, n) {\n    while (top && a[st[top]] > a[i]) R[st[top]] = i - 1, -- top;\n    st[++ top] = i;\n  }\n  while (top) R[st[top]] = n, -- top;\n  drep(i, n, 1) {\n    while (top && a[st[top]] > a[i]) L[st[top]] = i + 1, -- top;\n    st[++ top] = i;\n  }\n  while (top) L[st[top]] = 1, -- top;\n  rep(i, 1, n) {\n    rep(j, 1, i) pre[i] = max(pre[i], a[j] * (min(i, R[j]) - L[j] + 1));\n    rep(j, i, n) suf[i] = max(suf[i], a[j] * (R[j] - max(i, L[j]) + 1));\n  }\n  rep(i, 0, n) ans = max(ans, pre[i] + suf[i + 1]);\n  // pa(L, 1, n);\n  // pa(R, 1, n);\n  rep(t, 1, n) {\n    int l = L[t], r = R[t];\n    // cout << ""------- t, l, r = "" << t << \' \' << l << \' \' << r << endl;\n    rep(i, 1, n) {\n      if (l < L[i] || R[i] < r) continue;\n      ans = max(ans, a[i] * (R[i] - L[i] - (r - l)) + a[t] * (r - l + 1));\n    }\n    for (int i = 1, p = r + 1; i <= r; ++ i) {\n      if (l < L[i] || R[i] < r) continue;\n      // cout << ""i, L[i], R[i] = "" << i << \' \' << L[i] << \' \' << R[i] << endl;\n      for (; p <= n && a[i] + a[p] >= a[t]; ++ p) ;\n      ans = max(ans, a[i] * (r - L[i] + 1) + (a[t] - a[i]) * (p - l));\n      // cout << ""2 p, ans = "" << p << \' \' << ans << endl;\n    }\n    for (int i = n, p = l - 1; i >= l; -- i) {\n      if (l < L[i] || R[i] < r) continue;\n      for (; p && a[i] + a[p] >= a[t]; -- p) ;\n      ans = max(ans, a[i] * (R[i] - l + 1) + (a[t] - a[i]) * (r - p));\n      // cout << ""2 p, ans = "" << p << \' \' << ans << endl;\n    }\n    for (int i = r, q = n, mx = 0; i; -- i) {\n      if (l < L[i] || R[i] < r) continue;\n      // cout << ""i, L[i], R[i] = "" << i << \' \' << L[i] << \' \' << R[i] << endl;\n      for (; q > r && (r < L[q] || R[q] < l || a[i] + a[q] <= a[t]); -- q) {\n        if (L[q] <= l && r <= R[q]) mx = max(mx, a[q] * (R[q] - l + 1));\n      }\n      ans = max(ans, a[i] * (r - L[i] + 1) + mx);\n      // cout << ""3 q, mx, ans = "" << q << \' \' << mx << \' \' << ans << endl;\n    }\n  }\n  printf(""%lld\\n"", ans);\n  return 0;\n}']","['brute force', 'data structures', 'greedy', 'two pointers']",3200
https://codeforces.com//contest/362/problem/B,B. Petya and Staircases,Little boy Petya loves stairs very much But he is bored from simple going up and down them he loves jumping over several stairs at a time As he stands on some stair he can either jump to the next one or jump over one or two stairs at a time But some stairs are too dirty and Petya doesn t want to step on them Now Petya is on the first stair of the staircase consisting of stairs He also knows the numbers of the dirty stairs of this staircase Help Petya find out if he can jump through the entire staircase and reach the last stair number without touching a dirty stair once One has to note that anyway Petya should step on the first and last stairs so if the first or the last stair is dirty then Petya cannot choose a path with clean steps only ,"['#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <sstream>\n#include <assert.h>\n#include <complex>\n\n#include <time.h>\n#pragma comment(linker, ""/STACK:20000000"")\n\n#define fr(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define fd(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nusing namespace std;\n\nint ri(){int x;scanf(""%d"",&x);return x;}\nll rll(){ll x;scanf(""%lld"",&x);return x;}\n\n\n\nvoid solve()\n{\n\tint n = ri(),k = ri();\n\tif (k == 0)\n\t{\n\t\tcout << ""YES"" << endl;\n\t\treturn;\n\t}\n\tvector<int> mas;\n\tfr(i,1,k)\n\t\tmas.pb(ri());\n\tsort(mas.begin(),mas.end());\n\tif (mas[0] == 1 || mas[0] == n || mas[mas.size() - 1] == 1 || mas[mas.size() - 1] == n)\n\t{\n\t\tcout << ""NO"" << endl;\n\t\treturn;\n\t}\n\tfr(i,0,k-3)\n\t{\n\t\tif (mas[i] + 1 == mas[i + 1] && mas[i + 1] + 1 == mas[i + 2])\n\t\t{\n\t\t\tcout << ""NO"" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << ""YES"" << endl;\n}\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/input.txt"",""rt"",stdin);\n\t\tfreopen(""C:/Users/CleRIC/Desktop/Универ/acm.timus.ru/output.txt"",""wt"",stdout);\n\t#else\n\t\t//freopen(""cubroot.in"",""rt"",stdin);\n\t\t//freopen(""cubroot.out"",""wt"",stdout);\n\t#endif\n\n\tsolve();\n\n\t#ifndef ONLINE_JUDGE\n\t\tprintf(""\\n\\ntime-%.3lf"",clock()*1e-3);\n\t#endif\n\n\treturn 0;\n}']","['implementation', 'sortings']",1100
https://codeforces.com//contest/1829/problem/A,A. Love Story,Timur loves codeforces That s why he has a string s having length 10 made containing only lowercase Latin letters Timur wants to know how many indices string s from the string For example string s differs from in 4 indices shown in bold Help Timur by finding the number of indices where string s differs from Note that you can t reorder the characters in the string s ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n\nstring a = ""codeforces"";\nstring b;\n\nvoid solve() {\n    cin >> b;\n    int res = 0;\n    rep(i, 0, min(a.size(), b.size()) - 1) {\n        res += (a[i] != b[i]);\n    }\n    cout << res << ""\\n"";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","['implementation', 'strings']",800
https://codeforces.com//contest/1253/problem/C,C. Sweets Eating,Tsumugi brought n delicious sweets to the Light Music Club They are numbered from 1 to n where the i th sweet has a sugar concentration described by an integer a i Yui loves sweets but she can eat at most m sweets each day for health reasons Days are 1 indexed numbered 1 2 3 ldots Eating the sweet i at the d th day will cause a sugar penalty of d cdot a i as sweets become more sugary with time A sweet can be eaten at most once The total sugar penalty will be the of the individual penalties of each sweet eaten Suppose that Yui chooses exactly k sweets and eats them in any order she wants What is the total sugar penalty she can get Since Yui is an undecided girl she wants you to answer this question for every value of k between 1 and n ,"['#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n\nint n,m;\nint A[200005];\nvector < int > B[200005],id;\nLL row[200005];\nint cnt = 0;\n\nint main(){\n\n\n\tscanf(""%d%d"",&n,&m);\n\tfor ( int i = 0; i < n; i++ ){\n\t\tscanf(""%d"",&A[i]);\n\t}\n\tsort(A,A+n);\n\n\tcnt = 0;\n\tfor ( int i = 0; i < n; i++ ){\n\t\tif ( B[cnt].size() == m ) cnt++;\n\t\tB[cnt].push_back(A[i]);\n\t}\n\t\n\tcnt = 0;\n\tint pos = 0;\n\tLL ans = 0;\n\tfor ( int i = 1; i <= n; i++ ){\n\t\trow[pos] += B[cnt][pos];\n\t\tans += row[pos];\n\t\tpos++;\n\t\tif ( pos == m ){\n\t\t\tcnt++;\n\t\t\tpos = 0;\n\t\t}\n\t\tprintf(""%lld"",ans);\n\t\tif ( i < n ) printf("" "");\n\t\telse printf(""\\n"");\n\t}\n\treturn 0;\n}']","['dp', 'greedy', 'math', 'sortings']",1500
https://codeforces.com//contest/1313/problem/B,B. Different Rules,Nikolay has only recently started in competitive programming but already qualified to the finals of one prestigious olympiad There going to be n participants one of whom is Nikolay Like any good olympiad it consists of two rounds Tired of the traditional rules in which the participant who solved the largest number of problems wins the organizers came up with different rules Suppose in the first round participant A took x th place and in the second round y th place Then the total score of the participant A is sum x y The overall place of the participant A is the number of participants including A having their total score less than or equal to the total score of A Note that some participants may end up having a common overall place It is also important to note that in both the first and the second round there were no two participants tying at a common place In other words for every i from 1 to n participant took i th place in first round and participant took i th place in second round Right after the end of the Olympiad Nikolay was informed that he got x th place in first round and y th place in the second round Nikolay doesn t know the results of other participants yet he wonders what is the minimum and maximum place he can take if we consider the most favorable and unfavorable outcome for him Please help Nikolay to find the answer to this question ,"['#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-\'0\',ch=getchar();\n\treturn f?x:-x;\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(""in.in"",""r"",stdin);\n\t//freopen(""out.out"",""w"",stdout);\n#endif\n\tint T=gi();\n\twhile(T--){\n\t\tint n=gi(),x=gi(),y=gi();\n\t\tif(x>y)std::swap(x,y);\n\t\tprintf(""%d %d\\n"",std::min(n,std::max(1,x+y-n+1)),std::max(1,n+1-std::max(1,(n+1-x)+(n+1-y)-n)));\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'implementation', 'math']",1700
https://codeforces.com//contest/1254/problem/A,A. Feeding Chicken,Long is a huge fan of CFC Codeforces Fried Chicken But the price of CFC is increasing so he decides to breed the chicken on his own farm His farm is presented by a rectangle grid with r rows and c columns Some of these cells contain rice others are empty k chickens are living on his farm Long wants to give his chicken playgrounds by assigning these farm cells to his chickens He would like to satisfy the following requirements Each cell of the farm is assigned to chicken Each chicken is assigned cell The set of cells assigned to every chicken forms a connected area More precisely if two cells x y and u v are assigned to the same chicken this chicken is able to walk from x y to u v by passing only its cells and moving from each cell to another cell sharing a side Long also wants to prevent his chickens from fighting for food Hence he wants the difference between the maximum and the minimum number of cells with rice assigned to a chicken to be as small as possible Please help him ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=107;\n\nint n, m, k;\n\nchar wcz[nax][nax];\nint tab[nax][nax];\n\nint faj;\n\nchar pyt(int v)\n{\n\tif (v<26)\n\t\treturn \'a\'+v;\n\tif (v<52)\n\t\treturn \'A\'+(v-26);\n\treturn \'0\'+(v-52);\n}\n\nvoid test()\n{\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfaj=0;\n\tvector <pii> pola;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%s"", wcz[i]+1);\n\t\tif (i&1)\n\t\t{\n\t\t\tfor (int j=1; j<=m; j++)\n\t\t\t{\n\t\t\t\ttab[i][j]=(wcz[i][j]==\'R\');\n\t\t\t\tfaj+=tab[i][j];\n\t\t\t\tpola.push_back({i, j});\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j=m; j; j--)\n\t\t\t{\n\t\t\t\ttab[i][j]=(wcz[i][j]==\'R\');\n\t\t\t\tfaj+=tab[i][j];\n\t\t\t\tpola.push_back({i, j});\n\t\t\t}\n\t\t}\n\t}\n\tint bylo=0;\n\tint kt=0;\n\tfor (pii i : pola)\n\t{\n\t\tbylo+=tab[i.first][i.second];\n\t\tif (bylo>faj*(kt+1)/k)\n\t\t\tkt++;\n\t\tkt=min(kt, k-1);\n\t\twcz[i.first][i.second]=pyt(kt);\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tprintf(""%c"", wcz[i][j]);\n\t\tprintf(""\\n"");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'implementation']",1700
https://codeforces.com//contest/343/problem/D,D. Water Tree,Mad scientist Mike has constructed a rooted tree which consists of vertices Each vertex is a reservoir which can be either empty or filled with water The vertices of the tree are numbered from 1 to with the root at vertex 1 For each vertex the reservoirs of its children are located below the reservoir of this vertex and the vertex is connected with each of the children by a pipe through which water can flow downwards Mike wants to do the following operations with the tree Fill vertex with water Then and all its children are filled with water Empty vertex Then and all its ancestors are emptied Determine whether vertex is filled with water at the moment Initially all vertices of the tree are empty Mike has already compiled a full list of operations that he wants to perform in order Before experimenting with the tree Mike decided to run the list through a simulation Help Mike determine what results will he get after performing all the operations ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint pz[N], pv[N], fin[N];\nint s[N], val[N];\nint kw, w[N];\nint ss[2 * N], ff[2 * N], pred[2 * N], last[N];\n\nvoid dfs(int v, int pr) {\n  w[++kw] = v;\n  pz[v] = kw;\n  int j = last[v];\n  while (j > 0) {\n    if (ff[j] != pr) {\n      pv[ff[j]] = v;\n      dfs(ff[j], v);\n    }\n    j = pred[j];\n  }\n  fin[v] = kw;\n}\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  int m = n - 1;\n  for (int i = 1; i <= m; i++) {\n    scanf(""%d %d"", ss + i, ff + i);\n    ss[i + m] = ff[i];\n    ff[i + m] = ss[i];\n  }\n  for (int i = 1; i <= n; i++) last[i] = 0;\n  for (int i = 1; i <= m + m; i++) {\n    pred[i] = last[ss[i]];\n    last[ss[i]] = i;\n  }\n  kw = 0;\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) s[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i]++;\n    int j = (i | (i - 1)) + 1;\n    if (j <= n) s[j] += s[i];\n    val[i] = 1;\n  }\n  int tt;\n  scanf(""%d"", &tt);\n  while (tt--) {\n    int com, v;\n    scanf(""%d %d"", &com, &v);\n    if (com == 1) {\n      int sum = 0;\n      int x = pz[v] - 1;\n      while (x > 0) {\n        sum += s[x];\n        x &= x - 1;\n      }\n      int cur = 0;\n      x = fin[v];\n      while (x > 0) {\n        cur += s[x];\n        x &= x - 1;\n      }\n      if (cur == sum) continue;\n      int last = pz[v] - 1;\n      while (cur > sum) {\n        int ll = last + 1, rr = fin[v];\n        while (ll < rr) {\n          int mid = (ll + rr) >> 1;\n          x = mid;\n          int q = 0;\n          while (x > 0) {\n            q += s[x];\n            x &= x - 1;\n          }\n          if (q > sum) rr = mid;\n          else ll = mid + 1;\n        }\n        x = ll;\n        val[x] = 0;\n        while (x <= n) {\n          s[x]--;\n          x = (x | (x - 1)) + 1;\n        }\n        last = ll;\n        cur--;\n      }\n      if (v != 1) {\n        int x = pz[pv[v]];\n        if (val[x] == 0) {\n          val[x] = 1;\n          while (x <= n) {\n            s[x]++;\n            x = (x | (x - 1)) + 1;\n          }\n        }\n      }\n    } else\n    if (com == 2) {\n      if (val[pz[v]] == 0) {\n        int x = pz[v];\n        val[x] = 1;\n        while (x <= n) {\n          s[x]++;\n          x = (x | (x - 1)) + 1;\n        }\n      }\n    } else {\n      int sum = 0;\n      int x = fin[v];\n      while (x > 0) {\n        sum += s[x];\n        x &= x - 1;\n      }\n      x = pz[v] - 1;\n      while (x > 0) {\n        sum -= s[x];\n        x &= x - 1;\n      }\n      if (sum > 0) printf(""0\\n"");\n      else printf(""1\\n"");\n    }\n  }\n  return 0;\n}\n']","['data structures', 'dfs and similar', 'graphs', 'trees']",2100
https://codeforces.com//contest/1850/problem/E,E. Cardboard for Pictures,Mircea has n pictures The i th picture is a square with a side length of s i centimeters He mounted each picture on a square piece of cardboard so that each picture has a border of w centimeters of cardboard on all sides In total he used c square centimeters of cardboard Given the picture sizes and the value c can you find the value of w Please note that the piece of cardboard goes behind each picture not just the border ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tll n, c;  cin >> n >> c;\n\tvector<ll> a(n);\n\tfor (auto &ai: a) {\n\t\tcin >> ai;\n\t}\n\tll lo = 0, hi = 1;\n\twhile (true) {\n\t\tll sum = 0;\n\t\tfor (auto ai: a) {\n\t\t\tsum += (ai + 2 * hi) * (ai + 2 * hi);\n\t\t}\n\t\tif (sum >= c)  break;\n\t\thi *= 2;\n\t}\n\n\twhile (lo <= hi) {\n\t\tll mid = (lo + hi) / 2;\n\t\tll sum = 0;\n\t\tfor (auto ai: a) {\n\t\t\tsum += (ai + 2 * mid) * (ai + 2 * mid);\n\t\t}\n\t\tif (sum >= c)  hi = mid - 1;\n\t\telse  lo = mid + 1;\n\t}\n\tcout << lo << ""\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","['binary search', 'geometry', 'implementation', 'math']",1100
https://codeforces.com//contest/691/problem/F,F. Couple Cover,Couple Cover a wildly popular luck based game is about to begin Two players must work together to construct a rectangle A bag with balls each with an integer written on it is placed on the table The first player reaches in and grabs a ball randomly all balls have equal probability of being chosen the number written on this ball is the rectangle s width in meters This ball is not returned to the bag and the second player reaches into the bag and grabs another ball the number written on this ball is the rectangle s height in meters If the area of the rectangle is greater than or equal some threshold square meters the players win Otherwise they lose The organizers of the game are trying to select an appropriate value for so that the probability of a couple winning is not too high and not too low but they are slow at counting so they have hired you to answer some questions for them You are given a list of the numbers written on the balls the organizers would like to know how many winning pairs of balls exist for different values of Note that two pairs are different if either the first or the second ball is different between the two in pair and two different balls with the same number are considered different ,"['/*\nOne, two, three, four, five against one\nFive, five, against one\nSaid one, two, three, four, five against one\nFive, five, five, five, five against one\n\nTorture from you to me\nAbducted from the street\n\nI\'d rather be\nI\'d rather be with\nI\'d rather be with an animal\n\nWhy would you wanna hurt me? Oh\nOh, so frightened of your pain\n\nI\'d rather be\nI\'d rather be with\nI\'d rather be with an animal\nI\'d rather be\nI\'d rather be\nI\'d rather be with an animal\n\nI\'d rather be\nI\'d rather be with\nI\'d rather be with an animal\nI\'d rather be\nI\'d rather be\nI\'d rather be with an animal\n\nSaid one, two, three, four, five against one\nFive, five, five, five, five against one\nOne, two, three, four, five against one\nFive, five, five, five, five against one\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 3000031;\n\nint n, ar[N];\nint cnt[N];\nlong long total[N], below[N];\nint tests, val;\n\nint main(){\n\t//freopen(""fabro.in"",""r"",stdin);\n\t//freopen(""fabro.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"", ""r"", stdin);\n\t//freopen(""F:/output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tcnt[ar[i]]++;\n\t}\n\n\tfor (int i = 1; i <= 3000000; i++)\n\t{\n\t\tif (cnt[i] == 0)\n\t\t\tcontinue;\n\n\t\tfor (int j = 1; j*i <= 3000000; j++)\n\t\t{\n\t\t\ttotal[i*j] += 1ll*cnt[i] * cnt[j];\n\t\t\tif (i == j)\n\t\t\t\ttotal[i*j] -= cnt[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3000000; i++)\n\t{\n\t\tbelow[i] = below[i - 1] + total[i - 1];\n\t}\n\n\tlong long RES = 1ll * n*(n - 1);\n\n\tcin >> tests;\n\tfor (; tests; --tests)\n\t{\n\t\tcin >> val;\n\t\tcout << RES - below[val] << ""\\n"";\n\t}\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']","['brute force', 'dp', 'number theory']",2200
https://codeforces.com//contest/863/problem/C,C. 1-2-3,Ilya is working for the company that constructs robots Ilya writes programs for entertainment robots and his current project is Bob a new generation game robot Ilya s boss wants to know his progress so far Especially he is interested if Bob is better at playing different games than the previous model Alice So now Ilya wants to compare his robots performance in a simple game called 1 2 3 This game is similar to the Rock Paper Scissors game both robots secretly choose a number from the set and say it at the same moment If both robots choose the same number then it s a draw and noone gets any points But if chosen numbers are different then one of the robots gets a point beats beats and beats Both robots programs make them choose their numbers in such a way that their choice in th game depends only on the numbers chosen by them in th game Ilya knows that the robots will play games Alice will choose number in the first game and Bob will choose in the first game He also knows both robots programs and can tell what each robot will choose depending on their choices in previous game Ilya doesn t want to wait until robots play all games so he asks you to predict the number of points they will have after the final game ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tlong long K; int a; int b;\n\twhile (~scanf(""%lld%d%d"", &K, &a, &b)) {\n\t\t-- a, -- b;\n\t\tvector<vector<int> > A(3, vector<int>(3));\n\t\tfor (int i = 0; i < 3; ++ i) for (int j = 0; j < 3; ++ j)\n\t\t\tscanf(""%d"", &A[i][j]), -- A[i][j];\n\t\tvector<vector<int> > B(3, vector<int>(3));\n\t\tfor (int i = 0; i < 3; ++ i) for (int j = 0; j < 3; ++ j)\n\t\t\tscanf(""%d"", &B[i][j]), -- B[i][j];\n\t\tstruct Perm {\n\t\t\tarray<pair<int, pair<ll, ll>>, 9> next;\n\t\t\tPerm() {\n\t\t\t\trep(i, 9)\n\t\t\t\t\tnext[i] = { i, {0, 0} };\n\t\t\t}\n\t\t\tPerm operator*(const Perm &that) {\n\t\t\t\tPerm res;\n\t\t\t\trep(i, 9) {\n\t\t\t\t\tint j = next[i].first;\n\t\t\t\t\tres.next[i] = {\n\t\t\t\t\t\tthat.next[j].first,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnext[i].second.first + that.next[j].second.first,\n\t\t\t\t\t\t\tnext[i].second.second + that.next[j].second.second,\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t};\n\t\tPerm perm;\n\t\trep(i, 3) rep(j, 3) {\n\t\t\tint x = A[i][j], y = B[i][j];\n\t\t\tperm.next[i * 3 + j] = { x * 3 + y, {(i + 2) % 3 == j, (j + 2) % 3 == i} };\n\t\t}\n\t\tPerm x = perm, y{};\n\t\twhile (K > 0) {\n\t\t\tif (K & 1) y = y * x;\n\t\t\tx = x * x;\n\t\t\tK >>= 1;\n\t\t}\n\t\tauto ans = y.next[a * 3 + b].second;\n\t\tprintf(""%lld %lld\\n"", ans.first, ans.second);\n\t}\n\treturn 0;\n}\n']","['graphs', 'implementation']",1800
https://codeforces.com//contest/630/problem/B,B. Moore's Law,The city administration of IT City decided to fix up a symbol of scientific and technical progress in the city s main square namely an indicator board that shows the effect of Moore s law in real time Moore s law is the observation that the number of transistors in a dense integrated circuit doubles approximately every months The implication of Moore s law is that computer performance as function of time increases exponentially as well You are to prepare information that will change every second to display on the indicator board Let s assume that every second the number of transistors increases exactly times ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    int n, t;\n    cin >> n >> t;\n    dbl res = n * pow(1.000000011, t);\n    printf(""%.10f\\n"", res);\n\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']",['math'],1200
https://codeforces.com//contest/1893/problem/A,A. Anonymous Informant,You are given an array b 1 b 2 ldots b n An anonymous informant has told you that the array b was obtained as follows initially there existed an array a 1 a 2 ldots a n after which the following two component operation was performed k times A fixed point dagger x of the array a was chosen Then the array a was cyclically shifted to the left ddagger exactly x times As a result of k such operations the array b 1 b 2 ldots b n was obtained You want to check if the words of the anonymous informant can be true or if they are guaranteed to be false dagger A number x is called a fixed point of the array a 1 a 2 ldots a n if 1 leq x leq n and a x x ddagger A cyclic left shift of the array a 1 a 2 ldots a n is the array a 2 ldots a n a 1 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tchmin(k,n+10);\n\tvi b=readvi(n);\n\tint head=0;\n\trep(_,k){\n\t\tint x=b[(head+(n-1))%n];\n\t\thead+=(n-x);\n\t\tif(!inc(1,x,n))return No(0);\n\t}\n\treturn Yes(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['brute force', 'dfs and similar', 'graphs', 'implementation']",1400
https://codeforces.com//contest/1701/problem/E,E. Text Editor,You wanted to write a text t consisting of m lowercase Latin letters But instead you have written a text s consisting of n lowercase Latin letters and now you want to fix it by obtaining the text t from the text s Initially the cursor of your text editor is at the end of the text s after its last character In one move you can do one of the following actions press the left button so the cursor is moved to the left by one position or does nothing if it is pointing at the beginning of the text i e before its first character press the right button so the cursor is moved to the right by one position or does nothing if it is pointing at the end of the text i e after its last character press the home button so the cursor is moved to the beginning of the text before the first character of the text press the end button so the cursor is moved to the end of the text after the last character of the text press the backspace button so the character before the cursor is removed from the text if there is no such character nothing happens Your task is to calculate the minimum number of moves required to obtain the text t from the text s using the given set of actions or determine it is impossible to obtain the text t from the text s You have to answer T independent test cases ,"['/**\n *    author:  tourist\n *    created: 08.07.2022 18:52:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    string t;\n    cin >> s >> t;\n    int ptr = 0;\n    int pref = 0;\n    for (int i = 0; i < n; i++) {\n      if (ptr < m && s[i] == t[ptr]) {\n        if (i == ptr) {\n          pref += 1;\n        }\n        ptr += 1;\n      }\n    }\n    if (ptr < m) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    int ans = n - pref;\n    const int inf = (int) 1e9;\n    vector<int> d0(m + 1, inf);\n    vector<int> d1(m + 1, inf);\n    vector<int> d2(m + 1, inf);\n    d0[0] = d1[0] = d2[0] = 0;\n    for (char c : s) {\n      vector<int> f0(m + 1, inf);\n      vector<int> f1(m + 1, inf);\n      vector<int> f2(m + 1, inf);\n      for (int i = 0; i <= m; i++) {\n        f0[i] = min(f0[i], d0[i] + 2);\n        f2[i] = min(f2[i], d2[i] + 1);\n        if (i < m && c == t[i]) {\n          f0[i + 1] = min(f0[i + 1], d0[i] + 1);\n          f1[i + 1] = min(f1[i + 1], d1[i]);\n          f2[i + 1] = min(f2[i + 1], d2[i] + 1);\n        }\n      }\n      for (int i = 0; i <= m; i++) {\n        f1[i] = min(f1[i], f0[i]);\n        f2[i] = min(f2[i], f1[i]);\n      }\n      swap(d0, f0);\n      swap(d1, f1);\n      swap(d2, f2);\n    }\n    ans = min(ans, d2[m] + 1);\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'dp', 'greedy', 'strings']",2500
https://codeforces.com//contest/979/problem/A,"A. Pizza, Pizza, Pizza   ",Katie Kuro and Shiro are best friends They have known each other since kindergarten That s why they often share everything with each other and work together on some very hard problems Today is Shiro s birthday She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday including her best friends Katie and Kuro She has ordered a very big round pizza in order to serve her many friends Exactly n of Shiro s friends are here That s why she has to divide the pizza into n 1 slices Shiro also needs to eat She wants the slices to be exactly the same size and shape If not some of her friends will get mad and go home early and the party will be over Shiro is now hungry She wants to cut the pizza with of straight cuts A cut is a straight segment it might have ends inside or outside the pizza But she is too lazy to pick up the calculator As usual she will ask Katie and Kuro for help But they haven t come yet Could you help Shiro with this problem ,"['#include <bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=5e5+7;\n\nLL n;\n\nint main()\n{\n\tscanf(""%lld"", &n);\n\tn++;\n\tif (n==1){\n\t\tprintf(""0\\n"");\n\t}\n\telse{\n\t\tif (n%2)\n\t\t\tprintf(""%lld\\n"", n);\n\t\telse\n\t\t\tprintf(""%lld\\n"", n/2);\n\t}\n    return 0;\n}\n']",['math'],1000
https://codeforces.com//contest/1208/problem/B,B. Uniqueness,You are given an array a 1 a 2 ldots a n You can remove subsegment from it The remaining elements should be pairwise distinct In other words time you can choose two integers l and r 1 leq l leq r leq n and delete integers a l a l 1 ldots a r from the array Remaining elements should be pairwise distinct Find the minimum size of the subsegment you need to remove to make all remaining elements distinct ,"[""/**\n *    author:  tourist\n *    created: 25.08.2019 17:36:33       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> b = a;\n  sort(b.begin(), b.end());\n  b.resize(unique(b.begin(), b.end()) - b.begin());\n  if ((int) b.size() == n) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    a[i] = (int) (lower_bound(b.begin(), b.end(), a[i]) - b.begin());\n  }\n  int ans = 0;\n  vector<int> mark(n, 0);\n  for (int i = 0; i < n; i++) {\n    int take = 0;\n    for (int j = 0; j < n; j++) {\n      if (mark[a[n - 1 - j]] > 0) {\n        break;\n      }\n      mark[a[n - 1 - j]] = 1;\n      ++take;\n    }\n    ans = max(ans, i + take);\n    for (int j = 0; j < take; j++) {\n      mark[a[n - 1 - j]] = 0;\n    }\n    if (mark[a[i]]) {\n      break;\n    }\n    mark[a[i]] = 1;\n  }\n  cout << n - ans << '\\n';\n  return 0;\n}\n""]","['binary search', 'brute force', 'implementation', 'two pointers']",1500
https://codeforces.com//contest/1809/problem/F,F. Traveling in Berland,There are n cities in Berland arranged in a circle and numbered from 1 to n in clockwise order You want to travel all over Berland starting in some city visiting all the other cities and returning to the starting city Unfortunately you can only drive along the Berland Ring Highway which connects all n cities The road was designed by a very titled and respectable minister so it is one directional it can only be traversed clockwise only from the city i to the city i bmod n 1 i e from 1 to 2 from 2 in 3 from n to 1 The fuel tank of your car holds up to k liters of fuel To drive from the i th city to the next one a i liters of fuel are needed and are consumed in the process Every city has a fuel station a liter of fuel in the i th city costs b i burles Refueling between cities is not allowed if fuel has run out between cities then your journey is considered incomplete For each city calculate the minimum cost of the journey if you start and finish it in that city ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    \n    std::vector<i64> f(2 * n + 1);\n    for (int i = 0; i < 2 * n; i++) {\n        f[i + 1] = f[i] + a[i % n];\n    }\n    \n    int last = -1;\n    std::vector<int> pre(2 * n);\n    for (int i = 0; i < 2 * n; i++) {\n        if (b[i % n] == 1) {\n            last = i;\n        }\n        pre[i] = last;\n    }\n    \n    std::vector<i64> ans(n);\n    ans[0] += sum;\n    for (int i = 0; i < 2 * n - 1; i++) {\n        if (b[i % n] == 2) {\n            if (pre[i] == -1) {\n                ans[std::max(0, i - n + 1)] += a[i % n];\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            } else {\n                int v = std::max(0LL, std::min(1LL * a[i % n], f[i + 1] - f[pre[i]] - k));\n                ans[std::max(0, i - n + 1)] += v;\n                if (pre[i] + 1 < n) {\n                    ans[pre[i] + 1] += a[i % n] - v;\n                }\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        ans[i] += ans[i - 1];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['binary search', 'data structures', 'graphs', 'greedy', 'implementation']",2500
https://codeforces.com//contest/1506/problem/G,G. Maximize the Remaining String,You are given a string s consisting of lowercase Latin letters While there is at least one character in the string s that is you perform the following operation you choose the index i 1 le i le s such that the character at position i occurs times in the string s and delete the character at position i that is replace s with s 1 s 2 ldots s i 1 s i 1 s i 2 ldots s n For example if s then you can apply the following sequence of operations i 6 Rightarrow s i 1 Rightarrow s i 7 Rightarrow s Given a given string s find the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string A string a of length n is lexicographically less than a string b of length m if there is an index i 1 le i le min n m such that the first i 1 characters of the strings a and b are the same and the i th character of the string a is less than i th character of string b the first min n m characters in the strings a and b are the same and n m For example the string a is lexicographically less than the string b ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint lst[205];\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring a;\n\t\tcin >> a;\n\t\tint n=a.size();\n\t\tfor(int i=\'a\';i<=\'z\';i++) lst[i]=n;\n\t\tlst[0]=n;\n\t\tfor(int i=0;i<a.size();i++)\n\t\t\tlst[a[i]]=i;\n\t\tint pos=0;\n\t\tfor(int X=0;X<=26;X++)\n\t\t{\n\t\t\tchar mx=0;\n\t\t\tfor(int i=pos;i<n;i++)\n\t\t\t{\n\t\t\t\tmx=max(mx,a[i]);\n\t\t\t\tif(lst[a[i]]==i)\n\t\t\t\t{\n\t\t\t\t\tlst[mx]=n;\n\t\t\t\t\tcout << mx;\n\t\t\t\t\twhile(a[pos]!=mx) ++pos;\n\t\t\t\t\t++pos; \n\t\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\t\tif(a[i]==mx) a[i]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ""\\n"";\n\t}\n\treturn 0;\n}']","['brute force', 'data structures', 'dp', 'greedy', 'strings']",2000
https://codeforces.com//contest/1494/problem/D,D. Dogeforces,The Dogeforces company has k employees Each employee except for lower level employees has at least 2 subordinates Lower level employees have no subordinates Each employee except for the head of the company has exactly one direct supervisor The head of the company is a direct or indirect supervisor of all employees It is known that in Dogeforces each supervisor receives a salary strictly more than all his subordinates The full structure of the company is a secret but you know the number of lower level employees and for each pair of lower level employees the salary of their common supervisor is known if there are several such supervisors then the supervisor with the minimum salary You have to restore the structure of the company ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nint n;\nvector<vector<int>> a;\n\nvector<pair<int, int>> edges;\n\n\nvector<int> vals;\nint idx;\n\n\nint solve(vector<int> cur)\n{\n\n    //cout<<""Solving for: ""; for (auto it: cur) cout<<it<<\' \'; cout<<endl;\n\n    if (cur.size()==1)\n    {\n        vals[cur[0]] = a[cur[0]][cur[0]];\n        return cur[0];\n    }\n\n    int maxx = 0;\n    int k = cur.size();\n    for (int i = 0; i<k; i++)\n        for (int j = 0; j<k; j++) maxx = max(maxx, a[cur[i]][cur[j]]);\n\n    vals.push_back(maxx);\n\n    int cur_idx = idx;\n    idx++;\n\n\n    vector<vector<int>> vecs;\n    for (auto it: cur)\n    {\n        bool found = false;\n        for (auto &vec: vecs)\n        {\n            if (a[vec.back()][it] < maxx)\n            {\n                found = true; vec.push_back(it); break;\n            }\n        }\n        if (!found)\n        {\n            vecs.push_back({it});\n        }\n    }\n\n    for (auto vec: vecs)\n    {\n        int son_idx = solve(vec);\n        edges.push_back(mp(son_idx, cur_idx));\n    }\n\n\n    return cur_idx;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    cin>>n;\n\n    idx = n;\n    vals.resize(n);\n\n    a = vector<vector<int>>(n, vector<int>(n));\n    for (int i = 0; i<n; i++)\n    {\n        for (int j = 0; j<n; j++) cin>>a[i][j];\n    }\n\n    vector<int> guys(n); for (int i = 0; i<n; i++) guys[i] = i;\n\n    int root = solve(guys);\n\n    cout<<vals.size()<<endl;\n    for (auto it: vals) cout<<it<<\' \';\n    cout<<endl;\n    cout<<root+1<<endl;\n    for (auto it: edges) cout<<it.first+1<<\' \'<<it.second+1<<endl;\n\n\n\n\n\n\n}']","['constructive algorithms', 'data structures', 'dfs and similar', 'divide and conquer', 'dsu', 'greedy', 'sortings', 'trees']",2300
https://codeforces.com//contest/1209/problem/G1,G1. Into Blocks  easy version , A sequence of integers is called if its elements are arranged in blocks like in 3 3 3 4 1 1 Formally if two elements are equal everything in between must also be equal Let s define of a sequence as a minimum possible number of elements to change to get a nice sequence However if you change at least one element of value x to value y you must also change all other elements of value x into y as well For example for 3 3 1 3 2 1 2 it isn t allowed to change first 1 to 3 and second 1 to 2 You need to leave 1 s untouched or change them to the same value You are given a sequence of integers a 1 a 2 ldots a n and q updates Each update is of form i x change a i to x Updates are not independent the change stays for the future Print the difficulty of the initial sequence and of the sequence after every update ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000,M=200000;\nint n,l[N],r[N],cnt[N],gor[N],a[N],f[N],ans;\n\nint main() {\n\tscanf(""%d%*d"",&n);\n\trep(i,1,M+1) l[i]=n+1,r[i]=0;\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",a+i);\n\t\tl[a[i]]=min(l[a[i]],i);\n\t\tr[a[i]]=max(r[a[i]],i);\n\t\tcnt[a[i]]++;\n\t}\n\trep(i,1,n+1) gor[i]=r[a[i]];\n\tint p=1;\n\twhile (p<=n) {\n\t\tint mr=gor[p];\n\t\tint md=0;\n\t\twhile (p<=mr) {\n\t\t\tmd=max(md,cnt[a[p]]);\n\t\t\tmr=max(mr,gor[p]);\n\t\t\tp++;\n\t\t}\n\t\tans+=md;\n\t}\n\tprintf(""%d\\n"",n-ans);\n}\n']","['data structures', 'dsu', 'greedy', 'implementation', 'two pointers']",2000
https://codeforces.com//contest/1704/problem/H1,H1. Game of AI  easy version ,Cirno is playing a war simulator game with n towers numbered from 1 to n and n bots numbered from 1 to n The i th tower is initially occupied by the i th bot for 1 le i le n Before the game Cirno first chooses a permutation p p 1 p 2 ldots p n of length n A permutation of length n is an array of length n where each integer between 1 and n appears exactly once After that she can choose a sequence a a 1 a 2 ldots a n 1 le a i le n and a i ne i for all 1 le i le n The game has n rounds of attacks In the i th round if the p i th bot is still in the game it will begin its attack and as the result the a p i th tower becomes occupied by the p i th bot the bot that previously occupied the a p i th tower will no longer occupy it If the p i th bot is not in the game nothing will happen in this round After each round if a bot doesn t occupy any towers it will be eliminated and leave the game Please note that no tower can be occupied by more than one bot but one bot can occupy more than one tower during the game At the end of the game Cirno will record the result as a sequence b b 1 b 2 ldots b n where b i is the number of the bot that occupies the i th tower at the end of the game However as a mathematics master she wants you to solve the following counting problem instead of playing games Count the number of different pairs of sequences a and b that we can get from all possible choices of sequence a and permutation p Since this number may be large output it modulo M ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 18:10:18       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nvector<Mint> fact;\nvector<Mint> inv_fact;\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n >> md;\n  fact = inv_fact = {1};\n  C(2 * n + 1, 0);\n  Mint ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; 2 * j <= i; j++) {\n      Mint dp = fact[i] * C(i - j - 1, j - 1) * inv_fact[j];\n      int ones = n - i;\n      Mint add = dp * C(n, i) * power(Mint(n - 1), j) * power(Mint(n - j - ones), ones);\n      ans += add;\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","['combinatorics', 'constructive algorithms', 'dp', 'fft', 'math']",3200
https://codeforces.com//contest/706/problem/E,E. Working routine,Vasiliy finally got to work where there is a huge amount of tasks waiting for him Vasiliy is given a matrix consisting of rows and columns and tasks Each task is to swap two submatrices of the given matrix For each task Vasiliy knows six integers where is the index of the row where the top left corner of the first rectangle is located is the index of its column is the index of the row of the top left corner of the second rectangle is the index of its column is the height of the rectangle and is its width It s guaranteed that two rectangles in one query do not overlap and do not touch that is no cell belongs to both rectangles and no two cells belonging to different rectangles However rectangles are allowed to share an angle Vasiliy wants to know how the matrix will look like after all tasks are performed ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int , int> pi;\ntypedef pair< int , pi> pii;\n\nconst int INF = ~0U >> 1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n\tint ret = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % Mod)\n\t\tif (x & 1) ret = 1ll * ret * a % Mod;\n\treturn ret;\n}\n\nconst int N = 1000 + 10, M = 1100000;\nint id[N][N], l[M], r[M], u[M], d[M], val[M];\nint l1[N], l2[N], r1[N], r2[N], u1[N], u2[N], d1[N], d2[N];\nint n, m, q, tot, a, b, c, e, h, w;\n\nint main() {\n\tscanf(""%d%d%d"", &n, &m, &q);\n\trep(i, 0, n + 2) rep(j, 0, m + 2) id[i][j] = tot++;\n\trep(i, 0, n + 2) rep(j, 0, m + 1)\n\t\tr[id[i][j]] = id[i][j + 1],\n\t\tl[id[i][j + 1]] = id[i][j];\n\trep(i, 0, n + 1) rep(j, 0, m + 2)\n\t\td[id[i][j]] = id[i + 1][j],\n\t\tu[id[i + 1][j]] = id[i][j];\n\trep(i, 1, n + 1) rep(j, 1, m + 1) scanf(""%d"", val + id[i][j]);\n\trep(i, 0, q) {\n\t\tscanf(""%d%d%d%d"", &a, &b, &c, &e);\n\t\tint x = id[0][0], y = id[0][0];\n\t\trep(j, 0, a) x = d[x];\n\t\trep(j, 0, b) x = r[x];\n\t\trep(j, 0, c) y = d[y];\n\t\trep(j, 0, e) y = r[y];\n\t\tscanf(""%d%d"", &h, &w);\n\t\tint z = x, v = y;\n\t\trep(j, 0, h) {\n\t\t\tl1[j] = z; l2[j] = v;\n\t\t\tz = d[z]; v = d[v];\n\t\t}\n\t\tz = u[z]; v = u[v];\n\t\trep(j, 0, w) {\n\t\t\td1[j] = z; d2[j] = v;\n\t\t\tz = r[z]; v = r[v];\n\t\t}\n\t\tz = x, v = y;\n\t\trep(j, 0, w) {\n\t\t\tu1[j] = z; u2[j] = v;\n\t\t\tz = r[z]; v = r[v];\n\t\t}\n\t\tz = l[z]; v = l[v];\n\t\trep(j, 0, h) {\n\t\t\tr1[j] = z; r2[j] = v;\n\t\t\tz = d[z]; v = d[v];\n\t\t}\n\t\trep(j, 0, h) {\n\t\t\tswap(r[l[l1[j]]], r[l[l2[j]]]);\n\t\t\tswap(l[l1[j]], l[l2[j]]);\n\t\t\tswap(l[r[r1[j]]], l[r[r2[j]]]);\n\t\t\tswap(r[r1[j]], r[r2[j]]);\n\t\t}\n\t\trep(j, 0, w) {\n\t\t\tswap(d[u[u1[j]]], d[u[u2[j]]]);\n\t\t\tswap(u[u1[j]], u[u2[j]]);\n\t\t\tswap(u[d[d1[j]]], u[d[d2[j]]]);\n\t\t\tswap(d[d1[j]], d[d2[j]]);\n\t\t}\n\t}\n\tint u = id[0][0];\n\trep(i, 1, n + 1) {\n\t\tu = d[u];\n\t\tint v = u;\n\t\trep(j, 1, m + 1) {\n\t\t\tv = r[v];\n\t\t\tprintf(""%d "", val[v]);\n\t\t}\n\t\tputs("""");\n\t}\n}']","['data structures', 'implementation']",2500
https://codeforces.com//contest/1036/problem/G,G. Sources and Sinks,You are given an acyclic directed graph consisting of n vertices and m edges The graph contains no multiple edges and no self loops The vertex is called a if it has no incoming edges The vertex is called a if it has no outgoing edges These definitions imply that some vertices can be both source and sink The number of sources in the given graph is equal to the number of sinks in it and each of these numbers doesn t exceed 20 The following algorithm is applied to the graph if the graph has no sources and sinks then quit choose arbitrary source s arbitrary sink t add an edge from t to s to the graph and go to step 1 that operation pops s out of sources and t out of sinks Note that s and t may be the same vertex then a self loop is added At the end you check if the graph becomes strongly connected that is any vertex is reachable from any other vertex Your task is to check that the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=(1<<20);\nvoid build(){\n\n}\nint n, m, od[N], id[N];\nvector<int> v[N];\nint oid[N], iid[N], tot;\nvoid init(){\n  n=getint();\n  m=getint();\n  while(m--){\n    int ui=getint();\n    int vi=getint();\n    od[ui]++;\n    id[vi]++;\n    v[ui].push_back(vi);\n  }\n  int _oid=0, _iid=0;\n  for(int i=1; i<=n; i++){\n    if(od[i]==0) oid[i]=_oid++;\n    else oid[i]=-1;\n    if(id[i]==0) iid[i]=_iid++;\n    else iid[i]=-1;\n  }\n  tot=_oid;\n}\nconst int K=20;\nint to[K], tg[N], stmp;\nvoid go(int st, int now){\n  tg[now]=stmp;\n  if(oid[now] >= 0)\n    to[st]|=(1<<oid[now]);\n  for(int nxt: v[now]){\n    if(tg[nxt] == stmp) continue;\n    go(st, nxt);\n  }\n}\nint msk[1<<K], cb[1<<K];\nvoid solve(){\n  for(int i=1; i<=n; i++)\n    if(iid[i] >= 0){\n      ++stmp;\n      go(iid[i], i);\n    }\n  for(int i=1; i<(1<<tot); i++)\n    cb[i]=cb[i>>1]+(i&1);\n  bool win=false;\n  for(int i=1; i<(1<<tot) and not win; i++){\n    for(int j=0; j<tot; j++)\n      if((i >> j) & 1)\n        msk[i]=msk[i^(1<<j)]|to[j];\n    if(i < (1<<tot)-1){\n      if(cb[i] == cb[msk[i]])\n        win=true;\n    }\n  }\n  puts(win?""NO"":""YES"");\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']","['bitmasks', 'brute force', 'dfs and similar']",2700
https://codeforces.com//contest/1333/problem/C,C. Eugene and an array,Eugene likes working with arrays And today he needs your help in solving one challenging task An array c is a subarray of an array b if c can be obtained from b by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end Let s call a nonempty array if for every nonempty subarray of this array sum of the elements of this subarray is nonzero For example array 1 2 3 is as all arrays 1 1 2 1 2 3 2 2 3 3 have nonzero sums of elements However array 1 2 1 3 isn t as his subarray 1 2 1 has sum of elements equal to 0 Help Eugene to calculate the number of nonempty subarrays of a given array a ,"['#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\nmap<ll, int> frec;\nint const nmax = 200000;\n\nint main()\n{\n  int n;\n  cin >> n;\n  ll result = 0, sum = 0;\n  int st = 1;\n  frec[0] = 1;\n  for(int i = 1;i <= n; i++){\n    int val;\n    cin >> val;\n    sum += val;\n    st = max(st, frec[sum] + 1);\n    frec[sum] = i + 1;\n    result += (i + 1 - st);\n  }\n  cout << result;\n  return 0;\n}\n']","['binary search', 'data structures', 'implementation', 'two pointers']",1700
https://codeforces.com//contest/244/problem/A,A. Dividing Orange,One day Ms Swan bought an orange in a shop The orange consisted of segments numbered with integers from 1 to There were children waiting for Ms Swan at home The children have recently learned about the orange and they decided to divide it between them For that each child took a piece of paper and wrote the number of the segment that he would like to get the th child wrote the number All numbers accidentally turned out to be different Now the children wonder how to divide the orange so as to meet these conditions each child gets exactly orange segments the th child gets the segment with number for sure no segment goes to two children simultaneously Help the children divide the orange and fulfill the requirements described above ,"['#include <stdio.h>\nint u[1010], a[50];\nint main(){\n    int n, k, i, x;\n    scanf(""%d%d"", &n, &k);\n    for (i = 0; i < k; i++){\n        scanf(""%d"", &x);\n        a[i] = x;\n        u[x] = 1;\n    }\n    for (i = 0; i < k; i++){\n        printf(""%d"", a[i]);\n        int t = n - 1;\n        x = 1;\n        while (t){\n            if (u[x]==0){\n                u[x]=1;\n                printf("" %d"", x);\n                t--;\n            }\n            x++;\n        }\n        printf(""\\n"");\n    }\n    return 0;\n}\n']",['implementation'],900
https://codeforces.com//contest/1845/problem/A,A. Forbidden Integer,You are given an integer n which you want to obtain You have an unlimited supply of every integer from 1 to k except integer x there are no integer x at all You are allowed to take an arbitrary amount of each of these integers possibly zero Can you make the sum of taken integers equal to n If there are multiple answers print any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int t;cin>>t;\n    while(t--)\n    {\n        int n,k,x;cin>>n>>k>>x;\n        if(x!=1)\n        {\n            cout<<""YES""<<\'\\n\';\n            cout<<n<<\'\\n\';\n            for(int i=0;i<n;++i) cout<<1<<\' \'; cout<<\'\\n\';\n        }\n        else\n        {\n            if(k>=2 && n%2==0)\n            {\n                cout<<""YES""<<\'\\n\';\n                cout<<n/2<<\'\\n\';\n                for(int i=0;i<n/2;++i) cout<<2<<\' \'; cout<<\'\\n\';\n            }\n            else if(k>=3)\n            {\n                cout<<""YES""<<\'\\n\';\n                cout<<n/2<<\'\\n\';\n                cout<<3<<\' \';\n                for(int i=1;i<n/2;++i) cout<<2<<\' \'; cout<<\'\\n\';\n            }\n            else\n            {\n                cout<<""NO""<<\'\\n\';\n            }\n        }\n    }\n    return 0;\n}\n']","['constructive algorithms', 'implementation', 'math', 'number theory']",800
https://codeforces.com//contest/625/problem/B,B. War of the Corporations,A long time ago in a galaxy far far away two giant IT corporations Pineapple and Gogol continue their fierce competition Crucial moment is just around the corner Gogol is ready to release it s new tablet Lastus 3000 This new device is equipped with specially designed artificial intelligence AI Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible Finally they found out that the name of the new artificial intelligence is similar to the name of the phone that Pineapple released 200 years ago As all rights on its name belong to Pineapple they stand on changing the name of Gogol s artificial intelligence Pineapple insists that the name of their phone occurs in the name of AI as a substring Because the name of technology was already printed on all devices the Gogol s director decided to replace some characters in AI name with As this operation is pretty expensive you should find the minimum number of characters to replace with such that the name of AI doesn t contain the name of the phone as a substring Substring is a continuous subsequence of a string ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int inf = 1001001001;\n\nint n,k,ans;\nstring S,s;\nint main()\n{\n    //freopen(""input.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n\n    cin >> S >> s;\n    int k=0;\n    for (int i=0; i<S.size(); i++){\n        k=0;\n        for (int j=0; j<s.size(); j++){\n            if (S[i+j]==s[j]) k++;\n        }\n        if (k==s.size()){\n            S[i+s.size()-1]=\'#\';\n            ans++;\n        }\n    }\n    cout << ans;\n    return 0;\n}\n']","['constructive algorithms', 'greedy', 'strings']",1200
https://codeforces.com//contest/1092/problem/F,F. Tree with Maximum Cost,You are given a tree consisting exactly of n vertices Tree is a connected undirected graph with n 1 edges Each vertex v of this tree has a value a v assigned to it Let dist x y be the distance between the vertices x and y The distance between the vertices is the number of edges on the simple path between them Let s define the cost of the tree as the following value firstly let s fix some vertex of the tree Let it be v Then the cost of the tree is sum limits i 1 n dist i v cdot a i Your task is to calculate the of the tree if you can choose v arbitrarily ,"['#include<cstdio>\n#include<vector>\nusing namespace std;\nvector<int>e[200001];\nlong long dp0[200001],s[200001];\nlong long a[200001];\nvoid dfs0(int x,int lt){\n    s[x]=a[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs0(y,x);\n        dp0[x]+=dp0[y]+s[y];\n        s[x]+=s[y];\n    }\n}\nlong long an;\nvoid dfs(int x,int lt,long long v){\n    if(v+dp0[x]>an)an=v+dp0[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs(y,x,v+dp0[x]-dp0[y]-s[y]*2+s[1]);\n    }\n}\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++)scanf(""%lld"",&a[i]);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(""%d%d"",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs0(1,1);\n    dfs(1,1,0);\n    printf(""%lld\\n"",an);\n    return 0;\n}\n']","['dfs and similar', 'dp', 'trees']",1900
https://codeforces.com//contest/1549/problem/B,B. Gregor and the Pawn Game,There is a chessboard of size n by n The square in the i th row from top and j th column from the left is labelled i j Currently Gregor has some pawns in the n th row There are also enemy pawns in the 1 st row On one turn Gregor moves one of pawns A pawn can move one square up from i j to i 1 j if there is no pawn in the destination square Additionally a pawn can move one square diagonally up from i j to either i 1 j 1 or i 1 j 1 if and only if there is an enemy pawn in that square The enemy pawn is also removed Gregor wants to know what is the maximum number of his pawns that can reach row 1 Note that only Gregor takes turns in this game and Also when Gregor s pawn reaches row 1 it is stuck and cannot make any further moves ,"['// Problem: B. Gregor and the Pawn Game\n// Contest: Codeforces - Codeforces Round #736 (Div. 2)\n// URL: https://codeforces.com/contest/1549/problem/B\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define chkmx(a,b) ((a)=max((a),(b)))\n#define chkmn(a,b) ((a)=min((a),(b)))\nusing namespace std;\ntemplate<typename T>\ninline void read(T &x){x=0;char c=getchar();bool f=false;for(;!isdigit(c);c=getchar())f|=c==\'-\';for(;isdigit(c);c=getchar())x=x*10+c-\'0\';if(f)x=-x;}\ntemplate<typename T ,typename ...Arg>inline void read(T &x,Arg &...args){read(x);read(args...);}\ntemplate<typename T>inline void write(T x){if(x<0)putchar(\'-\'),x=-x;if(x>=10)write(x/10);putchar(x%10+\'0\');}\n//#define int long long\ntypedef long long ll;\nconst int N=2e5+100;\nint t,n;char a[N],b[N];int fg[N];\nsigned main(){\n\tread(t);\n\twhile(t--){\n\t\tread(n);\n\t\tscanf(""%s"",a+1);\n\t\tscanf(""%s"",b+1);\n\t\ta[n+1]=b[n+1]=0;\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(a[i]==\'0\'){\n\t\t\t\tif(b[i]==\'1\')\n\t\t\t\t\tans++,b[i]=0;\n\t\t\t}else if(a[i]==\'1\'){\n\t\t\t\tif(b[i-1]==\'1\')ans++,b[i-1]=0;\n\t\t\t\telse if(b[i+1]==\'1\')ans++,b[i+1]=0;\n\t\t\t}\n\t\t}\n\t\twrite(ans);putchar(\'\\n\');\n\t}\n}']","['dfs and similar', 'dp', 'flows', 'graph matchings', 'graphs', 'greedy', 'implementation']",800
https://codeforces.com//contest/600/problem/C,C. Make Palindrome,A string is called palindrome if it reads the same from left to right and from right to left For example and are palindroms but strings and are not You are given string consisting of lowercase Latin letters At once you can choose any position in the string and change letter in that position to any other lowercase letter So after each changing the length of the string doesn t change At first you can change some letters in Then you can permute the order of letters as you want Permutation doesn t count as changes You should obtain palindrome with the minimal number of changes If there are several ways to do that you should get the lexicographically alphabetically smallest palindrome So firstly you should minimize the number of changes and then minimize the palindrome lexicographically ,"['/*\nYour insecurities makes me feel\nSo helpless, feel like letting go\nYour insincerities, it makes a world\nOf difference, you will never know\n\nAnother voiced rejection\nThrow it at me, please just let me go\nAnother selfish reason\nThrow it at me, please just let me go\n\nIt\'s all too much for me, I cannot hide\nThe sickness you bring on in me\nFree of sympathy, you\'ll never know\nHow it hurts, you will never know\n\nAnother voiced rejection\nThrow it at me, please just let me go\nAnother selfish reason\nThrow it at me, please just let me go\n\nThrow it at me, please just let me go\nAnother selfish reason\nThrow it at me, please just let me go\nAnother voiced rejection\nThrow it at me, please just let me go\n\nAnother selfish reason, throw it at me\nPlease just let me go, let me go\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 200005;\n\nusing namespace std;\n\nstring st;\nint cnt[N];\ndeque<char> qu;\nvector<int> odd;\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin>>st;\n\tfor (int i=0;i<st.size();i++)\n\t{\n\t\tcnt[st[i]]++;\n\t}\n\t\n\tfor (int i=\'a\';i<=\'z\';i++)\n\t\tif (cnt[i]%2)\n\t\t\todd.push_back(i);\n\t\n\tsort(odd.begin(),odd.end());\n\t/*\n\tif (odd.size()%2)\n\t{\n\t\tfor (int i=2;i<odd.size();i++)\n\t\t{\n\t\t\tcnt[odd[i]]--;\n\t\t\tcnt[odd[0]]++;\n\t\t}\n\t}\n\telse\n\t\n\tfor (int i=1;i<odd.size();i++)\n\t{\n\t\tcnt[odd[i]]--;\n\t\tcnt[odd[0]]++;\n\t}\n\t*/\n\t\n\tint sz=odd.size();\n\tint l=0;\n\tint r=sz-1;\n\twhile (l<r)\n\t{\n\t\tcnt[odd[l]]++;\n\t\tcnt[odd[r]]--;\n\t\t++l;\n\t\t--r;\n\t}\n\t\n\tint op=-1;\n\t\n\tfor (int i=\'a\';i<=\'z\';i++)\n\t{\n\t\tif (cnt[i]%2)\n\t\t{\n\t\t\tcnt[i]--;\n\t\t\tqu.push_back(i);\n\t\t}\n\t}\n\tfor (int i=\'z\';i>=\'a\';i--)\n\t{\n\t\twhile (cnt[i])\n\t\t{\n\t\t\tqu.push_back(i);\n\t\t\tqu.push_front(i);\n\t\t\tcnt[i]-=2;\n\t\t}\n\t}\n\t\n\twhile (qu.size())\n\t{\n\t\tcout<<qu.front();\n\t\tqu.pop_front();\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}']","['constructive algorithms', 'greedy', 'strings']",1800
https://codeforces.com//contest/1381/problem/A2,A2. Prefix Flip  Hard Version ,There are two binary strings a and b of length n a binary string is a string consisting of symbols 0 and 1 In an operation you select a prefix of a and simultaneously invert the bits in the prefix 0 changes to 1 and 1 changes to 0 and reverse the order of the bits in the prefix For example if a 001011 and you select the prefix of length 3 it becomes 011011 Then if you select the entire string it becomes 001001 Your task is to transform the string a into b in at most 2n operations It can be proved that it is always possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n;\nstr a,b;\n\nvi nor(str& x) {\n\tvi res;\n\tint ind = 0;\n\twhile (1) {\n\t\twhile (ind < n-1 && x[ind] == x[ind+1]) ind ++;\n\t\tif (ind == n-1) return res;\n\t\tres.pb(ind+1);\n\t\tx[ind] = \'0\'+\'1\'-x[ind];\n\t}\n}\n\nvoid solve() {\n\tre(n); re(a,b);\n\tvi x = nor(a);\n\tvi y = nor(b);\n\tif (a[n-1] != b[n-1]) {\n\t\tx.pb(n);\n\t}\n\treverse(all(y)); trav(t,y) x.pb(t);\n\tpr(sz(x),\' \'); ps(x);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","['constructive algorithms', 'data structures', 'implementation', 'strings', 'two pointers']",1700
https://codeforces.com//contest/803/problem/C,C. Maximal GCD,You are given positive integer number You should create such sequence of positive numbers that their sum is equal to and greatest common divisor is maximal Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them If there is no possible sequence then output ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    ll n, k;\n    scanf(""%lld%lld"", &n, &k);\n    if (k > (ll)1e8)\n    {\n        printf(""-1\\n"");\n        return 0;\n    }\n    ll b = n / (k * (k + 1) / 2);\n    if (b == 0)\n    {\n        printf(""-1\\n"");\n        return 0;\n    }\n    ll r = 1;\n    for (ll x = 1; x * x <= n; x++)\n    {\n        if (n % x != 0) continue;\n        if (x <= b && x > r) r = x;\n        if (n / x <= b && n / x > r) r = n / x;\n    }\n    for (int i = 1; i < k; i++)\n        printf(""%lld "", r * i);\n    n -= r * k * (k - 1) / 2;\n    printf(""%lld\\n"", n);\n\n    return 0;\n}\n']","['constructive algorithms', 'greedy', 'math']",1900
https://codeforces.com//contest/997/problem/E,E. Good Subsegments,A permutation p of length n is a sequence p 1 p 2 ldots p n consisting of n distinct integers each of which from 1 to n 1 leq p i leq n Let s call the subsegment l r of the permutation if all numbers from the minimum on it to the maximum on this subsegment occur among the numbers p l p l 1 dots p r For example good segments of permutation 1 3 2 5 4 are 1 1 1 3 1 5 2 2 2 3 2 5 3 3 4 4 4 5 5 5 You are given a permutation p 1 p 2 ldots p n You need to answer q queries of the form find the number of good subsegments of the given segment of permutation In other words to answer one query you need to calculate the number of good subsegments x dots y for some given segment l dots r such that l leq x leq y leq r ,"['#pragma GCC optimize(""-O3"",""-funroll-all-loops"")\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,p[SZ],q,ls[SZ],rs[SZ];\nvector<int> v[SZ];\nint s1[SZ],n1,s2[SZ],n2;\n//sqrt-blocking works better than segment tree\nconst int S=350;\n#define B S\ntypedef pair<ll,ll> pll;\ninline pll operator + (pll a,pll b)\n{\n\tif(!a.se) return b;\n\tif(!b.se) return a;\n\tif(a.fi<b.fi) return a;\n\tif(a.fi>b.fi) return b;\n\treturn pll(a.fi,a.se+b.se);\n}\nll x[SZ]; pll bmi[SZ],bmt[SZ],emi[SZ];\nll ba[SZ],bt[SZ];\nvoid pd(int b)\n{\n\tif(!bt[b]&&!bmt[b].se) return;\n\tbmi[b]=mp(8e18,0);\n\tfor(int j=b*S;j<b*S+S;++j)\n\t{\n\t\temi[j]=emi[j]+pll(bmt[b].fi+x[j],bmt[b].se);\n\t\tx[j]+=bt[b]; bmi[b]=bmi[b]+pll(x[j],1);\n\t}\n\tbmt[b]=mp(0,0); bt[b]=0;\n}\nvoid fedt(int b,int l,int r,int v)\n{\n\tfor(int j=max(b*S,l);j<b*S+S&&j<=r;++j) x[j]+=v;\n\tbmi[b]=mp(8e18,0);\n\tfor(int j=b*S;j<b*S+S;++j)\n\t\tbmi[b]=bmi[b]+pll(x[j],1);\n}\nvoid edt(int l,int r,int x)\n{\n\tpd(l/B),fedt(l/B,l,r,x);\n\tif(l/B!=r/B) pd(r/B),fedt(r/B,l,r,x);\n\tfor(int s=l/B+1;s<r/B;++s)\n\t\tbt[s]+=x;\n}\nvoid pr()\n{\n\tfor(int s=0;s<=n/B;++s)\n\t{\n\t\tif(bmi[s].fi+bt[s]==-1) ba[s]+=bmi[s].se;\n\t\tbmt[s]=bmt[s]+pll(bt[s],1);\n\t}\n}\nll qry(int l)\n{\n\tint bl=l/B;\n\tpd(bl); ll ans=0;\n\tfor(int t=l;t/B==bl;++t)\n\t\tans+=(emi[t].fi==-1)?emi[t].se:0;\n\tfor(int t=bl+1;t<=n/B;++t)\n\t\tans+=ba[t];\n\treturn ans;\n}\nll ans[SZ];\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(""%d"",p+i);\n\tscanf(""%d"",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(""%d%d"",ls+i,rs+i),v[rs[i]].pb(i);\n\t//max-min-len>=0, required:=0\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\twhile(n1&&p[s1[n1]]<p[i])\n\t\t\tedt(s1[n1-1]+1,s1[n1],p[i]-p[s1[n1]]),--n1;\n\t\twhile(n2&&p[s2[n2]]>p[i])\n\t\t\tedt(s2[n2-1]+1,s2[n2],p[s2[n2]]-p[i]),--n2;\n\t\ts1[++n1]=i; s2[++n2]=i;\n\t\tedt(1,i,-1); pr();\n\t\tfor(auto p:v[i])\n\t\t\tans[p]=qry(ls[p]);\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tprintf(""%lld\\n"",ans[i]);\n}\n']",['data structures'],3000
https://codeforces.com//contest/1646/problem/E,E. Power Board,You have a rectangular board of size n times m n rows m columns The n rows are numbered from 1 to n from top to bottom and the m columns are numbered from 1 to m from left to right The cell at the intersection of row i and column j contains the number i j i raised to the power of j For example if n 3 and m 3 the board is as follows Find the number of distinct integers written on the board ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    LL n, m, ans = 1, sum;\n    cin >> n >> m;\n    vector<vector<pair<int, int>>> d(n + 1);\n    for (int i = 2; i <= n; i += 1)\n        if (d[i].empty())\n            for (int j = i; j <= n; j += i) {\n                d[j].emplace_back(i, 0);\n                for (int k = j; k % i == 0; k /= i)\n                    d[j].back().second += 1;\n            }\n    vector<int> mp = {0};\n    for (LL i = 2; i <= n; i += 1) {\n        int x = 0;\n        for (auto [p, r] : d[i])\n            x = gcd(x, r);\n        int y = 1;\n        for (auto [p, r] : d[i])\n            for (int j = 0; j < r / x; j += 1)\n                y *= p;\n        if (y == i) {\n            int k = 1;\n            while (y * i <= n) {\n                y *= i;\n                k += 1;\n            }\n            while (k >= mp.size()) mp.push_back(0);\n            mp[k] += 1;\n        }\n    }\n    vector<int> f((mp.size() - 1) * m + 1);\n    for (int i = 1; i < mp.size(); i += 1) {\n        for (int j = 1; j <= m; j += 1)\n            if (not f[i * j])\n                sum += f[i * j] = 1;\n        ans += sum * mp[i];\n    }\n    cout << ans;\n    return 0;\n}']","['brute force', 'dp', 'math', 'number theory']",2200
https://codeforces.com//contest/1100/problem/A,A. Roman and Browser,This morning Roman woke up and opened the browser with n opened tabs numbered from 1 to n There are two kinds of tabs those with the information required for the test and those with social network sites Roman decided that there are too many tabs open so he wants to close some of them He decided to accomplish this by closing every k th 2 leq k leq n 1 tab Only then he will decide whether he wants to study for the test or to chat on the social networks Formally Roman will choose one tab let its number be b and then close all tabs with numbers c b i cdot k that satisfy the following condition 1 leq c leq n and i is an integer it may be positive negative or zero For example if k 3 n 14 and Roman chooses b 8 then he will close tabs with numbers 2 5 8 11 and 14 After closing the tabs Roman will calculate the amount of remaining tabs with the information for the test let s denote it e and the amount of remaining social network tabs s Help Roman to calculate the maximal absolute value of the difference of those values e s so that it would be easy to decide what to do next ,"['#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,k,a[MAXN];\nint main()\n{\n    scanf(""%d%d"",&n,&k);\n    int s0=0,s1=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(""%d"",&a[i]);\n        if(a[i]==1) s0++; else s1++;\n    }\n    int ans=0;\n    for(int i=1;i<=k;i++)\n    {\n        int cnt0=0,cnt1=0;\n        if(a[i]==1) cnt0++; else cnt1++;\n        for(int j=i+k;j<=n;j+=k) if(a[j]==1) cnt0++; else cnt1++;\n        ans=max(ans,abs(s0-cnt0-s1+cnt1));\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n']",['implementation'],1000
https://codeforces.com//contest/759/problem/C,C. Nikita and stack,Nikita has a stack A stack in this problem is a data structure that supports two operations Operation puts an integer on the top of the stack and operation deletes the top integer from the stack i e the last added If the stack is empty then the operation does nothing Nikita made operations with the stack but forgot them Now Nikita wants to remember them He remembers them one by one on the th step he remembers an operation he made th In other words he remembers the operations in order of some permutation After each step Nikita wants to know what is the integer on the top of the stack after performing the operations he have already remembered in the corresponding order Help him ,"['#include <cstdio>\n#include <algorithm>\n\nconst int o = 1 << 17;\n\nusing namespace std;\n\nstruct node {\n\tint sum, min;\n} IT[1 << 18];\nint a[100001];\n\nint main() {\n\tint i, j, k, l, n, t;\n\tscanf(""%d"", &n);\n\twhile (n--) {\n\t\tscanf(""%d%d"", &i, &j);\n\t\tif (j) {\n\t\t\tscanf(""%d"", &k);\n\t\t\ta[i] = k;\n\t\t\tl = i + o;\n\t\t\tIT[l].sum = 1;\n\t\t\twhile (l >>= 1) {\n\t\t\t\tIT[l].sum = IT[l << 1].sum + IT[l << 1 | 1].sum;\n\t\t\t\tIT[l].min = min(IT[l << 1].min, IT[l << 1].sum + IT[l << 1 | 1].min);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tl = i + o;\n\t\t\tIT[l].sum = -1;\n\t\t\twhile (l >>= 1) {\n\t\t\t\tIT[l].sum = IT[l << 1].sum + IT[l << 1 | 1].sum;\n\t\t\t\tIT[l].min = min(IT[l << 1].min, IT[l << 1].sum + IT[l << 1 | 1].min);\n\t\t\t}\n\t\t}\n\t\tl = 1;\n\t\tt = IT[1].sum - 1;\n\t\tif (IT[1].min > t) {\n\t\t\tputs(""-1"");\n\t\t\tcontinue;\n\t\t}\n\t\twhile (l < o) {\n\t\t\tif (IT[l << 1].sum + IT[l << 1 | 1].min > t) l = l << 1;\n\t\t\telse {\n\t\t\t\tt -= IT[l << 1].sum;\n\t\t\t\tl = l << 1 | 1;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", a[l - o]);\n\t}\n}']","['binary search', 'data structures']",2200
https://codeforces.com//contest/1691/problem/B,B. Shoe Shuffling,A class of students got bored wearing the same pair of shoes every day so they decided to shuffle their shoes among themselves In this problem a pair of shoes is inseparable and is considered as a single object There are n students in the class and you are given an array s in order where s i is the shoe size of the i th student A shuffling of shoes is valid only if and if every student gets shoes of size their size You have to output a permutation p of 1 2 ldots n denoting a valid shuffling of shoes where the i th student gets the shoes of the p i th student p i ne i And output 1 if a valid shuffling does not exist A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, s[N], p[N];\n\nvoid solve() {\n\tn = in; rep(i, 1, n) s[i] = in;\n\trep(i, 1, n) p[i] = i;\n\tfor(int l = 1, r; l <= n; l = r) {\n\t\tr = l; while(r <= n && s[r] == s[l]) r++;\n\t\tif(r != l + 1) {\n\t\t\trep(j, l, r - 1) p[j] = j + 1;\n\t\t\tp[r - 1] = l;\n\t\t} else return puts(""-1""), void();\n\t}\n\trep(i, 1, n) printf(""%d "", p[i]); puts("""");\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n']","['constructive algorithms', 'greedy', 'implementation', 'two pointers']",1000
https://codeforces.com//contest/1631/problem/A,A. Min Max Swap,You are given two arrays a and b of n positive integers each You can apply the following operation to them any number of times Select an index i 1 leq i leq n and swap a i with b i i e a i becomes b i and vice versa Find the possible value of max a 1 a 2 ldots a n cdot max b 1 b 2 ldots b n you can get after applying such operation any number of times possibly zero ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_n = 1e2 + 5;\n\nint a[max_n], b[max_n];\n\nvoid solve_tc(){\n\tint n; \n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> b[i];\n\t}\n\t\n\tint max_a = 0, max_b = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (a[i] > b[i]){\n\t\t\tswap(a[i], b[i]);\n\t\t}\n\t\tmax_a = max(max_a, a[i]);\n\t\tmax_b = max(max_b, b[i]);\n\t}\n\t\n\tcout << max_a * max_b << ""\\n"";\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint tests; \n\tcin >> tests;\n\twhile (tests--){\n\t\tsolve_tc();\n\t}\n}']",['greedy'],800
https://codeforces.com//contest/1721/problem/E,E. Prefix Function Queries,You are given a string s consisting of lowercase Latin letters You are asked q queries about it given another string t consisting of lowercase Latin letters perform the following steps concatenate s and t calculate the prefix function of the resulting string s t print the values of the prefix function on positions s 1 s 2 dots s t s and t denote the lengths of strings s and t respectively revert the string back to s The prefix function of a string a is a sequence p 1 p 2 dots p a where p i is the maximum value of k such that k i and a 1 k a i k 1 i a l r denotes a contiguous substring of a string a from a position l to a position r inclusive In other words it s the longest proper prefix of the string a 1 i that is equal to its suffix of the same length ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.length();\n    \n    std::vector<int> fail(n + 10 + 1);\n    fail[0] = -1;\n    std::vector<std::array<int, 26>> f(n + 10 + 1);\n    f[0][s[0] - \'a\'] = 1;\n    fail[1] = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < 26; j++) {\n            if (j == s[i] - \'a\') {\n                f[i][j] = i + 1;\n                fail[i + 1] = f[fail[i]][j];\n            } else {\n                f[i][j] = f[fail[i]][j];\n            }\n        }\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    while (q--) {\n        std::string t;\n        std::cin >> t;\n        \n        int m = t.length();\n        for (int i = n; i < n + m; i++) {\n            for (int j = 0; j < 26; j++) {\n                if (j == t[i - n] - \'a\') {\n                    f[i][j] = i + 1;\n                    fail[i + 1] = f[fail[i]][j];\n                } else {\n                    f[i][j] = f[fail[i]][j];\n                }\n            }\n            std::cout << fail[i + 1] << "" \\n""[i == n + m - 1];\n        }\n    }\n    \n    return 0;\n}\n']","['dfs and similar', 'dp', 'hashing', 'string suffix structures', 'strings', 'trees']",2200
https://codeforces.com//contest/1397/problem/B,B. Power Sequence,Let s call a list of positive integers a 0 a 1 a n 1 a if there is a positive integer c so that for every 0 le i le n 1 then a i c i Given a list of n positive integers a 0 a 1 a n 1 you are allowed to Reorder the list i e pick a permutation p of 0 1 n 1 and change a i to a p i then Do the following operation any number of times pick an index i and change a i to a i 1 or a i 1 i e increment or decrement a i by 1 with a cost of 1 Find the minimum cost to transform a 0 a 1 a n 1 into a power sequence ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long int INF = (long long)1e15;\n\nint N;\nint arr[101010];\n\n__int128 abds(__int128 x)\n{\n    if(x>0) return x;\n    return -x;\n}\n\nint main()\n{\n    cin >> N;\n    for(int i=0; i<N; ++i)\n        cin >> arr[i];\n    sort(arr, arr+N);\n    __int128 ans = INF;\n    int cmax;\n    if(N == 3) cmax = (int)1e7;\n    else cmax = (int)1e7/N;\n    for(int c=1; c<=cmax; ++c)\n    {\n        __int128 loc = 0;\n        __int128 v = 1;\n        for(int i=0; i<N; ++i)\n        {\n            loc += abds(arr[i]-v);\n            if(loc > ans) break;\n            v *= c;\n        }\n        if(ans>loc) ans = loc;\n    }\n    cout << (long long)ans << endl;\n}']","['brute force', 'math', 'number theory', 'sortings']",1500
https://codeforces.com//contest/1842/problem/F,F. Tenzing and Tree,Tenzing has an undirected tree of n vertices Define the of a tree with black and white vertices in the following way The of an edge is the absolute difference between the number of black nodes in the two components of the tree after deleting the edge The value of the tree is the sum of values over all edges For all k such that 0 leq k leq n Tenzing wants to know the maximum value of the tree when k vertices are painted black and n k vertices are painted white ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:46:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> ans(n + 1, 0);\n  for (int ver = 0; ver < n; ver++) {\n    vector<int> dist(n, -1);\n    dist[ver] = 0;\n    vector<int> que(1, ver);\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int to : g[que[b]]) {\n        if (dist[to] == -1) {\n          que.push_back(to);\n          dist[to] = dist[que[b]] + 1;\n        }\n      }\n    }\n    vector<int> cnt(n, 0);\n    for (int i = 0; i < n; i++) {\n      cnt[dist[i]] += 1;\n    }\n    int sum = 0;\n    int cc = 0;\n    for (int d = 0; d < n; d++) {\n      for (int rep = 0; rep < cnt[d]; rep++) {\n        sum += d;\n        cc += 1;\n        ans[cc] = max(ans[cc], cc * (n - 1) - 2 * sum);\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    cout << ans[i] << "" \\n""[i == n];\n  }\n  return 0;\n}\n']","['dfs and similar', 'greedy', 'shortest paths', 'sortings', 'trees']",2500
https://codeforces.com//contest/765/problem/E,E. Tree Folding,Vanya wants to minimize a tree He can perform the following operation multiple times choose a vertex and two disjoint except for paths of equal length and Additionally vertices must not have any neighbours in the tree other than adjacent vertices of corresponding paths After that one of the paths may be merged into the other that is the vertices can be effectively erased Help Vanya determine if it possible to make the tree into a path via a sequence of described operations and if the answer is positive also determine the shortest length of such path ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int N = (int) 2e5 + 100;\nvector <int> g[N];\n\n\nvoid dfs(int v, int par, int cd, int d[] )\n{\n\td[v] = cd;\n\tfor (int to : g[v] )\n\t{\n\t\tif (to == par) continue;\n\t\tdfs(to, v, cd + 1, d);\n\t}\n}\n\nint dfsCheck(int v, int par)\n{\n\tvector <int> ds;\n\tfor (int to : g[v] )\n\t{\n\t\tif (to == par) continue;\n\t\tds.push_back(dfsCheck(to, v) );\t\n\t}\n\tsort(ds.begin(), ds.end() );\n\tds.resize(unique(ds.begin(), ds.end() ) - ds.begin() );\n\tif (v != par)\n\t{\n//\t\teprintf(""v = %d, par = %d, ds.size() = %d\\n"", v, par, (int) ds.size() );\n\t\tif ( (int) ds.size() > 1)\n\t\t{\n\t\t\tprintf(""-1\\n"");\n\t\t\texit(0);\n\t\t}\n\t\tif (ds.empty() ) return 1;\n\t\treturn ds[0] + 1;\n\t}\n\tif (ds.empty() ) return 0;\n\tif ( (int) ds.size() > 2) return -1;\n\treturn ds[0] + ds.back();\n}\n\nint d0[N];\nint da[N];\nint db[N];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(0, 0, 0, d0);\n\tint a = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (d0[i] > d0[a] )\n\t\t\ta = i;\n\tdfs(a, a, 0, da);\n\tint b = a;\n\tfor (int i = 0; i < n; i++)\n\t\tif (da[i] > da[b] )\n\t\t\tb = i;\n\tdfs(b, b, 0, db);\n\tint c = b;\n\tfor (int i = 0; i < n; i++)\n\t\tif (db[i] + da[i] == db[a] && min(db[i], da[i] ) > min(db[c], da[c] ) )\n\t\t\tc = i;\n//\teprintf(""a = %d, b = %d, c = %d\\n"", a, b, c);\n\t\n\tint ans = dfsCheck(c, c);\n\twhile (ans % 2 == 0 && ans > 0)\n\t\tans /= 2;\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n\n\n']","['dfs and similar', 'dp', 'greedy', 'implementation', 'trees']",2200
https://codeforces.com//contest/1774/problem/F1,F1. Magician and Pigs  Easy Version ,Little09 has been interested in magic for a long time and it s so lucky that he meets a magician The magician will perform n operations each of them is one of the following three 1 x Create a pig with x Health Points 2 x Reduce the Health Point of all living pigs by x 3 Repeat all previous operations Formally assuming that this is the i th operation in the operation sequence perform the first i 1 operations including Repeat operations involved in turn A pig will die when its Health Point is less than or equal to 0 Little09 wants to know how many living pigs there are after all the operations Please print the answer modulo 998 244 353 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst ll INF = (ll)1e10;\nconst int N = 800800;\nPowers P2 = Powers(N, Mint(2));\nvector<int> allDoubles;\nint cntDoubles[N];\nll sumDamage[N];\nll sumDamageDoulbed[N];\nint a[N][2];\nint n;\nMint ANS;\nll b[100];\nll c[100];\nint m;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcntDoubles[i + 1] = cntDoubles[i];\n\t\tsumDamage[i + 1] = sumDamage[i];\n\t\tsumDamageDoulbed[i + 1] = sumDamageDoulbed[i];\n\t\tscanf(""%d"", &a[i][0]);\n\t\tif (a[i][0] == 1) {\n\t\t\tscanf(""%d"", &a[i][1]);\n\t\t} else if (a[i][0] == 2) {\n\t\t\tscanf(""%d"", &a[i][1]);\n\t\t\tsumDamage[i + 1] += a[i][1];\n\t\t\tsumDamageDoulbed[i + 1] = min(INF, sumDamageDoulbed[i + 1] + a[i][1]);\n\t\t} else {\n\t\t\tcntDoubles[i + 1] += 1;\n\t\t\tsumDamageDoulbed[i + 1] = min(INF, sumDamageDoulbed[i + 1] * 2);\n\t\t\tif (sumDamage[i] > 0) allDoubles.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (a[i][0] == 1) {\n\t\tll x = a[i][1];\n\t\tx -= sumDamage[n] - sumDamage[i];\n\t\tif (x <= 0) continue;\n\t\tm = 0;\n\t\tint p = lower_bound(all(allDoubles), i) - allDoubles.begin();\n\t\tif (p == (int)allDoubles.size()) {\n\t\t\tANS += P2.pow(cntDoubles[n] - cntDoubles[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tint q = p;\n\t\tint pw = cntDoubles[allDoubles[p]] - cntDoubles[i];\n\t\tassert(pw >= 0);\n\t\twhile(m < 32 && p < (int)allDoubles.size()) {\n\t\t\tb[m] = sumDamage[allDoubles[p]];\n\t\t\tif (b[m] >= x) break;\n\t\t\tm++;\n\t\t\tp++;\n\t\t}\n\t\tif (m == 0) {\n\t\t\tANS += P2.pow(pw);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = m - 1; i > 0; i--)\n\t\t\tb[i] -= b[i - 1];\n\t\tb[0] = sumDamageDoulbed[allDoubles[q]];\n\t\tc[0] = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tc[i + 1] = min(x + 1, 2 * c[i] + b[i]);\n\t\teprintf(""x = %lld\\n"", x);\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\teprintf(""%lld "", c[i]);\n\t\teprintf(""\\n"");\n\t\tll res = 1;\n\t\tfor (int i = m; i > 0; i--) {\n\t\t\tif (x <= c[i]) continue;\n\t\t\tres += 1LL << (i - 1);\n\t\t\tx -= c[i];\n\t\t}\n\t\tANS += Mint(res) * P2.pow(pw);\n\t}\n\tprintf(""%u\\n"", ANS.x);\n\n\treturn 0;\n}\n']","['brute force', 'data structures', 'implementation']",2400
https://codeforces.com//contest/1221/problem/F,F. Choose a Square,Petya recently found a game Choose a Square In this game there are n points numbered from 1 to n on an infinite field The i th point has coordinates x i y i and cost c i You have to choose a square such that its sides are parallel to coordinate axes the lower left and upper right corners belong to the line y x and all corners have integer coordinates The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square Note that the length of the side can be zero Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e6 + 100;\nint x[maxN], y[maxN], c[maxN];\nint bestX = 1.5e9;\nint bestY = bestX;\nll cost = 0;\nint idX[maxN], idY[maxN];\nint id[maxN];\nvector < int > events[maxN];\npair < ll, int > t[4 * maxN];\nll upd[4 * maxN];\nvoid build(int v, int tl, int tr) {\n    t[v] = make_pair(0, tl);\n    if (tl == tr) return;\n    int tm = (tl + tr) / 2;\n    build(2 * v, tl, tm);\n    build(2 * v + 1, tm + 1, tr);\n}\nvoid push(int v, int tl, int tr) {\n    if (upd[v] == 0) return;\n    t[v].first += upd[v];\n    if (tl != tr) {\n        upd[2 * v] += upd[v];\n        upd[2 * v + 1] += upd[v];\n    }\n    upd[v] = 0;\n}\nvoid add(int v, int tl, int tr, int l, int r, ll val) {\n    if (l <= tl && tr <= r) {\n        upd[v] += val;\n        push(v, tl, tr);\n        return;\n    }\n    push(v, tl, tr);\n    if (r < tl || l > tr) return;\n    int tm = (tl + tr) / 2;\n    add(2 * v, tl, tm, l, r, val);\n    add(2 * v + 1, tm + 1, tr, l, r, val);\n    t[v] = max(t[2 * v], t[2 * v + 1]);\n}\nconst ll INF = 2e18;\npair < ll, int > get_mx(int v, int tl, int tr, int l, int r) {\n    push(v, tl, tr);\n    if (l <= tl && tr <= r) return t[v];\n    if (l > r) return make_pair(-INF, -1);\n    int tm = (tl + tr) / 2;\n    return max(get_mx(2 * v, tl, tm, l, min(r, tm)), get_mx(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    vector < int > cords;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> c[i];\n        if (x[i] < y[i]) swap(x[i], y[i]);\n        cords.push_back(x[i]);\n        cords.push_back(y[i]);\n    }\n    sort(cords.begin(), cords.end());\n    cords.erase(unique(cords.begin(), cords.end()), cords.end());\n    for (int i = 0; i < cords.size(); i++) {\n        id[i + 1] = cords[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        idX[i] = lower_bound(cords.begin(), cords.end(), x[i]) - cords.begin() + 1;\n        idY[i] = lower_bound(cords.begin(), cords.end(), y[i]) - cords.begin() + 1;\n        events[idX[i]].push_back(i);\n    }\n    int m = cords.size();\n    build(1, 1, m);\n    for (int i = 1; i <= cords.size(); i++) {\n        add(1, 1, m, i, i, id[i]);\n        for (int v : events[i]) {\n            add(1, 1, m, 1, idY[v], c[v]);\n        }\n        auto it = get_mx(1, 1, m, 1, i);\n        ll val = it.first - id[i];\n        if (val > cost) {\n            bestX = id[i];\n            bestY = id[it.second];\n            cost = val;\n        }\n    }\n    cout << cost << \'\\n\';\n    cout << bestY << "" "" << bestY << "" "" << bestX << "" "" << bestX;\n\n    return 0;\n}']","['binary search', 'data structures', 'sortings']",2400
https://codeforces.com//contest/369/problem/A,A. Valera and Plates,Valera is a lazy student He has clean bowls and clean plates Valera has made an eating plan for the next days As Valera is lazy he will eat exactly one dish per day At that in order to eat a dish he needs exactly one plate or bowl We know that Valera can cook only two types of dishes He can eat dishes of the first type from bowls and dishes of the second type from either bowls or plates When Valera finishes eating he leaves a dirty plate bowl behind His life philosophy doesn t let him eat from dirty kitchenware So sometimes he needs to wash his plate bowl Find the minimum number of times Valera will need to wash a plate bowl if he acts optimally ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define lowbit(x) ((x) & (-(x)))\nusing namespace std;\ntypedef long long LL;\nconst int N = 1005;\nint n , m , k , a[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n    #endif\n    int ans = 0;\n    cin >> n >> m >> k;\n    for (int i = 0 ; i < n ; i ++) {\n        cin >> a[i];\n        if (a[i] == 2) {\n            if (k) k --;\n            else if (m) m --;\n            else ans ++;\n        }\n        else if (a[i] == 1) {\n            if (m) m --;\n            else ans ++;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;  \n}']","['greedy', 'implementation']",900
https://codeforces.com//contest/811/problem/E,E. Vladik and Entertaining Flags,In his spare time Vladik estimates beauty of the flags Every flag could be represented as the matrix which consists of positive integers Let s define the beauty of the flag as number of components in its matrix We call component a set of cells with same numbers and between any pair of cells from that set there exists a path through adjacent cells from same component Here is the example of the partitioning some flag matrix into components But this time he decided to change something in the process Now he wants to estimate not the entire flag but some segment Segment of flag can be described as a submatrix of the flag matrix with opposite corners at and where conditions are satisfied Help Vladik to calculate the beauty for some segments of the given flag ,"['#include<bits/stdc++.h>\n#define rep(i,j,k) for((i)=(j);(i)<=(k);++i)\n#define per(i,j,k) for((i)=(j);(i)>=(k);--i)\nusing namespace std;\ntypedef long long ll;\ninline void cmin(int &x,int y){if(y<x)x=y;}\ninline void cmax(int &x,int y){if(y>x)x=y;}\nconst int N = 1000006;\nint a[12][N],sum[N],tmp[N],bcj[N],f[N][22],id[N],n,m,T,i,j,l,r;\nint inline read(){\n\tchar ch=getchar();int z=0,f=1;\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){z=z*10+ch-\'0\';ch=getchar();}\n\treturn z*f;\n}\nint find(int x){if(bcj[x]==x)return x;return bcj[x]=find(bcj[x]);}\n/*int calc(int j,int k){\n\tint i , ans = 0;\n\trep(i,1,n) if(i == 1 || a[i][j] != a[i-1][j]) f[i] = i; else f[i] = f[i - 1];\n\trep(i,1,n) if(i == 1 || a[i][k] != a[i-1][k]) f[i+n] = i+n; else f[i+n] = f[i+n-1];\n\trep(i,1,n) if(a[i][j] == a[i][k] && find(i) != find(i + n)){++ans; f[find(i + n)] = find(i);}\n\treturn ans;\n}*/\nint calc(int f[],int g[],int j,int k){\n\tint i,ans = 0;\n\trep(i,1,n+n) bcj[i] = f[i];\n\trep(i,1,n+n) bcj[n+n+i] = n + n + g[i];\n\trep(i,1,n)\n\t\tif(a[i][j] == a[i][k] && find(n + i) != find(n + n + i)){++ans; bcj[find(n + n + i)] = find(n + i);}\n\treturn ans;\n}\nvoid build(int l,int r,int x){\n\tint mid=l+r>>1,i;\n\tif(l == r){\n\t\tint ans = 1;\n\t\trep(i,2,n) if(a[i][l] != a[i-1][l]) ++ans;\n\t\tsum[x] = ans;\n\t\trep(i,1,n) if(i == 1 || a[i][l] != a[i-1][l]) f[x][i] = i; else f[x][i] = f[x][i - 1];\n\t\trep(i,1,n) f[x][n + i] = f[x][i];\n\t\t//printf(""a %d %d\\n"",l,r);\n\t\t//rep(i,1,n+n) printf(""%d "",f[x][i]); puts("""");\n\t}else{\n\t\tbuild(l,mid,x*2); build(mid+1,r,x*2+1);\n\t\tsum[x] = sum[x*2] + sum[x*2+1];\n\t\tsum[x] -= calc(f[x * 2],f[x * 2 + 1],mid,mid+1);\n\t\trep(i,1,n * 4) bcj[i] = find(i) , id[i] = 0;\n\t\trep(i,1,n){\n\t\t\tint z = bcj[i];\n\t\t\tif(!id[z]) id[z] = i;\n\t\t\tf[x][i] = id[z];\n\t\t}\n\t\trep(i,n+1,n+n){\n\t\t\tint z = bcj[n * 2 + i];\n\t\t\tif(!id[z]) id[z] = i;\n\t\t\tf[x][i] = id[z];\n\t\t}\n\t\t//printf(""a %d %d\\n"",l,r);\n\t\t//rep(i,1,n*4) printf(""%d "",bcj[i]); puts("""");\n\t\t//rep(i,1,n+n) printf(""%d "",f[x][i]); puts("""");\n\t}\n}\nint query(int l,int r,int x,int s,int t,int g[]){\n\tint i;\n\tif(s <= l && r <= t){\n\t\trep(i,1,n+n) g[i] = f[x][i];\n\t\treturn sum[x];\n\t}\n\tint mid = l + r >> 1;\n\tif(t <= mid) return query(l,mid,x*2,s,t,g);\n\tif(s > mid) return query(mid+1,r,x*2+1,s,t,g);\n\tint h1[22],h2[22];\n\tint ans = query(l,mid,x*2,s,t,h1) + query(mid+1,r,x*2+1,s,t,h2);\n\tans -= calc(h1,h2,mid,mid+1);\n\trep(i,1,n * 4) bcj[i] = find(i) , id[i] = 0;\n\trep(i,1,n){\n\t\tint z = bcj[i];\n\t\tif(!id[z]) id[z] = i;\n\t\tg[i] = id[z];\n\t}\n\trep(i,n+1,n+n){\n\t\tint z = bcj[n * 2 + i];\n\t\tif(!id[z]) id[z] = i;\n\t\tg[i] = id[z];\n\t}\n\treturn ans;\n}\nint main(){\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tn=read();m=read();T=read();\n\trep(i,1,n) rep(j,1,m) a[i][j] = read();\n\tbuild(1 , m , 1);\n\twhile(T--){l=read();r=read();printf(""%d\\n"",query(1,m,1,l,r,tmp));}\n\treturn 0;\n}\n']","['data structures', 'dsu', 'graphs']",2600
https://codeforces.com//contest/900/problem/C,C. Remove Extra One,You are given a permutation of length Remove one element from permutation to make the number of records the maximum possible We remind that in a sequence of numbers the element is a if for every integer the following holds ,"['#include<bits/stdc++.h>\n#define maxn 100200\n\nusing namespace std;\n\nint a[maxn],x[maxn],y[maxn],n,k,cnt[maxn];\n\nint main()\n{\n    scanf(""%d"",&n);for (int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n    memset(x,0,sizeof(x));memset(y,0,sizeof(y));\n    for (int i=1;i<=n;i++)\n    {\n        x[i]=x[i-1];y[i]=y[i-1];\n        if (a[i]>x[i]) y[i]=x[i],x[i]=a[i];\n        else if (a[i]>y[i]) y[i]=a[i];\n    }\n    memset(cnt,0,sizeof(cnt));\n    for (int i=1;i<=n;i++) if (y[i]==a[i]) cnt[x[i]]++;\n    for (int i=1;i<=n;i++) if (x[i]==a[i]) cnt[a[i]]--;\n    k=1;for (int i=2;i<=n;i++) if (cnt[i]>cnt[k]) k=i;\n    printf(""%d\\n"",k);return 0;\n}\n']","['brute force', 'data structures', 'math']",1700
https://codeforces.com//contest/618/problem/B,B. Guess the Permutation,Bob has a permutation of integers from to Denote this permutation as The th element of will be denoted as For all pairs of distinct integers between and he wrote the number He writes for all integer from to Bob gave you all the values of that he wrote down Your job is to reconstruct any permutation that could have generated these values The input will be formed so that it is guaranteed that there is at least one solution that is consistent with the information given ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 60;\nint n;\nint a[N];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(""%d"", &x);\n\t\t\ta[i] = max(a[i], x);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] == n - 1)\n\t\t{\n\t\t\ta[i] = n;\n\t\t\tbreak;\n\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", a[i]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}']",['constructive algorithms'],1100
https://codeforces.com//contest/1271/problem/D,D. Portals,You play a strategic video game In this game you control a large army and your goal is to conquer n castles of your opponent Let s describe the game process in detail Initially you control an army of k warriors Your enemy controls n castles to conquer the i th castle you need at least a i warriors you are so good at this game that you don t lose any warriors while taking over a castle so your army stays the same after the fight After you take control over a castle you recruit new warriors into your army formally after you capture the i th castle b i warriors join your army Furthermore after capturing a castle or later you can defend it if you leave at least one warrior in a castle this castle is considered Each castle has an importance parameter c i and your total score is the sum of importance values over all defended castles There are two ways to defend a castle if you are currently in the castle i you may leave one warrior to defend castle i there are m one way portals connecting the castles Each portal is characterised by two numbers of castles u and v A portal can be used as follows if you are currently in the castle u you may send one warrior to defend castle v Obviously when you order your warrior to defend some castle he leaves your army You capture the castles in fixed order you have to capture the first one then the second one and so on After you capture the castle i but only before capturing castle i 1 you may recruit new warriors from castle i leave a warrior to defend castle i and use any number of portals leading from castle i to other castles having smaller numbers As soon as you capture the next castle these actions for castle i won t be available to you If during some moment in the game you don t have enough warriors to capture the next castle you lose Your goal is to maximize the sum of importance values over all defended castles note that you may hire new warriors in the last castle defend it and use portals leading from it even after you capture it your score will be calculated afterwards Can you determine an optimal strategy of capturing and defending the castles ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 5050, inF = 1e9 + 100;\n\nint n, m, k, a[N], b[N], c[N], best[N], dp[N][N];\nvector<int> vec[N];\n\nvoid input() {\n\tcin >> n >> m >> k;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i] >> b[i] >> c[i];\n\tiota(best, best + N, 0);\n\twhile (m--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (u > v)\n\t\t\tswap(u, v);\n\t\tbest[u] = max(best[u], v);\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tvec[i].push_back(0);\n\tfor (int i = 1; i <= n; i++)\n\t\tvec[best[i]].push_back(c[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(vec[i].begin() + 1, vec[i].end(), greater<int>());\n\t\tfor (int j = 1; j < vec[i].size(); j++)\n\t\t\tvec[i][j] += vec[i][j - 1];\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tdp[i][j] = -inF;\n\tdp[0][k] = 0;\n}\n\nvoid solve() {\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (dp[i][j] >= 0) {\n\t\t\t\tfor (int cnt = 0; cnt < vec[i].size() && j - cnt >= a[i + 1]; cnt++)\n\t\t\t\t\tdp[i + 1][j - cnt + b[i + 1]] = max(dp[i + 1][j - cnt + b[i + 1]], dp[i][j] + vec[i][cnt]);\n\t\t\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tinput();\n\tsolve();\n\tint ans = *max_element(dp[n + 1], dp[n + 1] + N);\n\tcout << (ans < 0? -1: ans);\n}\n']","['data structures', 'dp', 'greedy', 'implementation', 'sortings']",2100
https://codeforces.com//contest/429/problem/E,E. Points and Segments,Iahub isn t well prepared on geometry problems but he heard that this year there will be a lot of geometry problems on the IOI selection camp Scared Iahub locked himself in the basement and started thinking of new problems of this kind One of them is the following Iahub wants to draw distinct segments on the axis He can draw each segment with either red or blue The drawing is good if and only if the following requirement is met for each point of the axis consider all the segments that contains point suppose that red segments and blue segments contain point for each point inequality must be satisfied A segment contains a point if and only if Iahub gives you the starting and ending points of all the segments You have to find any good drawing for him ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nvector<pii> a;\nvector< vector<int> > g;\nvector<int> pos[100500];\nint col[200500];\n\nvoid error() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid go(int v, int c) {\n\tcol[v]= c;\n\tforn(i, g[v].size())\n\t\tif (col[g[v][i]] == -1)\n\t\t\tgo(g[v][i], 1 - c);\n\t\telse if (col[g[v][i]] == c)\n\t\t\terror();\t\t\t\t\n}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tcin >> n;\n\ta.clear();\n\tforn(i, n) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx *= 2;\n\t\ty *= 2;\n\t\ta.pb(mp(x-1, i));\n\t\ta.pb(mp(y, i));\n\t}\t\n\tsort(all(a));\n\tforn(i, a.size())\n\t\tpos[a[i].sc].pb(i);\n\tg.resize(n * 2);\n\tforn(i, n) {\n\t\tg[i * 2].pb(i * 2 + 1);\n\t\tg[i * 2 + 1].pb(i * 2);\n\n\t\tg[pos[i][0]].pb(pos[i][1]);\n\t\tg[pos[i][1]].pb(pos[i][0]);\n\t}\n\tseta(col, 255);\n\tforn(i, n * 2)\n\t\tif (col[i] == -1)\n\t\t\tgo(i, 0);\n\tforn(i, n)\n\t\tprintf(""%d "", col[pos[i][0]]);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']",['graphs'],3000
https://codeforces.com//contest/628/problem/A,A. Tennis Tournament,A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n  int n, b, p;\n  in >> n >> b >> p;\n  out << (2 * b + 1) * (n - 1) << "" "" << n * p << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","['implementation', 'math']",1000
https://codeforces.com//contest/382/problem/D,D. Ksenia and Pawns,Ksenia has a chessboard of size Each cell of the chessboard contains one of the characters The cells that contain character are blocked We know that all chessboard cells that touch the border are blocked Ksenia is playing with two pawns on this chessboard Initially she puts the pawns on the chessboard One cell of the chessboard can contain two pawns if and only if the cell is blocked In other cases two pawns can not stand in one cell The game begins when Ksenia put pawns on the board In one move Ksenia moves each pawn to a side adjacent cell in the direction of arrows painted on the cell on which the corresponding pawn sits if the pawn sits on it does not move Assume that Ksenia moves pawns simultaneously see the second test case Of course Ksenia plays for points How can one calculate the points per game Very simply Let s count how many movements the first pawn made and how many movements the second pawn made sum these two numbers it will be the resulting score of the game Ksenia wonders what is the maximum number of points she can earn for that she should place the pawns optimally well early in the game Help her and find that number ,"['#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar s[3001][3001];\nint d[3001][3001];\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\nconst char ds[]="">v<^"";\nbool vis[3001][3001];\nint dp[3001][3001][2];\nint n,m;\nint bfs[3001*3001][2];\nint T;\nint anss[2];\nvoid Update(int ans[],int x,int y){\n\tif(x>ans[1]){\n\t\tans[1]=x;\n\t\tif(ans[1]>ans[0]) swap(ans[1],ans[0]);\n\t\tif(y>ans[1]) ans[1]=y;\n\t}\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=0;i<n;++i) scanf(""%s"",s[i]);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tdp[i][j][0]=0,dp[i][j][1]=-1;\n\t\tif(s[i][j]!=\'#\'){\n\t\t\tfor(int k=0;k<4;++k) if(ds[k]==s[i][j]){\n\t\t\t\t++d[i+dx[k]][j+dy[k]];\n\t\t\t}\n\t\t}\n\t}\n\tT=-1;\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tif(!d[i][j]) ++T,bfs[T][0]=i,bfs[T][1]=j;\n\t}\n\tfor(int i=0;i<=T;++i){\n\t\tint x=bfs[i][0],y=bfs[i][1];\n\t\tif(s[x][y]==\'#\'){\n\t\t\tUpdate(anss,dp[x][y][0],dp[x][y][1]);\n\t\t}\n\t\telse{\n\t\t\tif(dp[x][y][0]==dp[x][y][1]) --dp[x][y][1];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tif(s[x][y]==ds[k]){\n\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\tUpdate(dp[nx][ny],dp[x][y][0]+1,dp[x][y][1]+1);\n\t\t\t\t\tif(--d[nx][ny]==0) ++T,bfs[T][0]=nx,bfs[T][1]=ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(T!=n*m-1) printf(""-1\\n"");\n\telse printf(""%d\\n"",anss[0]+anss[1]);\n\tscanf(""%d"",&n);\n\treturn 0;\n}\n']","['dfs and similar', 'graphs', 'implementation', 'trees']",2200
https://codeforces.com//contest/1537/problem/D,D. Deleting Divisors,Alice and Bob are playing a game They start with a positive integer n and take alternating turns doing operations on it Each turn a player can subtract from n one of its divisors that isn t 1 or n The player who cannot make a move on his her turn loses Alice always moves first Note that they subtract a divisor of the number in each turn You are asked to find out who will win the game if both players play optimally ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include ""map""\ntypedef double ld;\ntypedef long long ll;\n#define int long long\n#define all(x) x.begin(), x.end()\nusing namespace std;\nvoid solve() {\n    int n;\n    cin >> n;\n    int b2 = 2;\n    while (b2 < n)\n        b2 *= 4;\n    if (b2 == n) {\n        cout << ""Bob\\n"";\n        return;\n    }\n    if (n % 2 == 1) {\n        cout << ""Bob\\n"";\n    } else {\n        cout << ""Alice\\n"";\n    }\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q;\n    cin >> q;\n    while (q--) solve();\n}']","['games', 'math', 'number theory']",1700
https://codeforces.com//contest/222/problem/E,E. Decoding Genome,Recently a top secret mission to Mars has taken place As a result scientists managed to obtain some information about the Martian DNA Now we know that any Martian DNA contains at most different nucleotides numbered from to Special characteristics of the Martian DNA prevent some nucleotide pairs from following consecutively in this chain For example if the nucleotide 1 and nucleotide 2 can not follow consecutively in the Martian DNA then the chain of nucleotides 1 2 is not a valid chain of Martian DNA but the chain of nucleotides 2 1 can be a valid chain if there is no corresponding restriction The number of nucleotide pairs that can t follow in the DNA chain consecutively is The needs of gene research required information about the quantity of correct long chains of the Martian DNA Your task is to write a program that will calculate this value ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Matrix\n{\n\tlong long a[ 53 ][ 53 ];\n\tint n, m;\n\tMatrix( ) { memset( a, 0, sizeof( a ) ); }\n};\n\nvoid operator *= ( Matrix &a, const Matrix &b )\n{\n\tMatrix c;\n\tint i, j, k;\n\tc.n = a.n; c.m = b.m;\n\tfor ( i = 0; i < a.n; i++ )\n\t\tfor ( j = 0; j < a.m; j++ )\n\t\t\tfor ( k = 0; k < b.m; k++ )\n\t\t\t\tc.a[ i ][ k ] = ( c.a[ i ][ k ] + a.a[ i ][ j ] * b.a[ j ][ k ] ) % 1000000007;\n\ta = c;\n}\n\nint main( )\n{\n\tint m, k, i, j, u, v;\n\tlong long n, p, ans = 0;\n\tchar s[ 3 ];\n\tMatrix a, b, c;\n\tscanf(""%I64d%d%d"", &n, &m, &k); n--;\n\ta.n = 1; a.m = m;\n\tb.n = b.m = m;\n\tc.n = c.m = m;\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\ta.a[ 0 ][ i ] = 1;\n\t\tc.a[ i ][ i ] = 1;\n\t\tfor ( j = 0; j < m; j++ )\n\t\t\tb.a[ i ][ j ] = 1;\n\t}\n\tfor ( i = 0; i < k; i++ )\n\t{\n\t\tscanf(""%s"", s);\n\t\tif ( s[ 0 ] >= \'a\' && s[ 0 ] <= \'z\' )\n\t\t\tu = s[ 0 ] - \'a\';\n\t\telse\n\t\t\tu = s[ 0 ] - \'A\' + 26;\n\t\tif ( s[ 1 ] >= \'a\' && s[ 1 ] <= \'z\' )\n\t\t\tv = s[ 1 ] - \'a\';\n\t\telse\n\t\t\tv = s[ 1 ] - \'A\' + 26;\n\t\tb.a[ v ][ u ] = 0;\n\t}\n\tp = 1;\n\twhile ( p <= n ) p <<= 1;\n\tp >>= 1;\n\twhile ( p )\n\t{\n\t\tc *= c;\n\t\tif ( p & n ) c *= b;\n\t\tp >>= 1;\n\t}\n\ta *= c;\n\tfor ( i = 0; i < m; i++ )\n\t\tans = ( ans + a.a[ 0 ][ i ] ) % 1000000007;\n\tprintf(""%I64d\\n"", ans);\n\treturn 0;\n}\n']","['dp', 'matrices']",1900
https://codeforces.com//contest/1218/problem/D,D. Xor Spanning Tree,In the galaxy far far away is the ancient interplanetary republic of Bubbleland consisting of N planets Between them there are M bidirectional wormholes each connecting a pair of planets Bubbleland is a very centralized republic having a capital planet Whiteplanet from which any another planet can be reached using these wormholes It is also guaranteed that no wormhole connects planet to itself and that no two different wormholes connect same pair of planets We call a path that begins at one planet visits other planets and each of them at most once and returns to starting point a Interplanetary Safety Regulations guarantee that each planet belongs to at most one and that there are at most 42 After many eons of usage wormholes need to be repaired and each wormhole has the cost W i which needs to be payed for reparation Unfortunately the Senate of Bubbleland is short on budget Therefore they have decided only to fix as many wormholes as they need in order to have all planets reachable from capital and to pay as little money as they have to for this repair However the way in which the Senate calculates the cost is different Cost of the set of reparations is binary xor of costs of each individual reparation that is if reparations to be made have costs A 1 A 2 A k the cost of entire set is A 1 oplus A 2 oplus oplus A k Now the Senate would like to know how much money do they have to pay and also the number of different ways to achieve that cost ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\nconst int N = 100005, SZ = 131072, L = 17;\nll M = ll(1e9) + 7, MM = 998244353, ISZ = 742744451, ISZZ = 998236737;\n\nint Rev(int x) {\n    int i, r = 0;\n    for (i = 0; i < L; i++) {\n        r = r << 1 | x & 1;\n        x >>= 1;\n    }\n    return r;\n}\n \nvoid FFT(ll *a, bool f, ll M, ll ISZ) {\n    int i, j, k, z;\n    for (i = 0; i < SZ; i++) {\n        j = Rev(i);\n        if (i < j) {\n            z = a[i];\n            a[i] = a[j];\n            a[j] = z;\n        }\n    }\n    for (i = 1; i < SZ; i <<= 1) for (j = 0; j < SZ; j += i << 1) for (k = 0; k < i; k++) {\n        z = a[i + j + k];\n        a[i + j + k] = (a[j + k] - z + M) % M;\n        (a[j + k] += z) %= M;\n    }\n    if (f) for (i = 0; i < SZ; i++) a[i] = a[i] * ISZ % M;\n}\n\nint n, m, p[N], tt;\nvector<pii> e[N];\nll a[SZ], b[SZ], aa[SZ], bb[SZ];\n\nint f(int x){\n    if(x == p[x]) return x;\n    return p[x] = f(p[x]);\n}\n\nint g(int x, int y, int z){\n    if(x == z) return 1;\n    for(pii &i : e[x]){\n        if(i.x == y) continue;\n        if(!g(i.x, x, z)) continue;\n        b[i.y]++;\n        return 1;\n    }\n    return 0;\n}\n\nvoid h(){\n    memcpy(bb, b, sizeof(b));\n    FFT(b, 0, M, ISZ);\n    FFT(bb, 0, MM, ISZZ);\n    for(int i = 0; i < SZ; i++) (a[i] *= b[i]) %= M;\n    for(int i = 0; i < SZ; i++) (aa[i] *= bb[i]) %= MM;\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    iota(p, p+n+1, 0);\n    a[0] = aa[0] = 1;\n    FFT(a, 0, M, ISZ);\n    FFT(aa, 0, MM, ISZZ);\n    for(int x, y, z; m--; ){\n        cin >> x >> y >> z;\n        tt ^= z;\n        if(f(x) != f(y)){\n            p[f(y)] = f(x);\n            e[x].emplace_back(y, z);\n            e[y].emplace_back(x, z);\n        }\n        else{\n            memset(b, 0, sizeof(b));\n            b[z]++;\n            g(x, 0, y);\n            h();\n        }\n    }\n    memset(b, 0, sizeof(b));\n    b[tt] = 1;\n    h();\n    FFT(a, 1, M, ISZ);\n    FFT(aa, 1, MM, ISZZ);\n    for(int i = 0; ; i++) if(a[i] || aa[i]){\n        cout << i << ' ' << a[i] << '\\n';\n        return 0;\n    }\n}""]","['divide and conquer', 'fft', 'graphs']",2400
https://codeforces.com//contest/1650/problem/D,D. Twist the Permutation,Petya got an array a of numbers from 1 to n where a i i He performed n operations sequentially In the end he received a new state of the a array At the i th operation Petya chose the first i elements of the array and cyclically shifted them to the right an arbitrary number of times elements with indexes i 1 and more remain in their places One cyclic shift to the right is such a transformation that the array a a 1 a 2 dots a n becomes equal to the array a a i a 1 a 2 dots a i 2 a i 1 a i 1 a i 2 dots a n For example if a 5 4 2 1 3 and i 3 that is this is the third operation then as a result of this operation he could get any of these three arrays a 5 4 2 1 3 makes 0 cyclic shifts or any number that is divisible by 3 a 2 5 4 1 3 makes 1 cyclic shift or any number that has a remainder of 1 when divided by 3 a 4 2 5 1 3 makes 2 cyclic shifts or any number that has a remainder of 2 when divided by 3 Let s look at an example Let n 6 i e initially a 1 2 3 4 5 6 A possible scenario is described below i 1 no matter how many cyclic shifts Petya makes the array a does not change i 2 let s say Petya decided to make a 1 cyclic shift then the array will look like a textbf 2 textbf 1 3 4 5 6 i 3 let s say Petya decided to make 1 cyclic shift then the array will look like a textbf 3 textbf 2 textbf 1 4 5 6 i 4 let s say Petya decided to make 2 cyclic shifts the original array will look like a textbf 1 textbf 4 textbf 3 textbf 2 5 6 i 5 let s say Petya decided to make 0 cyclic shifts then the array won t change i 6 let s say Petya decided to make 4 cyclic shifts the array will look like a textbf 3 textbf 2 textbf 5 textbf 6 textbf 1 textbf 4 You are given a final array state a after all n operations Determine if there is a way to perform the operation that produces this result In this case if an answer exists print the numbers of cyclical shifts that occurred during each of the n operations ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector<ll> V;\nvoid solve(){\n\tint n; cin>>n;\n\tdeque<int>deq;\n\tfor(int i=1; i<=n; i++){\n\t\tint x; cin>>x;\n\t\tdeq.push_back(x);\n\t}\n\tint cur = n;\n\tvector<int>ans;\n\twhile(cur>0){\n\t\tint cnt = 0;\n\t\twhile(deq.back()!=cur){\n\t\t\tcnt++;\n\t\t\tdeq.push_back(deq.front());\n\t\t\tdeq.pop_front();\n\t\t}\n\t\tdeq.pop_back();\n\t\tans.emplace_back(cnt);\n\t\tcur--;\n\t}\n\tfor(int i=n-1; i>=0; i--) cout<<ans[i]<<"" ""; cout<<\'\\n\';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}']","['brute force', 'constructive algorithms', 'implementation', 'math']",1300
https://codeforces.com//contest/1295/problem/B,B. Infinite Prefixes,You are given string s of length n consisting of s and s You build an infinite string t as a concatenation of an infinite number of strings s or t ssss dots For example if s then t Calculate the number of prefixes of t with equal to x The balance of some string q is equal to cnt 0 q cnt 1 q where cnt 0 q is the number of occurrences of in q and cnt 1 q is the number of occurrences of in q The number of such prefixes can be infinite if it is so you must say that A prefix is a string consisting of several first letters of a given string without any reorders An empty prefix is also a valid prefix For example the string abcd has 5 prefixes empty string a ab abc and abcd ,"['// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n        assert(~c);\n    }\n    if (c == \'-\') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 1e5 + 5;\n\nchar s[N];\n\nvoid solve() {\n    int n, x;\n    scanf(""%d%d%s"", &n, &x, s);\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == \'0\') {\n            ++sum;\n        } else {\n            --sum;\n        }\n    }\n    int ans = 0, cur = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!sum) {\n            if (x == cur) {\n                puts(""-1"");\n                return;\n            }\n        } else if ((x - cur) % sum == 0) {\n            int l = (x - cur) / sum;\n            if (l >= 0) {\n                ++ans;\n            }\n        }\n        if (s[i] == \'0\') {\n            ++cur;\n        } else {\n            --cur;\n        }\n    }\n    printf(""%d\\n"", ans);\n}\n\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n']","['math', 'strings']",1700
https://codeforces.com//contest/1277/problem/D,D. Let s Play the Words ,Polycarp has n binary words A word called binary if it contains only characters and For example these words are binary and Polycarp wants to offer his set of n binary words to play a game words In this game players name words and each next word starting from the second must start with the last character of the previous word The first word can be any For example these sequence of words can be named during the game Word reversal is the operation of reversing the order of the characters For example the word after the reversal becomes the word after the reversal becomes Probably Polycarp has such a set of words that there is no way to put them in the order correspondent to the game rules In this situation he wants to reverse some words from his set so that the final set of n words still contains words i e all words are unique there is a way to put all words of the final set of words in the order so that the final sequence of n words is consistent with the game rules Polycarp wants to reverse minimal number of words Please help him ,"['#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(t_, t){\n    int n;cin>>n;\n    vector<int> n01,n00,n10,n11;\n    vector<string> s01,s10;\n    reps(i,n){\n      string s;\n      cin>>s;\n      if(s[0] == \'0\'){\n        if(s[s.size()-1] == \'0\'){\n          n00.push_back(i);\n        }else{\n          n01.push_back(i);\n          s01.push_back(s);\n        }\n      }else{\n        if(s[s.size()-1] == \'0\'){\n          n10.push_back(i);\n          s10.push_back(s);\n        }else{\n          n11.push_back(i);\n        }\n      }\n    }\n    if(n01.size() == 0 && n10.size() == 0 && n00.size() > 0 && n11.size() > 0){\n      cout<<-1<<endl;\n      continue;\n    }\n    if(n01.size() > n10.size()){\n      vector<int> tmp = n01;\n      n01 = n10;\n      n10 = tmp;\n      vector<string> tmps = s01;\n      s01 = s10;\n      s10 = tmps;\n    }\n    set<string> used;\n    rep(i, n01.size()){\n      reverse(all(s01[i]));\n      used.insert(s01[i]);\n    }\n    cout<<(n10.size() - n01.size())/2<<endl;\n    int count = 0;\n    int i = 0;\n    while(count < (n10.size() - n01.size())/2){\n      if(used.count(s10[i]) > 0){\n        i++;\n        continue;\n      }\n      cout<<n10[i]<<"" "";\n      count++;\n      i++;\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}\n']","['data structures', 'hashing', 'implementation', 'math']",1900
https://codeforces.com//contest/596/problem/A,A. Wilbur and Swimming Pool,After making bad dives into swimming pools Wilbur wants to build a swimming pool in the shape of a rectangle in his backyard He has set up coordinate axes and he wants the sides of the rectangle to be parallel to them Of course the area of the rectangle must be positive Wilbur had all four vertices of the planned pool written on a paper until his friend came along and erased some of the vertices Now Wilbur is wondering if the remaining vertices of the initial rectangle give enough information to restore the area of the planned swimming pool ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nset<int> x, y;\nmap<int, int> cntx, cnty;\n\nvoid ex () {\n    cout << -1 << endl;\n    exit(0);\n}\n\nint32_t main () {\n    ios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        int a, b; cin >> a >> b;\n        cntx[a]++;\n        cnty[b]++;\n        x.insert(a);\n        y.insert(b);    \n    }\n    if ((int) x.size() == 2 && (int) y.size() == 2) {\n        auto it1 = x.begin(); if (cntx[*it1] > 2) ex(); it1++;if (cntx[*it1] > 2) ex();\n        auto it2 = y.begin(); if (cnty[*it2] > 2) ex(); it2++;if (cnty[*it2] > 2) ex();\n        cout << (*it1 - *(x.begin())) * (*it2 - *(y.begin()));\n    } else {\n        cout << -1; \n    }\n        \n            \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","['geometry', 'implementation']",1100
https://codeforces.com//contest/438/problem/C,C. The Child and Polygon,This time our child has a simple polygon He has to find the number of ways to split the polygon into non degenerate triangles each way must satisfy the following requirements each vertex of each triangle is one of the polygon vertex each side of the polygon must be the side of exactly one triangle the area of intersection of every two triangles equals to zero and the sum of all areas of triangles equals to the area of the polygon each triangle must be completely inside the polygon The picture below depicts an example of a correct splitting Please help the child Calculate the described number of ways modulo for him ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef linux\n#define LLD ""%lld""\n#else\n#define LLD ""%I64d""\n#endif\n\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double INF = inf;\nconst double EPS = eps;\n\nconst int mod = inf+7;\n\ninline void madd (int& a, int b)\n{\n  a+=b;\n  if (a>=mod)\n    a-=mod;\n}\n\nint mul (int a, int b)\n{\n  return (a*1ll*b)%mod;\n}\n\npii operator - (const pii& a, const pii& b)\n{\n  return mp(a.first-b.first,a.second-b.second);\n}\n                         \nll operator ^ (const pii& a, const pii& b)\n{\n  return a.first*1ll*b.second-a.second*1ll*b.first;\n}\n\nint n;\n//bool can[210][210];\nint D[210][210];\npii P[410];\nll S[210][210][210];\n\ninline bool check (int a, int b, int c)\n{\n  //cerr<<a<<"" ""<<b<<"" ""<<c<<endl;\n  int i;\n  ll s=S[a][b][c];\n  for (i=0; i<a; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=a+1; i<b; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=b+1; i<c; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=c+1; i<n; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  //cerr<<a<<"" ""<<b<<"" ""<<c<<endl;\n  return 1;\n}\n\nint main()\n{\n  int i, j, len, k;//l, r;\n  #ifdef LOCAL\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n  scanf(""%d"", &n);\n  for (i=0; i<n; i++)\n    scanf(""%d%d"", &P[i].first, &P[i].second);\n  for (i=n-1; i>=0; i--)\n    P[i]=P[i]-P[0];\n  ll s=0;\n  for (i=1; i<n-1; i++)\n    s+=(P[i]^P[i+1]);\n  if (s<0)\n    reverse(P+1,P+n);\n  for (i=0; i<n; i++)\n    P[i+n]=P[i];\n  for (i=0; i<n; i++)\n    for (j=0; j<n; j++)\n      for (k=0; k<n; k++)\n        S[i][j][k]=abs((P[i]-P[k])^(P[j]-P[k]));\n  //TIMESTAMP(cs);\n  /*for (i=0; i<n; i++)\n    for (j=0; j<n; j++)\n      if (i!=j)\n      {\n        can[i][j]=1;\n        pii diff=P[j]-P[i];\n        if (i<j)\n          l=i+1, r=j;\n        else\n          l=i+1, r=j+n;\n        while (l<r)\n        {\n          if (((P[l]-P[i])^diff)<=0)\n          {\n            can[i][j]=0;\n            break;\n          }\n          l++;\n        }\n        //cerr<<i<<"" ""<<j<<"" ""<<can[i][j]<<endl;\n      }   */\n  for (i=0; i<n-1; i++)\n    D[i][i+1]=1;\n  for (len=2; len<n; len++)\n    for (i=0; i+len<n; i++)\n    {\n      for (j=i+1; j<i+len; j++)\n      {\n        if (check(i,j,i+len))\n          madd(D[i][i+len],mul(D[i][j],D[j][i+len]));\n      }\n      //cerr<<len<<"" ""<<i<<"" ""<<D[[j]\n    }\n  printf(""%d\\n"", D[0][n-1]);\n  TIMESTAMP(end);\n  return 0;\n}\n']","['dp', 'geometry']",2500
https://codeforces.com//contest/796/problem/B,B. Find The Bone,Zane the wizard is going to perform a magic show shuffling the cups There are cups numbered from to placed along the axis on a table that has holes on it More precisely cup is on the table at the position The problematic bone is initially at the position Zane will confuse the audience by swapping the cups times the th time of which involves the cups at the positions and If the bone happens to be at the position where there is a hole at any time it will fall into the hole onto the ground and will not be affected by future swapping operations Do not forget that Zane is a wizard When he swaps the cups he does not move them ordinarily Instead he teleports the cups along with the bone if it is inside to the intended positions Therefore for example when he swaps the cup at and the one at they will not be at the position at any moment during the operation Zane s puppy Inzane is in trouble Zane is away on his vacation and Inzane cannot find his beloved bone as it would be too exhausting to try opening all the cups Inzane knows that the Codeforces community has successfully helped Zane so he wants to see if it could help him solve his problem too Help Inzane determine the final position of the bone ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, h[1000020];\nbool fall;\nint bone, x, y;\nint main() {\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tbone = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%d"", &x);\n\t\th[x] = 1;\n\t}\n\tif (h[1] == 1) {\n\t\tfall = true;\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(""%d%d"", &x, &y);\n\t\tif (fall) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == bone) {\n\t\t\tbone = y;\n\t\t} else if (y == bone) {\n\t\t\tbone = x;\n\t\t}\n\t\tif (h[bone] == 1) {\n\t\t\tfall = true;\n\t\t}\n\t}\n\tprintf(""%d\\n"", bone);\n}']",['implementation'],1300
https://codeforces.com//contest/1941/problem/A,A. Rudolf and the Ticket,Rudolf is going to visit Bernard and he decided to take the metro to get to him The ticket can be purchased at a machine that accepts exactly two coins the sum of which does not exceed k Rudolf has two pockets with coins In the left pocket there are n coins with denominations b 1 b 2 dots b n In the right pocket there are m coins with denominations c 1 c 2 dots c m He wants to choose exactly one coin from the left pocket and exactly one coin from the right pocket two coins in total Help Rudolf determine how many ways there are to select indices f and s such that b f c s le k ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n , m , k ;\n    cin >> n >> m >> k ;\n    int a[ n ] , b[ m ] ;\n    FOR( i , n ) cin >> a[ i ] ;\n    FOR( i , m ) cin >> b[ i ] ;\n    int ans = 0 ; \n    FOR( i , n ){\n    \tFOR( j , m ){\n    \t\tif( a[ i ] + b[ j ] <= k ) ans ++ ;\n\t\t}\n\t}\n    cout << ans << ""\\n"" ;\n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']","['brute force', 'math']",800
https://codeforces.com//contest/796/problem/F,F. Sequence Recovery,Zane once had a sequence consisting of integers but he has lost it A sequence is said to be if and only if all of its integers are non negative and do not exceed in value However Zane remembers having played around with his sequence by applying operations to it There are two types of operations 1 Find the maximum value of integers with indices such that given and 2 Assign as the value of the integer with index given and After he finished playing he restored his sequence to the state it was before any operations were applied That is sequence was no longer affected by the applied type 2 operations Then he lost his sequence at some time between now and then Fortunately Zane remembers all the operations and the order he applied them to his sequence along with the results of all type 1 operations Moreover among all sequences that would produce the same results when the same operations are applied in the same order he knows that his sequence has the greatest We define of a sequence as the bitwise OR result of all integers in such sequence For example the of Zane s sequence is Zane understands that it might not be possible to recover exactly the lost sequence given his information so he would be happy to get any sequence consisting of integers that 1 would give the same results when the same operations are applied in the same order and2 has the same as that of Zane s original sequence If there is such a sequence find it Otherwise it means that Zane must have remembered something incorrectly which is possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define oo 1000000010\n#define mod 1000000007\nconst int N = 300010;\nint n , m ;\n\nint t[N] , l[N] , r[N] , x[N];\n\nint arr[N];\n\nint cnt = 0;\n\nint seg[4 * N];\n\nbool done[N];\n\nint Mx;\n\nint build(int s,int e,int idx){\n    if(s == e)\n        return seg[idx] = arr[s];\n    return seg[idx] = max(build(s,((s+e) >> 1),(idx << 1)),build(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nint L , R , val;\n\nvoid update2(int s,int e,int idx){\n    if(s > R || e < L) return;\n    if(s >= L && e <= R){\n        seg[idx] = min(seg[idx] , val);\n        return;\n    }\n    update2(s,((s+e) >> 1),(idx << 1));\n    update2(((s+e) >> 1) + 1,e,(idx << 1) + 1);\n}\n\nint get2(int i){\n    int s = 0 , e = n - 1 , res = Mx , idx = 1;\n    while(true){\n        res = min(res , seg[idx]);\n        if(s == e) break;\n        if(i > ((s + e) >> 1)){\n            s = ((s + e) >> 1) + 1;\n            idx = (idx << 1) + 1;\n        }\n        else{\n            e = ((s+e) >> 1);\n            idx = (idx << 1);\n        }\n    }\n    return res;\n}\n\nint update(int s,int e,int idx){\n    if(s > R || e < L) \n        return seg[idx];\n    if(s == e)\n        return seg[idx] = val;\n    return seg[idx] = max(update(s,((s+e) >> 1),(idx << 1)) , update(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nint getmax(int s,int e,int idx){\n    if(s > R || e < L)\n        return 0;\n    if(s >= L && e <= R)\n        return seg[idx];\n    return max(getmax(s,((s+e) >> 1),(idx << 1)) , getmax(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nbool check(int Val){\n    Mx = Val;\n    for(int i = 0 ;i < n;i++) \n        arr[i] = Val , done[i] = false;\n    build(0,n-1,1);\n    for(int i = 0 ;i < m;i++){\n        if(t[i] == 2){\n            if(done[l[i]]) continue;\n            arr[l[i]] = get2(l[i]);\n            done[l[i]] = true;\n            continue;\n        }\n        L = l[i] , R = r[i] , val = x[i];\n        update2(0, n - 1 , 1);\n    }\n    for(int i = 0 ;i < n;i++){\n        if(!done[i])\n            arr[i] = get2(i);\n    }\n    build(0,n-1,1);\n    for(int i = 0 ;i < m;i++){\n        if(t[i] == 2){\n            L = R = l[i];\n            val = x[i];\n            update(0,n-1,1);\n        }\n        else{\n            L = l[i] , R = r[i];\n            if(getmax(0,n-1,1) != x[i])\n                return false;\n        }\n    }\n    return true;\n}\n\nmap < int , bool > Done;\n\ninline int get(int val){\n    for(int i = 29 ;i >= 0 ;i--){\n        if(((val >> i) & 1) == 1)\n            return (1 << i) - 1;\n    }\n    return 0; \n}\n\nint main(){\n    scanf(""%d%d"",&n,&m);\n    for(int i = 0 ;i < m;i++){\n        scanf(""%d%d%d"",&t[i],&l[i],&r[i]);\n        if(t[i] == 1){\n            l[i]--,r[i]--;\n            scanf(""%d"",&x[i]);\n        }\n        else{\n            x[i] = r[i];\n            l[i]--;\n            r[i] = l[i];\n        }\n    }\n    int val = (int)1e9 + 1;\n    if(!check(val)){\n        puts(""NO"");\n        return 0;\n    }\n    puts(""YES"");\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] == val) continue;\n        if(Done[arr[i]]){\n            arr[i] = get(arr[i]);\n            continue;\n        }\n        Done[arr[i]] = true;\n    }\n    int o = 0;\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] == val){\n            continue;\n        }\n        o |= arr[i];\n    }\n    o ^= ((1 << 30) - 1);\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] != val) continue;\n        arr[i] = 0;\n        for(int j = 29 ;j >=0 ;j--){\n            if(((o >> j) & 1) == 0) continue;\n            if((arr[i] ^ (1 << j)) >= val) continue;\n            arr[i] ^= (1 << j);\n            o ^= (1 << j);\n        }\n    }\n\n    for(int i = 0 ;i < n;i++){\n        if(i) putchar(\' \');\n        printf(""%d"",arr[i]);\n    }\n    puts("""");\n    return 0;\n}']","['bitmasks', 'data structures', 'greedy']",2800
https://codeforces.com//contest/266/problem/D,D. BerDonalds,BerDonalds a well known fast food restaurant is going to open a cafe in Bertown The important thing is to choose the new restaurant s location so that it would be easy to get there The Bertown road system is represented by junctions connected by bidirectional roads For each road we know its length We also know that we can get from any junction to any other one moving along the roads Your task is to find such location of the restaurant that the shortest distance along the roads from the cafe to the farthest junction would be minimum Note that the restaurant can be located not only on the junction but at any point of any road ,"['#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <set>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ndouble anss;\nint hh[210],ecnt;\nint n;\nint in[210],dis[210][210];\nint tdis1[210],tdis2[210];\ndouble cal(double l,double w)\n{\n    double anss=0;\n    for (int i=1; i<=n; i++)\n    {\n        if (tdis1[i]==-1) anss=max(anss,w-l+tdis2[i]);\n        else if (tdis2[i]==-1) anss=max(anss,l+tdis1[i]);\n        else anss=max(anss,min(w-l+tdis2[i],l+tdis1[i]));\n    }\n    return anss;\n}\nint uu[40010],vv[40010],ww[40010];\nstruct node\n{\n    double l,r;\n};\nnode p[210];\nint sgn(double x)\n{\n    if (fabs(x)<1e-10) return 0;\n    return x>0?1:-1;\n}\nbool cmp(const node &a,const node &b)\n{\n    if (sgn(a.l-b.l)!=0) return a.l<b.l;\n    return a.r>b.r;\n}\nint main()\n{\n    int m;\n    scanf(""%d%d"",&n,&m);\n    memset(dis,-1,sizeof(dis));\n    for (int i=0; i<m; i++)\n    {\n        scanf(""%d%d%d"",&uu[i],&vv[i],&ww[i]);\n        int u=uu[i],v=vv[i],w=ww[i];\n        if (dis[u][v]==-1||dis[u][v]>w)\n            dis[u][v]=dis[v][u]=w;\n    }\n    anss=-100;\n    for (int i=1; i<=n; i++)\n        dis[i][i]=0;\n    for (int k=1; k<=n; k++)\n        for (int i=1; i<=n; i++)\n            for (int j=1; j<=n; j++)\n            {\n                if (dis[i][k]==-1) continue;\n                if (dis[k][j]==-1) continue;\n                if (dis[i][j]==-1||dis[i][j]>dis[i][k]+dis[k][j])\n                    dis[i][j]=dis[i][k]+dis[k][j];\n            }\n    int maxx=0;\n    for (int s=1; s<=n; s++)\n    {\n        for (int i=1; i<=n; i++)\n            maxx=max(maxx,dis[s][i]);\n        if (anss<-50) anss=maxx*1.0;\n        else anss=min(anss,maxx*1.0);\n    }\n    double L=0;\n    double R=anss;\n    for (int i=0; i<m; i++)\n    {\n        int u=uu[i],v=vv[i],w=ww[i];\n        for (int k=1; k<=n; k++)\n            tdis1[k]=tdis2[k]=-1;\n        bool ck=true;\n        int maxx=0;\n        for (int k=1; k<=n; k++)\n        {\n            if (dis[v][k]+w>dis[u][k])\n                tdis1[k]=dis[u][k];\n            if (dis[u][k]+w>dis[v][k])\n                tdis2[k]=dis[v][k];\n            int minn=tdis1[k];\n            if (minn==-1||(tdis2[k]!=-1&&minn>tdis2[k])) minn=tdis2[k];\n            maxx=max(maxx,minn);\n            if (minn>R)\n            {\n                ck=false;\n                break;\n            }\n        }\n        if (!ck) continue;\n        L=maxx;\n        while (fabs(L-R)>1e-9)\n        {\n            double mid=(L+R)/2.0;\n            for (int j=1;j<=n;j++)\n            {\n                p[j-1].l=min(w*1.0,mid-dis[u][j]);\n                p[j-1].r=w-min(w*1.0,mid-dis[v][j]);\n                p[j-1].l=max(p[j-1].l,0.0);\n                p[j-1].r=min(p[j-1].r,w*1.0);\n            }\n            sort(p,p+n,cmp);\n            double ll=0,rr=0;\n            bool ok=false;\n            for (int j=0;j<n;j++)\n            {\n                if (sgn(rr-w)==0) break;\n                if (sgn(p[j].l-rr)>0)\n                {\n                    ok=true;\n                    break;\n                }\n                else rr=max(p[j].r,rr);\n            }\n            if (sgn(rr-w)<0) ok=true;\n            if (ok) R=mid;\n            else L=mid;\n        }\n        anss=min(anss,L);\n    }\n    printf(""%.15f\\n"",anss);\n}\n']","['graphs', 'math', 'shortest paths']",2400
https://codeforces.com//contest/363/problem/C,C. Fixing Typos,Many modern text editors automatically check the spelling of the user s text Some editors even suggest how to correct typos In this problem your task to implement a small functionality to correct two types of typos in a word We will assume that three identical letters together is a typo for example word contains a typo Besides a couple of identical letters immediately followed by another couple of identical letters is a typo too for example words and contain typos Write a code that deletes the minimum number of letters from a word correcting described typos in the word You are allowed to delete letters from both ends and from the middle of the word ,"['#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <ctime>\n#include <deque>\n#include <bitset>\n#include <cctype>\n#include <utility>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\n#define Rep(i,n) for(int i = 0; i < (n); ++i)\n#define Repd(i,n) for(int i = (n)-1; i >= 0; --i)\n#define For(i,a,b) for(int i = (a); i <= (b); ++i)\n#define Ford(i,a,b) for(int i = (a); i >= (b); --i)\n#define Fit(i,v) For(__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++i)\n#define Fitd(i,v) For(__typeof((v).rbegin()) i = (v).rbegin(); i != (v).rend(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(), (a).end()\n#define ms(a,x) memset(a, x, sizeof(a))\n\ntemplate<class F, class T> T convert(F a, int p = -1) { stringstream ss; if (p >= 0) ss << fixed << setprecision(p); ss << a; T r; ss >> r; return r; }\ntemplate<class T> T gcd(T a, T b) { T r; while (b != 0) { r = a % b; a = b; b = r; } return a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<class T> T sqr(T x) { return x * x; }\ntemplate<class T> T cube(T x) { return x * x * x; }\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcount(s); }\nconst int bfsz = 1 << 16; char bf[bfsz + 5]; int rsz = 0;int ptr = 0;\nchar gc() { if (rsz <= 0) { ptr = 0; rsz = (int) fread(bf, 1, bfsz, stdin); if (rsz <= 0) return EOF; } --rsz; return bf[ptr++]; }\nvoid ga(char &c) { c = EOF; while (!isalpha(c)) c = gc(); }\nint gs(char s[]) { int l = 0; char c = gc(); while (isspace(c)) c = gc(); while (c != EOF && !isspace(c)) { s[l++] = c; c = gc(); } s[l] = \'\\0\'; return l; }\ntemplate<class T> bool gi(T &v) {\n    v = 0; char c = gc(); while (c != EOF && c != \'-\' && !isdigit(c)) c = gc(); if (c == EOF) return false; bool neg = c == \'-\'; if (neg) c = gc();\n    while (isdigit(c)) { v = v * 10 + c - \'0\'; c = gc(); } if (neg) v = -v; return true;\n}\n\ntypedef pair<int, int> II;\n\nconst ld PI = acos(ld(-1.0));\nconst ld eps = 1e-9;\n\nconst int inf = (int)1e9 + 5;\nconst ll linf = (ll)1e17 + 5;\nint dr[4] = {-1, 0, +1, 0};\nint dc[4] = {0, -1, 0, +1};\nconst ll mod = 1000000007;\n\n#define maxn 1000015\n\nint len, n;\nint a[maxn];\nchar ch[maxn];\nstring s;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(""in.txt"", ""r"", stdin);\n    cin >> s;\n    len = (int)s.length();\n    int run = 1, n = 0;\n    For(i, 1, len - 1){\n        if(s[i] == s[i - 1]) run++;\n        else{\n            n++;\n            ch[n] = s[i - 1];\n            a[n] = run;\n            run = 1;\n        }\n    }\n    n++; ch[n] = s[len - 1]; a[n] = run;\n    bool have = false;\n    For(i, 1, n){\n        if(a[i] >= 2){\n            if(have){\n                a[i] = 1;\n                have = false;\n            }\n            else{\n                a[i] = 2;\n                have = true;\n            }\n        }\n        else have = false;\n    }\n\n    string res = """";\n    For(i, 1, n){\n        Rep(j, a[i]){\n            res.pb(ch[i]);\n        }\n    }\n    cout << res;\n\n    return 0;\n}\n']","['greedy', 'implementation']",1400
https://codeforces.com//contest/832/problem/B,B. Petya and Exam,It s hard times now Today Petya needs to score 100 points on Informatics exam The tasks seem easy to Petya but he thinks he lacks time to finish them all so he asks you to help with one There is a glob pattern in the statements a string consisting of lowercase English letters characters and It is known that character occurs in the pattern Also query strings are given it is required to determine for each of them if the pattern matches it or not Everything seemed easy to Petya but then he discovered that A pattern matches a string if it is possible to replace each character with one lowercase English letter and the character if there is one with any including empty string of lowercase English letters so that the resulting string is the same as the given string The good letters are given to Petya All the others are bad ,"['#include<stdio.h>\n#include<string.h>\n\nint isgood[26]; char gd[30], wild[101010]; int wcn, asix=-1;\nchar str[101010]; int len;\n\nint match(){\n\tif(asix < 0){\n\t\tif(len != wcn) return 0;\n\t\tfor(int i=0; i<len; i++){\n\t\t\tif(wild[i] == \'?\' && !isgood[str[i]-\'a\']) return 0;\n\t\t\tif(wild[i] != \'?\' && str[i]!=wild[i]) return 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tif(len < wcn-1) return 0;\n\tfor(int i=0; i<asix; i++){\n\t\tif(wild[i] == \'?\' && !isgood[str[i]-\'a\']) return 0;\n\t\tif(wild[i] != \'?\' && str[i]!=wild[i]) return 0;\n\t}\n\tfor(int i=asix+1; i<wcn; i++){\n\t\tint j = len-1 - (wcn-1 - i);\n\t\tif(wild[i] == \'?\' && !isgood[str[j]-\'a\']) return 0;\n\t\tif(wild[i] != \'?\' && str[j]!=wild[i]) return 0;\n\t}\n\tfor(int i=asix; i<len-1 - (wcn-1 - (asix+1)); i++){\n\t\tif(isgood[str[i]-\'a\']) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\tscanf(""%s\\n%s"", gd, wild); wcn = strlen(wild);\n\tfor(int i=0; gd[i]; i++) isgood[gd[i]-\'a\']=1;\n\tfor(int i=0; i<wcn; i++){\n\t\tif(wild[i] == \'*\') asix = i;\n\t}\n\tint Q;\n\tfor(scanf(""%d"",&Q); Q--;){\n\t\tscanf(""\\n%s"", str); len=strlen(str);\n\t\tputs(match() ? ""YES"" : ""NO"");\n\t}\n\treturn 0;\n}\n']","['implementation', 'strings']",1600
https://codeforces.com//contest/1847/problem/D,D. Professor Higashikata,Josuke is tired of his peaceful life in Morioh Following in his nephew Jotaro s footsteps he decides to study hard and become a professor of computer science While looking up competitive programming problems online he comes across the following one Let s be a binary string of length n An operation on s is defined as choosing two distinct integers i and j 1 leq i j leq n and swapping the characters s i s j Consider the m strings t 1 t 2 ldots t m where t i is the substring dagger of s from l i to r i Define t s t 1 t 2 ldots t m as the concatenation of the strings t i in that order There are q updates to the string In the i th update s x i gets flipped That is if s x i 1 then s x i becomes 0 and vice versa After each update find the minimum number of to make t s lexicographically as large ddagger as possible Note that no operation is actually performed We are only interested in the number of operations Help Josuke in his dream by solving the problem for him dagger A string a is a substring of a string b if a can be obtained from b by the deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ddagger A string a is lexicographically larger than a string b of the same length if and only if the following holds in the first position where a and b differ the string a has a 1 and the string b has a 0 ,"[""#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define N 300'005\n\nint n, m, q, l[N], r[N], id[N], tot;\nstring s;\nstruct BIT\n{\n    int s[N];\n    int lowbit(int x) { return x & -x; }\n    void update(int x, int y)\n    {\n        while (x < N)\n        {\n            s[x] += y;\n            x += lowbit(x);\n        }\n    }\n    int query(int x)\n    {\n        int res = 0;\n        while (x)\n        {\n            res += s[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n} tr;\nvoid solve()\n{\n    cin >> n >> m >> q >> s;\n    s = ' ' + s;\n    for (int i = 1; i <= m; i++)\n        cin >> l[i] >> r[i];\n    set<int> num;\n    for (int i = 1; i <= n; i++)\n        num.insert(i);\n    for (int i = 1; i <= m; i++)\n    {\n        auto it = num.lower_bound(l[i]);\n        while (it != num.end() && *it <= r[i])\n        {\n            int u = *it;\n            it++;\n            id[u] = ++tot;\n            num.erase(u);\n        }\n    }\n    int cnt1 = 0, limit = tot;\n    for (int i : num)\n        id[i] = ++tot;\n    for (int i = 1; i <= n; i++)\n    {\n        if (s[i] == '1')\n            cnt1++;\n        else\n            tr.update(id[i], 1);\n    }\n    while (q--)\n    {\n        int x;\n        cin >> x;\n        if (s[x] == '1')\n        {\n            cnt1--;\n            tr.update(id[x], 1);\n            int sum = min(limit, cnt1);\n            cout << tr.query(sum) << '\\n';\n            s[x] = '0';\n        }\n        else\n        {\n            cnt1++;\n            tr.update(id[x], -1);\n            int sum = min(limit, cnt1);\n            cout << tr.query(sum) << '\\n';\n            s[x] = '1';\n        }\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}""]","['data structures', 'dsu', 'greedy', 'implementation', 'strings']",1900
https://codeforces.com//contest/145/problem/B,B. Lucky Number 2,Petya loves long lucky numbers very much He is interested in the lucky number that meets some condition Let be the number of occurrences of number in number as a substring For example if then Petya wants the following condition to fulfil simultaneously Petya is not interested in the occurrences of other numbers Help him cope with this task ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\nint n4,n7,n47,n74;\n\nbool solve()\n{\n\tif (abs(n47-n74)>1) return false;\n\tREP(fst,10) if (fst==4||fst==7)\n\t{\n\t\tif (fst==4 && n47 < n74) continue;\n\t\tif (fst==7 && n47 > n74) continue;\n\t\tint mn4 = (fst==4 ? 1 : 0) + n74;\n\t\tint mn7 = (fst==7 ? 1 : 0) + n47;\n\t\tif (mn4 > n4 || mn7 > n7) continue;\n\t\tVI order;\n\t\tint groups = n47+n74+1;\n\t\tint e4 = n4-mn4;\n\t\tint e7 = n7-mn7;\n\t\tREP(i,groups)\n\t\t{\n\t\t\tint cur = ((fst==4) ^ (i%2 == 0) ^ 1) ? 4 : 7;\n\t\t\tprintf(""%d"",cur);\n\t\t\tif (i<=1 && cur == 4)\n\t\t\t\tREP(i,e4) printf(""4"");\n\t\t\tif (i>=groups-2 && cur==7)\n\t\t\t\tREP(i,e7) printf(""7"");\n\t\t}\n\t\tprintf(""\\n"");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tscanf(""%d%d%d%d"",&n4,&n7,&n47,&n74);\n\tif (!solve())\n\t\tprintf(""-1\\n"");\n\treturn 0;\n}']",['constructive algorithms'],1800
https://codeforces.com//contest/1133/problem/C,C. Balanced Team,You are a coach at your local university There are n students under your supervision the programming skill of the i th student is a i You have to create a team for a new programming competition As you know the more students some team has the more probable its victory is So you have to create a team with the maximum number of students But you also know that a team should be It means that the programming skill of each pair of students in a created team should differ by no more than 5 Your task is to report the maximum possible number of students in a team ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define INF 9223372036854775807\n#define M_PI 3.14159265358979323846\n\nint mod = INF;\n\nint fastPow(int b, int e){int r = 1;while(e){if(e%2 == 1){r*=b;r%=mod;}b*=b;b%=mod;e/=2;}return r;}\nint pgcd(int a, int b){ if(a%b == 0) return b; else return pgcd(b, a%b);}\nint sign(int a){if(a < 0){ return -1;}if(a == 0) {return 0;}return 1;}\nbool isPrime(int a){if(a == 1) {return false;}int f = sqrt(a);for(int i = 2; i<=f; i++){if(a%i == 0){return false;}}return true;}\nint toInt(string s){int tot = 0;for(int i = s.size()-1; i >= 0; i--){tot+=((s[i]-\'0\')%mod)*fastPow(10,i);tot%=mod;}return tot;}\nstring toString(int a){string s = """";while(a){s = (char)(\'0\'+a%10) + s;a/=10;}return s;}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for(int i = 0; i < n; i++){\n        cin >> v[i];\n    }\n    sort(v.begin(), v.end());\n    int ans = 1;\n\n    for(int i = 0; i < n; i++){\n        int l = lower_bound(v.begin(), v.end(), v[i]-5)-v.begin();\n        int r = i;\n        if(l > r) continue;\n        ans = max(ans, r-l+1);\n    }\n\n    cout << ans << endl;\n}\n']","['sortings', 'two pointers']",1200
https://codeforces.com//contest/540/problem/E,E. Infinite Inversions,There is an infinite sequence consisting of all positive integers in the increasing order We performed operations with this sequence A is an operation of swapping the elements of the sequence on positions and Your task is to find the number of inversions in the resulting sequence i e the number of such index pairs that and ,"['#include<bits/stdc++.h>\n#define sz(x) int((x).size())\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> PII;\ntypedef std::pair<ll,ll> PLL;\n\ntemplate<class T> inline T pr(T x) { return --x; }\ntemplate<class T> inline T nx(T x) { return ++x; }\n\nconst int maxn = 200010;\nint n,a[maxn],b[maxn];\nvector<int> x,y;\nunordered_map<int,int> id;\n\nconst int T_maxn = maxn*2;\nstruct Trray {\n\tint c[T_maxn+10];\n\tinline int bit(int x) { return x&(-x); }\n\tinline void clr() { memset(c,0,sizeof(c)); }\n\tint add(int i,int k) {\n\t\tfor (; i<=T_maxn; i+=bit(i)) c[i] += k;\n\t}\n\tint pf(int i) {\n\t\tif (i<=0) return 0;\n\t\tint r = 0;\n\t\tfor (; i; i-=bit(i)) r += c[i];\n\t\treturn r;\n\t}\n\tinline int get(int i,int j) { return i>j?0:pf(j)-pf(i-1); }\n}ta;\n\nint main() {\n    int i,j,k,t,tt,T,Test;\n    scanf(""%d"",&n);\n    for (i=1; i<=n; ++i) {\n        scanf(""%d%d"",a+i,b+i);\n        x.push_back(a[i]); x.push_back(b[i]);\n    }\n    sort(x.begin(),x.end());\n    x.resize( unique(x.begin(),x.end()) - x.begin() );\n    for (i=0; i<sz(x); ++i) y.push_back(i);\n    for (i=1; i<=n; ++i) {\n        a[i] = lower_bound(x.begin(),x.end(),a[i]) - x.begin();\n        b[i] = lower_bound(x.begin(),x.end(),b[i]) - x.begin();\n        swap(y[a[i]],y[b[i]]);\n    }\n    ll ans = 0;\n    for (int e:y) {\n        ans += (ll)ta.get(e+2,sz(y));\n        ta.add(e+1,1);\n    }\n    for (i=0; i<sz(x); ++i) {\n        if (y[i]<i) {\n            t = x[i]-1-x[y[i]]-(i-y[i]-1);\n            ans += (ll)t;\n        }\n        else if (y[i]>i) {\n            ans += (ll)(t=x[y[i]]-x[i]-1-(y[i]-i-1));\n        }\n    }\n    printf(""%I64d\\n"",ans);\n\n    return 0;\n}\n']","['binary search', 'data structures', 'implementation', 'sortings', 'trees']",2100
https://codeforces.com//contest/253/problem/E,E. Printer,Let s consider a network printer that functions like that It starts working at time 0 In each second it can print one page of a text At some moments of time the printer receives printing tasks We know that a printer received tasks Let s number the tasks by consecutive integers from 1 to Then the task number is characterised by three integers is the time when the task came is the task s volume in pages and is the task s priority The priorities of all tasks are distinct When the printer receives a task the task goes to the queue and remains there until all pages from this task are printed The printer chooses a page to print each time when it either stops printing some page or when it is free and receives a new task Among all tasks that are in the queue at this moment the printer chooses the task with the highest priority and next second prints an unprinted page from this task You can assume that a task goes to the queue immediately that s why if a task has just arrived by time the printer can already choose it for printing You are given full information about all tasks except for one you don t know this task s priority However we know the time when the last page from this task was finished printing Given this information find the unknown priority value and determine the moments of time when the printer finished printing each task ,"['#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef set<pii>::iterator vit;\n\nstruct TASK\n{\n    int t;\n    int s;\n    int p;\n    int id;\n    ll FT;\n    inline bool operator<(const TASK& b) const \n    {\n        return t == b.t ? s > b.s : t < b.t;\n    }\n};\nTASK Tasks[55555];\n\npii ps[55555];\n\nll ftans[55555];\n\nint main(void)\n{\n    freopen(""input.txt"",""rt"",stdin);\n    freopen(""output.txt"",""wt"",stdout);\n    int n = 0;\n    scanf(""%d"",&n);\n    int target = -1;\n    for(int i = 0;i < n;i++)\n    {\n        scanf(""%d %d %d"",&Tasks[i].t,&Tasks[i].s,&Tasks[i].p);\n        Tasks[i].id = i;\n    }\n    \n    ll T = 0;\n    scanf(""%I64d"",&T);\n\n    sort(Tasks,Tasks+n);\n    for(int i = 0;i < n;i++) if(Tasks[i].p == -1) target = i;\n\n    ll inside = T-Tasks[target].t-Tasks[target].s;\n    set<pii> que;\n    int maxx = (int)1e9+1;\n    int minx = 0;\n    // result in (minx,maxx), take (minx+maxx)/2\n    for(int i = 0;i < n;i++)\n    {\n        if(i && Tasks[i].t != Tasks[i-1].t)\n        {\n            ll ft = Tasks[i].t-Tasks[i-1].t;\n            ll ct = Tasks[i-1].t;\n            while(ft && que.size())\n            {\n                vit it = que.begin();\n                int tid = it->second;\n                int cost = min<ll>(ft,Tasks[tid].s);\n                ct += cost;\n                Tasks[tid].s -= cost;\n                ft -= cost;\n                if(Tasks[tid].s == 0) { que.erase(it); Tasks[tid].FT = ct; }\n            }\n        }\n        if(Tasks[i].p == -1)\n        {\n            int xpcnt = 0;\n            for(int j = 0;j < n;j++)\n            {\n                if(Tasks[j].t > T) break;\n                if(Tasks[j].s == 0 || Tasks[j].p == -1) continue;\n                ps[xpcnt++] = pii(Tasks[j].p,Tasks[j].s);\n            }\n            sort(ps,ps+xpcnt);\n            ll sum = 0;\n            for(int j = xpcnt;j >= 0;j--)\n            {\n                sum += ps[j].second;\n                if(sum == inside)\n                {\n                    if(j < xpcnt) maxx = ps[j].first;\n                    if(j) minx = ps[j-1].first;\n                    break;\n                }\n            }\n            Tasks[i].p = (minx+maxx)/2;\n            //printf(""!!!!!! %d\\n"",Tasks[i].p);\n        }\n        que.insert(pii(-Tasks[i].p,i));\n    }\n    ll ct = Tasks[n-1].t;\n    while(que.size())\n    {\n        vit it = que.begin();\n        int tid = it->second;\n        int cost = Tasks[tid].s;\n        ct += cost;\n        Tasks[tid].s -= cost;\n        if(Tasks[tid].s == 0) { que.erase(it); Tasks[tid].FT = ct; }\n    }\n\n    printf(""%d\\n"",Tasks[target].p);\n    for(int i = 0;i < n;i++) ftans[Tasks[i].id] = Tasks[i].FT;\n    for(int i = 0;i < n;i++) printf(""%I64d "",ftans[i]);\n    puts("""");\n    while(getchar() != EOF);\n    return 0;\n}\n']","['binary search', 'data structures', 'implementation', 'sortings']",2200
https://codeforces.com//contest/1886/problem/D,D. Monocarp and the Set,Monocarp has n numbers 1 2 dots n and a set initially empty He adds his numbers to this set n times in some order During each step he adds a new number which has not been present in the set before In other words the sequence of added numbers is a permutation of length n Every time Monocarp adds an element into the set he writes out a character if the element Monocarp is trying to insert becomes the maximum element in the set Monocarp writes out the character if the element Monocarp is trying to insert becomes the minimum element in the set Monocarp writes out the character if none of the above Monocarp writes out the character You are given a string s of n 1 characters which represents the characters written out by Monocarp in the order he wrote them out You have to process m queries to the string Each query has the following format i c replace s i with the character c Both before processing the queries and after each query you have to calculate the number of different ways to order the integers 1 2 3 dots n such that if Monocarp inserts the integers into the set in that order he gets the string s Since the answers might be large print them modulo 998244353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    n--;\n    \n    Z ans = 1;\n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 1; i < n; i++) {\n        if (s[i] == \'?\') {\n            ans *= i;\n        }\n    }\n    \n    auto query = [&]() {\n        if (s[0] == \'?\') {\n            std::cout << 0 << ""\\n"";\n        } else {\n            std::cout << ans << ""\\n"";\n        }\n    };\n    \n    query();\n    while (m--) {\n        int x;\n        char y;\n        std::cin >> x >> y;\n        x--;\n        if (x && s[x] == \'?\') {\n            ans *= comb.inv(x);\n        }\n        s[x] = y;\n        if (x && y == \'?\') {\n            ans *= x;\n        }\n        query();\n    }\n    \n    return 0;\n}\n']","['combinatorics', 'data structures', 'math']",2100
https://codeforces.com//contest/497/problem/C,C. Distributing Parts ,You are an assistant director in a new musical play The play consists of musical parts each part must be performed by exactly one actor After the casting the director chose actors who can take part in the play Your task is to assign the parts to actors However there are several limitations First each actor has a certain voice range and there are some parts that he cannot sing Formally there are two integers for each actor and the pitch of the lowest and the highest note that the actor can sing There also are two integers for each part and the pitch of the lowest and the highest notes that are present in the part The th actor can perform the th part if and only if i e each note of the part is in the actor s voice range According to the contract the th actor can perform at most parts Besides you are allowed not to give any part to some actors then they take part in crowd scenes The rehearsal starts in two hours and you need to do the assignment quickly ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\nconst int M = 100000;\n\nstruct Input {\n\tint n;\n\tint a[N], b[N];\n\tint m;\n\tint c[M], d[M], k[M];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d%d"", &a[i], &b[i]);\n\t\t}\n\t\tcin >> m;\n\t\tforn (i, m) {\n\t\t\tscanf(""%d%d%d"", &c[i], &d[i], &k[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tbool res;\n\tint ans[N];\n\t\n\tvoid write () {\n\t\tif (!res) {\n\t\t\tputs(""NO"");\n\t\t\treturn;\n\t\t}\n\t\tputs(""YES"");\n\t\tforn (i, n) {\n\t\t\tif (i) {\n\t\t\t\tprintf("" "");\n\t\t\t}\n\t\t\tprintf(""%d"", ans[i] + 1);\n\t\t}\n\t\tputs("""");\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tvoid solve () {\n\t\tve<pa<int, pii> > q;\n\t\tforn (i, n) {\n\t\t\tq.pb(mp(b[i], mp(0, i)));\n\t\t}\n\t\tforn (i, m) {\n\t\t\tq.pb(mp(d[i], mp(1, i)));\n\t\t}\n\t\tsort(all(q));\n\t\t\n\t\tset<pii> s;\n\t\tforn (i, sz(q)) {\n\t\t\tif (q[i].sc.fs == 0) {\n\t\t\t\ts.insert(mp(-a[q[i].sc.sc], q[i].sc.sc));\n\t\t\t} else {\n\t\t\t\tforn (j, k[q[i].sc.sc]) {\n\t\t\t\t\tauto it = s.upper_bound(mp(-c[q[i].sc.sc], N));\n\t\t\t\t\tif (it == s.begin()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t--it;\n\t\t\t\t\tans[it->sc] = q[i].sc.sc;\n\t\t\t\t\ts.erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = s.empty();\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n']","['data structures', 'greedy', 'implementation', 'sortings', 'two pointers']",2100
https://codeforces.com//contest/494/problem/C,C. Helping People,Malek is a rich man He also is very generous That s why he decided to split his money between poor people A charity institute knows poor people numbered from to The institute gave Malek recommendations A recommendation is a segment of people like which means the institute recommended that Malek gives one dollar to every person whose number is in this segment However this charity has very odd rules about the recommendations Because of those rules the recommendations are given in such a way that for every two recommendation and one of the following conditions holds The two segments are completely disjoint More formally either or One of the two segments are inside another More formally either or The of a charity is the value of maximum money a person has after Malek finishes giving his money The institute knows for each recommendation what is the probability that Malek will accept it They want to know the expected value of of this charity So they asked you for help You have been given the list of recommendations and for each recommendation the probability of it being accepted by Malek You have also been given how much money each person initially has You must find the expected value of ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX = 200010;\n\nint a[MAX];\n\nconst int N = 5010;\n\nvector <int> g[N];\nvector <double> f[N];\nint start[N], finish[N];\ndouble prob[N];\nint from[N], to[N];\n\nvoid solve(int i) {\n  int sz = g[i].size();\n  from[i] = 0;\n  if (sz == 0) {\n    for (int pos = start[i]; pos <= finish[i]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n  } else {\n    for (int pos = start[i]; pos < start[g[i][0]]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n    for (int j = 0; j + 1 < sz; j++) {\n      for (int pos = finish[g[i][j]] + 1; pos < start[g[i][j + 1]]; pos++) {\n        if (a[pos] > from[i]) {\n          from[i] = a[pos];\n        }\n      }\n    }\n    for (int pos = finish[g[i][sz - 1]] + 1; pos <= finish[i]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n  }\n  to[i] = from[i];\n  for (int j = 0; j < sz; j++) {\n    int u = g[i][j];\n    solve(u);\n    if (from[u] > from[i]) {\n      from[i] = from[u];\n    }\n    if (to[u] > to[i]) {\n      to[i] = to[u];\n    }\n  }\n  f[i].resize(to[i] - from[i] + 1);\n  for (int v = to[i]; v >= from[i]; v--) {\n    double cur = 1.0;\n    for (int j = 0; j < sz; j++) {\n      int u = g[i][j];\n      if (to[u] >= v) {\n        cur *= (1.0 - f[u][v - from[u]]);\n      }\n    }\n    f[i][v - from[i]] = 1.0 - cur;\n  }\n  f[i][0] = 1.0;\n  f[i].push_back(f[i][to[i] - from[i]] * prob[i]);\n  for (int v = to[i]; v > from[i]; v--) {\n    f[i][v - from[i]] = f[i][v - from[i]] * (1 - prob[i]) + f[i][v - from[i] - 1] * prob[i];\n  }\n  to[i]++;\n}\n\nint st[N];\npair < pair <int, int>, int > adds[N];\n\nint main() {\n  int n, q;\n  scanf(""%d %d"", &n, &q);\n  for (int i = 1; i <= n; i++) {\n    scanf(""%d"", a + i);\n  }\n  q++;\n  for (int i = 0; i < q; i++) {\n    if (i == q - 1) {\n      start[i] = 1;\n      finish[i] = n + 1;\n      prob[i] = 0.0;\n    } else {\n      scanf(""%d %d %lf"", start + i, finish + i, prob + i);\n    }\n    adds[i] = make_pair(make_pair(start[i], -finish[i]), i);\n  }\n  sort(adds, adds + q);\n  for (int i = 0; i < q; i++) {\n    g[i].clear();\n  }\n  int e = 0;\n  for (int id = 0; id < q; id++) {\n    int i = adds[id].second;\n    while (e > 0 && finish[st[e - 1]] < start[i]) {\n      e--;\n    }\n    if (e > 0) {\n      g[st[e - 1]].push_back(i);\n    }\n    st[e++] = i;\n  }\n  finish[q - 1] = n;\n  solve(q - 1);\n  double ans = from[q - 1];\n  for (int j = from[q - 1] + 1; j <= to[q - 1]; j++) {\n    ans += f[q - 1][j - from[q - 1]];\n  }\n  printf(""%.17f\\n"", ans);\n  return 0;\n}\n']","['dp', 'probabilities']",2600
https://codeforces.com//contest/1856/problem/B,B. Good Arrays,You are given an array of integers a of length n Let s call an array of integers b of length n if a i neq b i for i from 1 to n a 1 a 2 ldots a n b 1 b 2 ldots b n Does a good array exist ,"['#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\n\nconst int N = 1e5 + 5;\nll a[N];\nll b[N];\nint n;\n\nvoid solve(){\n    cin >> n;\n    ll s = 0;\n    ll ms = 0;\n    bool can = false;\n    for(int i=1;i<=n;i++){\n        cin >> a[i];\n        if(a[i] == 1) b[i] = 2;\n        else b[i] = 1;\n        s += a[i];\n        ms += b[i];\n        if(b[i] == 2) can = true;\n    }\n    if(n == 1){\n        cout << ""NO"" << ""\\n"";\n        return;\n    }\n    if(ms <= s){\n        if(ms <= s - 2 || can || ms == s){\n            cout << ""YES"" << ""\\n"";\n            return;\n        }\n    }\n    cout << ""NO"" << ""\\n"";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n']","['implementation', 'math']",900
https://codeforces.com//contest/1092/problem/D2,D2. Great Vova Wall  Version 2 ,Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence a of n integers with a i being the height of the i th part of the wall Vova can only use 2 times 1 bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighbouring parts of the wall of equal height It means that if for some i the current height of part i is the same as for part i 1 then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part 1 of the wall or to the right of part n of it Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,"['#include<cstdio>\nint m;\nint a[200000];\nint cnt[200000];\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++){\n        int x;\n        scanf(""%d"",&x);\n        while(m&&a[m-1]<x){\n            if(cnt[m-1]&1){\n                puts(""NO"");\n                return 0;\n            }\n            m--;\n        }\n        if(!m||a[m-1]!=x){\n            cnt[m]=1;\n            a[m++]=x;\n        }\n        else{\n            cnt[m-1]++;\n        }\n    }\n    for(int i=1;i<m;i++){\n        if(cnt[i]&1){\n            puts(""NO"");\n            return 0;\n        }\n    }\n    puts(""YES"");\n    return 0;\n}\n']","['data structures', 'implementation']",2200
https://codeforces.com//contest/1256/problem/E,E. Yet Another Division Into Teams,There are n students at your university The programming skill of the i th student is a i As a coach you want to divide them into teams to prepare them for the upcoming ICPC finals Just imagine how good this university is if it has 2 cdot 10 5 students ready for the finals Each team should consist of Each student should belong to The of a team is the difference between the programming skill of some student that belongs to this team and the programming skill of some student that belongs to this team in other words if the team consists of k students with programming skills a i 1 a i 2 dots a i k then the of this team is max limits j 1 k a i j min limits j 1 k a i j The total is the sum of of all teams formed Your task is to minimize the total of the division of students and find the optimal way to divide the students ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXA=3e5;\nint n,N,b[MAXA],c[MAXA];\nlong long f[MAXA],a[MAXA];\nint mysort(int x,int y){\n    return a[x]<a[y];\n}\nint main(){\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++) scanf(""%lld"",&a[i]),c[i]=i;\n    sort(c+1,c+n+1,mysort);\n    for(int i=1;i<=n;i++){\n\tf[i]=1e18;\n\tfor(int j=3;j<=min(6,i);j++){\n\t    f[i]=min(f[i],f[i-j]+a[c[i]]-a[c[i-j+1]]);\n\t}\n    }\n    for(int i=n;i;){\n\tfor(int j=3;j<=min(6,i);j++)\n\t    if(f[i]==f[i-j]+a[c[i]]-a[c[i-j+1]]){\n\t\t++N;\n\t\tfor(int k=1;k<=j;k++) b[c[i-k+1]]=N;\n\t\ti=i-j;\n\t\tbreak;\n\t    }\n    }\n    printf(""%lld %d\\n"",f[n],N);\n    for(int i=1;i<=n;i++) printf(""%d "",b[i]);\n}']","['dp', 'greedy', 'sortings']",2000
https://codeforces.com//contest/1732/problem/A,A. Bestie,You are given an array a consisting of n integers a 1 a 2 ldots a n Friends asked you to make the greatest common divisor GCD of all numbers in the array equal to 1 In one operation you can do the following Select an arbitrary index in the array 1 leq i leq n Make a i gcd a i i where gcd x y denotes the GCD of integers x and y The cost of such an operation is n i 1 You need to find the minimum total cost of operations we need to perform so that the GCD of the all array numbers becomes equal to 1 ,"[""#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n,a[25],res,dp[25],b[25];\nbool vis[25];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n);\n\t\tint fk=0;\n\t\tfor(int i=1;i<=n;i++)gi(a[i]),b[i]=__gcd(i,a[i]),fk=__gcd(fk,a[i]);\n\t\tif(fk==1){\n\t\t\tpi(0,'\\n');\n\t\t\tcontinue;\n\t\t}\n\t\tres=1e9;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++)dp[j]=1e9;\n\t\t\tdp[__gcd(a[i],i)]=n-i+1;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[__gcd(b[j],k)]=min(dp[__gcd(b[j],k)],dp[k]+n-j+1);\n\t\t\t\t\tdp[__gcd(a[j],k)]=min(dp[__gcd(a[j],k)],dp[k]);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tres=min(res,dp[1]);\n\t\t}\n\t\tpi(res,'\\n');\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/""]","['brute force', 'combinatorics', 'constructive algorithms', 'implementation', 'math', 'number theory']",1000
https://codeforces.com//contest/557/problem/C,C. Arthur and Table,Arthur has bought a beautiful big table into his new flat When he came home Arthur noticed that the new table is unstable In total the table Arthur bought has legs the length of the th leg is Arthur decided to make the table stable and remove some legs For each of them Arthur determined number the amount of energy that he spends to remove the th leg A table with legs is assumed to be stable if there are more than half legs of the maximum length For example to make a table with legs stable you need to make sure it has at least three out of these five legs of the maximum length Also a table with one leg is always stable and a table with two legs is stable if and only if they have the same lengths Your task is to help Arthur and count the minimum number of energy units Arthur should spend on making the table stable ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair <int, int> \nint leng [100005]; \nint energy [100005]; \nPII len [100005]; \nint totenergy [100005]; \nvector <int> energybyleng [100005]; \nint cur [205]; \nint main()\n{\n    ios_base::sync_with_stdio(0); \n    int N; cin >> N;\n    long long tot = 0; \n    for (int g=1; g<=N; g++) cin >> leng[g]; \n    for (int g=1; g<=N; g++) cin >> energy[g]; \n    for (int g=1; g<=N; g++) tot+=energy[g], totenergy[leng[g]]+=energy[g], len[g]=PII(leng[g], energy[g]), energybyleng[leng[g]].push_back(energy[g]); \n    sort(len+1, len+N+1); \n    for (int g=1; g<=100000; g++) sort(energybyleng[g].begin(), energybyleng[g].end()); \n    int checker=0; \n    for (int g=1; g<=100000; g++)\n    {\n        if (!energybyleng[g].size()) continue; \n        int x = totenergy[g]; \n        int cansave = energybyleng[g].size()-1; \n        for (int y=200; y>=1; y--)\n        {\n            if (cansave==0) break; \n            if (cur[y]>=cansave)\n            {\n                x+=(cansave*y); break;\n            }\n            else\n            {\n                x+=(cur[y]*y); \n                cansave-=cur[y]; \n            }\n        }\n        if (x>checker)checker=x; \n        for (int y=0; y<energybyleng[g].size(); y++)\n        {\n            cur[energybyleng[g][y]]++; \n        }\n    }   \n    cout << tot-checker; \n    return 0;\n}']","['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings']",1900
https://codeforces.com//contest/302/problem/A,A. Eugeny and Array,Eugeny has array consisting of integers Each integer equals to 1 or to 1 Also he has queries Query number is given as a pair of integers The response to the query will be integer if the elements of array can be rearranged so as the sum otherwise the response to the query will be integer Help Eugeny answer all his queries ,"['#include <iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nint a[300000];\nint s[300000];\n\nint main()\n{\n\tint n,m;\n\tcin >> n >> m;\n\tmemset(s,0,sizeof(s));\n\tint p = 0;\n\tint q = 0;\n\tfor (int i = 1; i <= n ; i++)\n\t{\n\t\tscanf(""%d"", &a[i]);\n\t\t//s[i] = s[i-1] + a[i];\n\t\tif (a[i] == 1) p++;\n\t\tif (a[i] == -1) q++;\n\t}\n\tfor (int i = 0; i< m; i++)\n\t{\n\t\tint l,r;\n\t\tscanf(""%d %d"", &l, &r);\n\t\tint u = r - l + 1;\n\t\tif (u% 2==1)\n\t\t{\n\t\t\t printf(""0\\n"");\n\t\t\t continue;\n\t\t\t}\n\t\tu = u / 2;\n\t\tif (p >= u && q >= u) printf(""1\\n""); else printf(""0\\n"");\n\t}\n\t//system(""pause"");\n}\n\n/*\n2 3\n1 -1\n1 1\n1 2\n2 2\n*/\n']",['implementation'],800
https://codeforces.com//contest/792/problem/E,E. Colored Balls,There are boxes with colored balls on the table Colors are numbered from to th box contains balls all of which have color You have to write a program that will divide all balls into sets such that each ball belongs to exactly one of the sets there are no empty sets there is no set containing two or more balls of different colors each set contains only balls of one color there are no two sets such that the difference between their sizes is greater than Print the minimum possible number of sets ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << "" "";\n    }\n    cerr << ""\\n"";\n}\n\nint n;\nll a[600];\nvector<int> vv;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tsort(a, a + n);\n\tfor (int i = 1; i < 40000; ++i) {\n\t\tif (a[0] / i >= a[0] % i)\n\t\t\tvv.push_back(i);\n\t}\n\tfor (int i = 1; i < 40000; ++i) {\n\t\tll k = a[0] / i;\n\t\tif (k > 0 && (a[0] / k >= a[0] % k))\n\t\t\tvv.push_back(k);\n\t\tk -= 1;\n\t\tif (k > 0 && (a[0] / k >= a[0] % k))\n\t\t\tvv.push_back(k);\n\t}\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\trandom_shuffle(a, a + n);\n\tfor (int i = vv.size() - 1; i >= 0; --i) {\n\t\tint x = vv[i];\n\t\tint fl = 0;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (a[j] / x < a[j] % x) {\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fl) {\n\t\t\tll ans = 0;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tans += a[j] / (x + 1);\n\t\t\t\tif (a[j] % (x + 1))\n\t\t\t\t\t++ans;\n\t\t\t}\n\t\t\tcout << ans << ""\\n"";\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n']","['greedy', 'math', 'number theory']",2500
https://codeforces.com//contest/808/problem/A,A. Lucky Year,Apart from having lots of holidays throughout the year residents of Berland also have whole years Year is considered if it has no more than non zero digit in its number So years 100 40000 5 are and 12 3001 and 12345 are not You are given current year in Berland Your task is to find how long will residents of Berland wait till the next year ,"['#include<cstdio>\n#include<algorithm>\nlong long x,z=1,s[1007];\nint p=0;\nint main(){\n\tfor(int i=1;i<=10;++i){\n\t\tfor(int j=1;j<=9;++j)s[p++]=j*z;\n\t\tz*=10;\n\t}\n\tscanf(""%I64d"",&x);\n\tprintf(""%I64d"",*std::upper_bound(s,s+p,x)-x);\n\treturn 0;\n}']",['implementation'],900
https://codeforces.com//contest/996/problem/B,B. World Cup,Allen wants to enter a fan zone that occupies a round square and has n entrances There already is a queue of a i people in front of the i th entrance Each entrance allows one person from its queue to enter the fan zone in one minute Allen uses the following strategy to enter the fan zone Initially he stands in the end of the queue in front of the first entrance Each minute if he is not allowed into the fan zone during the minute meaning he is not the first in the queue he leaves the current queue and stands in the end of the queue of the next entrance or the first entrance if he leaves the last entrance Determine the entrance through which Allen will finally enter the fan zone ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <stdlib.h>\n#include <set>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <regex>\n#include <math.h>\n#include <map>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <array>\n#include <valarray>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\ntypedef int integer;\ntypedef array<int, 2> hv;\n#define double long double\n#define int long long\n#define make(type, x) type x; cin>>x\n#define make2(type, x, y) type x, y; cin>>x>>y\n#define make3(type, x, y, z) type x, y, z; cin>>x>>y>>z\n#define make4(type, x, y, z, q) type x, y, z, q; cin>>x>>y>>z>>q\n#define ALL(x) (x).begin(), (x).end()\n#define FORIT(p) for(auto it = p.begin(); it != p.end(); it++)\n#define FOR(b) for(int i = 0; i <(b); ++i)\n#define VI vector<int>\n#define VVI vector<vector<int>>\n#define PII pair<int, int>\n#define PPII pair<PII, int>\n#define M7 1000000007\n#define M9 1000000009\n\n\n\n\nvoid Solve() {\n\tmake(int, n);\n\tVI a(n);\n\tFOR(n) cin >> a[i];\n\tint mn = a[0];\n\tfor (int i = 1; i < n; ++i) mn = min(a[i], mn);\n\tint cnt_kr = mn / n;\n\tFOR(n) a[i] -= cnt_kr*n;\n\tfor (int d = 0; d < 20; d++) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] -= i;\n\t\t\tif (a[i] <= 0) {\n\t\t\t\tcout << i + 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\ta[i] -= n - i;\n\t\t}\n\t}\n\n\n}\n\n\n\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie();\n#if  _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tSolve();\n\twhile (!cin.eof()) {\n\t\tstring s = ""_"";\n\t\tdo getline(cin, s);\n\t\twhile (!cin.eof() && !s.empty());\n\t\tif (cin.eof()) return 0;\n\t\tFOR(3) cout << endl;\n\t\tSolve();\n\t}\n#else\n\tSolve();\n#endif\n\treturn 0;\n\t}']","['binary search', 'math']",1300
https://codeforces.com//contest/625/problem/D,D. Finals in arithmetic,Vitya is studying in the third grade During the last math lesson all the pupils wrote on arithmetic quiz Vitya is a clever boy so he managed to finish all the tasks pretty fast and Oksana Fillipovna gave him a new one that is much harder Let s denote a of an integer as follows number is considered in decimal notation and then reverted If there are any leading zeroes afterwards they are thrown away For example if we flip the result is the integer but flipping we obtain and by flipping we come to Oksana Fillipovna picked some number without leading zeroes and flipped it to get number Then she summed and and told Vitya the resulting value His goal is to find any valid As Oksana Fillipovna picked some small integers as and Vitya managed to find the answer pretty fast and became interested in finding some general algorithm to deal with this problem Now he wants you to write the program that for given finds any without leading zeroes such that or determine that such doesn t exist ,"['#include <bits/stdc++.h>\nusing namespace std;\nchar str[100005];\nint a[100005];\nint main(){\n\tscanf(""%s"",str);\n\tint l=strlen(str);\n\tif(l==1){\n\t\tint d=str[0]-\'0\';\n\t\tif(d%2==0) printf(""%d\\n"",d/2);\n\t\telse printf(""0\\n"");\n\t\treturn 0;\n\t}\n\tint x1=0,x2=l-1;\n\tint d1=str[0]-\'0\',d2=str[l-1]-\'0\';\n\tbool fail=0;\n\twhile(x1<x2){\n\t\tif(x2-1==x1){\n\t\t\tif(d1==d2){\n\t\t\t\ta[x2]=d1/2;\n\t\t\t\ta[x1]=d1-d1/2;\n\t\t\t}\n\t\t\telse if(d1-1==d2+10){\n\t\t\t\ta[x2]=(d1-1)/2;\n\t\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\t}\n\t\t\telse fail=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(d1==d2){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\';\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+1&&d2>=0){\n\t\t\ta[x2]=d2/2;\n\t\t\ta[x1]=d2-d2/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+10&&d2<9){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse if(d1-1==d2+10&&d2<9){\n\t\t\ta[x2]=(d1-1)/2;\n\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse{\n\t\t\tfail=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!fail&&a[0]){\n\t\tfor(int x=0;x<l;x++) printf(""%d"",a[x]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\telse if(l==2){\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tfail=0;\n\tx1=1,x2=l-1;\n\td1=(str[0]-\'0\')*10+str[1]-\'0\',d2=str[l-1]-\'0\';\n\twhile(x1<x2){\n\t\tif(x2-1==x1){\n\t\t\tif(d1==d2){\n\t\t\t\ta[x2]=d1/2;\n\t\t\t\ta[x1]=d1-d1/2;\n\t\t\t}\n\t\t\telse if(d1-1==d2+10){\n\t\t\t\ta[x2]=(d1-1)/2;\n\t\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\t}\n\t\t\telse fail=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(d1==d2){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\';\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+1&&d2>=0){\n\t\t\ta[x2]=d2/2;\n\t\t\ta[x1]=d2-d2/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\';\n\t\t}\n\t\telse if(d1==d2+10&&d2<9){\n\t\t\ta[x2]=d1/2;\n\t\t\ta[x1]=d1-d1/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\';\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse if(d1-1==d2+10&&d2<9){\n\t\t\ta[x2]=(d1-1)/2;\n\t\t\ta[x1]=d1-1-(d1-1)/2;\n\t\t\tx1++;\n\t\t\tx2--;\n\t\t\tif(x1==x2){\n\t\t\t\td1=str[x1]-\'0\'+10-1;\n\t\t\t\tif(d1%2==0){\n\t\t\t\t\ta[x1]=d1/2;\n\t\t\t\t}\n\t\t\t\telse fail=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td1=str[x1]-\'0\'+10;\n\t\t\td2=str[x2]-\'0\'-1;\n\t\t}\n\t\telse{\n\t\t\tfail=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!fail&&a[1]){\n\t\tfor(int x=1;x<l;x++) printf(""%d"",a[x]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\tprintf(""0\\n"");\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation', 'math']",2400
https://codeforces.com//contest/1348/problem/D,D. Phoenix and Science,Phoenix has decided to become a scientist He is currently investigating the growth of bacteria Initially on day 1 there is one bacterium with mass 1 Every day some number of bacteria will split possibly zero or all When a bacterium of mass m splits it becomes two bacteria of mass frac m 2 each For example a bacterium of mass 3 can split into two bacteria of mass 1 5 Also every night the mass of every bacteria will increase by one Phoenix is wondering if it is possible for the total mass of all the bacteria to be exactly n If it is possible he is interested in the way to obtain that mass using the minimum possible number of nights Help him become the best scientist ,"['#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint t,n,cur;\nll qpow (ll a,ll b) {\n\tll res=1;\n\twhile (b) {\n\t\tif (b) {res*=a;}\n\t\ta*=a,b>>=1;\n\t}\n\treturn res;\n}\nll divc (ll a,ll b) {\n\tif (a%b==0) {return a/b;}\n\telse {return a/b+1;}\n}\nll calc (int x) {return (1<<x)-1;}\nint main () {\n\tscanf(""%d"",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(""%d"",&n);\n\t\tint ans=0;\n\t\twhile (calc(ans)<n) {ans++;}\n\t\tprintf(""%d\\n"",ans-1);\n\t\tcur=1,n--;\n\t\tfor (int i=2;i<=ans;i++) {\n\t\t\tint tmp=cur;\n\t\t\tcur=divc(n,calc(ans-i+1));\n\t\t\tn-=cur;\n\t\t\tprintf(""%d "",cur-tmp);\n\t\t}\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math']",1900
https://codeforces.com//contest/1601/problem/A,A. Array Elimination,You are given array a 1 a 2 ldots a n consisting of non negative integers Let s define operation of elimination with integer parameter k 1 leq k leq n as follows Choose k distinct array indices 1 leq i 1 i 2 ldots i k le n Calculate x a i 1 a i 2 ldots a i k where denotes the bitwise AND operation notes section contains formal definition Subtract x from each of a i 1 a i 2 ldots a i k all other elements remain untouched Find all possible values of k such that it s possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k It can be proven that exists at least one possible k for any array a Note that you ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[200005], c[35];\nint gcd(int x, int y)\n{\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nvoid solve()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%d"", &a[i]);\n\tmemset(c, 0, sizeof(c));\n\trep(i, n) rep(j, 30) if(a[i] >> j & 1) c[j] ++;\n\tint r = 0;\n\trep(i, 30) r = gcd(r, c[i]);\n\trep1(i, n) if(r % i == 0) printf(""%d "", i); printf(""\\n"");\n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']","['bitmasks', 'greedy', 'math', 'number theory']",1300
https://codeforces.com//contest/602/problem/B,B. Approximating a Constant Range,When Xellos was doing a practice course in university he once had to measure the intensity of an effect that slowly approached equilibrium A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average Of course with the usual sizes of data it s nothing challenging but why not make a similar programming contest problem while we re at it You re given a sequence of data points There aren t any big jumps between consecutive data points for each it s guaranteed that A range of data points is said to be if the difference between the largest and the smallest value in that range is at most Formally let be the maximum and the minimum value of for the range is almost constant if Find the length of the longest almost constant range ,"['#include <iostream>\n\nusing namespace std;\n\nint n;\nint a[110000];\nint last[110000];\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i <= 100000; i++)  {\n        last[i] = -1;\n    }\n    int l = 0;\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int x = -1;\n        if (a[i] + 2 <= 100000) {\n            x = max(x, last[a[i] + 2]);\n        }\n        if (a[i] - 2 >= 0) {\n            x = max(x, last[a[i] - 2]);\n        }\n        l = max(l, x + 1);\n        ans = max(ans, i - l + 1);\n\n        last[a[i]] = i;\n    }\n    cout << ans << endl;\n    return 0;\n}\n']","['dp', 'implementation', 'two pointers']",1400
https://codeforces.com//contest/498/problem/E,E. Stairs and Lines,You are given a figure on a grid representing stairs consisting of 7 steps The width of the stair on height is squares Formally the figure is created by consecutively joining rectangles of size so that the sides lie on one straight line Thus for example if all the figure will look like that different colors represent different rectangles And if then it looks like that Find the number of ways to color some borders of the figure s inner squares so that no square had all four borders colored The borders of the squares lying on the border of the figure should be considered painted The ways that differ with the figure s rotation should be considered distinct ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nconst int MOD = int(1e9 + 7);\nvoid madd(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint mmul(int a, int b) { return ll(a) * b % MOD; }\n\nconst int h = 7;\n\nstruct Mat {\n  static const int n = 1 << h;\n  int dat[n][n];\n\n  Mat(int x = 0) {\n    memset(dat, 0, sizeof dat);\n    forn (i, n) dat[i][i] = x;\n  }\n        int *operator[](int y)       { return dat[y]; }\n  const int *operator[](int y) const { return dat[y]; }\n\n  friend Mat operator*(const Mat &a, const Mat &b) {\n    const ll MOD2 = ll(MOD) * MOD;\n    Mat res;\n    forn (i, n)\n    forn (j, n) {\n      ll cur = 0;\n      forn (k, n) {\n        cur += ll(a[i][k]) * b[k][j];\n        if (cur >= MOD2) cur -= MOD2;\n      }\n      res[i][j] = cur % MOD;\n    }\n    return res;\n  }\n};\n\nMat mpow(Mat a, int b) {\n  Mat res = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) res = res * a;\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n\n  vi ws(h + 1);\n  while (scanf(""%d"", &ws[1]) == 1) {\n    for (int y = 2; y <= h; y++)\n      scanf(""%d"", &ws[y]);\n\n    Mat ans = 1;\n    int py = 0;\n    for (int y = 1; y <= h; y++) if (ws[y]) {\n      // first step\n      for (int x = 0; x < 2; x++) {\n        Mat cur;\n        int prevMsk = x ? (1 << y) : (1 << py);\n        forn (old, prevMsk) {\n          forn (vmsk, prevMsk) if (!(old & vmsk)) {\n            forn (hmsk, 1 << (y - 1)) {\n              int hasBottom = (hmsk << 1) | 1;\n              int hasMiddle = vmsk;\n              if (x == 0) hasMiddle |= ((1 << (y - py)) - 1) << py;\n              int hasTop = hmsk | (1 << (y - 1));\n              int ne = hasBottom & hasMiddle & hasTop;\n              madd(cur[old][ne], 1);\n            }\n          }\n        }\n\n        int need = 1;\n        if (x == 1) need = ws[y] - 1;\n        ans = ans * mpow(cur, need);\n      }\n      py = y;\n    }\n    printf(""%d\\n"", ans[0][0]);\n  }\n\n  return 0;\n}\n']","['dp', 'matrices']",2700
https://codeforces.com//contest/889/problem/C,C. Maximum Element,One day Petya was solving a very interesting problem But although he used many optimization techniques his solution still got Time limit exceeded verdict Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of positive integers was too slow Desperate Petya decided to use a somewhat unexpected optimization using parameter so now his function contains the following code int fast max int n int a int ans 0 int offset 0 for int i 0 i n i if ans a i ans a i offset 0 else offset offset 1 if offset k return ans return ans That way the function iteratively checks array elements storing the intermediate maximum and if after consecutive iterations that maximum has not changed it is returned as the answer Now Petya is interested in fault rate of his function He asked you to find the number of permutations of integers from to such that the return value of his function on those permutations is not equal to Since this number could be very big output the answer modulo ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\n\nll rev(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = rev(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll f[MAXN];\nll fct[MAXN];\nll rfct[MAXN];\n\nll cnk(int x, int y) {\n    return fct[x + y] * rfct[x] % MOD * rfct[y] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    rfct[n] = rev(fct[n]);\n    for (int i = n; i > 0; --i) {\n        rfct[i - 1] = (rfct[i] * i) % MOD;\n    }\n    \n    ll mulall = 1;\n    ll ans = fct[n - 1];\n\n\n    ll sum = 0;\n    f[0] = 1;\n    sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        sum = (sum + f[i - 1]) % MOD;\n        ll cf = sum * mulall % MOD;\n        ans += cf * fct[n - 1] % MOD * rfct[i] % MOD;\n        ans %= MOD;\n        mulall = (mulall * i) % MOD;\n        f[i] = (rev(mulall) * cf) % MOD;\n        if (i >= k) {\n            sum = (sum - f[i - k] + MOD) % MOD;\n        }\n    }\n\n    cout << (fct[n] - ans + MOD) % MOD;\n}']","['dp', 'math']",2400
https://codeforces.com//contest/1742/problem/C,C. Stripes,On an 8 times 8 grid some horizontal rows have been painted red and some vertical columns have been painted blue in some order The stripes are drawn sequentially one after the other When the stripe is drawn it repaints all the cells through which it passes Determine which color was used last ,"[""#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\n\nvoid solve()\n{\n\tvector<vector<char>> v(8,vector<char>(8));\n\n\tfor(int i=0;i<8;i++)\n\t{\n\t\t string s;\n\t\t cin>>s;\n\n\t\t for(int j=0;j<8;j++)\n\t\t {\n\t\t \t v[i][j]=s[j];\n\t\t }\n\t}\n\n\tchar ans='R';\n\n\tfor(int i=0;i<8;i++)\n\t{\n\t\t int f=0;\n\t\t for(int j=0;j<8;j++)\n\t\t {\n\t\t \t if(v[i][j]=='R')\n\t\t \t {\n\t\t \t \t f++;\n\t\t \t }\n\t\t }\n\n\t\t if(f==8)\n\t\t \tans='R';\n\t}\n\n\tfor(int j=0;j<8;j++)\n\t{\n\t\t int f=0;\n\t\t for(int i=0;i<8;i++)\n\t\t {\n\t\t \t if(v[i][j]=='B')\n\t\t \t {\n\t\t \t \t f++;\n\t\t \t }\n\t\t }\n\n\t\t if(f==8)\n\t\t \t ans='B';\n\t}\n\n\tcout<<ans<<endl;\n}\n\nint32_t main()\n{\n\t int t=1;\n\n\t cin>>t;\n\n\t while(t--)\n\t {\n\t \t solve();\n\t }\n\t return 0;\n}                                    ""]",['implementation'],900
https://codeforces.com//contest/1296/problem/C,C. Yet Another Walking Robot,There is a robot on a coordinate plane Initially the robot is located at the point 0 0 Its path is described as a string s of length n consisting of characters Each of these characters corresponds to some move left means that the robot moves from the point x y to the point x 1 y right means that the robot moves from the point x y to the point x 1 y up means that the robot moves from the point x y to the point x y 1 down means that the robot moves from the point x y to the point x y 1 The company that created this robot asked you to optimize the path of the robot somehow To do this you can remove of the path But this company doesn t want their customers to notice the change in the robot behavior It means that if before the optimization the robot ended its path at the point x e y e then after optimization i e removing some single substring from s the robot also ends its path at the point x e y e This optimization is a low budget project so you need to remove possible substring to optimize the robot s path such that the endpoint of his path doesn t change It is possible that you can t optimize the path Also it is possible that after the optimization the target path is an empty string i e deleted substring is the whole string s Recall that the substring of s is such string that can be obtained from s by removing some amount of characters possibly zero from the prefix and some amount of characters possibly zero from the suffix For example the substrings of are but not and You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;char a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int x=0,y=0;\n        map<PII,int>mp;\n        mp[PII(0,0)]=0;\n        scanf(""%d"",&n);\n        scanf(""%s"",a+1);\n        int ans=INF;\n        int l=0;\n        for(int i=1;i<=n;i++){\n            if(a[i]==\'L\')x++;\n            if(a[i]==\'R\')x--;\n            if(a[i]==\'U\')y++;\n            if(a[i]==\'D\')y--;\n            if(mp.count(PII(x,y))){\n                int k=mp[PII(x,y)];\n                if(i-k<ans)ans=i-k,l=k+1;\n            }\n            mp[PII(x,y)]=i;\n        }\n        if(l==0)printf(""-1\\n"");\n        else printf(""%d %d\\n"",l,l+ans-1);\n    }\n    return 0;\n}\n/*\n*/\n']","['data structures', 'implementation']",1500
https://codeforces.com//contest/1446/problem/D1,D1. Frequency Problem  Easy Version ,You are given an array a 1 a 2 dots a n Your goal is to find the length of the longest subarray of this array such that the most frequent value in it is unique In other words you are looking for a subarray such that if the most frequent value occurs f times in this subarray then at least 2 different values should occur exactly f times An array c is a subarray of an array d if c can be obtained from d by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int M = 101;\nint a[N];\nint d[N];\nint n;\nint cnt[N];\nint ans = 0;\n\nvoid solve(int b, int c) {\n\tfor (int i = 0; i <= n; i++)\n\t\td[i] = -1;\n\tint bal = cnt[b];\n\td[bal] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b)\n\t\t\tbal--;\n\t\telse if (a[i] == c) bal++;\n\t\tif (d[bal] == -1) {\n\t\t\td[bal] = i + 1;\n\t\t} else {\n\t\t\tans = max(ans, i + 1 - d[bal]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tcnt[a[i]]++;\n\t}\n\tint b = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (cnt[i] > cnt[b])\n\t\t\tb = i;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (i == b) continue;\n\t\tsolve(b, i);\n\t}\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","['data structures', 'greedy']",2600
https://codeforces.com//contest/1713/problem/A,A. Traveling Salesman Problem,You are living on an infinite plane with the Cartesian coordinate system on it In one move you can go to any of the four adjacent points left right up down More formally if you are standing at the point x y you can go left and move to x 1 y or go right and move to x 1 y or go up and move to x y 1 or go down and move to x y 1 There are n boxes on this plane The i th box has coordinates x i y i It is guaranteed that the boxes are either on the x axis or the y axis That is either x i 0 or y i 0 You can collect a box if you and the box are at the same point Find the minimum number of moves you have to perform to collect all of these boxes if you have to at the point 0 0 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\n\nbool solve(int caseN) {\n    int n;\n    cin >> n;\n\n    int minX = 0, maxX = 0, minY = 0, maxY = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n    }\n    cout << 2*(maxX-minX+maxY-minY) << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""complexity.in"", ""r"", stdin);\n    // freopen(""complexity.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(i); /*\n    for (int i = 1; solve(i); i++); /**/\n    cout.flush();\n    return 0;\n}']","['geometry', 'greedy', 'implementation']",800
https://codeforces.com//contest/1728/problem/C,C. Digital Logarithm,Let s define f x for a positive integer x as the length of the base 10 representation of x without leading zeros I like to call it a digital logarithm Similar to a digital root if you are familiar with that You are given two arrays a and b each containing n positive integers In one operation you do the following pick some integer i from 1 to n assign either f a i to a i or f b i to b i Two arrays are considered similar to each other if you can rearrange the elements in both of them so that they are equal e g a i b i for all i from 1 to n What s the smallest number of operations required to make a and b similar to each other ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 2e5 + 5;\n\npriority_queue<int> A, B;\nint a[N], b[N];\nint T, n;\n\nint calc(int x) {\n\tint ans = 0;\n\twhile (x) {\n\t\t++ans;\n\t\tx /= 10;\n\t}\n\treturn ans;\n}\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\tfor (int i = 1; i <= n; i++) a[i] = read(), A.push(a[i]);\n\t\tfor (int i = 1; i <= n; i++) b[i] = read(), B.push(b[i]);\n\t\tint ans = 0;\n\t\tfor (int _ = 1; _ <= n; _++) {\n\t\t\tint x = A.top(), y = B.top();\n\t\t\twhile (x != y) {\n\t\t\t\t++ans;\n\t\t\t\tif (x > y) {\n\t\t\t\t\tA.pop();\n\t\t\t\t\tA.push(calc(x));\n\t\t\t\t\tx = A.top();\n\t\t\t\t} else {\n\t\t\t\t\tB.pop();\n\t\t\t\t\tB.push(calc(y));\n\t\t\t\t\ty = B.top();\n\t\t\t\t}\n\t\t\t}\n\t\t\tA.pop();\n\t\t\tB.pop();\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n}\n']","['data structures', 'greedy', 'sortings']",1400
https://codeforces.com//contest/1397/problem/A,A. Juggling Letters,You are given n strings s 1 s 2 ldots s n consisting of lowercase Latin letters In one operation you can remove a character from a string s i and insert it to an arbitrary position in a string s j j may be equal to i You may perform this operation any number of times Is it possible to make all n strings equal ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int T; cin >> T;\n    while(T--)\n    {\n        vector<int> arr(256);\n        int N; cin >> N;\n        for(int i=1; i<=N; ++i)\n        {\n            string s;\n            cin >> s;\n            for(auto c: s) arr[c]++;\n        }\n        bool f = true;\n        for(int i=0; i<256; ++i)\n            if(arr[i]%N!=0) f = false;\n        if(f) puts(""YES"");\n        else puts(""NO"");\n    }\n}']","['greedy', 'strings']",800
https://codeforces.com//contest/1698/problem/C,C. 3SUM Closure,You are given an array a of length n The array is called if for all distinct indices i j k the sum a i a j a k is an element of the array More formally a is 3SUM closed if for all integers 1 leq i j k leq n there exists some integer 1 leq l leq n such that a i a j a k a l Determine if a is 3SUM closed ,"['#include<bits/stdc++.h>\nusing namespace std;\nint T,n,k,tot,fl,j,l,i,a[1000005];\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;tot=0;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i];\n\t\t\tif(a[i]==0){\n\t\t\t\t++tot;\n\t\t\t\tif(tot>1){\n\t\t\t\t\t--i;--n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n>10){\n\t\t\tcout<<""NO\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tfl=0;tot=0;\n\t\t\tfor(i=1;i<=n;++i){\n\t\t\t\tfor(j=i+1;j<=n;++j){\n\t\t\t\t\tfor(k=j+1;k<=n;++k){\n\t\t\t\t\t\tfl=0;\n\t\t\t\t\t\tfor(l=1;l<=n;++l){\n\t\t\t\t\t\t\tif(a[l]==a[i]+a[j]+a[k]){\n\t\t\t\t\t\t\t\tfl=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fl==0)++tot;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tot)cout<<""NO\\n"";\n\t\t\telse cout<<""YES\\n"";\n\t\t}\n\t}\n} ']","['brute force', 'data structures']",1300
https://codeforces.com//contest/165/problem/B,B. Burning Midnight Oil,One day a highly important task was commissioned to Vasya writing a program in a night The program consists of lines of code Vasya is already exhausted so he works like that first he writes lines of code drinks a cup of tea then he writes as much as lines drinks another cup of tea then he writes lines and so on The expression is regarded as the integral part from dividing number by number The moment the current value equals 0 Vasya immediately falls asleep and he wakes up only in the morning when the program should already be finished Vasya is wondering what minimum allowable value can take to let him write than lines of code before he falls asleep ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nint main(){\n\tint n, k;\n\twhile( cin>>n>>k ){\n\t\tint l=0, r=n;\n\t\twhile( l+1<r ){\n\t\t\tint mid=(l+r)/2;\n\t\t\tLL sum=0, M=1;\n\t\t\twhile( true ){\n\t\t\t\tsum+=mid/M;\n\t\t\t\tif( mid/M==0 ) break;\n\t\t\t\tM*=k;\n\t\t\t}\n\t\t\tif( sum>=n ) r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tcout<<r<<endl;\n\t}\n}\n\n\n\n\n']","['binary search', 'implementation']",1500
https://codeforces.com//contest/1895/problem/B,B. Points and Minimum Distance,You are given a sequence of integers a of length 2n You have to split these 2n integers into n pairs each pair will represent the coordinates of a point on a plane Each number from the sequence a should become the x or y coordinate of exactly one point Note that some points can be equal After the points are formed you have to choose a path s that starts from one of these points ends at one of these points and visits all n points at least once The length of path s is the sum of distances between all adjacent points on the path In this problem the distance between two points x 1 y 1 and x 2 y 2 is defined as x 1 x 2 y 1 y 2 Your task is to form n points and choose a path s in such a way that the length of path s is minimized ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<int> A(N*2);\n\trep(i,0,N*2) cin>>A[i];\n\tSo(A);\n\tint ans=0;\n\trep(i,1,N*2) if(i!=N) ans+=A[i]-A[i-1];\n\tcout<<ans<<""\\n"";\n\trep(i,0,N) cout<<A[i]<<"" ""<<A[i+N]<<""\\n"";\n}']","['greedy', 'math', 'sortings']",800
https://codeforces.com//contest/41/problem/E,E. 3-cycles,During a recent research Berland scientists found out that there were cities in Ancient Berland joined by two way paths Any two cities are joined by no more than one path No path joins a city with itself According to a well known tradition the road network was built so that it would be impossible to choose three cities from each of which one can get to any other one directly That is there was no cycle exactly as long as 3 Unfortunately the road map has not been preserved till nowadays Now the scientists are interested how much developed a country Ancient Berland was Help them find what maximal number of roads could be in the country You also have to restore any of the possible road maps ,"['#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<list>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<sstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I=(A);I<=(B);I++)\n#define REP(I,N) for(int I=0;I<(N);I++)\n#define ALL(X) (X).begin(),(X).end()\n#define VAR(A,B) __typeof(B) A=B\n#define FORE(I,X) for(VAR(I,(X).begin());I!=(X).end();I++)\n#define F first\n#define S second\n#define INF 1000000007\n#define PB push_back\n#define MP make_pair\ntypedef pair<int,int> PII;\ntypedef long long LL;\nint n,wyn;\n\nint main(){\n\tscanf(""%d"",&n);\n\tif (n<3){\n\t\tif (n==1) printf(""0\\n"");\n\t\telse printf(""1\\n1 2\\n"");\n\t\treturn 0;\n\t}\n\tREP(i,n){\n\t\twyn+=(n-i)/2;\n\t}\n\tprintf(""%d\\n"",wyn);\n\tREP(i,n){\n\t\tREP(j,(n-i)/2){\n\t\t\tprintf(""%d %d\\n"",i+1,i+2*j+2);\n\t\t}\n\t}\n}\n']","['constructive algorithms', 'graphs', 'greedy']",1900
https://codeforces.com//contest/1349/problem/A,A. Orac and LCM,For the multiset of positive integers s s 1 s 2 dots s k define the Greatest Common Divisor GCD and Least Common Multiple LCM of s as follow gcd s is the maximum positive integer x such that all integers in s are divisible on x textrm lcm s is the minimum positive integer x that divisible on all integers from s For example gcd 8 12 4 gcd 12 18 6 6 and textrm lcm 4 6 12 Note that for any positive integer x gcd x textrm lcm x x Orac has a sequence a with length n He come up with the multiset t textrm lcm a i a j i j and asked you to find the value of gcd t for him In other words you need to calculate the GCD of LCMs of all pairs of elements in the given sequence ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint d[N];\nint ans[N][3];\n\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int i = 2; i < N; i++) {\n\t\tif (d[i]) continue;\n\t\tfor (int j = i; j < N; j += i)\n\t\t\tif (d[j] == 0)\n\t\t\t\td[j] = i;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tans[i][0] = ans[i][1] = 100;\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\twhile(x > 1) {\n\t\t\tint p = d[x];\n\t\t\tint t = 0;\n\t\t\twhile(x % p == 0) {\n\t\t\t\tx /= p;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (t < ans[p][j])\n\t\t\t\t\tswap(t, ans[p][j]);\n\t\t\t}\n\t\t\tans[p][2]++;\n\t\t}\n\t}\n\tll res = 1;\n\tfor (int p = 2; p < N; p++) {\n\t\tif (ans[p][2] <= n - 2) continue;\n\t\tint t = 0;\n\t\tif (ans[p][2] == n - 1)\n\t\t\tt = ans[p][0];\n\t\telse\n\t\t\tt = ans[p][1];\n\t\twhile(t--) res *= p;\n\t}\n\tprintf(""%lld\\n"", res);\n\n\treturn 0;\n}\n']","['data structures', 'math', 'number theory']",1600
https://codeforces.com//contest/985/problem/B,B. Switches and Lamps,You are given switches and lamps The th switch turns on some subset of the lamps This information is given as the matrix consisting of rows and columns where if the th switch turns on the th lamp and if the th switch is not connected to the th lamp Initially all lamps are turned off Switches change state only from off to on It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards It is guaranteed that if you push all switches then Your think that you have too many switches and you would like to ignore one of them Your task is to say if there exists such a switch that if you will ignore not use it but press all the other switches then all the lamps will be turned on ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n, m, co[2000];\nchar g[2000][2000];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    F0R(i,n) F0R(j,m) {\n        cin >> g[i][j];\n        if (g[i][j] == \'1\') co[j] ++;\n    }\n    F0R(i,n) {\n        bool need = 0;\n        F0R(j,m) if (co[j] == 1 && g[i][j] == \'1\') need = 1;\n        if (!need) {\n            cout << ""YES"";\n            exit(0);\n        }\n    }\n    cout << ""NO"";\n    \n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)']",['implementation'],1200
https://codeforces.com//contest/825/problem/A,A. Binary Protocol,Polycarp has just invented a new binary protocol for data transmission He is encoding positive integer decimal number to binary string using following algorithm Each digit is represented with number of characters equal to the value of that digit for it is zero ones Digits are written one by one in order corresponding to number and separated by single character Though Polycarp learnt how to encode the numbers he has no idea how to decode them back Help him calculate the decoded number ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n    int n;\n    in >> n;\n    std::string s;\n    in >> s;\n    s.push_back(\'0\');\n    int res = 0;\n    int cur = 0;\n    for (size_t i = 0; i < s.length(); i++) {\n        if (s[i] == \'1\') {\n            cur++;\n        } else {\n            res = 10 * res + cur;\n            cur = 0;\n        }\n    }\n    out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']",['implementation'],1100
https://codeforces.com//contest/1635/problem/E,E. Cars ,There are n cars on a coordinate axis OX Each car is located at an integer point initially and no two cars are located at the same point Also each car is oriented either left or right and they can move at any constant positive speed in that direction at any moment More formally we can describe the i th car with a letter and an integer its orientation ori i and its location x i If ori i L then x i is decreasing at a constant rate with respect to time Similarly if ori i R then x i is increasing at a constant rate with respect to time We call two cars if they never end up in the same point regardless of their speed In other words they won t share the same coordinate at any moment We call two cars if they always end up in the same point regardless of their speed In other words they must share the same coordinate at some moment Unfortunately we lost all information about our cars but we do remember m relationships There are two types of relationships 1 i j i th car and j th car are 2 i j i th car and j th car are Restore the orientations and the locations of the cars satisfying the relationships or report that it is impossible If there are multiple solutions you can output any Note that if two cars share the same coordinate they will intersect but at the same moment they will continue their movement in their directions ,"['// Problem: E. Cars \n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/E\n// Memory Limit: 512 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nint op[200003],x[200003],y[200003];\nvector<int> e[200003],ee[200003];\nint col[200003];\nint ans[200003],deg[200003];\nvoid dfs(int x)\n{\n\tfor(int y:e[x]) if(y!=x) \n\t{\n\t\tif(col[y]==-1) col[y]=col[x]^1,dfs(y);\n\t\telse if(col[x]==col[y]) puts(""NO""),exit(0);\n\t}\n}\nsigned main()\n{\n\tmemset(col,-1,sizeof(col));\n\tint n=read(),m=read();\n\tfor(int i=1; i<=m; ++i) op[i]=read(),x[i]=read(),y[i]=read(),\n\te[x[i]].push_back(y[i]),e[y[i]].push_back(x[i]);\n\tfor(int i=1; i<=n; ++i) if(col[i]==-1) col[i]=0,dfs(i);\n\tqueue<int> q;\n\tfor(int i=1; i<=m; ++i)\n\t\tif(op[i]==1)\n\t\t{\n\t\t\tif(col[x[i]])//<-- y[i] x[i] --> \n\t\t\t{\n\t\t\t\t++deg[x[i]],ee[y[i]].push_back(x[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++deg[y[i]],ee[x[i]].push_back(y[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(col[x[i]])//x[i] --> <-- y[i] \n\t\t\t{\n\t\t\t\t++deg[y[i]],ee[x[i]].push_back(y[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++deg[x[i]],ee[y[i]].push_back(x[i]);\n\t\t\t}\n\t\t}\n\tfor(int i=1; i<=n; ++i) if(!deg[i]) q.push(i);\n\tint cnt=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tans[x]=++cnt;q.pop();\n\t\tfor(int y:ee[x]) if(!--deg[y]) q.push(y);\n\t}\n\tif(cnt!=n) puts(""NO""),exit(0);\n\tputs(""YES"");\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tif(col[i]) putchar(\'R\');\n\t\telse putchar(\'L\');\n\t\tprintf("" %d\\n"",ans[i]);\n\t}\n\treturn 0;\n}']","['2-sat', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']",2200
https://codeforces.com//contest/312/problem/B,B. Archer,SmallR is an archer SmallR is taking a match of archer with Zanoes They try to shoot in the target in turns and SmallR shoots first The probability of shooting the target each time is for SmallR while for Zanoes The one who shoots in the target first should be the winner Output the probability that SmallR will win the match ,"['#include<iostream>\n#include<cstdio>\nusing namespace std;\ndouble a,b,c,d,x,y;\nint main()\n{\n    cin>>a>>b>>c>>d;\n    x=a/b,y=c/d;\n    printf(""%.10lf\\n"",x/(1-(1-x)*(1-y)));\n    return 0;\n}']","['math', 'probabilities']",1300
https://codeforces.com//contest/154/problem/D,D. Flatland Fencing,The King of Flatland will organize a knights tournament The winner will get half the kingdom and the favor of the princess of legendary beauty and wisdom The final test of the applicants courage and strength will be a fencing tournament The tournament is held by the following rules the participants fight one on one the winner or rather the survivor transfers to the next round Before the battle both participants stand at the specified points on the axis with integer coordinates Then they make moves in turn The first participant moves first naturally During a move the first participant can transfer from the point to any integer point of the interval The second participant can transfer during a move to any integer point of the interval That is the options for the players moves are symmetric note that the numbers and are not required to be positive and if then staying in one place is a correct move At any time the participants can be located arbitrarily relative to each other that is it is allowed to jump over the enemy in any direction A participant wins if he uses his move to transfer to the point where his opponent is Of course the princess has already chosen a husband and now she wants to make her sweetheart win the tournament He has already reached the tournament finals and he is facing the last battle The princess asks the tournament manager to arrange the tournament finalists in such a way that her sweetheart wins the tournament considering that both players play optimally However the initial location of the participants has already been announced and we can only pull some strings and determine which participant will be first and which one will be second But how do we know which participant can secure the victory Alas the princess is not learned in the military affairs Therefore she asks you to determine how the battle will end considering that both opponents play optimally Also if the first player wins your task is to determine his winning move ,"['#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long x1,x2,a,b;\ninline int solve(long long& winm){\n    if(x2-x1<=b&&x2-x1>=a){\n        // one step\n        winm = x2;\n        return 1;\n    }\n    bool ref=0;\n    if(b<=0){\n        a*=-1;b*=-1;x1*=-1;x2*=-1;\n        swap(a,b);\n        ref=1;\n    }\n    if(a>0){\n        if(x1>x2)return 0;\n        long long tot=a+b;\n        long long r=x2-x1;\n        long long s=r%tot;\n        if(s==0)return -1;\n        if(s>=a&&s<=b){\n            winm=s+x1;\n            if(ref)winm*=-1;\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\nint main(){\n    scanf(""%I64d%I64d%I64d%I64d"",&x1,&x2,&a,&b);\n    if(a>b)swap(a,b);\n    long long f;\n    int d=solve(f);\n    puts(d==0?""DRAW"":d==-1?""SECOND"":""FIRST"");\n    if(d==1)printf(""%I64d\\n"",f);\n}\n']","['games', 'math']",2400
https://codeforces.com//contest/1045/problem/J,J. Moonwalk challenge,Since astronauts from BubbleCup XI mission finished their mission on the Moon and are big fans of famous singer they decided to spend some fun time before returning to the Earth and hence created a so called Moonwalk challenge game Teams of astronauts are given the map of craters on the Moon and direct bidirectional paths from some craters to others that are safe for Moonwalking Each of those direct paths is colored in one color and there is unique path between each two craters Goal of the game is to find two craters such that given array of colors appears most times as continuous subarray on the path between those two craters overlapping appearances should be counted To help your favorite team win you should make a program that given the map answers the queries of the following type For two craters and array of colors answer how many times given array appears as continuous subarray on the path from the first crater to the second Colors are represented as lowercase English alphabet letters ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nusing hsh = ull;\nconst int MAXN = 120000;\nconst int LOG = 20;\nconst hsh P = 23917;\n\nint n;\nvector<pair<int, char>> eds[MAXN];\nint aa[MAXN];\nint bb[MAXN];\nstring s[MAXN];\nint up[MAXN][LOG];\nchar pc[MAXN];\nint tm1;\nint tin[MAXN];\nint tout[MAXN];\nint h[MAXN];\n\nvoid dfs1(int v, int p) {\n\ttin[v] = tm1++;\n\tup[v][0] = p;\n\tfor (int i = 1; i < LOG; ++i)\n\t\tup[v][i] = up[up[v][i - 1]][i - 1];\n\tfor (auto e: eds[v]) {\n\t\tif (e.first == p)\n\t\t\tcontinue;\n\t\th[e.first] = h[v] + 1;\n\t\tpc[e.first] = e.second;\n\t\tdfs1(e.first, v);\n\t}\n\ttout[v] = tm1;\n}\n\nbool is_p(int a, int b) {\n\treturn tin[a] <= tin[b] && tin[b] < tout[a];\n}\n\nint lca(int a, int b) {\n\tif (is_p(a, b))\n\t\treturn a;\n\tif (is_p(b, a))\n\t\treturn b;\n\tfor (int i = LOG - 1; i >= 0; --i) {\n\t\tif (!is_p(up[a][i], b))\n\t\t\ta = up[a][i];\n\t}\n\treturn up[a][0];\n}\n\nint goup(int a, int h) {\n\tfor (int i = LOG - 1; i >= 0; --i) {\n\t\tif (h >= (1 << i))\n\t\t\th -= (1 << i), a = up[a][i];\n\t}\n\treturn a;\n}\n\nhsh geths(const string &s) {\n\thsh hs = 0;\n\tfor (int i = 0; i < s.size(); ++i)\n\t\ths = hs * P + s[i];\n\treturn hs;\n}\n\nhsh pw[MAXN];\nint ans[MAXN];\nvector<hsh> vv;\nvector<tuple<hsh, int, int>> go[MAXN];\n\nvoid add(int v, hsh hs, int k, int d) {\n\tgo[v].emplace_back(hs, k, d);\n}\n\nint lst[MAXN * 2];\nint cc[MAXN * 2];\nvector<char> st;\n\nvoid dfs2(int v, int p) {\n\tif (v != 0)\n\t\tst.push_back(pc[v]);\n\tvector<pair<int, int>> undo;\n\thsh hs = 0;\n\tfor (int i = (int)st.size() - 1; i >= 0 && i >= (int)st.size() - 100; --i) {\n\t\ths = hs * P + st[i];\n\t\tint pos = lower_bound(ALL(vv), hs) - vv.begin();\n\t\tif (pos == vv.size() || vv[pos] != hs)\n\t\t\tcontinue;\n\t\tundo.emplace_back(pos, lst[pos]);\n\t\t++cc[pos];\n\t}\n\n\tfor (auto q: go[v]) {\n\t\thsh hs; int k, d;\n\t\ttie(hs, k, d) = q;\n\t\tint pos = lower_bound(ALL(vv), hs) - vv.begin();\n\t\tif (pos == vv.size() || vv[pos] != hs)\n\t\t\tcontinue;\n\t\tans[k] += d * cc[pos];\n\t}\n\tfor (auto e: eds[v]) {\n\t\tif (e.first == p)\n\t\t\tcontinue;\n\t\tdfs2(e.first, v);\n\t}\n\n\tfor (auto p: undo) {\n\t\t--cc[p.first];\n\t\tlst[p.first] = p.second;\n\t}\n\tif (v != 0)\n\t\tst.pop_back();\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tpw[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tpw[i] = (pw[i - 1] * P);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tchar c;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tcin >> c;\n\t\teds[a].emplace_back(b, c);\n\t\teds[b].emplace_back(a, c);\n\t}\n\tdfs1(0, 0);\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tcin >> aa[i] >> bb[i];\n\t\t--aa[i], --bb[i];\n\t\tcin >> s[i];\n\t\tint x = lca(aa[i], bb[i]);\n\t\tint a = aa[i];\n\t\tint b = bb[i];\n\t\tint ga = a;\n\t\tif (h[a] - h[x] > s[i].size() - 1)\n\t\t\tga = goup(a, h[a] - h[x] - (s[i].size() - 1));\n\t\tint gb = b;\n\t\tif (h[b] - h[x] > s[i].size() - 1)\n\t\t\tgb = goup(b, h[b] - h[x] - (s[i].size() - 1));\n\t\tstring s2;\n\t\tstring tmp;\n\t\tint cur = ga;\n\t\twhile (cur != x)\n\t\t\ts2 += pc[cur], cur = up[cur][0];\n\t\tcur = gb;\n\t\twhile (cur != x)\n\t\t\ttmp += pc[cur], cur = up[cur][0];\n\t\treverse(ALL(tmp));\n\t\ts2 += tmp;\n\t\thsh hs = geths(s[i]);\n\t\tif (s2.size() >= s[i].size()) {\n\t\t\thsh now = 0;\n\t\t\tfor (int j = 0; j < s[i].size(); ++j)\n\t\t\t\tnow = now * P + s2[j];\n\t\t\tif (now == hs)\n\t\t\t\t++ans[i];\n\t\t\tfor (int j = s[i].size(); j < s2.size(); ++j) {\n\t\t\t\tnow = now * P + s2[j];\n\t\t\t\tnow -= pw[s[i].size()] * s2[j - s[i].size()];\n\t\t\t\tif (now == hs)\n\t\t\t\t\t++ans[i];\n\t\t\t}\n\t\t}\n\t\tvv.push_back(hs);\n\t\tadd(a, hs, i, 1);\n\t\tadd(ga, hs, i, -1);\n\t\treverse(ALL(s[i]));\n\t\ths = geths(s[i]);\n\t\tvv.push_back(hs);\n\t\tadd(b, hs, i, 1);\n\t\tadd(gb, hs, i, -1);\n\t}\n\tsort(ALL(vv));\n\tvv.resize(unique(ALL(vv)) - vv.begin());\n\tfor (int i = 0; i < vv.size(); ++i)\n\t\tlst[i] = -1, cc[i] = 0;\n\tdfs2(0, -1);\n\tfor (int i = 0; i < q; ++i)\n\t\tcout << ans[i] << ""\\n"";\n\treturn 0;\n}\n\n']","['data structures', 'strings', 'trees']",2600
https://codeforces.com//contest/1517/problem/F,F. Reunion,It is reported that the 2050 Conference will be held in Yunqi Town in Hangzhou from April 23 to 25 including theme forums morning jogging camping and so on The relationship between the n volunteers of the 2050 Conference can be represented by a tree a connected undirected graph with n vertices and n 1 edges The n vertices of the tree corresponds to the n volunteers and are numbered by 1 2 ldots n We define the distance between two volunteers i and j i j as the number of edges on the shortest path from vertex i to vertex j on the tree i j 0 whenever i j Some of the volunteers can attend the on site reunion while others cannot If for some volunteer x and nonnegative integer r all volunteers whose distance to x is no more than r can attend the on site reunion a forum with radius r can take place The of the on site reunion is defined as the maximum possible radius of any forum that can take place Assume that each volunteer can attend the on site reunion with probability frac 1 2 and these events are independent Output the expected level of the on site reunion When no volunteer can attend the level is defined as 1 When all volunteers can attend the level is defined as n ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint N;\nvi adj[305];\n// map<pi,int> dp[305];\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nint max_bad;\n\nmap<pi,mi> solve(int x, int y) {\n\tmap<pi,mi> dp;\n\tdp[{MOD,0}] = 1; // >= 0 -> need\n\t// < 0 -> provide\n\teach(c,adj[x]) if (c != y) {\n\t\tauto c_ans = solve(c,x);\n\t\tmap<pi,mi> DP;\n\t\teach(a,dp) each(b,c_ans) {\n\t\t\tint closest = min(a.f.f,b.f.f+1);\n\t\t\tint farthest_bad = max(a.f.s,b.f.s+1);\n\t\t\tif (farthest_bad <= max_bad)\n\t\t\t\tDP[{closest,farthest_bad}] += a.s*b.s;\n\t\t}\n\t\tswap(dp,DP);\n\t}\n\tmap<pi,mi> DP;\n\teach(a,dp) {\n\t\tassert(a.f.s <= max_bad);\n\t\tif (a.f.f+a.f.s <= max_bad) {\n\t\t\tDP[{a.f.f,-1}] += a.s;\n\t\t} else {\n\t\t\tDP[a.f] += a.s;\n\t\t}\n\t\tDP[{0,-1}] += a.s;\n\t}\n\treturn DP;\n}\n\nvoid ad(vmi& v, int ind, mi prod) {\n\twhile (sz(v) <= ind) v.pb(0);\n\tv[ind] += prod;\n}\n\nAR<vmi,2> solve_new(int a, int b) {\n\tAR<vmi,2> dp; // bad, good\n\tdp[0] = {1};\n\t// dp[0] = 1; // >= 0 -> need\n\t// // < 0 -> provide\n\n\teach(c,adj[a]) if (c != b) {\n\t\tauto c_ans = solve_new(c,a);\n\t\tF0R(i,2) c_ans[i].ins(begin(c_ans[i]),0);\n\t\tAR<vmi,2> res;\n\t\tF0R(x,2) F0R(y,2) \n\t\t\tF0R(xx,sz(dp[x])) F0R(yy,sz(c_ans[y])) {\n\t\t\t\tmi prod = dp[x][xx]*c_ans[y][yy];\n\t\t\t\tif (x == 0) {\n\t\t\t\t\tif (y == 0) {\n\t\t\t\t\t\tad(res[0],max(xx,yy),prod);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (xx+yy <= max_bad) {\n\t\t\t\t\t\t\tad(res[1],yy,prod);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tad(res[0],xx,prod);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (y == 0) {\n\t\t\t\t\t\tif (xx+yy <= max_bad) {\n\t\t\t\t\t\t\tad(res[1],xx,prod);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tad(res[0],yy,prod);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tad(res[1],min(xx,yy),prod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tswap(dp,res);\n\t}\n\t// dbg(""BEF"",dp);\n\tauto DP = dp;\n\tF0R(i,sz(dp[0])) if (i <= max_bad) ad(DP[1],0,dp[0][i]);\n\tF0R(i,sz(dp[1])) ad(DP[1],0,dp[1][i]);\n\t// dbg(""RESULT"",a,b,dp);\n\treturn DP;\n}\n\nmi all_within(int x) {\n\tauto a = solve_new(1,0);\n\tdbg(""HA"",a);\n\tmi ans = 0;\n\teach(t,a[1]) ans += t;\n\treturn ans;\n\t// if (x == 0) return 1;\n\t// mi ret = 0;\n\t// auto a = solve(1,0);\n\t// each(t,a) if (t.f.s == -1) ret += t.s;\n\t// return ret;\n}\n\n// dp[vertex][closest][farthest uncovered]\n\n// for each x: find # candidates such that\n\t// exists bad vertex within x of every vertex\n\nint main() {\n\tsetIO(); re(N);\n\trep(N-1) {\n\t\tints(a,b);\n\t\tadj[a].pb(b), adj[b].pb(a);\n\t}\n\tvmi rec(N);\n\tF0R(x,N) {\n\t\tmax_bad = x;\n\t\trec[x] = all_within(x);\n\t}\n\tdbg(rec);\n\tassert(rec.bk == pow(mi(2),N)-1);\n\t// rec[N] = pow(mi(2),N);\n\tmi ans = 0;\n\tF0R(i,N) {\n\t\tans += (rec[i]-(i?rec[i-1]:0))*(i-1);\n\t\t// dbg(""NUM WITH"",i,(rec[i]-(i?rec[i-1]:0)));\n\t\t// rec[i]-rec[i-1] -> exists bad within i, but not i-1\n\t\t// rec[i]-rec[i-1]*(i-1)\n\t\t// (rec[i]-rec[i-1])*i;\n\t}\n\tans += N;\n\tdbg(ans);\n\tps(ans/pow(mi(2),N));\n\t// dbg(rec);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['combinatorics', 'dp', 'trees']",3200
https://codeforces.com//contest/311/problem/B,B. Cats Transport,Zxr960115 is owner of a large farm He feeds cute cats and employs feeders There s a straight road across the farm and hills along the road numbered from 1 to from left to right The distance between hill and is meters The feeders live in hill 1 One day the cats went out to play Cat went on a trip to hill finished its trip at time and then waited at hill for a feeder The feeders must take all the cats Each feeder goes straightly from hill 1 to without waiting at a hill and takes all the cats at each hill away Feeders walk at a speed of 1 meter per unit time and are strong enough to take as many cats as they want For example suppose we have two hills and one cat that finished its trip at time 3 at hill 2 Then if the feeder leaves hill 1 at time 2 or at time 3 he can take this cat but if he leaves hill 1 at time 1 he can t take it If the feeder leaves hill 1 at time 2 the cat waits him for 0 time units if the feeder leaves hill 1 at time 3 the cat waits him for 1 time units Your task is to schedule the time leaving from hill 1 for each feeder so that the sum of the waiting time of all cats is minimized ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,p,x,h,t,now,last,d[100010],ti[100010],q[100010];\nlong long f[100010][2],sum[100010];\nint main(){\n    scanf(""%d%d%d"",&n,&m,&p);\n    for(int i=2;i<=n;++i){\n        scanf(""%d"",&d[i]);\n        d[i]+=d[i-1];\n    }\n    for(int i=1;i<=m;++i){\n        scanf(""%d%d"",&x,&ti[i]);\n        ti[i]-=d[x];\n        sum[i]=sum[i-1]+ti[i];\n    }\n    sort(ti+1,ti+m+1);\n    memset(f,63,sizeof(f));\n    f[0][0]=0;\n    for(int e=1;e<=p;++e){\n        last=now;now^=1;\n        h=t=0;q[t]=0; \n        for(int i=1;i<=m;++i){\n            while(h<t&&f[q[h+1]][last]+sum[q[h+1]]-f[q[h]][last]-sum[q[h]]<=(long long)ti[i]*(q[h+1]-q[h]))++h;\n            f[i][now]=f[q[h]][last]+(long long)ti[i]*(i-q[h])-(sum[i]-sum[q[h]]);\n            while(h<t&&(f[q[t]][last]+sum[q[t]]-f[q[t-1]][last]-sum[q[t-1]])/(double)(q[t]-q[t-1]) > (f[i][last]+sum[i]-f[q[t]][last]-sum[q[t]])/(double)(i-q[t]) )--t;\n            q[++t]=i;\n        }\n    }\n    printf(""%I64d\\n"",f[m][now]);\n    return 0;\n} \n']","['data structures', 'dp']",2400
https://codeforces.com//contest/1904/problem/B,B. Collecting Game,You are given an array a of n positive integers and a score If your score is greater than or equal to a i then you can increase your score by a i and remove a i from the array For each index i output the maximum number of additional array elements that you can remove if you remove a i and then set your score to a i Note that the removal of a i should not be counted in the answer ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1e5 + 5;\nint T, n, m, a[N], id[N];\nll sum[N], mnv[N], ans[N];\nint pos[N];\n\ninline bool cmp(int i, int j) {\n\treturn a[i] < a[j];\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i) cin >> a[i], id[i] = i;\n\t\tsort(id + 1, id + n + 1, cmp);\n\t\tfor (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + a[id[i]];\n\t\tmnv[0] = 1e18;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tmnv[i] = min(mnv[i - 1], sum[i - 1] - a[id[i]]);\n\t\tm = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (sum[i - 1] < a[id[i]])\n\t\t\t\tpos[++m] = i;\n\t\tpos[m + 1] = n + 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (mnv[i - 1] >= -a[id[i]]) {\n\t\t\t\tans[id[i]] = *upper_bound(pos + 1, pos + m + 1, i) - 2;\n\t\t\t} else {\n\t\t\t\tans[id[i]] = upper_bound(mnv + 1, mnv + i, a[id[i]], greater<int>()) - mnv - 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) cout << ans[i] << ' ';\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}\n""]","['binary search', 'dp', 'greedy', 'sortings', 'two pointers']",1100
https://codeforces.com//contest/1295/problem/E,E. Permutation Separation,You are given a permutation p 1 p 2 dots p n an array where each integer from 1 to n appears exactly once The weight of the i th element of this permutation is a i At first you separate your permutation into two sets prefix and suffix More formally the first set contains elements p 1 p 2 dots p k the second p k 1 p k 2 dots p n where 1 le k n After that you may move elements between sets The operation you are allowed to do is to choose some element of the first set and move it to the second set or vice versa move from the second set to the first You have to pay a i dollars to move the element p i Your goal is to make it so that each element of the first set is less than each element of the second set Note that if one of the sets is empty this condition is met For example if p 3 1 2 and a 7 1 4 then the optimal strategy is separate p into two parts 3 1 and 2 and then move the 2 element into first set it costs 4 And if p 3 5 1 6 2 4 a 9 1 9 9 1 9 then the optimal strategy is separate p into two parts 3 5 1 and 6 2 4 and then move the 2 element into first set it costs 1 and 5 element into second set it also costs 1 Calculate the minimum number of dollars you have to spend ,"[""// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2e5 + 5;\nconst size_t V = N << 2;\n\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n\nLL val[V], tag[V];\n\nvoid pushup(int x) {\n    val[x] = min(val[lc(x)], val[rc(x)]);\n}\n\nvoid update(int x, LL v) {\n    val[x] += v;\n    tag[x] += v;\n}\n\nvoid pushdown(int x) {\n    if (tag[x]) {\n        update(lc(x), tag[x]);\n        update(rc(x), tag[x]);\n        tag[x] = 0;\n    }\n}\n\nvoid modify(int x, int tl, int tr, int l, int r, LL v) {\n    if (tl >= r || tr <= l) return;\n    if (l <= tl && tr <= r) {\n        return update(x, v);\n    }\n    pushdown(x);\n    int mid = (tl + tr) >> 1;\n    modify(lc(x), tl, mid, l, r, v);\n    modify(rc(x), mid, tr, l, r, v);\n    pushup(x);\n}\n\nint p[N], a[N];\n\nint main() {\n    int n = read();\n    generate_n(p, n, read);\n    generate_n(a, n, read);\n    for (int i = 0; i < n; ++i) {\n        modify(1, 0, n + 1, p[i], n + 1, a[i]);\n    }\n    LL ans = 1e18;\n    for (int i = 0; i + 1 < n; ++i) {\n        modify(1, 0, n + 1, p[i], n + 1, -a[i]);\n        modify(1, 0, n + 1, 0, p[i], a[i]);\n        ans = min(ans, val[1]);\n    }\n    cout << ans;\n    return 0;\n}\n""]","['data structures', 'divide and conquer']",2200
https://codeforces.com//contest/1879/problem/D,D. Sum of XOR Functions,You are given an array a of length n consisting of non negative integers You have to calculate the value of sum l 1 n sum r l n f l r cdot r l 1 where f l r is a l oplus a l 1 oplus dots oplus a r 1 oplus a r the character oplus denotes bitwise XOR Since the answer can be very large print it modulo 998244353 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    ll A[N]; F0R(i, N) cin >> A[i];\n    ll ans = 0;\n    F0R(b, 30) {\n        ll cb = 1ll<<b;\n        ll cnt[2]; F0R(i, 2) cnt[i] = 0;\n        cnt[0] = 1;\n        ll sum[2]; F0R(i, 2) sum[i] = 0;\n        ll cur = 0;\n        F0R(i, N) {\n            if (A[i]&cb) cur ^= 1;\n            cnt[cur]++;\n            sum[cur] += i+1;\n            ll cv = cnt[cur^1] * (i+1) - sum[cur^1];\n            cv %= MOD;\n            ans += cv * cb;\n            ans %= MOD;\n        }\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']","['bitmasks', 'combinatorics', 'divide and conquer', 'dp', 'math']",1700
https://codeforces.com//contest/1283/problem/F,F. DIY Garland,Polycarp has decided to decorate his room because the New Year is soon One of the main decorations that Polycarp will install is the garland he is going to solder himself Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp He is going to solder a garland consisting of n lamps and n 1 wires Exactly one lamp will be connected to power grid and power will be transmitted from it to other lamps by the wires Each wire connectes exactly two lamps one lamp is called for this wire the one that gets power from some other wire and transmits it to this wire the other one is called the one that gets power from this wire Obviously each lamp has at most one wire that brings power to it and this lamp is the auxiliary lamp for this wire and the main lamp for all other wires connected directly to it Each lamp has a brightness value associated with it the i th lamp has brightness 2 i We define the of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut and all other wires are still working Polycarp has drawn the scheme of the garland he wants to make the scheme depicts all n lamp and n 1 wires and the lamp that will be connected directly to the grid is marked the wires are placed in such a way that the power can be transmitted to each lamp After that Polycarp calculated the importance of each wire enumerated them from 1 to n 1 in descending order of their importance and then wrote the index of the main lamp for each wire in the order from the first wire to the last one The following day Polycarp bought all required components of the garland and decided to solder it but he could not find the scheme Fortunately Polycarp found the list of indices of main lamps for all wires Can you help him restore the original scheme ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\n\nbool findPath[MAXN];\n\nvector< pii > ans;\n\nint main()\n{\n\tscanf(""%d"",&n);\n\n\tfor(int i = 1 ; i < n ; i++)\n\t\tscanf(""%d"",&v[i]);\n\n\tprintf(""%d\\n"",v[1]);\n\n\tfindPath[ v[1] ] = true;\n\n\tint p = 2;\n\tint last = n;\n\n\twhile( true )\n\t{\n\t\twhile( last > 0 && findPath[last] ) last--;\n\t\tfindPath[last] = true;\n\n\t\tif( last == 0 ) break;\n\n\t\twhile( p < n && !findPath[ v[p] ] )\n\t\t{\n\t\t\tans.push_back( { v[p - 1] , v[p] } );\n\t\t\tfindPath[ v[p] ] = true;\n\t\t\tp++;\n\t\t}\n\n\t\tans.push_back( { last , v[p - 1] } );\n\t\tp++;\n\t}\n\n\tfor(int i = 0 ; i < n - 1 ; i++)\n\t\tprintf(""%d %d\\n"",ans[i].first,ans[i].second);\n}']","['constructive algorithms', 'greedy', 'trees']",2200
https://codeforces.com//contest/1848/problem/A,A. Vika and Her Friends,Vika and her friends went shopping in a mall which can be represented as a rectangular grid of rooms with sides of length n and m Each room has coordinates a b where 1 le a le n 1 le b le m Thus we call a hall with coordinates c d a neighbouring for it if a c b d 1 Tired of empty fashion talks Vika decided to sneak away unnoticed But since she hasn t had a chance to visit one of the shops yet she doesn t want to leave the mall After a while her friends noticed Vika s disappearance and started looking for her Currently Vika is in a room with coordinates x y and her k friends are in rooms with coordinates x 1 y 1 x 2 y 2 x k y k respectively The coordinates can coincide Note that all the girls move to the neighbouring rooms Every minute first Vika moves to one of the adjacent to the side rooms of her choice and then each friend also chooses one of the adjacent rooms to move to If that is after all the girls have moved on to the neighbouring rooms at least one friend is in the same room as Vika she is caught and all the other friends are called Tell us can Vika run away from her annoying friends forever or will she have to continue listening to empty fashion talks after some time ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\nconst int mod = 998244353, N = 100005;\n \nvoid frank() {\n    int n, m, k; cin >> n >> m >> k;\n    int x, y; cin >> x >> y;\n    bool ok = 1;\n    for (int i = 0; i < k; ++i) {\n        int a, b; cin >> a >> b;\n        if ((a + b + x + y) % 2 == 0) ok = 0;\n    }\n    cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        frank();\n    }\n}']","['games', 'math']",900
https://codeforces.com//contest/1010/problem/D,D. Mars rover,Natasha travels around Mars in the Mars rover But suddenly it broke down namely the logical scheme inside it The scheme is an undirected tree connected acyclic graph with a root in the vertex 1 in which every leaf excluding root is an input and all other vertices are logical elements including the root which is output One bit is fed to each input One bit is returned at the output There are four types of logical elements AND 2 inputs OR 2 inputs XOR 2 inputs NOT 1 input Logical elements take values from their direct descendants inputs and return the result of the function they perform Natasha knows the logical scheme of the Mars rover as well as the fact that only one input is broken In order to fix the Mars rover she needs to change the value on this input For each input determine what the output will be if Natasha changes this input ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin » t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nenum Type {\n  AND,\n  OR,\n  XOR,\n  NOT,\n  IN\n};\n\nvector<Type> types;\nvector<vector<int>> g;\nvector<int> val;\nvector<int> val_changed;\nvector<int> parent;\n\nint dfs(int v, int p) {\n  parent[v] = p;\n  if (types[v] == IN) {\n    return val[v];\n  }\n  if (types[v] == NOT) {\n    return val[v] = !dfs(g[v][0], v);\n  }\n  if (types[v] == AND) {\n    return val[v] = dfs(g[v][0], v) & dfs(g[v][1], v);\n  }\n  if (types[v] == OR) {\n    return val[v] = dfs(g[v][0], v) | dfs(g[v][1], v);\n  }\n  if (types[v] == XOR) {\n    return val[v] = dfs(g[v][0], v) ^ dfs(g[v][1], v);\n  }\n}\n\nvoid dfs_ans(int v) {\n  if (v == 0) {\n    val_changed[v] = val[v] ^ 1;\n  } else {\n    int p = parent[v];\n    int new_val = (val[v] ^ 1);\n    if (types[p] == NOT) {\n      val_changed[v] = val_changed[p];\n    } else {\n      int diff_val = ((g[p][0] == v) ? val[g[p][1]] : val[g[p][0]]);\n      int parent_val = val[p];\n      if (types[p] == AND) {\n        parent_val = diff_val & new_val;\n      }\n      if (types[p] == OR) {\n        parent_val = diff_val | new_val;\n      }\n      if (types[p] == XOR) {\n        parent_val = diff_val ^ new_val;\n      }\n      if (parent_val != val[p]) {\n        val_changed[v] = val_changed[p];\n      } else {\n        val_changed[v] = val[0];\n      }\n    }\n  }\n  for (int to : g[v]) {\n    dfs_ans(to);\n  }\n}\n\nvoid solve(bool read) {\n  int n;\n  cin >> n;\n  types.resize(n);\n  g.clear();\n  g.resize(n);\n  val.resize(n);\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    if (s == ""IN"") {\n      types[i] = IN;\n      cin >> val[i];\n    } else if (s == ""NOT"") {\n      types[i] = NOT;\n      int cur;\n      cin >> cur;\n      --cur;\n      g[i].push_back(cur);\n    } else {\n      switch(s[0]) {\n        case \'A\':\n          types[i] = AND;\n          break;\n        case \'O\':\n          types[i] = OR;\n          break;\n        case \'X\':\n          types[i] = XOR;\n          break;\n        default:\n          assert(false);\n      }\n      g[i].resize(2);\n      for (int j = 0; j < 2; ++j) {\n        cin >> g[i][j];\n        --g[i][j];\n      }\n    }\n  }\n  parent.resize(n);\n  dfs(0, 0);\n  val_changed.resize(n);\n  dfs_ans(0);\n\n  for (int i = 0; i < n; ++i) {\n    if (types[i] == IN) {\n      cout << val_changed[i];\n    }\n  }\n  cout << ""\\n"";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","['dfs and similar', 'graphs', 'implementation', 'trees']",2000
https://codeforces.com//contest/1941/problem/C,C. Rudolf and the Ugly String,Rudolf has a string s of length n Rudolf considers the string s to be ugly if it contains the substring dagger or the substring otherwise the string s will be considered beautiful For example are ugly strings while are beautiful strings Rudolf wants to shorten the string s by removing some characters to make it beautiful The main character doesn t like to strain so he asks you to make the string beautiful by removing the minimum number of characters He can remove characters from positions in the string not just from the beginning or end of the string dagger String a is a substring of b if there exists a segment of characters in string b equal to a ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n ; cin >> n ;\n    string s ; cin >> s ;\n    int ans = 0 ;\n    if( s.size() >= 3 )\n    FOR( i , s.size() - 2 ){\n    \tif( s[ i ] == \'p\' && s[ i + 1 ] == \'i\' && s[ i + 2 ] == \'e\' ){\n    \t\tans ++ ; continue ; \n\t\t}\n\t\tif( s[ i ] == \'m\' && s[ i + 1 ] == \'a\' && s[ i + 2 ] == \'p\' ){\n    \t\tans ++ ; \n    \t\tif( i + 3 < s.size() && s[ i + 3 ] != \'p\' ){\n    \t\t\ti += 2 ; \n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << ""\\n"" ; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']","['dp', 'greedy', 'strings']",900
https://codeforces.com//contest/1000/problem/F,F. One Occurrence,You are given an array a consisting of n integers and q queries to it i th query is denoted by two integers l i and r i For each query you have to find integer that occurs in the subarray of a from index l i to index r i a subarray is a contiguous subsegment of an array For example if a 1 1 2 3 2 4 then for query l i 2 r i 6 the subarray we are interested in is 1 2 3 2 4 and possible answers are 1 3 and 4 for query l i 1 r i 2 the subarray we are interested in is 1 1 and there is no such element that occurs exactly once Can you answer all of the queries ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 500500;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint a[N];\nint l[N];\nint r[N];\nint ans[N];\nint used[N];\npair < int, int > t[4 * N];\n\nvoid upd(int x, int l, int r, int g, int y)\n{\n        if(l == r){\n                t[x] = {y, a[l]};\n                return;\n        }\n        int m = (l + r) / 2;\n        if(g <= m){\n                upd(x * 2, l, m, g, y);\n        }\n        else{\n                upd(x * 2 + 1, m + 1, r, g, y);\n        }\n        t[x] = max(t[x * 2], t[x * 2 + 1]);\n}\n\npair < int, int > get(int x, int l, int r, int tl, int tr)\n{\n        if(tl > tr){\n                return {0, 0};\n        }\n        if(l == tl && r == tr){\n                return t[x];\n        }\n        int m = (l + r) / 2;\n        return max(get(x * 2, l, m, tl, min(m, tr)), get(x * 2 + 1, m + 1, r, max(m + 1, tl), tr));\n}\n\nvoid solve()\n{\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n                l[i] = used[a[i]];\n                used[a[i]] = i;\n        }\n        for(int i = 1; i < N; i++){\n                used[i] = n + 1;\n        }\n        vector < pair < int, pair < int, int > > > v;\n        for(int i = n; i >= 1; i--){\n                r[i] = used[a[i]];\n                used[a[i]] = i;\n                v.push_back({l[i], {r[i], i}});\n        }\n        sort(v.begin(), v.end());\n        int q;\n        cin >> q;\n        vector < pair < int, pair < int, int > > > qu;\n        for(int i = 1; i <= q; i++){\n                int l, r;\n                cin >> l >> r;\n                qu.push_back({l, {r, i}});\n        }\n        sort(qu.begin(), qu.end());\n        int h = 0;\n        for(auto p: qu){\n                while(h < v.size() && v[h].fi < p.fi){\n                        upd(1, 1, n, v[h].se.se, v[h].se.fi);\n                        h++;\n                }\n                auto g = get(1, 1, n, p.fi, p.se.fi);\n                if(g.fi > p.se.fi){\n                        ans[p.se.se] = g.se;\n                }\n        }\n        for(int i = 1; i <= q; i++){\n                cout << ans[i] << ""\\n"";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","['data structures', 'divide and conquer']",2400
https://codeforces.com//contest/1113/problem/B,B. Sasha and Magnetic Machines,One day Sasha visited the farmer 2D and his famous magnetic farm On this farm the crop grows due to the influence of a special magnetic field Maintaining of the magnetic field is provided by n machines and the power of the i th machine is a i This year 2D decided to cultivate a new culture but what exactly he didn t say For the successful growth of the new culture it is necessary to slightly change the powers of the machines 2D can choose an arbitrary integer x then choose one machine and reduce the power of its machine by x times and at the same time increase the power of one another machine by x times powers of all the machines must stay Note that he may not do that if he wants More formally 2D can choose two such indices i and j and one integer x such that x is a divisor of a i and change powers as following a i frac a i x a j a j cdot xSasha is very curious that s why he wants to calculate the total power the farmer can reach There are too many machines and Sasha can t cope with computations help him ,"['#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n, a[50000];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a+n);\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) sum += a[i];\n\n    int sol = sum;\n    for (int i = 1; i < n; i++) {\n        for (int d = 2; d <= a[i]; d++) {\n            if(a[i] % d != 0) continue;\n            sol = min(sol, sum-a[0]-a[i] + d*a[0] + a[i]/d);\n        }\n    }\n    cout << sol << endl;\n    return 0;\n}\n']","['greedy', 'number theory']",1300
https://codeforces.com//contest/1394/problem/D,D. Boboniu and Jianghu,Since Boboniu finished building his Jianghu he has been doing Kungfu on these mountains every day Boboniu designs a map for his n mountains He uses n 1 roads to connect all n mountains Every pair of mountains is connected via roads For the i th mountain Boboniu estimated the tiredness of doing Kungfu on the top of it as t i He also estimated the height of each mountain as h i A is a sequence of mountains M such that for each i 1 le i M there exists a road between M i and M i 1 Boboniu would regard the as a if for each i 1 le i M h M i le h M i 1 Boboniu wants to divide n 1 roads into several Note that each road must appear in challenge but a mountain may appear in several challenges Boboniu wants to minimize the total tiredness to do all the The tiredness of a M is the sum of tiredness of all mountains in it i e sum i 1 M t M i He asked you to find the minimum total tiredness As a reward for your work you ll become a guardian in his Jianghu ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n;\nll H[MX], T[MX];\nvi adj[MX];\nll dp[MX][2];\n\nvoid dfs(int x, int y) { // 0 -> up, 1 -> down\n\t// max(zeroes, ones)\n\tll sum = 0;\n\tvl dif;\n\tint in = 0, out = 0;\n\ttrav(t,adj[x]) if (t != y) {\n\t\tdfs(t,x);\n\t\tif (H[t] < H[x]) {\n\t\t\tin ++;\n\t\t\tsum += dp[t][0];\n\t\t} else if (H[t] > H[x]) {\n\t\t\tout ++;\n\t\t\tsum += dp[t][1];\n\t\t} else {\n\t\t\tsum += dp[t][0]; // default: in\n\t\t\tdif.pb(dp[t][1]-dp[t][0]);\n\t\t}\n\t}\n\tsort(all(dif));\n\tauto get = [&](int z) {\n\t\tll res = INF, cur = sum;\n\t\tF0R(i,sz(dif)+1) {\n\t\t\tif (i) cur += dif[i-1];\n\t\t\tint IN = in+sz(dif)-i, OUT = out+i;\n\t\t\tif (z == 0) IN ++;\n\t\t\tif (z == 1) OUT ++;\n\t\t\tckmin(res,cur+max(IN,OUT)*T[x]);\n\t\t}\n\t\treturn res;\n\t};\n\tif (y) {\n\t\tdp[x][0] = get(1);\n\t\tdp[x][1] = get(0);\n\t} else {\n\t\tps(get(-1));\n\t}\n}\n\nint main() {\n\tsetIO(); re(n); \n\tFOR(i,1,n+1) re(T[i]);\n\tFOR(i,1,n+1) re(H[i]);\n\tF0R(i,n-1) {\n\t\tint u,v; re(u,v);\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tdfs(1,0);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","['dp', 'greedy', 'sortings', 'trees']",2800
https://codeforces.com//contest/1840/problem/G2,G2. In Search of Truth  Hard Version ,You are playing a game The circle is divided into n sectors sectors are numbered from 1 to n in some order You are in the adjacent room and do not know either the number of sectors or their numbers There is also an arrow that initially points to some sector Initially the host tells you the number of the sector to which the arrow points After that you can ask the host to move the arrow k sectors counterclockwise or clockwise at most 1000 times And each time you are told the number of the sector to which the arrow points Your task is to determine the integer n the number of sectors in at most 1000 queries It is guaranteed that 1 le n le 10 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int K=333;\nint random()\n{\n    return (int)(1.0*rand()/RAND_MAX*1e9);\n}\nmap<int,int> ma;\nint main()\n{\n    srand(time(0));\n    int m=0,x;\n    scanf(""%d"", &m);\n    for(int i=1;i<=K;i++)\n    {\n        printf(""+ %d\\n"",random());\n        fflush(stdout);\n        scanf(""%d"",&x);\n        if(x>m) m=x;\n    }\n    for(int i=1;i<=K;i++)\n    {\n        printf(""+ %d\\n"",1);\n        fflush(stdout);\n        scanf(""%d"",&x);\n        if(ma[x])\n        {\n            printf(""! %d"",i-1);\n            return 0;\n        }\n        else ma[x]=i;\n    }\n    printf(""+ %d\\n"",m);\n    fflush(stdout);\n    scanf(""%d"",&x);\n    if(ma[x])\n    {\n        printf(""! %d"",K+m-ma[x]);\n        return 0;\n    }\n    for(int i=1;i<=K;i++)\n    {\n        printf(""+ %d\\n"",K);\n        fflush(stdout);\n        scanf(""%d"",&x);\n        if(ma[x])\n        {\n            printf(""! %d"",(i+1)*K+m-ma[x]);\n            return 0;\n        }\n    }\n    return 0;\n}']","['constructive algorithms', 'interactive', 'math', 'meet-in-the-middle', 'probabilities']",2500
https://codeforces.com//contest/1775/problem/D,D. Friendly Spiders,Mars is home to an unusual species of spiders Binary spiders Right now Martian scientists are observing a colony of n spiders the i th of which has a i legs Some of the spiders are friends with each other Namely the i th and j th spiders are friends if gcd a i a j ne 1 i e there is some integer k ge 2 such that a i and a j are simultaneously divided by k without a remainder Here gcd x y denotes the greatest common divisor GCD of integers x and y Scientists have discovered that spiders can send messages If two spiders are friends then they can transmit a message directly in one second Otherwise the spider must pass the message to his friend who in turn must pass the message to his friend and so on until the message reaches the recipient Let s look at an example Suppose a spider with eight legs wants to send a message to a spider with 15 legs He can t do it directly because gcd 8 15 1 But he can send a message through the spider with six legs because gcd 8 6 2 and gcd 6 15 3 Thus the message will arrive in two seconds Right now scientists are observing how the s th spider wants to send a message to the t th spider The researchers have a hypothesis that spiders always transmit messages optimally For this reason scientists would need a program that could calculate the minimum time to send a message and also deduce one of the optimal routes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n;\nint arr[300005];\nbool has[300005];\n\nconst int BUF=300005;\nvector<int> al[600010];\n\nint w[600010];\nint pp[600010];\nqueue<int> q;\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tcin>>n;\n\trep(x,1,n+1) cin>>arr[x];\n\tint s,t; cin>>s>>t;\n\t\n\tif (s!=t && arr[s]==arr[t]){\n\t\tif (arr[s]==1) cout<<""-1""<<endl;\n\t\telse{\n\t\t\tcout<<2<<endl;\n\t\t\tcout<<s<<"" ""<<t<<endl;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\trep(x,1,n+1) has[arr[x]]=true;\n\t\n\trep(x,2,300005){\n\t\tfor (int y=x;y<300005;y+=x) if (has[y]){\n\t\t\tal[y].pub(BUF+x);\n\t\t\tal[BUF+x].pub(y);\n\t\t}\n\t}\n\t\n\tmemset(w,-1,sizeof(w));\n\tw[arr[s]]=0;\n\tq.push(arr[s]);\n\t\n\twhile (!q.empty()){\n\t\tint u=q.front(); q.pop();\n\t\tfor (auto it:al[u]){\n\t\t\tif (w[it]==-1){\n\t\t\t\tw[it]=w[u]+1;\n\t\t\t\tpp[it]=u;\n\t\t\t\tq.push(it);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (w[arr[t]]==-1){\n\t\tcout<<""-1""<<endl;\n\t\treturn 0;\n\t}\n\t\n\tvector<int> stk={arr[t]};\n\twhile (stk.back()!=arr[s]) stk.pub(pp[stk.back()]);\n\t\n\tmap<int,int> occ;\n\trep(x,1,n+1) occ[arr[x]]=x;\n\tocc[arr[s]]=s,occ[arr[t]]=t;\n\t\n\tcout<<w[arr[t]]/2+1<<endl;\n\tfor (int x=sz(stk)-1;x>=0;x-=2) cout<<occ[stk[x]]<<"" ""; cout<<endl;\n}\n']","['dfs and similar', 'graphs', 'math', 'number theory', 'shortest paths']",1800
https://codeforces.com//contest/820/problem/B,B. Mister B and Angle in Polygon,On one quiet day all of sudden Mister B decided to draw angle on his field Aliens have already visited his field and left many different geometric figures on it One of the figures is regular convex polygon with sides That s why Mister B decided to use this polygon Now Mister B must find three distinct vertices such that the angle where is the vertex of the angle and and lie on its sides is as close as possible to In other words the value should be minimum possible If there are many optimal solutions Mister B should be satisfied with any of them ,"['#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\tint n,a,minh;\n\tdouble ptr,mina=720;\nint inline read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\nint main()\n{\n\tn=read(),a=read();\n\tptr=(double)180/n;\n\tfor (int i=1;i<n-1;i++)\n\t\tif (fabs(ptr*i-a)<mina) mina=fabs(ptr*i-a),minh=i;\n\tprintf(""%d %d %d\\n"",1,2+minh,1+minh);\n\treturn 0;\n}']","['constructive algorithms', 'geometry', 'math']",1300
https://codeforces.com//contest/866/problem/C,C. Gotta Go Fast,You re trying to set the record on your favorite video game The game consists of levels which must be completed sequentially in order to beat the game You usually complete each level as fast as possible but sometimes finish a level slower Specifically you will complete the th level in either seconds or seconds where and there s a percent chance of completing it in seconds After completing a level you may decide to either continue the game and play the next level or reset the game and start again from the first level Both the decision and the action are instant Your goal is to complete all the levels sequentially in at most total seconds You want to minimize the expected amount of time playing before achieving that goal If you continue and reset optimally how much total time can you expect to spend playing ,"['/**\n *    author:  tourist\n *    created: 30.09.2017 20:16:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 55;\nconst int MAX = 12345;\n\nint a[N], b[N], p[N], sum_b[N];\ndouble f[N][MAX];\n\nint main() {\n  int n, r;\n  scanf(""%d %d"", &n, &r);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d %d %d"", a + i, b + i, p + i);\n  }\n  sum_b[0] = 0;\n  for (int i = 0; i < n; i++) {\n    sum_b[i + 1] = sum_b[i] + b[i];\n  }\n  double low = 0.0, high = 1e15;\n  for (int it = 0; it < 120; it++) {\n    double mid = (low + high) * 0.5;\n    for (int i = n; i >= 0; i--) {\n      for (int j = 0; j <= sum_b[i]; j++) {\n        if (i == n) {\n          f[i][j] = (j <= r ? 0.0 : mid);\n          continue;\n        }\n        f[i][j] = 0.01 * ((f[i + 1][j + a[i]] + a[i]) * p[i] + (f[i + 1][j + b[i]] + b[i]) * (100 - p[i]));\n        if (i > 0) {\n          f[i][j] = min(f[i][j], mid);\n        }\n      }\n    }\n    if (f[0][0] > mid) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  double ans = 0.5 * (low + high);\n  printf(""%.17f\\n"", ans);\n  return 0;\n}\n']","['binary search', 'dp', 'probabilities']",2400
https://codeforces.com//contest/613/problem/B,B. Skills,Lesha plays the recently published new version of the legendary game hacknet In this version character skill mechanism was introduced Now each player character has exactly skills Each skill is represented by a non negative integer the current skill level All skills have the same maximum level Along with the skills global ranking of all players was added Players are ranked according to the so called Force The of a player is the sum of the following values The number of skills that a character has perfected i e such that multiplied by coefficient The minimum skill level among all skills multiplied by coefficient Now Lesha has hacknetian currency units which he is willing to spend Each currency unit can increase the current level of any skill by if it s not equal to yet Help him spend his money in order to achieve the maximum possible value of the Force ,"['#include<cassert>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A, cf, cm;\n\nlong long m;\n\nint a[N], b[N], ord[N];\n\nlong long sum[N];\n\nbool byA(const int &i, const int &j) {\n    return a[i] < a[j];\n}\n\nint main() {\n    scanf(""%d%d%d%d"", &n, &A, &cf, &cm);\n    cin >> m;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", a + i);\n        b[i] = a[i];\n        ord[i] = i;\n    }\n    sort(ord, ord + n, byA);\n    sort(a, a + n);\n    for (int i = 0; i < n; ++i) {\n        sum[i + 1] = sum[i] + a[i];\n    }\n    long long ans = -1, ansi = -1, ansm = -1;\n    for (int i = 0, j = 0; i <= n; ++i) {\n        //i to n - 1 shall be all perfect then maxmize the minimum among 0 to i - 1\n        long long cost = 0, tmp = 0;\n        cost = (long long)A * (n - i) - (sum[n] - sum[i]);\n        if (cost > m) {\n            continue;\n        }\n        tmp += (n - i) * cf;\n        long long left = m - cost;\n        while (j < i && (long long)j * a[j] - sum[j] <= left) {\n            ++j;\n        }\n        int mins = 0;\n        if (j) {\n            mins = min((long long)A, (left + sum[j]) / j);\n        } else {\n            mins = A;\n        }\n        tmp += (long long)mins * cm;\n        if (tmp > ans) {\n            ans = tmp;\n            ansi = i;\n            ansm = mins;\n        }\n    }\n    cout << ans << endl;\n    long long cost = 0, mins = A, maxs = 0;\n    for (int i = 0; i < n; ++i) {\n        int delta = 0, u = b[ord[i]];\n        if (i >= ansi) {\n            delta = A - u;\n        } else {\n            delta = max(0ll, ansm - u);\n        }\n        b[ord[i]] += delta;\n        cost += delta;\n        mins = min(mins, (long long)b[ord[i]]);\n        maxs += b[ord[i]] == A;\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(""%d%c"", b[i], i == n - 1 ? \'\\n\' : \' \');\n    }\n    assert(cost <= m && mins * cm + maxs * cf == ans);\n    return 0;\n}']","['binary search', 'brute force', 'dp', 'greedy', 'sortings', 'two pointers']",1900
https://codeforces.com//contest/1007/problem/E,E. Mini Metro,In a simplified version of a Mini Metro game there is only one subway line and all the trains go in the same direction There are n stations on the line a i people are waiting for the train at the i th station at the beginning of the game The game starts at the beginning of the 0 th hour At the end of each hour couple minutes before the end of the hour b i people instantly arrive to the i th station If at some moment the number of people at the i th station is larger than c i you lose A player has several trains which he can appoint to some hours The capacity of each train is k passengers In the middle of the appointed hour the train goes from the 1 st to the n th station taking as many people at each station as it can accommodate A train can not take people from the i th station if there are people at the i 1 th station If multiple trains are appointed to the same hour their capacities are being added up and they are moving together The player wants to stay in the game for t hours Determine the minimum number of trains he will need for it ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 205;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>\n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nll d[MX][MX][2], g[MX][MX][2];\nll a[MX], b[MX], c[MX];\nll sa[MX], sb[MX];\nll n,t,k; \n\nll cdiv(ll a, ll b) {\n    return (a+b-1)/b;\n}\n\nint main() {\n\tre(n,t,k);\n\tFOR(i,1,n+1) re(a[i],b[i],c[i]);\n\ta[n+1] = c[n+1] = 1e18;\n\tFOR(i,1,n+2) {\n\t    sa[i] = sa[i-1]+a[i];\n\t    sb[i] = sb[i-1]+b[i];\n\t}\n\tFOR(p,1,n+2) F0R(s,t+1) F0R(z,2) {\n\t    d[p][s][z] = g[p][s][z] = INF;\n\t    if (s*b[p]+z*a[p] <= c[p] && d[p-1][s][z] != INF) {\n\t        d[p][s][z] = d[p-1][s][z];\n\t        ll val = cdiv(z*sa[p-1]+s*sb[p-1],k);\n\t        if (val*k <= z*sa[p]+s*sb[p]) g[p][s][z] = val;\n\t    }\n\t    F0R(r,s) if (g[p][r][z] != INF) {\n\t        ll m = z*sa[p]+r*sb[p]-k*g[p][r][z];\n\t        ll x = cdiv(max(m+(s-r)*b[p]-c[p],0LL),k); \n\t        // ps(""WAT"",p,s,z,r,m,x); \n\t        if (x*k <= m && d[p-1][s-r][0] != INF) {\n    \t        ckmin(d[p][s][z],g[p][r][z]+x+d[p-1][s-r][0]);\n    \t        ll val = cdiv((s-r)*sb[p-1],k);\n    \t        if (val*k <= (s-r)*sb[p]+m-x*k) \n    \t            ckmin(g[p][s][z],g[p][r][z]+x+val);\n\t        }\n\t    }\n\t    // ps(""??"",p,s,z,d[p][s][z],g[p][s][z]);\n\t}\n\tps(d[n+1][t][1]);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/']",['dp'],3400
https://codeforces.com//contest/1923/problem/E,E. Count Paths,You are given a tree consisting of n vertices numbered from 1 to n Every vertex is colored in some color denoted by an integer from 1 to n A simple path of the tree is called if it consists of at least 2 vertices the first and the last vertices of the path have the same color no other vertex on the path has the same color as the first vertex Count the number of the simple paths of the tree Note that paths are considered undirected i e the path from x to y is the same as the path from y to x ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n        c[i]--;\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<std::map<int, int>> mp(n);\n    i64 ans = 0;\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            self(self, y, x);\n            if (mp[y].count(c[x])) {\n                ans += mp[y][c[x]];\n                mp[y].erase(c[x]);\n            }\n            if (mp[x].size() < mp[y].size()) {\n                std::swap(mp[x], mp[y]);\n            }\n            for (auto [a, b] : mp[y]) {\n                ans += 1LL * b * mp[x][a];\n                mp[x][a] += b;\n            }\n            mp[y].clear();\n        }\n        mp[x][c[x]] += 1;\n    };\n    dfs(dfs, 0, -1);\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['data structures', 'dfs and similar', 'dp', 'dsu', 'graphs', 'trees']",2000
https://codeforces.com//contest/1474/problem/A,A. Puzzle From the Future,In the year Mike found two binary integers a and b of length n both of them are written only by digits 0 and 1 that can have leading zeroes In order not to forget them he wanted to construct integer d in the following way he creates an integer c as a result of bitwise summing of a and b so c may have one or more 2 s For example the result of bitwise summing of 0110 and 1101 is 1211 or the sum of 011000 and 011000 is 022000 after that Mike replaces equal consecutive digits in c by one digit thus getting d In the cases above after this operation 1211 becomes 121 and 022000 becomes 020 so d won t have equal consecutive digits Unfortunately Mike lost integer a before he could calculate d himself Now to cheer him up you want to find integer a of length n such that d will be Maximum possible as integer means that 102 21 012 101 021 21 and so on ,"[""#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n\tlong long n,i;\n\tstring str;\n\tcin>>n>>str;\n\tlong long b[n],cur=1+str[0]-'0';\n\tb[0]=1;\n\tfor(i=1;i<n;i++){\n\t\tif(cur==0){\n\t\t\tb[i]=1;\n\t\t}\n\t\telse if(cur==1){\n\t\t\tif(str[i]=='1'){\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i]=0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(str[i]=='0'){\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i]=0;\n\t\t\t}\n\t\t}\n\t\tcur=(str[i]-'0')+b[i];\n\t}\n\tfor(i=0;i<n;i++)\n\t\tcout<<b[i];\n\tcout<<endl;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlong long t=1;\n\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}""]",['greedy'],800
https://codeforces.com//contest/1693/problem/B,B. Fake Plastic Trees,We are given a rooted tree consisting of n vertices numbered from 1 to n The root of the tree is the vertex 1 and the parent of the vertex v is p v There is a number written on each vertex initially all numbers are equal to 0 Let s denote the number written on the vertex v as a v For each v we want a v to be between l v and r v l v leq a v leq r v In a single operation we do the following Choose some vertex v Let b 1 b 2 ldots b k be vertices on the path from the vertex 1 to vertex v meaning b 1 1 b k v and b i p b i 1 Choose a non decreasing array c of length k of nonnegative integers 0 leq c 1 leq c 2 leq ldots leq c k For each i 1 leq i leq k increase a b i by c i What s the minimum number of operations needed to achieve our goal ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint oj[nax];\nll dol[nax];\nll gor[nax];\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""Yes\\n"");\n\telse\n\t\tprintf(""No\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=0;\n\tfor (int i=2; i<=n; i++)\n\t\tscanf(""%d"", &oj[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld%lld"", &dol[i], &gor[i]);\n\tint wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]<dol[i])\n\t\t{\n\t\t\twyn++;\n\t\t\ttab[i]=gor[i];\n\t\t}\n\t\ttab[oj[i]]+=min(gor[i], tab[i]);\n\t}\n\tprintf(""%d\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['dfs and similar', 'dp', 'greedy', 'trees']",1700
https://codeforces.com//contest/899/problem/C,C. Dividing the numbers,Petya has integers He wants to split these integers in groups in such a way that the absolute difference of sums of integers in each group is as small as possible Help Petya to split the integers Each of integers should be exactly in one group ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,a[60005];\nint main(){\n\tscanf(""%d"",&n);\n\tif(n%4==1){\n\t\tprintf(""1\\n"");\n\t\tint sz=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i%4==1||i%4==2)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}else if(n%4==2){\n\t\tprintf(""1\\n"");\n\t\tint sz=0;\n\t\ta[sz++]=2;\n\t\tfor(int i=3;i<=n;i++)\n\t\t\tif(i%4==2||i%4==3)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}else if(n%4==3){\n\t\tprintf(""0\\n"");\n\t\tint sz=0;\n\t\ta[sz++]=3;\n\t\tfor(int i=4;i<=n;i++)\n\t\t\tif(i%4==1||i%4==2)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}else {\n\t\tprintf(""0\\n"");\n\t\tint sz=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i%4==2||i%4==3)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'graphs', 'math']",1300
https://codeforces.com//contest/744/problem/C,C. Hongcow Buys a Deck of Cards,One day Hongcow goes to the store and sees a brand new deck of special cards Each individual card is either red or blue He decides he wants to buy them immediately To do this he needs to play a game with the owner of the store This game takes some number of turns to complete On a turn Hongcow may do one of two things Collect tokens Hongcow collects red token blue token by choosing this option thus tokens in total per one operation Buy a card Hongcow chooses some card and spends tokens to purchase it as specified below The th card requires red resources and blue resources Suppose Hongcow currently has red cards and blue cards Then the th card will require Hongcow to spend red tokens and blue tokens Note only tokens disappear but the cards stay with Hongcow forever Each card can be bought only once Given a description of the cards and their costs determine the minimum number of turns Hongcow needs to purchase all cards ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 77777;\nconst int MAX = 300;\n\nint f[N][MAX];\nint cR[N], cB[N];\nint r[N], b[N];\nbool type[N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n; i++) {\n    char ch = getchar();\n    while (ch != \'R\' && ch != \'B\') {\n      ch = getchar();\n    }\n    type[i] = (ch == \'R\');\n    scanf(""%d %d"", r + i, b + i);\n  }\n  for (int t = 0; t < (1 << n); t++) {\n    cR[t] = cB[t] = 0;\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        cR[t] += (type[i] == true);\n        cB[t] += (type[i] == false);\n      }\n    }\n  }\n  for (int t = 0; t < (1 << n); t++) {\n    for (int ar = 0; ar < MAX; ar++) {\n      f[t][ar] = -1;\n    }\n  }\n  f[0][0] = 0;\n  for (int t = 0; t < (1 << n); t++) {\n    for (int ar = 0; ar < MAX; ar++) {\n      int ft = f[t][ar];\n      if (ft == -1) {\n        continue;\n      }\n      for (int i = 0; i < n; i++) {\n        if (t & (1 << i)) {\n          continue;\n        }\n        int new_ar = ar + min(r[i], cR[t]);\n        int new_ab = ft + min(b[i], cB[t]);\n        if (new_ab > f[t + (1 << i)][new_ar]) {\n          f[t + (1 << i)][new_ar] = new_ab;\n        }\n      }\n    }\n  }\n  int allR = 0, allB = 0;\n  for (int i = 0; i < n; i++) {\n    allR += r[i];\n    allB += b[i];\n  }\n  int ans = max(allR, allB);\n  for (int ar = 0; ar < MAX; ar++) {\n    int ab = f[(1 << n) - 1][ar];\n    if (ab == -1) {\n      continue;\n    }\n    ans = min(ans, max(allR - ar, allB - ab));\n  }\n  printf(""%d\\n"", ans + n);\n  return 0;\n}\n']","['bitmasks', 'brute force', 'dp']",2400
https://codeforces.com//contest/1796/problem/E,E. Colored Subgraphs,Monocarp has a tree consisting of n vertices He is going to select some vertex r and perform the following operations on each vertex v from 1 to n set d v equal to the distance from v to r the number of edges on the shortest path color v some color A coloring satisfies two conditions for each pair of vertices of the same color v u there exists a path from v to u that only visits vertices of the same color for each pair of vertices of the same color v u d v neq d u Note that Monocarp can choose any amount of different colors he wants to use For each used color he then counts the number of vertices of this color The of the tree is the minimum of these numbers What can be the maximum cost of the tree ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nvector<int> e[200005];\nint f[200005],FA[200005];\nmultiset<int> S,sf[200005];\nint ans;\nvoid mv(int u,int v)\n{\n\tif(f[u]==f[v]+1)\n\t{\n\t\tif(sf[u].size()>1)\n\t\t{\n\t\t\tf[u]=(*++sf[u].begin())+1;\n\t\t\tS.erase(S.find(f[u]-1));\n\t\t}\n\t\telse f[u]=1;\n\t}\n\telse S.erase(S.find(f[v]));\n\tsf[u].erase(sf[u].find(f[v]));\n\tFA[u]=v,FA[v]=0;\n\tsf[v].insert(f[u]);\n\tif(*sf[v].begin()==f[u])\n\t{\n\t\tif(sf[v].size()>1)\n\t\t\tS.insert(*++sf[v].begin());\n\t}\n\telse S.insert(f[u]);\n\tf[v]=(*sf[v].begin())+1;\n}\nvoid dfs2(int u,int fa)\n{\n\tif(S.size()) ans=max(ans,min(f[u],*S.begin()));\n\telse ans=max(ans,f[u]);\n\tfor(auto v:e[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tmv(u,v),dfs2(v,u),mv(v,u);\n\t}\n}\nvoid dfs1(int u,int fa)\n{\n\tFA[u]=fa;\n\tvector<int> ss;\n\tfor(auto v:e[u])\n\t\tif(v!=fa) dfs1(v,u),ss.push_back(f[v]);\n\tsort(ss.begin(),ss.end());\n\tif(ss.size()) f[u]=ss[0]+1;\n\telse f[u]=1;\n\tfor(auto t:ss) sf[u].insert(t);\n\tfor(int i=1;i<ss.size();i++) S.insert(ss[i]);\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tS.clear();\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0;i<=n;i++) e[i].clear(),sf[i].clear(),f[i]=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tcin >> u >> v;\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tans=0;\n\t\tdfs1(1,0);\n\t/*\tfor(int i=1;i<=n;i++) cout << f[i] << "" "";\n\t\tcout << ""\\n"";\n\t\tmv(1,2);\n\t\tfor(int i=1;i<=n;i++) cout << f[i] << "" "";\n\t\tcout << ""\\n"";*/\n\t\tdfs2(1,0);\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}\n/*\n1\n4\n1 2\n2 3\n3 4\n*/']","['dfs and similar', 'dp', 'games', 'greedy', 'trees']",2500
https://codeforces.com//contest/1536/problem/D,D. Omkar and Medians,Uh oh Ray lost his array yet again However Omkar might be able to help because he thinks he has found the of Ray s array The of an array a with elements a 1 a 2 ldots a 2k 1 is the array b with elements b 1 b 2 ldots b k such that b i is equal to the median of a 1 a 2 ldots a 2i 1 for all i Omkar has found an array b of size n 1 leq n leq 2 cdot 10 5 10 9 leq b i leq 10 9 Given this array b Ray wants to test Omkar s claim and see if b actually is an of some array a Can you help Ray The median of a set of numbers a 1 a 2 ldots a 2i 1 is the number c i where c 1 c 2 ldots c 2i 1 represents a 1 a 2 ldots a 2i 1 sorted in nondecreasing order ,"['#include<bits/stdc++.h>\n#define re register\n#define ll long long\n#define LL inline ll\n#define I inline int\n#define V inline void\n#define FOR(i,a,b) for(re int i=(a),i##i=(b) ; i<=i##i ; ++i)\n#define ROF(i,a,b) for(re int i=(a),i##i=(b) ; i>=i##i ; --i)\n#define gc getchar()\n//#define gc (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<18,stdin),fs==ft))?0:*fs++\nusing namespace std;\nconst int N=2e5+10,mo=1e9+7;\nchar *fs,*ft,buf[1<<18];\nLL read(){\n    ll p=0; char ch=gc; bool w=0;\n    while(!isdigit(ch)) w=ch==\'-\'?1:0,ch=gc;\n    while(isdigit(ch)) p=p*10+ch-\'0\',ch=gc;\n    return w?-p:p;\n}\nint T,n,cnt,ans;\nint a[N],sck[N],bt[N];\nI lb(int x){ return x&(-x); }\nV add(int x,int k){ for(;x<=cnt&&x;x+=lb(x)) bt[x]+=k;}\nI ask(int x){ int as=0; for(;x<=cnt&&x;x-=lb(x)) as+=bt[x]; return as;}\nV sol(){\n\tsort(sck+1,sck+1+cnt);\n\tcnt=unique(sck+1,sck+1+cnt)-sck-1;\n\tFOR(i,1,n) a[i]=lower_bound(sck+1,sck+1+cnt,a[i])-sck;\n\tFOR(i,1,cnt) bt[i]=0;\n\ta[0]=1;\n\tint x,y;\n\tFOR(i,1,n){\n\t\tx=max(a[i],a[i-1]),y=min(a[i],a[i-1]);\n\t\tif(ask(x-1)-ask(y)>0) ans=0;\n\t\tadd(a[i],1);\n\t}\n\tif(ans) cout<<""YES""<<\'\\n\';\n\telse cout<<""NO""<<\'\\n\';\n\treturn ;\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tn=read(),cnt=0,ans=1;\n\t\tFOR(i,1,n) a[i]=read(),sck[++cnt]=a[i];\n\t\tsol();\n\t}\n\treturn 0;\n}\n']","['data structures', 'greedy', 'implementation']",2000
https://codeforces.com//contest/1630/problem/C,C. Paint the Middle,You are given n elements numbered from 1 to n the element i has value a i and color c i initially c i 0 for all i The following operation can be applied Select three elements i j and k 1 leq i j k leq n such that c i c j and c k are all equal to 0 and a i a k then set c j 1 Find the maximum value of sum limits i 1 n c i that can be obtained after applying the given operation any number of times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint b[N][2];\nint ans;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i <= n; i++)\n\t\tb[i][0] = b[i][1] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tif (b[a[i]][0] == -1) b[a[i]][0] = i;\n\t\tb[a[i]][1] = i;\n\t}\n\tans = n;\n\tint l = 0, r = -1;\n\twhile(l < n) {\n\t\teprintf(""[%d %d]\\n"", l, r);\n\t\tif (r == -1) {\n\t\t\tint p = b[a[l]][1];\n\t\t\tif (p > l) {\n\t\t\t\tans--;\n\t\t\t\tl++;\n\t\t\t\tr = p;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t\tans--;\n\t\t\t}\n\t\t} else {\n\t\t\tint mx = r;\n\t\t\twhile(l < r) {\n\t\t\t\tmx = max(mx, b[a[l]][1]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (mx == r) {\n\t\t\t\tans--;\n\t\t\t\tl = r + 1;\n\t\t\t\tr = -1;\n\t\t\t} else {\n\t\t\t\tans--;\n\t\t\t\tl = r + 1;\n\t\t\t\tr = mx;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","['dp', 'greedy', 'sortings', 'two pointers']",2200
https://codeforces.com//contest/786/problem/C,C. Till I Collapse,Rick and Morty want to find MR PBH and they can t do it alone So they need of Mr Meeseeks They Have generated Mr Meeseeks standing in a line numbered from to Each of them has his own color th Mr Meeseeks color is Rick and Morty are gathering their army and they want to divide Mr Meeseeks into some squads They don t want their squads to be too colorful so each squad should have Mr Meeseeks of at most different colors Also each squad should be a continuous subarray of Mr Meeseeks in the line Meaning that for each if Mr Meeseeks number and Mr Meeseeks number are in the same squad then Mr Meeseeks number should be in that same squad Also each squad needs its own presidio and building a presidio needs money so they want the total number of squads to be minimized Rick and Morty haven t finalized the exact value of so in order to choose it for each between and inclusive need to know the minimum number of presidios needed ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,c[N],ocr[N],nxtocr[N],cnt[N],a[N];\nVI r[N];\nvoid modify(int x,int s) {\n\tfor (;x<=n+1;x+=x&(-x)) c[x]+=s;\n}\nint find(int x) {\n\tint p=0;\n\tper(i,0,20) {\n\t\tif (p+(1<<i)<=n+1&&c[p+(1<<i)]<x) {\n\t\t\tx-=c[p+(1<<i)];\n\t\t\tp+=(1<<i);\n\t\t}\n\t}\n\treturn p+1;\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,1,n+1) ocr[i]=n+1;\n\tper(i,1,n+1) {\n\t\tnxtocr[i]=ocr[a[i]];\n\t\tocr[a[i]]=i;\n\t}\n\trep(i,1,n+1) {\n\t\tmodify(ocr[i],1);\n\t\tr[1].pb(i);\n\t}\n\trep(i,1,n+1) {\n\t\tfor (auto d:r[i]) {\n\t\t\tint k=find(d+1);\n//\t\t\tprintf(""%d %d %d\\n"",i,d,k);\n\t\t\tcnt[d]++;\n\t\t\tr[k].pb(d);\n\t\t}\n\t\tmodify(i,-1);\n\t\tmodify(nxtocr[i],1);\n\t}\n\trep(i,1,n+1) printf(""%d "",cnt[i]);\n}\n']","['data structures', 'divide and conquer']",2400
https://codeforces.com//contest/1611/problem/E1,E1. Escape The Maze  easy version , Vlad built a maze out of n rooms and n 1 bidirectional corridors From any room u any other room v can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited k friends to play a game with them Vlad starts the game in the room 1 and wins if he reaches a room other than 1 into which exactly one corridor leads Friends are placed in the maze the friend with number i is in the room x i and no two friends are in the same room that is x i neq x j for all i neq j Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win Vlad is a bit afraid of their ardor Determine if he can guarantee victory i e can he win in any way friends play In other words determine if there is such a sequence of Vlad s moves that lets Vlad win in any way friends play ,"['#include <bits/stdc++.h>\ntypedef std::pair<int,int> pii;\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        int N,K;\n        std::cin>>N>>K;\n        std::vector<int> con[N];\n        std::queue<pii> niveis;\n        int tol[N]={};\n        bool visitou[N]={};\n        for(int i=0;i!=K;++i){\n            int x;\n            std::cin>>x;--x;\n            niveis.push({x,0});\n        }\n        for(int i=1;i!=N;++i){\n            int a,b;\n            std::cin>>a>>b;\n            --a;--b;\n            con[a].push_back(b);\n            con[b].push_back(a);\n        }\n        while(niveis.size()){\n            auto _ = niveis.front();\n            niveis.pop();\n            if(visitou[_.first])continue;\n            visitou[_.first]=true;\n            tol[_.first]=_.second;\n            for(auto&x:con[_.first]){\n                niveis.push({x,_.second+1});\n            }\n        }\n        std::queue<pii> bfs2;\n        bfs2.push({0,0});\n        bool vis[N]={};\n        while(bfs2.size()){\n            auto _ = bfs2.front();\n            bfs2.pop();\n            if(tol[_.first]<=_.second)continue;\n            if(vis[_.first])continue;\n            vis[_.first]=true;\n            if(con[_.first].size()==1&&_.first){\n                printf(""YES\\n"");\n                goto prox;\n            }\n            for(auto&x:con[_.first])bfs2.push({x,_.second+1});\n        }\n        printf(""NO\\n"");\n        prox:{}\n    }\n}\n']","['dfs and similar', 'greedy', 'shortest paths', 'trees', 'two pointers']",1700
https://codeforces.com//contest/1461/problem/E,E. Water Level,In recent years John has very successfully settled at his new job at the office But John doesn t like to idly sit around while his code is compiling so he immediately found himself an interesting distraction The point of his distraction was to maintain a water level in the water cooler used by other zebras Originally the cooler contained exactly k liters of water John decided that the amount of water must always be at least l liters of water but no more than r liters John will stay at the office for exactly t days He knows that each day exactly x liters of water will be used by his colleagues At the beginning of each day he can add exactly y liters of water to the cooler but at any point in time the amount of water in the cooler must be in the range l r Now John wants to find out whether he will be able to maintain the water level at the necessary level for t days Help him answer this question ,"['//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<"" "";cout<<""\\n"";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int k, l, r, t, x, y;\n    cin>>k>>l>>r>>t>>x>>y;\n    set <int> s;\n    int f=0;\n    while(1)\n    {\n        int d=(k-l)/x;\n        t-=d;\n        if(t<=0)\n        break;\n        k-=(d*x);\n        if(s.find(k%x)!=s.end())\n        break;\n        if((k+y)>r)\n        {\n            f=1;\n            break;\n        }\n        s.insert(k%x);\n        k+=y;\n        if((k-x)<l)\n        {\n            f=1;\n            break;\n        }\n    }\n    if(f)\n    cout<<""No"";\n    else\n    cout<<""Yes"";\n}']","['brute force', 'graphs', 'greedy', 'implementation', 'math']",2200
https://codeforces.com//contest/1782/problem/B,B. Going to the Cinema,A company of n people is planning a visit to the cinema Every person can either go to the cinema or not That depends on how many other people will go Specifically every person i said I want to go to the cinema if and only if at least a i other people will go That means that person i will become sad if they go to the cinema and strictly less than a i other people go or they don t go to the cinema and at least a i other people go In how many ways can a set of people going to the cinema be chosen so that nobody becomes sad ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, a[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) \n\t\tcin >> a[i];\n\tsort(a + 1, a + n + 1);\n\tint ns = 0;\n\tL(i, 0, n) {\n\t\tint ok = 1;\n\t\tint cnt = i - 1;\n\t\tif(i) ok &= a[i] <= cnt;\n\t\tif(i < n) ok &= a[i + 1] > cnt + 1;\n\t\tns += ok;\n\t}\n\tcout << ns << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ""]","['brute force', 'greedy', 'sortings']",1000
https://codeforces.com//contest/675/problem/D,D. Tree Construction,During the programming classes Vasya was assigned a difficult problem However he doesn t know how to code and was unable to find the solution in the Internet so he asks you to help You are given a sequence a consisting of n integers that is used to construct the binary search tree Below is the formal description of the construction process First element a 1 becomes the root of the tree Elements a 2 a 3 ldots a n are added one by one To add element a i one needs to traverse the tree starting from the root and using the following rules The pointer to the current node is set to the root If a i is greater than the value in the current node then its right child becomes the current node Otherwise the left child of the current node becomes the new current node If at some point there is no required child the new node is created it is assigned value a i and becomes the corresponding child of the current node ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nset <pair<int, int> > s;\nint a[200000];\nint lc[200000];\nint l, r;\nset <pair<int, int> > :: iterator it;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    int n, x;\n    cin >> n;\n    cin >> a[0];\n    s.insert(make_pair(a[0], 0));\n\n    for (int i = 1; i < n; i++)\n    {\n        cin >> a[i];\n        x = a[i];\n\n        it = s.lower_bound(make_pair(x, 0));\n        if (it == s.end())\n            r = -1;\n        else\n            r = it->second;\n\n        if (it == s.begin())\n        {\n            l = -1;\n        }\n        else\n        {\n            it--;\n            l = it->second;\n        }\n\n        if (l == -1 || (l >= 0 && r >= 0 && a[lc[l]] < x))\n        {\n            cout << a[r] << \' \' ;\n            lc[i] = r;\n        }\n        else\n        {\n            cout << a[l] << \' \' ;\n            lc[i] = lc[l];\n            lc[l] = l;\n        }\n\n        s.insert(make_pair(x, i));\n    }\n\n\n\n    return 0;\n}\n']","['data structures', 'trees']",1800
https://codeforces.com//contest/509/problem/A,A. Maximum in Table,An table is defined as follows The first row and the first column contain ones that is for all Each of the remaining numbers in the table is equal to the sum of the number above it and the number to the left of it In other words the remaining elements are defined by the formula These conditions define all the values in the table You are given a number You need to determine the maximum value in the table defined by the rules above ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\nlong long a[20][20],n;\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)a[1][i]=1;\n    for(int i=2;i<=n;i++){\n    a[i][1]=1;\n    for(int j=2;j<=n;j++)a[i][j]=a[i-1][j]+a[i][j-1];\n    }\n    cout<<a[n][n]<<endl;\n    return 0;\n}\n']","['brute force', 'implementation']",800
https://codeforces.com//contest/1777/problem/F,F. Comfortably Numb,You are given an array a consisting of n non negative integers The of a subarray a l a l 1 ldots a r for arbitrary l leq r is defined as max a l a l 1 ldots a r oplus a l oplus a l 1 oplus ldots oplus a r where oplus denotes the bitwise XOR operation Find the maximum numbness over all subarrays ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nvector<int> lg(2);\ntemplate <typename T> struct maxtable\n{\n\tvector<T> a;\n\tvector<vector<T>> st;\n\tmaxtable(const vector<T> &b) :a(all(b))\n\t{\n\t\tint n=a.size(),i,j,k,r;\n\t\twhile (lg.size()<=n) lg.push_back(lg[lg.size()>>1]+1);\n\t\tst.assign(lg[n]+1,vector<T>(n));\n\t\tiota(all(st[0]),0);\n\t\tfor (j=1; j<=lg[n]; j++)\n\t\t{\n\t\t\tr=n-(1<<j);\n\t\t\tk=1<<j-1;\n\t\t\tfor (i=0; i<=r; i++) st[j][i]=a[st[j-1][i]]<a[st[j-1][i+k]]?st[j-1][i+k]:st[j-1][i];\n\t\t}\n\t}\n\tT rmq(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn max(a[st[z][l]],a[st[z][r-(1<<z)+1]]);\n\t}\n\tint rmp(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn a[st[z][l]]<a[st[z][r-(1<<z)+1]]?st[z][r-(1<<z)+1]:st[z][l];\n\t}\n};\nconst int N=7e6+5;\nint c[N][2],s[N];\nint id;\nvoid insert(int &x,int y,int w,int dep)\n{\n\tx=++id; s[x]=s[y]+1;\n\tif (dep==-1) return;\n\tint o=w>>dep&1;\n\tc[x][o^1]=c[y][o^1];\n\tinsert(c[x][o],c[y][o],w,dep-1);\n}\nint ask(int x,int y,int w)\n{\n\tint r=0,o;\n\tfor (int i=29; i>=0; i--)\n\t{\n\t\to=1^w>>i&1;\n\t\tif (s[c[x][o]]==s[c[y][o]]) o^=1;\n\t\telse r|=1<<i;\n\t\tx=c[x][o]; y=c[y][o];\n\t}\n\treturn r;\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tfor (i=1; i<=id; i++) c[i][0]=c[i][1]=s[i]=0;\n\t\tcin>>n;\n\t\tvector<int> a(n+1),sum(n+1);\n\t\tfor (i=1; i<=n; i++) cin>>a[i];\n\t\t// for (i=1; i<=n; i++) a[i]=i;\n\t\tfor (i=1; i<=n; i++) sum[i]=sum[i-1]^a[i];\n\t\tvector<int> rt(n+1);\n\t\tid=0;\n\t\tfor (i=0; i<=n; i++) insert(rt[i],i==0?0:rt[i-1],sum[i],29);\n\t\tmaxtable t(a);\n\t\tint ans=0;\n\t\tfunction<void(int,int)> dfs=[&](int l,int r)\n\t\t{\n\t\t\tif (l>r) return;\n\t\t\tint m=t.rmp(l,r);\n\t\t\t//[l-1,m-1],[m,r]\n\t\t\tif (m-l<r-m)\n\t\t\t{\n\t\t\t\tfor (int i=l-1; i<=m-1; i++) cmax(ans,ask(rt[m-1],rt[r],sum[i]^a[m]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i=m; i<=r; i++) cmax(ans,ask(l==1?0:rt[l-2],rt[m-1],sum[i]^a[m]));\n\t\t\t}\n\t\t\tdfs(l,m-1); dfs(m+1,r);\n\t\t};\n\t\tdfs(1,n);\n\t\tcout<<ans<<\'\\n\';\n\t}\n}\n']","['bitmasks', 'data structures', 'divide and conquer', 'strings', 'trees']",2400
https://codeforces.com//contest/1490/problem/B,B. Balanced Remainders,You are given a number n and an array a 1 dots n In one move you can increase any of the array elements by one Formally you choose the index i 1 le i le n and a i with a i 1 You can choose the same index i multiple times for different moves Let s denote by c 0 c 1 and c 2 the number of numbers from the array a that have remainders 0 1 and 2 when divided by the number 3 respectively Let s say that the array a has balanced remainders if c 0 c 1 and c 2 are equal For example if n 6 and a 0 2 5 5 4 8 then the following sequence of moves is possible initially c 0 1 c 1 1 and c 2 4 these values are not equal to each other Let s increase a 3 now the array a 0 2 6 5 4 8 c 0 2 c 1 1 and c 2 3 these values are not equal Let s increase a 6 now the array a 0 2 6 5 4 9 c 0 3 c 1 1 and c 2 2 these values are not equal Let s increase a 1 now the array a 1 2 6 5 4 9 c 0 2 c 1 2 and c 2 2 these values are equal to each other which means that the array a has balanced remainders Find the minimum number of moves needed to make the array a have balanced remainders ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tint n;\n\tint div[3];\n\tint i;\n\tint x;\n\tint ans;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\n\t\tfor (i = 0; i < 3; i++) div[i] = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x;\n\n\t\t\tdiv[x % 3]++;\n\t\t}\n\n\t\tans = 0;\n\t\tfor (i = 0; i < 3; i++)\n\t\t{\n\t\t\tif (div[i] > n / 3)\n\t\t\t{\n\t\t\t\tans += div[i] - n / 3;\n\t\t\t\tdiv[(i + 1) % 3] += div[i] - n / 3;\n\t\t\t\tdiv[i] = n / 3;\n\t\t\t}\n\t\t\telse if (div[i] < n / 3)\n\t\t\t{\n\t\t\t\tans += n / 3 - div[i];\n\t\t\t\tdiv[(i + 2) % 3] -= n / 3 - div[i];\n\t\t\t\tdiv[i] = n / 3;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n}""]","['brute force', 'constructive algorithms', 'math']",1000
https://codeforces.com//contest/372/problem/C,C. Watching Fireworks is Fun,A festival will be held in a town s main street There are sections in the main street The sections are numbered through from left to right The distance between each adjacent sections is In the festival fireworks will be launched The th launching is on time at section If you are at section at the time of th launching you ll gain happiness value note that the happiness value might be a negative value You can move up to length units in a unit time interval but it s prohibited to go out of the main street Also you can be in an arbitrary section at initial time moment time equals to and want to maximize the sum of happiness that can be gained from watching fireworks Find the maximum total happiness Note that two or more fireworks can be launched at the same time ,"['#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n//#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(int)n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ACCU accumulate\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<ll> VL;\nconst ll mod=1000000007,inf=(1ll<<60);\nconst double eps=1e-9;\nconst double pi=acos(0)*2;\nll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\nconst int N=150100;\nll dp[N],pd[N],ans;\nint q[N],n,m,d,prt,a[567],b[567],t[567];\n\nvoid transfer(int leg,int a,int b) {\n\tint h=1,t=0;\n\tmemset(q,0,sizeof(q));\n\trep(i,0,leg) {\n\t\twhile (h<=t&&dp[i]>dp[q[t]]) --t;\n\t\tq[++t]=i;\n\t}\n\trep(i,0,n) {\n\t\tif (i+leg<n) {\n\t\t\twhile (h<=t&&dp[i+leg]>dp[q[t]]) --t;\n\t\t\tq[++t]=i+leg;\n\t\t}\n\t\twhile (h<=t&&i-q[h]>leg) h++;\n\t\tpd[i]=dp[q[h]];\n\t}\n\trep(i,0,n) pd[i]+=b-abs(a-i);\n}\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&d);\n\tprt=1;\n\trep(i,0,m) {\n\t\trep(j,0,n) pd[j]=-inf;\n\t\tscanf(""%d%d%d"",a+i,b+i,t+i);--a[i];\n\t\ttransfer(min(1ll*(t[i]-prt)*d,1ll*n),a[i],b[i]);\n\t\trep(j,0,n) dp[j]=pd[j];prt=t[i];\n\t}\n\tans=-inf;\n\trep(i,0,n) ans=max(ans,pd[i]);\n\tprintf(""%I64d\\n"",ans);\n\treturn 0;\n}\n']","['data structures', 'dp', 'math']",2100
https://codeforces.com//contest/831/problem/C,C. Jury Marks,Polycarp watched TV show where jury members one by one rated a participant by adding him a certain number of points may be negative i e points were subtracted Initially the participant had some score and each the marks were one by one added to his score It is known that the th jury member gave points Polycarp does not remember how many points the participant had before this marks were given but he remembers that among the scores announced after each of the judges rated the participant there were values it is guaranteed that all values are distinct It is possible that Polycarp remembers not all of the scores announced i e Note that the initial score wasn t announced Your task is to determine the number of options for the score the participant could have before the judges rated the participant ,"['#include<bits/stdc++.h>\nint n,m,ans=0;\nint a[10007],b[10007],c[10007];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(""%d"",a+i);\n\tfor(int i=1;i<=n;++i)b[i]=b[i-1]+a[i];\n\tstd::sort(b+1,b+n+1);\n\tn=std::unique(b+1,b+n+1)-b-1;\n\tfor(int i=1;i<=m;++i)scanf(""%d"",c+i);\n\tans=n;\n\tfor(int i=1;i<=n;++i){\n\t\tint d=c[1]-b[i];\n\t\tfor(int j=1;j<=m;++j)if(!std::binary_search(b+1,b+n+1,c[j]-d)){\n\t\t\t--ans;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(""%d"",ans);\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms']",1700
https://codeforces.com//contest/1546/problem/B,B. AquaMoon and Stolen String,AquaMoon had n strings of length m each n is an number When AquaMoon was gone Cirno tried to pair these n strings together After making frac n 1 2 pairs she found out that there was exactly one string without the pair In her rage she disrupted each pair of strings For each pair she selected some positions at least 1 and at most m and swapped the letters in the two strings of this pair at the selected positions For example if m 6 and two strings and are in one pair and Cirno selected positions 2 3 and 6 she will swap with with and with The resulting strings will be and Cirno then stole away the string without pair and shuffled all remaining strings in arbitrary order AquaMoon found the remaining n 1 strings in complete disarray Also she remembers the initial n strings She wants to know which string was stolen but she is not good at programming Can you help her ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"") \n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n,m;\nstring a[200005];\nint cnt[100005][26];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n >> m;\n        for(int i = 0;i < m;i++) {\n            for(int j = 0;j < 26;j++) cnt[i][j] = 0;\n        }\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            for(int j = 0;j < m;j++) {\n                cnt[j][a[i][j]-\'a\']++;\n            }\n        }\n        for(int i = n+1;i < 2*n;i++) {\n            cin >> a[i];\n            for(int j = 0;j < m;j++) {\n                cnt[j][a[i][j]-\'a\']--;\n            }\n        }\n        for(int i = 0;i < m;i++) {\n            for(int j = 0;j < 26;j++) {\n                if(cnt[i][j]) cout << (char)(j+\'a\');\n            }\n        }\n        cout << \'\\n\';\n    }\n}']","['interactive', 'math']",1200
https://codeforces.com//contest/678/problem/B,B. The Same Calendar,The girl Taylor has a beautiful calendar for the year In the calendar all days are given with their days of week Monday Tuesday Wednesday Thursday Friday Saturday and Sunday The calendar is so beautiful that she wants to know what is the next year after when the calendar will be exactly the same Help Taylor to find that year Note that leap years has days The year is leap if it is divisible by or it is divisible by but not by https en wikipedia org wiki Leap year ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint isleap(int y) {\n    if (y % 100 == 0) {\n        return y % 400 == 0;\n    }\n    return y % 4 == 0;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int w = 1;\n    for (int i = 2016 ; i > 1000 ; -- i) {\n        if (isleap(i)) {\n            w -= 366 % 7;\n        } else {\n            w -= 365 % 7;\n        }\n        w += 7 , w %= 7;\n    }\n    for (int i = 1001 ; i <= n ; ++ i) {\n        w += isleap(i) + 365;\n        w %= 7;\n    }\n    int p = w;\n    int q = isleap(n);\n    int j = n + 1;\n    while (1) {\n        w += isleap(j) + 365;\n        w %= 7;\n        if (w == p && isleap(j) == q) {\n            printf(""%d\\n"" , j);\n            break;\n        }\n        ++ j;\n    }\n\n}\n']",['implementation'],1600
https://codeforces.com//contest/668/problem/C,C. Little Artem and Random Variable,Little Artyom decided to study probability theory He found a book with a lot of nice exercises and now wants you to help him with one of them Consider two dices When thrown each dice shows some integer from to inclusive For each dice the probability of each outcome is given of course their sum is and different dices may have different probability distributions We throw both dices simultaneously and then calculate values and where is equal to the outcome of the first dice while is equal to the outcome of the second dice You don t know the probability distributions for particular values on each dice but you know the probability distributions for and That is for each from to you know the probability that would be equal to and the probability that would be equal to Find any valid probability distribution for values on the dices It s guaranteed that the input data is consistent that is at least one solution exists ,"['#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nint main() {\n\tint n;\n\twhile(~scanf(""%d"", &n)) {\n\t\tvector<double> ma(n + 2), mi(n + 2);\n\t\trep(i, n)\n\t\t\tscanf(""%lf"", &ma[i + 1]);\n\t\trep(i, n)\n\t\t\tscanf(""%lf"", &mi[i + 1]);\n\t\t//P[a <  i && b <  i] = P[a < i] P[b < i]\n\t\t//P[a >= i && b >= i] = (1 - P[a < i]) (1 - P[b < i])\n\t\t//                    = 1 - P[b < i] - P[a < i] + P[a < i] P[b < i]\n\t\t//P[a < i] + P[b < i]\n\t\t//P[a = i] + P[b = i]\n\t\t//P[a <= i && b <= i] = P[a < i] P[b < i] + P[a < i] P[b = i] + P[a = i] P[b < i] + P[a = i] P[b = i]\n\t\tvector<double> lt(n + 2), ge(n + 2);\n\t\trer(i, 0, n)\n\t\t\tlt[i + 1] = lt[i] + ma[i];\n\t\tfor(int i = n; i >= 0; -- i)\n\t\t\tge[i] = ge[i + 1] + mi[i];\n\t\tvector<double> sumlt(n + 2);\n\t\trer(i, 0, n + 1)\n\t\t\tsumlt[i] = 1 - (ge[i] - lt[i]);\n\t\tvector<double> sum2(n + 2);\n\t\trer(i, 0, n)\n\t\t\tsum2[i] = sumlt[i + 1] - sumlt[i];\n\t\tvector<double> p1(n + 1), p2(n + 1);\n\t\tdouble suma = 0, sumb = 0;\n\t\trer(i, 1, n) {\n\t\t\tdouble a = sumb, b = suma;\n\t\t\tdouble t = ma[i];\n\t\t\tdouble u = sum2[i];\n\t\t\t//ax + by + xy = t, x + y = u\n\t\t\tdouble x = 1. / 2 * abs(sqrt(max(0., a*a - 2 * a*b + 2 * a*u + b*b + 2 * b*u - 4 * t + u*u)) + a - b + u);\n\t\t\tdouble y = u - x;\n\t\t\tp1[i] = x, p2[i] = y;\n\t\t\tsuma += p1[i], sumb += p2[i];\n\t\t}\n\t\trer(i, 1, n) {\n\t\t\tif(i != 1) putchar(\' \');\n\t\t\tprintf(""%.10f"", p1[i]);\n\t\t}\n\t\tputs("""");\n\t\trer(i, 1, n) {\n\t\t\tif(i != 1) putchar(\' \');\n\t\t\tprintf(""%.10f"", p2[i]);\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","['math', 'probabilities']",2400
https://codeforces.com//contest/138/problem/A,A. Literature Lesson,Vera adores poems All the poems Vera knows are divided into quatrains groups of four lines and in each quatrain some lines contain rhymes Let s consider that all lines in the poems consist of lowercase Latin letters without spaces Letters are considered vowels Two lines rhyme if their suffixes that start from the th vowels counting from the end match If a line has less than vowels then such line can t rhyme with any other line For example if lines and rhyme the corresponding suffixes equal and if they do not rhyme Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes namely the following ones the same letters stand for rhyming lines Clerihew Alternating Enclosed If all lines of a quatrain pairwise rhyme then the quatrain can belong to any rhyme scheme this situation is represented by If all quatrains of a poem belong to the same rhyme scheme then we can assume that the whole poem belongs to this rhyme scheme If in each quatrain all lines pairwise rhyme then the rhyme scheme of the poem is Let us note that it doesn t matter whether lines from different quatrains rhyme with each other or not In other words it is possible that different quatrains aren t connected by a rhyme Vera got a long poem as a home task The girl has to analyse it and find the poem rhyme scheme Help Vera cope with the task ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <memory.h>\n#include <string>\n#include <set>\nusing namespace std;\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,(int)(v).size())\n#define iinf 1000000000\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define lng long long\n#define eps 1e-8\n#define SQ(a) ((a)*(a))\n#define PI 3.14159265359\n#define index asdindex\n\nbool syll[256];\n\nvoid nope(){\n    cout<<""NO"";\n    exit(0);\n}\n\nint main(){\n#ifdef __ASD__\n    freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#endif\n\n    syll[\'a\']=syll[\'e\']=syll[\'i\']=syll[\'o\']=syll[\'u\']=true;\n    int n,k;\n    cin>>n>>k;\n    set<string> res;\n    forn(i,n){\n        string suf[4];\n        forn(j,4){\n            string s;\n            cin>>s;\n            int p=s.length();\n            int c=0;\n            while(p>0&&c<k){\n                --p;\n                if(syll[s[p]])\n                    ++c;\n            }\n            if(c<k)\n                nope();\n            suf[j]=s.substr(p);\n        }\n        if(suf[0]==suf[1]){\n            if(suf[2]==suf[3]){\n                if(suf[1]==suf[2])\n                    res.insert(""aaaa"");\n                else\n                    res.insert(""aabb"");\n            }else nope();\n        }else if(suf[0]==suf[2]){\n            if(suf[1]==suf[3])\n                res.insert(""abab"");\n            else\n                nope();\n        }else if(suf[0]==suf[3]&&suf[1]==suf[2])\n            res.insert(""abba"");\n        else\n            nope();\n    }\n    if(res.size()>1){\n        if(res.size()==2&&*res.begin()==""aaaa""){\n            res.erase(res.begin());\n        }else nope();\n    }\n    if(res.size()<1)\n        exit(321);\n    cout<<*res.begin();\n\n    return 0;\n}\n']",['implementation'],1600
https://codeforces.com//contest/1343/problem/C,C. Alternating Subsequence,Recall that the sequence b is a a subsequence of the sequence a if b can be derived from a by removing zero or more elements without changing the order of the remaining elements For example if a 1 2 1 3 1 2 1 then possible subsequences are 1 1 1 1 3 and 1 2 1 3 1 2 1 but not 3 2 3 and 1 1 1 1 2 You are given a sequence a consisting of n positive and negative elements there is no zeros in the sequence Your task is to choose length subsequence of the given sequence i e the sign of each next element is the opposite from the sign of the current element like positive negative positive and so on or negative positive negative and so on Among all such subsequences you have to choose one which has the of elements In other words if the maximum length of subsequence is k then your task is to find the of elements of some subsequence of length k You have to answer t independent test cases ,"['#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<\'0\') || (ch>\'9\')) {if (ch==\'-\') f=-1;ch=getchar();}\n    while ((ch>=\'0\') && (ch<=\'9\')) {x=x*10+(ch-\'0\');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nint n,a[200100];\n\nint calc(int x)\n{\n\tif (x>0) return 1;else return -1;\n}\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();\n\t\trep(i,1,n) a[i]=read();\n\t\tll ans=0,sum=0;\n\t\tint pos=1,mx=a[1];\n\t\trep(i,2,n)\n\t\t{\n\t\t\tif (calc(a[i])==calc(a[pos]))\n\t\t\t{\n\t\t\t\tmx=max(mx,a[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//cout << ""range "" << pos << "" "" << i-1 << endl;\n\t\t\t\tans+=mx;pos=i;mx=a[i];\n\t\t\t}\n\t\t}\n\t\tans+=mx;\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n\n\n']","['dp', 'greedy', 'two pointers']",1200
https://codeforces.com//contest/864/problem/E,E. Fire,Polycarp is in really serious trouble his house is on fire It s time to save the most valuable items Polycarp estimated that it would take seconds to save th item In addition for each item he estimated the value of the moment after which the item will be completely burned and will no longer be valuable for him at all In particular if then th item cannot be saved Given the values for each of the items find a set of items that Polycarp can save such that the total value of this items is maximum possible Polycarp saves the items one after another For example if he takes item first and then item then the item will be saved in seconds and the item in seconds after fire started ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint f[110][2010];\nint g[110][2010];\nstruct p\n{\n\tint t,d,p,id;\n};\np a[110];\nint cmp(p a,p b)\n{\n\treturn a.d<b.d;\n}\nvoid solve(int x,int y,int s)\n{\n\tif(x<0)\n\t\tprintf(""%d\\n"",s);\n\telse\n\t{\n\t\tif(!g[x][y])\n\t\t\tsolve(x-1,y,s);\n\t\telse\n\t\t{\n\t\t\tsolve(x-1,y-a[x].t,s+1);\n\t\t\tprintf(""%d "",a[x].id);\n\t\t}\n\t}\n}\nint main()\n{\n\tmemset(f,0x80,sizeof f);\n\tf[0][0]=0;\n\tint n;\n\tscanf(""%d"",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d%d%d"",&a[i].t,&a[i].d,&a[i].p);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=2000;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tg[i][j]=0;\n\t\t\tif(j>=a[i].t&&j<a[i].d)\n\t\t\t\tif(f[i-1][j-a[i].t]+a[i].p>f[i][j])\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=f[i-1][j-a[i].t]+a[i].p;\n\t\t\t\t\tg[i][j]=1;\n\t\t\t\t}\n\t\t}\n\tint ans1=-1,ans2=-1;\n\tfor(i=0;i<=2000;i++)\n\t\tif(f[n][i]>ans1)\n\t\t{\n\t\t\tans1=f[n][i];\n\t\t\tans2=i;\n\t\t}\n\tprintf(""%d\\n"",ans1);\n\tsolve(n,ans2,0);\n\treturn 0;\n}']","['dp', 'sortings']",2000
https://codeforces.com//contest/550/problem/C,C. Divisibility by Eight,You are given a non negative integer its decimal representation consists of at most digits and doesn t contain leading zeroes Your task is to determine if it is possible in this case to remove some of the digits possibly not remove any digit at all so that the result contains at least one digit forms a non negative integer doesn t have leading zeroes and is divisible by 8 After the removing it is forbidden to rearrange the digits If a solution exists you should print it ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-9;\nconst int oo = 0x3f3f3f3;\nconst int MAXN = (int)1e5 + 10;\n\nbool lookthis(string &s, string &t){\n    int p1 = 0;\n    for (int i = 0; i < s.length() && p1 < t.length(); ++i)\n        if (s[i] == t[p1]) ++p1;\n    return p1 == t.length();\n}\n\nstring getString(int v){\n    if (v == 0) return ""0"";\n    string ans = """";\n    while (v){\n        char cur = (v % 10 + \'0\');\n        ans = cur + ans;\n        v /= 10;\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s; cin >> s;\n\n    for (int i = 0; i < 1000; i += 8){\n        string cur = getString(i);\n        if (lookthis(s, cur)){\n            cout << ""YES"" << endl << cur << endl;\n            exit(0);\n        }\n    }\n    cout << ""NO"" << endl;\n\n    return 0;\n}\n']","['brute force', 'dp', 'math']",1500
https://codeforces.com//contest/1106/problem/B,B. Lunar New Year and Food Ordering,The restaurant Alice s serves n kinds of food The cost for the i th kind is always c i Initially the restaurant has enough ingredients for serving exactly a i dishes of the i th kind In the New Year s Eve m customers will visit Alice s one after another and the j th customer will order d j dishes of the t j th kind of food The i 1 st customer will only come after the i th customer is completely served Suppose there are r i dishes of the i th kind remaining initially r i a i When a customer orders 1 dish of the i th kind the following principles will be processed If r i 0 the customer will be served exactly 1 dish of the i th kind The cost for the dish is c i Meanwhile r i will be reduced by 1 Otherwise the customer will be served 1 dish of the available kind of food if there are any If there are multiple cheapest kinds of food the one with the smallest index among the cheapest will be served The cost will be the cost for the dish served and the remain for the corresponding dish will be reduced by 1 If there are no more dishes at all the customer will leave angrily Therefore no matter how many dishes are served previously the cost for the customer is 0 If the customer doesn t leave after the d j dishes are served the cost for the customer will be the sum of the cost for these d j dishes Please determine the total cost for each of the m customers ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nint a[N], c[N];\nset<pair<int, int> > S;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= n; i++) cin >> c[i];\n\tfor (int i = 1; i <= n; i++) S.insert(make_pair(c[i], i));\n\tlong long ans = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint t, d; cin >> t >> d;\n\t\tlong long cost = 0;\n\t\twhile (d) {\n\t\t\tif (a[t]) {\n\t\t\t\tint s = min(a[t], d);\n\t\t\t\ta[t] -= s;\n\t\t\t\td -= s;\n\t\t\t\tif (!a[t]) S.erase(make_pair(c[t], t));\n\t\t\t\tcost += 1LL * s * c[t];\n\t\t\t} else {\n\t\t\t\tif (S.empty()) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tpair<int, int> x = *S.begin();\n\t\t\t\t\tt = x.second;\n\t\t\t\t\tint s = min(a[t], d);\n\t\t\t\t\ta[t] -= s;\n\t\t\t\t\td -= s;\n\t\t\t\t\tif (!a[t]) S.erase(make_pair(c[t], t));\n\t\t\t\t\tcost += 1LL * s * c[t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}\t\t\t']","['data structures', 'implementation']",1500
https://codeforces.com//contest/1530/problem/E,E. Minimax,of string t t 1 t 2 ldots t n and position i in it is defined as the length k of the longest proper not equal to the whole substring prefix of substring t 1 t 2 ldots t i which is also a suffix of the same substring For example for string t the values of the prefix function in positions 1 2 ldots 7 are equal to 0 0 1 0 1 2 3 Let f t be equal to the value of the prefix function of string t over all its positions For example f 3 You are given a string s Reorder its characters arbitrarily to get a string t the number of occurrences of any character in strings s and t must be equal The value of f t must be Out of all options to minimize f t choose the one where string t is the ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.length();\n    \n    int cnt[26] = {};\n    for (int i = 0; i < n; i++) {\n        cnt[s[i] - \'a\']++;\n    }\n    \n    if (s == std::string(n, s[0])) {\n        std::cout << s << ""\\n"";\n        return;\n    }\n    \n    int x = 0;\n    while (x < 26 && cnt[x] != 1) {\n        x++;\n    }\n    \n    if (x < 26) {\n        std::swap(s[0], s[s.find(\'a\' + x)]);\n        std::sort(s.begin() + 1, s.end());\n        std::cout << s << ""\\n"";\n        return;\n    }\n    \n    x = 0;\n    while (cnt[x] == 0) {\n        x++;\n    }\n    \n    std::string t;\n    t += \'a\' + x;\n    cnt[x]--;\n    \n    if (cnt[x] <= n / 2) {\n        t += \'a\' + x;\n        cnt[x]--;\n        int y = x + 1;\n        while (cnt[x] > 0) {\n            while (cnt[y] == 0) {\n                y++;\n            }\n            t += \'a\' + y;\n            cnt[y]--;\n            t += \'a\' + x;\n            cnt[x]--;\n        }\n        while (int(t.length()) < n) {\n            while (cnt[y] == 0) {\n                y++;\n            }\n            t += \'a\' + y;\n            cnt[y]--;\n        }\n        std::cout << t << ""\\n"";\n        return;\n    }\n    \n    int y = x + 1;\n    while (cnt[y] == 0) {\n        y++;\n    }\n    \n    if (cnt[x] + cnt[y] == n - 1) {\n        while (cnt[y]--) {\n            t += \'a\' + y;\n        }\n        while (cnt[x]--) {\n            t += \'a\' + x;\n        }\n        std::cout << t << ""\\n"";\n        return;\n    }\n    \n    int z = y + 1;\n    while (cnt[z] == 0) {\n        z++;\n    }\n    \n    t += \'a\' + y;\n    cnt[y]--;\n    \n    while (cnt[x]--) {\n        t += \'a\' + x;\n    }\n    \n    t += \'a\' + z;\n    cnt[z]--;\n    \n    for (int i = y; i < 26; i++) {\n        while (cnt[i]--) {\n            t += \'a\' + i;\n        }\n    }\n    \n    std::cout << t << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'greedy', 'strings']",2100
https://codeforces.com//contest/1345/problem/A,A. Puzzle Pieces,You are given a special jigsaw puzzle consisting of n cdot m identical pieces Every piece has three tabs and one blank as pictured below The jigsaw puzzle is considered solved if the following conditions hold The pieces are arranged into a grid with n rows and m columns For any two pieces that share an edge in the grid a tab of one piece fits perfectly into a blank of the other piece Through rotation and translation of the pieces determine if it is possible to solve the jigsaw puzzle ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int t;\n  cin >>t;\n\n  for (int j = 0; j < t; j++) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 1 || m == 1 || (n==2&&m==2)) cout << ""YES\\n"";\n    else cout << ""NO\\n"";\n  }\n}\n']",['math'],800
https://codeforces.com//contest/1453/problem/E,E. Dog Snacks,Gildong is playing with his dog Badugi They re at a park that has n intersections and n 1 bidirectional roads each 1 meter in length and connecting two intersections with each other The intersections are numbered from 1 to n and for every a and b 1 le a b le n it is possible to get to the b th intersection from the a th intersection using some set of roads Gildong has put one snack at every intersection of the park Now Gildong will give Badugi a mission to eat all of the snacks Badugi starts at the 1 st intersection and he will move by the following rules Badugi looks for snacks that are as close to him as possible Here the distance is the length of the shortest path from Badugi s current location to the intersection with the snack However Badugi s sense of smell is limited to k meters so he can only find snacks that are less than or equal to k meters away from himself If he cannot find any such snack he fails the mission Among all the snacks that Badugi can smell from his current location he chooses a snack that minimizes the distance he needs to travel from his current intersection If there are multiple such snacks Badugi will choose one arbitrarily He repeats this process until he eats all n snacks After that he has to find the 1 st intersection again which also must be less than or equal to k meters away from the last snack he just ate If he manages to find it he completes the mission Otherwise he fails the mission Unfortunately Gildong doesn t know the value of k So he wants you to find the minimum value of k that makes it possible for Badugi to complete his mission if Badugi moves optimally ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nconst int N=200005;\nint n,flag,dp[N],deg[N];\nvector<int>E[N];\ninline void add(int x,int y){\n\tE[x].PB(y),E[y].PB(x);\n\tdeg[x]++,deg[y]++;\n}\ninline void getDP(int x,int f,int dis){\n\tif(x!=1&&deg[x]==1){\n\t\tdp[x]=0;\n\t\treturn ;\n\t}\n\tvector<int>temp;\n\tRep(y,E[x]){\n\t\tif(y==f)continue;\n\t\tgetDP(y,x,dis);\n\t\ttemp.PB(dp[y]);\n\t}\n\tsort(temp.begin(),temp.end());\n\tint size=temp.size();\n\tif(temp[size-1]>=dis){\n\t\tflag=0;\n\t}\n\telse if(temp[size-1]==dis-1){\n\t\tif(size>=2&&temp[size-2]==dis-1)flag=0;\n\t\telse dp[x]=dis;\n\t}\n\telse dp[x]=temp[0]+1;\n}\nint _;\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(_);\n    while(_--){\n    \tread(n);\n    \tF(i,1,n)E[i].clear(),deg[i]=0;\n    \tint tu,tv;\n    \tF(i,1,n-1){\n    \t\tread(tu),read(tv),add(tu,tv);\n    \t\t//cout<<tu<<\' \'<<tv<<endl;\n\t\t}\n    \tint L=1,R=n;\n    \twhile(L<R){\n    \t\tflag=1;\n    \t\tint mid=(L+R)>>1;\n    \t\tgetDP(1,0,mid);\n    \t\tif(flag&&dp[1]<=mid)R=mid;\n    \t\telse L=mid+1;\n\t\t}\n\t\tcout<<L<<\'\\n\';\n\t}\n    return 0;\n}']","['binary search', 'dfs and similar', 'dp', 'greedy', 'trees']",2300
https://codeforces.com//contest/1311/problem/F,F. Moving Points,There are n points on a coordinate axis OX The i th point is located at the integer point x i and has a speed v i It is guaranteed that no two points occupy the same coordinate All n points move with the constant speed the coordinate of the i th point at the moment t t is calculated as x i t cdot v i Consider two points i and j Let d i j be the minimum possible distance between these two points over any possible moments of time even It means that if two points i and j coincide at some moment the value d i j will be 0 Your task is to calculate the value sum limits 1 le i j le n d i j the sum of minimum distances over all pairs of points ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\npair<int,int> p[200005];\nint d1[200005],d2[200005];\nlong long BIT1[200005],BIT2[200005],BITcnt1[200005],BITcnt2[200005];\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(long long* BIT,int x,long long d)\n{\n    while(x<=200004)\n    {\n        BIT[x]+=d;\n        x+=lowbit(x);\n    }\n}\nlong long query(long long* BIT,int x)\n{\n    long long ret=0;\n    while(x)\n    {\n        ret+=BIT[x];\n        x-=lowbit(x);\n    }\n    return ret;\n}\nint main()\n{\n    int n,cnt1,cnt2;\n    long long ans;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&p[i].first);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&p[i].second);\n    sort(p,p+n);\n    cnt1=0;\n    cnt2=0;\n    for(int i=0;i<n;i++)\n        if(p[i].second>=0)\n            d1[cnt1++]=p[i].second;\n        else d2[cnt2++]=-p[i].second;\n    sort(d1,d1+cnt1);\n    sort(d2,d2+cnt2);\n    cnt1=unique(d1,d1+cnt1)-d1;\n    cnt2=unique(d2,d2+cnt2)-d2;\n    ans=0;\n    for(int i=n-1;i>=0;i--)\n    {\n        if(p[i].second>=0)\n        {\n            ans+=(query(BIT1,cnt1)-query(BIT1,lower_bound(d1,d1+cnt1,p[i].second)-d1))-(query(BITcnt1,cnt1)-query(BITcnt1,lower_bound(d1,d1+cnt1,p[i].second)-d1))*p[i].first;\n            update(BIT1,lower_bound(d1,d1+cnt1,p[i].second)-d1+1,p[i].first);\n            update(BITcnt1,lower_bound(d1,d1+cnt1,p[i].second)-d1+1,1);\n        }\n        else\n        {\n            ans+=query(BIT2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1)-query(BITcnt2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1)*p[i].first;\n            ans+=query(BIT1,cnt1)-query(BITcnt1,cnt1)*p[i].first;\n            update(BIT2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1,p[i].first);\n            update(BITcnt2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1,1);\n        }\n    }\n    printf(""%lld\\n"",ans);\n    return 0;\n}\n']","['data structures', 'divide and conquer', 'implementation', 'sortings']",1900
https://codeforces.com//contest/1462/problem/C,C. Unique Number,You are given a positive number x Find the smallest positive integer number that has the sum of digits equal to x and all digits are unique ,"[""#include <bits/stdc++.h>\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define si short int\n#define speed ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define pill pair<ll,ll>\n#define f first\n#define s second\n#define pilc pair<ll,char>\n#define all(a) (a).begin(),(a).end()\n#define rep(s,e,step) for(int i = (s); i < (e) ; i += step)\n#define vrep(s,e,step) for(int j = (s); j < (e) ; j += step)\n#define ex exit(0) \n#define sz(a) (a).size()\n#define triple pair<pill, ll>\n#define pinode pair<node*, node*>\n#define quadra pair<pill, pill>\n#define ld long double\nusing namespace std;\n \nconst ll N = 2e5 + 10;\nconst ll M = 2e5 + 1;\nconst ll big = 1e18;\nconst ll hsh2 = 1964325029 ;\nconst long long mod = 1e9 + 7;\nconst long double EPS = 1e-14;\nconst ll block = 1e7;\nconst ll shift = 2e3;\nmt19937_64 rofl(chrono::steady_clock::now().time_since_epoch().count());\n\nll t, x;\nll ans, sub;\nll F[10] = {0};\n\nvoid rec(ll sum) {\n\tif(sum > x)\n\t\treturn;\n\tif(sum == x) {\n\t\tans = min(sub, ans);\n\t\treturn;\n\t}\n\tfor(int j = 1;j < 10; j++) {\n\t\tif(!F[j]) {\n\t\t    F[j] = 1;\n\t\t    sub = sub * 10 + j;\n\t\t\trec(sum + j);\n\t\t\tsub /= 10;\n\t\t\tF[j] = 0;\n\t\t}\n\t}\n}\n\nvoid solve() {\n    ans = big;\n \tcin >> x;\n \trec(0);\n \tcout << (ans == big ? -1 : ans)<< '\\n';\n}\n\nint main() {\n\tspeed;\n\tcin >> t;\n\twhile(t--)solve(); \t\n}              \n/*\nqiwwqdesw\n1\nd\n \n*/""]","['brute force', 'greedy', 'math']",900
https://codeforces.com//contest/83/problem/A,A. Magical Array,Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written He immediately thought that the numbers in this array were not random As a result of extensive research Valera worked out a wonderful property that a magical array should have an array is defined as magic if its He decided to share this outstanding discovery with you but he asks you for help in return Despite the tremendous intelligence and wit Valera counts very badly and so you will have to complete his work All you have to do is count the number of magical subarrays of the original array of numbers written on the parchment Subarray is defined as ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint a[100000];\nint64 res;\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tres = 0;\n\tscanf (""%d"", &n);\n\tforn (i, n)\n\t\tscanf (""%d"", &a[i]);\n\tint l = 0;\n\twhile (l < n) {\n\t\tint r = l;\n\t\twhile (r + 1 < n && a[r+1] == a[l])\n\t\t\tr ++;\n\t\tint64 d = r - l + 1;\n\t\tres += d * (d + 1) / 2;\n\t\tl = r + 1;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n']",['math'],1300
https://codeforces.com//contest/1282/problem/C,C. Petya and Exam,Petya has come to the math exam and wants to solve as many problems as possible He prepared and carefully studied the rules by which the exam passes The exam consists of n problems that can be solved in T minutes Thus the exam begins at time 0 and ends at time T Petya can leave the exam at any integer time from 0 to T inclusive All problems are divided into two types easy problems Petya takes exactly a minutes to solve any easy problem hard problems Petya takes exactly b minutes b a to solve any hard problem Thus if Petya starts solving an easy problem at time x then it will be solved at time x a Similarly if at a time x Petya starts to solve a hard problem then it will be solved at time x b For every problem Petya knows if it is easy or hard Also for each problem is determined time t i 0 le t i le T at which it will become required If Petya leaves the exam at time s and there is such a problem i that t i le s and he didn t solve it then he will receive 0 points for the whole exam Otherwise i e if he has solved all such problems for which t i le s he will receive a number of points equal to the number of solved problems Note that leaving at time s Petya can have both mandatory and non mandatory problems solved For example if n 2 T 5 a 2 b 3 the first problem is hard and t 1 3 and the second problem is easy and t 2 2 Then if he leaves at time s 0 then he will receive 0 points since he will not have time to solve any problems if he leaves at time s 1 he will receive 0 points since he will not have time to solve any problems if he leaves at time s 2 then he can get a 1 point by solving the problem with the number 2 it must be solved in the range from 0 to 2 if he leaves at time s 3 then he will receive 0 points since at this moment both problems will be mandatory but he will not be able to solve both of them if he leaves at time s 4 then he will receive 0 points since at this moment both problems will be mandatory but he will not be able to solve both of them if he leaves at time s 5 then he can get 2 points by solving all problems Thus the answer to this test is 2 Help Petya to determine the maximal number of points that he can receive before leaving the exam ,"['#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nll b[MAXN], c[MAXN];\npii a[MAXN];\nvector<ll> f;\nvector<ll> g[MAXN];\nvoid solve() {\n    ll n, T, x, y;\n    cin >> n >> T >> x >> y;\n    ll sum1 = 0, sum2 = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].Y;\n        if (a[i].Y) {\n            sum2++;\n        } else {\n            sum1++;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].X;\n    }\n    if (sum1 * x + sum2 * y <= T) {\n        cout << n << ""\\n"";\n        return;\n    }\n    sort(a, a+n);\n    ll totsum1 = sum1;\n    ll totsum2 = sum2;\n    sum1 = 0;\n    sum2 = 0;\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (i > 0) {\n            if (a[i - 1].Y) {\n                sum2++;\n            } else {\n                sum1++;\n            }\n        }\n        if (a[i].X - 1 >= sum1 * x + sum2 * y) {\n            ll lft = a[i].X - 1 - (sum1 * x + sum2 * y);\n            ll lft1 = totsum1 - sum1;\n            ll lft2 = totsum2 - sum2;\n            ll sum = sum1 + sum2;\n            if (lft1 * x >= lft) {\n                sum += lft / x;\n            } else {\n                sum += lft1 + min(lft2, (lft - lft1 * x) / y);\n            }\n            ans = max(ans, sum);\n        }\n    }\n    cout << ans << ""\\n"";\n\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n    return 0;\n}']","['greedy', 'sortings', 'two pointers']",1800
https://codeforces.com//contest/1849/problem/C,C. Binary String Copying,You are given a string s consisting of n characters and or You make m copies of this string let the i th copy be the string t i Then you perform exactly one operation on each of the copies for the i th copy you sort its substring l i r i the substring from the l i th character to the r i th character both endpoints inclusive Your task is to calculate the number of different strings among t 1 t 2 ldots t m Note that the initial string s should be counted only if at least one of the copies stays the same after the operation ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::set<std::pair<int, int>> S;\n    \n    std::vector<int> nxt(n + 1, n), lst(n + 1, -1);\n    for (int i = n - 1; i >= 0; i--) {\n        nxt[i] = s[i] == \'1\' ? i : nxt[i + 1];\n    }\n    for (int i = 0; i < n; i++) {\n        lst[i + 1] = s[i] == \'0\' ? i : lst[i];\n    }\n    \n    while (m--) {\n        int l, r;\n        std::cin >> l >> r;\n        l--;\n        l = nxt[l];\n        r = lst[r];\n        if (l > r) {\n            l = r = -1;\n        }\n        S.emplace(l, r);\n    }\n    std::cout << S.size() << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['binary search', 'brute force', 'data structures', 'hashing', 'strings']",1600
https://codeforces.com//contest/195/problem/E,E. Building Forest,An is an acyclic weighted digraph in which from each vertex at most one edge goes The of vertex of an oriented weighted forest is a vertex from which no edge goes and which can be reached from vertex moving along the edges of the weighted oriented forest We denote the root of vertex as The of vertex is the sum of weights of paths passing from the vertex to its root Let s denote the depth of the vertex as Let s consider the process of constructing a weighted directed forest Initially the forest does not contain vertices Vertices are added sequentially one by one Overall there are performed operations of adding The th adding operation is described by a set of numbers and means that we should add vertex number and edges to the graph an edge from vertex to vertex with weight an edge from vertex to vertex with weight and so on If then only vertex is added to the graph there are no added edges Your task is like this given the operations of adding vertices calculate the sum of the weights of all edges of the forest resulting after the application of all defined operations modulo ,"['#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vll;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\n#define MOD 1000000007\n\nstatic pair<int, ll> find(vi &parent, vll &weight, int x)\n{\n    int y = x;\n    ll w = 0;\n    while (parent[y] >= 0)\n    {\n        w = (w + weight[y]) % MOD;\n        y = parent[y];\n    }\n\n    ll ws = 0;\n    while (parent[x] >= 0)\n    {\n        int n = parent[x];\n        ll wn = weight[x];\n\n        parent[x] = y;\n        weight[x] = (w - ws) % MOD;\n        ws = (ws + wn) % MOD;\n        x = n;\n    }\n\n    return make_pair(y, w);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N;\n    vi parent(N, -1);\n    vll weight(N, 0);\n    ll ans = 0;\n    for (int i = 0; i < N; i++)\n    {\n        int K;\n        cin >> K;\n        for (int j = 0; j < K; j++)\n        {\n            int v;\n            ll x;\n            cin >> v >> x;\n            v--;\n            pair<int, ll> root = find(parent, weight, v);\n            ll w = (root.second + x) % MOD;\n            ans = (ans + w) % MOD;\n            parent[root.first] = i;\n            weight[root.first] = w;\n            cerr << i << \' \' << root.first << \' \' << w << \'\\n\';\n        }\n    }\n    ans %= MOD;\n    if (ans < 0)\n        ans += MOD;\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']","['data structures', 'dsu', 'graphs']",2000
https://codeforces.com//contest/1735/problem/B,B. Tea with Tangerines,There are n pieces of tangerine peel the i th of them has size a i In one step it is possible to divide one piece of size x into two pieces of positive integer sizes y and z so that y z x You want that for each pair of pieces their sizes differ less than twice In other words there should not be two pieces of size x and y such that 2x le y What is the minimum possible number of steps needed to satisfy the condition ,"[""// LUOGU_RID: 91547726\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+'0');\n}\n#define writesp(x) write(x),putchar(' ')\n#define writeln(x) write(x),putchar('\\n')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=200200;\n\nint n;\nint a[N];\n\nvoid solve() {\n\tn=read(); rep(i,1,n) a[i]=read();\n\tint mn=a[1];\n\trep(i,1,n) mn=min(mn,a[i]);\n\tll ans=0;\n\trep(i,1,n) {\n\t\tint x=(a[i]-1)/(mn*2-1);\n\t\tans+=x;\n\t}\n\twriteln(ans);\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n""]","['greedy', 'math']",900
https://codeforces.com//contest/330/problem/D,D. Biridian Forest,You re a mikemon breeder currently in the middle of your journey to become a mikemon master Your current obstacle is go through the infamous Biridian Forest The Biridian Forest is a two dimensional grid consisting of rows and columns Each cell in Biridian Forest may contain a tree or may be vacant A vacant cell may be occupied by zero or more mikemon breeders there may also be breeders other than you in the forest Mikemon breeders including you cannot enter cells with trees One of the cells is designated as the exit cell The initial grid including your initial position the exit cell and the initial positions of all other breeders will be given to you Here s an example of such grid from the first example Breeders including you may move in the forest In a single move breeders may perform one of the following actions Do nothing Move from the current cell to one of the four adjacent cells two cells are adjacent if they share a side Note that breeders cannot enter cells with trees If you are located on the exit cell you may leave the forest Only you can perform this move all other mikemon breeders will never leave the forest by using this type of movement After each time you make a single move each of the other breeders simultaneously make a single move the choice of which move to make may be different for each of the breeders If you and mikemon breeders are located on the same cell exactly mikemon battles will ensue that time since you will be battling each of those breeders once After the battle all of those breeders will leave the forest to heal their respective mikemons Note that the moment you leave the forest no more mikemon battles can ensue even if another mikemon breeder move to the exit cell immediately after that Also note that a battle only happens between you and another breeders there will be no battle between two other breeders there may be multiple breeders coexisting in a single cell You would like to leave the forest In order to do so you have to make a sequence of moves ending with a move of the final type Before you make any move however you post this sequence on your personal virtual idol Blog Then you will follow this sequence of moves faithfully Because you post the sequence in your Blog the other breeders will all know your exact sequence of moves even before you make your first move All of them will move in such way that will guarantee a mikemon battle with you if possible The breeders that couldn t battle you will do nothing Print the minimum number of mikemon battles that you must participate in assuming that you pick the sequence of moves that minimize this number Note that you are not required to minimize the number of moves you make ,"['#include<stdio.h>\n#include<queue>\nusing namespace std;\n#define N 1001\n\nstruct pnt{\n\tint h,w,z;\n\tpnt(int h,int w,int z):h(h),w(w),z(z){}\n};\n\nbool operator == (pnt a,pnt b){\n\tif(a.h==b.h&&a.w==b.w)return 1;\n\treturn 0;\n}\n\nint r,c;\nint p[N][N];\nint chk[N][N];\nint dh[]={-1,0,1,0},dw[]={0,1,0,-1};\n\nint main(){\n\t//freopen(""2.in"",""r"",stdin);\n\tint i,j,k;\n\tchar C;\n\tscanf(""%d%d\\n"",&r,&c);\n\tqueue<pnt>q;\n\tfor(i=1;i<=r;i++)for(j=1;j<=c;j++){\n\t\tscanf(""%c\\n"",&C);\n\t\tif(C==\'S\')p[i][j]=-N;\n\t\telse if(C==\'E\')p[i][j]=N,q.push(pnt(i,j,0)),chk[i][j]=1;\n\t\telse if(C==\'T\')p[i][j]=-1;\n\t\telse p[i][j]=C-\'0\';\n\t}\n\n\tint ans=0,dep=N*N;\n\twhile(!q.empty()){\n\t\tpnt en=q.front();q.pop();\n\t\tif(en.z<=dep)ans+=p[en.h][en.w];\n\t\tfor(k=0;k<4;k++){\n\t\t\ti=en.h+dh[k];j=en.w+dw[k];\n\t\t\tif(i<1||i>r||j<1||j>c||p[i][j]==-1||chk[i][j])continue;\n\t\t\tif(p[i][j]==-N)dep=en.z+1;\n\t\t\tq.push(pnt(i,j,en.z+1));\n\t\t\tchk[i][j]=1;\n\t\t}\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","['dfs and similar', 'implementation', 'shortest paths']",1500
https://codeforces.com//contest/1573/problem/A,A. Countdown,You are given a digital clock with n digits Each digit shows an integer from 0 to 9 so the whole clock shows an integer from 0 to 10 n 1 The clock will show leading zeroes if the number is smaller than 10 n 1 You want the clock to show 0 with as few operations as possible In an operation you can do one of the following decrease the number on the clock by 1 or swap two digits you can choose which digits to swap and they don t have to be adjacent Your task is to determine the minimum number of operations needed to make the clock show 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint i,j,k,n,m,t,res;\n\nint main(){\n\tscanf(""%d"",&t);\n\twhile(t--){\n\t\tscanf(""%d"",&n);res=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(""%1d"",&k);\n\t\t\tif(k){\n\t\t\t\tres+=1+k;\n\t\t\t\tif(i==n)res--;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",res);\n\t}\n}']",['greedy'],800
https://codeforces.com//contest/1747/problem/A,A. Two Groups,You are given an array a consisting of n integers You want to distribute these n integers into two groups s 1 and s 2 groups can be empty so that the following conditions are satisfied For each i 1 leq i leq n a i goes into exactly one group The value sum s 1 sum s 2 is the maximum possible among all such ways to distribute the integers Here sum s 1 denotes the sum of the numbers in the group s 1 and sum s 2 denotes the sum of the numbers in the group s 2 Determine the maximum possible value of sum s 1 sum s 2 ,"['// LUOGU_RID: 93002917\n/*\nわんわん……わんだほーいっ☆\nWonderhoy!\n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nchar buf[1<<21],*p1=buf,*p2=buf;\n#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)\nLL read()\n{\n\tLL x=0,f=1;\n\tchar c=getchar();\n\twhile(c<\'0\' || c>\'9\')\tf=(c==\'-\'?-1:f),c=getchar();\n\twhile(c>=\'0\' && c<=\'9\')\tx=(x<<1)+(x<<3)+(c^\'0\'),c=getchar();\n\treturn x*f;\n}\nvoid write(LL x)\n{\n\tif(x>9)\twrite(x/10);\n\tputchar(x%10+\'0\');\n}\nvoid Solve();\nint main(){\n\tLL T=read();\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}\nLL n,a[100005];\nvoid Solve()\n{\n\tn=read();\n\tfor(LL i=1;i<=n;++i)\ta[i]=read();\n\tLL p=0,q=0;\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tif(a[i]<0)\tp-=a[i];\n\t\telse\tq+=a[i];\n\t}\n\twrite(max(p,q)-min(p,q)),puts("""");\n}']","['constructive algorithms', 'greedy']",800
https://codeforces.com//contest/1665/problem/B,B. Array Cloning Technique,You are given an array a of n integers Initially there is only one copy of the given array You can do operations of two types Choose any array and clone it After that there is one more copy of the chosen array Swap two elements from two copies maybe in the same copy on any positions You need to find the minimal number of operations needed to obtain a copy where all elements are equal ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nmap <int,int> mp;\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tint mx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tmx=max(mx,++mp[x]);\n\t\t}\n\t\tmp.clear();\n\t\tint ans=n-mx;\n\t\twhile(mx<n) ++ans,mx*=2;\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'greedy', 'sortings']",900
https://codeforces.com//contest/1554/problem/B,B. Cobb,You are given n integers a 1 a 2 ldots a n and an integer k Find the maximum value of i cdot j k cdot a i a j over all pairs i j of integers with 1 le i j le n Here is the bitwise OR operator ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint t,n,k,a[100005];\nint main()\n{\n    scanf(""%d"",&t);\n    while(t--)\n    {\n        scanf(""%d%d"",&n,&k);\n        for(int i=1;i<=n;i++)\n        {\n            scanf(""%d"",&a[i]);\n        }\n        long long ans=-1e9;\n        for(int i=max(1,n-105);i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                ans=max(ans,((long long)i)*j-(a[i]|a[j])*k);\n            }\n        }\n        printf(""%lld\\n"",ans);\n    }\n}']","['bitmasks', 'brute force', 'greedy', 'math']",1700
https://codeforces.com//contest/69/problem/A,A. Young Physicist,A guy named Vasya attends the final grade of a high school One day Vasya decided to watch a match of his favorite hockey team And as the boy loves hockey very much even more than physics he forgot to do the homework Specifically he forgot to complete his physics tasks Next day the teacher got very angry at Vasya and decided to teach him a lesson He gave the lazy student a seemingly easy task You are given an idle body in space and the forces that affect it The body can be considered as a material point with coordinates 0 0 0 Vasya had only to answer whether it is in equilibrium Piece of cake thought Vasya we need only to check if the sum of all vectors is equal to 0 So Vasya began to solve the problem But later it turned out that there can be lots and lots of these forces and Vasya can not cope without your help Help him Write a program that determines whether a body is idle or is moving by the given vectors of forces ,"['#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n , sx = 0 , sy = 0 , sz = 0 ;\n\tcin >> n ;\n\tfor ( int i = 0 ; i < n ; i ++ ) {\n\t\tint x , y , z ;\n\t\tcin >> x >> y >> z ;\n\t\tsx += x ;\n\t\tsy += y ;\n\t\tsz += z ;\n\t}\n\tif ( sx == 0 && sy == 0 && sz == 0 ) {\n\t\tcout << ""YES"" << endl ;\n\t} else {\n\t\tcout << ""NO"" << endl ;\n\t}\n\treturn 0 ;\n}\n']","['implementation', 'math']",1000
https://codeforces.com//contest/986/problem/D,D. Perfect Encoding,You are working as an analyst in a company working on a new system for big data storage This system will store n different objects Each object should have a unique ID To create the system you choose the parameters of the system integers m ge 1 and b 1 b 2 ldots b m With these parameters an ID of some object in the system is an array of integers a 1 a 2 ldots a m where 1 le a i le b i holds for every 1 le i le m Developers say that production costs are proportional to sum i 1 m b i You are asked to choose parameters m and b i so that the system will be able to assign unique IDs to n different objects and production costs are minimized Note that you don t have to use all available IDs ,"['/**\n *    author:  tourist\n *    created: 29.05.2018 18:52:44       \n**/\n//#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nnamespace fft {\n  typedef double dbl;\n\n  struct num {\n    dbl x, y;\n    num() { x = y = 0; }\n    num(dbl x, dbl y) : x(x), y(y) { }\n  };\n\n  inline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\n  inline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\n  inline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n  inline num conj(num a) { return num(a.x, -a.y); }\n\n  int base = 1;\n  vector<num> roots = {{0, 0}, {1, 0}};\n  vector<int> rev = {0, 1};\n\n  const dbl PI = acosl(-1.0);\n\n  void ensure_base(int nbase) {\n    if (nbase <= base) {\n      return;\n    }\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n        dbl angle_i = angle * (2 * i + 1 - (1 << base));\n        roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n      }\n      base++;\n    }\n  }\n\n  void fft(vector<num> &a, int n = -1) {\n    if (n == -1) {\n      n = a.size();\n    }\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          num z = a[i + j + k] * roots[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n/*    for (int len = 1; len < n; len <<= 1) {\n      for (int i = 0; i < n; i += 2 * len) {\n        for (int j = i, k = i + len; j < i + len; j++, k++) {\n          num z = a[k] * roots[k - i];\n          a[k] = a[j] - z;\n          a[j] = a[j] + z;\n        }\n      }\n    }*/\n  }\n\n  vector<num> fa, fb;\n\n  vector<int> multiply(vector<int> &a, vector<int> &b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    if (sz > (int) fa.size()) {\n      fa.resize(sz);\n    }\n    for (int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = num(x, y);\n    }\n    fft(fa, sz);\n    num r(0, -0.25 / (sz >> 1));\n    for (int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n      if (i != j) {\n        fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n      }\n      fa[i] = z;\n    }\n    for (int i = 0; i < (sz >> 1); i++) {\n      num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n      num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n      fa[i] = A0 + A1 * num(0, 1);\n    }\n    fft(fa, sz >> 1);\n    vector<int> res(need);\n    for (int i = 0; i < need; i++) {\n      if (i % 2 == 0) {\n        res[i] = fa[i >> 1].x + 0.5;\n      } else {\n        res[i] = fa[i >> 1].y + 0.5;\n      }\n    }\n    return res;\n  }\n\n  vector<long long> square(const vector<int> &a) {\n    int need = a.size() + a.size() - 1;\n    int nbase = 1;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    if ((sz >> 1) > (int) fa.size()) {\n      fa.resize(sz >> 1);\n    }\n    for (int i = 0; i < (sz >> 1); i++) {\n      int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n      int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n      fa[i] = num(x, y);\n    }\n    fft(fa, sz >> 1);\n    num r(1.0 / (sz >> 1), 0.0);\n    for (int i = 0; i <= (sz >> 2); i++) {\n      int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n      num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n      num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n      num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n      num tmp = fe * fo;\n      fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n      fa[j] = r * (aux + num(0, 2) * tmp);\n    }\n    fft(fa, sz >> 1);\n    vector<long long> res(need);\n    for (int i = 0; i < need; i++) {\n      if (i % 2 == 0) {\n        res[i] = fa[i >> 1].x + 0.5;\n      } else {\n        res[i] = fa[i >> 1].y + 0.5;\n      }\n    }\n    return res;\n  }\n\n  vector<int> multiply_mod(vector<int> &a, vector<int> &b, int m, int eq = 0) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    if (sz > (int) fa.size()) {\n      fa.resize(sz);\n    }\n    for (int i = 0; i < (int) a.size(); i++) {\n      int x = (a[i] % m + m) % m;\n      fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n    }\n    fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});\n    fft(fa, sz);\n    if (sz > (int) fb.size()) {\n      fb.resize(sz);\n    }\n    if (eq) {\n      copy(fa.begin(), fa.begin() + sz, fb.begin());\n    } else {\n      for (int i = 0; i < (int) b.size(); i++) {\n        int x = (b[i] % m + m) % m;\n        fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n      }\n      fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});\n      fft(fb, sz);\n    }\n    dbl ratio = 0.25 / sz;\n    num r2(0, -1);\n    num r3(ratio, 0);\n    num r4(0, -ratio);\n    num r5(0, 1);\n    for (int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      num a1 = (fa[i] + conj(fa[j]));\n      num a2 = (fa[i] - conj(fa[j])) * r2;\n      num b1 = (fb[i] + conj(fb[j])) * r3;\n      num b2 = (fb[i] - conj(fb[j])) * r4;\n      if (i != j) {\n        num c1 = (fa[j] + conj(fa[i]));\n        num c2 = (fa[j] - conj(fa[i])) * r2;\n        num d1 = (fb[j] + conj(fb[i])) * r3;\n        num d2 = (fb[j] - conj(fb[i])) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector<int> res(need);\n    for (int i = 0; i < need; i++) {\n      long long aa = fa[i].x + 0.5;\n      long long bb = fb[i].x + 0.5;\n      long long cc = fa[i].y + 0.5;\n      res[i] = (aa + ((bb % m) << 15) + ((cc % m) << 30)) % m;\n    }\n    return res;\n  }\n\n  vector<int> square_mod(vector<int> &a, int m) {\n    return multiply_mod(a, a, m, 1);\n  }\n};\n\nvoid multiply(vector<int> &a, int b) {\n  int carry = 0;\n  for (int i = 0; i < (int) a.size(); i++) {\n    carry += a[i] * b;\n    a[i] = carry % 100000;\n    carry /= 100000;\n  }\n  while (carry > 0) {\n    a.push_back(carry % 100000);\n    carry /= 100000;\n  }\n}\n\nvoid divide(vector<int> &a, int b) {\n  int md = 0;\n  for (int i = (int) a.size() - 1; i >= 0; i--) {\n    md = 100000 * md + a[i];\n    a[i] = md / b;\n    md %= b;\n  }\n  assert(md == 0);\n  while (!a.empty() && a.back() == 0) {\n    a.pop_back();\n  }\n}\n\nbool is_less(const vector<int> &a, const vector<int> &b) {\n  if (a.size() != b.size()) {\n    return (a.size() < b.size());\n  }\n  for (int i = (int) a.size() - 1; i >= 0; i--) {\n    if (a[i] != b[i]) {\n      return (a[i] < b[i]);\n    }\n  }\n  return false;\n}\n\nvector<int> sp3;\nvector<long long> sp3_aux;\n\nvoid get_p3(int p3) {\n  if (p3 <= 0) {\n    return;\n  }\n  if (p3 & 1) {\n    get_p3(p3 - 1);\n    multiply(sp3, 3);\n  } else {\n    get_p3(p3 >> 1);\n    sp3_aux = fft::square(sp3);\n    sp3.resize(sp3_aux.size());\n    long long carry = 0;\n    for (int i = 0; i < (int) sp3_aux.size(); i++) {\n      carry += sp3_aux[i];\n      sp3[i] = carry % 100000;\n      carry /= 100000;\n    }\n    while (carry > 0) {\n      sp3.push_back(carry % 100000);\n      carry /= 100000;\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n//  debug(fft::square({100, 200, 300, 400, 500}));\n//  return 0;\n  string foo;\n  cin >> foo;\n  if (foo == ""1"") {\n    cout << 1 << \'\\n\';\n    return 0;\n  }\n  int len = (int) foo.size();\n  vector<int> s_10(len);\n  for (int i = 0; i < len; i++) {\n    s_10[i] = (int) (foo[len - 1 - i] - \'0\');\n  }\n  vector<int> s((len + 4) / 5);\n  for (int i = 0; i < (int) s.size(); i++) {\n    s[i] = s_10[5 * i];\n    if (5 * i + 1 < (int) s_10.size()) s[i] += 10 * s_10[5 * i + 1];\n    if (5 * i + 2 < (int) s_10.size()) s[i] += 100 * s_10[5 * i + 2];\n    if (5 * i + 3 < (int) s_10.size()) s[i] += 1000 * s_10[5 * i + 3];\n    if (5 * i + 4 < (int) s_10.size()) s[i] += 10000 * s_10[5 * i + 4];\n  }\n  int p3 = (int) (logl(10) * (len - 1) / logl(3));\n  sp3.assign(1, 1);\n  get_p3(p3);\n  int ans = 3 * p3;\n  while (is_less(sp3, s)) {\n    if (ans <= 3) {\n      sp3[0] = ans + 1;\n    } else {\n      if (ans % 3 == 0) {\n        divide(sp3, 3);\n        multiply(sp3, 4);\n      } else {\n        divide(sp3, 2);\n        multiply(sp3, 3);\n      }\n    }\n    ans++;\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","['fft', 'math']",3100
https://codeforces.com//contest/1004/problem/E,E. Sonya and Ice Cream,Sonya likes ice cream very much She eats it even during programming competitions That is why the girl decided that she wants to open her own ice cream shops Sonya lives in a city with n junctions and n 1 streets between them All streets are two way and connect two junctions It is possible to travel from any junction to any other using one or more streets City Hall allows opening shops only on junctions The girl cannot open shops in the middle of streets Sonya has exactly k friends whom she can trust If she opens a shop one of her friends has to work there and not to allow anybody to eat an ice cream not paying for it Since Sonya does not want to skip an important competition she will not work in shops personally Sonya wants all her ice cream shops to form a simple path of the length r 1 le r le k i e to be located in different junctions f 1 f 2 dots f r and there is street between f i and f i 1 for each i from 1 to r 1 The girl takes care of potential buyers so she also wants to minimize the maximum distance between the junctions to the nearest ice cream shop The distance between two junctions a and b is equal to the sum of all the street lengths that you need to pass to get from the junction a to the junction b So Sonya wants to max a min 1 le i le r d a f i where a takes a value of all possible n junctions f i the junction where the i th Sonya s shop is located and d x y the distance between the junctions x and y Sonya is not sure that she can find the optimal shops locations that is why she is asking you to help her to open not more than k shops that will form a simple path and the maximum distance between any junction and the nearest shop would be minimal ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Edge;\n\n#define MAXN 100001\n#define MAXD 17\n#define INF 0x3f3f3f3f\n\nint n, s, p[MAXN], f[MAXN], tot, que[MAXN], dis[MAXN], pre[MAXN], suf[MAXN], Log[MAXN], st[MAXD][MAXN];\nvector<Edge> e[MAXN];\nbool inq[MAXN];\n\nint rmq(int l, int r) {\n\tif(l > r)\n\t\treturn 0;\n\tint d = Log[r - l + 1];\n\treturn max(st[d][l], st[d][r - (1 << d) + 1]);\n}\n\nvoid dfs(int u, int fa) {\n\tf[u] = 0;\n\tfor(auto it : e[u]) {\n\t\tint v = it.first, w = it.second;\n\t\tif(v == fa || inq[v])\n\t\t\tcontinue;\n\t\tdfs(v, u);\n\t\tif(f[u] < f[v] + w) {\n\t\t\tf[u] = f[v] + w;\n\t\t\tp[u] = v;\n\t\t}\n\t}\n}\n\nint main() {\n\tLog[1] = 0;\n\tfor(int i = 2; i < MAXN; ++i)\n\t\tLog[i] = Log[i >> 1] + 1;\n\tscanf(""%d%d"", &n, &s);\n\tfor(int i = 1; i < n; ++i) {\n\t\tint u, v, w;\n\t\tscanf(""%d%d%d"", &u, &v, &w);\n\t\te[u].push_back(make_pair(v, w));\n\t\te[v].push_back(make_pair(u, w));\n\t}\n\tdfs(1, -1);\n\tfor(que[tot++] = 1; f[que[0]]; que[0] = p[que[0]]);\n\tdfs(que[0], -1);\n\tinq[que[0]] = 1;\n\tdis[0] = f[que[0]];\n\tfor(int u = que[0]; f[u]; u = p[u]) {\n\t\tinq[p[u]] = 1;\n\t\tdis[tot] = f[p[u]];\n\t\tque[tot++] = p[u];\n\t}\n\tfor(int i = 0; i < tot; ++i) {\n\t\tdfs(que[i], -1);\n\t\tpre[i] = suf[i] = st[0][i] = f[que[i]];\n\t}\n\tfor(int i = 1; i < tot; ++i)\n\t\tif(pre[i] < pre[i - 1] + dis[i - 1] - dis[i])\n\t\t\tpre[i] = pre[i - 1] + dis[i - 1] - dis[i];\n\tfor(int i = tot - 2; i >= 0; --i)\n\t\tif(suf[i] < suf[i + 1] + dis[i] - dis[i + 1])\n\t\t\tsuf[i] = suf[i + 1] + dis[i] - dis[i + 1];\n\tfor(int d = 1; d < MAXD; ++d)\n\t\tfor(int i = 0; i < tot && i + (1 << d - 1) < tot; ++i)\n\t\t\tst[d][i] = max(st[d - 1][i], st[d - 1][i + (1 << d - 1)]);\n\tint ans = INF;\n\tfor(int i = 0, j = 0; i < tot; ++i)\n\t\tfor(j = j < i ? i : j; j < tot && j - i + 1 <= s; ++j) {\n\t\t\tint tmp = max(max(pre[i], suf[j]), rmq(i + 1, j - 1));\n\t\t\tif(ans > tmp)\n\t\t\t\tans = tmp;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']","['binary search', 'data structures', 'dp', 'greedy', 'shortest paths', 'trees']",2400
https://codeforces.com//contest/765/problem/B,B. Code obfuscation,Kostya likes Codeforces contests very much However he is very disappointed that his solutions are frequently hacked That s why he decided to obfuscate intentionally make less readable his code before upcoming contest To obfuscate the code Kostya first looks at the first variable name used in his program and replaces all its occurrences with a single symbol then he looks at the second variable name that has not been replaced yet and replaces all its occurrences with and so on Kostya is well mannered so he doesn t use any one letter names before obfuscation Moreover there are at most 26 unique identifiers in his programs You are given a list of identifiers of some program with removed spaces and line breaks Check if this program can be a result of Kostya s obfuscation ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 505;\nchar str[N];\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tscanf(""%s"", str);\n\tint n = strlen(str);\n\n\tint cur = \'a\';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (str[i] < cur) continue;\n\t\tif (str[i] > cur)\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tif (str[i] == cur)\n\t\t{\n\t\t\tcur++;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n\n\n\n\treturn 0;\n}\n\n\n']","['greedy', 'implementation', 'strings']",1100
https://codeforces.com//contest/181/problem/A,A. Series of Crimes,The Berland capital is shaken with three bold crimes committed by the Pihsters a notorious criminal gang The Berland capital s map is represented by an rectangular table Each cell of the table on the map represents some districts of the capital The capital s main detective Polycarpus took a map and marked there the districts where the first three robberies had been committed as asterisks Deduction tells Polycarpus that the fourth robbery will be committed in such district that all four robbed districts will form the vertices of some rectangle parallel to the sides of the map Polycarpus is good at deduction but he s hopeless at math So he asked you to find the district where the fourth robbery will be committed ,"['#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long i64;\ntypedef unsigned long long ui64;\n\nconst int intINF=999999999;\nconst i64 i64INF=99999999999999999ll;\nconst double doubleINF=9999999999.;\n\nusing namespace std;\n\nint X[4],Y[4],l;\n\nint main(){\n\tint n,m;\n\tchar c;\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(""%*c"");\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(""%c"",&c);\n\t\t\tif(c==\'*\') X[++l]=i,Y[l]=j;\n\t\t}\n\t}\n\tsort(X+1,X+4);\n\tsort(Y+1,Y+4);\n\tif(X[1]==X[2]) printf(""%d"",X[3]);\n\telse printf(""%d"",X[1]);\n\tprintf("" "");\n\tif(Y[1]==Y[2]) printf(""%d"",Y[3]);\n\telse printf(""%d"",Y[1]);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","['brute force', 'geometry', 'implementation']",800
https://codeforces.com//contest/997/problem/A,A. Convert to Ones,You ve got a string a 1 a 2 dots a n consisting of zeros and ones Let s call a sequence of consecutive elements a i a i 1 ldots a j 1 leq i leq j leq n a of string a You can apply the following operations any number of times Choose some substring of string a for example you can choose entire string and reverse it paying x coins for it for example to Choose some substring of string a for example you can choose entire string or just one symbol and replace each symbol to the opposite one zeros are replaced by ones and ones by zeros paying y coins for it for example to You can apply these operations in any order It is allowed to apply the operations multiple times to the same substring What is the minimum number of coins you need to spend to get a string consisting only of ones ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,x,y;\nchar s[SZ];\nint main()\n{\n\tscanf(""%d%d%d%s"",&n,&x,&y,s+1);\n\tint b=0; ll ans=8e18;\n\tfor(int i=1;i<=n;++i)\n\t\tif(s[i]==\'0\'&&s[i-1]!=\'0\') ++b;\n\tif(!b) ans=0;\n\tfor(int i=0;i<b;++i)\n\t\tans=min(ans,y*(ll)(b-i)+x*(ll)i);\n\tprintf(""%lld\\n"",ans);\n}\n']","['brute force', 'greedy', 'implementation', 'math']",1500
https://codeforces.com//contest/1157/problem/B,B. Long Number,You are given a long decimal number a consisting of n digits from 1 to 9 You also have a function f that maps every digit from 1 to 9 to some possibly the same digit from 1 to 9 You can perform the following operation choose a non empty of digits in a and replace each digit x from this segment with f x For example if a 1337 f 1 1 f 3 5 f 7 3 and you choose the segment consisting of three rightmost digits you get 1553 as the result What is the maximum possible number you can obtain applying this operation no more than once ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <numeric>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+"".in"").c_str());\n\t\tFout((pname+"".out"").c_str());\n\t#else\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 200010\n\nint n;\nint a[MAXN];\nint to[MAXN];\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) a[i] = In.Readnum()-\'0\';\n\tFor(i,9) Read(to[i]);\n\n\tint flag = 0;\n\tFor(i,n){\n\t\tif( flag == 1 ){\n\t\t\tif( to[a[i]] >= a[i] ) a[i] = to[a[i]];\n\t\t\telse flag = 2;\n\t\t}\n\t\tif( flag == 0 ){\n\t\t\tif( to[a[i]] > a[i] ){\n\t\t\t\ta[i] = to[a[i]];\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\t;\n\t}else{\n\t\t/*\n\t\tbool eq = 0;\n\t\tFor(i,n){\n\t\t\tif( a[i] == to[a[i]] ) eq = 1;\n\t\t}\n\t\tif(!eq) a[n] = to[a[n]];\n\t\t*/\n\t}\n\tFor(i,n)\n\t\tputchar(a[i]+\'0\');\n\tputchar(10);\n\n\tEND();\n}\n']",['greedy'],1300
https://codeforces.com//contest/1487/problem/D,D. Pythagorean Triples,A Pythagorean triple is a triple of integer numbers a b c such that it is possible to form a right triangle with the lengths of the first cathetus the second cathetus and the hypotenuse equal to a b and c respectively An example of the Pythagorean triple is 3 4 5 Vasya studies the properties of right triangles and he uses a formula that determines if some triple of integers is Pythagorean Unfortunately he has forgotten the exact formula he remembers only that the formula was some equation with squares So he came up with the following formula c a 2 b Obviously this is not the right formula to check if a triple of numbers is Pythagorean But to Vasya s surprise it actually worked on the triple 3 4 5 5 3 2 4 so according to Vasya s formula it is a Pythagorean triple When Vasya found the right formula and understood that his formula is wrong he wondered how many are there triples of integers a b c with 1 le a le b le c le n such that they are Pythagorean both according to his formula and the real definition He asked you to count these triples ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    ll N; cin >> N;\n    int ans = 0;\n    for (int i = 3; true; i+=2) {\n        if ((i*i+1)/2 > N || i > N) break;\n        ans++;\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['binary search', 'brute force', 'math', 'number theory']",1500
https://codeforces.com//contest/1490/problem/G,G. Old Floppy Drive ,Polycarp was dismantling his attic and found an old floppy drive on it A round disc was inserted into the drive with n integers written on it Polycarp wrote the numbers from the disk into the a array It turned out that the drive works according to the following algorithm the drive takes one positive number x as input and puts a pointer to the first element of the a array after that the drive starts rotating the disk every second moving the pointer to the next element counting the sum of all the elements that have been under the pointer Since the disk is round in the a array the last element is again followed by the first one as soon as the sum is at least x the drive will shut down Polycarp wants to learn more about the operation of the drive but he has absolutely no free time So he asked you m questions To answer the i th of them you need to find how many seconds the drive will work if you give it x i as input Please note that in some cases the drive can work infinitely For example if n 3 m 3 a 1 3 4 and x 1 5 2 then the answers to the questions are as follows the answer to the first query is 0 because the drive initially points to the first item and the initial sum is 1 the answer to the second query is 6 the drive will spin the disk completely twice and the amount becomes 1 3 4 1 3 4 1 5 the answer to the third query is 2 the amount is 1 3 4 2 ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int SIZE = 1 << 20;\nconst int len = 1 << 19;\nlong long tree[SIZE];\nint n, m;\nint arr[200010];\n\nvoid update(int idx, long long value)\n{\n\tidx += len;\n\ttree[idx] = value;\n\tidx /= 2;\n\twhile (idx >= 1)\n\t{\n\t\ttree[idx] = max(tree[2 * idx], tree[2 * idx + 1]);\n\t\tidx /= 2;\n\t}\n}\n\nint get(int idx, int s, int e, long long value)\n{\n\tint mid;\n\n\tif (idx >= len) return s;\n\n\tmid = (s + e) / 2;\n\n\tif (tree[2 * idx] >= value) return get(2 * idx, s, mid, value);\n\telse return get(2 * idx + 1, mid + 1, e, value);\n}\n\nint main()\n{\n\tint t;\n\tint i;\n\tlong long x;\n\tlong long sum;\n\tlong long cycle;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n >> m;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\tsum = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tsum += arr[i];\n\n\t\t\tupdate(i, sum);\n\t\t}\n\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> x;\n\n\t\t\tif (tree[1] >= x)\n\t\t\t{\n\t\t\t\tcout << get(1, 0, len - 1, x) << ' ';\n\t\t\t}\n\t\t\telse if (sum <= 0)\n\t\t\t{\n\t\t\t\tcout << -1 << ' ';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcycle = (x - tree[1]) / sum + ((x - tree[1]) % sum != 0);\n\t\t\t\tx -= sum * cycle;\n\t\t\t\tcout << get(1, 0, len - 1, x) + n * cycle << ' ';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tupdate(i, 0);\n\t\t}\n\t}\n}""]","['binary search', 'data structures', 'math']",1900
https://codeforces.com//contest/995/problem/D,D. Game,Allen and Bessie are playing a simple number game They both know a function f 0 1 n to mathbb R i e the function takes n binary arguments and returns a real value At the start of the game the variables x 1 x 2 dots x n are all set to 1 Each round with equal probability one of Allen or Bessie gets to make a move A move consists of picking an i such that x i 1 and either setting x i to 0 or x i to 1 After n rounds all variables are set and the game value resolves to f x 1 x 2 dots x n Allen wants to maximize the game value and Bessie wants to minimize it Your goal is to help Allen and Bessie find the expected game value They will play r 1 times though so between each game exactly one value of f changes In other words between rounds i and i 1 for 1 le i le r f z 1 dots z n to g i for some z 1 dots z n in 0 1 n You are to find the expected game value in the beginning and after each change ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,r,z,c[(1<<18)+10];\nll ans;\nint main() {\n\tscanf(""%d%d"",&n,&r);\n\trep(i,0,(1<<n)) {\n\t\tscanf(""%d"",c+i);\n\t\tans+=c[i];\n\t}\n\tdouble w=1<<n;\n\tprintf(""%.10f\\n"",ans/w);\n\trep(i,0,r) {\n\t\tscanf(""%d"",&z);\n\t\tans-=c[z];\n\t\tscanf(""%d"",c+z);\n\t\tans+=c[z];\n\t\tprintf(""%.10f\\n"",ans/w);\n\t}\n}\n']",['math'],2500
https://codeforces.com//contest/1798/problem/F,F. Gifts from Grandfather Ahmed,Grandfather Ahmed s School has n 1 students The students are divided into k classes and s i students study in the i th class So s 1 s 2 ldots s k n 1 Due to the upcoming April Fools Day all students will receive gifts Grandfather Ahmed planned to order n 1 boxes of gifts Each box can contain one or more gifts He plans to distribute the boxes between classes so that the following conditions are satisfied Class number i receives s i boxes so that each student can open exactly one box The total number of gifts in the boxes received by the i th class should be a multiple of s i it should be possible to equally distribute the gifts among the s i students of this class Unfortunately Grandfather Ahmed ordered only n boxes with gifts the i th of which contains a i gifts Ahmed has to buy the missing gift box and the number of gifts in the box should be an integer between 1 and 10 6 Help Ahmed to determine how many gifts should the missing box contain and build a suitable distribution of boxes to classes or report that this is impossible ,"['#pragma GCC optimization(""O3"")\n#pragma GCC optimization(""Ofast,unroll-loops"")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline ""\\n""                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<"" ""; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<""{""; _print(p.first);cerr<<"",""; _print(p.second);cerr<<""}"";}\ntemplate<class T>void _print(vector<T> v) {cerr<<"" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(set<T> v) {cerr<<"" [ ""; for (T i:v){_print(i); cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< "" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<"" [ ""; for(auto i:v) {_print(i);cerr<<"" "";} cerr<<""]"";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n,k; cin>>n>>k;\n    vector<ll> a(n+5);\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    vector<ll> s(k+5,0);\n    for(ll i=1;i<=k;i++){\n        cin>>s[i];\n    }\n    vector<ll> skip(n+5,0);\n    vector<vector<ll>> ans;\n    ll already=0;\n    for(ll i=1;i<=k;i++){\n        ll len=s[i];\n        vector<vector<ll>> dp(len+5,vector<ll>(len+5,-1));\n        dp[0][0]=0;\n        for(ll pos=1;pos<=n;pos++){\n            if(skip[pos]){\n                continue;\n            }\n            for(ll freq=len-1;freq>=0;freq--){\n                for(ll rem=len-1;rem>=0;rem--){\n                    if(dp[freq][rem]==-1){\n                        continue; \n                    }\n                    if(dp[freq+1][(rem+a[pos])%len]!=-1){\n                        continue;\n                    }\n                    dp[freq+1][(rem+a[pos])%len]=pos; \n                }\n            }\n        }\n        vector<ll> now;\n        if(dp[len][0]!=-1){\n            ;\n        }\n        else{\n            assert(already==0); \n            for(ll rem=0;rem<len;rem++){\n                if(dp[len-1][rem]!=-1){\n                    dp[len][0]=n+1;\n                    a[n+1]=len-rem;\n                    break;  \n                }  \n            }\n            already=1;\n        }\n        ll rem=0;     \n        for(ll freq=len;freq>=1;freq--){\n            ll cur=dp[freq][rem];\n            now.push_back(a[cur]);\n            rem=(rem-a[cur])%len;\n            rem=(rem+len)%len;\n            skip[cur]=1;\n        }\n        ans.push_back(now);\n    }\n    cout<<a[n+1]<<nline;\n    for(auto it:ans){\n        for(auto i:it){\n            cout<<i<<"" "";\n        }\n        cout<<nline; \n    }\n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(""input.txt"", ""r"", stdin);                                              \n    freopen(""output.txt"", ""w"", stdout);  \n    freopen(""error.txt"", ""w"", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    //cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}  ']","['dp', 'math', 'number theory']",2500
https://codeforces.com//contest/1580/problem/C,C. Train Maintenance,Kawasiro Nitori is excellent in engineering Thus she has been appointed to help maintain trains There are n models of trains and Nitori s department will only have at most one train of each model at any moment In the beginning there are no trains at each of the following m days one train will be added or one train will be removed When a train of model i is added at day t it works for x i days day t inclusive then it is in maintenance for y i days then in work for x i days again and so on until it is removed In order to make management easier Nitori wants you to help her calculate how many trains are in maintenance in each day ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAGIC = 450;\n\nint n, m, x[200005], y[200005], cur, sum;\nint d0[200005], d1[455][455];\nint beg[200005];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep1(i, n) scanf(""%d%d"", &x[i], &y[i]);\n\t\n\trep(i, m) {\n\t\tint op, k, coef = 1;\n\t\tscanf(""%d%d"", &op, &k);\n\t\tif(op == 1) beg[k] = i;\n\t\telse {\n\t\t\tcoef = -1;\n\t\t\tif((i - 1 - beg[k]) % (x[k] + y[k]) < x[k]) cur --;\n\t\t}\n\t\tsum += coef;\n\t\tif(x[k] + y[k] < MAGIC) {\n\t\t\td1[x[k] + y[k]][beg[k] % (x[k] + y[k])] += coef; d1[x[k] + y[k]][(beg[k] + x[k]) % (x[k] + y[k])] -= coef;\n\t\t} else {\n\t\t\tfor(LL tmp = beg[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] += coef;\n\t\t\tfor(LL tmp = beg[k] + x[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] -= coef;\n\t\t}\n\t\tcur += d0[i];\n\t\tfor(int tmp = 2; tmp < MAGIC; tmp ++) cur += d1[tmp][i % tmp];\n\t\tprintf(""%d\\n"", sum - cur);\n\t}\n\treturn 0;\n}']","['brute force', 'data structures', 'implementation']",2200
https://codeforces.com//contest/244/problem/B,B. Undoubtedly Lucky Numbers,Let s call a positive integer if there are such digits and that the decimal representation of number without leading zeroes contains only digits and Polycarpus has integer He wants to know how many positive integers that do not exceed are undoubtedly lucky Help him count this number ,"['#include <stdio.h>\n#include <map>\nusing namespace std;\nmap<long long, int> mp;\nint l[10000], w, r;\nint main(){\n    int n, x, y, ans = 0;\n    scanf(""%d"", &n);\n    for (x = 0; x < 10; x++){\n        for (y = x + 1; y < 10; y++){\n            w = r = 0;\n            if (x && x <= n) l[w++] = x;\n            if (y && y <= n) l[w++] = y;\n            while (r < w){\n                long long t = l[r];\n                if (t * 10 + x <= n) l[w++] = t * 10 + x;\n                if (t * 10 + y <= n) l[w++] = t * 10 + y;\n                r++;\n            }\n            for (r = 0; r < w; r++){\n                if (mp.count(l[r]) == 0){\n                    ans++;\n                    mp[l[r]] = 1;\n                }\n            }\n        }\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","['bitmasks', 'brute force', 'dfs and similar']",1600
https://codeforces.com//contest/1872/problem/A,A. Two Vessels,You have two vessels with water The first vessel contains a grams of water and the second vessel contains b grams of water Both vessels are very large and can hold any amount of water You also have an empty cup that can hold c grams of water In one move you can scoop c grams of water from any vessel and pour it into vessel Note that the mass of water poured in one move What is the minimum number of moves required to make the masses of water in the vessels equal Note that you cannot perform any actions other than the described moves ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        cout << (abs(a-b) + 2*c - 1) / (2*c) << endl;\n    }\n}']","['brute force', 'greedy', 'math']",800
https://codeforces.com//contest/1131/problem/C,C. Birthday,Cowboy Vlad has a birthday today There are n children who came to the celebration In order to greet Vlad the children decided to form a circle around him Among the children who came there are both tall and low so if they stand in a circle arbitrarily it may turn out that there is a tall and low child standing next to each other and it will be difficult for them to hold hands Therefore children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible Formally let s number children from 1 to n in a circle order that is for every i child with number i will stand next to the child with number i 1 also the child with number 1 stands next to the child with number n Then we will call the discomfort of the circle the maximum absolute difference of heights of the children who stand next to each other Please help children to find out how they should reorder themselves so that the resulting discomfort is smallest possible ,"['/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,""r"",stdin);\n#define fpo(x) freopen(x,""w"",stdout);\n#define fprio fpi(""in.txt"");fpo(""out.txt"");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==\' \');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes("""");}\ninline void writei(int x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(""-funsafe-loop-optimizations"")\n#pragma GCC optimize(""-funroll-loops"")\n#pragma GCC optimize(""-fwhole-program"")\n#pragma GCC optimize(""Ofast,no-stack-protector"")\n#pragma GCC optimize(""-fthread-jumps"")\n#pragma GCC optimize(""-falign-functions"")\n#pragma GCC optimize(""-falign-jumps"")\n#pragma GCC optimize(""-falign-loops"")\n#pragma GCC optimize(""-falign-labels"")\n#pragma GCC optimize(""-fcaller-saves"")\n#pragma GCC optimize(""-fcrossjumping"")\n#pragma GCC optimize(""-fcse-follow-jumps"")\n#pragma GCC optimize(""-fcse-skip-blocks"")\n#pragma GCC optimize(""-fdelete-null-pointer-checks"")\n#pragma GCC optimize(""-fdevirtualize"")\n#pragma GCC optimize(""-fexpensive-optimizations"")\n#pragma GCC optimize(""-fgcse"")\n#pragma GCC optimize(""-fgcse-lm"")\n#pragma GCC optimize(""-fhoist-adjacent-loads"")\n#pragma GCC optimize(""-finline-small-functions"")\n#pragma GCC optimize(""-findirect-inlining"")\n#pragma GCC optimize(""-fipa-sra"")\n#pragma GCC optimize(""-foptimize-sibling-calls"")\n#pragma GCC optimize(""-fpartial-inlining"")\n#pragma GCC optimize(""-fpeephole2"")\n#pragma GCC optimize(""-freorder-blocks"")\n#pragma GCC optimize(""-freorder-functions"")\n#pragma GCC optimize(""-frerun-cse-after-loop"")\n#pragma GCC optimize(""-fsched-interblock"")\n#pragma GCC optimize(""-fsched-spec"")\n#pragma GCC optimize(""-fschedule-insns"")\n#pragma GCC optimize(""-fschedule-insns2"")\n#pragma GCC optimize(""-fstrict-aliasing"")\n#pragma GCC optimize(""-fstrict-overflow"")\n#pragma GCC optimize(""-ftree-switch-conversion"")\n#pragma GCC optimize(""-ftree-tail-merge"")\n#pragma GCC optimize(""-ftree-pre"")\n#pragma GCC optimize(""-ftree-vrp"")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<""NO"";return 0;}\n#define YES {cout<<""YES"";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nll n,m,i,j,k,a[100005],b[100005];\nstring st;\nint main()\n{\n\tread(n);\n\trep(i,n) read(a[i]);\n\tsort(a+1,a+n+1);\n\tj=1;k=n;\n\trep(i,n)\n\t{\n\t\tif (i&1) b[j++]=a[i]; else b[k--]=a[i];\n\t}\n\trep(i,n) printf(""%I64d "",b[i]); \n\treturn 0;\n}']","['binary search', 'greedy', 'sortings']",1200
https://codeforces.com//contest/864/problem/B,B. Polycarp and Letters,Polycarp loves lowercase letters and dislikes uppercase ones Once he got a string consisting only of lowercase and uppercase Latin letters Let be a set of positions in the string Let s call it if following conditions are met letters on positions from in the string are all distinct and lowercase there are no uppercase letters in the string which are situated between positions from i e there is no such that is an uppercase letter and for some and from Write a program that will determine the maximum number of elements in a set of positions ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nchar s[1010];\nint c[27];\nint main()\n{\n\tint n;\n\tscanf(""%d%s"",&n,s+1);\n\tint i;\n\tint ans=0;\n\tint j=0;\n\tint k;\n\tfor(i=1;i<=n;i++)\n\t\tif(s[i]>=\'A\'&&s[i]<=\'Z\')\n\t\t{\n\t\t\tmemset(c,0,sizeof c);\n\t\t\tint res=0;\n\t\t\tfor(k=j+1;k<=i-1;k++)\n\t\t\t{\n\t\t\t\tif(!c[s[k]-\'a\'+1])\n\t\t\t\t\tres++;\n\t\t\t\tc[s[k]-\'a\'+1]++;\n\t\t\t}\n\t\t\tans=max(ans,res);\n\t\t\tj=i;\n\t\t}\n\tmemset(c,0,sizeof c);\n\tint res=0;\n\tfor(k=j+1;k<=n;k++)\n\t{\n\t\tif(!c[s[k]-\'a\'+1])\n\t\t\tres++;\n\t\tc[s[k]-\'a\'+1]++;\n\t}\n\tans=max(ans,res);\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","['brute force', 'implementation', 'strings']",1000
https://codeforces.com//contest/91/problem/D,D. Grocer s Problem,Yesterday was a fair in a supermarket s grocery section There were jars with spices on the fair Before the event the jars were numbered from to from the left to the right After the event the jars were moved and the grocer had to sort them by the increasing of the numbers The grocer has a special machine at his disposal The machine can take any or less jars and rearrange them in the way the grocer wants Note that the jars stand consecutively For example from the permutation one can get permutation if pick the jars on the positions and Which minimum number of such operations is needed to arrange all the jars in the order of their numbers increasing ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nvector < pair < vector <int>, vector <int> > > ans, threes, twos;\nint n;\nvector <int> a;\nchar buf[100];\n\npair < vector <int>, vector <int> > merge (pair < vector <int>, vector <int> > a, pair < vector <int>, vector <int> > b) {\n\ta.fs.insert (a.fs.end(), b.fs.begin(), b.fs.end());\n\ta.sc.insert (a.sc.end(), b.sc.begin(), b.sc.end());\n\treturn a;\n}\n\nvoid split (pair < vector <int>, vector <int> > a) {\n\tpair < vector <int>, vector <int> > a1, a2;\n\ta1.fs.pb (a.fs[0]);\n\ta1.fs.pb (a.fs[1]);\n\ta1.sc.pb (a.fs[1]);\n\ta1.sc.pb (a.fs[0]);\n\n\ta2.fs.pb (a.fs[0]);\n\ta2.fs.pb (a.fs[2]);\n\ta2.sc.pb (a.fs[2]);\n\ta2.sc.pb (a.fs[0]);\n\n\ttwos.pb (a2);\n\ttwos.pb (a1);\n}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf (""%d"", &n);\n\ta.resize (n);\n\tforn (i, n)\n\t\tscanf (""%d"", &a[i]);\n\tforn (i, n)\n\t\ta[i] --;\n\tans.clear ();\n\tthrees.clear ();\n\ttwos.clear ();\n\tforn (i, n)\n\t\twhile (a[i] != i) {\n\t\t\tint v = i;\n\t\t\tvector <int> tmp;\n\t\t\ttmp.pb (v);\n\t\t\twhile (I tmp.size() < 5 && a[v] != i) {\n\t\t\t\tv = a[v];\n\t\t\t\ttmp.pb (v);\n\t\t\t}\n\t\t\tvector <int> tmpans;\n\t\t\tforn (i, tmp.size()) \n\t\t\t\ttmpans.pb (tmp[(i+1)%tmp.size()]);\n\t\t\tif (tmp.size() == 2)\n\t\t\t\ttwos.pb (mp (tmp, tmpans));\n\t\t\telse\n\t\t\tif (tmp.size() == 3)\n\t\t\t\tthrees.pb (mp (tmp, tmpans));\n\t\t\telse\n\t\t\t\tans.pb (mp (tmp, tmpans));\n\t\t\tford (i, tmp.size())\n\t\t\t\tif (i)\n\t\t\t\t\tswap (a[tmp[(i+1)%tmp.size()]], a[tmp[i]]);\n\t\t}\n\twhile (threes.size() > 0) {\n\t\tif (twos.size() > 0) {\n\t\t\tans.pb (merge (twos.back(), threes.back()));\n\t\t\ttwos.pop_back();\n\t\t\tthrees.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (threes.size() == 1) {\n\t\t\tans.pb (threes.back());\n\t\t\tthrees.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tsplit (threes.back());\n\t\tthrees.pop_back();\n\t}\n\n\twhile (twos.size() > 0) {\n\t\tif (twos.size() == 1) {\n\t\t\tans.pb (twos.back());\n\t\t\ttwos.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tpair < vector <int>, vector <int> > tmp = twos.back();\n\t\ttwos.pop_back();\n\t\tans.pb (merge (tmp, twos.back()));\n\t\ttwos.pop_back();\n\t}\n\tprintf (""%d\\n"", ans.size());\n\tforn (i, ans.size()) {\n\t\tprintf (""%d\\n"", ans[i].fs.size());\n\t\tforn (j, ans[i].fs.size())\n\t\t\tprintf (""%d "", ans[i].fs[j]+1);\n\t\tprintf (""\\n"");\n\t\tforn (j, ans[i].fs.size())\n\t\t\tprintf (""%d "", ans[i].sc[j]+1);\n\t\tprintf (""\\n"");\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'graphs', 'greedy']",2600
https://codeforces.com//contest/1458/problem/A,A. Row GCD,You are given two positive integer sequences a 1 ldots a n and b 1 ldots b m For each j 1 ldots m find the greatest common divisor of a 1 b j ldots a n b j ,"['/**\n *    author:  tourist\n *    created: 19.12.2020 12:31:44       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  long long g = 0;\n  for (int i = 1; i < n; i++) {\n    g = __gcd(g, abs(a[i] - a[0]));\n  }\n  for (int i = 0; i < m; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << __gcd(g, a[0] + b[i]);\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","['math', 'number theory']",1600
https://codeforces.com//contest/1879/problem/A,A. Rigged ,Monocarp organizes a weightlifting competition There are n athletes participating in the competition the i th athlete has strength s i and endurance e i The 1 st athlete is Monocarp s friend Polycarp and Monocarp really wants Polycarp to win The competition will be conducted as follows The jury will choose a positive integer w which denotes the weight of the barbell that will be used in the competition The goal for each athlete is to lift the barbell as many times as possible The athlete who lifts the barbell the most amount of times will be declared the winner If the barbell s weight w is than the strength of the i th athlete s i then the i th athlete will be unable to lift the barbell even one single time Otherwise the i th athlete will be able to lift the barbell and the number of times he does it will be equal to his endurance e i For example suppose there are 4 athletes with parameters s 1 7 e 1 4 s 2 9 e 2 3 s 3 4 e 3 6 s 4 2 e 4 2 If the weight of the barbell is 5 then the first athlete will be able to lift the barbell 4 times the second athlete will be able to lift the barbell 3 times the third athlete will be unable to lift the barbell the fourth athlete will be unable to lift the barbell Monocarp wants to choose w in such a way that Polycarp the 1 st athlete wins the competition Help him to choose the value of w or report that it is impossible ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    int S[N], E[N]; F0R(i, N) cin >> S[i] >> E[i];\n    FOR(i, 1, N) {\n        if (S[i] >= S[0] && E[i] >= E[0]) {\n            cout << -1 << nl; return;\n        }\n    }\n    cout << S[0] << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']",['greedy'],800
https://codeforces.com//contest/1063/problem/A,A. Oh Those Palindromes,A non empty string is called if it reads the same from the left to the right and from the right to the left For example and are palindromes while and are not A string is called a of another string if it can be obtained from that string by dropping some possibly zero number of characters from the beginning and from the end of it For example and are substrings of the string while and are not Let s define a of the string as the number of its substrings that are palindromes For example the palindromic count of the string is 6 because all its substrings are palindromes and the palindromic count of the string is 3 because only its substrings of length 1 are palindromes You are given a string s You can arbitrarily rearrange its characters You goal is to obtain a string with the maximum possible value of palindromic count ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N;\n  string s;\n  cin >> N >> s;\n\n  sort(ALL(s));\n  cout << s << ""\\n"";\n}\n\n']","['constructive algorithms', 'strings']",1300
https://codeforces.com//contest/1540/problem/B,B. Tree Array,You are given a tree consisting of n nodes You generate an array from the tree by marking nodes one by one Initially when no nodes are marked a node is equiprobably chosen and marked from the entire tree After that until all nodes are marked a node is equiprobably chosen and marked from the set of unmarked nodes with at least one edge to a marked node It can be shown that the process marks all nodes in the tree The final array a is the list of the nodes labels in order of the time each node was marked Find the expected number of inversions in the array that is generated by the tree and the aforementioned process The number of inversions in an array a is the number of pairs of indices i j such that i j and a i a j For example the array 4 1 3 2 contains 4 inversions 1 2 1 3 1 4 3 4 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\ntemplate<class E>\nvc<E> get_tree_path(const vvc<E>&t,int a,int b){\n\tvc<E> res;\n\tauto rec=[&](auto self,int v,int p)->bool{\n\t\tif(v==b)return true;\n\t\tfor(auto e:t[v])if(e!=p){\n\t\t\tres.pb(e);\n\t\t\tif(self(self,e,v))return true;\n\t\t\tres.pop_back();\n\t\t}\n\t\treturn false;\n\t};\n\trec(rec,a,-1);\n\treturn res;\n}\n\nconst int nmax=205;\n\nmint dp[nmax][nmax];\n\nvoid slv(){\n\tconst mint inv2=mint(2).inv();\n\trep(i,nmax)dp[i][0]=0;\n\trep(i,nmax)dp[0][i]=1;\n\trng(i,1,nmax)rng(j,1,nmax){\n\t\tdp[i][j]=(dp[i-1][j]+dp[i][j-1])*inv2;\n\t}\n\t\n\tint n;cin>>n;\n\tauto t=readTree(n);\n\t\n\tauto getsub=[&](auto self,int v,int p)->int{\n\t\tint res=1;\n\t\tfor(auto to:t[v])if(to!=p)\n\t\t\tres+=self(self,to,v);\n\t\treturn res;\n\t};\n\t\n\tmint ans;\n\t\n\trep(a,n)rep(b,a){\n\t\tauto p=get_tree_path(t,a,b);\n\t\tp.insert(p.bg,a);\n\t\tvc<bool> z(n);\n\t\tfor(auto v:p)z[v]=true;\n\t\trep(i,si(p)){\n\t\t\tint v=p[i];\n\t\t\tint sum=1;\n\t\t\tfor(auto to:t[v])if(!z[to]){\n\t\t\t\tsum+=getsub(getsub,to,v);\n\t\t\t}\n\t\t\tans+=dp[i][si(p)-1-i]*sum;\n\t\t}\n\t}\n\t\n\tprint(ans/n);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['brute force', 'combinatorics', 'dp', 'graphs', 'math', 'probabilities', 'trees']",2300
https://codeforces.com//contest/18/problem/B,B. Platforms,In one one dimensional world there are platforms Platform with index platforms are numbered from 1 is a segment with coordinates and Grasshopper Bob starts to jump along the platforms from point with each jump he moves exactly units right Find out the coordinate of the point where Bob will fall down The grasshopper falls down if he finds himself not on the platform but if he finds himself on the edge of the platform he doesn t fall down ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""h""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n    lld n, d, m, l;\n    cin >> n >> d >> m >> l;\n    lld k=0, x=0;\n    for (lld i=0; ;) {\n        lld t=(l-x)/d;\n        i+=t;\n        x+=t*d;\n        k+=x/m;\n        x%=m;\n        if (k>=n || x>l) {\n            cout << i*d << endl;\n            return 0;\n        }\n        t=1;\n        i+=t;\n        x+=t*d;\n        k+=x/m;\n        x%=m;\n        if (k>=n || x>l) {\n            cout << i*d << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}']","['brute force', 'math']",1700
https://codeforces.com//contest/22/problem/D,D. Segments,You are given segments on the Ox axis You can drive a nail in any integer point on the Ox axis line nail so that all segments containing this point are considered nailed down If the nail passes through endpoint of some segment this segment is considered to be nailed too What is the smallest number of nails needed to nail all the segments down ,"['#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nbool cmp(pair <int, int> a, pair <int, int> b){\n    if(a.first<b.first){\n        return true;\n    }else{\n        if(a.first==b.first){\n            return a.second<b.second;\n        }\n        return false;\n    }\n}\n\n\nint main(){\n\n    int n;\n    pair <int, int> a[1013];\n    cin>>n;\n    for(int i=0; i<n; i++){\n        cin>>a[i].first>>a[i].second;\n        if(a[i].first>a[i].second) swap(a[i].first,a[i].second);\n    }\n    sort(a,a+n,cmp);\n    int m=0;\n    queue <int> q;\n    int f=0;\n    pair<int ,int> t;\n    while(f<n){\n        t=a[f];\n        int p=f;\n        bool fl=false;\n        while(p<n && max(t.first,a[p].first)<=min(t.second,a[p].second)){\n            t.first=max(t.first,a[p].first);\n            t.second=min(t.second,a[p].second);\n            fl=true;\n            p++;\n        }\n        q.push(t.first);\n        if(!fl) p++;\n        f=p;\n    }\n    cout<<q.size()<<endl;\n    while(!q.empty()){\n        cout<<q.front()<<"" "";\n        q.pop();\n    }\n    return 0;\n}']","['greedy', 'sortings']",1900
https://codeforces.com//contest/1593/problem/A,A. Elections,The elections in which three candidates participated have recently ended The first candidate received a votes the second one received b votes the third one received c votes For each candidate solve the following problem how many votes should be added to this candidate so that he wins the election i e the number of votes for this candidate was strictly greater than the number of votes for any other candidate Please note that for each candidate it is necessary to solve this problem i e the added votes for any candidate affect the calculations when getting the answer for the other two candidates ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n    ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int test;\n    cin >> test;\n    while(test --) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        cout << max(0, max(b, c) + 1 - a ) << ' '  << max(0, max(a, c) + 1 - b) << ' ' << max(0, max(a, b) + 1 - c) << '\\n';\n    }\n    return 0;\n}""]",['math'],800
https://codeforces.com//contest/1931/problem/B,B. Make Equal,There are n containers of water lined up numbered from left to right from 1 to n Each container can hold any amount of water initially the i th container contains a i units of water The sum of a i is divisible by n You can apply the following operation any possibly zero number of times pour any amount of water from the i th container to the j th container where i must be than j i e i j Any index can be chosen as i or j any number of times Determine whether it is possible to make the amount of water in all containers the same using this operation ,"['// Problem: B. Make Equal\n// Contest: Codeforces - Codeforces Round 925 (Div. 3)\n// URL: https://codeforces.com/contest/1931/problem/B\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n; cin >> n;\n\tll sum = 0;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> a[i], sum += a[i];\n\tll cur = 0;\n\tsum /= n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] + cur < sum) {\n\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\treturn;\n\t\t}\n\t\tcur = a[i] + cur - sum;\n\t}\n\tcout << ""YES"" << \'\\n\';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}']",['greedy'],800
https://codeforces.com//contest/533/problem/B,B. Work Group,One Big Software Company has employees numbered from to The director is assigned number Every employee of the company except the director has exactly one immediate superior The director of course doesn t have a superior We will call person a subordinates of another person if either is an immediate supervisor of or the immediate supervisor of is a subordinate to person In particular subordinates of the head are all other employees of the company To solve achieve an Important Goal we need to form a workgroup Every person has some efficiency expressed by a positive integer where is the person s number The efficiency of the workgroup is defined as the total efficiency of all the people included in it The employees of the big software company are obsessed with modern ways of work process organization Today pair programming is at the peak of popularity so the workgroup should be formed with the following condition Each person entering the workgroup should be able to sort all of his subordinates who are also in the workgroup into pairs In other words for each of the members of the workgroup the number of his subordinates within the workgroup should be even Your task is to determine the maximum possible efficiency of the workgroup formed at observing the given condition Any person including the director of company can enter the workgroup ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PI;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 210001\nint n;\nint c[MAX];\nLL w1[MAX],w2[MAX];\nvector<int> d[MAX];\nPI dfs(int nr){\n  PI res = MP(0ll,(LL)-1e18);\n  R(i,d[nr].size()){\n    PI pom = dfs(d[nr][i]);\n    res = MP(\n      max(pom.FI + res.FI,pom.SE+res.SE),\n      max(pom.FI + res.SE,pom.SE+res.FI)\n    );\n  }\n  MA(res.SE,res.FI + c[nr]);\n  return res;\n}\nmain(){\n  make(n);\n  R(i,n){\n    int a;\n    make2(a,c[i]);\n    if(a != -1){\n      a--;\n      d[a].PB(i);\n    }\n  }\n  PI wyn = dfs(0);\n  printf(""%lld\\n"",max(wyn.FI,wyn.SE));\n}']","['dfs and similar', 'dp', 'graphs', 'strings', 'trees']",2000
https://codeforces.com//contest/1712/problem/B,B. Woeful Permutation,Effluvium of the MindYou are given a positive integer n Find any permutation p of length n such that the sum operatorname lcm 1 p 1 operatorname lcm 2 p 2 ldots operatorname lcm n p n is as large as possible Here operatorname lcm x y denotes the least common multiple LCM of integers x and y A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define int long long\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n\nint T,n,ans,i,j,k,a[N]; \nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tif(n&1){\n\t\t\tcout<<1<<"" "";\n\t\t\tfor(i=2;i<=n;i+=2){\n\t\t\t\tcout<<i+1<<"" ""<<i<<"" "";\n\t\t\t}\n\t\t\tcout<<""\\n"";\n\t\t}\n\t\telse {\n\t\t\tfor(i=1;i<=n;i+=2){\n\t\t\t\tcout<<i+1<<"" ""<<i<<"" "";\n\t\t\t}\n\t\t\tcout<<""\\n"";\n\t\t}\n\t}\n}']","['constructive algorithms', 'greedy', 'number theory']",800
https://codeforces.com//contest/1649/problem/B,B. Game of Ball Passing,Daniel is watching a football team playing a game during their training session They want to improve their passing skills during that session The game involves n players making multiple passes towards each other Unfortunately since the balls were moving too fast after the session Daniel is unable to know how many balls were involved during the game The only thing he knows is the number of passes delivered by each player during all the session Find the minimum possible amount of balls that were involved in the game ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#ifndef ONLINE_JUDGE\n#include ""debug.h""\n#else\n#define deb(...) 4\n#endif\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>v(n);\n\t\tfor(int i=0;i<n;i++) cin>>v[i];\n\t\tint sm=0;\n\t\tfor(auto x:v) sm+=x;\n\t\tif(sm==0){\n\t\t\tcout<<""0\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tint mx=*max_element(v.begin(),v.end());\n\t\tcout<<1+max(0LL,mx-sm+mx-1)<<\'\\n\';\n\t}\n\treturn 0;\n}']","['greedy', 'implementation']",1300
https://codeforces.com//contest/1872/problem/F,F. Selling a Menagerie,You are the owner of a menagerie consisting of n animals numbered from 1 to n However maintaining the menagerie is quite expensive so you have decided to sell it It is known that each animal is afraid of exactly one other animal More precisely animal i is afraid of animal a i a i neq i Also the cost of each animal is known for animal i it is equal to c i You will sell all your animals in some fixed order Formally you will need to choose some permutation dagger p 1 p 2 ldots p n and sell animal p 1 first then animal p 2 and so on selling animal p n last When you sell animal i there are two possible outcomes If animal a i was sold animal i you receive c i money for selling animal i If animal a i was sold animal i you receive 2 cdot c i money for selling animal i Surprisingly animals that are currently afraid are more valuable Your task is to choose the order of selling the animals in order to maximize the total profit For example if a 3 4 4 1 3 c 3 4 5 6 7 and the permutation you choose is 4 2 5 1 3 then The first animal to be sold is animal 4 Animal a 4 1 was not sold before so you receive 2 cdot c 4 12 money for selling it The second animal to be sold is animal 2 Animal a 2 4 was sold before so you receive c 2 4 money for selling it The third animal to be sold is animal 5 Animal a 5 3 was not sold before so you receive 2 cdot c 5 14 money for selling it The fourth animal to be sold is animal 1 Animal a 1 3 was not sold before so you receive 2 cdot c 1 6 money for selling it The fifth animal to be sold is animal 3 Animal a 3 4 was sold before so you receive c 3 5 money for selling it Your total profit with this choice of permutation is 12 4 14 6 5 41 Note that 41 is the maximum possible profit in this example dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in any order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but 4 is present in the array ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        vll a(n);\n        for (ll& x : a) cin >> x, x--;\n        vll c(n);\n        for (ll& x : c) cin >> x;\n        vll deg(n);\n        for (ll x : a) deg[x]++;\n        vll ans;\n        vll vis(n);\n        stack<ll> deg0;\n        for (ll i = 0; i < n; i++) if (!deg[i]) deg0.push(i);\n        while (!deg0.empty()) {\n            ll v = deg0.top(); deg0.pop();\n            vis[v] = 1;\n            ans.push_back(v);\n            if (!--deg[a[v]]) deg0.push(a[v]);\n        }\n        for (ll i = 0; i < n; i++) {\n            if (!vis[i]) {\n                vll cycle;\n                ll mincost = 1e18;\n                ll mincostind = 0;\n                ll j = i;\n                do {\n                    cycle.push_back(j);\n                    if (c[j] < mincost) {\n                        mincost = c[j];\n                        mincostind = cycle.size();\n                    }\n                    vis[j] = 1;\n                    j = a[j];\n                } while (j != i);\n                for (ll k = 0; k < cycle.size(); k++) {\n                    ans.push_back(cycle[mincostind++ % cycle.size()]);\n                }\n            }\n        }\n        for (ll v : ans) cout << v+1 << ' ';\n        cout << '\\n';\n    }\n}""]","['dfs and similar', 'dsu', 'graphs', 'implementation', 'math']",1800
https://codeforces.com//contest/1204/problem/A,A. BowWow and the Timetable,In the city of Saint Petersburg a day lasts for 2 100 minutes From the main station of Saint Petersburg a train departs after 1 minute 4 minutes 16 minutes and so on in other words the train departs at time 4 k for each integer k geq 0 Team BowWow has arrived at the station at the time s and it is trying to count how many trains have they missed in other words the number of trains that have departed time s For example if s 20 then they missed trains which have departed at 1 4 and 16 As you are the only one who knows the time help them Note that the number s will be given you in a binary representation without leading zeroes ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\nint sum;\n\nint main(){\n    cin >> s;\n    for(int i=0; i<(int)s.size(); i++) sum += s[i] - \'0\';\n    if(sum == 0) printf(""0"");\n    else if(sum == 1) printf(""%d"", s.size()/2);\n    else printf(""%d"", (s.size()+1)/2);\n}\n']",['math'],1000
https://codeforces.com//contest/1682/problem/D,D. Circular Spanning Tree,There are n nodes arranged in a circle numbered from 1 to n in the clockwise order You are also given a binary string s of length n Your task is to construct a tree on the given n nodes satisfying the two conditions below or report that there such tree does not exist For each node i 1 le i le n the degree of node is even if s i 0 and odd if s i 1 No two edges of the tree intersect internally in the circle The edges are allowed to intersect on the circumference Note that all edges are drawn as straight line segments For example edge u v in the tree is drawn as a line segment connecting u and v on the circle A tree on n nodes is a connected graph with n 1 edges ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nchar s[200005];\nint ansu[200005],ansv[200005],tmp;\nint js[200005],cnt;\nbool vis[200005];\nint main()\n{\n\tint t,n,ans=0,ans1=0,tsl,las;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tscanf(""%s"",s+1);\n\t\ttsl=0;\n\t\tfor(int i=1;i<=n;i++)if(s[i]==\'1\')tsl++;\n\t\tif(tsl==0||tsl%2==1)\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(""YES\\n"");\n\t\ttmp=0;\n\t\tcnt=0;\n\t\tlas=0;\n\t\tfor(int i=1;i<=n;i++)vis[i]=false;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'0\'&&las!=0)\n\t\t\t{\n\t\t\t\tansu[++tmp]=i;\n\t\t\t\tvis[i]=true;\n\t\t\t\tansv[tmp]=las;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t\tif(s[i]==\'1\')\n\t\t\t{\n\t\t\t\tif(las!=0)js[++cnt]=las;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'0\'&&vis[i]==false)\n\t\t\t{\n\t\t\t\tansu[++tmp]=i;\n\t\t\t\tansv[tmp]=las;\n\t\t\t\tvis[i]=true;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t\tif(s[i]==\'1\')break;\n\t\t}\n\t\tjs[++cnt]=las;\n\t\t//printf(""!!!%d\\n"",cnt);\n\t\tfor(int i=2;i<=cnt;i++)\n\t\t{\n\t\t\tansu[++tmp]=js[1];\n\t\t\tansv[tmp]=js[i];\n\t\t}\n\t\tfor(int i=1;i<=tmp;i++)printf(""%d %d\\n"",ansu[i],ansv[i]);\n\t}\n\treturn 0;\n} ']","['constructive algorithms', 'implementation', 'trees']",2000
https://codeforces.com//contest/1806/problem/B,B. Mex Master,You are given an array a of length n The of a is the MEX dagger of a 1 a 2 a 2 a 3 ldots a n 1 a n Find the minimum score of a if you are allowed to rearrange elements of a in any order Note that you are to construct the array a that achieves the minimum score dagger The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"[""// Problem: B. Mex Master\n// Contest: Codeforces - Codeforces Round 858 (Div. 2)\n// URL: https://codeforces.com/contest/1806/problem/B\n// Memory Limit: 1024 MB\n// Time Limit: 1000 ms\n\n#include<bits/stdc++.h>\n#define poly vector<int>\n#define IOS ios::sync_with_stdio(false)\n#define ll long long\n#define mp make_pair\n#define mt make_tuple\n#define pa pair < int,int >\n#define fi first\n#define se second\n#define inf 1e18\n#define mod 998244353\n#define int ll\n// #define N \nusing namespace std;\nvoid BellaKira()\n{\n\tint n;\n\tcin>>n;\n\tint x=0,y=0,z=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint o=0;\n\t\tcin>>o;\n\t\tif (o==0) x++;\n\t\telse if (o==1) y++;\n\t\telse z++;\n\t}\n\tif (y+z>=x-1)\n\t{\n\t\tcout<<0<<'\\n';\n\t\treturn;\n\t}\n\tif (z)\n\t{\n\t\tcout<<1<<'\\n';\n\t\treturn;\n\t}\n\tif (!y) cout<<1<<'\\n';\n\telse\n\t\tcout<<2<<'\\n';\n}\nsigned main()\n{\n\tIOS;cin.tie(0); \n\tint T=1;\n\tcin>>T;\n\twhile (T--)\n\t{\n\t\tBellaKira();\n\t}\n}\n""]","['constructive algorithms', 'greedy']",900
https://codeforces.com//contest/1924/problem/B,B. Space Harbour,There are n points numbered 1 to n on a straight line Initially there are m harbours The i th harbour is at point X i and has a value V i There is exactly one ship on each of the n points The cost of moving a ship from its current location to the next harbour is the product of the value of the nearest harbour to its left and the distance from the nearest harbour to its right Specifically if a ship is already at a harbour the cost of moving it to the next harbour is 0 Additionally there are q queries each of which is either of the following 2 types 1 x v Add a harbour at point x with value v It is guaranteed that before adding the harbour there is no harbour at point x 2 l r Print the sum of the cost of moving all ships at points from l to r to their next harbours ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree() : n(0) {}\n    LazySegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    LazySegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        tag.assign(4 << std::__lg(n), Tag());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nstruct Tag {\n    i64 k = 0;\n    i64 b = 0;\n    \n    void apply(const Tag &t) {\n        if (t.k < 0) {\n            k = t.k;\n            b = t.b;\n        }\n    }\n};\n\nstruct Info {\n    i64 cnt = 0;\n    i64 sid = 0;\n    i64 sum = 0;\n    \n    void apply(const Tag &t) {\n        if (t.k < 0) {\n            sum = sid * t.k + cnt * t.b;\n        }\n    }\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    return {a.cnt + b.cnt, a.sid + b.sid, a.sum + b.sum};\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<int> X(m), V(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> X[i];\n        X[i]--;\n    }\n    for (int i = 0; i < m; i++) {\n        std::cin >> V[i];\n    }\n    \n    std::map<int, int> s;\n    for (int i = 0; i < m; i++) {\n        s[X[i]] = V[i];\n    }\n    \n    LazySegmentTree<Info, Tag> seg(n);\n    for (int i = 0; i < n; i++) {\n        seg.modify(i, {1, i, 0});\n    }\n    auto work = [&](auto it) {\n        auto nxt = std::next(it);\n        seg.rangeApply(it->first + 1, nxt->first + 1, {-it->second, 1LL * it->second * nxt->first});\n    };\n    for (auto it = s.begin(); it->first != n - 1; it++) {\n        work(it);\n    }\n    \n    while (q--) {\n        int t, x, y;\n        std::cin >> t >> x >> y;\n        \n        if (t == 1) {\n            x--;\n            s[x] = y;\n            auto it = s.find(x);\n            work(it);\n            work(std::prev(it));\n        } else {\n            x--;\n            i64 ans = seg.rangeQuery(x, y).sum;\n            std::cout << ans << ""\\n"";\n        }\n    }\n    \n    return 0;\n}']","['data structures', 'implementation', 'math', 'sortings']",2100
https://codeforces.com//contest/1208/problem/H,H. Red Blue Tree,You are given a tree of n nodes The tree is rooted at node 1 which is not considered as a leaf regardless of its degree Each leaf of the tree has one of the two colors or Leaf node v initially has color s v The color of each of the internal nodes including the root is determined as follows Let b be the number of immediate children and r be the number of immediate children of a given vertex Then the color of this vertex is if and only if b r ge k otherwise Integer k is a parameter that is same for all the nodes You need to handle the following types of queries print the color of node v change the color of leaf v to c c 0 means red c 1 means blue update the current value of k to h ,"['/**\n *    author:  tourist\n *    created: 25.08.2019 18:50:27       \n**/\n#pragma GCC optimize(""Ofast"", ""unroll-loops"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int N = 100010;\n\nint from_leaves[N];\nint from_others[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> color(n);\n  for (int i = 0; i < n; i++) {\n    cin >> color[i];\n  }\n  vector<int> order;\n  vector<int> pos(n, -1);\n  vector<int> endd(n, -1);\n  vector<bool> is_leaf(n, false);\n  vector<int> map_to(n);\n  vector<int> deg(n);\n  vector<int> parent(n, -1);\n  iota(map_to.begin(), map_to.end(), 0);\n  function<void(int, int)> Dfs = [&](int v, int pv) {\n    parent[v] = pv;\n    deg[v] = (int) g[v].size() - (pv != -1);\n    if (pv != -1 && deg[v] == 1 && deg[pv] == 1) {\n      map_to[v] = map_to[pv];\n      for (int u : g[v]) {\n        if (u == pv) {\n          continue;\n        }\n        Dfs(u, v);\n      }\n      return;\n    }\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    for (int u : g[v]) {\n      if (u == pv) {\n        continue;\n      }\n      Dfs(u, v);\n    }\n    endd[v] = (int) order.size() - 1;\n    if (deg[v] == 0) {\n      is_leaf[v] = true;\n      order.pop_back();\n      pos[v] = endd[v] = -1;\n    }\n  };\n  Dfs(0, -1);\n  int cnt = (int) order.size();\n  memset(from_leaves, 0, sizeof(int) * cnt);\n  memset(from_others, 0, sizeof(int) * cnt);\n  for (int i = 0; i < n; i++) {\n    if (is_leaf[i]) {\n      from_leaves[pos[map_to[parent[i]]]] += (color[i] == 1 ? 1 : -1);\n    }\n  }\n  vector<int> go_to(cnt);\n  for (int i = 1; i < cnt; i++) {\n    go_to[i] = pos[map_to[parent[order[i]]]];\n  }\n  int tt;\n  cin >> tt;\n  vector<int> op(tt), ver(tt), val(tt), res(tt, -1);\n  for (int i = 0; i < tt; i++) {\n    cin >> op[i];\n    if (op[i] == 1) {\n      cin >> ver[i];\n      --ver[i];\n    }\n    if (op[i] == 2) {\n      cin >> ver[i] >> val[i];\n      --ver[i];\n    }\n    if (op[i] == 3) {\n      cin >> val[i];\n    }\n  }\n  map<int, int> mp;\n  int beg = 0;\n  while (beg < tt) {\n    int end = beg;\n    while (end + 1 < tt && op[end + 1] == op[end]) {\n      ++end;\n    }\n    if (op[beg] == 1) {\n      mp.clear();\n      for (int i = beg; i <= end; i++) {\n        int v = ver[i];\n        if (!is_leaf[v]) {\n          v = map_to[v];\n          from_others[pos[v]] = 0;\n          mp[pos[v] + 1] += 1;\n          mp[endd[v] + 1] -= 1;\n        }\n      }\n      vector<pair<int, int>> segs;\n      int balance = 0;\n      int start = -1;\n      for (auto& p : mp) {\n        if (p.second == 0) {\n          continue;\n        }\n        if (balance == 0) {\n          start = p.first;\n        }\n        balance += p.second;\n        if (balance == 0) {\n          segs.emplace_back(start, p.first - 1);\n          start = -1;\n        }\n      }\n      for (auto& p : segs) {\n        int from = p.first;\n        int to = p.second;\n        memset(from_others + from, 0, sizeof(int) * (to - from + 1));\n        for (int i = to; i >= from; i--) {\n          from_others[go_to[i]] += (from_others[i] + from_leaves[i] >= k ? 1 : -1);\n        }\n      }\n      for (int i = beg; i <= end; i++) {\n        int v = ver[i];\n        if (is_leaf[v]) {\n          res[i] = color[v];\n        } else {\n          v = map_to[v];\n          res[i] = (from_others[pos[v]] + from_leaves[pos[v]] >= k);\n        }\n      }\n    }\n    if (op[beg] == 2) {\n      for (int i = beg; i <= end; i++) {\n        int v = ver[i];\n        from_leaves[pos[map_to[parent[v]]]] -= (color[v] == 1 ? 1 : -1);\n        color[v] = val[i];\n        from_leaves[pos[map_to[parent[v]]]] += (color[v] == 1 ? 1 : -1);\n      }\n    }\n    if (op[beg] == 3) {\n      k = val[end];\n    }\n    beg = end + 1;\n  }\n  for (int i = 0; i < tt; i++) {\n    if (op[i] == 1) {\n      cout << res[i] << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","['data structures', 'implementation', 'trees']",3500
https://codeforces.com//contest/274/problem/A,A. k-Multiple Free Set,A multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by That is there are no two integers and from the set such that You re given a set of distinct positive integers Your task is to find the size of it s largest multiple free subset ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nset <int> bad;\nint a[100010];\n\nint main(void){\n    int N,K,i;\n    \n    cin >> N >> K;\n    REP(i,N) scanf(""%d"", &a[i]);\n    sort(a, a+N);\n    \n    int ans = 0;\n    for(i=N-1;i>=0;i--){\n        if(bad.find(a[i]) == bad.end()){\n            ans++;\n            if(a[i] % K == 0) bad.insert(a[i] / K);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']","['binary search', 'greedy', 'sortings']",1500
https://codeforces.com//contest/1478/problem/C,C. Nezzar and Symmetric Array,Long time ago there was a symmetric array a 1 a 2 ldots a 2n consisting of 2n Array a 1 a 2 ldots a 2n is called symmetric if for each integer 1 le i le 2n there exists an integer 1 le j le 2n such that a i a j For each integer 1 le i le 2n Nezzar wrote down an integer d i equal to the sum of absolute differences from a i to all integers in a i e d i sum j 1 2n a i a j Now a million years has passed and Nezzar can barely remember the array d and totally forget a Nezzar wonders if there exists any symmetric array a consisting of 2n distinct integers that generates the array d ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 200100\n\ntypedef long long ll;\n\nint n;\nll a[N], d[N];\n\nint main() {\n    int T;\n    scanf(""%d"", &T);\n    while (T --) {\n\t\tscanf(""%d"", &n);\n\t\tfor (int i = 0; i < 2 * n; i ++) scanf(""%lld"", &d[i]);\n\t\tsort(d, d + 2 * n);\n\t\tbool ok = true; d[2*n] = a[n] = 0;\n\t\tfor (int i = n - 1; i >= 0; i --) {\n\t\t\tif (d[2*i] != d[2*i+1]) ok = false;\n\t\t\tll del = d[2*i+2] - d[2*i];\n\t\t\tif (del == 0 || del % (2 * (i + 1)) != 0) ok = false;\n\t\t\ta[i] = a[i+1] - del / (2 * (i + 1));\n\t\t}\n\t\tif (ok && a[0] > 0) puts(""YES"");\n\t\telse puts(""NO"");\n    }\n\n    return 0;\n}\n']","['implementation', 'math', 'sortings']",1700
https://codeforces.com//contest/418/problem/B,B. Cunning Gena,A boy named Gena really wants to get to the Russian Code Cup finals or at least get a t shirt But the offered problems are too complex so he made an arrangement with his friends that they will solve the problems for him The participants are offered problems on the contest For each friend Gena knows what problems he can solve But Gena s friends won t agree to help Gena for nothing the th friend asks Gena rubles for his help he can Also the friend agreed to write a code for Gena only if Gena s computer is connected to at least monitors each monitor costs rubles Gena is careful with money so he wants to spend as little money as possible to solve all the problems Help Gena tell him how to spend the smallest possible amount of money Initially there s no monitors connected to Gena s computer ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst long long inf = (long long)4e18;\n\nconst int N = 12345;\nconst int T = (1 << 21);\n\nint x[N], k[N], mask[N];\nlong long f[T];\n\nint main() {\n  int n, m, b;\n  scanf(""%d %d %d"", &n, &m, &b);\n  for (int i = 0; i < n; i++) {\n    int foo;\n    scanf(""%d %d %d"", x + i, k + i, &foo);\n    mask[i] = 0;\n    while (foo--) {\n      int bar;\n      scanf(""%d"", &bar);\n      mask[i] |= (1 << (bar - 1));\n    }\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++)\n      if (k[i] > k[j]) {\n        swap(x[i], x[j]);\n        swap(k[i], k[j]);\n        swap(mask[i], mask[j]);\n      }\n  for (int i = 0; i < (1 << m); i++) f[i] = inf;\n  f[0] = 0;\n  long long ans = inf;\n  for (int i = 0; i < n; i++) {\n    for (int t = 0; t < (1 << m); t++)\n      if (f[t] + x[i] < f[t | mask[i]]) {\n        f[t | mask[i]] = f[t] + x[i];\n      }\n    long long cur = f[(1 << m) - 1];\n    cur += 1LL * k[i] * b;\n    if (cur < ans) ans = cur;\n  }\n  cout << (ans == inf ? -1 : ans) << endl;\n  return 0;\n}\n']","['bitmasks', 'dp', 'sortings']",1900
https://codeforces.com//contest/1909/problem/D,D. Split Plus K,There are n positive integers a 1 a 2 dots a n on a blackboard You are also given a positive integer k You can perform the following operation some possibly 0 times choose a number x on the blackboard erase one occurrence of x write two integers y z such that y z x k on the blackboard Is it possible to make all the numbers on the blackboard equal If yes what is the minimum number of operations you need ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi a=readvi(n,-k);\n\tif(a==vi(n,0))return print(0);\n\tsoin(a);\n\t\n\tif(0<a[0]){\n\t\t\n\t}else if(a[n-1]<0){\n\t\t\n\t}else{\n\t\treturn print(-1);\n\t}\n\tint g=0;\n\tfor(auto v:a)g=gcd(g,v);\n\tint ans=0;\n\tfor(auto v:a){\n\t\tans+=abs(v/g);\n\t}\n\tprint(ans-n);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['greedy', 'math', 'number theory']",1900
https://codeforces.com//contest/1804/problem/F,F. Approximate Diameter,Jack has a graph of n vertices and m edges All edges are bidirectional and of unit length The graph is connected i e there exists a path between any two of its vertices There can be more than one edge connecting the same pair of vertices The graph can contain self loops i e edges connecting a node to itself The distance between vertices u and v is denoted as rho u v and equals the minimum possible number of edges on a path between u and v The diameter of graph G is defined as the maximum possible distance between some pair of its vertices We denote it as d G In other words d G max 1 le u v le n rho u v Jack plans to consecutively apply q updates to his graph Each update adds exactly one edge to the graph Denote as G i the graph after exactly i updates are made Jack wants to calculate q 1 values d G 0 d G 1 d G 2 ldots d G q However Jack suspects that finding the exact diameters of q 1 graphs might be a difficult task so he is fine with approximate answers that differ from the correct answers no more than twice Formally Jack wants to find a sequence of positive integers a 0 a 1 a 2 ldots a q such that left lceil frac d G i 2 right rceil le a i le 2 cdot d G i for each i You cannot make hacks in this problem ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].emplace_back(v, 0);\n        adj[v].emplace_back(u, 0);\n    }\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].emplace_back(v, i + 1);\n        adj[v].emplace_back(u, i + 1);\n    }\n    \n    auto get = [&](int t) {\n        std::queue<int> q;\n        std::vector<int> dis(n, -1);\n        q.push(0);\n        dis[0] = 0;\n        while (!q.empty()) {\n            int x = q.front();\n            q.pop();\n            for (auto [y, w] : adj[x]) {\n                if (w <= t && dis[y] == -1) {\n                    dis[y] = dis[x] + 1;\n                    q.push(y);\n                }\n            }\n        }\n        return *std::max_element(dis.begin(), dis.end());\n    };\n    \n    std::vector<int> ans(q + 1);\n    for (int i = 0; i < q + 1; ) {\n        int val = get(i);\n        int lo = i + 1, hi = q + 1;\n        while (lo < hi) {\n            int x = (lo + hi) / 2;\n            if (2 * get(x) < val) {\n                hi = x;\n            } else {\n                lo = x + 1;\n            }\n        }\n        while (i < lo) {\n            ans[i] = val;\n            i += 1;\n        }\n    }\n    for (int i = 0; i <= q; i++) {\n        std::cout << ans[i] << "" \\n""[i == q];\n    }\n    \n    return 0;\n}\n']","['binary search', 'divide and conquer', 'graphs', 'shortest paths']",2700
https://codeforces.com//contest/1027/problem/G,G. X-mouse in the Campus,The campus has m rooms numbered from 0 to m 1 Also the x mouse lives in the campus The x mouse is not just a mouse each second x mouse moves from room i to the room i cdot x mod m in fact it teleports from one room to another since it doesn t visit any intermediate room Starting position of the x mouse is unknown You are responsible to catch the x mouse in the campus so you are guessing about minimum possible number of traps one trap in one room you need to place You are sure that if the x mouse enters a trapped room it immediately gets caught And the only observation you made is text GCD x m 1 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define mp make_pair\n\nconst ll B = (ll)1e4;\nll mult(ll x, ll y, ll mod) {\n\tif (y == 0) return 0;\n\treturn (mult(x, y / B, mod) * B + x * (y % B)) % mod;\n}\nll bin_pow(ll x, ll p, ll mod) {\n\tif (p == 0) return 1 % mod;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1, mod), mod);\n\treturn bin_pow(mult(x, x, mod), p / 2, mod);\n}\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nll lcm(ll x, ll y) {\n\treturn x * (y / gcd(x, y));\n}\n\nconst int N = 50;\nint n;\nll P[N][2];\nll a[N][N][2];\n\nvector<pll> factorize(ll m) {\n\tvector<pll> res;\n\tfor (ll y = 2; y * y <= m; y++) {\n\t\tif (m % y) continue;\n\t\tres.push_back(mp(y, 0LL));\n\t\twhile(m % y == 0) {\n\t\t\tres.back().second++;\n\t\t\tm /= y;\n\t\t}\n\t\tn++;\n\t}\n\tif (m > 1) {\n\t\tres.push_back(mp(m, 1LL));\n\t}\n\treturn res;\n}\n\nll ans;\nvoid brute(int pos, ll PP, ll Q) {\n//\teprintf(""brute %d %lld %lld\\n"", pos, PP, Q);\n\tif (pos == n) {\n\t\tans += PP / Q;\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= P[pos][1]; i++) {\n\t\tbrute(pos + 1, PP * a[pos][i][0], lcm(Q, a[pos][i][1]));\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tll m, x;\n\tcin >> m >> x;\n\n\tvector<pll> q = factorize(m);\n\tn = (int)q.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP[i][0] = q[i].first;\n\t\tP[i][1] = q[i].second;\n\t}\n\n//\teprintf(""%d\\n"", n);\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(""%lld %lld\\n"", P[i][0], P[i][1]);\n//\treturn 0;\n\n\tans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tll mod = 1;\n\t\tq = factorize(P[i][0] - 1);\n\t\tfor (int pw = 0; pw <= P[i][1]; pw++) {\n\t\t\tif (pw == 0) {\n\t\t\t\ta[i][pw][0] = a[i][pw][1] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmod *= P[i][0];\n\t\t\tll cur = mod - mod / P[i][0];\n\t\t\tfor (int j = 0; j < (int)q.size(); j++) {\n\t\t\t\tfor (int k = 0; k < q[j].second; k++) {\n\t\t\t\t\tll ncur = cur / q[j].first;\n\t\t\t\t\tif (bin_pow(x, ncur, mod) != 1) break;\n\t\t\t\t\tcur = ncur;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < pw - 1; k++) {\n\t\t\t\tll ncur = cur / P[i][0];\n\t\t\t\tif (bin_pow(x, ncur, mod) != 1) break;\n\t\t\t\tcur = ncur;\n\t\t\t}\n\t\t\ta[i][pw][0] = mod - mod / P[i][0];\n\t\t\ta[i][pw][1] = cur;\n\t\t}\n\t}\n\tbrute(0, 1, 1);\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['bitmasks', 'math', 'number theory']",2600
https://codeforces.com//contest/346/problem/A,A. Alice and Bob,It is so boring in the summer holiday isn t it So Alice and Bob have invented a new game to play The rules are as follows First they get a set of distinct integers And then they take turns to make the following moves During each move either Alice or Bob the player whose turn is the current can choose two distinct integers and from the set such that the set doesn t contain their absolute difference Then this player adds integer to the set so the size of the set increases by one If the current player has no valid move he or she loses the game The question is who will finally win the game if both players play optimally Remember that Alice always moves first ,"['#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n//#pragma comment(linker,""/STACK:102400000,102400000"")\n\nlong long gcd(long long a, long long b)\n{\n\tif(a == 0 || b == 0)return a + b;\n\treturn gcd(b, a % b);\n}\n\nint MAIN()\n{\n\tvector <int> xs;\n\tint n;\n\tint g = 0;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint t;\n\t\tcin >> t;\n\t\tg = gcd(g, t);\n\t\txs.push_back(t);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\txs[i] /= g;\n\tsort(xs.begin(), xs.end());\n\tif((xs[xs.size()-1]-xs.size()) % 2 == 0)\n\t\tcout << ""Bob"" << endl;\n\telse\n\t\tcout << ""Alice"" << endl;\n\n\t\n\treturn 0;\n}\n\nint main()\n{\n\t#ifdef LOCAL_TEST\n\t\tfreopen(""in.txt"", ""r"", stdin);\n\t\tfreopen(""out.txt"", ""w"", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\treturn MAIN();\n}\n']","['games', 'math', 'number theory']",1600
https://codeforces.com//contest/814/problem/E,E. An unavoidable detour for home,Those unwilling to return home from a long journey will be affected by the oddity of the snail and lose their way Mayoi the oddity s carrier wouldn t like this to happen but there s nothing to do with this before a cure is figured out For now she would only like to know the enormous number of possibilities to be faced with if someone gets lost There are towns in the region numbered from to The town numbered is called the capital The traffic network is formed by bidirectional roads connecting pairs of towns No two roads connect the same pair of towns and no road connects a town with itself The time needed to travel through each of the roads is the same Lost travelers will not be able to find out how the towns are connected but the residents can help them by providing the following facts Starting from each town other than the capital the shortest path i e the path passing through the minimum number of roads to the capital exists and is unique Let be the number of roads on the shortest path from town to the capital then holds for all For town the number of roads connected to it is denoted by which equals either or You are to count the number of different ways in which the towns are connected and give the answer modulo Two ways of connecting towns are considered different if a pair exists such there is a road between towns and in one of them but not in the other ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nll md(ll x){\n    return x % mod;\n}\n\nint n;\n\nint d[maxn];\n\nll sq[55][55][55][55];\n\nll q[55][55];\n\nll bpow(ll x, ll y){\n    if (y == 0)\n        return 1;\n    if (y == 1)\n        return x;\n    ll ret = bpow(x, y >> 1);\n    ret = md(ret * ret);\n    if (y & 1)\n        ret = md(ret * x);\n    return ret;\n}\n\nll bdiv(ll x, ll y){\n    return md(x * bpow(y, mod - 2));\n}\n\nll fact[55];\n\nvoid prefact(){\n    fact[0] = 1;\n    for (ll i = 1; i <= n; i++)\n        fact[i] = md(fact[i - 1] * i);\n}\n\nvoid presq(){\n    for (int l = 1; l < n; l++){\n        if (d[l] == 3)\n            sq[l][l][2][1] = 1;\n        else\n            sq[l][l][1][0] = 1;\n        for (int r = l; r < n - 1; r++)\n            for (int k = 0; k <= (r - l + 1) * 2; k++)\n                for (int db = 0; db <= r - l + 1; db++)\n                if (sq[l][r][k][db] != 0){\n                    ll val = sq[l][r][k][db];\n                    if (d[r + 1] == 2){\n                        sq[l][r + 1][k + 1][db] = md(sq[l][r + 1][k + 1][db] + val);\n                        if (db > 0)\n                            sq[l][r + 1][k - 1][db - 1] = md(sq[l][r + 1][k - 1][db - 1] + val * db);\n                        if (k - 2 * db > 0)\n                            sq[l][r + 1][k - 1][db] = md(sq[l][r + 1][k - 1][db] + val * (k - 2 * db));\n                    }\n                    else{\n                        sq[l][r + 1][k + 2][db + 1] = md(sq[l][r + 1][k + 2][db + 1] + val);\n                        if (db > 0)\n                            sq[l][r + 1][k][db - 1] = md(sq[l][r + 1][k][db - 1] + val * db);\n                        if (k - 2 * db > 0)\n                            sq[l][r + 1][k][db] = md(sq[l][r + 1][k][db] + val * (k - 2 * db));\n                        if (k - 2 * db > 1)\n                            sq[l][r + 1][k - 2][db] = md(sq[l][r + 1][k - 2][db] + val * (k - 2 * db) * (k - 2 * db - 1) / 2);\n                        if (k - 2 * db > 0 && db > 0)\n                            sq[l][r + 1][k - 2][db - 1] = md(sq[l][r + 1][k - 2][db - 1] + val * (k - 2 * db) * db);\n                        if (db > 1)\n                            sq[l][r + 1][k - 2][db - 2] = md(sq[l][r + 1][k - 2][db - 2] + val * db * (db - 1) / 2);\n                    }\n                }\n    }\n}\n\nvoid preq(){\n    if (d[0] == 2)\n        q[1][2] = 1;\n    else\n        q[1][3] = 1;\n    for (int r = 2; r < n; r++)\n        for (int l = 1; l <= r; l++)\n        if (q[l][r] > 0)\n            for (int k = 0; k <= (r - l + 1) * 2; k++)\n                for (int db = 0; db <= r - l + 1; db++)\n                    if (r + k < n)\n                        q[r + 1][r + k] = md(q[r + 1][r + k] + bdiv(md(md(q[l][r] * sq[l][r][k][db]) * fact[k]), bpow(2, db)));\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> d[i];\n    if (d[0] == 3 && n == 3){\n        cout << 0;\n        return 0;\n    }\n    prefact();\n    presq();\n    preq();\n    ll answer = 0;\n    for (int l = 1; l < n; l++)\n        answer = md(answer + q[l][n - 1] * sq[l][n - 1][0][0]);\n    cout << answer;\n}\n']","['combinatorics', 'dp', 'graphs', 'shortest paths']",2600
https://codeforces.com//contest/1213/problem/B,B. Bad Prices,Polycarp analyzes the prices of the new berPhone At his disposal are the prices for n last days a 1 a 2 dots a n where a i is the price of berPhone on the day i Polycarp considers the price on the day i to be bad if later that is a day with a greater number berPhone was sold at a lower price For example if n 6 and a 3 9 4 6 7 5 then the number of days with a bad price is 3 these are days 2 a 2 9 4 a 4 6 and 5 a 5 7 Print the number of days with a bad price You have to answer t independent data sets ,"['#include ""bits/stdc++.h""\nusing namespace std;\n// #define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint a[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        fr(i, 1, n) {\n            cin >> a[i];\n        }\n        int mini = 1e9, ans = 0;\n        for(int i = n; i >= 1; i--) {\n            if(a[i] > mini) ans++;\n            mini = min(mini, a[i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}']","['data structures', 'implementation']",1100
https://codeforces.com//contest/1934/problem/A,A. Too Min Too Max,Given an array a of n elements find the maximum value of the expression a i a j a j a k a k a l a l a i where i j k and l are four indices of the array a with 1 le i j k l le n Here x denotes the absolute value of x ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    IOS;\n\n    int T; cin >> T;\n    while(T--){\n        int N; cin >> N;\n        vi A(N); for(int& i : A) cin >> i;\n        sort(A.begin(), A.end());\n        int ans = abs(A[0] - A[N - 1]) + abs(A[N - 1] - A[1]) + abs(A[1] - A[N - 2]) + abs(A[N - 2] - A[0]);\n        cout << ans << endl;\n    } \n\n}""]","['greedy', 'math']",800
https://codeforces.com//contest/677/problem/A,A. Vanya and Fence,Vanya and his friends are walking along the fence of height and they do not want the guard to notice them In order to achieve this the height of each of the friends should not exceed If the height of some person is greater than he can bend down and then he surely won t be noticed by the guard The height of the th person is equal to Consider the width of the person walking as usual to be equal to while the width of the bent person is equal to Friends want to talk to each other while walking so they would like to walk in a single row What is the minimum width of the road such that friends can walk in a row and remain unattended by the guard ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,h,x,ans;\n\nint main()\n{\n    cin>>n>>h;\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>x;\n        if(x>h)\n            ans++;\n        ans++;\n    }\n    cout<<ans<<""\\n"";\n}\n']",['implementation'],800
https://codeforces.com//contest/1260/problem/C,C. Infinite Fence,You are a rebel leader and you are planning to start a revolution in your country But the evil Government found out about your plans and set your punishment in the form of correctional labor You must paint a fence which consists of 10 100 planks in two colors in the following way suppose planks are numbered from left to right from 0 if the index of the plank is divisible by r such planks have indices 0 r 2r and so on then you must paint it red if the index of the plank is divisible by b such planks have indices 0 b 2b and so on then you must paint it blue if the index is divisible both by r and b to paint the plank otherwise you don t need to paint the plank at all and it is forbidden to spent paint on it Furthermore the Government added one additional restriction to make your punishment worse Let s list all planks of the fence in ascending order if there are k consecutive planks with the same color in this list then the Government will state that you failed the labor and execute you immediately If you don t paint the fence according to the four aforementioned conditions you will also be executed The question is will you be able to accomplish the labor the time is not important or the execution is unavoidable and you need to escape at all costs ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    for (int tc = 1; tc <= t; tc++) {\n        int a, b, k;\n        scanf(""%d %d %d"", &a, &b, &k);\n        int g = __gcd(a, b);\n        a /= g;\n        b /= g;\n        if (a > b) swap(a, b);\n        if ((b - 1 + a - 1) / a >= k) printf(""REBEL\\n"");\n        else printf(""OBEY\\n"");\n    }\n}']","['greedy', 'math', 'number theory']",1700
https://codeforces.com//contest/785/problem/E,E. Anton and Permutation,Anton likes permutations especially he likes to permute their elements Note that a permutation of elements is a sequence of numbers in which every number from to appears exactly once One day Anton got a new permutation and started to play with it He does the following operation times he takes two elements of the permutation and swaps these elements After each operation he asks his friend Vanya how many inversions there are in the new permutation The number of inversions in a permutation is the number of distinct pairs such that and Vanya is tired of answering Anton s silly questions So he asked you to write a program that would answer these questions instead of him Initially Anton s permutation was that is for all such that ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#define bel(i) ((i)>>10)\n#define lbt(i) ((i)&-(i))\nusing namespace std;\ntypedef long long LL;\nint n,q;\nconst int MX=200011,B=1024;\nint cnt[MX/B+2][MX],cntblk[MX/B+2][MX],a[MX];\ninline void add(int *c,int *s,int x,int d){\n\tfor(int i=x;bel(i)==bel(x)&&i<=n;i++)c[i]+=d;\n\tfor(int i=bel(x);i<=bel(n);i++)s[i]+=d;\n}\ninline int que(int *c,int *s,int x){\n\treturn bel(x)?s[bel(x)-1]+c[x]:c[x];\n}\nLL ans=0LL;\ninline int rd(){\n\tint x=0;char ch=getchar();\n\twhile(ch>\'9\'||ch<\'0\')ch=getchar();\n\twhile(ch>=\'0\'&&ch<=\'9\')x=x*10+ch-\'0\',ch=getchar();\n\treturn x;\n}\nint main(){\n\tn=rd(),q=rd();\n\tfor(int i=1;i<=n;i++)a[i]=i;\n\tfor(int i=1;i<=n;i++)add(cnt[bel(i)],cntblk[bel(i)],a[i],1);\n\tfor(int i=1;i<=q;i++){\n\t\tint l=rd(),r=rd();\n\t\tif(l==r)goto E;\n\t\tif(l>r)swap(l,r);\n\t\tif(a[l]<a[r]){\n\t\t\tans++;\n\t\t\tif(bel(l+1)==bel(r-1))for(int j=l+1;j<r;j++)ans+=2*(a[j]>a[l]&&a[j]<a[r]);\n\t\t\telse {\n\t\t\t\tfor(int j=l+1;bel(j)==bel(l+1);j++)ans+=2*(a[j]>a[l]&&a[j]<a[r]);\n\t\t\t\tfor(int j=r-1;bel(j)==bel(r-1);j--)ans+=2*(a[j]>a[l]&&a[j]<a[r]);\n\t\t\t\tfor(int j=bel(l+1)+1;j<bel(r-1);j++)ans+=2*(que(cnt[j],cntblk[j],a[r])-que(cnt[j],cntblk[j],a[l]));\n\t\t\t}\n\t\t}else{\n\t\t\tans--;\n\t\t\tif(bel(l+1)==bel(r-1))for(int j=l+1;j<r;j++)ans-=2*(a[j]>a[r]&&a[j]<a[l]);\n\t\t\telse {\n\t\t\t\tfor(int j=l+1;bel(j)==bel(l+1);j++)ans-=2*(a[j]>a[r]&&a[j]<a[l]);\n\t\t\t\tfor(int j=r-1;bel(j)==bel(r-1);j--)ans-=2*(a[j]>a[r]&&a[j]<a[l]);\n\t\t\t\tfor(int j=bel(l+1)+1;j<bel(r-1);j++)ans-=2*(que(cnt[j],cntblk[j],a[l])-que(cnt[j],cntblk[j],a[r]));\n\t\t\t}\n\t\t}\n\t\tadd(cnt[bel(l)],cntblk[bel(l)],a[l],-1);\n\t\tadd(cnt[bel(r)],cntblk[bel(r)],a[r],-1);\n\t\tswap(a[l],a[r]);\n\t\tadd(cnt[bel(l)],cntblk[bel(l)],a[l],1);\n\t\tadd(cnt[bel(r)],cntblk[bel(r)],a[r],1);\nE:\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}']","['brute force', 'data structures']",2200
https://codeforces.com//contest/1314/problem/B,B. Double Elimination,The biggest event of the year Cota 2 world championship The Innernational is right around the corner 2 n teams will compete in a double elimination format please carefully read problem statement even if you know what is it to identify the champion Teams are numbered from 1 to 2 n and will play games one on one All teams start in the upper bracket All upper bracket matches will be held played between teams that haven t lost any games yet Teams are split into games by team numbers Game winner advances in the next round of upper bracket losers drop into the lower bracket Lower bracket starts with 2 n 1 teams that lost the first upper bracket game Each lower bracket round consists of two games In the first game of a round 2 k teams play a game with each other teams are split into games by team numbers 2 k 1 loosing teams are eliminated from the championship 2 k 1 winning teams are playing 2 k 1 teams that got eliminated in this round of upper bracket again teams are split into games by team numbers As a result of each round both upper and lower bracket have 2 k 1 teams remaining See example notes for better understanding Single remaining team of upper bracket plays with single remaining team of lower bracket in grand finals to identify championship winner You are a fan of teams with numbers a 1 a 2 a k You want the championship to have as many games with your favourite teams as possible Luckily you can affect results of every championship game the way you want What s maximal possible number of championship games that include teams you re fan of ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bool> a(1 << n);\n  while (m--) {\n    int x;\n    cin >> x;\n    a[--x] = true;\n  }\n  vector<vector<int>> dp(1 << (n + 1), vector<int>(4, -1));\n  auto merge = [&](int x, int l, int r) {\n    for (int i = 0; i < 4; ++i) {\n      if (dp[l][i] == -1) {\n        continue;\n      }\n      for (int j = 0; j < 4; ++j) {\n        if (dp[r][j] == -1) {\n          continue;\n        }\n        int w1 = i / 2, w2 = j / 2;\n        int l1 = i % 2, l2 = j % 2;\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n        swap(w1, w2);\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n      }\n    }\n  };\n  function<void(int, int, int)> solve = [&](int x, int l, int r) {\n    if (r - l == 2) {\n      if (!a[l] && !a[l + 1]) {\n        dp[x][0] = 0;\n      } else if (a[l] && a[l + 1]) {\n        dp[x][3] = 1;\n      } else {\n        dp[x][1] = dp[x][2] = 1;\n      }\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l) << 1);\n      solve(x + 1, l, y);\n      solve(z, y, r);\n      merge(x, x + 1, z);\n    }\n  };\n  solve(0, 0, 1 << n);\n  cout << max(dp[0][0], max(dp[0][1] + 1, max(dp[0][2] + 1, dp[0][3] + 1))) << ""\\n"";\n  return 0;\n}\n']","['dp', 'implementation']",2500
https://codeforces.com//contest/821/problem/C,C. Okabe and Boxes,Okabe and Super Hacker Daru are stacking and removing boxes There are boxes numbered from to Initially there are no boxes on the stack Okabe being a control freak gives Daru commands of which are to add a box to the top of the stack and of which are to remove a box from the top of the stack and throw it in the trash Okabe wants Daru to throw away the boxes in the order from to Of course this means that it might be impossible for Daru to perform some of Okabe s commands because the required box is not on the top of the stack That s why Daru can decide to wait until Okabe looks away and then reorder the boxes in the stack in any way he wants He can do it at any point of time between Okabe s commands but he can t add or remove boxes while he does it Tell Daru the minimum number of times he needs to reorder the boxes so that he can successfully complete all of Okabe s commands It is guaranteed that every box is added before it is required to be removed ,"['#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 300010\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') ch = getchar();\n\twhile (ch >= \'0\' && ch <= \'9\')\n\t\tx = x * 10 + ch - \'0\', ch = getchar();\n}\nchar s[20];\nint n, sta[maxn], top, x, k, ans;\nint main() {\n\tgn(n);\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tscanf(""%s"", s + 1);\n\t\tif (s[1] == \'a\') {\n\t\t\tscanf(""%d"", &x);\n\t\t\tsta[++top] = x; \n\t\t} else {\n\t\t\t++k;\n\t\t\tif (top && sta[top] == k) {\n\t\t\t\t--top;\n\t\t\t} else {\n\t\t\t\tif (!top) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\t++ans; top = 0; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n\n\n']","['data structures', 'greedy', 'trees']",1500
https://codeforces.com//contest/256/problem/D,D. Liars and Serge,There are people sitting in a line at the table For each person we know that he always tells either the truth or lies Little Serge asked them how many of you always tell the truth Each of the people at the table knows everything who is an honest person and who is a liar about all the people at the table The honest people are going to say the correct answer the liars are going to say any integer from 1 to which is not the correct answer Every liar chooses his answer regardless of the other liars so two distinct liars may give distinct answer Serge does not know any information about the people besides their answers to his question He took a piece of paper and wrote integers where is the answer of the th person in the row Given this sequence Serge determined that exactly people sitting at the table Serge wonders how many variants of people s answers sequences of answers of length there are where one can say that exactly people sitting at the table apparently lie As there can be rather many described variants of answers count the remainder of dividing the number of the variants by ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nconst int MOD = 777777777;\n\ntypedef long long int64;\n\nstruct Int {\n\tint x;\n\tInt() :\n\t\t\tx(0) {\n\t}\n\tInt(int _x) :\n\t\t\tx(_x) {\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t}\n\tInt(int64 _x) {\n\t\tx = _x % MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t}\n\tstatic Int get(int x) {\n\t\tInt a;\n\t\ta.x = x;\n\t\treturn a;\n\t}\n\n\tInt operator+(const Int&o) const {\n\t\tint t = x + o.x;\n\t\tif (t >= MOD)\n\t\t\tt -= MOD;\n\t\treturn get(t);\n\t}\n\tInt operator*(const Int&o) const {\n\t\treturn get(1LL * x * o.x % MOD);\n\t}\n\tInt operator-(const Int&o) const {\n\t\tint t = x - o.x;\n\t\tif (t < 0)\n\t\t\tt += MOD;\n\t\treturn get(t);\n\t}\n\tInt operator/(const Int&o) const {\n\t\treturn (*this) * o.inv();\n\t}\n\tInt&operator+=(const Int&o) {\n\t\treturn (*this) = *this + o;\n\t}\n\tInt&operator-=(const Int&o) {\n\t\treturn (*this) = *this - o;\n\t}\n\tInt&operator*=(const Int&o) {\n\t\treturn (*this) = *this * o;\n\t}\n\tInt&operator/=(const Int&o) {\n\t\treturn (*this) = *this / o;\n\t}\n\n\tInt power(int64 n) const {\n\t\tif (!n)\n\t\t\treturn get(1);\n\t\tconst Int&a = *this;\n\t\tif (n & 1)\n\t\t\treturn power(n - 1) * a;\n\t\telse\n\t\t\treturn (a * a).power(n >> 1);\n\t}\n\n\tInt inv() const {\n\t\treturn power(MOD - 2);\n\t}\n};\nconst int MAX_N = 300;\nInt comb[MAX_N][MAX_N];\nint n, k;\nInt dp[MAX_N][MAX_N][MAX_N];\nint a[10][300] = { { 0 }, { 2, 1 }, { 32, 30, 80, 109 }, { 6824, 59808, 147224, 415870, 1757896, 1897056, 4898872, 7593125 }, { 776830421, 290516100, 746623577, 293783147, 33900006, 735127505,\n\t\t565460332, 428982705, 472062098, 161873957, 117354594, 515619293, 578944191, 312106242, 569389279, 391464593 }, { 261086313, 584837659, 683961846, 468868529, 211593382, 736955478, 229471758,\n\t\t157617135, 398169441, 360252438, 629394768, 264125799, 647490480, 342079395, 391579767, 225200475, 486011304, 513156108, 628771752, 132906648, 142138221, 20119449, 444199674, 195188679,\n\t\t387329805, 44684703, 651912135, 737154512, 612549793, 519860281, 186175544, 212568440 }, { 240805271, 239509872, 581127897, 6511239, 156126222, 509425833, 672407328, 366667722, 459185405,\n\t\t509737025, 554790222, 165216555, 703150560, 74806569, 398730015, 383350905, 506108358, 51326142, 298053147, 104256117, 391428765, 374020479, 206607807, 87664059, 275899176, 56407680,\n\t\t551553401, 448939463, 582889860, 129676638, 226078251, 135769095, 61292868, 578972226, 190181628, 390739055, 184587732, 446575689, 732674124, 232198470, 676760679, 352474101, 611444862,\n\t\t575661807, 628905585, 320813094, 522840969, 469781928, 156006018, 554473341, 239654268, 643714911, 433540170, 199307003, 496385218, 291740751, 67309914, 370826673, 202356819, 279421821,\n\t\t421203111, 63744786, 520987612, 550671827 }, { 482164403, 768209115, 462063756, 154906374, 36099042, 341766705, 678182556, 621882744, 478771358, 231881111, 175889805, 243630450, 168908523,\n\t\t671961765, 55761813, 652682670, 773939082, 517628076, 756201264, 124604900, 750976272, 498253248, 676047609, 137170026, 705610017, 495032139, 561797418, 703097347, 500815609, 95984586,\n\t\t739707108, 265613565, 387099846, 777331779, 594676173, 591219559, 407997044, 208947235, 93337440, 478908360, 685013007, 487033953, 671903001, 39521181, 738490312, 33785059, 465470131,\n\t\t310453920, 54648783, 346831137, 427694175, 474743430, 705296781, 435828036, 429824745, 663532359, 261388683, 244690731, 533997135, 596108961, 506813013, 371892402, 590145264, 104733162,\n\t\t143420103, 654339672, 700348950, 685038942, 578826927, 286484229, 501639192, 434962491, 299270097, 27702486, 335375775, 111746817, 565603164, 294926121, 676063665, 735862995, 710035809,\n\t\t437011960, 668528077, 138765186, 508213986, 615036450, 353784942, 624827616, 343900011, 241289776, 52410890, 72018835, 352406796, 415705878, 4802637, 376367145, 65589678, 333633477, 341834527,\n\t\t303717460, 282387700, 42951006, 254706039, 423048528, 526429710, 68131467, 669954708, 12787348, 500636381, 317959019, 479433192, 657133515, 416259390, 610216692, 340129188, 44594256,\n\t\t257373347, 138718678, 530767740, 292922628, 37220268, 605295159, 480722613, 458170419, 30540300, 487159055, 232966794, 149150650 }, { 412133651, 386543325, 139952108, 289303402, 102404925,\n\t\t317067177, 396414708, 80515854, 663739304, 317300809, 228877044, 493725043, 715317967, 490300965, 315527373, 743539734, 488329191, 553627998, 533025234, 242583957, 706116537, 614109258,\n\t\t645447222, 523195911, 492109128, 722623041, 111085128, 766395126, 654378921, 691964847, 496688157, 399056049, 654363234, 102052314, 191720088, 473910948, 259736526, 332840025, 388047555,\n\t\t665791056, 627111387, 139696515, 441456687, 443032569, 283264821, 771641703, 452641455, 511306362, 117572859, 127701891, 721298331, 176520078, 357242229, 611296308, 696994956, 405628839,\n\t\t429224274, 465336054, 695091546, 689828796, 574648641, 351220905, 507964023, 675326610, 517248963, 453528621, 220301928, 494463186, 681789969, 339589656, 44524053, 417125457, 339589404,\n\t\t747135963, 341780733, 734158215, 396817281, 21997836, 5728464, 147611205, 456248898, 714128667, 377654949, 3862068, 128418948, 589390074, 304947090, 11703825, 228266073, 127304142, 429215724,\n\t\t361541124, 521572968, 468358191, 341231688, 65323503, 613778508, 15985323, 291661029, 410970006, 591638112, 349541550, 89967528, 224922159, 361094166, 584206074, 640051812, 324264456,\n\t\t652625388, 693768537, 11740617, 309238398, 211085469, 194905872, 639416484, 110110707, 296645895, 748118511, 131177718, 511142751, 775975599, 421403409, 475528473, 434685258, 1768977,\n\t\t80301375, 708023862, 569195676, 56238084, 632887668, 88089750, 631539342, 396695565, 38780154, 695798271, 469819224, 439587099, 69045921, 682966116, 112310856, 64943298, 534475872, 40215357,\n\t\t389728458, 286368453, 736006257, 501181650, 54829908, 603489402, 338032656, 512182818, 627500097, 462674016, 3103092, 157324491, 43978329, 596818971, 259025598, 9088632, 91991781, 577291428,\n\t\t211245489, 429471231, 142626330, 172560633, 510907446, 444609585, 758102058, 375112647, 744786693, 276174402, 19259856, 233672418, 745389414, 225772848, 23385663, 324290610, 519804558,\n\t\t120337812, 402578568, 360676008, 450089262, 551043738, 337388940, 512108856, 28879011, 690040638, 106017282, 558262341, 99972432, 608226003, 612152037, 42414435, 776201013, 39580443,\n\t\t518796945, 494437752, 583194366, 723936555, 415359657, 309569589, 751104774, 166684527, 249229170, 353120823, 130668327, 753823584, 580966092, 561963717, 543672234, 393846327, 586278000,\n\t\t327398400, 278403867, 156455586, 363920382, 190245195, 290039148, 547014447, 466218648, 146037150, 585462906, 666008595, 691786683, 374707494, 622498779, 231158277, 685740951, 115612245,\n\t\t681825249, 545555745, 551718468, 277206615, 640171035, 757727334, 195193908, 658656684, 457760646, 225925875, 505761984, 18685233, 506832921, 112511021, 396846646, 290147622, 113924623,\n\t\t669986155, 336008070, 63611061, 238586775, 119956662, 616557739, 772784623, 334527774, 410403148, 51933421 } };\nvoid makeTable() {\n\tcout << ""int a[10][300]={"";\n\tfor (n = 1; n <= 256; n <<= 1) {\n\t\tcout << ""{"";\n\t\tmemset(comb, 0, sizeof comb);\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tcomb[i][j] = (!i || !j) ? 1 : comb[i - 1][j] + comb[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof dp);\n\n\t\tdp[1][0][0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\t\tInt c = dp[i][j][k];\n\t\t\t\t\tif (c.x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int l = 0; j + l <= n; ++l) {\n\t\t\t\t\t\tint nk = k + ((l != i) ? l : 0);\n\t\t\t\t\t\tdp[i + 1][j + l][nk] += c * comb[n - j][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcout << dp[n + 1][n][i].x;\n\t\t\tif (i + 1 <= n)\n\t\t\t\tcout << "","";\n\t\t}\n\t\tcout << ""},"";\n\t}\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tint pw = 0;\n\twhile ((1 << pw) < n)\n\t\t++pw;\n\tcout << a[pw][k - 1] << endl;\n\treturn 0;\n}\n']",['dp'],2700
https://codeforces.com//contest/32/problem/B,B. Borze,Ternary numeric notation is quite popular in Berland To telegraph the ternary number the Borze alphabet is used Digit 0 is transmitted as 1 as and 2 as You are to decode the Borze code i e to find out the ternary number given its representation in Borze alphabet ,"['#include <cstdio>\n#include <string>\nusing namespace std;\n\nint p = 0;\nchar s[300];\nstring str;\n\nvoid main() {\n\tgets(s);\n\tstr = s;\n\tfor(str = s; p != str.size(); ++p) {\n\t\tif(p == str.find(""--"", p)) {\n\t\t\tputchar(\'2\');\n\t\t\t++p;\n\t\t} else if(p == str.find(""-."", p)) {\n\t\t\tputchar(\'1\');\n\t\t\t++p;\n\t\t} else {\n\t\t\tputchar(\'0\');\n\t\t}\n\t}\n}']","['expression parsing', 'implementation']",800
https://codeforces.com//contest/1732/problem/D2,D2. Balance  Hard version ,Initially you have a set containing one element 0 You need to handle q queries of the following types x add the integer x to the set It is guaranteed that this integer is not contained in the set x remove the integer x from the set It is guaranteed that this integer is contained in the set k find the k text mex of the set In our problem we define the k text mex of a set of integers as the smallest non negative integer x that is divisible by k and which is not contained in the set ,"['#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c==\'-\')f=-1;\n\t\tfor(;c<\'0\'||c>\'9\';c=gc())if(c==\'-\')f=-1;\n\t\tfor(;c>=\'0\'&&c<=\'9\';c=gc())\n\t\t\tx=x*10+(c-\'0\');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c=\'\\n\'){\n\t\tif(x<0)pc(\'-\'),x=-x;\n\t\tif(x==0) pc(\'0\'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+\'0\';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint q,cnt,cnt2;\nmap<LL,int>H,id,H2,H3,H4;\nset<LL>S[200005],S2[200005];\nset<LL>::iterator it;\nsigned main(){\n\tsrand(time(0));\n\tgi(q);\n\twhile(q--){\n\t\tchar s[4];\n\t\tLL x;\n\t\tLL k;\n\t\tscanf(""%s"",s+1);\n\t\tif(s[1]==\'+\'){\n\t\t\tgi(x);\n\t\t\tbool fl=0;\n\t\t\tif(!H3[x])H3[x]=++cnt,fl=1;\n\t\t\tint id=H3[x];\n\t\t\tH2[x]=1;\n\t\t\tif(!fl){\n\t\t\t\tfor(it=S[id].begin();it!=S[id].end();++it){\n\t\t\t\t\tLL k=(*it);\n\t\t\t\t\tint id2=H4[k];\n\t\t\t\t\tS2[id2].erase(x/k);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}else if(s[1]==\'-\'){\n\t\t\tgi(x);\n\t\t\tif(!H3[x])H3[x]=++cnt;\n\t\t\tint id=H3[x];\n\t\t\tH2[x]=0;\n\t\t\tfor(it=S[id].begin();it!=S[id].end();++it){\n\t\t\t\tLL k=(*it);\n\t\t\t\tint id2=H4[k];\n\t\t\t\tS2[id2].insert(x/k);\n\t\t\t}\n\t\t}else{\n\t\t\tgi(k);\n\t\t\tif(!H4[k])H4[k]=++cnt2;\n\t\t\tif(H.find(k)==H.end())H[k]=1;\n\t\t\tint now=H[k],id2=H4[k];\n\t\t\tif(S2[id2].size()){\n\t\t\t\tnow=*S2[id2].begin();\n\t\t\t\tpi(1ll*now*k,\'\\n\');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(H2[1ll*now*k]){\n\t\t\t\tS[H3[1ll*now*k]].insert(k);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tH[k]=now;\n\t\t\tpi(1ll*now*k,\'\\n\');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/']","['brute force', 'data structures', 'number theory']",2400
https://codeforces.com//contest/834/problem/B,B. The Festive Evening,It s the end of July the time when a festive evening is held at Jelly Castle Guests from all over the kingdom gather here to discuss new trends in the world of confectionery Yet some of the things discussed here are not supposed to be disclosed to the general public the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands So it s a necessity to not let any uninvited guests in There are 26 entrances in Jelly Castle enumerated with uppercase English letters from to Because of security measures each guest is known to be assigned an entrance he should enter the castle through The door of each entrance is opened right before the first guest s arrival and closed right after the arrival of the last guest that should enter the castle through this entrance No two guests can enter the castle simultaneously For an entrance to be protected from possible intrusion a candy guard should be assigned to it There are such guards in the castle so if there are more than opened doors one of them is going to be left unguarded Notice that a guard can t leave his post until the door he is assigned to is closed Slastyona had a suspicion that there could be uninvited guests at the evening She knows the order in which the invited guests entered the castle and wants you to help her check whether there was a moment when more than doors were opened ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n#define fir first\n#define sec second\n\nint n, k;\nchar a[1000006];\nint s[1000006];\nint L[128];\nint R[128];\n\nint main() {\n\tcin >> n >> k;\n\tscanf(""%s"", a);\n\t\n\tfor (int i = 0; i < 128; ++i) {\n\t\tL[i] = INT_MAX;\n\t\tR[i] = INT_MIN;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tL[a[i]] = min(L[a[i]], i);\n\t\tR[a[i]] = max(R[a[i]], i);\n\t}\n\t\n\tfor (int i = 0; i < 128; ++i) if (L[i] != INT_MAX)\n\t\tfor (int j = L[i]; j <= R[i]; ++j)\n\t\t\t++s[j];\n\t\n\tputs(*max_element(s, s + n) <= k ? ""NO"" : ""YES"");\n\t\n\treturn 0;\n}\n']","['data structures', 'implementation']",1100
https://codeforces.com//contest/915/problem/E,E. Physical Education Lessons,This year Alex has finished school and now he is a first year student of Berland State University For him it was a total surprise that even though he studies programming he still has to attend physical education lessons The end of the term is very soon but unfortunately Alex still hasn t attended a single lesson Since Alex doesn t want to get expelled he wants to know the number of working days left until the end of the term so he can attend physical education lessons during these days But in BSU calculating the number of working days is a complicated matter There are days left before the end of the term numbered from to and initially all of them are working days Then the university staff sequentially publishes orders one after another Each order is characterised by three numbers and If then all days from to inclusive become non working days If some of these days are made working days by some previous order then these days still become non working days If then all days from to inclusive become working days If some of these days are made non working days by some previous order then these days still become working days Help Alex to determine the number of working days left after each order ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>working;\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n, q; cin >> n >> q;\n\tworking[-1] = -1;\n\tworking[2E9] = 2E9;\n\tworking[1] = n;\n\tint answer = n;\n\twhile (q--) {\n\t\tint l, r, k; cin >> l >> r >> k;\n\t\tint haveNow = 0;\n\t\tmap<int, int>::iterator it = working.lower_bound(l);\n\t\tit--;\n\t\tif (it->second >= l) {\n\t\t\tworking[l] = it->second;\n\t\t\tit->second = l-1;\n\t\t}\n\t\tit++;\n\t\twhile (it->first <= r) {\n\t\t\tif (it->second > r) {\n\t\t\t\thaveNow += r + 1 - it->first;\n\t\t\t\tworking[r + 1] = it->second;\n\n\t\t\t}\n\t\t\telse\n\t\t\t\thaveNow += it->second - it->first + 1;\n\t\t\tmap<int, int>::iterator it2 = it;\n\t\t\tit++;\n\t\t\tworking.erase(it2);\n\t\t}\n\t\tif (k == 1) {\n\t\t\tanswer -= haveNow;\n\t\t}\n\t\telse {\n\t\t\tanswer -= haveNow;\n\t\t\tworking[l] = r;\n\t\t\tanswer += r - l + 1;\n\t\t}\n\t\tcout << answer << ""\\n"";\n\t}\n\n\treturn 0;\n}']","['data structures', 'implementation', 'sortings']",2300
https://codeforces.com//contest/1853/problem/A,A. Desorting,Call an array a of length n if a 1 leq a 2 leq ldots leq a n 1 leq a n Ntarsis has an array a of length n He is allowed to perform one type of operation on it zero or more times Choose an index i 1 leq i leq n 1 Add 1 to a 1 a 2 ldots a i Subtract 1 from a i 1 a i 2 ldots a n The values of a can be negative after an operation Determine the minimum operations needed to make a ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 550;\nint a[maxN];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint T;\n\tfor (cin >> T; T; T--) {\n\t\tint n; cin >> n;\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\t\tint mn = 1e9;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (a[i] < a[i - 1]) mn = 0;\n\t\t\telse mn = min(mn, (a[i] - a[i - 1]) / 2 + 1);\n\t\t}\n\t\tcout << mn << '\\n';\n\t}\n\treturn 0;\n}""]","['brute force', 'greedy', 'math']",800
https://codeforces.com//contest/849/problem/B,B. Tell Your World,There are points on a coordinate plane the th of which being Determine whether it s possible to draw two parallel and non overlapping lines such that every point in the set lies on of them and each of them passes through point in the set ,"['#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define MN 1005\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\nint n,gs,pre;\nint a[MN];\nbool bj[MN],u[MN];\n\nint main()\n{\n\tregister int i,j;\n\tn=read();\n\tfor (i=1;i<=n;++i) a[i]=read();\n\tfor (i=1;i<n;++i) if (a[i+1]-a[i]!=a[2]-a[1]) break;\n\tif (i==n) return 0*printf(""No"");\n\tfor (i=2;i<n;++i) if (a[i+1]-a[i]!=a[3]-a[2]) break;\n\tif (i==n) return 0*printf(""Yes"");\n\tu[1]=true;\n\tfor (i=2;i<=n;++i)\n\t{\n\t\tif (u[i]) continue;\n\t\tmemset(bj,0,sizeof(bj));\n\t\tgs=1; bj[1]=true;\n\t\tfor (j=i;j<=n;++j) if (1LL*(a[j]-a[1])*(i-1)==1LL*(a[i]-a[1])*(j-1)) bj[j]=true,++gs;\n//\t\tfor (j=1;j<=n;++j) printf(""%d "",bj[j]); puts("""");\n\t\tif (n-gs<2) return 0*printf(""Yes"");\n\t\tpre=0;\n\t\tfor (j=1;j<=n;++j)\n\t\t{\n\t\t\tif (!bj[j]) {if (pre&&1LL*(a[j]-a[pre])*(i-1)!=1LL*(a[i]-a[1])*(j-pre)) break; pre=j;}\n\t\t\telse u[j]=true;\n\t\t}\n\t\tif (j>n) return 0*printf(""Yes"");\n//\t\tfor (j=1;j<=n;++j) printf(""%d "",u[j]); puts("""");\n\t}\n\tprintf(""No"");\n}']","['brute force', 'geometry']",1600
https://codeforces.com//contest/347/problem/A,A. Difference Row,You want to arrange integers in some order in a row Let s define the value of an arrangement as the sum of differences between all pairs of adjacent integers More formally let s denote some arrangement as a sequence of integers where sequence is a permutation of sequence The value of such an arrangement is Find the largest possible value of an arrangement Then output the lexicographically smallest sequence that corresponds to an arrangement of the largest possible value ,"['#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cmath>\n\nusing namespace std;\n\n#define DBG(z) cerr << #z << "": "" << (z) << endl\n#define NEWL cerr << endl\n#define passert(x, m) {if (!(x)) {cerr << m << ""  ::  "";} assert(x);}\n#define err(s) cerr << ""\x1b[92m"" << s << ""\x1b[0m"" << endl\n#define LINE cerr << ""DEBUG LINE: "" << __LINE__ << endl\n\n#define IT(v) __typeof((v).begin())\n#define mem(f, a) memset(f, a, sizeof(f))\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define for_each(it, v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define next_int() ({int __t; scanf(""%d"", &__t); __t;})\n\nint main() {\n    int n = next_int();\n    vector <int> a(n);\n    for (int i = 0; i < a.size(); ++i) a[i] = next_int();\n    sort(all(a));\n    swap(a[0], a[n - 1]);\n    for (int i = 0; i < a.size(); ++i) {\n        if (i) printf("" "");\n        printf(""%d"", a[i]);\n    }\n    printf(""\\n"");\n}\n\n']","['constructive algorithms', 'implementation', 'sortings']",1300
https://codeforces.com//contest/1288/problem/B,B. Yet Another Meme Problem,You are given two integers A and B calculate the number of pairs a b such that 1 le a le A 1 le b le B and the equation a cdot b a b conc a b is true conc a b is the concatenation of a and b for example conc 12 23 1223 conc 100 11 10011 ,"['//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 _y0\n#define kill _kill\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll btc = 30;\nconst ld eps = 1e-10;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 998244353; //(int)(1e9 + 7); //998244353;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n//constants\nconst int M = (int)(2e5 + 239);\nconst int N = (int)(2e3 + 239);\nconst int L = 20;\nconst int T = (1 << 20);\nconst int B = 500;\nconst int X = 1e4 + 239;\n\nvoid solve()\n{\n    int a, b;\n    cin >> a >> b;\n    ll pr = 10;\n    ll ans = 0;\n    while (pr - 1 <= b) {\n        ans += a;\n        pr *= 10;\n    }\n    cout << ans << ""\\n"";\n}\n\nint32_t main()\n{\n#ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}']",['math'],1100
https://codeforces.com//contest/1209/problem/D,D. Cow and Snacks,The legendary Farmer John is throwing a huge party and animals from all over the world are hanging out at his house His guests are hungry so he instructs his cow Bessie to bring out the snacks Moo There are n snacks flavors numbered with integers 1 2 ldots n Bessie has n snacks one snack of each flavor Every guest has exactly two favorite flavors The procedure for eating snacks will go as follows First Bessie will line up the guests in some way Then in this order guests will approach the snacks one by one Each guest in their turn will eat all remaining snacks of their favorite flavor In case no favorite flavors are present when a guest goes up they become very sad Help Bessie to minimize the number of sad guests by lining the guests in an optimal way ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n,k,f[N],sz[N],se[N];\nint u,v;\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint main() {\n\tscanf(""%d%d"",&n,&k);\n\trep(i,1,n+1) f[i]=i,sz[i]=1,se[i]=0;\n\trep(i,0,k) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\tu=find(u); v=find(v);\n\t\tif (u==v) se[u]++;\n\t\telse {\n\t\t\tf[v]=u;\n\t\t\tsz[u]+=sz[v];\n\t\t\tse[u]+=se[v]+1;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,1,n+1) if (find(i)==i) {\n\t\tans+=se[i]-sz[i]+1;\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","['dfs and similar', 'dsu', 'graphs']",1700
https://codeforces.com//contest/1379/problem/F2,F2. Chess Strikes Back  hard version ,Ildar and Ivan are tired of chess but they really like the chessboard so they invented a new game The field is a chessboard 2n times 2m it has 2n rows 2m columns and the cell in row i and column j is colored white if i j is even and is colored black otherwise The game proceeds as follows Ildar marks some of the cells of the chessboard as and asks Ivan to place n times m kings on the remaining cells in such way so that there are no kings attacking each other A king can attack another king if they are located in the adjacent cells sharing an edge or a corner Ildar would like to explore different combinations of cells Initially all cells are marked as available and then he has q queries In each query he either marks a cell as unavailable or marks the previously unavailable cell as available After each query he would like to know whether it is possible to place the kings on the available cells in a desired way Please help him ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntuple<bool, int, int> domerge(tuple<bool, int, int> a, tuple<bool, int, int> b) {\n\treturn {\n\t\tget<0>(a) && get<0>(b) && get<2>(a) > get<1>(b),\n\t\tmax(get<1>(a), get<1>(b)),\n\t\tmin(get<2>(a), get<2>(b))\n\t};\n}\n\n\nclass SegmentTree {\npublic:\n\tvector< tuple<bool, int, int> > a;\n\tint n;\n\n\tSegmentTree(int sz) {\n\t\tn = sz;\n\t\ta.resize(4 * n, tuple<bool, int, int>(true, -1, 1000000000));\n\t}\n\n\tvoid set(int v, int vl, int vr, int i, tuple<bool, int, int> x) {\n\t\tif(vr - vl == 1) {\n\t\t\ta[v] = x;\n\t\t} else {\n\t\t\tint vm = (vl + vr) / 2;\n\t\t\tif(i < vm) {\n\t\t\t\tset(v * 2, vl, vm, i, x);\n\t\t\t} else {\n\t\t\t\tset(v * 2 + 1, vm, vr, i, x);\n\t\t\t}\n\t\t\ta[v] = domerge(a[v * 2], a[v * 2 + 1]);\n\t\t}\n\t}\n\n\tvoid set(int i, tuple<bool, int, int> x) {\n\t\tset(1, 0, n, i, x);\n\t}\n\n\ttuple<bool, int, int> get(int v, int vl, int vr, int l, int r) {\n\t\tif(vl == l && vr == r) {\n\t\t\treturn a[v];\n\t\t} else {\n\t\t\tint vm = (vl + vr) / 2;\n\t\t\tif(r <= vm) {\n\t\t\t\treturn get(v * 2, vl, vm, l, r);\n\t\t\t} else if(l >= vm) {\n\t\t\t\treturn get(v * 2 + 1, vm, vr, l, r);\n\t\t\t} else {\n\t\t\t\treturn domerge(get(v * 2, vl, vm, l, vm), get(v * 2 + 1, vm, vr, vm, r));\n\t\t\t}\n\t\t}\n\t}\n\n\ttuple<bool, int, int> get(int l, int r) {\n\t\treturn get(1, 0, n, l, r);\n\t}\n};\n\nsigned main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tvector< set<int> > zeroes_on_line(n);\n\tvector< set<int> > ones_on_line(n);\n\n\tSegmentTree st(n);\n\n\tfor(int cnt = 0; cnt < q; cnt++) {\n\t\tint i, j;\n\t\tcin >> i >> j;\n\t\ti--; j--;\n\t\tbool is_one = i % 2 == 0;\n\t\ti /= 2;\n\t\tj /= 2;\n\n\t\tif(is_one) {\n\t\t\tif(ones_on_line[i].count(j)) {\n\t\t\t\tones_on_line[i].erase(j);\n\t\t\t} else {\n\t\t\t\tones_on_line[i].insert(j);\n\t\t\t}\n\t\t} else {\n\t\t\tif(zeroes_on_line[i].count(j)) {\n\t\t\t\tzeroes_on_line[i].erase(j);\n\t\t\t} else {\n\t\t\t\tzeroes_on_line[i].insert(j);\n\t\t\t}\n\t\t}\n\n\t\tauto line = st.get(i, i + 1);\n\t\tget<1>(line) = zeroes_on_line[i].empty() ? -1 : *zeroes_on_line[i].rbegin();\n\t\tget<2>(line) = ones_on_line[i].empty() ? 1000000000 : *ones_on_line[i].begin();\n\t\tget<0>(line) = get<1>(line) < get<2>(line);\n\t\tst.set(i, line);\n\n\t\tif(get<0>(st.get(0, n))) {\n\t\t\tcout << ""YES"" << ""\\n"";\n\t\t} else {\n\t\t\tcout << ""NO"" << ""\\n"";\n\t\t}\n\t}\n\n\treturn 0;\n}']","['data structures', 'divide and conquer']",2800
https://codeforces.com//contest/1732/problem/D1,D1. Balance  Easy version ,Initially you have a set containing one element 0 You need to handle q queries of the following types x add the integer x to the set It is guaranteed that this integer is not contained in the set k find the k text mex of the set In our problem we define the k text mex of a set of integers as the smallest non negative integer x that is divisible by k and which is not contained in the set ,"['#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c==\'-\')f=-1;\n\t\tfor(;c<\'0\'||c>\'9\';c=gc())if(c==\'-\')f=-1;\n\t\tfor(;c>=\'0\'&&c<=\'9\';c=gc())\n\t\t\tx=x*10+(c-\'0\');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c=\'\\n\'){\n\t\tif(x<0)pc(\'-\'),x=-x;\n\t\tif(x==0) pc(\'0\'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+\'0\';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,q;\nLL x,k;\nmap<LL,int>H,H2;\nsigned main(){\n\tsrand(time(0));\n\tgi(q);\n\twhile(q--){\n\t\tchar s[3];\n\t\tscanf(""%s"",s+1);\n\t\tif(s[1]==\'+\'){\n\t\t\tgi(x);\n\t\t\tH2[x]=1;\n\t\t}else{\n\t\t\tgi(k);\n\t\t\tif(H.find(k)==H.end())H[k]=1;\n\t\t\tint now=H[k];\n\t\t\twhile(H2[1ll*now*k])now++;\n\t\t\tH[k]=now;\n\t\t\tpi(1ll*now*k,\'\\n\');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/']","['brute force', 'data structures', 'implementation', 'number theory']",1500
https://codeforces.com//contest/1687/problem/C,C. Sanae and Giant Robot,Is it really The robot only existing in my imagination The Colossal Walking Robot Kochiya Sanae Sanae made a giant robot Hisoutensoku but something is wrong with it To make matters worse Sanae can not figure out how to stop it and she is forced to fix it on the fly The state of a robot can be represented by an array of integers of length n Initially the robot is at state a She wishes to turn it into state b As a great programmer Sanae knows the art of copy and paste In one operation she can choose some segment from given segments copy the segment from b and paste it into of the robot replacing the original state there However she has to ensure that the sum of a after each copy operation in case the robot go haywire Formally Sanae can choose segment l r and assign a i b i l le i le r if sum limits i 1 n a i does not change after the operation Determine whether it is possible for Sanae to successfully turn the robot from the initial state a to the desired state b with any possibly zero operations ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nvector<int> g[N];\nint n;\nll a[N], b[N];\nset<int> setik;\nint q[N];\nint topQ;\n\nvoid fixSegm(int l, int r) {\n\tif (l > r) swap(l, r);\n\twhile(true) {\n\t\tauto it = setik.lower_bound(l);\n\t\tif (it == setik.end()) break;\n\t\tif (*it > r) break;\n\t\tint x = *it;\n\t\tsetik.erase(it);\n\t\tq[topQ++] = x;\n\t}\n}\n\nbool solve() {\n\tint m;\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i <= n; i++)\n\t\tg[i].clear();\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%lld"", &a[i + 1]);\n\t\ta[i + 1] += a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%lld"", &b[i + 1]);\n\t\tb[i + 1] += b[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tl--;\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\t}\n\tif (a[n] != b[n]) return false;\n\ttopQ = 0;\n\tsetik.clear();\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tq[topQ++] = i;\n\t\telse\n\t\t\tsetik.insert(i);\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (setik.count(u)) continue;\n\t\t\tfixSegm(v, u);\n\t\t}\n\t}\n\treturn setik.empty();\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) {\n\t\tif (solve()) {\n\t\t\tprintf(""Yes\\n"");\n\t\t} else {\n\t\t\tprintf(""No\\n"");\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","['binary search', 'brute force', 'data structures', 'dsu', 'greedy', 'sortings']",2500
https://codeforces.com//contest/1343/problem/F,F. Restore the Permutation by Sorted Segments,We guessed a permutation p consisting of n integers The permutation of length n is the array of length n where each element from 1 to n appears exactly once This permutation is a secret for you For each position r from 2 to n we chose some other index l l r and gave you the segment p l p l 1 dots p r in order i e we rearranged the elements of this segment in a way that the elements of this segment are sorted Thus you are given exactly n 1 segments of the initial permutation but elements inside each segment are sorted The segments are given to you in random order For example if the secret permutation is p 3 1 4 6 2 5 then the possible given set of segments can be 2 5 6 4 6 1 3 4 1 3 1 2 4 6 Your task is to find suitable permutation i e any permutation corresponding to the given input data It is guaranteed that the input data corresponds to some permutation i e such permutation exists You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; //\ntypedef string str; //\n//\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; //\ntypedef pair<db,db> pd; //\n//\ntypedef vector<int> vi; \ntypedef vector<ll> vl; //\ntypedef vector<db> vd; //\ntypedef vector<str> vs; //\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; //\ntypedef vector<pd> vpd; //\n \ntypedef tree<pi, null_type, less<pi>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n \n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() //\n#define rsz resize\n#define ins insert //\n#define ft front() //\n#define bk back()\n#define pf push_front //\n#define pb push_back\n#define eb emplace_back //\n#define lb lower_bound //\n#define ub upper_bound //\n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; //\nconst ll INF = 1e18; //\nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; //\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); //\n//\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { //\n\treturn a < b ? a = b, 1 : 0; } //\nconstexpr int pct(int x) { return __builtin_popcount(x); } //\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) //\nconstexpr int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 //\n// IGNORE\nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n \n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n// IGNORE\n//\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint t;\n\tcin >> t;\n\tF0R(i, t){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> lists[n - 1];\n\t\tF0R(a, n - 1){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tF0R(b, k){\n\t\t\t\tint temp;\n\t\t\t\tcin >> temp;\n\t\t\t\ttemp--;\n\t\t\t\tlists[a].pb(temp);\n\t\t\t}\n\t\t}\n\t\tF0R(a, n){\n\t\t\tbool bad = false;\n\t\t\tvector<int> ans;\n\t\t\tset<int> l[n - 1];\n\t\t\tF0R(b, n - 1)\n\t\t\t\ttrav(c, lists[b])\n\t\t\t\t\tl[b].insert(c);\n\t\t\tans.pb(a);\n\t\t\tF0R(b, n - 1){\n\t\t\t\tint last = ans[sz(ans) - 1];\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tc.erase(last);\n\t\t\t\tint cnt = 0;\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tcnt += (c.size() == 1);\n\t\t\t\tif(cnt != 1){\n\t\t\t\t\tbad = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tif(c.size() == 1)\n\t\t\t\t\t\tans.pb(*c.begin());\n\t\t\t}\n\t\t\tif(!bad){\n\t\t\t\ttrav(b, lists){\n\t\t\t\t\tF0R(c, n){\n\t\t\t\t\t\tauto temp = lb(all(b), ans[c]);\n\t\t\t\t\t\tif(temp != b.end() && *temp == ans[c]){\n\t\t\t\t\t\t\tif(c + sz(b) > n){\n\t\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tset<int> test;\n\t\t\t\t\t\t\ttest.insert(ans[c]);\n\t\t\t\t\t\t\tFOR(d, c + 1, c + sz(b))\n\t\t\t\t\t\t\t\ttest.insert(ans[d]);\n\t\t\t\t\t\t\tF0R(d, sz(b))\n\t\t\t\t\t\t\t\ttest.erase(b[d]);\n\t\t\t\t\t\t\tif(sz(test) != 0){\n\t\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(bad)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(bad)\n\t\t\t\t\tcontinue;\n\t\t\t\ttrav(b, ans)\n\t\t\t\t\tcout << b + 1 << "" "";\n\t\t\t\tcout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n']","['brute force', 'constructive algorithms', 'data structures', 'greedy', 'implementation']",2400
https://codeforces.com//contest/1673/problem/D,D. Lost Arithmetic Progression,Long ago you thought of two finite arithmetic progressions A and B Then you found out another sequence C containing all elements common to both A and B It is not hard to see that C is also a finite arithmetic progression After many years you forgot what A was but remember B and C You are for some reason determined to find this lost arithmetic progression Before you begin this eternal search you want to know how many different finite arithmetic progressions exist which can be your lost progression A Two arithmetic progressions are considered different if they differ in their first term common difference or number of terms It may be possible that there are infinitely many such progressions in which case you won t even try to look for them Print 1 in all such cases Even if there are finite number of them the answer might be very large So you are only interested to find the answer modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar(\'-\'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nconst int mod=1e9+7;\n\nll b,q,y;\nll c,r,z;\n\nll lcm(ll x,ll y){return x/__gcd(x,y)*y;}\n\nvoid solve(){\n    scanf(""%lld%lld%lld"",&b,&q,&y);\n    scanf(""%lld%lld%lld"",&c,&r,&z);\n    if(r%q)return puts(""0""),void();\n    if((b-c)%q)return puts(""0""),void();\n    if(c<b||c+r*(z-1)>b+q*(y-1))return puts(""0""),void();\n    ll ans=0;\n    bool flag=0;\n    ll pos1,pos2;\n    pos1=(c-b)/q+1;\n    pos2=(c+r*(z-1)-b)/q+1;\n    auto sol=[&](ll x){\n        ll t=lcm(x,q);\n        if(t<r)return;\n        assert(t==r);\n        ll new_pos1=pos1-r/q;\n        ll new_pos2=pos2+r/q;\n        if(new_pos1<1||new_pos2>y){\n            flag=1;\n            return;\n        }else{\n            ans+=(r/x)*(r/x);\n            ans%=mod;\n        }\n    };\n    for(int i=1;i*i<=r;i++)if(r%i==0){\n        sol(i);\n        if(i!=r/i)sol(r/i);\n    }\n    if(flag)puts(""-1"");\n    else print(ans,\'\\n\');\n}\n\nint main(){\n    int T=read();\n    while(T--)solve();\n    return 0;\n}']","['combinatorics', 'math', 'number theory']",1900
https://codeforces.com//contest/1355/problem/C,C. Count Triangles,Like any unknown mathematician Yuri has favourite numbers A B C and D where A leq B leq C leq D Yuri also likes triangles and once he thought how many non degenerate triangles with integer sides x y and z exist such that A leq x leq B leq y leq C leq z leq D holds Yuri is preparing problems for a new contest now so he is very busy That s why he asked you to calculate the number of triangles with described property The triangle is called non degenerate if and only if its vertices are not collinear ,"['#include <bits/stdc++.h>\n#define ld long double\n#define endl ""\\n""\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\nint32_t main(){\n  fastio;\n  ll a,b,c,d;\n  cin>>a>>b>>c>>d;\n  ll tot=0;\n  for(int z=c;z<=d;z++){\n    int mn = max(a,z-c + 1);\n    if(mn > b)continue;\n\n    int mn2 = max(b,z - mn + 1);\n\n    int ter = (b - mn + 1);   \n\n    int put1 = min(ter,mn2 - b + 1);\n\n    int a1 = c - mn2 + 1;\n\n    tot+=(put1*(a1 + a1 + put1 - 1) / 2);\n\n    ter-=put1;\n    tot+=ter*(c-b+1);\n\n  }\n  cout << tot << endl;\n  \n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}']","['binary search', 'implementation', 'math', 'two pointers']",1800
https://codeforces.com//contest/273/problem/E,E. Dima and Game,Dima and Anya love playing different games Now Dima has imagined a new game that he wants to play with Anya Dima writes pairs of integers on a piece of paper Then players take turns On his turn the player can do the following actions choose the number of the pair such that replace pair number by pair or by pair Notation means rounding down to the closest integer The player who can t make a move loses Of course Dima wants Anya who will move first to win That s why Dima should write out such pairs of integers that if both players play optimally well the first one wins Count the number of ways in which Dima can do it Print the remainder after dividing the answer by number Two ways are considered distinct if the sequences of the written pairs are distinct ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\ntypedef long long LL;\nconst int N = 100000;\nclass SG{\n    public:\n        int l, r, sg;\n        SG(){}\n        SG(int _l, int _r, int _sg) { l=_l; r=_r; sg=_sg;}\n} a[1005];\nint getsg(int x, int y) {\n    if(x!=0 && y!=0) return 0;\n    if(x!=1 && y!=1) return 1;\n    return 2;\n}\nconst int MOD = 1e9+7;\n\nLL trapezoid(int top, int bot) {\n    return (top + bot) * 1LL * (top - bot + 1) / 2;\n}\nvoid add(LL &x, LL v) {\n    x = (x+v)%MOD;\n}\n\nint main(void) {\n    int n, p;\n    scanf(""%d%d"", &n, &p);\n\n    int m = 1, last=2;\n    a[0] = SG(0, 2, 0);\n    while(last < p) {\n        int x, u, v, i, j;\n        x = last+1;\n        u = x/3; v = x-x/3;\n        for(i=0;i<m;i++) if(u<=a[i].r && u>=a[i].l) break;\n        for(j=0;j<m;j++) if(v<=a[j].r && v>=a[j].l) break;\n        int ll=x, rr=p, mm, xx=x;\n        while(ll<=rr) {\n            mm=(ll+rr)/2;\n            if(mm/3 > a[i].r || mm - mm/3 > a[j].r) rr=mm-1;\n            else { xx=mm; ll = mm+1; }\n        }\n        a[m++] = SG(last+1, xx, getsg(a[i].sg, a[j].sg));\n        if(m>1 && a[m-1].sg == a[m-2].sg) {\n            --m;\n            a[m-1].r = a[m].r;\n        }\n        last = xx;\n        //printf(""%d %d %d\\n"", a[m-1].l, a[m-1].r, a[m-1].sg);\n    }\n    \n    a[0].l = 1;\n    LL c[4]={};\n    for(int i=0;i<m;i++) {\n        add(c[a[i].sg], trapezoid(p-a[i].l, p-a[i].r));\n    }\n    LL ans[1005][4]={};\n    ans[0][0] = 1;\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<4;j++)\n            for(int k=0;k<3;k++)\n                add(ans[i+1][j^k], ans[i][j] * c[k] % MOD);\n    }\n    LL sol = 0;\n    sol = ans[n][1] + ans[n][2] + ans[n][3];\n    sol = (sol % MOD+ MOD) % MOD;\n    printf(""%I64d\\n"", sol);\n    return 0;\n}\n']","['dp', 'games']",2600
https://codeforces.com//contest/351/problem/E,E. Jeff and Permutation,Jeff s friends know full well that the boy likes to get sequences and arrays for his birthday Thus Jeff got sequence for his birthday Jeff hates inversions in sequences An inversion in sequence is a pair of indexes such that an inequality holds Jeff can multiply some numbers of the sequence by 1 At that he wants the number of inversions in the sequence to be minimum Help Jeff and find the minimum number of inversions he manages to get ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint p[2010];\n\nint main(void){\n    int N,ans=0,i,j;\n    \n    cin >> N;\n    REP(i,N) cin >> p[i];\n    \n    REP(i,N) if(p[i] < 0) p[i] = -p[i];\n    \n    REP(i,N){\n        int a = 0, b = 0;\n        REP(j,N) if(p[j] < p[i]){\n            if(j < i) a++;\n            if(j > i) b++;\n        }\n        ans += min(a, b);\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']",['greedy'],2200
https://codeforces.com//contest/1622/problem/C,C. Set or Decrease,You are given an integer array a 1 a 2 dots a n and integer k In one step you can either choose some index i and decrease a i by one make a i a i 1 or choose two indices i and j and set a i equal to a j make a i a j What is the minimum number of steps you need to make the sum of array sum limits i 1 n a i le k You are allowed to make values of array negative ,"[""/**\n *    author:  tourist\n *    created: 27.12.2021 17:38:21       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    vector<long long> pref(n + 1);\n    for (int i = 0; i < n; i++) {\n      pref[i + 1] = pref[i] + a[i];\n    }\n    long long ans = (long long) 9e18;\n    for (int t = 0; t <= n - 1; t++) {\n      long long sum = pref[n - t] + a[0] * t;\n      long long cur = t;\n      if (sum > k) {\n        long long diff = sum - k;\n        cur += (diff + t) / (t + 1);\n      }\n      ans = min(ans, cur);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]","['binary search', 'brute force', 'greedy', 'sortings']",1600
https://codeforces.com//contest/660/problem/F,F. Bear and Bowling 4,Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,"['# include <cstdio>\n# include <vector>\nusing namespace std;\nconst int MN = 2e5 + 44;\nlong long a[MN];\nvector <pair <int, long long> > hull;\nbool bad(pair <int, long long> x)\n{\n\tif (hull.size() < 2)\n\t\treturn false;\n\tpair <int, long long> y = hull.back();\n\tpair <int, long long> z = hull[hull.size() - 2];\n\treturn (x.second - y.second) * (z.first - y.first) < (z.second - y.second) * (x.first - y.first);\n}\nlong long eval(pair <int, long long> a, long long x, long long y)\n{\n// \tprintf(""return %I64d\\n"", a.first * x + a.second + y);\n\treturn a.first * x + a.second + y;\n}\nlong long sufsum[MN];\nlong long sufscores[MN];\nint main()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%I64d"", a + i);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufsum[i] = sufsum[i + 1] + a[i];\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufscores[i] = sufscores[i + 1] + sufsum[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tpair <int, long long> add = make_pair(i, sufscores[i]);\n// \t\tprintf(""add %d %I64d\\n"", add.first, add.second);\n\t\twhile (bad(add))\n\t\t\thull.pop_back();\n\t\thull.push_back(add);\n\t}\n// \tfor (auto x : hull)\n// \t\tprintf(""%d %I64d\\n"", x.first, x.second);\n\tlong long res = 0;\n\tlong long x = 0, y = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t{\n// \t\tprintf(""i = %d x = %I64d y = %I64d\\n"", i, x, y);\n\t\tint low = 0, high = hull.size() - 1;\n\t\twhile (low < high - 3)\n\t\t{\n\t\t\tint med = (low + high) / 2;\n\t\t\tif (hull[med].first > i)\n\t\t\t\thigh = med - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong long val = eval(hull[med], x, y);\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[med].first, hull[med].second);\n\t\t\t\tres = max(res, val);\n\t\t\t\tif (eval(hull[med], x, y) > eval(hull[med + 1], x, y))\n\t\t\t\t\thigh = med;\n\t\t\t\telse\n\t\t\t\t\tlow = med;\n\t\t\t}\n\t\t}\n// \t\tprintf(""binsearch done\\n"");\n\t\tfor (int k = low; k <= high; ++k)\n\t\t\tif (hull[k].first <= i)\n\t\t\t{\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[k].first, hull[k].second);\n\t\t\t\tres = max(res, eval(hull[k], x, y));\n\t\t\t}\n\t\ty -= (i + 1) * a[i];\n\t\tx += a[i];\n\t}\n\tprintf(""%I64d\\n"", res);\n}']","['binary search', 'data structures', 'divide and conquer', 'geometry', 'ternary search']",2500
https://codeforces.com//contest/1882/problem/D,D. Tree XOR,You are given a tree with n vertices labeled from 1 to n An integer a i is written on vertex i for i 1 2 ldots n You want to make all a i equal by performing some possibly zero spells Suppose you root the tree at some vertex On each spell you can select any vertex v and any non negative integer c Then for all vertices i in the subtree dagger of v replace a i with a i oplus c The cost of this spell is s cdot c where s is the number of vertices in the subtree Here oplus denotes the bitwise XOR operation Let m r be the minimum possible total cost required to make all a i equal if vertex r is chosen as the root of the tree Find m 1 m 2 ldots m n dagger Suppose vertex r is chosen as the root of the tree Then vertex i belongs to the subtree of v if the simple path from i to r contains v ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T;\nint a[maxn],sz[maxn];\nlong long ans[maxn];\nvector<int>v[maxn];\nvoid dfs1(int x,int last){\n\tsz[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==last)\n\t\t\tcontinue;\n\t\tdfs1(y,x),sz[x]+=sz[y],ans[1]+=1ll*(a[x]^a[y])*sz[y];\n\t}\n}\nvoid dfs2(int x,int last){\n\tsz[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==last)\n\t\t\tcontinue;\n\t\tans[y]=ans[x]-1ll*(a[x]^a[y])*sz[y]+1ll*(a[x]^a[y])*(n-sz[y]);\n\t\tdfs2(y,x);\n\t}\n}\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(""%d"",&a[i]);\n\t\tfor(int i=1,x,y;i<n;i++)\n\t\t\tscanf(""%d%d"",&x,&y),v[x].emplace_back(y),v[y].emplace_back(x);\n\t\tdfs1(1,0),dfs2(1,0);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(""%lld%c"",ans[i],i==n? \'\\n\':\' \'),ans[i]=0,v[i].clear();\n\t}\n\treturn 0;\n}\n']","['bitmasks', 'dfs and similar', 'dp', 'greedy', 'trees']",1900
https://codeforces.com//contest/1364/problem/D,D. Ehab s Last Corollary,Given a connected undirected graph with n vertices and an integer k you have to either either find an independent set that has lceil frac k 2 rceil vertices or find a cycle of length k An independent set is a set of vertices such that no two of them are connected by an edge A simple cycle is a cycle that doesn t contain any vertex twice I have a proof that for any input you can always solve at least one of these problems but it s left as an exercise for the reader ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, k;\nint cycle_st, cycle_end;\nvector<vector<int>> g;\nvector<char> cl;\nvector<int> p;\n\nbool dfs(int v) {\n  cl[v] = 1;\n  for (size_t i = 0; i < g[v].size(); ++i) {\n    int to = g[v][i];\n    if (cl[to] == 0) {\n      p[to] = v;\n      if (dfs(to))\n        return true;\n    } else if (cl[to] == 1 && p[v] != to) {\n      cycle_end = v;\n      cycle_st = to;\n      return true;\n    }\n  }\n  cl[v] = 2;\n  return false;\n}\n\nint main() {\n  cin >> n >> m >> k;\n  n = min(n, k);\n  g.resize(n);\n  p.resize(n, -1);\n  cl.resize(n, 0);\n  cycle_st = -1;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    if (u > k || v > k) {\n      continue;\n    }\n    u--, v--;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    if (dfs(i)) {\n      break;\n    }\n  }\n\n  if (cycle_st == -1) {\n    vector<char> part(n, -1);\n    bool ok = true;\n    vector<int> q(n);\n    for (int st = 0; st < n; ++st) {\n      if (part[st] == -1) {\n        int h = 0, t = 0;\n        q[t++] = st;\n        part[st] = 0;\n        while (h < t) {\n          int v = q[h++];\n          for (size_t i = 0; i < g[v].size(); ++i) {\n            int to = g[v][i];\n            if (part[to] == -1) {\n              part[to] = !part[v], q[t++] = to;\n            } else {\n              ok &= part[to] != part[v];\n            }\n          }\n        }\n      }\n    }\n    cout << 1 << '\\n';\n    int x = 0, y = 0;\n    for (int i = 0; i < n; ++i) {\n      if (part[i] == 1) {\n        x++;\n      } else {\n        y++;\n      }\n    }\n    for (int i = 0, j = 0; i < n && j < (n + 1) / 2; ++i) {\n      if (x >= y && part[i] == 1) {\n        j++;\n        cout << i + 1 << ' ';\n      }\n      if (y > x && part[i] == 0) {\n        j++;\n        cout << i + 1 << ' ';\n      }\n    }\n  } else {\n    cout << 2 << '\\n';\n    vector<int> cycle;\n    cycle.push_back(cycle_st);\n    for (int v = cycle_end; v != cycle_st; v = p[v]) {\n      cycle.push_back(v);\n    }\n    cycle.push_back(cycle_st);\n    reverse(cycle.begin(), cycle.end());\n    cout << cycle.size() - 1 << '\\n';\n    for (size_t i = 0; i < cycle.size() - 1; ++i) {\n      cout << cycle[i] + 1 << ' ';\n    }\n  }\n\n  return 0;\n}\n""]","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'implementation', 'trees']",2100
https://codeforces.com//contest/329/problem/D,D. The Evil Temple and the Moving Rocks,You are an adventurer currently journeying inside an evil temple After defeating a couple of weak monsters you arrived at a square room consisting of tiles forming an grid surrounded entirely by walls At the end of the room lies a door locked with evil magical forces The following inscriptions are written on the door Being a very senior adventurer you immediately realize what this means In the room next door lies an infinite number of magical rocks There are four types of rocks this rock moves upwards this rock moves leftwards this rock moves rightwards this rock moves downwards To open the door you first need to place the rocks on some of the tiles one tile can be occupied by at most one rock Then you select a single rock that you have placed and activate it The activated rock will then move in its direction until it hits another rock or hits the walls of the room the rock will not move if something already blocks it in its chosen direction The rock then deactivates If it hits the walls or if there have been already events of rock becoming activated the movements end Otherwise the rock that was hit becomes activated and this procedure is repeated If a rock moves at least one cell before hitting either the wall or another rock the hit produces a sound The door will open once the number of produced sounds is at least It is okay for the rocks to continue moving after producing sounds The following picture illustrates the four possible scenarios of moving rocks Moves at least one cell then hits another rock A sound is produced the hit rock becomes activated Moves at least one cell then hits the wall i e the side of the room A sound is produced the movements end Does not move because a rock is already standing in the path The blocking rock becomes activated but no sounds are produced Does not move because the wall is in the way No sounds are produced and the movements end Assume there s an infinite number of rocks of each type in the neighboring room You know what to do place the rocks and open the door ,"['/*\nID: espr1t\nTASK: \nKEYWORDS: \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nFILE *in; FILE *out;\n\nconst int MAX = 128;\n\nint main(void) {\n\tin = stdin; out = stdout;\n//\tin = fopen(""D.in"", ""rt""); out = fopen(""D.out"", ""wt"");\n\t\n\tint n, k;\n\tfscanf(in, ""%d %d"", &n, &k);\n\tif (n == 3 && k == 2) {\n\t    fprintf(out, "">vv\\n"");\n\t    fprintf(out, ""^<.\\n"");\n\t    fprintf(out, ""^.<\\n"");\n\t    fprintf(out, ""1 3\\n"");\n\t    return 0;\n\t}\n\tif (n == 5 && k == 5) {\n        fprintf(out, "">...v\\n"");\n        fprintf(out, ""v.<..\\n"");\n        fprintf(out, ""..^..\\n"");\n        fprintf(out, "">....\\n"");\n        fprintf(out, ""..^.<\\n"");\n        fprintf(out, ""1 1\\n"");\n        return 0;\n\t}\n\t\n\tstatic char ans[MAX][MAX];\n\tmemset(ans, 0, sizeof(ans));\n\tfor (int i = 0; i < n; i++)\n\t    for (int c = 0; c < n; c++)\n\t        ans[i][c] = \'.\';\n\n\tint len = 33, idx = 0;\n\tfor (int i = 0; i < len; i++)\n\t    ans[0][idx++] = \'>\';\n\tfor (int i = 0; i < len; i++) {\n\t    ans[0][idx++] = \'.\';\n\t    ans[0][idx++] = \'>\';\n\t}\n\tans[0][idx++] = \'v\';\n\t\n\tfor (int i = 1; i < n - 1; i += 2) {\n\t    int row = i;\n\t    idx = 0;\n\t    ans[row][idx++] = \'^\';\n\t    ans[row][idx++] = \'v\';\n\t    for (int c = 0; c < len - 1; c++) {\n\t        ans[row][idx++] = \'.\';\n\t        ans[row][idx++] = \'<\';\n\t    }\n\t    while (idx < n)\n\t        ans[row][idx++] = \'<\';\n\t    \n\t    row++;\n\t    idx = 0;\n\t    ans[row][idx++] = \'^\';\n\t    for (int c = 0; c < len - 1; c++)\n\t        ans[row][idx++] = \'>\';\n\t    for (int c = 0; c < len - 1; c++) {\n\t        ans[row][idx++] = \'.\';\n\t        ans[row][idx++] = \'>\';\n\t    }\n\t    ans[row][n - 1] = \'v\';\n\t}\n\t\n\tidx = 0;\n\tans[n - 1][idx++] = \'^\';\n\tfor (int i = 0; i < len; i++) {\n\t    ans[n - 1][idx++] = \'.\';\n\t    ans[n - 1][idx++] = \'<\';\n\t}\n\twhile (idx < n)\n\t    ans[n - 1][idx++] = \'<\';\n\t\n\tfor (int i = 0; i < n; i++)\n\t    fprintf(out, ""%s\\n"", ans[i]);\n\tfprintf(out, ""1 1\\n"");\n\n\treturn 0;\n}\n']",['constructive algorithms'],2500
https://codeforces.com//contest/830/problem/D,D. Singer House,It is known that passages in Singer house are complex and intertwined Let s define a Singer house as a graph built by the following process take complete binary tree of height and add edges from each vertex to all its successors if they are not yet present Count the number of non empty paths in Singer house which do not pass the same vertex twice Two paths are distinct if the sets or the orders of visited vertices are different Since the answer can be large output it modulo ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mo=1e9+7;\nint f[500][500],C[500][500],I[500],nI[500];\nlong long A[500];\nint n;\nint quick(int k1,int k2){\n\tint k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3=1ll*k3*k1%mo; k2>>=1; k1=1ll*k1*k1%mo;\n\t}\n\treturn k3;\n}\nint main(){\n\tscanf(""%d"",&n);\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tI[0]=1; for (int i=1;i<=n;i++) I[i]=1ll*I[i-1]*i%mo;\n\tfor (int i=0;i<=n;i++) nI[i]=quick(I[i],mo-2);\n\tfor (int i=1;i<=n;i++){\n\t\tf[i][0]=1; memset(A,0x00,sizeof A); A[0]=1;\n\t\tfor (int j=n;j;j--)\n\t\t\tfor (int k=0;k<=j;k++)\n\t\t\t\tif (A[j]<0) A[j]+=1ll*f[i-1][k]*f[i-1][j-k];\n\t\t\t\telse A[j]+=1ll*(f[i-1][k]-mo)*f[i-1][j-k]; \n\t\tfor (int j=1;j<=n;j++) A[j]=1ll*(A[j]%mo+mo)*I[j]%mo;\n\t\tfor (int j=n;j;j--)\n\t\t\tf[i][j]=(1ll*(2*j+1)*A[j]+1ll*j*A[j+1]+1ll*j*A[j-1])%mo*nI[j]%mo;\n\t}\n\tprintf(""%d\\n"",f[n][1]);\n\treturn 0;\n}\n\t\t\t']","['combinatorics', 'dp', 'graphs', 'trees']",2800
https://codeforces.com//contest/909/problem/C,C. Python Indentation,In Python code blocks don t have explicit begin end or curly braces to mark beginning and end of the block Instead code blocks are defined by indentation We will consider an extremely simplified subset of Python with only two types of statements are written in a single line one per line An example of a simple statement is assignment are compound statements they contain one or several other statements For statement consists of a header written in a separate line which starts with for prefix and loop body Loop body is a block of statements indented one level further than the header of the loop Loop body can contain both types of statements Loop body can t be empty You are given a sequence of statements without indentation Find the number of ways in which the statements can be indented to form a valid Python program ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\n\nint n,dp[2][5005],now,ans;\nchar c;\nbool lsf;\n\nint main()\n{\n\tscanf(""%d"",&n),dp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdo c=getchar();while(!isalpha(c));\n\t\tnow=i&1;\n\t\tmemset(dp[now],0,n<<2);\n\t\tif(lsf)for(int j=1;j<n;j++)dp[now][j]=dp[now^1][j-1];\n\t\telse\n\t\t{\n\t\t\tdp[now][n-1]=dp[now^1][n-1];\n\t\t\tfor(int j=n-2;~j;j--)dp[now][j]=(dp[now][j+1]+dp[now^1][j])%mod;\n\t\t}\n\t\tlsf=(c==\'f\');\n\t}\n\tfor(int i=0;i<n;i++)ans=(ans+dp[n&1][i])%mod;\n\tprintf(""%d"",ans);\n\treturn 0;\n}']",['dp'],1800
https://codeforces.com//contest/1059/problem/C,C. Sequence Transformation,Let s call the following process a transformation of a sequence of length n If the sequence is empty the process ends Otherwise append the greatest common divisor GCD of all the elements of the sequence to the result and remove one arbitrary element from the sequence Thus when the process ends we have a sequence of n integers the greatest common divisors of all the elements in the sequence before each deletion You are given an integer sequence 1 2 dots n Find the lexicographically maximum result of its transformation A sequence a 1 a 2 ldots a n is lexicographically larger than a sequence b 1 b 2 ldots b n if there is an index i such that a j b j for all j i and a i b i ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\n\nVI f(int n){\n    VI ans;\n    if(n == 0){\n        return ans;\n    }\n    if(n == 1){\n        ans.PB(1);\n        return ans;\n    }\n    if(n == 2){\n        ans.PB(1);\n        ans.PB(2);\n        return ans;\n    }\n    if(n == 3){\n        ans.PB(1);\n        ans.PB(1);\n        ans.PB(3);\n        return ans;\n    }\n    REP(i,1,n+1){\n        if(i%2 == 1){\n            ans.PB(1);\n        }\n    }\n    auto tmp = f(n/2);\n    for(auto& i:tmp)ans.PB(i*2);\n    return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    SOLVE::main();\n    \n    \n    int n;in(n);\n    auto v = f(n);\n    for(auto i:v)printf(""%d "",i);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']","['constructive algorithms', 'math']",1600
https://codeforces.com//contest/1011/problem/A,A. Stages,Natasha is going to fly to Mars She needs to build a rocket which consists of several stages in some order Each of the stages is defined by a lowercase Latin letter This way the rocket can be described by the string concatenation of letters which correspond to the stages There are n stages available The rocket must contain exactly k of them Stages in the rocket should be ordered by their weight So after the stage with some letter can go only stage with a letter which is at least two positions after in the alphabet skipping one letter in between or even more For example after letter can t go letters and but can go letters For the rocket to fly as far as possible its weight should be minimal The weight of the rocket is equal to the sum of the weights of its stages The weight of the stage is the number of its letter in the alphabet For example the stage weighs one ton weighs two tons and 26 tons Build the rocket with the minimal weight or determine that it is impossible to build a rocket at all Each stage can be used at most once ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar str[100];\n\nint main() {\n  int n,k;\n  scanf(""%d%d"",&n,&k);\n  scanf(""%s"",str+1);\n  sort(str+1,str+n+1);\n  int s=0,x=1,cnt=0;\n  while (x<=n&&cnt<k) {\n  \tcnt++;\n  \ts+=str[x]-\'a\'+1;\n  \tchar c=str[x];\n  \tfor(;x<=n&&str[x]-c<2;x++);\n  }\n  printf(""%d\\n"",(cnt<k)?-1:s);\n  return 0;\n}']","['greedy', 'implementation', 'sortings']",900
https://codeforces.com//contest/1889/problem/F,F. Doremy s Average Tree,Doremy has a rooted tree of size n whose root is vertex r Initially there is a number w i written on vertex i Doremy can use her power to perform this operation k times Choose a vertex x 1 leq x leq n Let s frac 1 T sum i in T w i where T is the set of all vertices in x s subtree For all i in T assign w i s Doremy wants to know what is the lexicographically smallest dagger array w after performing all the operations Can you help her If there are multiple answers you may output any one dagger For arrays a and b both of length n a is lexicographically smaller than b if and only if there exist an index i 1 leq i le n such that a i b i and for all indices j such that j i a j b j is satisfied ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng(0);\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: Generate various types of trees.\n * Source: Own + Dhruv Rohatgi\n */\n\n////////////// DISTRIBUTIONS\n\n// return int in [L,R] inclusive\nint rng_int(int L, int R) {\n\tassert(L <= R);\n\treturn uniform_int_distribution<int>(L, R)(rng);\n}\nll rng_ll(ll L, ll R) {\n\tassert(L <= R);\n\treturn uniform_int_distribution<ll>(L, R)(rng);\n}\n\n// return double in [L,R] inclusive\ndb rng_db(db L, db R) {\n\tassert(L <= R);\n\treturn uniform_real_distribution<db>(L, R)(rng);\n}\n\n// http://cplusplus.com/reference/random/geometric_distribution/geometric_distribution/\n// flip a coin which is heads with probability p until you flip heads\n// mean value of c is 1/p-1\nint rng_geo(db p) {\n\tassert(0 < p && p <= 1);  // p large -> closer to 0\n\treturn geometric_distribution<int>(p)(rng);\n}\n\n////////////// VECTORS + PERMS\n\n// shuffle a vector\ntemplate <class T> void shuf(vector<T> &v) { shuffle(all(v), rng); }\n\n// generate random permutation of [0,N-1]\nvi randPerm(int N) {\n\tvi v(N);\n\tiota(all(v), 0);\n\tshuf(v);\n\treturn v;\n}\n\n// random permutation of [0,N-1] with first element 0\nvi randPermZero(int N) {\n\tvi v(N - 1);\n\tiota(all(v), 1);\n\tshuf(v);\n\tv.ins(bg(v), 0);\n\treturn v;\n}\n\n// shuffle permutation of [0,N-1]\nvi shufPerm(vi v) {\n\tint N = sz(v);\n\tvi key = randPerm(N);\n\tvi res(N);\n\tF0R(i, N) res[key[i]] = key[v[i]];\n\treturn res;\n}\n\n// vector with all entries in [L,R]\nvi rng_vec(int N, int L, int R) {\n\tvi res;\n\tF0R(_, N) res.pb(rng_int(L, R));\n\treturn res;\n}\n\n// vector with all entries in [L,R], unique\nvi rng_vec_unique(int N, int L, int R) {\n\tset<int> so_far;\n\tvi res;\n\tF0R(_, N) {\n\t\tint x;\n\t\tdo { x = rng_int(L, R); } while (so_far.count(x));\n\t\tso_far.ins(x);\n\t\tres.pb(x);\n\t}\n\treturn res;\n}\n\n////////////// GRAPHS\n\n// relabel edges ed according to perm, shuffle\nvpi relabelAndShuffle(vpi ed, vi perm) {\n\teach(t, ed) {\n\t\tt.f = perm[t.f], t.s = perm[t.s];\n\t\tif (rng() & 1) swap(t.f, t.s);\n\t}\n\tshuf(ed);\n\treturn ed;\n}\n\n// shuffle graph with vertices [0,N-1]\nvpi shufGraph(int N, vpi ed) {  // randomly swap endpoints, rearrange labels\n\treturn relabelAndShuffle(ed, randPerm(N));\n}\nvpi shufGraphZero(int N, vpi ed) {\n\treturn relabelAndShuffle(ed, randPermZero(N));\n}\n\n// shuffle tree given N-1 edges\nvpi shufTree(vpi ed) { return shufGraph(sz(ed) + 1, ed); }\n// randomly swap endpoints, rearrange labels\nvpi shufRootedTree(vpi ed) {\n\treturn relabelAndShuffle(ed, randPermZero(sz(ed) + 1));\n}\n\nvoid pgraphOne(int N, vpi ed) {\n\tps(N, sz(ed));\n\teach(e, ed) ps(1 + e.f, 1 + e.s);\n}\n\n////////////// GENERATING TREES\n\n// for generating tall tree\npi geoEdge(int i, db p) {\n\tassert(i > 0);\n\treturn {i, max(0, i - 1 - rng_geo(p))};\n}\n\n// generate edges of tree with verts [0,N-1]\n// smaller back -> taller tree\nvpi treeRand(int N, int back) {\n\tassert(N >= 1 && back >= 0);\n\tvpi ed;\n\tFOR(i, 1, N) ed.eb(i, i - 1 - rng_int(0, min(back, i - 1)));\n\treturn ed;\n}\n\n// generate path\nvpi path(int N) { return treeRand(N, 0); }\n\n// generate tall tree (large diameter)\n// the higher the p the taller the tree\nvpi treeTall(int N, db p) {\n\tassert(N >= 1);\n\tvpi ed;\n\tFOR(i, 1, N) ed.pb(geoEdge(i, p));\n\treturn ed;\n}\n\n// generate tall tree, then add rand at end\nvpi treeTallShort(int N, db p) {\n\tassert(N >= 1);\n\tint mid = (N + 1) / 2;\n\tvpi ed = treeTall(mid, p);\n\tFOR(i, mid, N) ed.eb(i, rng_int(0, i - 1));\n\treturn ed;\n}\n\n// lots of stuff connected to either heavy1 or heavy2\nvpi treeTallHeavy(int N, db p) {\n\tassert(N >= 1);  // + bunch of rand\n\tvpi ed;\n\tint heavy1 = 0, heavy2 = N / 2;\n\tFOR(i, 1, N) {\n\t\tif (i < N / 4) ed.eb(i, heavy1);\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\n\t\telse ed.pb(geoEdge(i, p));\n\t}\n\treturn ed;\n}\n\n// heavy tall tree + random\n// lots of verts connected to heavy1 or heavy2\nvpi treeTallHeavyShort(int N, db p) {\n\tassert(N >= 1);  // + almost-path + rand\n\tvpi ed;\n\tint heavy1 = 0, heavy2 = N / 2;\n\tFOR(i, 1, N) {\n\t\tif (i < N / 4) ed.eb(i, heavy1);\n\t\telse if (i <= heavy2) ed.pb(geoEdge(i, p));  // tall -> heavy1\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\n\t\telse ed.eb(i, rng_int(0, i - 1));\n\t}\n\treturn ed;\n}\n\nint rand_prime(int l, int r) {\n\twhile (1) {\n\t\tint x = rng_int(l, r);\n\t\tbool bad = 0;\n\t\tfor (int i = 2; i * i <= x; ++i)\n\t\t\tif (x % i == 0) bad = 1;\n\t\tif (!bad) return x;\n\t}\n}\n\nstruct Frac {\n\tll n, d;\n\tbool operator<(const Frac &o) const { return n * o.d < o.n * d; }\n\tbool operator==(const Frac &o) const { return n * o.d == o.n * d; }  // OK\n};\n\nostream &operator<<(ostream &os, const Frac &f) {\n\tos << ""Frac("" << f.n << "", "" << f.d << "")"";\n\treturn os;\n}\n\nstruct RangeInfo {\n\tpair<int, Frac> d0, d1;\n\tbool single_value() const { return d1.f == INT_MAX; }\n\tpair<int, Frac> first_dif(Frac f) const {\n\t\tif (d0.s == f) return d1;\n\t\treturn d0;\n\t}\n\tbool greater_than(Frac f) {\n\t\tauto [idx, val] = first_dif(f);\n\t\tif (idx == INT_MAX) return false;\n\t\tassert(!(f == val));\n\t\treturn f < val;\n\t}\n\tbool greater_or_equal(Frac f) {\n\t\tauto [idx, val] = first_dif(f);\n\t\tif (idx == INT_MAX) return true;\n\t\tassert(!(f == val));\n\t\treturn f < val;\n\t}\n};\n\nostream &operator<<(ostream &os, const pair<int, Frac> &p) {\n\tos << ""{"" << p.f << "", "" << p.s << ""}"";\n\treturn os;\n}\n\nostream &operator<<(ostream &os, const RangeInfo &i) {\n\tos << ""RangeInfo{"" << i.d0 << "", "" << i.d1 << ""}"";\n\treturn os;\n}\n\nRangeInfo operator+(RangeInfo l, RangeInfo r) {\n\tif (l.d0.f > r.d0.f) swap(l, r);\n\tassert(l.d0.f < r.d0.f);\n\treturn RangeInfo{l.d0, min(l.d1, l.d0.s == r.d0.s ? r.d1 : r.d0)};\n}\n\nstruct Info {\n\tint k, first_different;\n\tpi prev_pair;\n\tRangeInfo r;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n\tos << ""Info{"" << i.k << "", "" << i.first_different << "", ""\n\t   << ""{"" << i.prev_pair.f << "", "" << i.prev_pair.s << ""}""\n\t   << "", "" << i.r << ""}"";\n\treturn os;\n}\n\nInfo info_single(int x, int w) {\n\treturn {0, INT_MAX, {-1, -1}, RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}};\n}\n\nint N, K;\nV<V<Info>> dp, stor;\nvi W;\nV<vi> adj;\nvl sum;\nvi num;\n\nV<Info> conv(const V<Info> &dp_l, const V<Info> &dp_r) {\n\t// dbg(""COMPUTING"", sz(dp_l), sz(dp_r));\n\tint max_ops = min(dp_l.bk.k + dp_r.bk.k, K);\n\tV<vpi> cands(max_ops + 1);\n\tF0R(i, sz(dp_l)) F0R(j, sz(dp_r)) if (dp_l[i].k + dp_r[j].k <= K) {\n\t\tcands[dp_l[i].k + dp_r[j].k].pb({i, j});\n\t}\n\tauto better_pair = [&](pi a, pi b) {\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\n\t\tswap(a, b);\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\n\t\tif (a.f > b.f) swap(a, b);\n\t\tassert(a.f < b.f && a.s > b.s);\n\t\tint min_dif_a = INT_MAX;\n\t\tFOR(i, a.f + 1, b.f + 1) ckmin(min_dif_a, dp_l.at(i).first_different);\n\t\tint min_dif_b = INT_MAX;\n\t\tFOR(i, b.s + 1, a.s + 1) ckmin(min_dif_b, dp_r.at(i).first_different);\n\t\tif (min_dif_a < min_dif_b) return b;\n\t\treturn a;\n\t};\n\tauto first_different = [&](pi a, pi b) {\n\t\tint min_dif = INT_MAX;\n\t\tFOR(i, min(a.f, b.f) + 1, max(a.f, b.f) + 1)\n\t\tckmin(min_dif, dp_l.at(i).first_different);\n\t\tFOR(i, min(a.s, b.s) + 1, max(a.s, b.s) + 1)\n\t\tckmin(min_dif, dp_r.at(i).first_different);\n\t\treturn min_dif;\n\t};\n\tvpi best;\n\tF0R(i, sz(cands)) {\n\t\twhile (sz(cands[i]) > 1) {\n\t\t\tend(cands[i])[-2] =\n\t\t\t    better_pair(end(cands[i])[-2], end(cands[i])[-1]);\n\t\t\tcands[i].pop_back();\n\t\t}\n\t\tif (sz(cands[i])) {\n\t\t\tif (sz(best) && better_pair(best.bk, cands[i].bk) == best.bk)\n\t\t\t\tcontinue;\n\t\t\tbest.pb(cands[i].bk);\n\t\t\t// ret.pb();\n\t\t}\n\t}\n\tV<Info> ndp;\n\tF0R(i, sz(best)) {\n\t\tauto [l, r] = best[i];\n\t\tndp.pb({dp_l[l].k + dp_r[r].k,\n\t\t        i == 0 ? INT_MAX : first_different(best.at(i - 1), best.at(i)),\n\t\t        {l, r},\n\t\t        dp_l[l].r + dp_r[r].r});\n\t}\n\treturn ndp;\n\t// V<Info> ndp;\n\t// F0R(ops, max_ops + 1) {  // SLOW\n\t// \tint l = 0, r = 0;\n\t// \tint last_mn = INT_MAX;\n\t// \twhile (true) {\n\t// \t\tint mn = INT_MAX;\n\t// \t\tpi best;\n\t// \t\tFOR(i, l + 1, sz(dp_l))\n\t// \t\tif (dp_l[i].k + dp_r[r].k <= ops) {\n\t// \t\t\tif (ckmin(mn, dp_l[i].first_different)) { best = {0, i}; }\n\t// \t\t} else break;\n\t// \t\tFOR(j, r + 1, sz(dp_r))\n\t// \t\tif (dp_l[l].k + dp_r[j].k <= ops) {\n\t// \t\t\tif (ckmin(mn, dp_r[j].first_different)) { best = {1, j}; }\n\t// \t\t} else break;\n\t// \t\tif (mn == INT_MAX) {\n\t// \t\t\tif (dp_l[l].k + dp_r[r].k == ops) {\n\t// \t\t\t\tndp.pb({ops, last_mn, {l, r}, dp_l[l].r + dp_r[r].r});\n\t// \t\t\t}\n\t// \t\t\tbreak;\n\t// \t\t} else {\n\t// \t\t\tif (best.f == 0) l = best.s;\n\t// \t\t\telse r = best.s;\n\t// \t\t\tlast_mn = mn;\n\t// \t\t}\n\t// \t}\n\t// }\n\t// return ret;\n}\n\nvoid construct(int x, int p) {\n\tsum[x] = W[x];\n\tnum[x] = 1;\n\tdp[x] = {info_single(x, W[x])};\n\n\t// {{INT_MAX, RangeInfo{{x, Frac{W[x], 1}}, {INT_MAX, {}}}}};\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tconstruct(y, x);\n\t\t\tsum[x] += sum[y];\n\t\t\tnum[x] += num[y];\n\t\t\tauto ndp = conv(dp[x], dp[y]);\n\t\t\tswap(dp[x], stor[y]);\n\t\t\tswap(dp[x], ndp);\n\t\t}\n\tFrac f{sum[x], num[x]};\n\tif (!dp[x][0].r.greater_than(f)) return;\n\tif (sz(dp[x]) > 1) {\n\t\tassert(dp[x].at(1).k == 1);\n\t\tif (!dp[x].at(1).r.greater_than(f)) return;\n\t}\n\tint idx = 1;\n\twhile (idx < sz(dp[x]) && dp[x][idx].r.greater_or_equal(f)) ++idx;\n\tV<Info> ndp{dp[x][0]};\n\t{\n\t\tRangeInfo r{{dp[x][0].r.d0.f, f}, {INT_MAX, {}}};\n\t\tndp.pb({1, dp[x][0].r.first_dif(f).f, {-1, -1}, r});\n\t}\n\tif (idx < sz(dp[x])) {\n\t\tFOR(i, idx, sz(dp[x])) {\n\t\t\tassert(!dp[x][i].r.greater_or_equal(f));\n\t\t\tif (i == idx) {\n\t\t\t\tdp[x][i].first_different = dp[x][i].r.first_dif(f).f;\n\t\t\t\tndp.pb(dp[x][i]);\n\t\t\t} else {\n\t\t\t\tndp.pb(dp[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dp[x], ndp);\n}\n\nvoid reconstruct(vi &ans, int idx, int x, int p) {\n\tif (idx == 0) return;\n\tassert(idx < sz(dp[x]));\n\tauto [lhs, rhs] = dp[x].at(idx).prev_pair;\n\tif (lhs == -1) {\n\t\tans.pb(x);\n\t\treturn;\n\t}\n\tassert(lhs >= 0 && rhs >= 0);\n\tR0F(y_idx, sz(adj[x])) {\n\t\tint y = adj[x][y_idx];\n\t\tif (y == p) continue;\n\t\tassert(lhs < sz(stor[y]));\n\t\tassert(rhs < sz(dp[y]));\n\t\treconstruct(ans, rhs, y, x);\n\t\ttie(lhs, rhs) = stor[y].at(lhs).prev_pair;\n\t}\n\tassert(lhs == -1 && rhs == -1);\n}\n\nstruct NaiveSol {\n\tV<pair<int, Frac>> result;\n\tvi moves;\n};\n\ntemplate <class T> V<T> operator+(V<T> a, V<T> b) {\n\ta.ins(end(a), all(b));\n\treturn a;\n}\n\nNaiveSol operator+(NaiveSol a, NaiveSol b) {\n\tNaiveSol c{a.result + b.result, a.moves + b.moves};\n\tsor(c.result);\n\treturn c;\n}\n\nV<NaiveSol> brute(int x, int p) {\n\tsum[x] = W[x];\n\tnum[x] = 1;\n\tV<NaiveSol> dp;\n\tdp.pb({{{x, Frac{W[x], 1}}}, {}});\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tauto child_dp = brute(y, x);\n\t\t\tsum[x] += sum[y];\n\t\t\tnum[x] += num[y];\n\t\t\tV<NaiveSol> ndp;\n\t\t\tF0R(i, sz(dp)) F0R(j, sz(child_dp)) if (i + j <= K) {\n\t\t\t\tauto s = dp[i] + child_dp[j];\n\t\t\t\tif (i + j == sz(ndp)) {\n\t\t\t\t\tndp.pb(s);\n\t\t\t\t} else {\n\t\t\t\t\tif (s.result < ndp.at(i + j).result) ndp.at(i + j) = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp, ndp);\n\t\t}\n\t{\n\t\tauto result = dp.at(0).result;\n\t\teach(t, result) t.s = Frac{sum[x], num[x]};\n\t\tNaiveSol kill_sub{result, {x}};\n\t\tif (sz(dp) == 1) dp.pb(kill_sub);\n\t\telse if (kill_sub.result < dp[1].result) dp[1] = kill_sub;\n\t}\n\treturn dp;\n}\n\nvi solve1(int R) {\n\tauto cands = brute(R, 0);\n\tFOR(i, 1, sz(cands)) if (cands[i].result < cands[0].result) {\n\t\tcands[0] = cands[i];\n\t}\n\tvi ans = cands[0].moves;\n\treturn ans;\n}\n\nvi solve2(int R) {\n\tconstruct(R, 0);\n\tint k = dp[R].bk.k;\n\tvi ans;\n\treconstruct(ans, sz(dp[R]) - 1, R, 0);\n\tassert(sz(ans) == k);\n\treturn ans;\n}\n\n/**\n * Description: wraps a lambda so it can call itself\n * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\n */\n\nnamespace std {\n\ntemplate <class Fun> class y_combinator_result {\n\tFun fun_;\n\n  public:\n\ttemplate <class T>\n\texplicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\n\n\ttemplate <class... Args> decltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate <class Fun> decltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n}  // namespace std\n\nvoid y_comb_demo() {\n\tcout << y_combinator([](auto gcd, int a, int b) -> int {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t})(20, 30)\n\t     << ""\\n"";  // outputs 10\n}\n\nV<Frac> eval(int R, vi v) {\n\tV<Frac> res(N + 1);\n\t// dbg(""EVAL"", R, v);\n\ty_combinator([&](auto dfs_set, int x, int p, Frac val) -> void {\n\t\tif (!val.d) {\n\t\t\tif (find(all(v), x) != end(v)) val = Frac{sum[x], num[x]};\n\t\t}\n\t\t// dbg(""AT"", x, p, val);\n\t\tif (val.d) {\n\t\t\tres[x] = val;\n\t\t} else {\n\t\t\tres[x] = Frac{W[x], 1};\n\t\t}\n\t\tfor (int y : adj[x])\n\t\t\tif (y != p) dfs_set(y, x, val);\n\t})(R, 0, Frac{});\n\treturn res;\n}\n\nvoid solve(int tc, bool gen = true) {\n\t// dbg(""DOING"", tc);\n\tint R;\n\tif (gen) {\n\t\tN = 6;\n\t\t// N = rng_int(2, 5);\n\t\tR = rng_int(1, N);\n\t\tK = rng_int(0, N);\n\t} else {\n\t\tre(N, R, K);\n\t}\n\tW.rsz(N + 1);\n\tint mx = rng_int(1, 10);\n\tFOR(i, 1, N + 1) {\n\t\tif (gen) {\n\t\t\tW[i] = rng_int(1, mx);\n\t\t} else re(W[i]);\n\t}\n\tadj = V<vi>(N + 1);\n\tFOR(i, 2, N + 1) {\n\t\tif (gen) {\n\t\t\tint u = rng_int(1, i - 1), v = i;\n\t\t\tadj[u].pb(v), adj[v].pb(u);\n\t\t} else {\n\t\t\tdef(int, u, v);\n\t\t\tadj[u].pb(v), adj[v].pb(u);\n\t\t}\n\t}\n\t// dbg(tc);\n\t// if (tc == 47336) { dbg(N, R, K, W, adj); }\n\tdp = {};\n\tdp.rsz(N + 1);\n\tstor = {};\n\tstor.rsz(N + 1);\n\tsum = vl(N + 1);\n\tnum = vi(N + 1);\n\n\t// vi ans = solve1(R);\n\tvi ans = solve2(R);\n\t// ps(eval(R, ans));\n\t// if (!gen) {\n\tps(sz(ans));\n\tps(ans);\n\t// } else {\n\t// \tif (eval(R, ans) != eval(R, ans2)) {\n\t// \t\tdbg(""WHOOPS"", tc, N, R, K, W, adj);\n\t// \t\tdbg(ans, eval(R, ans));\n\t// \t\tdbg(ans2, eval(R, ans2));\n\t// \t\tFOR(i, 1, N + 1) dbg(i, dp[i]);\n\t// \t\texit(0);\n\t// \t}\n\t// }\n}\n\nint main() {\n\tsetIO();\n\t// RangeInfo r1{{1, Frac{2, 5}}, {2, Frac{2, 7}}};\n\t// RangeInfo r2{{3, Frac{2, 6}}, {4, Frac{2, 3}}};\n\t// auto r3 = r1 + r2;\n\t// dbg(r3.d0.f, r3.d1.f);\n\t// exit(0);\n\n\t// RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}\n\t// ps(Frac{1, 2} < Frac{2, 4});\n\t// ps(Frac{2, 4} < Frac{1, 2});\n\t// ps(Frac{1, 2} < Frac{2, 3});\n\t// exit(0);\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i, false);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['data structures', 'dp', 'greedy', 'trees']",3500
https://codeforces.com//contest/1620/problem/C,C. BA-String,You are given an integer k and a string s that consists only of characters a a lowercase Latin letter and an asterisk Each asterisk should be replaced with several from 0 to k inclusive lowercase Latin letters b Different asterisk can be replaced with different counts of letter b The result of the replacement is called a Two strings a and b are different if they either have different lengths or there exists such a position i that a i neq b i A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b Now consider all different BA strings and find the x th lexicographically smallest of them ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T, typename T_iterable>\nvector<pair<T, int>> run_length_encoding(const T_iterable &items) {\n    vector<pair<T, int>> encoding;\n    T previous;\n    int count = 0;\n\n    for (const T &item : items)\n        if (item == previous) {\n            count++;\n        } else {\n            if (count > 0)\n                encoding.emplace_back(previous, count);\n\n            previous = item;\n            count = 1;\n        }\n\n    if (count > 0)\n        encoding.emplace_back(previous, count);\n\n    return encoding;\n}\n\n\nvoid run_case() {\n    int N, K;\n    int64_t X;\n    string S;\n    cin >> N >> K >> X >> S;\n    X--;\n    vector<pair<char, int>> encoding = run_length_encoding<char>(S);\n    dbg(encoding);\n    vector<int64_t> bases;\n\n    for (auto &pr : encoding)\n        if (pr.first == \'*\')\n            bases.push_back(pr.second * K + 1);\n\n    dbg(bases);\n    vector<int64_t> B;\n\n    while (!bases.empty()) {\n        B.push_back(X % bases.back());\n        X /= bases.back();\n        bases.pop_back();\n    }\n\n    dbg(B);\n    string ans;\n\n    for (auto &pr : encoding)\n        if (pr.first == \'*\') {\n            ans += string(B.back(), \'b\');\n            B.pop_back();\n        } else {\n            ans += string(pr.second, pr.first);\n        }\n\n    cout << ans << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","['brute force', 'dp', 'greedy', 'implementation', 'math']",1800
https://codeforces.com//contest/1220/problem/D,D. Alex and Julian,Boy Dima gave Julian a birthday present set B consisting of positive integers However he didn t know that Julian hates sets but enjoys bipartite graphs more than anything else Julian was almost upset but her friend Alex said that he can build an undirected graph using this set in such a way let all integer numbers be vertices then connect any two i and j with an edge if i j belongs to B Unfortunately Julian doesn t like the graph that was built using B Alex decided to rectify the situation so he wants to erase some numbers from B so that graph built using the new set is bipartite The difficulty of this task is that the graph Alex has to work with has an infinite number of vertices and edges It is impossible to solve this task alone so Alex asks you for help Write a program that erases a subset of size from B so that graph constructed on the new set is bipartite Recall that graph is bipartite if all its vertices can be divided into two disjoint sets such that every edge connects a vertex from different sets ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#ifndef LOCAL\n#pragma GCC optimize(""O3"")\n#endif\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tint n; cin >> n;\n\tvll nums(n);\n\tfor (ll &x : nums) { cin >> x; }\n\t\n\tvector<vi> v2(64);\n\tfor (int i = 0; i < n; ++i) {\n\t\tll x = nums[i];\n\t\tint p = 0;\n\t\twhile (x % 2 == 0) {\n\t\t\tx /= 2;\n\t\t\t++p;\n\t\t}\n\t\tv2[p].push_back(i);\n\t}\n\t\n\tvector<int> best;\n\t\n\tfor (int i = 0; i < 64; ++i) {\n\t\tif (SZ(v2[i]) > SZ(best)) {\n\t\t\tbest = v2[i];\n\t\t}\n\t}\n\t\n\tcout << n - SZ(best) << ""\\n"";\n\tvector<bool> erase(n, true);\n\tfor (int x : best) { erase[x] = false; }\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (erase[i]) {\n\t\t\tcout << nums[i] << "" "";\n\t\t}\n\t}\n\tcout << ""\\n"";\n}\n']","['bitmasks', 'math', 'number theory']",1900
https://codeforces.com//contest/1182/problem/F,F. Maximum Sine,You have given integers a b p and q Let f x text abs text sin frac p q pi x Find minimum possible integer x that maximizes f x where a le x le b ,"[""#include<bits/stdc++.h>\n#include<stdint.h>\nusing namespace std;\n#define IOS {cin.tie(0);ios_base::sync_with_stdio(false);}\n#define N 300005\n#define int int64_t\nmap<int,int> mp;\n\nint32_t main(){\n\tIOS;\n\tint t,a,b,p,q,add = 0;\n\tcin >> t;\n\twhile(t--){\n\t\tmp.clear(); add = 0;\n\t\tcin >> a >> b >> p >> q;\n\t\tint gap = sqrt(b-a+1),mn = abs(2*p*a % (2*q) - q),best=a,wq = q;\n\t\tfor(int i=a;i<a+gap;i++) {\n\t\t\tif(mp.find(2*p*i % (2*q)) == mp.end())\n\t\t\t\tmp[2*p*i % (2*q)] = i;\n\t\t}\n\t\tauto it = mp.lower_bound(wq);\n\t\tauto it2 = mp.upper_bound(wq);\n\t\tif(it2!=mp.begin()){\n\t\t\t--it2;\n\t\t\tif(mn > abs(it2->first - wq)){\n\t\t\t\tmn = abs(it2->first - wq);\n\t\t\t\tbest = it2->second + add;\n\t\t\t}\n\t\t\tif(mn == abs(it2->first - wq)){\n\t\t\t\tbest = min(best,it2->second + add);\n\t\t\t}\n\t\t}\n\t\tif(it!=mp.end()) {\n\t\t\tif(mn > abs(it->first - wq)){\n\t\t\t\tmn = abs(it->first - wq);\n\t\t\t\tbest = it->second + add;\n\t\t\t}\n\t\t\tif(mn == abs(it->first - wq)){\n\t\t\t\tbest = min(best,it->second + add);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(a+gap < b-1000){\n\t\t\t\ta += gap;\n\t\t\t\tadd += gap;\n\t\t\t\twq = ((wq - 2*p*(gap)) % (2*q) + (2*q) ) % (2*q);\n\t\t\t\tit = mp.lower_bound(wq);\n\t\t\t\tit2 = mp.upper_bound(wq);\n\t\t\t\tif(it2!=mp.begin()){\n\t\t\t\t--it2;\n\t\t\t\tif(mn > abs(it2->first - wq)){\n\t\t\t\t\tmn = abs(it2->first - wq);\n\t\t\t\t\tbest = it2->second + add;\n\t\t\t\t}\n\t\t\t\tif(mn == abs(it2->first - wq)){\n\t\t\t\t\tbest = min(best,it2->second + add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(it!=mp.end()) {\n\t\t\t\tif(mn > abs(it->first - wq)){\n\t\t\t\t\tmn = abs(it->first - wq);\n\t\t\t\t\tbest = it->second + add;\n\t\t\t\t}\n\t\t\t\tif(mn == abs(it->first - wq)){\n\t\t\t\t\tbest = min(best,it->second + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(mn > abs(2*p*i % (2*q) - q)){\n\t\t\t\tmn = abs(2*p*i % (2*q) - q);\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\t\tcout << best << '\\n';\n\t}\n\treturn 0;\n}\n""]","['binary search', 'data structures', 'number theory']",2700
https://codeforces.com//contest/462/problem/A,A. Appleman and Easy Task,Toastman came up with a very easy task He gives it to Appleman but Appleman doesn t know how to solve it Can you help him Given a checkerboard Each cell of the board has either character or character Is it true that each cell of the board has even number of adjacent cells with Two cells of the board are adjacent if they share a side ,"['#include <cstdio>\n#ifdef _WIN32\n#define LLFORMAT ""%I64""\n#else\n#define LLFORMAT ""%ll""\n#endif\nconst int MAXN=105;\nint n;\nchar a[MAXN][MAXN];\nvoid init()\n{\n\tscanf(""%d"",&n);\n\tfor (int i=0;i<n;++i) scanf(""%s"",a[i]);\n}\nvoid solve()\n{\n\tconst int DR[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\tint fl=1;\n\tfor (int i=0;i<n;++i)\n\t\tfor (int j=0;j<n;++j)\n\t\t{\n\t\t\tint sum=0;\n\t\t\tfor (int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tint nx=i+DR[k][0],ny=j+DR[k][1];\n\t\t\t\tif (nx>=0&&nx<n&&ny>=0&&ny<n) sum+=(a[nx][ny]==\'o\');\n\t\t\t}\n\t\t\tif (sum%2) fl=0;\n\t\t}\n\tif (fl) printf(""YES\\n"");\n\telse printf(""NO\\n"");\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""A.in"",""r"",stdin);\n\tfreopen(""A.out"",""w"",stdout);\n#endif\n\tinit();\n\tsolve();\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);fclose(stdout);\n#endif\n\treturn 0;\n}\n']","['brute force', 'implementation']",1000
https://codeforces.com//contest/835/problem/B,B. The number on the board,Some natural number was written on the board Its sum of digits was not less than But you were distracted a bit and someone changed this number to replacing some digits with others It s known that the length of the number didn t change You have to find the minimum number of digits in which these two numbers can differ ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nchar s[1000010];\nint c[20];\nint main()\n{\n\tint k;\n\tscanf(""%d"",&k);\n\tscanf(""%s"",s+1);\n\tint n=strlen(s+1);\n\tint sum=0;\n\tint i;\n\tmemset(c,0,sizeof c);\n\tint ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tc[s[i]-\'0\']++;\n\t\tsum+=s[i]-\'0\';\n\t}\n\tsum=k-sum;\n\tfor(i=0;i<=9;i++)\n\t\twhile(sum>0&&c[i])\n\t\t{\n\t\t\tsum-=9-i;\n\t\t\tans++;\n\t\t\tc[i]--;\n\t\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']",['greedy'],1100
https://codeforces.com//contest/1713/problem/D,D. Tournament Countdown,There was a tournament consisting of 2 n contestants The 1 st contestant competed with the 2 nd the 3 rd competed with the 4 th and so on After that the winner of the first match competed with the winner of second match etc The tournament ended when there was only one contestant left who was declared the winner of the tournament Such a tournament scheme is known as the single elimination tournament You don t know the results but you want to find the winner of the tournament In one query you select two integers a and b which are the indices of two contestants The jury will return 1 if a won more matches than b 2 if b won more matches than a or 0 if their number of wins was equal Find the winner in no more than left lceil frac 1 3 cdot 2 n 1 right rceil queries Here lceil x rceil denotes the value of x rounded up to the nearest integer Note that the tournament is long over meaning that the results are fixed and do not depend on your queries ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vi arr(1<<n);\n    iota(all(arr), 1);\n\n    while (sz(arr) > 2) {\n        vi next;\n\n        for (int i = 0; i < sz(arr); i += 4) {\n            cout << ""? "" << arr[i] << "" "" << arr[i+2] << endl;\n            int res;\n            cin >> res;\n\n            if (res == 0) {\n                next.pb(arr[i+1]);\n                next.pb(arr[i+3]);\n            }\n            else if (res == 1) {\n                next.pb(arr[i]);\n                next.pb(arr[i+3]);\n            }\n            else {\n                next.pb(arr[i+2]);\n                next.pb(arr[i+1]);\n            }\n        }\n        arr = next;\n    }\n    cout << ""? "" << arr[0] << \' \' << arr[1] << endl;\n    int res;\n    cin >> res;\n    if (res == 1) {\n        cout << ""! "" << arr[0] << endl;\n    }\n    else {\n        cout << ""! "" << arr[1] << endl;\n    }\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""input.in"", ""r"", stdin);\n    // freopen(""input.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}']","['constructive algorithms', 'greedy', 'interactive', 'number theory', 'probabilities']",1800
https://codeforces.com//contest/875/problem/A,A. Classroom Watch,Eighth grader Vova is on duty today in the class After classes he went into the office to wash the board and found on it the number He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that is the answer to the arithmetic task for first graders In the textbook a certain was given The task was to add to the sum of the digits of the number written in decimal numeral system Since the number on the board was small Vova quickly guessed which could be in the textbook Now he wants to get a program which will search for arbitrary values of the number for all suitable values of or determine that such does not exist Write such a program for Vova ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,x[1000],m;\ninline bool check(int p)\n{\n\tint k=p;\n\twhile(p)\n\t  {\n\t   k+=p%10;\n\t   p/=10;\n\t  }\n\treturn k==n;\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i;\n\tscanf(""%d"",&n);\n\tfor(i=n-100;i<=n;i++)\n\t  if(check(i))\n\t    x[++m]=i;\n\tprintf(""%d\\n"",m);\n\tfor(i=1;i<=m;i++)\n\t  printf(""%d\\n"",x[i]);\n\treturn 0;\n}\n']","['brute force', 'math']",1200
https://codeforces.com//contest/1941/problem/B,B. Rudolf and 121,Rudolf has an array a of n integers the elements are numbered from 1 to n In one operation he can choose an index i 2 le i le n 1 and assign a i 1 a i 1 1 a i a i 2 a i 1 a i 1 1 Rudolf can apply this operation any number of times Any index i can be used zero or more times Can he make all the elements of the array equal to zero using this operation ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n ; cin >> n ;\n    int a[ n ] ;\n    FOR( i , n ) cin >> a[ i ] ;\n    for( int i = 0 ; i < n - 2 ; i ++ ){\n    \tif( a[ i ] >= 0 ){\n    \t\ta[ i + 1 ] = ( a[ i + 1 ] - 2 * a[ i ] ) ;\n    \t\ta[ i + 2 ] = a[ i + 2 ] - a[ i ] ;\n    \t\ta[ i ] = 0 ;\n\t\t}\n\t\telse{\n\t\t\tNO ; return ;\n\t\t}\n\t}\n\tif( a[ n - 1 ] == a[ n - 2 ] && a[ n - 1 ] == 0 ){\n\t\tYES ; \n\t} else NO ; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']","['brute force', 'dp', 'greedy', 'math']",1000
https://codeforces.com//contest/1117/problem/D,D. Magic Gems,Reziba has many magic gems Each magic gem can be split into M normal gems The amount of space each magic and normal gem takes is 1 unit A normal gem cannot be split Reziba wants to choose a set of magic gems and split some of them so the total space occupied by the resulting set of gems is N units If a magic gem is chosen and split it takes M units of space since it is split into M gems if a magic gem is not split it takes 1 unit How many different configurations of the resulting set of gems can Reziba have such that the total amount of space taken is N units Print the answer modulo 1000000007 10 9 7 Two configurations are considered different if the number of magic gems Reziba takes to form them differs or the indices of gems Reziba has to split differ ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int MAT=101;\nstruct Mat { ll v[MAT][MAT]; Mat(){ZERO(v);};};\nll mo=1000000007;\n\nMat mulmat(Mat& a,Mat& b,int n=MAT) {\n\tll mo2=4*mo*mo;\n\tint x,y,z; Mat r;\n\tFOR(x,n) FOR(y,n) r.v[x][y]=0;\n\tFOR(x,n) FOR(z,n) FOR(y,n) {\n\t\tr.v[x][y] += a.v[x][z]*b.v[z][y];\n\t\tif(r.v[x][y]>mo2) r.v[x][y] -= mo2;\n\t}\n\tFOR(x,n) FOR(y,n) r.v[x][y]%=mo;\n\treturn r;\n}\n\nMat powmat(ll p,Mat a,int n=MAT) {\n\tint i,x,y; Mat r;\n\tFOR(x,n) FOR(y,n) r.v[x][y]=0;\n\tFOR(i,n) r.v[i][i]=1;\n\twhile(p) {\n\t\tif(p%2) r=mulmat(r,a,n);\n\t\ta=mulmat(a,a,n);\n\t\tp>>=1;\n\t}\n\treturn r;\n}\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nll N,M;\n\nMat A;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\t\n\tif(N<M) return _P(""1\\n"");\n\t\n\tA.v[0][0]=A.v[0][M-1]=1;\n\tfor(i=1;i<M;i++) A.v[i][i-1]=1;\n\tMat B=powmat(N-(M-1),A,M);\n\t\n\tll ret=0;\n\tFOR(i,M) ret+=B.v[0][i];\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']","['dp', 'math', 'matrices']",2100
https://codeforces.com//contest/1567/problem/D,D. Expression Evaluation Error,On the board Bob wrote n positive integers in base 10 with sum s i e in decimal numeral system Alice sees the board but accidentally interprets the numbers on the board as base 11 integers and adds them up in base 11 What numbers should Bob write on the board so Alice s sum is as large as possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint pw[200];\nvoid solve() {\n\tint s, n;\n\tscanf(""%d%d"", &s, &n);\n\tint s2 = s;\n\tvector<int> d;\n\tint cnt = 0;\n\twhile (s) {\n\t\tcnt += s % 10;\n\t\td.push_back(s % 10);\n\t\ts /= 10;\n\t}\n\twhile (cnt < n) {\n\t\tfor (int j = 1; j < d.size(); j++) {\n\t\t\tif (d[j] > 0) {\n\t\t\t\td[j] -= 1;\n\t\t\t\td[j - 1] += 10;\n\t\t\t\tcnt += 9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ans;\n\tfor (int j = 0; j < d.size(); j++) {\n\t\tfor (int k = 0; k < d[j]; k++)\n\t\t\tans.push_back(pw[j]);\n\t}\n\treverse(ans.begin(), ans.end());\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tprintf(""%d "", ans[i]);\n\t\ts2 -= ans[i];\n\t}\n\tprintf(""%d\\n"", s2);\n}\n\nint main() {\n\tpw[0] = 1;\n\tfor (int i = 1; i < 10; i++) pw[i] = pw[i - 1] * 10;\n\tint T;\n\tscanf(""%d"", &T);\n\tfor (int i = 0; i < T; i++) solve();\n}']","['constructive algorithms', 'greedy', 'implementation', 'math']",2000
https://codeforces.com//contest/1472/problem/F,F. New Year's Puzzle,Polycarp got the following problem given a grid strip of size 2 times n some cells of it are blocked You need to check if it is possible to tile all free cells using the 2 times 1 and 1 times 2 tiles dominoes For example if n 5 and the strip looks like this black cells are blocked Then it can be tiled for example using two vertical and two horizontal tiles as in the picture below different tiles are marked by different colors And if n 3 and the strip looks like this It is impossible to tile free cells Polycarp easily solved this task and received his New Year s gift Can you solve it ,"['/**\n ____ ____ ____ ____ ____\n||a |||t |||o |||d |||o ||\n||__|||__|||__|||__|||__||\n|/__\\|/__\\|/__\\|/__\\|/__\\|\n\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M_MAX = 200002;\n\nint t;\n\nint n, m;\n\nstruct Block\n{\n    int a, b;\n};\n\nbool operator < (const Block &x, const Block &y)\n{\n    return x.b < y.b;\n}\n\nBlock v[M_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n >> m;\n        for(int i = 1; i <= m; i++)\n            cin >> v[i].a >> v[i].b;\n        sort(v + 1, v + m + 1);\n        bool complete = true;\n        bool answer = true;\n        for(int i = 1; i <= m && answer == true; i++)\n        {\n            if(v[i].b == v[i - 1].b)\n                continue;\n            if(i < m && v[i].b == v[i + 1].b)\n            {\n                answer = complete;\n                continue;\n            }\n            if(complete == true)\n            {\n                complete = false;\n                continue;\n            }\n            if(v[i].a == v[i - 1].a)\n            {\n                if((v[i].b - v[i - 1].b) % 2 == 0)\n                    answer = false;\n                else\n                    complete = true;\n            }\n            else\n            {\n                if((v[i].b - v[i - 1].b) % 2 == 1)\n                    answer = false;\n                else\n                    complete = true;\n            }\n        }\n        if(complete == false)\n            answer = false;\n        if(answer == true)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    return 0;\n}\n']","['brute force', 'dp', 'graph matchings', 'greedy', 'sortings']",2100
https://codeforces.com//contest/1251/problem/C,C. Minimize The Integer,You are given a huge integer a consisting of n digits n is between 1 and 3 cdot 10 5 inclusive It may contain leading zeros You can swap two digits on adjacent neighboring positions if the swapping digits are of different parity that is they have different remainders when divided by 2 For example if a 032867235 you can get the following integers in a single operation 302867235 if you swap the first and the second digits 023867235 if you swap the second and the third digits 032876235 if you swap the fifth and the sixth digits 032862735 if you swap the sixth and the seventh digits 032867325 if you swap the seventh and the eighth digits Note that you can t swap digits on positions 2 and 4 because the positions are not adjacent Also you can t swap digits on positions 3 and 4 because the digits have the same parity You can perform any number possibly zero of such operations Find the minimum integer you can obtain ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid solve_case() {\n    string A;\n    cin >> A;\n    string even, odd, answer;\n\n    for (char c : A)\n        if ((c - '0') % 2 == 0)\n            even += c;\n        else\n            odd += c;\n\n    answer.resize(A.size());\n    merge(even.begin(), even.end(), odd.begin(), odd.end(), answer.begin());\n    cout << answer << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0)\n        solve_case();\n}\n""]","['greedy', 'two pointers']",1600
https://codeforces.com//contest/198/problem/A,A. About Bacteria,Qwerty the Ranger took up a government job and arrived on planet Mars He should stay in the secret lab and conduct some experiments on bacteria that have funny and abnormal properties The job isn t difficult but the salary is high At the beginning of the first experiment there is a single bacterium in the test tube Every second each bacterium in the test tube divides itself into bacteria After that some abnormal effects create more bacteria in the test tube Thus if at the beginning of some second the test tube had bacteria then at the end of the second it will have bacteria The experiment showed that after seconds there were exactly bacteria and the experiment ended at this point For the second experiment Qwerty is going to sterilize the test tube and put there bacteria He hasn t started the experiment yet but he already wonders how many seconds he will need to grow at least bacteria The ranger thinks that the bacteria will divide by the same rule as in the first experiment Help Qwerty and find the minimum number of seconds needed to get a tube with at least bacteria in the second experiment ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tint64 k, n, b, t;\n\tcin >> k >> b >> n >> t;\n\tint64 cur = 1;\n\tint64 res = n;\n\twhile (res > 0 && cur * k + b <= t) {\n\t\tres --;\n\t\tcur = cur * k + b;\t\t\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n']","['implementation', 'math']",1700
https://codeforces.com//contest/1120/problem/C,C. Compress String,Suppose you are given a string s of length n consisting of lowercase English letters You need to compress it using the smallest possible number of coins To compress the string you have to represent s as a concatenation of several non empty strings s t 1 t 2 ldots t k The i th of these strings should be encoded with one of the two ways if t i 1 meaning that the current string consists of a single character you can encode it paying a coins if t i is a substring of t 1 t 2 ldots t i 1 then you can encode it paying b coins A string x is a substring of a string y if x can be obtained from y by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end So your task is to calculate the minimum possible number of coins you need to spend in order to compress the given string s ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=5007;\nconst int inf=1e9;\n\nint n, ka, kb;\n\nchar wcz[nax];\n\nint dp[nax][nax];\n\nint dp2[nax];\n\nint main()\n{\n\tscanf(""%d%d%d"", &n, &ka, &kb);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif (wcz[i]==wcz[j])\n\t\t\t\tdp[i][j]=dp[i-1][j-1]+1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tdp2[i]=dp2[i-1]+ka;\n\t\tfor (int j=1; j<i; j++)\n\t\t{\n\t\t\tint x=min(i-j, dp[i][j]);\n\t\t\tdp2[i]=min(dp2[i], dp2[i-x]+kb);\n\t\t}\n\t}\n\tprintf(""%d\\n"", dp2[n]);\n\treturn 0;\n}\n']","['dp', 'strings']",2100
https://codeforces.com//contest/1808/problem/E1,E1. Minibuses on Venus  easy version ,Maxim is a minibus driver on Venus To ride on Maxim s minibus you need a ticket Each ticket has a number consisting of n digits However as we know the residents of Venus use a numeral system with base k rather than the decimal system Therefore the ticket number can be considered as a sequence of n integers from 0 to k 1 inclusive The residents of Venus consider a ticket to be if there is a digit on it that is equal to the sum of the remaining digits modulo k For example if k 10 then the ticket 7135 is lucky because 7 1 5 equiv 3 pmod 10 On the other hand the ticket 7136 is not lucky because no digit is equal to the sum of the others modulo 10 Once while on a trip Maxim wondered how many lucky tickets exist At the same time Maxim understands that this number can be very large so he is interested only in the answer modulo some prime number m ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch < \'0\' || ch > \'9\') {\n    if (ch == \'-\') f = -1;\n    ch = getchar();\n  }\n  while (ch >= \'0\' && ch <= \'9\') {\n    x = x * 10 + ch - \'0\';\n    ch = getchar();\n  }\n  return x * f;\n}\n\nll n;\nint k, mod;\n\ninline int addmod(int x) { return x >= mod ? x - mod : x; }\ninline int submod(int x) { return x < 0 ? x + mod : x; }\nint fpow(int x, ll y) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n    y /= 2;\n  }\n  return ans;\n}\n\nsigned main() {\n  scanf(""%lld%d%d"", &n, &k, &mod);\n  if (n == 1) {\n    printf(""%d\\n"", 1 % mod);\n    return 0;\n  }\n  if (k % 2) {\n    int fl = 1;\n    if (n % 2 == 1) fl = mod - 1;\n    int ans1 = 1ll * (1ll * fpow(k - 1, n) - fl + mod) % mod * fpow(k, mod - 2) % mod;\n    int ans2 = 0;\n    for (int i = 0; i < k; i++) {\n      if (1ll * n % k * i % k == 2 * i % k) {\n        ans2++;\n      }\n    }\n    ans1 = (1ll * ans1 * k + 1ll * fl * ans2) % mod;\n    ans1 = submod(fpow(k, n) - ans1);\n    printf(""%d\\n"", ans1);\n    return 0;\n  } else {\n    int fl = fpow(2, n);\n    if (n % 2 == 1) fl = submod(-fl);\n    int ans1 = 1ll * (1ll * fpow(k - 2, n) - fl + mod) % mod * fpow(k, mod - 2) % mod;\n    int ans2 = 0;\n    for (int i = 0; i * 2 < k; i++) {\n      int u = 1ll * n % k * i % k;\n      if (u == 2 * i % k) ans2++;\n      if ((u + k / 2) % k == 2 * i % k) ans2++;\n    }\n    //\tprintf(""ans1=%d,ans2=%d,fl=%d\\n"",ans1,ans2,fl);\n    ans2 = 1ll * ans2 * fpow(2, mod - 2) % mod;\n    ans1 = (1ll * ans1 * (k / 2) + 1ll * fl * ans2) % mod;\n    ans1 = submod(1ll * fpow(k, n) * fpow(2, mod - 2) % mod - ans1);\n    printf(""%d\\n"", ans1);\n    return 0;\n  }\n  return 0;\n}\n']","['combinatorics', 'divide and conquer', 'dp']",2200
https://codeforces.com//contest/1551/problem/D2,D2. Domino  hard version ,There s a table of n times m cells n rows and m columns The value of n cdot m is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to place frac nm 2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nconst int N = 105;\n\nvector<int> dx = {1,-1,0,0},dy = {0,0,1,-1};\n\nint can[N][N][26];\n\nint _runtimeTerror_()\n{\n    int n,m,k;\n    cin >> n >> m >> k;\n    vector<vector<char>> ans(n,vector<char>(m));\n    for(int i=0;i<n;++i)\n        for(int j=0;j<m;++j)\n            for(int k=0;k<26;++k)\n                can[i][j][k] = 0;\n\n    auto assign = [&](int x,int y,int c)\n    {\n        ans[x][y] = char(c + \'a\');\n        for(int i=0;i<4;++i)\n        {\n            int u = x + dx[i],v = y + dy[i];\n            if(u >= 0 && u < n && v >= 0 && v < m)\n                can[u][v][c] = 1;\n        }\n    };\n    auto get = [&](vector<pair<pii,pii>> &a)\n    {\n        for(auto &[u,v]:a)\n        {\n            vector<int> cant(26,0);\n            auto [x,y] = u;\n            auto [xx,yy] = v;\n            for(int i=0;i<26;++i)\n                cant[i] = can[x][y][i] || can[xx][yy][i];\n            for(int i=0;i<26;++i)\n            {\n                if(cant[i] == 0)\n                {\n                    assign(x,y,i);\n                    assign(xx,yy,i);\n                    break;\n                }\n            }\n        }\n    };\n    vector<pair<pii,pii>> a;\n    if(n % 2 == 0 && m % 2 == 0)\n    {\n        if(k % 2 == 0)\n        {\n            cout << ""YES\\n"";\n            for(int i=0;i<n;i+=2)\n            {\n                for(int j=0;j<m;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n        }\n        else\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n    }\n    else if(n % 2 == 1 && m % 2 == 0)\n    {\n        k -= m/2;\n        if(k >= 0 && k % 2 == 0)\n        {\n            for(int j=0;j<m;j+=2)\n            {\n                a.push_back({{n-1,j},{n-1,j+1}});\n            }\n            for(int i=0;i<n-1;i+=2)\n            {\n                for(int j=0;j<m;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n            cout << ""YES\\n"";\n        }\n        else\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n    }\n    else if(n % 2 == 0 && m % 2 == 1)\n    {\n        if(k % 2 == 0 && k <= n * m / 2 - n / 2)\n        {\n            cout << ""YES\\n"";\n            for(int i=0;i<n;i+=2)\n                a.push_back({{i,m-1},{i+1,m-1}});\n            for(int i=0;i<n;i+=2)\n            {\n                for(int j=0;j<m-1;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n        }\n        else\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n    }\n    get(a);\n    for(int i=0;i<n;++i)\n    {\n        for(int j=0;j<m;++j)\n            cout << ans[i][j];\n        cout << ""\\n"";\n    }\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","['constructive algorithms', 'implementation', 'math']",2100
https://codeforces.com//contest/1421/problem/E,E. Swedish Heroes,While playing yet another strategy game Mans has recruited n Swedish heroes whose powers which can be represented as an array a Unfortunately not all of those mighty heroes were created as capable as he wanted so that he decided to do something about it In order to accomplish his goal he can pick two consecutive heroes with powers a i and a i 1 remove them and insert a hero with power a i a i 1 back in the same position For example if the array contains the elements 5 6 7 8 he can pick 6 and 7 and get 5 6 7 8 5 13 8 After he will perform this operation n 1 times Mans will end up having only one hero He wants his power to be as big as possible What s the largest possible power he can achieve ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing llint = long long;\n\ninline void err() { cerr << endl; }\n\ntemplate<typename hd, typename... tl> void err(hd a, tl... b) {\n#ifdef KH_CODE\n\tcerr << a << \' \'; err(b...);\n#endif\n}\n\ntemplate<typename hd, typename tl> void chkmin(hd& a, tl b) {\n\tif(b < a) a = b;\n}\n\ntemplate<typename hd, typename tl> void chkmax(hd& a, tl b) {\n\tif(a < b) a = b;\n}\n\nconst int MX = 200005;\n\nllint a[MX];\nvector <pair<llint, int>> V;\nvector<int> buf;\n\nint main() {\n#ifdef KH_CODE\n\tfreopen(""in.txt"", ""r"", stdin);\n\tfreopen(""out.txt"", ""w"", stdout);\n#endif\n\n\tios_base::sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tllint tot = 0, rlt = -LLONG_MAX;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ttot += a[i];\n\t\tV.push_back({a[i], i});\n\t}\n\tif(n == 1) cout << a[0] << endl;\n\telse if(n == 2) cout << -(a[0] + a[1]) << endl;\n\telse if(n == 3) cout << max(a[0] + a[1] - a[2], a[2] + a[1] - a[0]) << endl;\n\telse {\n\t\tsort(V.begin(), V.end());\n\t\tint s = 2 - n % 3;\n\t\ts = n - s;\n\t\ts %= 3;\n\t\tint c = 0;\n\t\tllint cur = 0;\n\t\twhile(s <= n) {\n\t\t\twhile(c < s) cur += V[c++].first;\n\t\t\tif(abs(s * 2 - n) <= 1) {\n\t\t\t\tllint tp = 0;\n\t\t\t\tbuf.clear();\n\t\t\t\tfor(int i = 0; i < s; i++) {\n\t\t\t\t\ttp += V[i].first;\n\t\t\t\t\tbuf.push_back(V[i].second);\n\t\t\t\t}\n\t\t\t\tsort(buf.begin(), buf.end());\n\t\t\t\tbool ok = 0;\n\t\t\t\tfor(int i = 0; i < buf.size() - 1; i++) if(buf[i + 1] - buf[i] != 2) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ok) rlt = max(rlt, tot -  tp * 2);\n\t\t\t\telse rlt = max(rlt, tot - 2 * (tp - V[s - 1].first + V[s].first));\n\t\t\t}\n\t\t\telse rlt = max(rlt, tot - 2 * cur);\n\t\t\ts += 3;\n\t\t}\n\t\tcout << rlt << endl;\n\t}\n\n\treturn 0;\n}\n\n']","['brute force', 'dp', 'implementation']",2700
https://codeforces.com//contest/1334/problem/G,G. Substring Search,You are given a permutation p consisting of exactly 26 integers from 1 to 26 since it is a permutation each integer from 1 to 26 occurs in p exactly once and two strings s and t consisting of lowercase Latin letters A substring t of string t is an of string s if the following conditions are met t s for each i in 1 s either s i t i or p idx s i idx t i where idx c is the index of character c in Latin alphabet idx text a 1 idx text b 2 idx text z 26 For example if p 1 2 p 2 3 p 3 1 s text abc t text abcaaba then three substrings of t are occurences of s they are t text abc t text bca and t text aba For each substring of t having length equal to s check if it is an of s ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int md = 998244353;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (long long) x * y % md;\n}\n\ninline int power(int x, int y) {\n  int res = 1;\n  for (; y; y >>= 1, x = mul(x, x)) {\n    if (y & 1) {\n      res = mul(res, x);\n    }\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) {\n    a += md;\n  }\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += md;\n  }\n  return u;\n}\n\nnamespace ntt {\nint base = 1, root = -1, max_base = -1;\nvector<int> rev = {0, 1}, roots = {0, 1};\n\nvoid init() {\n  int temp = md - 1;\n  max_base = 0;\n  while (temp % 2 == 0) {\n    temp >>= 1;\n    ++max_base;\n  }\n  root = 2;\n  while (true) {\n    if (power(root, 1 << max_base) == 1 && power(root, 1 << max_base - 1) != 1) {\n      break;\n    }\n    ++root;\n  }\n}\n\nvoid ensure_base(int nbase) {\n  if (max_base == -1) {\n    init();\n  }\n  if (nbase <= base) {\n    return;\n  }\n  assert(nbase <= max_base);\n  rev.resize(1 << nbase);\n  for (int i = 0; i < 1 << nbase; ++i) {\n    rev[i] = rev[i >> 1] >> 1 | (i & 1) << nbase - 1;\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    int z = power(root, 1 << max_base - 1 - base);\n    for (int i = 1 << base - 1; i < 1 << base; ++i) {\n      roots[i << 1] = roots[i];\n      roots[i << 1 | 1] = mul(roots[i], z);\n    }\n    ++base;\n  }\n}\n\nvoid dft(vector<int> &a) {\n  int n = a.size(), zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; ++i) {\n    if (i < rev[i] >> shift) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int i = 1; i < n; i <<= 1) {\n    for (int j = 0; j < n; j += i << 1) {\n      for (int k = 0; k < i; ++k) {\n        int x = a[j + k], y = mul(a[j + k + i], roots[i + k]);\n        a[j + k] = (x + y) % md;\n        a[j + k + i] = (x + md - y) % md;\n      }\n    }\n  }\n}\n\nvector<int> multiply(vector<int> a, vector<int> b) {\n  int need = a.size() + b.size() - 1, nbase = 0;\n  while (1 << nbase < need) {\n    ++nbase;\n  }\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  a.resize(sz);\n  b.resize(sz);\n  bool equal = a == b;\n  dft(a);\n  if (equal) {\n    b = a;\n  } else {\n    dft(b);\n  }\n  int inv_sz = inv(sz);\n  for (int i = 0; i < sz; ++i) {\n    a[i] = mul(mul(a[i], b[i]), inv_sz);\n  }\n  reverse(a.begin() + 1, a.end());\n  dft(a);\n  a.resize(need);\n  return a;\n}\n\nvector<int> inverse(vector<int> a) {\n  int n = a.size(), m = n + 1 >> 1;\n  if (n == 1) {\n    return vector<int>(1, inv(a[0]));\n  } else {\n    vector<int> b = inverse(vector<int>(a.begin(), a.begin() + m));\n    int need = n << 1, nbase = 0;\n    while (1 << nbase < need) {\n      ++nbase;\n    }\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    dft(a);\n    dft(b);\n    int inv_sz = inv(sz);\n    for (int i = 0; i < sz; ++i) {\n      a[i] = mul(mul(md + 2 - mul(a[i], b[i]), b[i]), inv_sz);\n    }\n    reverse(a.begin() + 1, a.end());\n    dft(a);\n    a.resize(n);\n    return a;\n  }\n}\n}\n\nusing ntt::multiply;\nusing ntt::inverse;\n\nvector<int>& operator += (vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    add(a[i], b[i]);\n  }\n  return a;\n}\n\nvector<int> operator + (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c += b;\n}\n\nvector<int>& operator -= (vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    sub(a[i], b[i]);\n  }\n  return a;\n}\n\nvector<int> operator - (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c -= b;\n}\n\nvector<int>& operator *= (vector<int> &a, const vector<int> &b) {\n  if (min(a.size(), b.size()) < 128) {\n    vector<int> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < c.size(); ++i) {\n      for (int j = 0; j < b.size(); ++j) {\n        add(a[i + j], mul(c[i], b[j]));\n      }\n    }\n  } else {\n    a = multiply(a, b);\n  }\n  return a;\n}\n\nvector<int> operator * (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c *= b;\n}\n\nvector<int>& operator /= (vector<int> &a, const vector<int> &b) {\n  int n = a.size(), m = b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<int> c = b;\n    reverse(a.begin(), a.end());\n    reverse(c.begin(), c.end());\n    c.resize(n - m + 1);\n    a *= inverse(c);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\nvector<int> operator / (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c /= b;\n}\n\nvector<int>& operator %= (vector<int> &a, const vector<int> &b) {\n  int n = a.size(), m = b.size();\n  if (n >= m) {\n    vector<int> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; ++i) {\n      sub(a[i], c[i]);\n    }\n  }\n  return a;\n}\n\nvector<int> operator % (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c %= b;\n}\n\nvector<int> derivative(const vector<int> &a) {\n  int n = a.size();\n  vector<int> b(n - 1);\n  for (int i = 1; i < n; ++i) {\n    b[i - 1] = mul(a[i], i);\n  }\n  return b;\n}\n\nvector<int> primitive(const vector<int> &a) {\n  int n = a.size();\n  vector<int> b(n + 1), invs(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    invs[i] = i == 1 ? 1 : mul(md - md / i, invs[md % i]);\n    b[i] = mul(a[i - 1], invs[i]);\n  }\n  return b;\n}\n\nvector<int> logarithm(const vector<int> &a) {\n  vector<int> b = primitive(derivative(a) * inverse(a));\n  b.resize(a.size());\n  return b;\n}\n\nvector<int> exponent(const vector<int> &a) {\n  vector<int> b(1, 1);\n  while (b.size() < a.size()) {\n    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    add(c[0], 1);\n    vector<int> old_b = b;\n    b.resize(b.size() << 1);\n    c -= logarithm(b);\n    c *= old_b;\n    for (int i = b.size() >> 1; i < b.size(); ++i) {\n      b[i] = c[i];\n    }\n  }\n  b.resize(a.size());\n  return b;\n}\n\nvector<int> power(const vector<int> &a, int m) {\n  int n = a.size(), p = -1;\n  vector<int> b(n);\n  for (int i = 0; i < n; ++i) {\n    if (a[i]) {\n      p = i;\n      break;\n    }\n  }\n  if (p == -1) {\n    b[0] = !m;\n    return b;\n  }\n  if ((long long) m * p >= n) {\n    return b;\n  }\n  int mu = power(a[p], m), di = inv(a[p]);\n  vector<int> c(n - m * p);\n  for (int i = 0; i < n - m * p; ++i) {\n    c[i] = mul(a[i + p], di);\n  }\n  c = logarithm(c);\n  for (int i = 0; i < n - m * p; ++i) {\n    c[i] = mul(c[i], m);\n  }\n  c = exponent(c);\n  for (int i = 0; i < n - m * p; ++i) {\n    b[i + m * p] = mul(c[i], mu);\n  }\n  return b;\n}\n\nvector<int> sqrt(const vector<int> &a) {\n  vector<int> b(1, 1);\n  while (b.size() < a.size()) {\n    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<int> old_b = b;\n    b.resize(b.size() << 1);\n    c *= inverse(b);\n    for (int i = b.size() >> 1; i < b.size(); ++i) {\n      b[i] = mul(c[i], md + 1 >> 1);\n    }\n  }\n  b.resize(a.size());\n  return b;\n}\n\nvector<int> multiply_all(int l, int r, vector<vector<int>> &all) {\n  if (l > r) {\n    return vector<int>();\n  } else if (l == r) {\n    return all[l];\n  } else {\n    int y = l + r >> 1;\n    return multiply_all(l, y, all) * multiply_all(y + 1, r, all);\n  }\n}\n\nvector<int> evaluate(const vector<int> &f, const vector<int> &x) {\n  int n = x.size();\n  if (!n) {\n    return vector<int>();\n  }\n  vector<vector<int>> up(n * 2);\n  for (int i = 0; i < n; ++i) {\n    up[i + n] = vector<int>{(md - x[i]) % md, 1};\n  }\n  for (int i = n - 1; i; --i) {\n    up[i] = up[i << 1] * up[i << 1 | 1];\n  }\n  vector<vector<int>> down(n * 2);\n  down[1] = f % up[1];\n  for (int i = 2; i < n * 2; ++i) {\n    down[i] = down[i >> 1] % up[i];\n  }\n  vector<int> y(n);\n  for (int i = 0; i < n; ++i) {\n    y[i] = down[i + n][0];\n  }\n  return y;\n}\n\nvector<int> interpolate(const vector<int> &x, const vector<int> &y) {\n  int n = x.size();\n  vector<vector<int>> up(n * 2);\n  for (int i = 0; i < n; ++i) {\n    up[i + n] = vector<int>{(md - x[i]) % md, 1};\n  }\n  for (int i = n - 1; i; --i) {\n    up[i] = up[i << 1] * up[i << 1 | 1];\n  }\n  vector<int> a = evaluate(derivative(up[1]), x);\n  for (int i = 0; i < n; ++i) {\n    a[i] = mul(y[i], inv(a[i]));\n  }\n  vector<vector<int>> down(n * 2);\n  for (int i = 0; i < n; ++i) {\n    down[i + n] = vector<int>(1, a[i]);\n  }\n  for (int i = n - 1; i; --i) {\n    down[i] = down[i << 1] * up[i << 1 | 1] + down[i << 1 | 1] * up[i << 1];\n  }\n  return down[1];\n}\n\nconst int N=201000;\nll val[1010],c[5][N],d[5][N],ss[N];\nint q,p[1010];\nchar s[N],t[N];\n\n\nint main() {\n\trep(i,0,26) val[i]=rnd(mod);\n\trep(i,0,26) {\n\t\tint q;\n\t\tscanf(""%d"",&q);\n\t\tp[q-1]=i;\n\t}\n\tscanf(""%s"",t);\n\tscanf(""%s"",s);\n\tint n=strlen(s);\n\trep(i,0,n) {\n\t\tint id=s[i]-\'a\';\n\t\tll u=val[id],v=val[p[id]];\n\t\tc[4][i]=1;\n\t\tc[3][i]=(-2*u-2*v)%mod;\n\t\tc[2][i]=(u*u+4*u*v+v*v)%mod;\n\t\tc[1][i]=-2*u*v%mod*(u+v)%mod;\n\t\tc[0][i]=u*u%mod*v%mod*v%mod;\n\t}\n\trep(i,0,n) rep(j,0,5) if (c[j][i]<0) c[j][i]+=mod;\n\tint m=strlen(t);\n\trep(i,0,m) {\n\t\tll u=val[t[i]-\'a\'];\n\t\td[0][i]=1;\n\t\trep(x,1,5) d[x][i]=d[x-1][i]*u%mod;\n\t}\n\trep(x,0,5) {\n\t\treverse(d[x],d[x]+m);\n\t\tauto a=multiply(VI(d[x],d[x]+m),VI(c[x],c[x]+n));\n\t\trep(j,m-1,n) ss[j]=(ss[j]+a[j])%mod;\n\t}\n\trep(j,m-1,n) putchar(ss[j]==0?\'1\':\'0\');\n\tputs("""");\n}']","['bitmasks', 'brute force', 'fft']",2900
https://codeforces.com//contest/1607/problem/F,F. Robot on the Board 2,The robot is located on a checkered rectangular board of size n times m n rows m columns The rows in the board are numbered from 1 to n from top to bottom and the columns from 1 to m from left to right The robot is able to move from the current cell to one of the four cells adjacent by side Each cell has one of the symbols or written on it indicating the direction in which the robot will move when it gets in that cell left right down or up respectively The robot can start its movement in any cell He then moves to the adjacent square in the direction indicated on the current square in one move If the robot moves beyond the edge of the board it falls and breaks If the robot appears in the cell it already visited before it breaks it stops and doesn t move anymore Robot can choose any cell as the starting cell Its goal is to make the maximum number of steps before it breaks or stops Determine from which square the robot should start its movement in order to execute as many commands as possible A command is considered successfully completed if the robot has moved from the square on which that command was written it does not matter whether to another square or beyond the edge of the board ,"['#include <bits/stdc++.h>\nusing namespace std;\nchar a[2005][2005];\nint ans[2005][2005],n,m,vis[2005][2005],qwq,ANS,v2[2005][2005],flag=0,X,Y;\ninline void qaq(short x,short y)\n{\n\t//cout << x << "" "" << y << ""*\\n"";\n\tif(v2[x][y]==2) return ;\n\tv2[x][y]=2;\n\tans[x][y]=ANS;\n\tint nx=x,ny=y;\n\tif(a[x][y]==\'L\') --ny;\n\telse if(a[x][y]==\'R\') ++ny;\n\telse if(a[x][y]==\'U\') --nx;\n\telse if(a[x][y]==\'D\') ++nx;\n\tqaq(nx,ny);\n}\ninline int solve2(short x,short y)\n{\n\tif(v2[x][y]) return 0;\n\tv2[x][y]=1;\n//\tans[x][y]=ANS;\n\tint nx=x,ny=y;\n\tif(a[x][y]==\'L\') --ny;\n\telse if(a[x][y]==\'R\') ++ny;\n\telse if(a[x][y]==\'U\') --nx;\n\telse if(a[x][y]==\'D\') ++nx;\n\treturn 1+solve2(nx,ny);\n}\ninline int solve(short x,short y)\n{\n\tif(x<1||y<1||x>n||y>m) return 0;\n\tif(flag) return 0;\n\tif(vis[x][y]==qwq)\n\t{\n\t\tX=x,Y=y,flag=1;\n\t\treturn 0;\n\t}\n\tif(ans[x][y]) return ans[x][y];\n\tvis[x][y]=qwq;\n\tint nx=x,ny=y;\n\tif(a[x][y]==\'L\') --ny;\n\telse if(a[x][y]==\'R\') ++ny;\n\telse if(a[x][y]==\'U\') --nx;\n\telse if(a[x][y]==\'D\') ++nx;\n\treturn ans[x][y]=1+solve(nx,ny);\n}\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tcin >> n >> m;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tans[i][j]=0,vis[i][j]=0,v2[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tX=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(!vis[i][j])\n\t\t\t\t{\n\t\t\t\t\t++qwq,ANS=0;\n\t\t\t\t\tflag=0;\n\t\t\t\t\tsolve(i,j);\n\t\t\t//\t\tcout << X << "" "" << Y << ""*\\n"";\n\t\t\t\t\tif(X)\n\t\t\t\t\t{\n\t\t\t\t\t\tANS=solve2(X,Y);\n\t\t\t//\t\t\tcout << ANS << ""*\\n"";\n\t\t\t\t\t\tqaq(X,Y),++qwq,flag=0,solve(i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(ans[i][j]>mx) mx=ans[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(ans[i][j]==mx)\n\t\t\t\t{\n\t\t\t\t\tcout << i << "" "" << j << "" "" << mx << ""\\n"";\n\t\t\t\t\tmx=-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==-1) break;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}']","['brute force', 'dfs and similar', 'graphs', 'implementation']",2300
https://codeforces.com//contest/1045/problem/F,F. Shady Lady,Ani and Borna are playing a short game on a two variable polynomial It s a special kind of a polynomial the monomials are fixed but all of its coefficients are fill in the blanks dashes e g xy x 4 y 7 x 8 y 3 ldots Borna will fill in the blanks with positive integers He wants the polynomial to be i e his goal is to make sure there exists a real number M such that the value of the polynomial at any point is greater than M Ani is mischievous and wants the polynomial to be unbounded Along with stealing Borna s heart she can also steal parts of polynomials Ani is only a petty kind of thief though she can only steal monomial from the polynomial before Borna fills in the blanks If Ani and Borna play their only moves optimally who wins ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\n\nstruct P { int x,y,id; P() {} P(int x,int y):x(x),y(y),id(-1) {} };\nbool operator<(const P &a,const P &b) { if(a.x!=b.x) return a.x<b.x; return a.y<b.y; }\nP operator-(const P &a,const P &b) { return P(a.x-b.x,a.y-b.y); }\nll operator^(const P &a,const P &b) { return (ll)a.x*b.y-(ll)a.y*b.x; }\nll side(const P &a,const P &b,const P &c) { return (b-a)^(c-a); }\n\nint no;\nP o[MAXN];\n\nint np;\nP p[MAXN+1];\nbool killed[MAXN+1];\n\nint nh;\nP h[MAXN+2];\n\nint lst[MAXN+1],nlst;\n\nvoid makehull() { // assumes sorted\n\tnh=0; assert(!killed[0]); h[nh++]=p[0]; int tmp,last=-1;\n\ttmp=nh; FOR(i,1,np) if(!killed[i]) { while(nh>tmp&&side(h[nh-2],h[nh-1],p[i])<=0) --nh; h[nh++]=p[i]; last=i; }\n\ttmp=nh; for(int i=last-1;i>=0;--i) if(!killed[i]) { while(nh>tmp&&side(h[nh-2],h[nh-1],p[i])<=0) --nh; h[nh++]=p[i]; }\n\t--nh;\n}\n\nbool solve() {\n\tno=np; REP(i,np) o[i]=p[i];\n\t\n\tp[np++]=P(0,0);\n\tsort(p,p+np);\n\tREP(i,np) p[i].id=i;\n\tREP(i,np) killed[i]=false;\n\tmakehull();\n\tREP(i,nh) if(h[i].x%2==1||h[i].y%2==1) return true;\n\n\tnlst=nh; REP(i,nh) lst[i]=h[i].id;\n\tFORE(off,1,2) {\n\t\tREP(i,np) killed[i]=false; for(int i=off;i<nlst;i+=2) killed[lst[i]]=true;\n\t\tmakehull();\n\t\tREP(i,nh) if(h[i].x%2==1||h[i].y%2==1) return true;\n\t}\n\treturn false;\n}\n\nvoid run() {\n\tscanf(""%d"",&np);\n\tREP(i,np) scanf(""%d%d"",&p[i].x,&p[i].y);\n\tprintf(""%s\\n"",solve()?""Ani"":""Borna"");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']","['geometry', 'math']",3400
https://codeforces.com//contest/1388/problem/B,B. Captain Flint and a Long Voyage,In the beginning uncle Bogdan wrote on a board a positive integer x consisting of n digits After that he wiped out x and wrote integer k instead which was the concatenation of binary representations of digits x consists of without leading zeroes For example let x 729 then k 111101001 since 7 111 2 10 9 1001 After some time uncle Bogdan understood that he doesn t know what to do with k and asked Denis to help Denis decided to wipe last n digits of k and named the new number as r As a result Denis proposed to find such integer x of length n that r as number is maximum possible If there are multiple valid x then Denis is interested in the minimum one All crew members including captain Flint himself easily solved the task All except cabin boy Kostya who was too drunk to think straight But what about you Note in this task we compare integers x or k as numbers despite what representations they are written in so 729 1999 or 111 1000 ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main() {\n\tint a[N];\n\tf(i, N)a[i] = 0;\n\tint n, k, t;\n\tint x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(""%d"", &t);\n\tf(tt, t) {\n\t\tscanf(""%d"", &n);\n\t\tk = (n + 3) / 4;\n\t\tf(i, n - k)printf(""9"");\n\t\tf(i, k)printf(""8"");\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}']","['greedy', 'math']",1000
https://codeforces.com//contest/1830/problem/F,F. The Third Grace,You are given n intervals and m points on the number line The i th intervals covers coordinates l i r i and the i th point is on coordinate i and has coefficient p i Initially all points are not activated You should choose a subset of the m points to activate For each of n interval we define its as 0 if there are no activated points in the interval the coefficient of the activated point with the within it otherwise Your task is to maximize the sum of the costs of all intervals by choosing which points to activate ,"['#include ""bits/stdc++.h""\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define ar array\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing pi = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nconst int INFi = 2e9;\nconst ll INF = 2e18;\n\nstruct Line {\n    ll k, b;\n\n    ll get(ll x) { return k * x + b; }\n\n    // returns the x-intercept of intersection ""strictly"" larger than T\n    ll cross_after(Line &L, ll T) {\n        assert(L.get(T) >= get(T));\n        if (L.k >= k) return INF;\n        if (L.b >= b) return (L.b - b + (k - L.k)) / (k - L.k);\n        return (L.b - b + 1) / (k - L.k);\n    }\n\n    Line(ll k_ = 0, ll b_ = INF) : k(k_), b(b_) {}\n};\n\nstruct KineticSegTree { // min kinetic segment tree\n    struct Node {\n        Line best;\n        ll melt;\n        ar<ll, 2> upd; // upd[0] - heaten, upd[1] - add x\n\n        Node() : best(), melt(INF), upd({0, 0}) {}\n    };\n\n    ll T;\n    int n;\n    vector<Node> t;\n\n    void apply(int v, ar<ll, 2> x) {\n        t[v].upd[0] += x[0];\n        t[v].upd[1] += x[1];\n        t[v].best.b += x[0] * t[v].best.k + x[1];\n        t[v].melt -= x[0];\n    }\n\n    bool IsBetter(Line &a, Line &b) {\n        ll l = a.get(T), r = b.get(T);\n        if (l != r)\n            return l < r;\n        return a.k < b.k;\n    }\n\n    void pull(int v) {\n        Line A = t[v << 1].best;\n        Line B = t[v << 1 | 1].best;\n        t[v].melt = min(t[v << 1].melt, t[v << 1 | 1].melt);\n        if (IsBetter(B, A)) swap(A, B);\n        t[v].best = A;\n        t[v].melt = min(t[v].melt, A.cross_after(B, T));\n    }\n\n    void init(vector<Line> &l, ll TT = 0) {\n        n = l.size();\n        T = TT;\n        t.resize(n * 4);\n        init(1, 0, n, l);\n    }\n\n    void init(int v, int l, int r, vector<Line> &lines) {\n        if (l + 1 == r) {\n            t[v].best = lines[l];\n            return;\n        }\n        init(v << 1, l, (l + r) >> 1, lines);\n        init(v << 1 | 1, (l + r) >> 1, r, lines);\n        pull(v);\n    }\n\n    void push(int v) {\n        if (!t[v].upd[0] && !t[v].upd[1]) return;\n        apply(v << 1, t[v].upd);\n        apply(v << 1 | 1, t[v].upd);\n        t[v].upd[0] = t[v].upd[1] = 0;\n    }\n\n    void propagate(int v) {\n        if (t[v].melt > 0) return;\n        push(v);\n        propagate(v << 1);\n        propagate(v << 1 | 1);\n        pull(v);\n    }\n\n    ll get(int v, int l, int r, int lq, int rq) {\n        if (rq <= l || r <= lq) return INF;\n        if (lq <= l && r <= rq) {\n            return t[v].best.get(T);\n        }\n        push(v);\n        return min(get(v << 1, l, (l + r) >> 1, lq, rq), get(v << 1 | 1, (l + r) >> 1, r, lq, rq));\n    }\n\n    ll get(int lq, int rq) {\n        return get(1, 0, n, lq, rq);\n    }\n\n    void upd(int v, int l, int r, int lq, int rq, ar<ll, 2> &x) {\n        if (rq <= l || r <= lq) return;\n        if (lq <= l && r <= rq) {\n            apply(v, x);\n            propagate(v);\n            return;\n        }\n        push(v);\n        upd(v << 1, l, (l + r) >> 1, lq, rq, x);\n        upd(v << 1 | 1, (l + r) >> 1, r, lq, rq, x);\n        pull(v);\n    }\n\n    void upd(int lq, int rq, ar<ll, 2> x) {\n        upd(1, 0, n, lq, rq, x);\n    }\n\n    void heaten(int lq, int rq, ll x) {\n        upd(lq, rq, {x, 0});\n    }\n\n    void add(int lq, int rq, ll x) {\n        upd(lq, rq, {0, x});\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int m;\n    cin >> m;\n    vi l(n), r(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i];\n    }\n    vector<Line> a(m + 1, {0, 0});\n    for (int i = 1; i <= m; ++i) {\n        cin >> a[i].k;\n        a[i].k *= -1;\n    }\n    KineticSegTree kst;\n    kst.init(a, 0);\n    vi ord(n);\n    iota(all(ord), 0);\n    sort(all(ord), [&](const int &i, const int &j) { return r[i] < r[j]; });\n    int j = 0;\n    for (int i = 1; i <= m; ++i) {\n        ll ans = kst.get(0, i);\n        kst.add(i, i + 1, ans);\n        while (j < n && r[ord[j]] == i) {\n            kst.heaten(l[ord[j]], r[ord[j]] + 1, 1);\n            j++;\n        }\n    }\n    cout << -kst.get(0, m + 1) << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n     cin >> t;\n    rep(_, t) {\n        solve();\n    }\n    return 0;\n}']","['data structures', 'dp']",3200
https://codeforces.com//contest/1530/problem/H,H. Turing's Award,Alan Turing is standing on a tape divided into cells that is infinite in both directions Cells are numbered with consecutive integers from left to right Alan is initially standing in cell 0 Every cell x has cell x 1 on the left and cell x 1 on the right Each cell can either contain an integer or be empty Initially all cells are empty Alan is given a permutation a 1 a 2 ldots a n of integers from 1 to n that was chosen among all permutations of length n At time 1 integer a 1 is written down into cell 0 where Alan is located At each time i from 2 to n inclusive the following happens First Alan decides whether to stay in the same cell he s currently in move to the neighboring cell on the left or move to the neighboring cell on the right After that integer a i is written down into the cell where Alan is located If that cell already contained some integer the old integer is overwritten and irrelevant from that moment on Once a n is written down into some cell at time n sequence b of all integers contained in the cells from left to right is formed Empty cells are ignored Turing s award is equal to the length of the longest increasing subsequence of sequence b Help Alan and determine the largest possible value of his award if he acts optimally ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int L = 600;\n\nstruct Fenwick {\n    const int n;\n    std::vector<int> a;\n    Fenwick(int n) : n(n), a(n, -1) {}\n    void add(int x, int v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] = std::max(a[i - 1], v);\n        }\n    }\n    int query(int x) {\n        int ans = -1;\n        for (int i = x; i > 0; i -= i & -i) {\n            ans = std::max(ans, a[i - 1]);\n        }\n        return ans;\n    }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n    }\n    \n    std::reverse(a.begin(), a.end());\n    \n    int ans = 1;\n    \n    for (int t = 0; t < 2; t++) {\n        std::vector f(n, std::vector(L, -1)), g(n, std::vector(L, n));\n        \n        std::vector t1(L, Fenwick(n)), t2(t1), t3(t1), t4(t1);\n        \n        if (t == 0) {\n            t1[1].add(a[0], a[0]);\n            t2[1].add(n - 1 - a[0], n - 1 - a[0]);\n            f[0][1] = a[0];\n            g[0][1] = a[0];\n        }\n        \n        for (int i = 1; i < n; i++) {\n            if (t == 1) {\n                f[i][2] = a[i];\n                g[i][2] = a[i];\n                t1[2].add(a[i], a[i]);\n                t2[2].add(n - 1 - a[i], n - 1 - a[i]);\n            }\n            for (int j = 2; j < L; j++) {\n                f[i][j] = t1[j - 1].query(a[i]);\n                g[i][j] = n - 1 - t2[j - 1].query(n - 1 - a[i]);\n                \n                int x = i - j + 1;\n                if (x >= 0 && g[x][j - 1] < n) {\n                    t3[j - 1].add(g[x][j - 1], a[x]);\n                }\n                if (x >= 0 && f[x][j - 1] >= 0) {\n                    t4[j - 1].add(n - 1 - f[x][j - 1], n - 1 - a[x]);\n                }\n                f[i][j] = std::max(f[i][j], t3[j - 1].query(a[i]));\n                g[i][j] = std::min(g[i][j], n - 1 - t4[j - 1].query(n - 1 - a[i]));\n                \n                if (f[i][j] >= 0 || g[i][j] < n) {\n                    ans = std::max(ans, j - t);\n                }\n            }\n            for (int j = 2; j < L; j++) {\n                if (f[i][j] >= 0) {\n                    t1[j].add(a[i], f[i][j]);\n                }\n                if (g[i][j] < n) {\n                    t2[j].add(n - 1 - a[i], n - 1 - g[i][j]);\n                }\n            }\n        }\n    }\n    \n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['data structures', 'dp']",3400
https://codeforces.com//contest/814/problem/A,A. An abandoned sentiment from past,A few years ago Hitagi encountered a giant crab who stole the whole of her body weight Ever since she tried to avoid contact with others for fear that this secret might be noticed To get rid of the oddity and recover her weight a special integer sequence is needed Hitagi s sequence has been broken for a long time but now Kaiki provides an opportunity Hitagi s sequence has a length of Lost elements in it are denoted by zeros Kaiki provides another sequence whose length equals the number of lost elements in i e the number of zeros Hitagi is to replace each zero in with an element from so that Hitagi knows however that If the resulting sequence is an increasing sequence then it has the power to recover Hitagi from the oddity You are to determine whether this is possible or Kaiki s sequence is just another fake In other words you should detect whether it is possible to replace each zero in with an integer from so that each integer from is used exactly once and the resulting sequence is increasing ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint n, k;\n\nint a[maxn];\n\nint pos;\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> k;\n    if (k > 1){\n        cout << ""Yes"";\n        return 0;\n    }\n    for (int i = 0; i < n; i++){\n        cin >> a[i];\n        if (a[i] == 0)\n            pos = i;\n        if (i > 0 && a[i] < a[i - 1] && a[i] != 0){\n            cout << ""Yes"";\n            return 0;\n        }\n    }\n    int x;\n    cin >> x;\n    if ((pos == 0 || a[pos - 1] < x) && (pos == n - 1 || a[pos + 1] > x))\n        cout << ""No"";\n    else\n        cout << ""Yes"";\n}\n']","['constructive algorithms', 'greedy', 'implementation', 'sortings']",900
https://codeforces.com//contest/1080/problem/F,F. Katya and Segments Sets,It is a very important day for Katya She has a test in a programming class As always she was given an interesting problem that she solved very fast Can you solve that problem You are given n ordered segments sets Each segment can be represented as a pair of two integers l r where l leq r Each set can contain an arbitrary number of segments even 0 It is possible that some segments are equal You are also given m queries each of them can be represented as four numbers a b x y For each segment find out whether it is true that each set p a leq p leq b contains at least one segment l r that lies entirely on the segment x y that is x leq l leq r leq y Find out the answer to each query Note that you need to solve this problem That is you will get a new query only after you print the answer for the previous query ,"['#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 300050;\nconst int NN = N * 20;\nconst int INF = 2000000000;\n\nint root[N], maxv[NN], lc[NN], rc[NN], cnt = 1;\n\nvoid insert(int &o, int l, int r, int p, int y) {\n  maxv[cnt] = maxv[o];\n  lc[cnt] = lc[o];\n  rc[cnt] = rc[o];\n  o = cnt++;\n  if (l == r) maxv[o] = std::min(maxv[o], y);\n  else {\n    int mid = (l + r) / 2;\n    if (p <= mid) insert(lc[o], l, mid, p, y);\n    else insert(rc[o], mid + 1, r, p, y);\n    maxv[o] = std::max(maxv[lc[o]], maxv[rc[o]]);\n  }\n}\n\nint query(int o, int l, int r, int L, int R) {\n  if (l > R || L > r) return 0;\n  if (!o) return INF;\n  if (L <= l && r <= R) return maxv[o];\n  int mid = (l + r) / 2;\n  return std::max(query(lc[o], l, mid, L, R), query(rc[o], mid + 1, r, L, R));\n}\n\nstruct Interval {\n  int l, r, p;\n  friend bool operator<(const Interval &a, const Interval &b) {\n    return a.l > b.l;\n  }\n} I[N];\n\nint n, m, k;\n\nint main(){\n  maxv[0] = INF;\n  lc[0] = rc[0] = 0;\n  scanf(""%d%d%d"", &n, &m, &k);\n  for (int i = 0; i < k; ++i)\n    scanf(""%d%d%d"", &I[i].l, &I[i].r, &I[i].p);\n  std::sort(I, I + k);\n  root[0] = 0;\n  for (int i = 0; i < k; ++i) {\n    //printf(""  %d %d %d %d\\n"", i, I[i].l, I[i].r, I[i].p);\n    insert(root[i + 1] = root[i], 1, n, I[i].p, I[i].r);\n  }\n  while (m--) {\n    int a, b, x, y;\n    scanf(""%d%d%d%d"", &a, &b, &x, &y);\n    Interval t;\n    t.l = x;\n    int i = std::upper_bound(I, I + k, t) - I;\n    //printf(""  %d "", i);\n    puts(query(root[i], 1, n, a, b) <= y ? ""yes"" : ""no"");\n    fflush(stdout);\n  }\n  return 0;\n}']","['data structures', 'interactive', 'sortings']",2400
https://codeforces.com//contest/900/problem/A,A. Find Extra One,You have distinct points on a plane none of them lie on axis Check that there is a point after removal of which the remaining points are located on one side of the axis ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,a,b;\n\nint main()\n{\n    scanf(""%d"",&n);\n    a=0;b=0;\n    for (int i=1;i<=n;i++)\n    {\n        int x,y;scanf(""%d%d"",&x,&y);\n        if (x>0) a++; else b++;\n    }\n    if (a>1&&b>1) puts(""No\\n""); else puts(""Yes\\n"");\n    return 0;\n}\n']","['geometry', 'implementation']",800
https://codeforces.com//contest/803/problem/D,D. Magazine Ad,The main city magazine offers its readers an opportunity to publish their ads The format of the ad should be like this There are space separated non empty words of lowercase and uppercase Latin letters There are hyphen characters in some words their positions set word wrapping points Word can include more than one hyphen It is guaranteed that there are no adjacent spaces and no adjacent hyphens No hyphen is adjacent to space There are no spaces and no hyphens before the first word and after the last word When the word is wrapped the part of the word before hyphen and the hyphen itself stay on current line and the next part of the word is put on the next line You can also put line break between two words in that case the space stays on current line Check notes for better understanding The ad can occupy no more that lines and should have minimal width The width of the ad is the maximal length of string letters spaces and hyphens are counted in it You should write a program that will find minimal width of the ad ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9;\nint k;\nstring s;\nint n;\n\nint solve(int w)\n{\n    int ans = 0;\n    int l = 0;\n    while(l < n)\n    {\n        ans++;\n        int r = l + w;\n        if (r >= n) break;\n        while(r > l && s[r - 1] != \' \' && s[r - 1] != \'-\') r--;\n        if (r == l) return INF;\n        l = r;\n    }\n    return ans;\n}\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    cin >> k;\n    getline(cin, s);\n    getline(cin, s);\n\n    n = s.length();\n    int l = 0, r = n;\n    while(r - l > 1)\n    {\n        int m = (l + r) / 2;\n        if (solve(m) <= k)\n            r = m;\n        else\n            l = m;\n    }\n    cout << r << endl;\n\n    return 0;\n}\n']","['binary search', 'greedy']",1900
https://codeforces.com//contest/1923/problem/F,F. Shrink-Reverse,You are given a binary string s of length n a string consisting of n characters and each character is either or Let s look at s as at a binary representation of some integer and name that integer as the of string s For example the value of is 0 the value of is 13 is 32 and so on You can perform at most k operations on s Each operation should have one of the two following types choose two indices i j in s and swap s i with s j delete all leading zeroes from s and reverse s For example after you perform on you ll get What is the minimum value of s you can achieve by performing at most k operations on s ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\nstruct SuffixArray {\n    int n;\n    std::vector<int> sa, rk, lc;\n    SuffixArray(const std::string &s) {\n        n = s.length();\n        sa.resize(n);\n        lc.resize(n - 1);\n        rk.resize(n);\n        std::iota(sa.begin(), sa.end(), 0);\n        std::sort(sa.begin(), sa.end(), [&](int a, int b) {return s[a] < s[b];});\n        rk[sa[0]] = 0;\n        for (int i = 1; i < n; ++i)\n            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);\n        int k = 1;\n        std::vector<int> tmp, cnt(n);\n        tmp.reserve(n);\n        while (rk[sa[n - 1]] < n - 1) {\n            tmp.clear();\n            for (int i = 0; i < k; ++i)\n                tmp.push_back(n - k + i);\n            for (auto i : sa)\n                if (i >= k)\n                    tmp.push_back(i - k);\n            std::fill(cnt.begin(), cnt.end(), 0);\n            for (int i = 0; i < n; ++i)\n                ++cnt[rk[i]];\n            for (int i = 1; i < n; ++i)\n                cnt[i] += cnt[i - 1];\n            for (int i = n - 1; i >= 0; --i)\n                sa[--cnt[rk[tmp[i]]]] = tmp[i];\n            std::swap(rk, tmp);\n            rk[sa[0]] = 0;\n            for (int i = 1; i < n; ++i)\n                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);\n            k *= 2;\n        }\n        for (int i = 0, j = 0; i < n; ++i) {\n            if (rk[i] == 0) {\n                j = 0;\n            } else {\n                for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j]; )\n                    ++j;\n                lc[rk[i] - 1] = j;\n            }\n        }\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::string t = s;\n    \n    int res = k;\n    int r = n;\n    for (int i = 0; i < n; i++) {\n        if (t[i] == \'1\') {\n            while (r > 0 && t[r - 1] == \'1\') {\n                r--;\n            }\n            if (res > 0 && i < r) {\n                std::swap(t[i], t[r - 1]);\n                res--;\n            }\n        }\n    }\n    \n    auto work = [&](int k) {\n        int cnt = std::count(s.begin(), s.end(), \'1\');\n        int need = std::max(1, cnt - k);\n        std::vector<int> p;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == \'1\') {\n                p.push_back(i);\n            }\n        }\n        int len = n;\n        for (int i = need - 1; i < p.size(); i++) {\n            len = std::min(len, p[i] - p[i - (need - 1)] + 1);\n        }\n        if (len <= cnt) {\n            t = std::string(n - cnt, \'0\') + std::string(cnt, \'1\');\n            return;\n        }\n        std::vector<int> pre(n + 1);\n        SuffixArray sa(s);\n        for (int i = 0; i < n; i++) {\n            pre[i + 1] = pre[i] + s[i] - \'0\';\n        }\n        for (auto i : sa.sa) {\n            if (i + len <= n && pre[i + len] - pre[i] >= need) {\n                std::string ans = s.substr(i, len);\n                int res = k;\n                for (int i = ans.size() - 1; i >= 0; i--) {\n                    if (ans[i] == \'0\' && res > 0) {\n                        res--;\n                        ans[i] = \'1\';\n                    }\n                }\n                ans = std::string(n - len, \'0\') + ans;\n                t = std::min(t, ans);\n                return;\n            }\n        }\n        assert(false);\n    };\n    \n    if (k >= 2) {\n        work(k - 2);\n    }\n    if (k >= 1) {\n        std::reverse(s.begin(), s.end());\n        work(k - 1);\n    }\n    Z ans = 0;\n    for (auto c : t) {\n        ans = ans * 2 + (c - \'0\');\n    }\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['binary search', 'brute force', 'greedy', 'hashing', 'implementation', 'string suffix structures', 'strings']",2800
https://codeforces.com//contest/1477/problem/E,E. Nezzar and Tournaments,In the famous Oh Suit United tournament two teams are playing against each other for the grand prize of precious pepper points The first team consists of n players and the second team consists of m players Each player has a potential the potential of the i th player in the first team is a i and the potential of the i th player in the second team is b i In the tournament players will be on the stage in some order There will be a scoring device initially assigned to an integer k which will be used to value the performance of all players The scores for all players will be assigned in the order they appear on the stage Let the potential of the current player be x and the potential of the previous player be y Then x y is added to the value in the scoring device Afterwards if the value in the scoring device becomes negative Lastly the player s score is assigned to the current value on the scoring device The score of a team is the sum of the scores of all its members As an insane fan of the first team Nezzar desperately wants the biggest win for the first team He now wonders what is the maximum difference between scores of the first team and the second team Formally let the score of the first team be score f and the score of the second team be score s Nezzar wants to find the maximum value of score f score s over all possible orders of players on the stage However situation often changes and there are q events that will happen There are three types of events 1 pos x change a pos to x 2 pos x change b pos to x 3 x tournament is held with k x and Nezzar wants you to compute the maximum value of score f score s Can you help Nezzar to answer the queries of the third type ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\nstruct Waf{\n\tvi vs;\n\tBIT<int> bit,cnt;\n\tvoid prepare(){\n\t\tmkuni(vs);\n\t\tbit=BIT<int>(si(vs));\n\t\tcnt=BIT<int>(si(vs));\n\t}\n\tvoid insert(int v){\n\t\tint i=lwb(vs,v);\n\t\tbit.add(i,v);\n\t\tcnt.add(i,1);\n\t}\n\tvoid erase(int v){\n\t\tint i=lwb(vs,v);\n\t\tbit.add(i,-v);\n\t\tcnt.add(i,-1);\n\t}\n\tint query(int v){\n\t\tint i=lwb(vs,v);\n\t\tint val=bit.sum(i,si(vs));\n\t\tval-=cnt.sum(i,si(vs))*v;\n\t\treturn val;\n\t}\n};\n\nint getmin(const multiset<int>&s){\n\tassert(si(s));\n\treturn *s.bg;\n}\nint getmax(const multiset<int>&s){\n\tassert(si(s));\n\treturn *s.rbegin();\n}\nvoid del(multiset<int>&s,int val){\n\tauto itr=s.find(val);\n\tassert(itr!=s.ed);\n\ts.erase(itr);\n}\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\tvi a=readvi(n);\n\tvi b=readvi(m);\n\tint asum=accumulate(all(a),int(0));\n\tint bsum=accumulate(all(b),int(0));\n\tmultiset<int> as,bs,abvs;\n\tfor(auto v:a){\n\t\tas.insert(v);\n\t\tabvs.insert(v);\n\t}\n\tfor(auto v:b){\n\t\tbs.insert(v);\n\t\tabvs.insert(v);\n\t}\n\tWaf waf;\n\twaf.vs=b;\n\tstruct Query{\n\t\tint t,pos,x;\n\t\tvoid readinit(){\n\t\t\tcin>>t;\n\t\t\tif(t<=2){\n\t\t\t\tcin>>pos>>x;\n\t\t\t\tpos--;\n\t\t\t}else if(t==3){\n\t\t\t\tcin>>x;\n\t\t\t}else{\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t};\n\tvc<Query> qs(q);\n\trep(i,q){\n\t\tqs[i].readinit();\n\t\tif(qs[i].t==2)waf.vs.pb(qs[i].x);\n\t}\n\twaf.prepare();\n\tfor(auto v:b)waf.insert(v);\n\tfor(auto qq:qs){\n\t\tif(qq.t<=2){\n\t\t\tint pos=qq.pos,x=qq.x;\n\t\t\tif(qq.t==1){\n\t\t\t\tasum-=a[pos];\n\t\t\t\tdel(as,a[pos]);\n\t\t\t\tdel(abvs,a[pos]);\n\t\t\t\ta[pos]=x;\n\t\t\t\tasum+=a[pos];\n\t\t\t\tas.insert(a[pos]);\n\t\t\t\tabvs.insert(a[pos]);\n\t\t\t}else if(qq.t==2){\n\t\t\t\tbsum-=b[pos];\n\t\t\t\tdel(bs,b[pos]);\n\t\t\t\tdel(abvs,b[pos]);\n\t\t\t\twaf.erase(b[pos]);\n\t\t\t\tb[pos]=x;\n\t\t\t\tbsum+=b[pos];\n\t\t\t\tbs.insert(b[pos]);\n\t\t\t\tabvs.insert(b[pos]);\n\t\t\t\twaf.insert(b[pos]);\n\t\t\t}else assert(false);\n\t\t}else if(qq.t==3){\n\t\t\tint x=qq.x,ans=-inf;\n\t\t\tint tmp=getmin(abvs);\n\t\t\t{\n\t\t\t\tint top=getmax(bs);\n\t\t\t\t//dmp(waf.query(top-x));\n\t\t\t\tchmax(ans,asum-tmp*n-waf.query(top-x));\n\t\t\t\tauto upd=[&](int use){\n\t\t\t\t\tchmax(ans,asum-use-tmp*(n-1)-waf.query(use-x)+x);\n\t\t\t\t};\n\t\t\t\tauto itr=as.lower_bound(top+x);\n\t\t\t\tif(itr!=as.ed)upd(*itr);\n\t\t\t\tif(itr!=as.bg)upd(*prev(itr));\n\t\t\t}\n\t\t\t//dmp(ans);\n\t\t\t{\n\t\t\t\tconst auto upd=[&](int lv){\n\t\t\t\t\tchmax(ans,asum-lv*n-(bsum-lv*m));\n\t\t\t\t};\n\t\t\t\tupd(tmp-x);\n\t\t\t\tauto itr=abvs.upper_bound(tmp+x);\n\t\t\t\t--itr;\n\t\t\t\tupd(*itr-x);\n\t\t\t}\n\t\t\tprint(ans);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'greedy']",3300
https://codeforces.com//contest/1496/problem/B,B. Max and Mex,You are given a multiset S initially consisting of n distinct non negative integers A multiset is a set that can contain some elements multiple times You will perform the following operation k times Add the element lceil frac a b 2 rceil rounded up into S where a operatorname mex S and b max S If this number is already in the set it is added again Here operatorname max of a multiset denotes the maximum integer in the multiset and operatorname mex of a multiset denotes the smallest non negative integer that is not present in the multiset For example operatorname mex 1 4 0 2 3 operatorname mex 2 5 1 0 Your task is to calculate the number of elements in S after k operations will be done ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\nconst int N=100005;\nint n,k,a[N],T;\nmap<int,int>flag;\nint main(){\n\tcin>>T;\n\twhile (T--){\n\t\tcin>>n>>k;\n\t\tfor (int i=1;i<=n;i++)cin>>a[i];\n\t\tif (!k){\n\t\t\tprintf(""%d\\n"",n);\n\t\t\tcontinue;\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tint mex=0,Max=0;\n\t\tfor (int i=1;i<=n;i++)flag[a[i]]=1,Max=max(Max,a[i]);\n\t\twhile (flag[mex])mex++;\n\t\tif (mex>Max)printf(""%d\\n"",n+k);\n\t\telse if (!flag[(mex+Max+1)/2])printf(""%d\\n"",n+1);\n\t\telse printf(""%d\\n"",n);\n\t\tfor (int i=1;i<=n;i++)flag[a[i]]=0;\n\t}\n}\n']",['math'],1100
https://codeforces.com//contest/1118/problem/D1,D1. Coffee and Coursework  Easy version , Polycarp has to write a coursework The coursework consists of m pages Polycarp also has n cups of coffee The coffee in the i th cup has a i caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not usually being written in a single day in a perfect world of Berland at least Some of them require multiple days of hard work Let s consider some day of Polycarp s work Consider Polycarp drinks k cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are a i 1 a i 2 dots a i k Then the first cup he drinks gives him energy to write a i 1 pages of coursework the second cup gives him energy to write max 0 a i 2 1 pages the third cup gives him energy to write max 0 a i 3 2 pages the k th cup gives him energy to write max 0 a i k k 1 pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n#define ll long long int\n#define ld double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst ll M=2e5+5;\nll a[M];\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tll n,m;\n\tcin>>n>>m;\n\tll s=0;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t\ts=s+a[i];\n\t}\n\tsort(a+1,a+1+n);\n\tif(s<m)\n\t{\n\t\tcout<<""-1\\n"";\n\t\treturn 0;\n\t}\n\tll l=1,r=n,p=-1;\n\twhile(l<r)\n\t{\n\t\tll mid=(l+r)/2;\n\t\tif(mid==p)\n\t\t\tmid++;\n\t\tp=mid;\n\t\tll s=0;\n\t\tll curr=0;\n\t\tll x=0;\n\t\tfor(ll i=n;i>=1;i--)\n\t\t{\n\t\t\tif(curr==mid)\n\t\t\t{\n\t\t\t\tcurr=0;\n\t\t\t\tx++;\n\t\t\t}\n\t\t\ts=s+max(a[i]-x,(ll)0);\n\t\t\tcurr++;\n\t\t}\n\t\tif(s>=m)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcout<<r<<""\\n"";\n\treturn 0;\n}']","['brute force', 'greedy']",1700
https://codeforces.com//contest/1601/problem/E,E. Phys Ed Online,Students of one unknown college don t have PE courses That s why q of them decided to visit a gym nearby by themselves The gym is open for n days and has a ticket system At the i th day the cost of one ticket is equal to a i You are free to buy more than one ticket per day You can activate a ticket purchased at day i either at day i or any day later Each activated ticket is valid only for k days In other words if you activate ticket at day t it will be valid only at days t t 1 dots t k 1 You know that the j th student wants to visit the gym at each day from l j to r j inclusive Each student will use the following strategy of visiting the gym at any day i l j le i le r j person comes to a desk selling tickets placed near the entrance and buy several tickets with cost a i apiece possibly zero tickets if the person has at least one activated and still valid ticket they just go in Otherwise they activate one of tickets purchased today or earlier and go in Note that each student will visit gym only starting l j so each student has to buy at least one ticket at day l j Help students to calculate the minimum amount of money they have to spend in order to go to the gym ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, q, k, a[300005], ak[300005], ql[300005], qr[300005];\nLL ans[300005];\nvector<int> qy[300005];\n\nstruct fwt\n{\n\tint B;\n\tLL dat[300005], sum;\n\tvoid clear()\n\t{\n\t\tB = n / k + 2; sum = 0;\n\t\tfor(int i = B; i >= 0; i --) dat[i] = 0;\n\t}\n\tvoid add(int id, LL val)\n\t{\n\t\tsum += val;\n\t\tfor(; id <= B; id += id & -id) dat[id] += val;\n\t}\n\tLL query(int id)\n\t{\n\t\tLL ret = 0;\n\t\tfor(; id > 0; id -= id & -id) ret += dat[id];\n\t\treturn ret;\n\t}\n}t0, t1;\nvoid add_t(int r, LL val)\n{\n\tif(r == 0) return;\n\tt0.add(r, val); t1.add(r, 1LL * r * val);\n}\nLL query_t(int r)\n{\n\tif(r == 0) return 0;\n\treturn 1LL * r * (t0.sum - t0.query(r)) + t1.query(r);\n}\nvoid add_t(int l, int r, LL val)\n{\n\tadd_t(l, -val); add_t(r + 1, val);\n}\nLL query_t(int l, int r)\n{\n\treturn query_t(r + 1) - query_t(l);\n}\n\nPII sta[300005];\nint siz;\ndeque<PII> que;\nint main()\n{\n\tscanf(""%d%d%d"", &n, &q, &k);\n\trep1(i, n) scanf(""%d"", &a[i]);\n\trep(i, q) scanf(""%d%d"", &ql[i], &qr[i]);\n\t\n\tfor(int i = n; i >= 1; i --) {\n\t\tif(!que.empty() && que.front().second == i + k) que.pop_front();\n\t\twhile(!que.empty() && que.back().first >= a[i]) que.pop_back();\n\t\tque.push_back(MP(a[i], i));\n\t\tak[i] = que.front().first;\n\t}\n\t\n\trep(i, q) {\n\t\tans[i] = a[ql[i]];\n\t\tqr[i] = (qr[i] - ql[i]) / k;\n\t\tqy[ql[i] + 1].push_back(i);\n\t}\n\t\n\tfor(int i = n; i > n - k; i --) {\n\t\tt0.clear(); t1.clear();\n\t\tsiz = 1; sta[0] = MP(-1, i / k + 1);\n\t\tfor(int j = i; j >= 1; j -= k) {\n\t\t\twhile(sta[siz - 1].first >= ak[j]) {\n\t\t\t\tadd_t(sta[siz - 1].second, sta[siz - 2].second - 1, ak[j] - sta[siz - 1].first);\n\t\t\t\tsiz --;\n\t\t\t}\n\t\t\tint cj = j / k;\n\t\t\tsta[siz ++] = MP(ak[j], cj);\n\t\t\tadd_t(cj, cj, ak[j]);\n\t\t\trep(iq, qy[j].size()) {\n\t\t\t\tint cq = qy[j][iq], cv = a[j - 1];\n\t\t\t\tint cpos = lower_bound(sta, sta + siz, MP(cv, -1)) - sta - 1;\n\t\t\t\tif(cj + qr[cq] <= sta[cpos].second) ans[cq] += 1LL * cv * qr[cq];\n\t\t\t\telse ans[cq] += 1LL * cv * (sta[cpos].second - cj) + query_t(sta[cpos].second, cj + qr[cq] - 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, q) printf(""%lld\\n"", ans[i]);\n\treturn 0;\n}']","['data structures', 'dp', 'greedy']",2900
https://codeforces.com//contest/1313/problem/A,A. Fast Food Restaurant,Tired of boring office work Denis decided to open a fast food restaurant On the first day he made a portions of dumplings b portions of cranberry juice and c pancakes with condensed milk The peculiarity of Denis s restaurant is the procedure of ordering food For each visitor Denis himself chooses a set of dishes that this visitor will receive When doing so Denis is guided by the following rules every visitor should receive at least one dish dumplings cranberry juice pancakes with condensed milk are all considered to be dishes each visitor should receive no more than one portion of dumplings no more than one portion of cranberry juice and no more than one pancake with condensed milk all visitors should receive different sets of dishes What is the maximum number of visitors Denis can feed ,"['#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-\'0\',ch=getchar();\n\treturn f?x:-x;\n}\nint C[][3]={\n\t{0,0,1},\n\t{0,1,0},\n\t{1,0,0},\n\t{0,1,1},\n\t{1,0,1},\n\t{1,1,0},\n\t{1,1,1}\n};\nint main(){\n#ifdef LOCAL\n\tfreopen(""in.in"",""r"",stdin);\n\t//freopen(""out.out"",""w"",stdout);\n#endif\n\tint T=gi();\n\twhile(T--){\n\t\tint a=gi(),b=gi(),c=gi(),ans=0;\n\t\tfor(int i=0;i<1<<7;++i){\n\t\t\tint sa=0,sb=0,sc=0;\n\t\t\tfor(int j=0;j<7;++j)if(i>>j&1)sa+=C[j][0],sb+=C[j][1],sc+=C[j][2];\n\t\t\tif(sa<=a&&sb<=b&&sc<=c)ans=std::max(ans,__builtin_popcount(i));\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation']",900
https://codeforces.com//contest/1551/problem/B2,B2. Wonderful Coloring - 2,Recently Paul and Mary have found a new favorite sequence of integers a 1 a 2 dots a n They want to paint it using pieces of chalk of k colors The coloring of a sequence is called if the following conditions are met each element of the sequence is either painted in one of k colors or isn t painted each two elements which are painted in the same color are different i e there s no two equal values painted in the same color let s calculate for each of k colors the number of elements painted in the color all calculated numbers must be equal the total number of painted elements of the sequence is the among all colorings of the sequence which meet the first three conditions E g consider a sequence a 3 1 1 1 1 10 3 10 10 2 and k 3 One of the wonderful colorings of the sequence is shown in the figure Help Paul and Mary to find a wonderful coloring of a given sequence a ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    map<int,vector<int>> mp;\n    vector<int> ans(n+1,0);\n    for(int i=1;i<=n;++i)\n    {\n        int x;\n        cin >> x;\n        mp[x].push_back(i);\n    }\n    vector<int> t;\n    for(auto &[i,v]:mp)\n    {\n        while(sz(v) > k)\n            v.pop_back();\n        for(auto &j:v)\n            t.push_back(j);\n    }\n    while(sz(t) % k != 0)\n        t.pop_back();\n    int cur = 0;\n    for(int i=0;i<sz(t);++i)\n    {\n        ans[t[i]] = cur + 1;\n        cur = (cur + 1) % k;\n    }\n    for(int i=1;i<=n;++i)\n        cout << ans[i] << "" "";\n    cout <<""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","['binary search', 'constructive algorithms', 'data structures', 'greedy']",1400
https://codeforces.com//contest/313/problem/B,B. Ilya and Queries,Ilya the Lion wants to help all his friends with passing exams They need to solve the following problem to pass the IT exam You ve got string is the length of the string consisting only of characters and and queries Each query is described by a pair of integers The answer to the query is the number of such integers that Ilya the Lion wants to help his friends but is there anyone to help him Help Ilya solve the problem ,"['#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAXN = 101000;\n\nchar str[MAXN];\nint f[MAXN], n, m;\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tscanf(""%s"", str + 1);\n\tn = strlen(str + 1);\n\tscanf(""%d"", &m);\n\tfor (int i = 1; i < n; ++i)\n\t\tf[i] = f[i - 1] + (str[i] == str[i + 1]);\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tprintf(""%d\\n"", f[y - 1] - f[x - 1]);\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n']","['dp', 'implementation']",1100
https://codeforces.com//contest/406/problem/B,B. Toy Sum,Little Chris is very keen on his toy blocks His teacher however wants Chris to solve more problems so he decided to play a trick on Chris There are exactly blocks in Chris s set each block has a unique number from 1 to Chris s teacher picks a subset of blocks and keeps it to himself He will give them back only if Chris can pick such a non empty subset from the remaining blocks that the equality holds Are you kidding me asks Chris For example consider a case where and Chris s teacher took the blocks with numbers 1 4 and 5 One way for Chris to choose a set is to pick the blocks with numbers 3 and 6 see figure Then the required sums would be equal However now Chris has exactly blocks Given the set of blocks his teacher chooses help Chris to find the required set ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA ""sequence""\n\nconst int N=1000000;\nbool A0[N+100];\nbool A[N+100];\n\nint main(){\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n\t//freopen(TASKA"".in"", ""r"", stdin); freopen(TASKA"".out"", ""w"", stdout);\n#endif\n\t\n\tint n;\n\tcin>>n;\n\tforn(i,n){\n\t\tint a;\n\t\tscanf(""%d"",&a);\n\t\tA0[a]=true;\n\t\tA[a]=true;\n\t}\n\tvector<int> res;\n\tint c=0;\n\tfor(int i=1;i<=N;++i){\n\t\tif(A0[i]){\n\t\t\tif(A0[N-i+1]){\n\t\t\t\tif(N-i+1>=i)\n\t\t\t\t\t++c;\n\t\t\t}else{\n\t\t\t\tA[N-i+1]=true;\n\t\t\t\tres.pb(N-i+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tif(!c)\n\t\t\tbreak;\n\t\tif(A[i])\n\t\t\tcontinue;\n\t\tif(A[N-i+1])\n\t\t\texit(123);\n\t\t--c;\n\t\tA[i]=A[N-i+1]=true;\n\t\tres.pb(i);\n\t\tres.pb(N-i+1);\n\t}\n\t\n\tcout<<sz(res)<<endl;\n\tforv(i,res){\n\t\tprintf(""%d "",res[i]);\n\t}\n\t\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy']",1700
https://codeforces.com//contest/704/problem/D,D. Captain America,Steve Rogers is fascinated with new vibranium shields S H I E L D gave him They re all uncolored There are shields in total the th shield is located at point of the coordinate plane It s possible that two or more shields share the same location Steve wants to paint all these shields He paints each shield in either red or blue Painting a shield in red costs dollars while painting it in blue costs dollars Additionally there are constraints Steve wants to be satisfied The th constraint is provided by three integers and If then the absolute difference between the number of red and blue shields on line should not exceed If then the absolute difference between the number of red and blue shields on line should not exceed Steve gave you the task of finding the painting that satisfies all the condition and the total cost is minimum ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <utility>\n\nusing namespace std;\n\n// usage:\n// MaxFlowDinic::init(n);\n// MaxFlowDinic::addEdge(0, 1, 100, 100); // for bidirectional edge\n// MaxFlowDinic::addEdge(1, 2, 100); // directional edge\n// result = MaxFlowDinic::solve(0, 2); // source -> sink\n// graph[i][edgeIndex].res -> residual\n//\n// in order to find out the minimum cut, use `l\'.\n// if l[i] == 0, i is unreachable.\n\nstruct MaxFlowDinic {\n    typedef int cap_t;\n\n    struct Edge\n    {\n        int next;\n        int inv; /* inverse edge index */\n        cap_t res; /* residual */\n        cap_t save; /* save whatever you want. TODO: just remove if you don\'t need */\n    };\n\n    int n;\n    vector<vector<Edge>> graph;\n\n    vector<int> q, l, start;\n\n    void init(int _n) {\n        n = _n;\n        graph.resize(n);\n        for(int i = 0; i < n; i++) graph[i].clear();\n    }\n    void addNodes(int count) {\n        n += count;\n        graph.resize(n);\n    }\n\n    void addEdgeSave(int s, int e, cap_t cap, cap_t save) {\n        Edge forward = { e, (int)graph[e].size() + (s == e ? 1 : 0), cap, save};\n        Edge reverse = { s, (int)graph[s].size(), 0, -1};\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n\n    void addEdge(int s, int e, cap_t cap, cap_t caprev = 0) {\n        Edge forward = { e, (int)graph[e].size() + (s == e ? 1 : 0), cap, -1};\n        Edge reverse = { s, (int)graph[s].size(), caprev, -1};\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n\n    bool assignLevel(int source, int sink) {\n        int t = 0;\n        l.assign(n, 0);\n        l[source] = 1;\n        q[t++] = source;\n        for(int h = 0; h < t && !l[sink]; h++) {\n            int cur = q[h];\n            for (const auto &edge : graph[cur]) {\n                int next = edge.next;\n                if (l[next]) continue;\n                if (edge.res > 0) {\n                    l[next] = l[cur] + 1;\n                    q[t++] = next;\n                }\n            }\n        }\n        return l[sink] != 0;\n    }\n\n    cap_t blockFlow(int cur, int sink, cap_t currentFlow) {\n        if (cur == sink) return currentFlow;\n        for (auto &i = start[cur]; i < (int)graph[cur].size(); i++) {\n            int next = graph[cur][i].next;\n            if (graph[cur][i].res == 0 || l[next] != l[cur]+1)\n                continue;\n            if (cap_t res = blockFlow(next, sink, min(graph[cur][i].res, currentFlow))) {\n                int inv = graph[cur][i].inv;\n                graph[cur][i].res -= res;\n                graph[next][inv].res += res;\n                return res;\n            }\n        }\n        return 0;\n    }\n\n    cap_t solve(int source, int sink)\n    {\n        if (source == sink) {\n            // invalid case\n            return -1;\n        }\n        q.resize(n);\n        l.resize(n);\n        cap_t ans = 0;\n        while (assignLevel(source, sink)) {\n            start.assign(n, 0);\n            while (cap_t flow = blockFlow(source, sink, numeric_limits<cap_t>::max())) {\n                ans += flow;\n            }\n        }\n        return ans;\n    }\n};\n\nstruct MaxFlowEdgeDemand {\n    typedef MaxFlowDinic::cap_t cap_t;\n    MaxFlowDinic mf;\n\n    vector<cap_t> nodeSum;\n\n    void init(int _n) {\n        mf.init(_n + 2);\n        nodeSum.resize(_n + 2);\n    }\n\n    void addNodes(int count) {\n        mf.addNodes(count);\n        nodeSum.resize(mf.n + 2);\n    }\n\n    void addEdgeSave(int s, int e, cap_t demand, cap_t capacity, cap_t save) {\n        mf.addEdgeSave(s + 2, e + 2, capacity - demand, save);\n        nodeSum[s + 2] -= demand;\n        nodeSum[e + 2] += demand;\n    }\n\n    void addEdge(int s, int e, cap_t demand, cap_t capacity) {\n        mf.addEdge(s + 2, e + 2, capacity - demand);\n        nodeSum[s + 2] -= demand;\n        nodeSum[e + 2] += demand;\n    }\n\n    // -1 if it is impossible to satisfy demand\n    // return max flow.\n    cap_t solveFeasibility(int source, int sink) {\n        mf.addEdge(sink + 2, source + 2, numeric_limits<cap_t>::max());\n        cap_t saturation = 0;\n        for (int i = 2; i < (int)nodeSum.size(); i++) {\n            auto cap = nodeSum[i];\n            if (cap == 0) continue;\n            if (cap < 0) {\n                mf.addEdgeSave(i, 1, -cap, -cap);\n            } else if (cap > 0) {\n                mf.addEdgeSave(0, i, cap, cap);\n                saturation += cap;\n            }\n        }\n        cap_t result = mf.solve(0, 1);\n        if (result != saturation) {\n            return -1;\n        }\n        cap_t maxFlow = mf.solve(source + 2, sink + 2);\n        return maxFlow;\n    }\n};\n\n// maximize sum(selected profit) - sum(selected cost)\n// -> maximize sum(all profit) - sum(unselected profit) - sum(selected cost)\n// -> minimize sum(unselected profit) + sum(selected cost)\n// -> minimize sum(unselected profit) + sum(selected cost) + infinity * sum(selected project needs unselected project)\n// -> mincut on graph!\n// let A={unselected profit}, B={selected cost}.\n// Solution: connect profit projects to all dependent cost projects with infinity capacity. -> this is expensive,\n//        but anyway this forces all dependent cost projects of selected profit projects will be cut.\n// Solution improvement: no need to connect all. It just requires transitive path.\n// after connecting them, you need to cut profit or cut( = accept) cost\nstruct ProjectSelection {\n    typedef MaxFlowDinic::cap_t profit_t;\n    // profit can be negative if it induces costs\n    MaxFlowDinic mf;\n    int source, sink;\n\n    vector<profit_t> profits;\n\n    ProjectSelection(vector<profit_t> profits) : profits(move(profits)) {\n        int n = (int)profits.size();\n        mf.init(n + 2);\n        source = n;\n        sink = n + 1;\n        for (int i = 0; i < n; i++) {\n            auto p = profits[i];\n            if (p > 0) {\n                // profit!\n                mf.addEdge(source, i, p);\n            } else if (p < 0) {\n                // costly\n                mf.addEdge(i, sink, -p);\n            }\n        }\n    }\n\n    // ""a"" depends on ""b"". To do ""a"", you need ""b"" before.\n    void AddDependency(int a, int b) {\n        mf.addEdge(a, b, numeric_limits<MaxFlowDinic::cap_t>::max());\n    }\n\n    // return the best profit\n    //\n    // To get the actual selection,\n    // 1. get all selected profit projects (selected = not cut edges, so still reachable -> mf.l can be used)\n    // 2. find all dependencies by BFS\n    profit_t Solve() {\n        profit_t sum = 0;\n        for (int i = 0; i < (int)profits.size(); i++) {\n            auto p = profits[i];\n            if (p > 0) {\n                sum += p;\n            }\n        }\n        sum -= mf.solve(source, sink);\n        return sum;\n    }\n};\n\n\nint main() {\n    // CF366 D\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    int r, b;\n    scanf(""%d%d"", &r, &b);\n    vector<pair<int, int>> points; points.reserve(n);\n    map<int, int> X, Y; // x -> count\n    map<int, int> Xi, Yi; // x -> count\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(""%d%d"", &x, &y);\n        points.emplace_back(x, y);\n        X[x]++;\n        Y[y]++;\n    }\n    vector<pair<int, int>> rangexy(X.size() + Y.size());\n    {\n\n        int i = 0;\n        for (auto kv : X) {\n            rangexy[i].second = kv.second;\n            Xi[kv.first] = i;\n            i++;\n        }\n        for (auto kv : Y) {\n            rangexy[i].second = kv.second;\n            Yi[kv.first] = i;\n            i++;\n        }\n    }\n    MaxFlowEdgeDemand mf;\n    int source = (int)(X.size() + Y.size());\n    int sink = (int)(X.size() + Y.size() + 1);\n    mf.init((int)(X.size() + Y.size() + 2));\n    for (int i = 0; i < n; i++) {\n        int xi = Xi[points[i].first];\n        int yi = Yi[points[i].second];\n        mf.addEdgeSave(xi, yi, 0, 1, i);\n    }\n    for (int i = 0; i < m; i++) {\n        int t, l, d;\n        scanf(""%d%d%d"", &t, &l, &d);\n        if (t == 1) {\n            auto I = X.find(l);\n            if (I == X.end()) continue;\n            int cnt = I->second;\n            int lower = (-d + cnt); if (lower % 2) lower++; lower /= 2;\n            int upper = (d + cnt); if (upper % 2) upper--; upper /= 2;\n            rangexy[Xi[l]].first = max(rangexy[Xi[l]].first, lower);\n            rangexy[Xi[l]].second = min(rangexy[Xi[l]].second, upper);\n        } else if (t == 2) {\n            auto I = Y.find(l);\n            if (I == Y.end()) continue;\n            int cnt = I->second;\n            int lower = (-d + cnt); if (lower % 2) lower++; lower /= 2;\n            int upper = (d + cnt); if (upper % 2) upper--; upper /= 2;\n            rangexy[Yi[l]].first = max(rangexy[Yi[l]].first, lower);\n            rangexy[Yi[l]].second = min(rangexy[Yi[l]].second, upper);\n        }\n    }\n    for (int i = 0; i < (int)rangexy.size(); i++) {\n        if (rangexy[i].first > rangexy[i].second) {\n            printf(""-1\\n"");\n            return 0;\n        }\n        if (i < (int)X.size()) {\n            mf.addEdge(source, i, rangexy[i].first, rangexy[i].second);\n        } else {\n            mf.addEdge(i, sink, rangexy[i].first, rangexy[i].second);\n        }\n    }\n\n    auto result = mf.solveFeasibility(source, sink);\n    if (result < 0) {\n        printf(""-1\\n"");\n        return 0;\n    }\n\n    bool swapped = false;\n    if (r > b) {\n        swap(r, b);\n        swapped = true;\n    }\n\n    long long cost = (long long)r * n + (long long)(n-result) * (b-r);\n    printf(""%lld\\n"", cost);\n    string ans(n, \'?\');\n    for (int i = 0; i < (int)X.size(); i++) {\n        for (const auto &edge : mf.mf.graph[i + 2]) {\n            if (edge.save >= 0) {\n                bool filled = (edge.res == 0);\n                ans[edge.save] = ((swapped == filled) ? \'b\' : \'r\');\n            }\n        }\n    }\n    printf(""%s\\n"", ans.c_str());\n    return 0;\n}\n\n']","['flows', 'greedy']",3100
https://codeforces.com//contest/219/problem/E,E. Parking Lot,A parking lot in the City consists of parking spaces standing in a line The parking spaces are numbered from 1 to from left to right When a car arrives at the lot the operator determines an empty parking space for it For the safety s sake the chosen place should be located as far from the already occupied places as possible That is the closest occupied parking space must be as far away as possible If there are several such places then the operator chooses the place with the minimum index from them If all parking lot places are empty then the car gets place number We consider the distance between the th and the th parking spaces equal to meters You are given the parking lot records of arriving and departing cars in the chronological order For each record of an arriving car print the number of the parking lot that was given to this car ,"['#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nconst int maxn  =   200005;\nconst int maxid =   1000005;\n\nstruct node\n{\n    int maxlen;\n    int sl,sr,len;\n}tree[maxn*4];\nint position[maxid],n,m;\n\ninline node merge(const node &a,const node &b)\n{\n    node ret;\n    ret.maxlen=max(a.maxlen,b.maxlen);\n    ret.maxlen=max(ret.maxlen,a.sr+b.sl);\n    ret.sl=a.sl;\n    if (a.sl==a.len) ret.sl+=b.sl;\n    ret.sr=b.sr;\n    if (b.sr==b.len) ret.sr+=a.sr;\n    ret.len=a.len+b.len;\n    return ret;\n}\n\ninline void build(int num,int l,int r)\n{\n    tree[num].maxlen=tree[num].sl=tree[num].sr=tree[num].len=r-l+1;\n    if (l==r) return;\n    int mid=(l+r)/2;\n    build(num*2,l,mid);\n    build(num*2+1,mid+1,r);\n}\n\ninline void insert(int num,int l,int r,int pos,int delta)\n{\n    if (l==r){\n        if (delta==1){\n            tree[num].maxlen=tree[num].sl=tree[num].sr=0;\n        }else{\n            tree[num].maxlen=tree[num].sl=tree[num].sr=1;\n        }\n        return;\n    }\n    int mid=(l+r)/2;\n    if (pos<=mid) insert(num*2,l,mid,pos,delta);\n    else insert(num*2+1,mid+1,r,pos,delta);\n    tree[num]=merge(tree[num*2],tree[num*2+1]);\n}\n\ninline int query(int num,int l,int r,int tar)\n{\n    if (l==r){\n        return l;\n    }\n    if (l==1 && tree[num].sl>=tar) return 1;\n    int mid=(l+r)/2;\n    if ((tree[num*2].maxlen+1)>=tar*2){\n        return query(num*2,l,mid,tar);\n    }\n    if ((tree[num*2].sr+tree[num*2+1].sl)+1>=tar*2){\n        return (mid-tree[num*2].sr+tar);\n    }\n    return query(num*2+1,mid+1,r,tar);\n}\n\nint main()\n{\n    scanf(""%d%d"",&n,&m);\n    build(1,1,n);\n    for (int i=0;i<m;++i){\n        int t,id;\n        scanf(""%d%d"",&t,&id);\n        if (t==1){\n            int len=(tree[1].maxlen+1)/2;\n            len=max(tree[1].sl,len);\n            len=max(tree[1].sr,len);\n            \n            int pos=query(1,1,n,len);\n            position[id]=pos;\n            insert(1,1,n,pos,1);\n            printf(""%d\\n"",pos);\n        }else{\n            int pos=position[id];\n            insert(1,1,n,pos,-1);\n        }\n    }\n    \n    return 0;\n}\n']",['data structures'],2200
https://codeforces.com//contest/1810/problem/B,B. Candies,This problem is about candy Initially you only have 1 candy and you want to have exactly n candies You can use the two following spells in any order at most 40 times in total Assume you have x candies now If you use the first spell then x candies become 2x 1 candies Assume you have x candies now If you use the second spell then x candies become 2x 1 candies Construct a sequence of spells such that after using them in order you will have n candies or determine it s impossible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    if (n % 2 == 0) {\n        std::cout << -1 << ""\\n"";\n        return;\n    }\n    \n    std::vector<int> ans;\n    while (n != 1) {\n        if ((n + 1) / 2 % 2 == 1) {\n            n += 1;\n            ans.push_back(1);\n        } else {\n            n -= 1;\n            ans.push_back(2);\n        }\n        n /= 2;\n    }\n    \n    std::reverse(ans.begin(), ans.end());\n    std::cout << ans.size() << ""\\n"";\n    for (int i = 0; i < ans.size(); i++) {\n        std::cout << ans[i] << "" \\n""[i == ans.size() - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'math', 'number theory']",800
https://codeforces.com//contest/978/problem/A,A. Remove Duplicates,Petya has an array a consisting of n integers He wants to remove duplicate equal elements Petya wants to leave only the rightmost entry occurrence for each element of the array The relative order of the remaining unique elements should not be changed ,"[""#include <bits/stdc++.h>\n#define DIM 57\nusing namespace std;\n\nlong long n,a[DIM],used[1007];\nint main()\n{\n    cin>>n;\n    for(int i = 1; i<= n; ++i)\n        cin>>a[i];\n\n    vector<long long> ans;\n    for(int i = n;i>=1;--i)\n        if(used[a[i]]==0)\n    {\n        used[a[i]] = 1;\n        ans.push_back(a[i]);\n    }\n\n    reverse(ans.begin(),ans.end());\n    cout<<ans.size()<<endl;\n    for(auto i:ans)\n        cout<<i<<' ';\n    return 0;\n}\n""]",['implementation'],800
https://codeforces.com//contest/888/problem/D,D. Almost Identity Permutations,A permutation of size is an array such that every integer from to occurs exactly once in this array Let s call a permutation an iff there exist at least indices such that Your task is to count the number of permutations for given numbers and ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\nLL n , k;\nvoid init(){\n  n = getint();\n  k = getint();\n}\ninline LL C( LL a , LL b ){\n  LL ret = 1;\n  for( LL i = 0 ; i < b ; i ++ )\n    ret *= ( a - i );\n  for( LL i = 0 ; i < b ; i ++ )\n    ret /= ( b - i );\n  return ret;\n}\nLL cal( LL x ){\n  if( x == 1 ) return 0;\n  if( x == 0 ) return 1;\n  LL way = C( n , x );\n  if( x == 2 ) return way;\n  if( x == 3 ) return way * 2;\n  return way * 9;\n}\nvoid solve(){\n  LL ans = 0;\n  for( int i = 0 ; i <= k ; i ++ )\n    ans += cal( i );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","['combinatorics', 'dp', 'math']",1600
https://codeforces.com//contest/1582/problem/E,E. Pchelyonok and Segments,Pchelyonok decided to give Mila a gift Pchelenok has already bought an array a of length n but gifting an array is too common Instead of that he decided to gift Mila the segments of that array Pchelyonok wants his gift to be beautiful so he decided to choose k non overlapping segments of the array l 1 r 1 l 2 r 2 ldots l k r k such that the length of the first segment l 1 r 1 is k the length of the second segment l 2 r 2 is k 1 ldots the length of the k th segment l k r k is 1 for each i j the i th segment occurs in the array earlier than the j th i e r i l j the sums in these segments are strictly increasing i e let sum l ldots r sum limits i l r a i the sum of numbers in the segment l r of the array then sum l 1 ldots r 1 sum l 2 ldots r 2 ldots sum l k ldots r k Pchelenok also wants his gift to be as beautiful as possible so he asks you to find the maximal value of k such that he can give Mila a gift ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""e.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tvector<ll> s0(n + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t\ts0[i + 1] = s0[i] + a[i];\n\t\t}\n\t\tauto s = [&](int i, int j) {\n\t\t\treturn s0[j + 1] - s0[i];\n\t\t};\n\t\tint m = 0;\n\t\twhile (m * (m + 1) / 2 <= n) {\n\t\t\t++m;\n\t\t}\n\t\tm += 2;\n\t\tconst ll INF = (1LL << 62);\n\t\tvector<vector<ll>> f(m + 1, vector<ll>(m));\n\t\tvector<vector<ll>*> g(n + 1);\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tg[i] = &f[i % (m + 1)];\n\t\t}\n\t\t(*g[n])[0] = INF;\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tauto& cur = (*g[i]);\n\t\t\tcur[0] = INF;\n\t\t\tauto& prev = (*g[i + 1]);;\n\t\t\tfor (int k = 1; k < m; ++k) {\n\t\t\t\tcur[k] = prev[k];\n\t\t\t\tif (i + k - 1 < n) {\n\t\t\t\t\tll s2 = s(i, i + k - 1);\n\t\t\t\t\tif (s2 < (*g[i + k])[k - 1]) {\n\t\t\t\t\t\tcur[k] = max(cur[k], s2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 1;\n\t\tfor (int k = 1; k < m; ++k) {\n\t\t\tif (f[0][k] > 0) {\n\t\t\t\tret = k;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ret);\n\t}\n\treturn 0;\n}\n']","['binary search', 'data structures', 'dp', 'greedy', 'math']",2000
https://codeforces.com//contest/1265/problem/A,A. Beautiful String,A string is called beautiful if no two consecutive characters are equal For example and are beautiful strings while and are not Ahcl wants to construct a beautiful string He has a string s consisting of only characters and Ahcl needs to replace each character with one of the three characters or such that the resulting string is beautiful Please help him More formally after replacing all characters the condition s i neq s i 1 should be satisfied for all 1 leq i leq s 1 where s is the length of the string s ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=1e5+5;\nchar s[maxn];\nint n;\nint main(){\n\tint cas=read();\n\twhile(cas--){\n\t\tscanf(""%s"",s+1);\n\t\tn=strlen(s+1);\n\t\tint ok=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]==\'?\'){\n\t\t\t\tif(s[i-1]!=\'a\'&&s[i+1]!=\'a\')s[i]=\'a\';\n\t\t\t\telse if(s[i-1]!=\'b\'&&s[i+1]!=\'b\')s[i]=\'b\';\n\t\t\t\telse if(s[i-1]!=\'c\'&&s[i+1]!=\'c\')s[i]=\'c\';\n\t\t\t}else{\n\t\t\t\tif(s[i]==s[i-1]){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(""-1"");\n\t\telse{\n\t\t\tfor(int i=1;i<=n;i++)cout<<s[i];cout<<\'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n\n']","['constructive algorithms', 'greedy']",1000
https://codeforces.com//contest/1759/problem/B,B. Lost Permutation,A sequence of n numbers is called a permutation if it contains all integers from 1 to n exactly once For example the sequences 3 1 4 2 1 and 2 1 are permutations but 1 2 1 0 1 and 1 3 4 are not Polycarp lost his favorite permutation and found only some of its elements the numbers b 1 b 2 dots b m He is sure that the sum of the lost elements equals s Determine whether one or more numbers can be appended to the given sequence b 1 b 2 dots b m such that the sum of the added numbers equals s and the resulting new array is a permutation ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nvoid solve(){\n    int m, s;\n    cin >> m >> s;\n    int a[m], mx = 0, sum = 0;\n    rep(i, m) cin >> a[i], mx = max(mx, a[i]), sum += a[i];\n    int curS = mx * (mx + 1) / 2 - sum;\n    while(curS < s) curS += ++mx;\n    cout << (curS == s ? ""Yes"" : ""No"") << \'\\n\';\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']",['math'],800
https://codeforces.com//contest/1800/problem/D,D. Remove Two Letters,Dmitry has a string s consisting of lowercase Latin letters Dmitry decided to remove two characters from the string s and you are wondering how many different strings can be obtained after such an operation For example Dmitry has a string You can get the following different strings by deleting the first two or second and third characters by deleting the third and fourth characters by deleting the fourth and the fifth character and by deleting the last two ,"['// I am teacher of MakaPakka\n// LOUGI_ID:643723\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(x,y) for(int x=0;x<(y);x++)\ninline int in(){\n  int x;\n  cin >> x;\n  return x;\n}\nvoid solve(){\n  int n=in();\n  string s;cin>>s;\n  s=""$""+s+""$"";\n  int ans=0;\n  for(int i=1;i+1<=n;i++){\n    ans+=(s[i-1]!=s[i+1]);\n  }\n  cout<<ans<<""\\n"";\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while(T--) solve();\n}']","['data structures', 'greedy', 'hashing', 'strings']",1200
https://codeforces.com//contest/1236/problem/D,D. Alice and the Doll,Alice got a new doll these days It can even walk Alice has built a maze for the doll and wants to test it The maze is a grid with n rows and m columns There are k obstacles the i th of them is on the cell x i y i which means the cell in the intersection of the x i th row and the y i th column However the doll is clumsy in some ways It can only walk straight or turn right at most once in the same cell including the start cell It cannot get into a cell with an obstacle or get out of the maze More formally there exist 4 directions in which the doll can look The doll looks in the direction along the row from the first cell to the last While moving looking in this direction the doll will move from the cell x y into the cell x y 1 The doll looks in the direction along the column from the first cell to the last While moving looking in this direction the doll will move from the cell x y into the cell x 1 y The doll looks in the direction along the row from the last cell to first While moving looking in this direction the doll will move from the cell x y into the cell x y 1 The doll looks in the direction along the column from the last cell to the first While moving looking in this direction the doll will move from the cell x y into the cell x 1 y Standing in some cell the doll can move into the cell in the direction it looks or it can turn right once Turning right once the doll switches it s direction by the following rules 1 to 2 2 to 3 3 to 4 4 to 1 Standing in one cell the doll can make at most one turn right Now Alice is controlling the doll s moves She puts the doll in of the cell 1 1 the upper left cell of the maze Initially the doll looks to the direction 1 so along the row from the first cell to the last She wants to let the doll walk across all the cells without obstacles exactly once and end in any place Can it be achieved ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl \'\\n\'\ntypedef long long ll;\n\nconst int N = 1e5+5;\nset<int> iToj[N];\nset<int> jToi[N];\n\nsigned main() {\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    for(int i=0;i<k;++i){\n        int I,J;\n        cin>>I>>J;\n        iToj[I].insert(J);\n        jToi[J].insert(I);\n    }\n    int mni = 0, mxi = n+1, mnj = 0, mxj = m+1;\n    pair<int, int> pos = {1,1};\n    int dir = 0;\n    int cnt = 1;\n    bool First = true;\n    while(true) {\n        assert(!iToj[pos.first].count(pos.second));//remove\n        //cout << ""here, cnt: "" << cnt << endl;\n        //cout << ""here, pos: "" << pos.first << \' \'<< pos.second << endl;\n        //cout << ""bounds: ""<< mni << \' \' << mnj << \' \' << mxi << \' \' << mxj << endl;\n            //cout << ""\\n\\n"";\n        if(dir == 0) {\n            pair<int,int> next = pos;\n            next.second = mxj-1;\n            auto it = iToj[pos.first].upper_bound(pos.second);\n            if(it != iToj[pos.first].end()) {\n                next.second = min(next.second, *it-1);\n            }\n            if(next.second <= pos.second) {\n                if(First) {\n                    dir = (dir+1)%4;\n                    First = false;\n                    continue;\n                }\n                break;\n            }\n            cnt += next.second - pos.second;\n            mxj = next.second;\n            mni = next.first;\n            pos = next;\n        } else if(dir == 1) {\n\n\n            pair<int,int> next = pos;\n            next.first = mxi-1;\n            auto it = jToi[pos.second].upper_bound(pos.first);\n            if(it != jToi[pos.second].end()) {\n                next.first = min(next.first, *it-1);\n            }\n            if(next.first <= pos.first) {\n                //cout << ""deuaslfj\\n"";\n                break;\n            }\n\n            cnt += next.first - pos.first;\n            mxi = next.first;\n            mxj = next.second;\n            pos = next;\n\n\n\n        } else if(dir == 2) {\n            pair<int,int> next = pos;\n            next.second = mnj+1;\n            auto it = iToj[pos.first].lower_bound(pos.second);\n            if(it != iToj[pos.first].begin()) {\n                --it;\n                next.second = max(next.second, *it+1);\n            }\n            if(next.second >= pos.second) {\n\n                break;\n            }\n            cnt += pos.second - next.second;\n            mnj = next.second;\n            mxi = next.first;\n            pos = next;\n\n        } else {\n            pair<int,int> next = pos;\n            next.first = mni+1;\n            auto it = jToi[pos.second].lower_bound(pos.first);\n            if(it != jToi[pos.second].begin()) {\n                --it;\n                next.first = max(next.first, *it+1);\n            }\n            if(next.first >= pos.first) {\n\n                break;\n            }\n            cnt += pos.first - next.first;\n            mni = next.first;\n            mnj = next.second;\n            pos = next;\n\n        }\n        dir = (dir+1)%4;\n        First = false;\n    }\n    //cout << ""cnt: "" << cnt << endl;\n    cout << (cnt + k == n*m ? ""Yes"":""No"");\n}\n']","['brute force', 'data structures', 'greedy', 'implementation']",2300
https://codeforces.com//contest/1421/problem/B,B. Putting Bricks in the Wall,Roger Waters has a square grid of size n times n and he wants to traverse his grid from the upper left 1 1 corner to the lower right corner n n Waters can move from a square to any other square adjacent by a side as long as he is still in the grid Also except for the cells 1 1 and n n every cell has a value 0 or 1 in it Before starting his traversal he will pick either a 0 or a 1 and will be able to only go to cells values in which are equal to the digit he chose The starting and finishing cells 1 1 and n n are exempt from this rule he may go through them regardless of picked digit Because of this the cell 1 1 takes value the letter and the cell n n takes value the letter For example in the first example test case he can go from 1 1 to n n by using the zeroes on this path 1 1 2 1 2 2 2 3 3 3 3 4 4 4 The rest of the band Pink Floyd wants Waters to not be able to do his traversal so while he is not looking they will in the grid from 0 to 1 or vice versa They are afraid they will not be quick enough and asked for your help in choosing the cells We can show that there always exists a solution for the given constraints Also note that Waters will pick his digit of the traversal after the band has changed his grid so he must not be able to reach n n no matter what digit he picks ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nchar s[505][505];\nint main(){\n\tint t, n;\n\tfor(cin >> t; t--;) {\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n ; i ++) cin >> s[i];\n\t\tif(s[0][1] == s[1][0]) {\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tif(s[0][1] != s[n - 1][n - 2]) {\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << 2 << endl;\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t\tcout << ""2 1"" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == s[0][1]) {\n\t\t\t\t\tcout << n << \' \' << n - 1 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << n - 1<< \' \' << n << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[0][1] == s[n - 1][n - 2]) {\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t}\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 2 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == \'1\') cout << n << \' \' << n - 1 << endl;\n\t\t\t\telse cout << n - 1 << "" "" << n << endl;\n\t\t\t\tif(s[0][1] == \'0\') cout << ""1 2"" << endl;\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n']","['constructive algorithms', 'implementation']",1100
https://codeforces.com//contest/1453/problem/F,F. Even Harder,Gildong is now developing a puzzle game The puzzle consists of n platforms numbered from 1 to n The player plays the game as a character that can stand on each platform and the goal of the game is to move the character from the 1 st platform to the n th platform The i th platform is labeled with an integer a i 0 le a i le n i When the character is standing on the i th platform the player can move the character to any of the j th platforms where i 1 le j le i a i If the character is on the i th platform where a i 0 and i ne n the player loses the game Since Gildong thinks the current game is not hard enough he wants to make it even harder He wants to change some possibly zero labels to 0 so that there remains exactly one way to win He wants to modify the game as little as possible so he s asking you to find the number of platforms that should have their labels changed Two ways are different if and only if there exists a platform the character gets to in one way but not in the other way ,"['#include<bits/stdc++.h>\nusing namespace std;\nint _,n,dp[3005][3005],tot,a[3005],F[3005];\nint main(){\n    cin >> _;\n    while (_--){\n        cin >> n;\n        for (int i=1;i<=n;i++) cin >> a[i];\n        for (int i=1;i<=n+1;i++)\n        for (int j=1;j<=n+1;j++) dp[i][j]=n+1;\n        dp[1][1]=0;\n        F[1]=0;\n        for (int i=2;i<=n;i++) F[i]=n+1;\n        for (int i=2;i<=n;i++){\n            for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][i]);\n            tot=0;\n            for (int j=i-1;j;j--){\n                if (j+a[j]>=i){\n                    dp[i][j+a[j]+1]=min(dp[i][j+a[j]+1],F[j]+tot);\n                    ++tot;\n                }\n            }\n        }\n        for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][n+1]);\n        cout << F[n] << endl;\n    }\n    return 0;\n}\n']",['dp'],2700
https://codeforces.com//contest/1029/problem/A,A. Many Equal Substrings,You are given a string t consisting of n lowercase Latin letters and an integer number k Let s define a substring of some string s with indices from l to r as s l dots r Your task is to construct such string s of minimum possible length that there are exactly k positions i such that s i dots i n 1 t In other words your task is to construct such string s of minimum possible length that there are exactly k substrings of s equal to t It is guaranteed that the answer is always unique ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n\n\nint n,k;\n\nstring t;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n >> k >> t;\n    int mx=0;\n    for(int i=1;i<n;i++){\n        int gd=1;\n        for(int j=0;j<i;j++){\n            if(t[j]!=t[n-i+j]) gd=0;\n        }\n        if(gd) mx=i;\n    }\n    cout << t;\n    for(int i=2;i<=k;i++){\n        for(int j=mx;j<n;j++) cout << t[j];\n    }\n}\n']","['implementation', 'strings']",1300
https://codeforces.com//contest/1707/problem/E,E. Replace,You are given an integer array a 1 ldots a n where 1 le a i le n for all i There s a replace function f which takes a pair of integers l r where l le r as input and outputs the pair f big l r big left min a l a l 1 ldots a r max a l a l 1 ldots a r right Consider repeated calls of this function That is from a starting pair l r we get f big l r big then f big f big l r big big then f big f big f big l r big big big and so on Now you need to answer q queries For the i th query you have two integers l i and r i 1 le l i le r i le n You must answer the minimum number of times you must apply the replace function to the pair l i r i to get 1 n or report that it is impossible ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nint Log[100001];\nint n,q,a[100001],L[100001],R[100001];\nstruct ST{\n\tint st[100001][21];\n\tvoid init(){\n\t\tfor(int j=1;(1<<j)<=n;++j)\n\t\t\tfor(int i=1;i+(1<<j)-1<=n;++i)\n\t\t\t\tst[i][j]=std::min(st[i][j-1],st[i+(1<<(j-1))][j-1]);\n\t}\n\tint query(int l,int r){\n\t\tif(l>r)return 0x7f7f7f7f;\n\t\tint k=Log[r-l+1];\n\t\treturn std::min(st[l][k],st[r-(1<<k)+1][k]);\n\t}\n}mn[21],mx[21],amn;\nint f[100001];\nint dis[100001];\nint Q[100001],h,t;\nstd::vector<int>vec[1000001];\nvoid add(int root,int l,int r,int el,int er,int x){\n\tif(el>r||er<l)return;\n\tif(el<=l&&er>=r){\n\t\tvec[root].push_back(x);\n\t\t// printf(""add %d %d\\n"",root,x);\n\t\treturn;\n\t}\n\tadd(root<<1,l,(l+r)>>1,el,er,x);\n\tadd(root<<1|1,((l+r)>>1)+1,r,el,er,x);\n}\nvoid upd(int root,int l,int r,int e,int d){\n\tfor(int i=0;i<vec[root].size();++i){\n\t\tint u=vec[root][i];\n\t\tif(dis[vec[root][i]]>d){\n\t\t\tdis[u]=d;\n\t\t\tQ[++t]=u;\n\t\t}\n\t}\n\tvec[root].clear();\n\tif(l==r)return;\n\tif((l+r)>>1>=e)upd(root<<1,l,(l+r)>>1,e,d);\n\telse upd(root<<1|1,((l+r)>>1)+1,r,e,d);\n}\nint ans[100001];\nbool vis[100001];\nvoid upd2(int root,int l,int r,int e,int d){\n\tfor(int i=0;i<vec[root].size();++i){\n\t\tint u=vec[root][i];\n\t\tif(ans[vec[root][i]]==-1){\n\t\t\tans[u]=d;\n\t\t\tQ[++t]=u;\n\t\t}\n\t}\n\tvec[root].clear();\n\tif(l==r)return;\n\tif((l+r)>>1>=e)upd2(root<<1,l,(l+r)>>1,e,d);\n\telse upd2(root<<1|1,((l+r)>>1)+1,r,e,d);\n}\nint getans(int l,int r,int st){\n\tfor(int i=20;~i;--i)\n\t\tif(st>=(1<<i)){\n\t\t\tst-=1<<i;\n\t\t\tint ol=l,Or=r;\n\t\t\tl=mn[i].query(ol,Or);\n\t\t\tr=-mx[i].query(ol,Or);\n\t\t}\n\treturn r;\n}\nint g[100001];\nvoid upd3(int root,int l,int r,int e,int d){\n\t// printf(""%d %d %d\\n"",root,l,r);\n\tfor(int i=0;i<vec[root].size();++i){\n\t\tint u=vec[root][i];\n\t\t// printf(""%d\\n"",u);\n\t\tif(f[vec[root][i]]==-1){\n\t\t\tf[u]=d+g[u];\n\t\t\tQ[++t]=u;\n\t\t}\n\t}\n\tvec[root].clear();\n\tif(l==r)return;\n\tif((l+r)>>1>=e)upd3(root<<1,l,(l+r)>>1,e,d);\n\telse upd3(root<<1|1,((l+r)>>1)+1,r,e,d);\n}\nint main(){\n\tscanf(""%d%d"",&n,&q);\n\tfor(int i=1;i<=n;++i)scanf(""%d"",a+i);\n\tfor(int i=2;i<=n;++i)Log[i]=Log[i>>1]+1;\n\tfor(int i=1;i<n;++i)L[i]=std::min(a[i],a[i+1]),R[i]=std::max(a[i],a[i+1])-1;\n\tfor(int i=0;(1<<i)<=n;++i){\n\t\tfor(int j=1;j<n;++j){\n\t\t\tif(i==0){\n\t\t\t\tmn[i].st[j][0]=L[j];\n\t\t\t\tmx[i].st[j][0]=-(R[j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint l=mn[i-1].query(j,j);\n\t\t\t\tint r=-mx[i-1].query(j,j);\n\t\t\t\tmn[i].st[j][0]=mn[i-1].query(l,r);\n\t\t\t\tmx[i].st[j][0]=mx[i-1].query(l,r);\n\t\t\t\t// printf(""%d %d %d %d %d %d\\n"",j,i,l,r,mn[i-1].query(l,r),-mx[i-1].query(l,r));\n\t\t\t}\n\t\t}\n\t\tmn[i].init();\n\t\tmx[i].init();\n\t}\n\tfor(int i=2;i<n;++i)add(1,1,n,L[i],R[i],i);\n\tfor(int i=1;i<=n;++i)dis[i]=0x7f7f7f7f;\n\tQ[++t]=1;\n\tdis[1]=0;\n\twhile(h<t){\n\t\t++h;\n\t\tupd(1,1,n,Q[h],dis[Q[h]]+1);\n\t}\n\tfor(int i=1;i<n;++i)amn.st[i][0]=dis[i];\n\tamn.init();\n\tfor(int i=1;i<=1000000;++i)vec[i].clear();\n\tfor(int i=1;i<=n;++i)add(1,1,n,a[i],a[i],i);\n\th=t=0;\n\tfor(int i=1;i<=n;++i)ans[i]=-1;\n\tQ[++t]=1;\n\tans[1]=0;\n\twhile(h<t){\n\t\t++h;\n\t\tupd2(1,1,n,Q[h],ans[Q[h]]+1);\n\t}\n\t// for(int i=1;i<=n;++i)printf(""%d "",ans[i]);putchar(\'\\n\');\n\tfor(int i=1;i<=1000000;++i)vec[i].clear();\n\tfor(int i=1;i<n-1;++i){\n\t\tint L=mn[0].query(1,i),R=-mx[0].query(1,i);\n\t\tint mn=amn.query(L,R);\n\t\tif(mn==0x7f7f7f7f)f[i]=-1;\n\t\telse{\n\t\t\t++mn;\n\t\t\tint now=getans(1,i,mn);\n\t\t\t// printf(""%d %d %d\\n"",i,now,mn);\n\t\t\tf[i]=-1;\n\t\t\tg[i]=mn;\n\t\t\tadd(1,1,n,now,now,i);\n\t\t}\n\t}\n\th=t=0;\n\tQ[++t]=n-1;\n\tf[n-1]=0;\n\twhile(h<t){\n\t\t++h;\n\t\t// printf(""%d\\n"",Q[h]);\n\t\tupd3(1,1,n,Q[h],f[Q[h]]);\n\t}\n\t// for(int i=1;i<n;++i)printf(""%d "",f[i]);putchar(\'\\n\');\n\tfor(int i=1,l,r;i<=q;++i){\n\t\tscanf(""%d%d"",&l,&r);\n\t\tif(l==r){\n\t\t\tif(n==1)puts(""0"");\n\t\t\telse puts(""-1"");\n\t\t}\n\t\telse{\n\t\t\tint mn=amn.query(l,r-1);\n\t\t\t// printf(""%d\\n"",mn);\n\t\t\tif(mn==0x7f7f7f7f)puts(""-1"");\n\t\t\telse{\n\t\t\t\tint now=getans(l,r-1,mn);\n\t\t\t\t// printf(""%d\\n"",now);\n\t\t\t\tif(f[now]==-1)puts(""-1"");\n\t\t\t\telse printf(""%d\\n"",mn+f[now]);\n\t\t\t}\n\t\t}\n\t}\n}']","['binary search', 'data structures']",3500
https://codeforces.com//contest/1922/problem/C,C. Closest Cities,There are n cities located on the number line the i th city is in the point a i The coordinates of the cities are given in ascending order so a 1 a 2 dots a n The distance between two cities x and y is equal to a x a y For each city i let s define the city j as the city such that the distance between i and j is not greater than the distance between i and each other city k For example if the cities are located in points 0 8 12 15 20 then the closest city to the city 1 is the city 2 the closest city to the city 2 is the city 3 the closest city to the city 3 is the city 4 the closest city to the city 4 is the city 3 the closest city to the city 5 is the city 4 The cities are located in such a way that for every city the closest city is unique For example it is impossible for the cities to be situated in points 1 2 3 since this would mean that the city 2 has two closest cities 1 and 3 both having distance 1 You can travel between cities Suppose you are currently in the city x Then you can perform one of the following actions travel to any other city y paying a x a y coins travel to the city which is the closest to x paying 1 coin You are given m queries In each query you will be given two cities and you have to calculate the minimum number of coins you have to spend to travel from one city to the other city ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include ""debug.h""  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& ai : a) { cin >> ai; }\n    vector<int> b(n), c(n);\n    for (int i = 1; i < n; i += 1) {\n      if (i == 1 or a[i] - a[i - 1] < a[i - 1] - a[i - 2]) {\n        b[i] = a[i] - a[i - 1] - 1;\n      }\n      b[i] += b[i - 1];\n    }\n    for (int i = n - 2; i >= 0; i -= 1) {\n      if (i == n - 2 or a[i + 1] - a[i] < a[i + 2] - a[i + 1]) {\n        c[i] = a[i + 1] - a[i] - 1;\n      }\n      c[i] += c[i + 1];\n    }\n    int m;\n    cin >> m;\n    for (int i = 0, x, y; i < m; i += 1) {\n      cin >> x >> y;\n      x -= 1;\n      y -= 1;\n      int ans = abs(a[x] - a[y]);\n      cout << ans - (x < y ? b[y] - b[x] : c[y] - c[x]) << ""\\n"";\n    }\n  }\n}']","['greedy', 'implementation', 'math']",1300
https://codeforces.com//contest/1167/problem/G,G. Low Budget Inception,So we got bored and decided to take our own guess at how would Inception production go if the budget for the film had been terribly low The first scene we remembered was the one that features the whole city bending onto itself It feels like it will require high CGI expenses doesn t it Luckily we came up with a similar looking scene which was a tiny bit cheaper to make Firstly forget about 3D that s hard and expensive The city is now represented as a number line Secondly the city doesn t have to look natural at all There are n buildings on the line Each building is a square 1 times 1 Lower corners of building i are at integer points a i and a i 1 of the number line Also the distance between any two neighbouring buildings i and i 1 doesn t exceed d Distance between some neighbouring buildings i and i 1 is calculated from the lower right corner of building i to the lower left corner of building i 1 Finally curvature of the bend is also really hard to simulate Let the bend at some integer coordinate x be performed with the following algorithm Take the ray from x to infty and all the buildings which are on this ray and start turning the ray and the buildings counter clockwise around point x At some angle some building will touch either another building or a part of the line You have to stop bending there The only thing left is to decide what integer point x is the best to start bending around Fortunately we ve already chosen m candidates to perform the bending So can you please help us to calculate terminal angle alpha x for each bend x from our list of candidates ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nusing ld=long double;\nconst ld pi=2*acosl(0);\n\nint n, d;\nll tab[nax];\n\nint q;\n\nld kont(int a)\n{\n\treturn atan(1.0/a);\n}\n\nld kont(int a, int b)\n{\n\tassert(abs(a-b)<=1);\n\treturn 2*kont(max(a, b));\n}\n\nvoid out(ld v)\n{\n\tprintf(""%.11lf\\n"", (double)v);\n}\n\nvoid query()\n{\n\tll x;\n\tscanf(""%lld"", &x);\n\tif (x==tab[0] || x==tab[n]+1)\n\t{\n\t\tout(pi/2);\n\t\treturn;\n\t}\n\tint bsa=1;\n\tint bsb=n-1;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb+2)>>1;\n\t\tif (x>tab[bss])\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tint g=bsa;\n\tassert(x>tab[g] && x<=tab[g+1]);\n\tif (x==tab[g]+1 && x==tab[g+1])\n\t{\n\t\tout(pi);\n\t\treturn;\n\t}\n\tif (x==tab[g]+1 || x==tab[g+1])\n\t{\n\t\tout(pi/2);\n\t\treturn;\n\t}\n\tld wyn=kont(min(tab[g+1]-x, x-tab[g]-1));\n\tint a=g;\n\tint b=g+1;\n\tconst ll lim=min(tab[g+1]-x, x-tab[g]-1)*2+7;\n\twhile(a>0 && b<=n && tab[b]-x<=lim)\n\t{\n\t\tif (abs( (x-tab[a]-1)-(tab[b]-x) )<=1)\n\t\t\tbreak;\n\t\tif (x-tab[a]-1<tab[b]-x)\n\t\t\ta--;\n\t\telse\n\t\t\tb++;\n\t}\n\tif (a>=1 && b<=n && abs( (x-tab[a]-1)-(tab[b]-x) )<=1)\n\t\twyn=max(wyn, kont(x-tab[a]-1, tab[b]-x));\n\tout(wyn);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &d);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tscanf(""%d"", &q);\n\twhile(q--)\n\t\tquery();\n\treturn 0;\n}\n']","['brute force', 'geometry']",3100
https://codeforces.com//contest/1774/problem/G,G. Segment Covering,ChthollyNotaSeniorious gives DataStructures a number axis with m distinct segments on it Let f l r be the number of ways to choose an even number of segments such that the union of them is exactly l r and g l r be the number of ways to choose an odd number of segments such that the union of them is exactly l r ChthollyNotaSeniorious asked DataStructures q questions In each query ChthollyNotaSeniorious will give DataStructures two numbers l r and now he wishes that you can help him find the value f l r g l r modulo 998 244 353 so that he wouldn t let her down ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint n, m;\npii a[N];\npii b[N];\nint cntBad[N];\nint par[N][LOG];\nint h[N];\n\nint up(int v, int dh) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((dh >> k) & 1)\n\t\t\tv = par[v][k];\n\treturn v;\n}\nint LCA(int v, int u) {\n\tif (h[v] > h[u]) swap(v, u);\n\tu = up(u, h[u] - h[v]);\n\tif (v == u) return v;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (par[v][k] != par[u][k]) {\n\t\t\tv = par[v][k];\n\t\t\tu = par[u][k];\n\t\t}\n\t}\n\treturn par[v][0];\n}\nbool isPar(int v, int u) {\n\treturn h[v] <= h[u] && up(u, h[u] - h[v]) == v;\n}\n\nint solve(int l, int r) {\n\tint v = lower_bound(a, a + n, mp(l, -1)) - a;\n\tif (v == n || a[v].first != l) return 0;\n\tint u = lower_bound(b, b + n, mp(r, -1)) - b;\n\tif (u == n || b[u].first != r) return 0;\n\teprintf(""go %d %d\\n"", v, u);\n\tif (cntBad[v] != cntBad[u]) return 0;\n\tif (u < v) return 0;\n\tif (v == u) return -1;\n\tif (LCA(v, v + 1) <= u) return 0;\n\tif (isPar(u, v)) return -1;\n\tif (isPar(u, v + 1)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d%d"", &a[i].first, &a[i].second);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (m > 0 && a[i].first == b[m - 1].first) continue;\n\t\twhile(m > 0 && a[i].second <= b[m - 1].second) m--;\n\t\tb[m++] = a[i];\n\t}\n\tn = m;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = b[i];\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""(%d %d)\\n"", a[i].first, a[i].second);\n\tfor (int i = 1; i < n; i++) {\n\t\tassert(a[i - 1].first < a[i].first);\n\t\tassert(a[i - 1].second < a[i].second);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = mp(a[i].second, a[i].first);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tcntBad[i] = cntBad[i - 1];\n\t\tif (a[i].first > a[i - 1].second) cntBad[i]++;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tpar[i][k] = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = lower_bound(a, a + n, mp(a[i].second + 1, -1)) - a;\n\t\tif (v == n) continue;\n\t\tif (cntBad[v] != cntBad[i]) continue;\n\t\teprintf(""par[%d] = %d\\n"", i, v);\n\t\tpar[i][0] = v;\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t\th[i] = h[par[i][0]] + 1;\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tpar[v][k + 1] = par[par[v][k]][k];\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tint ans = solve(l, r);\n\t\tif (ans < 0) ans += 998244353;\n\t\tprintf(""%d\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']","['brute force', 'combinatorics', 'constructive algorithms', 'data structures', 'dp', 'trees']",3200
https://codeforces.com//contest/959/problem/B,B. Mahmoud and Ehab and the message,Mahmoud wants to send a message to his friend Ehab Their language consists of words numbered from to Some words have the same meaning so there are groups of words such that all the words in some group have the same meaning Mahmoud knows that the th word can be sent with cost For each word in his message Mahmoud can either replace it with another word of the same meaning or leave it as it is Can you help Mahmoud determine the minimum cost of sending the message The cost of sending the message is the sum of the costs of sending every word in it ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, k, m;\nstring s[MAXN];\nint a[MAXN], cost[MAXN];\nmap<string, int> mp;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> k >> m;\n\tfor (int i = 0; i < n; i++) cin >> s[i];\n\tfor (int i = 0; i < n; i ++) cin >> a[i];\n\tmemset(cost, 63, sizeof(cost));\n\tfor (int i = 0; i < k; i++){\n\t\tint t; cin >> t;\n\t\twhile (t--){\n\t\t\tint ind; cin >> ind, ind--;\n\t\t\tcost[i] = min(cost[i], a[ind]);\n\t\t\tmp[s[ind]] = i;\n\t\t}\n\t}\n\tll ans = 0;\n\twhile (m--){\n\t\tstring t; cin >> t;\n\t\tans += cost[mp[t]];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","['dsu', 'greedy', 'implementation']",1200
https://codeforces.com//contest/1454/problem/F,F. Array Partition,You are given an array a consisting of n integers Let min l r be the minimum value among a l a l 1 ldots a r and max l r be the maximum value among a l a l 1 ldots a r Your task is to choose three greater than 0 integers x y and z such that x y z n max 1 x min x 1 x y max x y 1 n In other words you have to split the array a into three consecutive non empty parts that cover the whole array and the maximum in the first part equals the minimum in the second part and equals the maximum in the third part or determine it is impossible to find such a partition Among all such triples partitions you can choose any You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nstruct DSU {\n    vector<int> e;\n    void init(int n) {\n        e = vector<int>(n, -1);\n    }\n    int get(int x) {\n        return e[x] < 0 ? x : e[x] = get(e[x]);\n    }\n    bool same_set(int a, int b) {\n        return get(a) == get(b);\n    }\n    int size(int x) {\n        return -e[get(x)];\n    }\n    bool unite(int x, int y) {\n        x = get(x), y = get(y);\n        if (x == y) return false;\n        if (e[x] > e[y]) swap(x, y);\n        e[x] += e[y]; e[y] = x;\n        return true;\n    }\n};\ntemplate<class T> struct RMQ { // floor(log_2(x))\n    int level(int x) { return 31-__builtin_clz(x); } \n    vector<T> v; vector<vi> jmp;\n    int comb(int a, int b) { // index of min\n        return v[a]==v[b]?min(a,b):(v[a]<v[b]?a:b); } \n    void init(const vector<T>& _v) {\n        v = _v; jmp = {vi(sz(v))}; iota(all(jmp[0]),0);\n        for (int j = 1; 1<<j <= sz(v); ++j) {\n            jmp.pb(vi(sz(v)-(1<<j)+1));\n            F0R(i,sz(jmp[j])) jmp[j][i] = comb(jmp[j-1][i],\n                                    jmp[j-1][i+(1<<(j-1))]);\n        }\n    }\n    int index(int l, int r) { // get index of min element\n        assert(l <= r); int d = level(r-l+1);\n        return comb(jmp[d][l],jmp[d][r-(1<<d)+1]); }\n    T query(int l, int r) { return v[index(l,r)]; }\n};\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        RMQ<int> R;\n        R.init(a);\n        vi pre(n);\n        vi suf(n);\n        f0r(i, n) {\n            if (i == 0) pre[i] = a[i];\n            else pre[i] = max(pre[i-1], a[i]);\n        }\n        for (int i = n-1; i >= 0; i--) {\n            if (i == n-1) suf[i] = a[i];\n            else suf[i] = max(suf[i+1], a[i]);\n        }\n        auto check = [&](int x, int y) -> bool {\n            if (x < 0 || y >= n) return false;\n            if (y - x <= 1) return false;\n            if (suf[y] != pre[x]) return false;\n            if (pre[x] != R.query(x+1, y-1)) return false;\n            return true;\n        };\n        bool ok = false;\n        pi res;\n        f1r(i, 2, n) {\n            int val = suf[i];\n            int lo = 0;\n            int hi = i-1;\n            while (hi - lo > 1) {\n                int mid = (lo + hi) / 2;\n                if (pre[mid] <= val) lo = mid;\n                else hi = mid - 1;\n            }\n            {\n                if (!ok && check(lo, i)) {\n                    ok = true;\n                    res = {lo, i};\n                } \n                if (!ok && check(lo - 1, i)) {\n                    ok = true;\n                    res = {lo - 1, i};\n                }\n                if (!ok && check(hi, i)) {\n                    ok = true;\n                    res = {hi, i};\n                }\n                if (!ok && check(hi - 1, i)) {\n                    ok = true;\n                    res = {hi - 1, i};\n                }\n            }\n            if (ok) break;\n        }\n        if (ok) {\n            ps(""YES"");\n            int x = res.f + 1;\n            int y = res.s - res.f - 1;\n            int z = n - x - y;\n            ps(x, y, z);\n        } else {\n            ps(""NO"");\n        }\n    }\n    return 0;\n}']","['binary search', 'data structures', 'greedy', 'two pointers']",2100
https://codeforces.com//contest/77/problem/A,A. Heroes,The year of 2012 is coming According to an ancient choradrican legend in this very year in 2012 Diablo and his brothers Mephisto and Baal will escape from hell and innumerable hordes of demons will enslave the human world But seven brave heroes have already gathered on the top of a mountain Arreat to protect us mere mortals from the effect of this terrible evil The seven great heroes are amazon barbarian sorceress druid necromancer paladin and a professional hit girl Heroes already know how much experience will be given for each of the three megabosses for Mephisto for Diablo and for Baal Here s the problem heroes are as much as seven and megabosses are only three Then our heroes decided to split into three teams where each team will go to destroy their own megaboss Each team member will receive a of experience rounded down where will be the amount of experience for the killed megaboss and the number of people in the team Heroes do not want to hurt each other s feelings so they want to split into teams so that the difference between the hero who received the maximum number of experience and the hero who received the minimum number of experience were minimal Since there can be several divisions into teams then you need to find the one in which were maximum It is known that some heroes like others But if hero likes hero this does not mean that the hero likes hero No hero likes himself The total amount of liking in teams is the amount of ordered pairs such that heroes and are in the same group and hero likes hero but it is not important if hero likes hero In case of heroes and likes each other and they are in the same group this pair should be counted twice as and A team can consist even of a single hero but it is important that every megaboss was destroyed All heroes must be involved in the campaign against evil None of the heroes can be in more than one team It is guaranteed that every hero is able to destroy any megaboss alone ,"['#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define y0 y3487465\n#define y1 y8687969\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) {\n    re x > 0 ? x : -x;\n}\n\nconst string name[7] = {""Anka"", ""Chapay"", ""Cleo"", ""Troll"", ""Dracul"", ""Snowy"", ""Hexadecimal""};\n\nint n;\nint m;\nint g[7][7];\nint ans, res, p[7], x[3], y[3];\n\nint get (string s) {\n    for (int i = 0; i < 7; i++)\n        if (name[i] == s)\n            re i;\n    re 0;\n}\n\nint go (int i) {\n    if (i == 7) {\n        int y[3];\n        memset (y, 0, sizeof (y));\n        for (int i = 0; i < 7; i++)\n            y[p[i]]++;\n        if (y[0] * y[1] * y[2] == 0) re 0;\n        int mn = min (x[0] / y[0], min (x[1] / y[1], x[2] / y[2]));\n        int mx = max (x[0] / y[0], max (x[1] / y[1], x[2] / y[2]));\n        int smp = 0;\n        for (int i = 0; i < 7; i++)\n            for (int j = 0; j < 7; j++)\n                if (g[i][j] && p[i] == p[j])\n                    smp++;\n        if (mx - mn < ans || mx - mn == ans && res < smp) {\n            ans = mx - mn;\n            res = smp;\n        }\n        re 0;\n    }\n    for (int j = 0; j < 3; j++) {\n        p[i] = j;\n        go (i + 1);\n    }\n    re 0;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        string a, b, c;\n        cin >> a >> b >> c;\n        g[get (a)][get (c)] = 1;\n    }\n    for (int i = 0; i < 3; i++) cin >> x[i];\n    ans = 2e9 + 1;\n    res = 0;\n    go (0);\n    printf (""%d %d\\n"", ans, res);\n    return 0;\n}']","['brute force', 'implementation']",1400
https://codeforces.com//contest/584/problem/E,E. Anton and Ira,Anton loves transforming one permutation into another one by swapping elements for money and Ira doesn t like paying for stupid games Help them obtain the required permutation by paying as little money as possible More formally we have two permutations and of numbers from to We can swap and by paying coins for it Find and print the smallest number of coins required to obtain permutation from permutation Also print the sequence of swap operations at which we obtain a solution ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2E3 + 10;\n\nint a[MAXN], b[MAXN];\nint loc[MAXN];\n\nint cnt;\nint out[MAXN * MAXN][2];\n\nint main(){\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(""%d"", &a[i]);\n\t\tloc[a[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(""%d"", &b[i]);\n\t\ta[loc[b[i]]] = i;\n\t}\n\t/*\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(""%d "", a[i]);\n\tputs("""");\n\t*/\n\n\tint cost = 0;\n\tcnt = 0;\n\tfor (int i = 1; i <= n; ++i){\n\t\tint u = 0;\n\t\tfor (u = i; u <= n && a[u] != i; ++u);\n\t\tfor (int j = u - 1; j >= i; --j)\n\t\t\tif (a[j] >= u){\n\t\t\t\tcost += u - j;\n\t\t\t\tout[cnt][0] = u;\n\t\t\t\tout[cnt][1] = j;\n\t\t\t\t++cnt;\n\t\t\t\tswap(a[u], a[j]);\n\t\t\t\tu = j;\n\t\t\t\tj = u;\n\t\t\t}\n\t}\n\tprintf(""%d\\n%d\\n"", cost, cnt);\n\tfor (int i = 0; i < cnt; ++i)\n\t\tprintf(""%d %d\\n"", out[i][0], out[i][1]);\n\t\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'math']",2300
https://codeforces.com//contest/1782/problem/E,E. Rectangle Shrinking,You have a rectangular grid of height 2 and width 10 9 consisting of unit cells There are n rectangles placed on this grid and the borders of these rectangles pass along cell borders The i th rectangle covers all cells in rows from u i to d i inclusive and columns from l i to r i inclusive 1 le u i le d i le 2 1 le l i le r i le 10 9 The initial rectangles can intersect be nested and coincide arbitrarily You should either remove each rectangle or replace it with any of its non empty subrectangles In the latter case the new subrectangle must lie inside the initial rectangle and its borders must still pass along cell borders In particular it is allowed for the subrectangle to be equal to the initial rectangle After that replacement no two non removed rectangles are allowed to have common cells and the total area covered with the new rectangles must be as large as possible ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, u[N], d[N], l[N], r[N]; \nbool vis[N];\nvector < int > S[3];\nvoid solve(vi &a, int rp = -1) {\n\tsort(a.begin(), a.end(), [&] (int x, int y) {\n\t\treturn r[x] == r[y] ? l[x] > l[y] : r[x] < r[y];\n\t});\n\tvi b;\n\tfor(auto x : a) {\n\t\twhile(sz(b) && l[b.back()] >= l[x]) {\n\t\t\tif(rp == -1) vis[b.back()] = false;\n\t\t\telse if(rp == 0) ++u[b.back()];\n\t\t\telse assert(rp == 1), --d[b.back()];\n\t\t\tb.pop_back();\n\t\t} \n\t\tif(sz(b) && r[b.back()] >= l[x]) {\n\t\t\tint y = b.back();\n\t\t\tint lenx = d[x] - u[x] + 1;\n\t\t\tint leny = d[y] - u[y] + 1;\n\t\t\tif(leny <= lenx) r[y] = l[x] - 1;\n\t\t\telse l[x] = r[y] + 1;\n\t\t}\n\t\tb.emplace_back(x); \n\t}\n\ta = b;\n}\nvoid Main() {\n\tcin >> n;\n\tS[0].clear();\n\tS[1].clear();\n\tS[2].clear();\n\tL(i, 1, n) {\n\t\tcin >> u[i] >> l[i] >> d[i] >> r[i];\n\t\tvis[i] = true;\n\t\tint op = -1;\n\t\tif(u[i] == 1 && d[i] == 1) op = 0;\n\t\tif(u[i] == 2 && d[i] == 2) op = 1;\n\t\tif(u[i] == 1 && d[i] == 2) op = 2;\n\t\tassert(op != -1);\n\t\tS[op].emplace_back(i);\n\t} \n\tL(i, 0, 2) solve(S[i]);\n\tfor(auto u : S[2]) L(i, 0, 1) S[i].emplace_back(u);\n\tL(i, 0, 1) solve(S[i], i);\n\t\n\tint sumsz = 0;\n\tL(i, 1, n) if(vis[i]) {\n\t\tint siz = (d[i] - u[i] + 1) * (r[i] - l[i] + 1);\n\t\tif(siz < 0) {\n\t\t\tcout << ""jingya\\n"";\n\t\t\tassert(false);\n\t\t}\n\t\tif(!siz) vis[i] = false;\n\t\tsumsz += siz;\n\t}\n\tcout << sumsz << \'\\n\';\n\tL(i, 1, n) \n\t\tif(vis[i]) cout << u[i] << \' \' << l[i] << \' \' << d[i] << \' \' << r[i] << \'\\n\';\n\t\telse cout << 0 << \' \' << 0 << \' \' << 0 << \' \' << 0 << \'\\n\';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} ']","['brute force', 'data structures', 'greedy', 'implementation', 'sortings']",2300
https://codeforces.com//contest/1917/problem/E,E. Construct Matrix,You are given an integer n and an integer k Your task is to construct a matrix of size n times n consisting of numbers 0 and 1 in such a way that the following conditions are true or report that it is impossible the sum of all the numbers in the matrix is exactly k the bitwise texttt XOR of all the numbers in the row i is the same for each i the bitwise texttt XOR of all the numbers in the column j is the same for each j ,"['#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\nusing namespace std;\nconst int maxn=1005;\nint T,n,k,p[maxn][maxn];\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>k;\n\t\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)p[i][j]=0;\n\t\tif(k&1){\n\t\t\tcout<<""No\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tif(k%4==0){\n\t\t\tcout<<""Yes\\n"";\n\t\t\tk/=4;\n\t\t\tfor(int i=1;i<=n&&k;i+=2)for(int j=1;j<=n&&k;j+=2){\n\t\t\t\t--k;\n\t\t\t\tp[i][j]=p[i+1][j]=p[i][j+1]=p[i+1][j+1]=1;\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\tfor(int j=1;j<=n;++j)cout<<p[i][j]<<\' \';\n\t\t\t\tcout<<\'\\n\';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint fg=0;\n\t\tif(k>n*n/2){\n\t\t\tk=n*n-k,fg=1;\n\t\t}\n\t\tint flag=0;\n\t\tif(n%4==2){\n\t\t\tif(k<n){\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk=(k-n)/4;\n\t\t\t\tfor(int i=1;i<=n;++i)p[i][i]=1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k<n+2){\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk=(k-n-2)/4;\n\t\t\t\tfor(int i=5;i<=n;++i)p[i][i]=1;\n\t\t\t\tp[1][2]=p[1][3]=p[1][4]=p[2][1]=p[3][1]=p[4][1]=1;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tif(k<6){\n\t\t\t\tcout<<""No\\n"";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk-=6;k/=4;\n\t\t\tp[1][1]=p[1][2]=p[2][1]=p[2][3]=p[3][2]=p[3][3]=1;\n\t\t}\n\t\tfor(int i=1;i<=n&&k;i+=2)for(int j=1;j<=n&&k;j+=2)if(!p[i][j]&&!p[i+1][j]&&!p[i][j+1]&&!p[i+1][j+1]){\n\t\t\t--k;\n\t\t\tp[i][j]=p[i+1][j]=p[i][j+1]=p[i+1][j+1]=1;\n\t\t}\n\t\tif(k){\n\t\t\tcout<<""No\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<""Yes\\n"";\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tfor(int j=1;j<=n;++j){\n\t\t\t\tif(fg)cout<<1-p[i][j]<<\' \';\n\t\t\t\telse cout<<p[i][j]<<\' \';\n\t\t\t}\n\t\t\tcout<<\'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'math']",2500
https://codeforces.com//contest/1718/problem/C,C. Tonya and Burenka-179,Tonya was given an array of a of length n written on a postcard for his birthday For some reason the postcard turned out to be a so the index of the element located strictly to the right of the n th is 1 Tonya wanted to study it better so he bought a robot Burenka 179 A program for Burenka is a pair of numbers s k where 1 leq s leq n 1 leq k leq n 1 Note that k be equal to n Initially Tonya puts the robot in the position of the array s After that Burenka makes n steps through the array If at the beginning of a step Burenka stands in the position i then the following happens The number a i is added to the of the program Burenka moves k positions to the right i i k is executed if i becomes greater than n then i i n Help Tonya find the maximum possible of a program for Burenka if the initial usefulness of any program is 0 Also Tony s friend Ilyusha asks him to change the array q times Each time he wants to assign a p x for a given index p and a value x You need to find the maximum possible of the program after each of these changes ,"['/**\n *    author:  tourist\n *    created: 16.08.2022 17:54:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> ds;\n    int old = n;\n    for (int i = 2; i <= n; i++) {\n      if (n % i == 0) {\n        ds.push_back(old / i);\n        while (n % i == 0) {\n          n /= i;\n        }\n      }\n    }\n    n = old;\n    int sz = (int) ds.size();\n    vector<vector<long long>> b(sz);\n    for (int i = 0; i < sz; i++) {\n      b[i].resize(ds[i]);\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < sz; j++) {\n        b[j][i % ds[j]] += a[i];\n      }\n    }\n    multiset<long long> s;\n    for (int i = 0; i < sz; i++) {\n      for (int j = 0; j < ds[i]; j++) {\n        s.insert(b[i][j] * ds[i]);\n      }\n    }\n    cout << (*s.rbegin()) << \'\\n\';\n    while (q--) {\n      int pos, val;\n      cin >> pos >> val;\n      --pos;\n      int delta = val - a[pos];\n      a[pos] = val;\n      for (int i = 0; i < sz; i++) {\n        int j = pos % ds[i];\n        s.erase(s.find(b[i][j] * ds[i]));\n        b[i][j] += delta;\n        s.insert(b[i][j] * ds[i]);\n      }\n      cout << (*s.rbegin()) << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","['data structures', 'greedy', 'math', 'number theory']",2400
https://codeforces.com//contest/1262/problem/A,A. Math Problem,Your math teacher gave you the following problem There are n segments on the x axis l 1 r 1 l 2 r 2 ldots l n r n The segment l r includes the bounds i e it is a set of such x that l le x le r The length of the segment l r is equal to r l Two segments a b and c d have a common point intersect if there exists x that a leq x leq b and c leq x leq d For example 2 5 and 3 10 have a common point but 5 6 and 1 4 don t have You should add one segment which has at least one common point with each of the given segments and as short as possible i e has minimal length The required segment can degenerate to be a point i e a segment with length zero The added segment may or may not be among the given n segments In other words you need to find a segment a b such that a b and every l i r i have a common point for each i and b a is minimal ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        int a1 = inf, a2 = -inf;\n        rep(i, 0, n) {\n            int l, r;\n            cin >> l >> r;\n            setmin(a1, r);\n            setmax(a2, l);\n        }\n        if (a1 <= a2) {\n            cout << a2 - a1 << ""\\n"";\n        } else {\n            cout << 0 << ""\\n"";\n        }\n    }\n    return 0;\n}']","['greedy', 'math']",1100
https://codeforces.com//contest/1929/problem/B,B. Sasha and the Drawing,Even in kindergarten Sasha liked a girl Therefore he wanted to give her a drawing and attract her attention As a drawing he decided to draw a square grid of size n times n in which some cells are colored But coloring the cells is difficult so he wants to color as few cells as possible But at the same time he wants k diagonals to have at least one colored cell Note that the square grid of size n times n has a total of 4n 2 diagonals Help little Sasha to make the girl fall in love with him and tell him the minimum number of cells he needs to color ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005];\nint main()\n{\n\tint t,n,k;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tk=read();\n\t\tif(k==4*n-2)printf(""%d\\n"",2*n);\n\t\telse printf(""%d\\n"",(k+1)/2);\n\t} \n}\n']","['constructive algorithms', 'greedy', 'math']",800
https://codeforces.com//contest/1842/problem/H,H. Tenzing and Random Real Numbers,There are n uniform random real variables between 0 and 1 inclusive which are denoted as x 1 x 2 ldots x n Tenzing has m conditions Each condition has the form of x i x j le 1 or x i x j ge 1 Tenzing wants to know the probability that all the conditions are satisfied modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output the integer x that 0 le x M and x cdot q equiv p pmod M ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:56:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> m0(n);\n  vector<int> m1(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, w;\n    cin >> w >> x >> y;\n    --x; --y;\n    if (w == 0) {\n      m0[x] |= (1 << y);\n      m0[y] |= (1 << x);\n    } else {\n      m1[x] |= (1 << y);\n      m1[y] |= (1 << x);\n    }\n  }\n  vector<Mint> dp(1 << n);\n  dp[0] = 1;\n  for (int t = 0; t < (1 << n); t++) {\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int nt = t | (1 << i);\n      int v0 = m0[i] & nt;\n      int v1 = m1[i] & nt;\n      int ways = (int) (v0 == 0) + (int) (v1 == 0);\n      dp[nt] += dp[t] * ways;\n    }\n  }\n  Mint ans = dp.back();\n  for (int i = 1; i <= n; i++) {\n    ans /= 2 * i;\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","['bitmasks', 'dp', 'graphs', 'math', 'probabilities']",3000
https://codeforces.com//contest/749/problem/D,D. Leaving Auction,There are people taking part in auction today The rules of auction are classical There were bids made though it s not guaranteed they were from different people It might happen that some people made no bids at all Each bid is define by two integers where is the index of the person who made this bid and is its size Bids are given in chronological order meaning for all Moreover participant never makes two bids in a row no one updates his own bid i e for all Now you are curious with the following question who and which bid will win the auction if some participants were absent Consider that if someone was absent all his bids are just removed and no new bids are added Note that if during this imaginary exclusion of some participants it happens that some of the remaining participants makes a bid twice or more times in a row only first of these bids is counted For better understanding take a look at the samples You have several questions in your mind compute the answer for each of them ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef pair <ll,ll> pii;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nll n,a[N],b[N],q,l[N],f[N];\npii t[4*N];\nvector<ll> g[N];\n\ninline pii merge(pii a, pii b)\n{\n\tif(b.F >= a.F)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\ninline void upd(int v, int tl, int tr ,int p, ll x)\n{\n\tif(tl==tr)\n\t{\n\t\tt[v].F=x;\n\t\tt[v].S=tl;\n\t\treturn;\n\t}\n\tint tm=tl+tr>>1;\n\tif(p<=tm) upd(v+v,tl,tm,p,x);\n\telse upd(v+v+1,tm+1,tr,p,x);\n\tt[v]=merge(t[v+v],t[v+v+1]);\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfo(i,n)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\tf[a[i]]=b[i];\n\t\tg[a[i]].pb(b[i]);\n\t}\n\tfo(i,n)\n\t\tupd(1,1,n,i,f[i]);\n\tcin>>q;\n\tfo(i,q)\n\t{\n\t\tint k;\n\t\tcin>>k;\n\t\tfo(j,k)\n\t\t{\n\t\t\tcin>>l[j];\n\t\t\tupd(1,1,n,l[j],0);\n\t\t}\n\t\tint winner=t[1].S;\n\t\tif(t[1].F==0)\n\t\t{\n\t\t\tcout<<0<<\' \'<<0<<""\\n"";\n\t\t\tfo(j,k)\n\t\t\t\tupd(1,1,n,l[j],f[l[j]]);\n\t\t\tcontinue;\n\t\t}\n\t\tupd(1,1,n,winner,0);\n\t\tcout<<winner<<\' \';\n\t\tint sec=t[1].F;\n\t\tint z=lower_bound(g[winner].begin(),g[winner].end(),sec)-g[winner].begin();\n\t\tcout<<g[winner][z]<<""\\n"";\n\t\tupd(1,1,n,winner,f[winner]);\n\t\tfo(j,k)\n\t\t\tupd(1,1,n,l[j],f[l[j]]);\n\t}\n\treturn 0;\t\n}']","['binary search', 'data structures']",2000
https://codeforces.com//contest/982/problem/B,B. Bus of Characters,In the Bus of Characters there are n rows of seat each having 2 seats The width of both seats in the i th row is w i centimeters All integers w i are distinct Initially the bus is empty On each of 2n stops one passenger enters the bus There are two types of passengers an introvert always chooses a row where both seats are empty Among these rows he chooses the one with the smallest seats width and takes one of the seats in it an extrovert always chooses a row where exactly one seat is occupied by an introvert Among these rows he chooses the one with the largest seats width and takes the vacant place in it You are given the seats width in each row and the order the passengers enter the bus Determine which row each passenger will take ,"['#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#define rep(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n\nstruct node{\n\tint w,pos;\n\tfriend bool operator <(node a,node b)\n\t{\n\t\treturn a.w<b.w;\n\t}\n};\n\nchar s[510000];\nint w[510000],ans[510000];\nint n;\npriority_queue<node>a,b;\nint main()\n{\n\tcin>>n;\n\tfor (int i=1;i<=n;i++) scanf(""%d"",&w[i]);\n\tscanf(""%s"",s);\n\twhile (!a.empty())a.pop();\n\trep(i,n)a.push((node){-w[i],i});\n\trep(i,2*n)\n\t\tif (s[i-1]==\'0\') \n\t\t{\n\t\t\tnode tmp=a.top(); a.pop();\n\t\t\tans[i]=tmp.pos;\n\t\t\ttmp.w=-tmp.w;\n\t\t\tb.push(tmp);\n\t\t}\n\t\telse\n\t\tif (s[i-1]==\'1\')\n\t\t{\n\t\t\tnode tmp=b.top(); \n\t\t\tb.pop();\n\t\t\tans[i]=tmp.pos;\n\t\t}\n\trep(i,2*n)printf(""%d%c"",ans[i],i==2*n?\'\\n\':\' \');\n}\n']","['data structures', 'greedy', 'implementation']",1300
https://codeforces.com//contest/1681/problem/C,C. Double Sort,You are given two arrays a and b both consisting of n integers In one move you can choose two indices i and j 1 le i j le n i neq j and swap a i with a j and b i with b j You have to perform the swap in both arrays You are allowed to perform at most 10 4 moves possibly zero Can you make both arrays sorted in a non decreasing order at the end If you can print any sequence of moves that makes both arrays sorted ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:37:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n      cin >> b[i];\n    }\n    vector<pair<int, int>> p(n);\n    for (int i = 0; i < n; i++) {\n      p[i] = make_pair(a[i], b[i]);\n    }\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    vector<pair<int, int>> res;\n    bool fail = false;\n    for (int i = 0; i < n; i++) {\n      for (int j = i; j < n; j++) {\n        if (p[j] == make_pair(a[i], b[i])) {\n          swap(p[i], p[j]);\n          if (i != j) {\n            res.emplace_back(i, j);\n          }\n          break;\n        }\n      }\n      if (p[i] != make_pair(a[i], b[i])) {\n        fail = true;\n        break;\n      }\n    }\n    if (fail) {\n      cout << -1 << \'\\n\';\n    } else {\n      cout << res.size() << \'\\n\';\n      for (auto& p : res) {\n        cout << p.first + 1 << "" "" << p.second + 1 << ""\\n"";\n      }\n    }\n  }\n  return 0;\n}\n']","['implementation', 'sortings']",1200
https://codeforces.com//contest/289/problem/A,A. Polo the Penguin and Segments ,Little penguin Polo adores integer segments that is pairs of integers He has a set that consists of integer segments We know that no two segments of this set intersect In one move Polo can either widen any segment of the set 1 unit to the left or 1 unit to the right that is transform to either segment or to segment The of a set of segments that consists of segments is the number of integers such that there is integer for which the following inequality holds Find the minimum number of moves needed to make the value of the set of Polo s segments divisible by ,"['#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,m,i,x,y,z;\nint main()\n{\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tz+=y-x+1;\n\t}\n\tcout<<(m-z%m)%m<<endl;\n}']","['brute force', 'implementation']",1100
https://codeforces.com//contest/1633/problem/E,E. Spanning Tree Queries,You are given a connected weighted undirected graph consisting of n vertices and m edges You are asked k queries about it Each query consists of a single integer x For each query you select a spanning tree in the graph Let the weights of its edges be w 1 w 2 dots w n 1 The cost of a spanning tree is sum limits i 1 n 1 w i x the sum of absolute differences between the weights and x The answer to a query is the lowest cost of a spanning tree The queries are given in a compressed format The first p 1 le p le k queries q 1 q 2 dots q p are provided explicitly For queries from p 1 to k q j q j 1 cdot a b mod c Print the xor of answers to all queries ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::array<int, 3>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        std::cin >> u >> v >> w;\n        u--;\n        v--;\n        edges[i] = {w, u, v};\n    }\n    \n    int p, k, a, b, c;\n    std::cin >> p >> k >> a >> b >> c;\n    \n    std::vector<int> q(k);\n    for (int i = 0; i < p; i++) {\n        std::cin >> q[i];\n    }\n    for (int i = p; i < k; i++) {\n        q[i] = (1LL * a * q[i - 1] + b) % c;\n    }\n    \n    std::sort(q.begin(), q.end());\n    \n    std::vector<int> e{0};\n    std::sort(edges.begin(), edges.end());\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = i; j < m; j++) {\n            e.push_back((edges[i][0] + edges[j][0] + 1) / 2);\n        }\n    }\n    \n    std::sort(e.begin(), e.end());\n    \n    i64 coef = 0, cons = 0;\n    \n    i64 ans = 0;\n    \n    for (int i = 0, j = 0; i < k; i++) {\n        int oj = j;\n        while (j < int(e.size()) && q[i] >= e[j]) {\n            j++;\n        }\n        \n        if (oj != j) {\n            std::sort(edges.begin(), edges.end(), [&](auto a, auto b) {\n                int x = std::abs(a[0] - e[j - 1]);\n                int y = std::abs(b[0] - e[j - 1]);\n                if (x != y) {\n                    return x < y;\n                } else {\n                    return a[0] > b[0];\n                }\n            });\n            \n            coef = cons = 0;\n            \n            DSU g(n);\n            for (auto [w, u, v] : edges) {\n                if (g.merge(u, v)) {\n                    if (w > e[j - 1]) {\n                        coef--;\n                        cons += w;\n                    } else {\n                        coef++;\n                        cons -= w;\n                    }\n                }\n            }\n        }\n        \n        ans ^= coef * q[i] + cons;\n    }\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['binary search', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'math', 'sortings', 'trees']",2400
https://codeforces.com//contest/1494/problem/A,A. ABC String,You are given a string a consisting of n characters n is even For each i from 1 to n a i is one of or A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You want to find a string b that consists of n characters such that b is a regular bracket sequence if for some i and j 1 le i j le n a i a j then b i b j In other words you want to replace all occurrences of with the same type of bracket then all occurrences of with the same type of bracket and all occurrences of with the same type of bracket Your task is to determine if such a string b exists ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nbool check(string s)\n{\n    int n = s.size();\n    int balance = 0;\n    for (auto c: s)\n    {\n        if (c==\')\') balance--; else balance++;\n        if (balance<0) return false;\n    }\n    if (balance!=0) return false;\n    return true;\n}\n\nvoid solve()\n{\n    string s; cin>>s;\n    for (int mask = 0; mask<8; mask++)\n    {\n        string s1;\n        for (auto c: s)\n        {\n            if (mask&(1<<(c-\'A\'))) s1+=\'(\'; else s1+=\')\';\n        }\n        if (check(s1)) {cout<<""YES""<<endl; return;}\n    }\n    cout<<""NO""<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}\n']","['bitmasks', 'brute force', 'implementation']",900
https://codeforces.com//contest/1792/problem/C,C. Min Max Sort,You are given a permutation p of length n a permutation of length n is an array of length n in which each integer from 1 to n occurs exactly once You can perform the following operation any number of times possibly zero choose two different elements x and y and erase them from the permutation insert the minimum of x and y into the permutation in such a way that it becomes the first element insert the maximum of x and y into the permutation in such a way that it becomes the last element For example if p 1 5 4 2 3 and we want to apply the operation to the elements 3 and 5 then after the first step of the operation the permutation becomes p 1 4 2 and after we insert the elements it becomes p 3 1 4 2 5 Your task is to calculate the minimum number of operations described above to sort the permutation p in ascending order i e transform p so that p 1 p 2 dots p n ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005],pos[500005];\nsigned main()\n{\n\tint t,n,ans;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),pos[a[i]]=i;\n\t\tif(n%2==1)ans=1;\n\t\telse ans=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint x,y;\n\t\t\tif(n%2==1)\n\t\t\t{\n\t\t\t\tx=(n+1)/2-(ans+1)/2;\n\t\t\t\ty=(n+1)/2+(ans+1)/2;\n\t\t\t\tif(x<1||y>n||pos[y]-pos[y-1]<0||pos[x+1]-pos[x]<0)break;\n\t\t\t\tans+=2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx=n/2-ans/2;\n\t\t\t\ty=n/2+1+ans/2;\n\t\t\t\tif(x<1||y>n||pos[y]-pos[y-1]<0||pos[x+1]-pos[x]<0)break;\n\t\t\t\tans+=2;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",(n-ans)/2);\n\t}\n\treturn 0;\n}']","['binary search', 'brute force', 'greedy', 'math', 'two pointers']",1500
https://codeforces.com//contest/1726/problem/C,C. Jatayu's Balanced Bracket Sequence,Last summer Feluda gifted Lalmohan Babu a bracket sequence s of length 2 n Topshe was bored during his summer vacations and hence he decided to draw an undirected graph of 2 n vertices using the s For any two distinct vertices i and j 1 le i j le 2 n Topshe draws an edge undirected and unweighted between these two nodes if and only if the s i ldots j forms a balanced bracket sequence Determine the number of in Topshe s graph See the Notes section for definitions of the underlined terms ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tint N;\n\tstr S;\n\tre(N, S);\n\tstr sofar;\n\tint ans = 0;\n\tchar last_char = \'.\';\n\tfor (char c: S) {\n\t\tif (c == \'(\') {\n\t\t\tif (last_char == \')\') {\n\n\t\t\t} else {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t} else {\n\n\t\t}\n\t\tlast_char = c;\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['data structures', 'dsu', 'graphs', 'greedy']",1300
https://codeforces.com//contest/1478/problem/B,B. Nezzar and Lucky Number,Nezzar s favorite digit among 1 ldots 9 is d He calls a integer lucky if d occurs at least once in its decimal representation Given q integers a 1 a 2 ldots a q for each 1 le i le q Nezzar would like to know if a i can be equal to a sum of several one or more lucky numbers ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 10010\n\nint n, d;\n\nint main() {\n    int T;\n    scanf(""%d"", &T);\n    while (T --) {\n\t\tscanf(""%d %d"", &n, &d);\n\t\twhile (n --) {\n\t\t\tint a;\n\t\t\tscanf(""%d"", &a);\n\t\t\tif (a % d == 0) puts(""YES"");\n\t\t\telse {\n\t\t\t\tint r = a % d + d * 10;\n\t\t\t\tif (a >= r) puts(""YES"");\n\t\t\t\telse {\n\t\t\t\t\tbool fg = false;\n\t\t\t\t\tfor (int i = 1; i <= 100; i ++) {\n\t\t\t\t\t\tint r = a - d * i;\n\t\t\t\t\t\tif (r >= 0 && r % 10 == 0) fg = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (fg) puts(""YES"");\n\t\t\t\t\telse puts(""NO"");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    return 0;\n}\n']","['brute force', 'dp', 'greedy', 'math']",1100
https://codeforces.com//contest/999/problem/F,F. Cards and Joy,There are n players sitting at the card table Each player has a favorite number The favorite number of the j th player is f j There are k cdot n cards on the table Each card contains a single integer the i th card contains number c i Also you are given a sequence h 1 h 2 dots h k Its meaning will be explained below The players have to distribute all the cards in such a way that each of them will hold exactly k cards After all the cards are distributed each player counts the number of cards he has that contains his favorite number The joy level of a player equals h t if the player holds t cards containing his favorite number If a player gets no cards with his favorite number i e t 0 his joy level is 0 Print the maximum possible total joy levels of the players after the cards are distributed Note that the sequence h 1 dots h k is the same for all the players ,"['#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl \'\\n\'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, k;\nint a[MAXN], cnt1[MAXN], cnt2[MAXN], f[MAXN], h[MAXN];\n\nbool read() {\n    if (!(cin >> n >> k))\n        return false;\n\n    forn (i, n * k)\n        cin >> a[i];\n\n    forn (i, n)\n        cin >> f[i];\n\n    forn (i, k)\n        cin >> h[i + 1];\n\n    return true;\n}\n\nvoid solve() {\n    forn (i, n * k)\n        ++cnt1[a[i]];\n\n    forn (i, n)\n        ++cnt2[f[i]];\n\n    ll ans = 0;\n\n    for (int x = 1; x <= 100000; ++x)\n        if (cnt2[x] != 0) {\n            vector< vector<int> > dp(cnt2[x] + 1, vector<int>(cnt1[x] + 1, 0));\n\n            for (int i = 0; i < cnt2[x]; ++i)\n                for (int j = 0; j <= cnt1[x]; ++j)\n                    for (int dj = 0; dj <= k && j + dj <= cnt1[x]; ++dj)\n                        dp[i + 1][j + dj] = max(dp[i + 1][j + dj], dp[i][j] + h[dj]);\n\n            ans += dp[cnt2[x]][cnt1[x]];\n        }\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand(\'S\' + \'E\' + \'R\' + \'E\' + \'Z\' + \'H\' + \'K\' + \'A\');\n\n#ifdef SEREZHKA\n    freopen(""file.in"", ""r"", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n']",['dp'],2000
https://codeforces.com//contest/613/problem/E,E. Puzzle Lover,Oleg Petrov loves crossword puzzles and every Thursday he buys his favorite magazine with crosswords and other word puzzles In the last magazine Oleg found a curious puzzle and the magazine promised a valuable prize for it s solution We give a formal description of the problem below The puzzle field consists of two rows each row contains cells Each cell contains exactly one small English letter You also are given a word which consists of small English letters A of the puzzle is a sequence of field cells such that For all from to the letter written in the cell matches the letter All the cells in the sequence are pairwise distinct For all from to cells and have a common side Oleg Petrov quickly found a solution for the puzzle Now he wonders how many distinct solutions are there for this puzzle Oleg Petrov doesn t like too large numbers so calculate the answer modulo Two solutions and are considered distinct if the sequences of cells do not match in at least one position that is there is such in range from to such that ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int Mod = 1e9 + 7;\n\nconst int maxn = 2000, maxm = 2000;\n\nint n, m;\nchar a[maxn + 5], b[maxn + 5], c[maxn + 5];\n\nint g[2][maxn + 5];\nint w[maxn + 5];\n\nbool ok_left[2][maxn + 5][maxm + 5];\nbool ok_right[2][maxn + 5][maxm + 5];\n\nint Max[2][maxn + 5][maxm + 5];\n\nint dp[2][maxn + 5][maxn + 5];\n\nint ans = 0;\n\ninline void update(int i, int j, int k, int val)\n{\n\tif (k == m || ok_right[i][j][k]) (ans += val) %= Mod;\n}\n\ninline void solve(bool ty)\n{\n\tmemset(ok_left, 0, sizeof ok_left);\n\tmemset(ok_right, 0, sizeof ok_right);\n\tmemset(Max, 0, sizeof Max);\n\tREP(i, 0, 2)\n\t{\n\t\tfor (int j = n - 1; j >= 0; --j) for (int k = m - 1; k >= 0; --k)\n\t\t\tif (g[i][j] == w[k]) Max[i][j][k] = Max[i][j + 1][k + 1] + 1;\n\t}\n\tREP(i, 0, 2)\n\t{\n\t\tREP(j, 0, n)\n\t\t{\n\t\t\tint k = j;\n\t\t\tint cur = 0;\n\t\t\twhile (k >= 0)\n\t\t\t{\n\t\t\t\tif (g[i][k] != w[cur++] || (cur << 1) > m) break;\n\t\t\t\tif (k != j) ok_left[!i][j + 1][cur << 1] = k + Max[!i][k][cur] > j;\n\t\t\t\t--k;\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j)\n\t\t{\n\t\t\tint k = j;\n\t\t\tint cur = m;\n\t\t\twhile (k < n)\n\t\t\t{\n\t\t\t\tif (g[i][k] != w[--cur] || (cur << 1) < m) break;\n\t\t\t\tif (j != k) ok_right[!i][j][(cur << 1) - m] = j + Max[!i][j][(cur << 1) - m] > k;\n\t\t\t\t++k;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 0, sizeof dp);\n\tREP(j, 0, n + 1)\n\t{\n\t\tREP(i, 0, 2)\n\t\t\tREP(k, 0, m + 1)\n\t\t\t{\n\t\t\t\tif (!k || ok_left[i][j][k]) (++dp[i][j][k]) %= Mod;\n\t\t\t\tif (ty && k && k < m) update(i, j, k, dp[i][j][k]);\n\t\t\t\tif (dp[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tif (j < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k < m && g[i][j] == w[k]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(dp[i][j + 1][k + 1] += dp[i][j][k]) %= Mod;\n\t\t\t\t\t\t\tif (ty && k && k + 1 == m) update(i, j + 1, k + 1, dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k + 1 < m && g[i][j] == w[k] && g[!i][j] == w[k + 1]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(dp[!i][j + 1][k + 2] += dp[i][j][k]) %= Mod;\n\t\t\t\t\t\t\tif (ty && k && k + 2 == m) update(!i, j + 1, k + 2, dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ty) update(i, j, k, dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tscanf(""%s%s%s"", a, b, c);\n\tn = strlen(a), m = strlen(c);\n\tREP(i, 0, n) g[0][i] = a[i] - \'a\', g[1][i] = b[i] - \'a\';\n\tREP(i, 0, m) w[i] = c[i] - \'a\';\n\tans = 0;\n\tsolve(0);\n\treverse(w, w + m);\n\tsolve(1);\n\t(ans += Mod) %= Mod;\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n\n']","['dp', 'hashing', 'strings']",3200
https://codeforces.com//contest/1619/problem/F,F. Let's Play the Hat ,n people gathered in a room with m tables n ge 2m They want to play the Hat k times Thus k games will be played at each table Each player will play in k games To do this they are distributed among the tables for each game During each game one player plays at exactly one table A player can play at different tables Players want to have the most fair schedule of games For this reason they are looking for a schedule table distribution for each game such that At any table in each game there are either lfloor frac n m rfloor people or lceil frac n m rceil people that is either n m rounded down or n m rounded up Different numbers of people can play different games at the same table Let s calculate for each player the value b i the number of times the i th player played at a table with lceil frac n m rceil persons n m rounded up Any two values of b imust differ by no more than 1 In other words for any two players i and j it must be true b i b j le 1 For example if n 5 m 2 and k 2 then at the request of the first item either two players or three players should play at each table Consider the following schedules First game 1 2 3 are played at the first table and 4 5 at the second one The second game at the first table they play 5 1 and at the second 2 3 4 This schedule is since b 2 2 the second player played twice at a big table and b 5 0 the fifth player did not play at a big table First game 1 2 3 are played at the first table and 4 5 at the second one The second game at the first table they play 4 5 2 and at the second one 1 3 This schedule is b 1 2 1 1 1 any two values of b i differ by no more than 1 Find any fair game schedule for n people if they play on the m tables of k games ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,n,m,k,pik,arv,su,ms,va,mv,x,l;\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n>>m>>k;\n        va=n/m; su=(n+m-1)/m;\n        if(va==su) mv=m;\n        else ms=n-m*va,mv=m-ms;\n        arv=min(ms*su,mv*va);\n        x=0;\n        for(int i=0; i<k; i++){\n            l=x;\n            l%=n;\n            for(int j=0; j<m; j++) if(j<ms){\n                cout<<su<<"" "";\n                for(int u=0; u<su; u++){\n                    cout<<l+1<<"" "";\n                    l++;\n                    l%=n;\n                }\n                cout<<""\\n"";\n            }\n            else{\n                cout<<va<<"" "";\n                for(int u=0; u<va; u++){\n                    cout<<l+1<<"" "";\n                    l++;\n                    l%=n;\n                }\n                cout<<""\\n"";\n            }\n            x+=arv;\n        }\n    }\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'math']",2000
https://codeforces.com//contest/817/problem/C,C. Really Big Numbers,Ivan likes to learn different things about numbers but he is especially interested in numbers Ivan thinks that a positive integer number is if the difference between and the sum of its digits in decimal representation is not less than To prove that these numbers may have different special properties he wants to know how rare or not rare they are in fact he needs to calculate the quantity of numbers that are not greater than Ivan tried to do the calculations himself but soon realized that it s too difficult for him So he asked you to help him in calculations ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nint sum(long long n) {\n    int res = 0;\n    while (n) {\n        res += n % 10;\n        n /= 10;\n    }\n    return res;\n}\n\nvoid solve() {\n    long long n, s; cin >> n >> s;\n    long long l = 1, r = n + 1;\n    while (l < r) {\n        long long m = l + r >> 1;\n        if (m - sum(m) < s) {\n            l = m + 1;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << n + 1 - (l + r) / 2 << ""\\n"";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","['binary search', 'brute force', 'dp', 'math']",1600
https://codeforces.com//contest/704/problem/E,E. Iron Man,Tony Stark is playing a game with his suits they have auto pilot now He lives in Malibu Malibu has junctions numbered from to connected with roads One can get from a junction to any other junction using these roads graph of Malibu forms a tree Tony has suits There s a special plan for each suit The th suit will appear at the moment of time in the junction and will move to junction using the shortest path between and with the speed roads per second passing a junctions takes no time and vanishing immediately when arriving at if it reaches in time it s available there at moment but not in further moments Also suits move continuously for example if at time it s in the middle of a road Please note that if it means the suit will be at junction number only at moment and then it vanishes An explosion happens if at any moment of time two suits share the same exact location it may be in a junction or somewhere on a road while appearing vanishing or moving Your task is to tell Tony the moment of the the first explosion if there will be any ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\n// {{{\n// clang-format off\n#define all(a) (a).begin(), (a).end()\n#define sz(a) static_cast<int>((a).size())\n#define fillchar(a, x) memset(a, x, sizeof(a))\n#define rep(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define irep(i, a, b) for (int i = int(a); i >= int(b); --i)\n#define replr(i, a, b) rep(i, a, (b)-1)\n#define reprl(i, a, b) irep(i, (b)-1, a)\n#define repn(i, n) rep(i, 0, (n)-1)\n#define irepn(i, n) irep(i, (n)-1, 0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define popcount __builtin_popcount\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<bool> VB;\ntypedef vector<string> VS;\ntypedef vector<PII> VPI;\ntypedef vector<PLL> VPL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VPI> VVPI;\ntypedef vector<VPL> VVPL;\ntemplate <class T, class S> ostream& operator<<(ostream& os, const pair<T, S>& v) { return os << ""("" << v.first << "", "" << v.second << "")""; }\ntemplate <class T> ostream& operator<<(ostream& os, const vector<T>& v) { os << ""[""; repn(i, sz(v)) { if(i) os << "", ""; os << v[i]; } return os << ""]""; }\ntemplate <class T> bool setmax(T& _a, T _b) { if(_a < _b) { _a = _b; return true; } return false; }\ntemplate <class T> bool setmin(T& _a, T _b) { if(_b < _a) { _a = _b; return true; } return false; }\ntemplate <class T> T gcd(T _a, T _b) { return _b == 0 ? _a : gcd(_b, _a % _b); }\nVI read_vi(int n = -1) { if (n < 0) scanf(""%d"", &n); VI a(n); repn(i, n) scanf(""%d"", &a[i]); return a; }\nVL read_vl(int n = -1) { if (n < 0) scanf(""%d"", &n); VL a(n); repn(i, n) scanf(""%lld"", &a[i]); return a; }\nVPI read_vpi(int n = -1) { if (n < 0) scanf(""%d"", &n); VPI a(n); repn(i, n) scanf(""%d%d"", &a[i].fi,&a[i].se); return a; }\nVPL read_vpl(int n = -1) { if (n < 0) scanf(""%d"", &n); VPL a(n); repn(i, n) scanf(""%lld%lld"", &a[i].fi,&a[i].se); return a; }\ninline LL powmod(LL a, LL b, LL m) { LL r = 1; for(; b > 0; b >>= 1, a = a * a % m) { if(b & 1) r = r * a % m; } return r; }\n// clang-format on\n// }}}\n\ntypedef long double R;\n\nconst R EPS = 1e-12;\nint sgn(R x) { return x < -EPS ? -1 : x > EPS; }\nstruct Point {\n    R x, y;\n    Point() {}\n    Point(R _x, R _y) : x(_x), y(_y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(R b) const { return Point(x * b, y * b); }\n    Point operator/(R b) const { return Point(x / b, y / b); }\n    void rotate90() {\n        swap(x, y);\n        x = -x;\n    }\n    R len() const { return sqrt(x * x + y * y); }\n    void normalize() { *this = *this / len(); }\n    friend R mult(Point p1, Point p2) { return p1.x * p2.y - p1.y * p2.x; }\n    friend R dot(Point p1, Point p2) { return p1.x * p2.x + p1.y * p2.y; }\n    friend R mult(Point p0, Point p1, Point p2) {\n        return mult(p1 - p0, p2 - p0);\n    }\n    friend R dot(Point p0, Point p1, Point p2) { return dot(p1 - p0, p2 - p0); }\n    friend R dist(Point p1, Point p2) { return (p1 - p2).len(); }\n    R lambda(Point s, Point t) const {  // return c: p=s+(t-s)*c\n        return dot(s, t, *this) / dot(s, t, t);\n    }\n};\nstruct Line {\n    R a, b, c;\n    Line() {}\n    Line(R _a, R _b, R _c) : a(_a), b(_b), c(_c) {}\n    Line(Point p1, Point p2) {\n        a = p2.y - p1.y, b = p1.x - p2.x;\n        c = -(p1.x * a + p1.y * b);\n    }\n    Point cross(const Line& l) const {\n        R t = a * l.b - b * l.a;\n        R x = b * l.c - c * l.b;\n        R y = c * l.a - a * l.c;\n        return Point(x / t, y / t);\n    }\n};\nstruct Segment {\n    Point p1, p2;\n    bool is_point = false;\n    Segment(R x, R y) : p1(x, y), p2(x, y), is_point(true) {}\n    Segment(R x1, R y1, R x2, R y2) : p1(x1, y1), p2(x2, y2) {\n        if(p1.y > p2.y) swap(p1, p2);\n    }\n    R at(R y) const {\n        if(is_point) {\n            assert(sgn(y - p1.y) == 0);\n            return p1.x;\n        }\n        return p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);\n    }\n};\n\nvector<Segment> prepare() {\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    VVI es(n);\n    repn(i, n - 1) {\n        int a, b;\n        scanf(""%d%d"", &a, &b), --a, --b;\n        es[a].pb(b), es[b].pb(a);\n    }\n    const int LOG = 20;\n    VI my(n, -1), dep(n);\n    VVI up(n, VI(LOG, -1));\n    const function<int(int, int)> cal_my = [&](int x, int fa) {\n        if(fa >= 0) dep[x] = dep[fa] + 1;\n        up[x][0] = fa;\n        for(int i = 0; up[x][i] >= 0; ++i) up[x][i + 1] = up[up[x][i]][i];\n        int size = 1, best = -1;\n        for(int y : es[x]) {\n            if(y != fa) {\n                int tmp = cal_my(y, x);\n                size += tmp;\n                if(setmax(best, tmp)) my[x] = y;\n            }\n        }\n        return size;\n    };\n    cal_my(0, -1);\n    VI head(n), where(n), arr;\n    const function<void(int, int, int)> dfs = [&](int x, int fa, int h) {\n        head[x] = h, where[x] = sz(arr), arr.pb(x);\n        if(my[x] >= 0) {\n            dfs(my[x], x, h);\n        }\n        for(int y : es[x]) {\n            if(y != fa && y != my[x]) {\n                arr.pb(x);\n                dfs(y, x, x);\n            }\n        }\n    };\n    dfs(0, -1, 0);\n    const auto lca = [&](int x, int y) {\n        if(dep[x] > dep[y]) swap(x, y);\n        repn(i, LOG) if((dep[y] - dep[x]) & (1 << i)) y = up[y][i];\n        irepn(i, LOG) if(up[x][i] != up[y][i]) x = up[x][i], y = up[y][i];\n        if(x != y) x = up[x][0];\n        return x;\n    };\n    const auto extract = [&](int x, int target) {\n        VPI r;\n        while(x != target) {\n            int y = head[x];\n            if(dep[y] < dep[target]) y = target;\n            int len = dep[x] - dep[y];\n            r.pb(mp(where[x], where[x] - len));\n            x = y;\n        }\n        return r;\n    };\n\n    // cout << head << endl;\n    // cout << where << endl;\n    // cout << arr << endl;\n\n    vector<Segment> segments;\n    while(m--) {\n        int t, c, x, y;\n        scanf(""%d%d%d%d"", &t, &c, &x, &y), --x, --y;\n        int z = lca(x, y);\n        VPI px = extract(x, z);\n        VPI py = extract(y, z);\n        bool covered = false;\n        if(!px.empty() && px.back().se == where[z]) covered = true;\n        if(!py.empty() && py.back().se == where[z]) covered = true;\n        int cur = 0;\n        for(const auto& p : px) {\n            int tmp = cur + abs(p.fi - p.se);\n            segments.pb(Segment(p.fi, t + R(cur) / c, p.se, t + R(tmp) / c));\n            cur = tmp;\n        }\n        if(!covered) {\n            segments.pb(Segment(where[z], t + R(cur) / c));\n        }\n        reverse(all(py));\n        for(auto& p : py) {\n            swap(p.fi, p.se);\n            int tmp = cur + abs(p.fi - p.se);\n            segments.pb(Segment(p.fi, t + R(cur) / c, p.se, t + R(tmp) / c));\n            cur = tmp;\n        }\n    }\n    return segments;\n}\n\nbool on_segment(Point p, Segment b) {\n    return sgn(dot(p, b.p1, b.p2)) <= 0 && sgn(mult(p, b.p1, b.p2)) == 0;\n}\n\nR intersection(Segment a, Segment b) {\n    if(sgn(mult(a.p1, a.p2, b.p1)) * sgn(mult(a.p1, a.p2, b.p2)) > 0)\n        return 1e50;\n    if(sgn(mult(b.p1, b.p2, a.p1)) * sgn(mult(b.p1, b.p2, a.p2)) > 0)\n        return 1e50;\n    if(sgn(mult(a.p1 - a.p2, b.p1 - b.p2)) == 0) {\n        R r = 1e50;\n        if(on_segment(a.p1, b)) setmin(r, a.p1.y);\n        if(on_segment(a.p2, b)) setmin(r, a.p2.y);\n        if(on_segment(b.p1, a)) setmin(r, b.p1.y);\n        if(on_segment(b.p2, a)) setmin(r, b.p2.y);\n        return r;\n    } else {\n        return Line(a.p1, a.p2).cross(Line(b.p1, b.p2)).y;\n    }\n}\n\nR cur = 0;\nvector<Segment> segments;\n\nvoid find_intersection() {\n    R found = 1e50;\n    vector<pair<R, int>> events;\n    repn(i, sz(segments)) {\n        events.pb(mp(segments[i].p1.y, -i - 1));\n        events.pb(mp(segments[i].p2.y + EPS / 5, i));\n    }\n    sort(all(events));\n    struct Id {\n        int i;\n        bool operator<(const Id& b) const {\n            int s = sgn(segments[i].at(cur) - segments[b.i].at(cur));\n            if(s == 0) s = i - b.i;\n            return s < 0;\n        }\n    };\n    set<Id> ids;\n    for(const auto& e : events) {\n        if(e.fi >= found) break;\n        cur = e.fi;\n        if(e.se < 0) {\n            auto it = ids.insert(Id{-e.se - 1}).fi;\n            auto p = it;\n            ++p;\n            if(p != ids.end()) {\n                setmin(found, intersection(segments[it->i], segments[p->i]));\n            }\n            p = it;\n            if(p != ids.begin()) {\n                --p;\n                setmin(found, intersection(segments[it->i], segments[p->i]));\n            }\n        } else {\n            assert(ids.erase(Id{e.se}) == 1);\n        }\n    }\n    if(found > 1e40) {\n        printf(""-1\\n"");\n    } else {\n        assert(found >= 0);\n        printf(""%.15lf\\n"", (double)found);\n    }\n}\n\nint main() {\n    segments = prepare();\n    find_intersection();\n    return 0;\n}\n']","['data structures', 'geometry', 'trees']",3300
https://codeforces.com//contest/1760/problem/C,C. Advantage,There are n participants in a competition participant i having a strength of s i Every participant wonders how much of an advantage they have over the other best participant In other words each participant i wants to know the difference between s i and s j where j is the strongest participant in the competition not counting i a difference can be negative So they ask you for your help For each i 1 leq i leq n output the difference between s i and the maximum strength of any participant other than participant i ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define int long long\n#define pb push_back\n#define pf push_front\n#define ppf pop_front\n#define ppb pop_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n\nvoid freo(string x) {\n  freopen((x + "".in"").c_str(), ""r"", stdin);\n  freopen((x + "".out"").c_str(), ""w"", stdout);\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector <pair <int, int>> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].F;\n    a[i].S = i;\n  }\n  sort(all(a));\n  int ans[n];\n  for (int i = 0; i < n - 1; i++) ans[a[i].S] = a[i].F - a[n - 1].F;\n  ans[a[n - 1].S] = a[n - 1].F - a[n - 2].F;\n  for (int i = 0; i < n; i++) cout << ans[i] << \' \';\n  cout << \'\\n\';\n}\n\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  //freo(""timeline"");\n  int tt = 1;\n  cin >> tt;\n  while (tt--) solve();\n}']","['data structures', 'implementation', 'sortings']",800
https://codeforces.com//contest/1191/problem/D,"D. Tokitsukaze, CSL and Stone Game",Tokitsukaze and CSL are playing a little game of stones In the beginning there are n piles of stones the i th pile of which has a i stones The two players take turns making moves Tokitsukaze moves first On each turn the player chooses a nonempty pile and removes exactly one stone from the pile A player loses if all of the piles are empty before his turn or if after removing the stone two piles possibly empty contain the same number of stones Supposing that both players play optimally who will win the game Consider an example n 3 and sizes of piles are a 1 2 a 2 3 a 3 0 It is impossible to choose the empty pile so Tokitsukaze has two choices the first and the second piles If she chooses the first pile then the state will be 1 3 0 and it is a good move But if she chooses the second pile then the state will be 2 2 0 and she immediately loses So the only good move for her is to choose the first pile Supposing that both players always take their best moves and never make mistakes who will win the game Note that even if there are two piles with the same number of stones at the beginning Tokitsukaze may still be able to make a valid first move It is only necessary that there are no two piles with the same number of stones after she moves ,"['#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>=\'0\'&&ch<=\'9\')) {if (ch==\'-\')f=-1;ch=getchar();}\n    while (ch>=\'0\'&&ch<=\'9\') {x=x*10+(ch-\'0\'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 100005;\n\nint n,a[N];\n\nint main() {\n\n\tn=read(); rep(i,1,n) a[i]=read();\n\tsort(a+1,a+n+1);\n\tint num=0,pos;\n\trep(i,1,n-1) if (a[i]==a[i+1]) num++,pos=i;\n\tif (num>=2) puts(""cslnb"");\n\telse if (num==0) {\n\t\tLL sum=0,aim=(LL)n*(LL)(n-1)/2;\n\t\trep(i,1,n) sum+=(LL)a[i];\n\t\tif ((sum-aim)&1) puts(""sjfnb"");\n\t\telse puts(""cslnb"");\n\t} else {\n\t\tif (a[pos]==0) puts(""cslnb"");\n\t\telse {\n\t\t\tif (pos==1||a[pos-1]!=a[pos]-1) {\n\t\t\t\tLL sum=0,aim=(LL)n*(LL)(n-1)/2;\n\t\t\t\trep(i,1,n) sum+=(LL)a[i];\n\t\t\t\tif ((sum-aim)&1) puts(""sjfnb"");\n\t\t\t\telse puts(""cslnb"");\n\t\t\t} else puts(""cslnb"");\n\t\t}\n\t}\n\n\n\treturn 0;\n\t\n}\n']","['games', 'greedy']",1800
https://codeforces.com//contest/602/problem/A,A. Two Bases,After seeing the ALL YOUR BASE ARE BELONG TO US meme for the first time numbers and realised that they have different bases which complicated their relations You re given a number represented in base and a number represented in base Compare those two numbers ,"[""#include <iostream>\n\nusing namespace std;\n\nint n, k;\nint a[100];\n\nlong long calc() {\n    long long x = 0;\n    for (int i = 0; i < n; i++) {\n        x = x * k + a[i];\n    }\n    return x;\n}\nint main() {\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    long long x = calc();\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    long long y = calc();\n    if (x == y) {\n        cout << '=' << endl;\n    } else if (x < y) {\n        cout << '<' << endl;\n    } else {\n        cout << '>' << endl;\n    }\n    return 0;\n}\n""]","['brute force', 'implementation']",1100
https://codeforces.com//contest/1361/problem/B,B. Johnny and Grandmaster,Johnny has just found the new great tutorial The tutorial tells many strange and unexpected for Johnny things such as you have to be patient or that very important is solving many harder and harder problems The boy has found an online judge with tasks divided by topics they cover He has picked p k i problems from i th category p is his favorite number He wants to solve them in two weeks the patience condition is too hard for Johnny so for simplicity he looks only at easy tasks which can be solved in such a period Now our future grandmaster has to decide which topics to cover first and which the second week Help him assign topics in such a way that workload is balanced Formally given n numbers p k i the boy wants to divide them into two disjoint sets minimizing the absolute difference between sums of numbers in each set Find the minimal absolute difference Output the result modulo 10 9 7 ,"['/**\n *    author:  tourist\n *    created: 04.06.2020 17:39:34       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, p;\n    cin >> n >> p;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.rbegin(), a.rend());\n    long long rdiff = 0;\n    Mint diff = 0;\n    int last = a[0];\n    for (int k : a) {\n      if (p > 1) {\n        for (int it = 0; rdiff > 0 && rdiff < n && it < last - k; it++) {\n          rdiff *= p;\n        }\n        diff *= power(Mint(p), last - k);\n      }\n      if (rdiff > 0) {\n        rdiff -= 1;\n        diff -= 1;\n      } else {\n        rdiff += 1;\n        diff += 1;\n      }\n      last = k;\n    }\n    diff *= power(Mint(p), last);\n    cout << diff << \'\\n\';\n  }\n  return 0;\n}\n']","['greedy', 'implementation', 'math', 'sortings']",1900
https://codeforces.com//contest/599/problem/B,B. Spongebob and Joke,While Patrick was gone shopping Spongebob decided to play a little trick on his friend The naughty Sponge browsed through Patrick s personal stuff and found a sequence of length consisting of integers from to not necessarily distinct Then he picked some sequence of length and for each number got number To finish the prank he erased the initial sequence It s hard to express how sad Patrick was when he returned home from shopping We will just say that Spongebob immediately got really sorry about what he has done and he is now trying to restore the original sequence Help him do this or determine that this is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\nint used[100005];\nint f[100005];\nint o[100005];\nint freq[100005], rev[100005];\nint main() {\n  int n, m, x;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(""%d"", &f[i]);\n    freq[f[i]]++;\n    rev[f[i]] = i;\n  }\n  bool amb = false;\n  for (int i = 1; i <= m; i++) {\n    scanf(""%d"", &x);\n    if (freq[x] == 1) {\n      o[i] = rev[x];\n    } else if (freq[x] == 0) {\n      printf(""Impossible\\n"");\n      return 0;\n    } else {\n      amb = true;\n    }\n  }\n  if (amb) {\n    printf(""Ambiguity\\n"");\n    return 0;\n  }\n  printf(""Possible\\n"");\n  for (int i = 1; i <= m; i++) {\n    printf(""%d%c"", o[i], i == m ? \'\\n\' : \' \');\n  }\n  return 0;\n}\n']",['implementation'],1500
https://codeforces.com//contest/1152/problem/F1,F1. Neko Rules the Catniverse  Small Version , Aki is playing a new video game In the video game he will control Neko the giant cat to fly between planets in the Catniverse There are n planets in the Catniverse numbered from 1 to n At the beginning of the game Aki chooses the planet where Neko is initially located Then Aki performs k 1 moves where in each move Neko is moved from the current planet x to some other planet y such that Planet y is not visited yet 1 leq y leq x m where m is a fixed constant given in the input This way Neko will visit exactly k different planets Two ways of visiting planets are called different if there is some index i such that the i th planet visited in the first way is different from the i th planet visited in the second way What is the total number of ways to visit k planets this way Since the answer can be quite large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007;\nll cc[105][15];\nll modpow(ll a, int b) {\n\tll res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn res;\n}\nint dis[20], arr[20], K, n, m;\nll f[4100][12];\nvector<int> bt[4100];\nstruct HashMap {\n\tstatic const int N = 1 << 20, B = N - 1;\n\tll key[N], sz; bool vis[N];\n\tll val[N];\n\tint hash(ll x) { return (x << 16 ^ x >> 6 ^ x << 1) & B; }\n\tint khash(ll x) { return (x << 15 ^ x >> 5 ^ x << 2) & B; }\n\tvoid ins(ll x, int y) {\n\t\tint t = hash(x), s = khash(x) | 1;\n\t\twhile (vis[t]) {\n\t\t\tif (key[t] == x) { val[t] += y; return; }\n\t\t\tt = (t + s) & B;\n\t\t}\n\t\tvis[t] = true, key[t] = x, ++sz, val[t] = y;\n\t}\n\tint query(ll x) {\n\t\tint t = hash(x), s = khash(x) | 1;\n\t\twhile (vis[t]) {\n\t\t\tif (key[t] == x) return val[t];\n\t\t\tt = (t + s) & B;\n\t\t}\n\t\treturn 0;\n\t}\n} hm, hn;\nvoid dfs(int k) {\n\tif (dis[k] >= K) return;\n\tif (k == n) {\n\t\tint mul = 0, cnt = 1;\n\t\tfor (int i = 1; i < k; i++) {\n\t\t\tint f = 0;\n\t\t\tfor (int j = i + 1; j <= k; j++)\n\t\t\t\tif (dis[j] - dis[i] <= m) f = j - i;\n\t\t\t\telse break;\n\t\t\tmul = mul * (m + 1) + f;\n\t\t\tif (dis[i + 1] - dis[i] > m) ++cnt;\n\t\t}\n\t\thm.ins(mul, cc[dis[k] + 1 - cnt][cnt]);\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= m + 1; i++) {\n\t\tdis[k + 1] = dis[k] + i;\n\t\tdfs(k + 1);\n\t}\n}\nint brr[20];\nint calc(int n) {\n\tif (n == 1) return 1;\n\tint nn = (1 << n) - 1;\n\tfor (int i = 1; i <= nn; i++)\n\tfor (int j : bt[i]) f[i][j] = 0;\n\tfor (int i = 0; i < n; i++) f[1 << i][i] = 1;\n\tfor (int i = 1; i < nn; i++)\n\tfor (int j : bt[i]) if (f[i][j])\n\tfor (int k : bt[nn ^ i]) {\n\t\tif (k > j + brr[j]) break;\n\t\tf[i | 1 << k][k] += f[i][j];\n\t}\n\tll res = 0;\n\tfor (int i = 0; i < n; i++) res += f[nn][i];\n\treturn res % MOD;\n}\nint main() {\n\tscanf(""%d%d%d"", &K, &n, &m);\n\tfor (int i = 0; i <= K && i <= 100; i++) {\n\t\tint nn = K - i;\n\t\tcc[i][0] = 1;\n\t\tfor (int j = 1; j <= nn && j <= n; j++)\n\t\t\tcc[i][j] = cc[i][j - 1] * (nn - j + 1) % MOD * modpow(j, MOD - 2) % MOD;\n\t}\n\tdfs(1);\n\t/*printf(""%d\\n"", hm.sz);\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = 0; k < n; k++, j /= m + 1) printf(""%d "", j % 5);\n\t\tputs("""");\n\t}*/\n\tfor (int i = 0; i < 1 << n; i++)\n\tfor (int j = 0; j < n; j++) if (i >> j & 1) bt[i].push_back(j);\n\tll ans = 0;\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);\n\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\tint k = j;\n\t\t\twhile (k < n - 1 && arr[k]) ++k;\n\t\t\tfor (int l = j; l <= k; l++) brr[l - j] = arr[l];\n\t\t\tint temp = 0;\n\t\t\tfor (int l = 0; l <= k - j; l++) temp = temp * (m + 1) + brr[l];\n\t\t\thn.ins((ll)temp << 5 | (k - j + 1), 0);\n\t\t\tj = k;\n\t\t}\n\t}\n\tfor (int i = 0; i < hn.N; i++) if (hn.vis[i]) {\n\t\tint now = hn.key[i] & 31, num = hn.key[i] >> 5;\n\t\tfor (int j = num, k = now - 1; k >= 0; k--, j /= m + 1) brr[k] = j % (m + 1);\n\t\thn.val[i] = calc(now);\n\t}\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);\n\t\tll mul = hm.val[i] % MOD, ss = mul;\n\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\tint k = j;\n\t\t\twhile (k < n - 1 && arr[k]) ++k;\n\t\t\tfor (int l = j; l <= k; l++) brr[l - j] = arr[l];\n\t\t\tint temp = 0;\n\t\t\tfor (int l = 0; l <= k - j; l++) temp = temp * (m + 1) + brr[l];\n\t\t\tmul = mul * hn.query((ll)temp << 5 | (k - j + 1)) % MOD;\n\t\t\tj = k;\n\t\t}\n\t\tans += mul;\n\t}\n\tprintf(""%lld\\n"", ans % MOD);\n\treturn 0;\n}//for (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);']","['bitmasks', 'dp', 'matrices']",2800
https://codeforces.com//contest/1303/problem/A,A. Erasing Zeroes,You are given a string s Each character is either or You want all s in the string to form a contiguous subsegment For example if the string is or then all s form a contiguous subsegment and if the string is or then this condition is not met You may erase some possibly none s from the string What is the minimum number of s that you have to erase ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint l=0, r=s.size()-1;\n\t\twhile(l<s.size()&&s[l]==\'0\')\n\t\t\t++l;\n\t\twhile(~r&&s[r]==\'0\')\n\t\t\t--r;\n\t\tint c=0;\n\t\tfor(int i=l; i<=r; ++i)\n\t\t\tc+=s[i]!=\'1\';\n\t\tcout << c << ""\\n"";\n\t}\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/1264/problem/A,A. Beautiful Regional Contest,So the Beautiful Regional Contest BeRC has come to an end n students took part in the contest The final standings are already known the participant in the i th place solved p i problems Since the participants are primarily sorted by the number of solved problems then p 1 ge p 2 ge dots ge p n Help the jury distribute the gold silver and bronze medals Let their numbers be g s and b respectively Here is a list of requirements from the rules which all must be satisfied for each of the three types of medals at least one medal must be awarded that is g 0 s 0 and b 0 the number of gold medals must be strictly less than the number of silver and the number of bronze that is g s and g b but there are no requirements between s and b each gold medalist must solve strictly more problems than any awarded with a silver medal each silver medalist must solve strictly more problems than any awarded a bronze medal each bronze medalist must solve strictly more problems than any participant not awarded a medal the total number of medalists g s b should not exceed half of all participants for example if n 21 then you can award a maximum of 10 participants and if n 26 then you can award a maximum of 13 participants The jury wants to reward with medals the total number participants i e to maximize g s b so that all of the items listed above are fulfilled Help the jury find such a way to award medals ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nint n,x,m,_;\nint cnt[N];\nvoid solve() {\n\tscanf(""%d"",&n);\n\tmap<int,int> hs;\n\trep(i,0,n) {\n\t\tscanf(""%d"",&x);\n\t\ths[x]++;\n\t}\n\tm=0;\n\tfor (auto p:hs) {\n\t\tcnt[m++]=p.se;\n\t}\n\treverse(cnt,cnt+m);\n\trep(i,1,m) cnt[i]+=cnt[i-1];\n\tVI ans{0,0,0,0};\n\trep(i,0,m) {\n\t\t// g  cnt[i]\n\t\tint a=lower_bound(cnt,cnt+m,2*cnt[i]+1)-cnt;\n\t\tif (a==m) continue;\n\t\tint f1=cnt[a]-cnt[i];\n\t\tint b=upper_bound(cnt,cnt+m,n/2)-cnt-1;\n\t\tint f2=cnt[b]-f1-cnt[i];\n\t\tif (f1>cnt[i]&&f2>cnt[i]) {\n\t\t\tans=max(ans,VI{cnt[i]+f1+f2,cnt[i],f1,f2});\n\t\t}\n\t\t// b 2*cnt[i]+1\n\t}\n\tprintf(""%d %d %d\\n"",ans[1],ans[2],ans[3]);\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n']","['greedy', 'implementation']",1500
https://codeforces.com//contest/1832/problem/C,C. Contrast Value,For an array of integers a 1 a 2 dots a n let s call the value a 1 a 2 a 2 a 3 cdots a n 1 a n the of the array Note that the contrast of an array of size 1 is equal to 0 You are given an array of integers a Your task is to build an array of b in such a way that all the following conditions are met b is not empty i e there is at least one element b is a subsequence of a i e b can be produced by deleting some elements from a maybe zero the contrast of b is equal to the contrast of a What is the minimum possible size of the array b ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    n = std::unique(a.begin(), a.end()) - a.begin();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (((i == 0 || a[i] > a[i - 1]) && (i == n - 1 || a[i] > a[i + 1]))\n            || ((i == 0 || a[i] < a[i - 1]) && (i == n - 1 || a[i] < a[i + 1]))) {\n            ans++;\n        }\n    }\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['greedy', 'implementation']",1200
https://codeforces.com//contest/1009/problem/B,B. Minimum Ternary String,You are given a ternary string it is a string which consists only of characters and You can swap any two adjacent consecutive characters and i e replace with or vice versa or any two adjacent consecutive characters and i e replace with or vice versa For example for string we can perform the following moves rightarrow rightarrow rightarrow rightarrow Note than you cannot swap rightarrow and vice versa You cannot perform any other operations with the given string excluding described above You task is to obtain the minimum possible lexicographically string by using these swaps arbitrary number of times String a is lexicographically less than string b if strings a and b have the same length if there exists some position i 1 le i le a where s is the length of the string s such that for every j i holds a j b j and a i b i ,"['//nie, 3 cze 2018, 13:38:19 CEST\n//Konrad Paluszek, University of Warsaw (former XIV LO Staszic)\n# include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst bool local = \n#ifdef LOCAL\ntrue;\n#else\nfalse;\n#endif\n#define f first\n#define s second\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define bvt(s, f) int s(int x){return f(x);}int s(UI x){return f(x);}int s(LL x){return f##ll(x);}int s(ULL x){return f##ll(x);}\n#define FORBITS(i,m)  for(decltype(m)lP6N4Slr=(m),i=lP6N4Slr?ctz(lP6N4Slr):0;lP6N4Slr;lP6N4Slr^=((decltype(m))1<<i),i=ctz(lP6N4Slr))\n#define FORDBITS(i,m) for(decltype(m)_6Im=(m),i=_6Im?8*sizeof(m)-clz(_6Im)-1:0;_6Im;_6Im^=((decltype(m))1<<i),i=8*sizeof(m)-clz(_6Im)-1)\n#define SUBS(i, mask) for(decltype(mask)i = (mask),NFR9xNQCJZTrYQ=1;NFR9xNQCJZTrYQ;NFR9xNQCJZTrYQ=i,i=(i-1)&(mask))\n#define PB push_back\n#define MP make_pair\n#define MT(a, b, c) MP(MP(a, b), c)\n#define MQ(a, b, c, d) MP(MP(a, b), MP(c, d))\n#define tri(a, b, c) pair <pair <a, b>, c>\n#define quadr(a, b, c, d) pair <pair <a, b>, pair <c, d> >\n#define EB emplace_back\n# define jvx(...)\n# define fkz(...) __VA_ARGS__ jvx()\n# define cxo(...) __VA_ARGS__\n#define uuu_id() uuu\nusing LL=long long;using PII=pair<int,int>;using VI=vector<int>;using SI=set<int>;\nusing MII=map<int,int>;using UMII=unordered_map<int, int>;using LD=long double;using TII=\npair<PII,int>;using QII=pair<PII,PII>;using UI=unsigned int;using ULL=unsigned long long;\n#define uuu(prev, t) using S##t=set<t>; using V##t=vector<t>; using M##t=map<t,t>;\\\n\tusing MI##t=map<int,t>;using US##t=unordered_set<t>; prev(S##t) prev(V##t)\n#define uuu_() uuu\n#define ymd(t) \n#define ymd2(t) fkz(uuu_)()(ymd, t)\n#define ymd3(t) cxo(cxo(cxo(fkz(uuu_)()(ymd2, t))))\n#define ymd4(t) using P##t = pair<t,t>; using T##t=tri(t,t,t); using Q##t=quadr(t,t,t,t); \\\n\tymd3(P##t) ymd3(T##t) ymd3(Q##t) ymd3(t)\nymd4(LL) ymd4(LD) ymd3(PII) ymd3(TII) ymd3(QII) ymd4(VI) ymd4(SI) ymd4(UI) ymd4(ULL)\nbvt(popc,__builtin_popcount)bvt(ctz,__builtin_ctz)bvt(clz,__builtin_clz)bvt(bit_parity,__builtin_parity)\n#define siz(r) ((int)r.size())\n#define ALL(r) r.begin(), r.end()\n#define sim template <class T\n#define ros return o\nsim,class N>bool mini(T&o,N h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(T&o,N h){if(o<h)ros=h,1;return 0;}\n#define oor >ostream &operator<<(ostream &o,\n#define urs(r) typename pta<typename remove_reference<decltype(r)>::type>::t\n#define bnt ;}sim> struct\nsim,class N oor pair<T,N>u){ros<<""<""<<u.f<<"", ""<<u.s<<"">"" bnt pta{using t=T;};sim,int N>struct pta<T[N]>{using t=T*;};\nsim,typename=typename enable_if<!is_same<T,string>::value,urs(T().end())>::type oor\nT u){int c=0;o<<""{"";for(auto e:u)o<<"", ""+2*!c++<<e;ros<<""}"";}\nint mpow(int b, int e) {int o = 1; while (e) {if (e & 1)o = o * 1ll * b % MOD;b = b * 1ll * b % MOD;e /= 2;}ros;}\nvoid dor(){cerr<<dec<<""\\033[0m""<<endl;}sim,class...N>void dor(T x,N...y){cerr<<boolalpha<<x<<""; "";dor(y...);} const bool deb =\n#define acv(N,O) sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(N o, T x) {ros O N(x);} \\\n  sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(T o, N x) {return N(o) O x;} \\\n  sim> typename enable_if<is_arithmetic<T>::value || is_same<T,N>::value, N&>::type operator O##=(N &o, T x) {ros = o O N(x);}\n#ifdef DEB\ntrue;\n#define debug(c...)cerr<<""\\033[1;""<<30+__LINE__%8<<""m[""<<__FUNCTION__<<""#""<<__LINE__<<""] \\033[""<<30+(__LINE__/8+__LINE__*3)%8<<""m"",::dor(c)\n#define rcu m);}g(+) g(-) g(*) g(/) g(%) g(<<) g(>>) g(^) g(|) g(&) g(>=) g(<=) g(>) g(<) g(!=) g(==)\n#define zub(h,t,n...) class N> auto operator h(n u)->nep<urs(t)> {return ngy(t,\nsim>string bte(T u){stringstream o;o<<u;ros.str()bnt nep;sim>T yyo(nep<T>);sim>nep<T>ngy(T v,string c,int m=0);sim>T yyo(T o){ros bnt\nnep{T v;string c;int m; nep<T>mask(){return ngy(v,c,1);}\n#define g(o) template<zub(o, v o u, N) ""("" + bte(*this) + "") "" #o "" ("" + bte(u) + "")"", m);}\ntemplate<zub([],v[yyo(u)],N)c+""[""+bte(u)+""]"",rcu};sim>nep<T>ngy(T v,string c,int m){return nep<T>{v,c,m};}\nsim>T yyo(nep<T> o){ros.v;}sim>int uhn(T){return 0;}sim>int uhn(nep<T>o){ros.m;}\n#define ccy(c, y) sim> class enable_if<c is_arithmetic<T>::value,string>::type ema(T u){return bte(y);}\nccy(,bitset<8*sizeof(T)>(u))ccy(!,u)sim,class N> string ema(pair<T,N> o) {return ""<"" + ema(o.f) + "", "" + ema(o.s) + "">"";}\n#define g(o) sim, zub(o, yyo(p) o u.v, T p, nep<N>) ""("" + bte(p) + "") "" #o "" ("" + bte(u) + "")"", uhn(p) + u.m);}\nsim>string bte(nep<T>o){ros.c+"" = ""+(o.m?ema(o.v):bte(o.v));}sim oor nep<T>m){ros<<bte(rcu sim>nep<T>ngy(nep<T>o,string c="""",int m=0){ros;}\n#undef g\n#define imie(a...) ngy(a, #a)\n#define imask(a...) ngy(a, #a, 1)\n#define range(u, g, c) ngy(list<urs(u[0])>(&u[yyo(g)], &u[yyo(c)] + 1), #u ""["" + bte(g) + ""..."" + bte(c) + ""]"")\n#define arr(a, i) imie(a)[imie(i)]\n#define arr2(a, i, j) imie(a)[imie(i)][imie(j)]\n#define arr3(a, i, j, k) imie(a)[imie(i)][imie(j)][imie(k)]\n#define arr4(a, i, j, k, q) imie(a)[imie(i)][imie(j)][imie(k)][imie(q)]\nvector <stringstream> lif;struct prux {prux() {lif.EB();}~prux() {lif.pop_back();}};\n#define mark_stack(c...) udz(__LINE__,c)\n#define udz(a,b...) erf(a, b)\n#define erf(l,c...) prux _4IJ1MYUxZy2p_Q##l;lif.back()<<""\\033[1;""<<30+l%8<<""m[""<<__FUNCTION__<<\\\n  ""#""<<l<<""] \\033[""<<30+(l/8+l*3)%8<<""m"";siw(c)\nvoid siw(){};sim, class...N> void siw(T x, N...y) {lif.back() << x << ""; "";siw(y...);}\n#define print_stack() cerr << ""STACK_TRACE_FROM:"" << __FUNCTION__ << ""#"" << __LINE__<<endl,nfl()\n#define ckx(o) template<zub(o, o yyo(u), nep<N>) #o ""("" + bte(u) + "")"", u.m);}\nsim> struct tqaz{T a;int u,d,l,r;};sim> tqaz<T> zaqt(T a,int u,int d,int l,int r){return tqaz<T>{a,u,d,l,r};}\n#define matr(a,u,d,l,r) ngy(zaqt(a,yyo(u),yyo(d),yyo(l),yyo(r)), #a""[""+bte(u)+""...""+bte(d)+""][""+bte(l)+""...""+bte(r)+""]"")\n#define avc(f) sim>string f(tqaz<T> x){vector<vector<string>> t;FOR(i,x.u,x.d){t.EB();FOR(j,x.l,x.r)t.back().PB(f(x.a[i][j]));}\\\nstringstream o;VI M;FOR(j,x.l,x.r){int m=0;FOR(i,x.u,x.d)maxi(m, siz(t[i-x.u][j-x.l]));M.PB(m);}FOR(i,x.u,x.d){o<<""\\n\\t[""<<i<<""] "";\\\nFOR(j,x.l,x.r){REP(_, M[j-x.l]-siz(t[i-x.u][j-x.l]))o<<"" "";o<<t[i-x.u][j-x.l]<<((j+1)%5?"", "":""; "");}}ros.str() + ""\\n"";}\nvoid nfl() {for (auto &s : lif)cerr << ""  "" << s.str() << ""\\033[m"" << endl;} ckx(+) ckx(-) ckx(!) ckx(~) avc(bte) avc(ema)\nstruct zet_p {int o;LD v;zet_p(LL x=0):o(x%MOD),v(x){} zet_p(LL x, LD y):o(x%MOD),v(y){} int get(){ros>=0?o:o+MOD;}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o,v+a.v);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o,v-a.v);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o,v*a.v);}\n  zet_p operator/(zet_p a) {assert(a.o != 0); return zet_p(o*1ll*mpow(a.o, MOD-2),v/a.v);}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nostream&operator<<(ostream &o, zet_p u) {ros<<""[""<<u.o<<"" @ ""<<u.v<<""]"";}using frac_mod = zet_p;\n#else\nfalse;\nstruct zet_p {int o;int get(){ros>=0?o:o+MOD;}zet_p(LL x=0):o(x%MOD){}zet_p(int x):o(x%MOD){}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o);}\n  zet_p operator/(zet_p a) {return zet_p(o*1ll*mpow(a.o, MOD - 2));}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nstruct frac_mod {int o,m;int get(){return (o*1ll*mpow(m,MOD-2)%MOD+MOD)%MOD;}frac_mod(int x=0):o(x%MOD),m(1){}frac_mod(LL x):o(x%MOD),m(1){}\n  frac_mod(LL a,LL b):o(a),m(b){}\n  frac_mod operator+(frac_mod a){return frac_mod(o*1ll*a.m+m*1ll*a.o,m*a.m);}\n  frac_mod operator-(frac_mod a){return frac_mod(o*1ll*a.m-m*1ll*a.o,m*a.m);}\n  frac_mod operator*(frac_mod a){return frac_mod(o*1ll*a.o,m*1ll*a.m);}\n  frac_mod operator/(frac_mod a){return frac_mod(o*1ll*a.m,m*1ll*a.o);}\n  bool operator==(frac_mod a) {return (o * 1ll * a.m - m * 1ll * a.o) % MOD == 0;}};\nacv(frac_mod, +) acv(frac_mod, -) acv(frac_mod, *) acv(frac_mod, /)\n#define debug(...)\n#define mark_stack(...)\n#define print_stack(...)\n#endif\nacv(zet_p, +) acv(zet_p, -) acv(zet_p, *) acv(zet_p, /)\n#define nok(o,c,r,l...) auto operator o(c p, r y)-> decltype(MP(l)) {return MP(l);}\n#define pcg(o) sim, class S, class N, class H> nok(o, pair<S u T>, pair<H u N>, p.f o y.f, p.s o y.s)\\\nsim,class S,class N,class=typename enable_if<!is_base_of<ios_base,typename remove_reference<T>::type>::value>::type>nok\\\n(o,T,pair<S u N>, p o y.f, p o y.s) sim, class S, class N> nok(o, pair<S u N>, T, p.f o y, p.s o y)\n#define clp(r) pcg(r) sim, class S, class N, class H> \\\n\tpair <T,S> & operator r##=(pair <T,S> &p, pair<N,H> y) {p.f r##= y.f; p.s r##= y.s; return p;}\\\n\tsim, class S, class N> pair <T,S> &operator r##=(pair<T,S> &p, N y) {p.f r##= y; p.s r##= y; return p;}\n#define u ,\n#define syd(o) sim, class N> auto operator o(pair<T,N> e) -> decltype(MP(o e.f, o e.s)) {return MP(o e.f, o e.s);}\nclp(+) clp(-) clp(*) clp(/) clp(%) clp(^) clp(|) clp(>>) clp(<<) clp(&) pcg(&&) pcg(||) syd(-) syd(+) syd(~) syd(!)\n#undef u\nsim> int dud(T &, T&);sim> char dud(T x, ...);\n#define muf(c...) {\\\n\tsim, class N> static T c get1(pair <T, N> c o){ros.f;}\\\n\tsim, class N> static N c get2(pair <T, N> c o){ros.s;}\\\n\tsim, class N, class S> static T c get1(tri(T, N, S) c o){ros.f.f;}\\\n\tsim, class N, class S> static N c get2(tri(T, N, S) c o){ros.f.s;}\\\n\tsim, class N, class S> static S c get3(tri(T, N, S) c o){ros.s;}\\\n\tsim, class N, class S, class H> static S c get3(quadr(T, N, S, H) c o){ros.s.f;}\\\n\tsim, class N, class S, class H> static H c get4(quadr(T, N, S, H) c o){ros.s.s;}\\\n};\ntemplate <class X> struct qul muf()\ntemplate <> struct qul <int> muf(&)\n#define get1(o) qul<decltype(dud(o, o))>::get1(o)\n#define get2(o) qul<decltype(dud(o, o))>::get2(o)\n#define get3(o) qul<decltype(dud(o, o))>::get3(o)\n#define get4(o) qul<decltype(dud(o, o))>::get4(o)\nsim, class N> using gyv = T;\nnamespace std {sim, class N> struct hash<pair<T,N>>{size_t operator()(const pair<T,N>&u)const {\n      return hash<T>()(u.f) * 440624741ULL ^ hash<N>()(u.s);}};\n  sim> struct hash<gyv<T, decltype(((T*)0)->end())>> {size_t operator()(const T& u) const {size_t o = 505347433;\nfor (auto e : u)o = hash<urs(e)>()(e) ^ o * 277953755ULL;ros;}};}\n\nconst int MN = 1e6 + 44;\nvoid PdAYB7V() {\n\tprint_stack();\n\tdebug(imie(MN) * 1ll * imie(MOD), ""make sure it is right!!!!"");\n\tdebug(""make sure m, n aren\'t misused"");\n\tdebug(""long longs!!!!!!!!!!!!!!!!!!!"");\n\tdebug(""run with m, n = 1"");\n\tdebug(""make sure bounds on values aren\'t misused"");\n\tdebug(""Check time/memory limit"");\n\twhile (getchar() != EOF);\n\texit(0);\n}\nchar in[MN];\nint main() {\n\t#ifdef DEB\n\tatexit(PdAYB7V);\n\t#endif\n\tscanf(""%s"", in);\n\tint ones = 0;\n\tint n = strlen(in);\n\tbool used = false;\n\tREP(i, n)\n\t\tif (in[i] == \'1\')\n\t\t\tones++;\n\tREP(i, n) {\n\t\tif (in[i] == \'2\' && !used) {\n\t\t\tused = true;\n\t\t\tREP(_, ones)\n\t\t\t\tputchar(\'1\');\n\t\t\t\n\t\t}\n\t\tif (in[i] != \'1\')\n\t\t\tputchar(in[i]);\n\t}\n\tif (!used)\n\t\tREP(_, ones)\n\t\t\tputchar(\'1\');\n\tprintf(""\\n"");\n}\n\n\n']","['greedy', 'implementation']",1400
https://codeforces.com//contest/1180/problem/A,A. Alex and a Rhombus,While playing with geometric figures Alex has accidentally invented a concept of a in a cell grid is just a square 1 times 1 i e just a cell for all n geq 2 one obtains from a adding all cells which have a common side with it to it look at the picture to understand it better Alex asks you to compute the number of cells in a ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC optimize(3)\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC target(""sse3"",""sse2"",""sse"")\n//#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n//#pragma GCC target(""f16c"")\n//#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n//#pragma GCC diagnostic error ""-fwhole-program""\n//#pragma GCC diagnostic error ""-fcse-skip-blocks""\n//#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n//#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return \'""\' + s + \'""\';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? ""true"" : ""false"");}template <typename A, typename B>string to_string(pair<A, B> p) {return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";}template <typename A>string to_string(A v) {bool first = true;string res = ""{"";for (const auto &x : v) {if (!first) {res += "", "";}first = false;res += to_string(x);}res += ""}"";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << "" "" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == \'-\') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - \'0\';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\n\nnamespace SOLVE {\n    ll f(ll n){\n        if(n == 1){\n            return 1;\n        }else{\n            return 4*(n-1)+f(n-1);\n        }\n    }\n    void main(){\n        ll n;cin>>n;\n        cout<<f(n);\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']","['dp', 'implementation', 'math']",800
https://codeforces.com//contest/1614/problem/A,A. Divan and a Store,Businessman loves chocolate Today he came to a store to buy some chocolate Like all businessmen knows the value of money so he will not buy too expensive chocolate At the same time too cheap chocolate tastes bad so he will not buy it as well The store he came to has n different chocolate bars and the price of the i th chocolate bar is a i dollars considers a chocolate bar too expensive if it costs strictly more than r dollars Similarly he considers a bar of chocolate to be too cheap if it costs strictly less than l dollars Divan will not buy too cheap or too expensive bars is not going to spend all his money on chocolate bars so he will spend at most k dollars on chocolates Please determine the maximum number of chocolate bars can buy ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tint T;\n\tfor(cin >> T ; T ; --T){\n\t\tint N , L , R , K; vector < int > A; cin >> N >> L >> R >> K;\n\t\tfor(int i = 1 ; i <= N ; ++i){int x; cin >> x; if(x >= L && x <= R) A.push_back(x);}\n\t\tsort(A.begin() , A.end() , [&](int p , int q){return p > q;}); int cnt = 0; while(A.size() && A.back() <= K){K -= A.back(); A.pop_back(); ++cnt;}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy']",800
https://codeforces.com//contest/1155/problem/E,E. Guess the Root,Jury picked a polynomial f x a 0 a 1 cdot x a 2 cdot x 2 dots a k cdot x k k le 10 and all a i are integer numbers and 0 le a i 10 6 3 It s guaranteed that there is at least one i such that a i 0 Now jury wants you to find such an integer x 0 that f x 0 equiv 0 mod 10 6 3 or report that there is not such x 0 You can ask no more than 50 queries you ask value x q and jury tells you value f x q mod 10 6 3 Note that printing the answer doesn t count as a query ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e6 + 3;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nll rev[MOD];\n\nconst int N = 12;\nll a[N];\nll b[N], c[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\trev[1] = 1;\n\tfor (ll x = 2; x < MOD; x++)\n\t\trev[x] = sub(0, mult(MOD / x, rev[MOD % x]));\n\n\tfor (int i = 0; i < N; i++) {\n\t\tprintf(""? %d\\n"", i);\n\t\tfflush(stdout);\n\t\tfor (int j = 0; j < N; j++)\n\t\t\ta[j] = 0;\n\t\ta[0] = 1;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == i) continue;\n\t\t\tfor (int k = N - 1; k > 0; k--)\n\t\t\t\ta[k] = sub(a[k - 1], mult(a[k], j));\n\t\t\ta[0] = sub(0, mult(a[0], j));\n\t\t}\n\t\tll y;\n\t\tscanf(""%lld"", &y);\n\t\tif (y == -1) throw;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == i) continue;\n\t\t\ty = mult(y, rev[sub(i, j)]);\n\t\t}\n\t\tfor (int k = 0; k < N; k++)\n\t\t\tc[k] = add(c[k], mult(y, a[k]));\n\t}\n/*\n\tfor (int k = 0; k < N; k++) {\n\t\tprintf(""%lld "", c[k]);\n\t}\n\tprintf(""\\n"");\n\tfflush(stdout);\n*/\n\tfor (ll x = 0; x < MOD; x++) {\n\t\tll w = 0;\n\t\tfor (int k = N - 1; k >= 0; k--) {\n\t\t\tw = add(mult(w, x), c[k]);\n\t\t}\n\t\tif (w == 0) {\n\t\t\tprintf(""! %lld\\n"", x);\n\t\t\tfflush(stdout);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""! -1\\n"");\n\tfflush(stdout);\n\n\treturn 0;\n}\n']","['brute force', 'interactive', 'math']",2200
https://codeforces.com//contest/1409/problem/B,B. Minimum Product,You are given four integers a b x and y Initially a ge x and b ge y You can do the following operation n times Choose either a or b and decrease it by one However as a result of this operation value of a cannot become less than x and value of b cannot become less than y Your task is to find the possible product of a and b a cdot b you can achieve by applying the given operation no more than n times You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nconst ll NN = 2e5 + 5;\nll t;\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n    \tll a, b, x, y, n;\n    \tcin >> a >> b >> x >> y >> n;\n    \tll a2, b2, n2;\n    \tll awal = min(n, a - x);\n    \tll awal2 = min(n, b - y);\n    \ta -= awal;\n    \tn -= awal;\n    \tb2 = b - awal2;\n    \tn2 = n - awal2;\n\n    \tll akhir = min(n, b - y);\n    \tll akhir2 = min(n2, a - x);\n    \tb -= akhir;\n    \tn -= akhir;\n    \ta2 = a - akhir2;\n    \tn2 = n2 - akhir2;\n    \t// cout << a << "" "" << b << "" "" << n << ""\\n"";\n    \ta *= b;\n    \ta2 *= b2;\n    \tcout << min(a, a2) << ""\\n"";\n    }\n}   ']","['brute force', 'greedy', 'math']",1100
https://codeforces.com//contest/812/problem/C,C. Sagheer and Nubian Market,On his trip to Luxor and Aswan Sagheer went to a Nubian market to buy some souvenirs for his friends and relatives The market has some strange rules It contains different items numbered from to The th item has base cost Egyptian pounds If Sagheer buys items with indices then the cost of item is for In other words the cost of an item is equal to its base cost in addition to its index multiplied by the factor Sagheer wants to buy as many souvenirs as possible without paying more than Egyptian pounds Note that he cannot buy a souvenir more than once If there are many ways to maximize the number of souvenirs he will choose the way that will minimize the total cost Can you help him with this task ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#if __cplusplus >= 201103L\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#include <vector>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define FOR(i,a,b) for(int i=a;i<(b);i++)\n#define FORN(i,b) for(int i=0;i<(b);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vii;\n\nint n;\nll w,t,a[100005],c[100005];\n\nbool can(int k){\n\tFORN(i,n)c[i]=a[i]+1LL*(i+1)*k;\n\tsort(c,c+n);\n\tt=0;\n\tFORN(i,k)t+=c[i];\n\treturn t<=w;\n}\n\nint main(){\n\tscanf(""%d%lld"",&n,&w);\n\tFORN(i,n)scanf(""%lld"",a+i);\n\tint s=0,e=n+1;\n\twhile(e-s>1){\n\t\tint m=(s+e)/2;\n\t\tif(can(m))s=m;\n\t\telse e=m;\n\t}\n\tassert(can(s));\n\tprintf(""%d %lld\\n"",s,t);\n\treturn 0;\n}\n']","['binary search', 'sortings']",1500
https://codeforces.com//contest/1316/problem/C,C. Primitive Primes,It is Professor R s last class of his teaching career Every time Professor R taught a class he gave a special problem for the students to solve You being his favourite student put your heart into solving it one last time You are given two polynomials f x a 0 a 1x dots a n 1 x n 1 and g x b 0 b 1x dots b m 1 x m 1 with positive integral coefficients It is guaranteed that the cumulative GCD of the coefficients is equal to 1 for both the given polynomials In other words gcd a 0 a 1 dots a n 1 gcd b 0 b 1 dots b m 1 1 Let h x f x cdot g x Suppose that h x c 0 c 1x dots c n m 2 x n m 2 You are also given a prime number p Professor R challenges you to find any t such that c t isn t divisible by p He guarantees you that under these conditions such t always exists If there are several such t output any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, p;\nint a[2000001], b[20000001];\nint idx, idy;\nint main( ) {\n\tscanf(""%d %d %d"", &n, &m, &p);\n\tfor (int i = 0; i < n; i ++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tif (a[i] % p) idx = i;\n\t}\n\tfor (int i = 0; i < m; i ++) {\n\t\tscanf(""%d"", &b[i]);\n\t\tif (b[i] % p) idy = i;\n\t}\n\tprintf(""%d\\n"", idx + idy);\n\treturn 0;\n}\n']","['constructive algorithms', 'math', 'ternary search']",1800
https://codeforces.com//contest/1835/problem/D,D. Doctor s Brown Hypothesis,The rebels have been crushed in the most recent battle with the imperial forces but there is a ray of new hope Meanwhile on one of the conquered planets Luke was getting ready for an illegal street race which should come as no surprise given his family history Luke arrived at the finish line with 88 miles per hour on his speedometer After getting out of the car he was greeted by a new reality It turns out that the battle has not happened yet and will start in exactly k hours The rebels have placed a single battleship on each of the n planets m unidirectional wormholes connect the planets Traversing each wormhole takes exactly one hour Generals of the Imperium have planned the battle precisely but their troops cannot dynamically adapt to changing circumstances Because of this it is enough for the rebels to move some ships around before the battle to confuse the enemy secure victory and change the galaxy s fate Owing to numerous strategical considerations which we now omit the rebels would like to choose two ships that will switch places so that both of them will be on the move for the whole time exactly k hours In other words rebels look for two planets x and y such that paths of length k exist from x to y and from y to x Because of the limited fuel supply choosing one ship would also be acceptable This ship should fly through the wormholes for k hours and then return to its initial planet How many ways are there to choose the ships for completing the mission ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n, m;\nll T;\nvector<int> g[N], rg[N];\nvector<pii> G[N];\nbool used[N];\nint ord[N];\nint ordSz;\nint col[N];\nint id[N];\nint a[N];\nvector<int> forCol[N];\nint GCD;\nll cntLen[N];\n\nvoid dfsOrd(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) if (!used[u])\n\t\tdfsOrd(u);\n\tord[ordSz++] = v;\n}\nvoid dfsCol(int v) {\n\tcol[v] = m;\n\tfor (int u : rg[v]) if (col[u] == 0)\n\t\tdfsCol(u);\n}\nvoid dfsVal(int v) {\n\tfor (pii e : G[v]) {\n\t\tint u = e.first;\n\t\tint x = a[v] + e.second;\n\t\tif (a[u] == -1) {\n\t\t\ta[u] = x;\n\t\t\tdfsVal(u);\n\t\t} else {\n\t\t\tx = abs(x - a[u]);\n\t\t\tif (x != 0) GCD = gcd(GCD, x);\n\t\t}\n\t}\n}\n\nll solve(int sz) {\n\tif (sz == 1) {\n\t\tif (G[0].empty()) return 0;\n\t\treturn 1;\n\t}\n\tfor (int i = 0; i < sz; i++)\n\t\ta[i] = -1;\n\ta[0] = N;\n\tGCD = 0;\n\tdfsVal(0);\n\tassert(GCD != 0);\n\tassert(GCD <= sz);\n\tfor (int i = 0; i < GCD; i++)\n\t\tcntLen[i] = 0;\n\tfor (int i = 0; i < sz; i++)\n\t\tcntLen[a[i] % GCD]++;\n\tll ans = 0;\n\tif (T % GCD == 0) {\n\t\tfor (int i = 0; i < GCD; i++)\n\t\t\tans += cntLen[i] * (cntLen[i] + 1) / 2;\n\t} else if ((2 * T) % GCD == 0) {\n\t\tfor (int i = 0; i < GCD / 2; i++)\n\t\t\tans += cntLen[i] * cntLen[i + GCD / 2];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%lld"", &n, &m, &T);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\trg[u].push_back(v);\n\t}\n\tfor (int v = 0; v < n; v++) if (!used[v])\n\t\tdfsOrd(v);\n\tm = 0;\n\treverse(ord, ord + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tif (col[v] != 0) continue;\n\t\tm++;\n\t\tdfsCol(v);\n\t}\n\tfor (int v = 0; v < n; v++)\n\t\tforCol[col[v] - 1].push_back(v);\n\tll ans = 0;\n\tfor (int c = 0; c < m; c++) {\n\t\tint sz = (int)forCol[c].size();\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tG[i].clear();\n\t\t\tid[forCol[c][i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tint v = forCol[c][i];\n\t\t\tfor (int u : g[v]) {\n\t\t\t\tif (col[u] != col[v]) continue;\n\t\t\t\tG[i].push_back(mp(id[u], 1));\n\t\t\t\tG[id[u]].push_back(mp(i, -1));\n\t\t\t}\n\t\t}\n\t\tans += solve(sz);\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","['dfs and similar', 'graphs', 'math', 'number theory']",2900
https://codeforces.com//contest/1644/problem/E,E. Expand the Path,Consider a grid of size n times n The rows are numbered top to bottom from 1 to n the columns are numbered left to right from 1 to n The robot is positioned in a cell 1 1 It can perform two types of moves move one cell down move one cell right The robot is not allowed to move outside the grid You are given a sequence of moves s the initial path of the robot This path doesn t lead the robot outside the grid You are allowed to perform an arbitrary number of modifications to it possibly zero With one modification you can duplicate one move in the sequence That is replace a single occurrence of with or a single occurrence of with Count the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn t move outside the grid ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (""avx2"")\n#pragma GCC optimization (""O3"")\n#pragma GCC optimization (""unroll-loops"")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    ll n; cin>>n;\n    string s; cin>>s;\n    int cntr = 0; int cntd = 0;\n    for (auto c: s)\n    {\n        if (c==\'D\') cntd++;\n        else cntr++;\n    }\n\n\n    int x = 1; int y = 1;\n\n    map<int, int> xmap, ymap;\n\n    xmap[1] = 1;\n    ymap[1] = 1;\n\n    for (auto c: s)\n    {\n        if (c==\'D\') y++;\n        else x++;\n        xmap[x] = y;\n        ymap[y] = x;\n    }\n\n    ll leftr = n-x;\n    ll leftd = n-y;\n\n\n    ll ans = 1 + (int)s.size();\n    for (auto it: xmap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftd);\n    }\n\n    for (auto it: ymap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftr);\n    }\n\n    if (x>1 && y>1) ans+=1ll*min(n-x, leftr)*min(n-y, leftd);\n    cout<<ans<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n/*\n1\n3\nD\n */']","['brute force', 'combinatorics', 'data structures', 'implementation', 'math']",1900
https://codeforces.com//contest/1479/problem/D,D. Odd Mineral Resource,In Homer s country there are n cities numbered 1 to n and they form a tree That is there are n 1 undirected roads between these n cities and every two cities can reach each other through these roads Homer s country is an industrial country and each of the n cities in it contains some mineral resource The mineral resource of city i is labeled a i Homer is given the plans of the country in the following q years The plan of the i th year is described by four parameters u i v i l i and r i and he is asked to find any mineral resource c i such that the following two conditions hold mineral resource c i appears an number of times between city u i and city v i and l i leq c i leq r i As the best friend of Homer he asks you for help For every plan find any such mineral resource c i or tell him that there doesn t exist one ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef uint64_t uint64;\ntypedef pair<int, int> ii;\n\ntypedef vector < vector<int> > graph;\ntypedef vector<int>::const_iterator const_graph_iter;\n\nclass DOddMineralResource {\n public:\n  int n;\n  vector<int> a;\n  graph adj;\n\n  vector<int> lca_h, lca_dfs_list, lca_first, lca_tree;\n  vector<char> lca_dfs_used;\n  vector<int> tleft;\n  vector<int> tright;\n  vector<uint64> thash;\n\n  uint64 mod1;\n  uint64 mod2;\n  uint64 base1;\n  uint64 base2;\n  vector<uint64> pow1;\n  vector<uint64> pow2;\n  vector<int> rootFor;\n\n  bool prime(uint64 x) {\n    for (uint64 p = 2; p * p <= x; ++p) if (x % p == 0) return false;\n    return true;\n  }\n\n  DOddMineralResource() {\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    mod1 = uniform_int_distribution((int) 9e8, (int) 1e9)(rng);\n    while (!prime(mod1)) ++mod1;\n    base1 = uniform_int_distribution((int) 3137, (int) mod1 - 3137)(rng);\n    mod2 = uniform_int_distribution((int) 9e8, (int) 1e9)(rng);\n    while (!prime(mod2)) ++mod2;\n    base2 = uniform_int_distribution((int) 3137, (int) mod2 - 3137)(rng);\n    pow1.resize((int) 3e5 + 10);\n    pow1[0] = 1;\n    pow2.resize((int) 3e5 + 10);\n    pow2[0] = 1;\n    for (int i = 1; i < pow1.size(); ++i) {\n      pow1[i] = base1 * pow1[i - 1] % mod1;\n      pow2[i] = base2 * pow2[i - 1] % mod2;\n    }\n  }\n\n  void lca_dfs (const graph & g, int v, int h = 1)\n  {\n    lca_dfs_used[v] = true;\n    lca_h[v] = h;\n    lca_dfs_list.push_back (v);\n    for (const_graph_iter i = g[v].begin(); i != g[v].end(); ++i)\n      if (!lca_dfs_used[*i])\n      {\n        lca_dfs (g, *i, h+1);\n        lca_dfs_list.push_back (v);\n      }\n  }\n\n  void lca_build_tree (int i, int l, int r)\n  {\n    if (l == r)\n      lca_tree[i] = lca_dfs_list[l];\n    else\n    {\n      int m = (l + r) >> 1;\n      lca_build_tree (i+i, l, m);\n      lca_build_tree (i+i+1, m+1, r);\n      if (lca_h[lca_tree[i+i]] < lca_h[lca_tree[i+i+1]])\n        lca_tree[i] = lca_tree[i+i];\n      else\n        lca_tree[i] = lca_tree[i+i+1];\n    }\n  }\n\n  void lca_prepare (const graph & g, int root)\n  {\n    int n = (int) g.size();\n    lca_h.resize (n);\n    lca_dfs_list.reserve (n*2);\n    lca_dfs_used.assign (n, 0);\n\n    lca_dfs (g, root);\n\n    int m = (int) lca_dfs_list.size();\n    lca_tree.assign (lca_dfs_list.size() * 4 + 1, -1);\n    lca_build_tree (1, 0, m-1);\n\n    lca_first.assign (n, -1);\n    for (int i = 0; i < m; ++i)\n    {\n      int v = lca_dfs_list[i];\n      if (lca_first[v] == -1)\n        lca_first[v] = i;\n    }\n  }\n\n  int lca_tree_min (int i, int sl, int sr, int l, int r)\n  {\n    if (sl == l && sr == r)\n      return lca_tree[i];\n    int sm = (sl + sr) >> 1;\n    if (r <= sm)\n      return lca_tree_min (i+i, sl, sm, l, r);\n    if (l > sm)\n      return lca_tree_min (i+i+1, sm+1, sr, l, r);\n    int ans1 = lca_tree_min (i+i, sl, sm, l, sm);\n    int ans2 = lca_tree_min (i+i+1, sm+1, sr, sm+1, r);\n    return lca_h[ans1] < lca_h[ans2] ? ans1 : ans2;\n  }\n\n  int lca (int a, int b)\n  {\n    int left = lca_first[a],\n        right = lca_first[b];\n    if (left > right)  swap (left, right);\n    return lca_tree_min (1, 0, (int)lca_dfs_list.size()-1, left, right);\n  }\n\n  int initTree(int left, int right) {\n    int at = tleft.size();\n    tleft.push_back(-1);\n    tright.push_back(-1);\n    thash.push_back(0);\n    if (left == right) {\n    } else {\n      int mid = (left + right) / 2;\n      tleft[at] = initTree(left, mid);\n      tright[at] = initTree(mid + 1, right);\n    }\n    return at;\n  }\n\n  uint64 mergeHashes(uint64 hleft, uint64 hright, int leftSize) {\n    uint64 h1 = ((hleft >> 32) + (hright >> 32) * pow1[leftSize]) % mod1;\n    uint64 h2 = ((hleft & (((uint64) 1 << 32) - 1)) + (hright & (((uint64) 1 << 32) - 1)) * pow2[leftSize]) % mod2;\n    return (h1 << 32) + h2;\n  }\n\n  int updateTree(int root, int left, int right, int updAt) {\n    int at = tleft.size();\n    tleft.push_back(tleft[root]);\n    tright.push_back(tright[root]);\n    thash.push_back(0);\n    if (left == right) {\n      assert(left == updAt);\n      uint64 one = (((uint64) 1) << 32) + 1;\n      if (thash[root] == 0) {\n        thash[at] = one;\n      } else {\n        assert(thash[root] == one);\n        thash[at] = 0;\n      }\n    } else {\n      int mid = (left + right) / 2;\n      if (updAt <= mid) {\n        tleft[at] = updateTree(tleft[root], left, mid, updAt);\n      } else {\n        tright[at] = updateTree(tright[root], mid + 1, right, updAt);\n      }\n      thash[at] = mergeHashes(thash[tleft[at]], thash[tright[at]], mid - left + 1);\n    }\n    return at;\n  }\n\n  void walk(int at, int skip, int treeRoot) {\n    treeRoot = updateTree(treeRoot, 0, n - 1, a[at]);\n    rootFor[at] = treeRoot;\n    for (int v : adj[at]) {\n      if (v == skip) continue;\n      walk(v, at, treeRoot);\n    }\n  }\n\n  int findDiff(int rootU, int rootV, int left, int right, int needLeft, int needRight) {\n    if (needLeft > needRight) return -1;\n    if (left == needLeft && right == needRight) {\n      if (thash[rootU] == thash[rootV]) {\n        return -1;\n      }\n      if (left == right) {\n        return left;\n      }\n    }\n    int mid = (left + right) / 2;\n    int c = findDiff(tleft[rootU], tleft[rootV], left, mid, needLeft, min(needRight, mid));\n    if (c >= 0) return c;\n    return findDiff(tright[rootU], tright[rootV], mid + 1, right, max(mid + 1, needLeft), needRight);\n  }\n\n  void solveOne() {\n    int q;\n    cin >> n >> q;\n    a = vector<int>(n);\n    for (auto& x : a) {\n      cin >> x;\n      --x;\n    }\n    adj = vector<vector<int>>(n);\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    int root = 0;\n    lca_prepare(adj, root);\n    tleft.clear();\n    tright.clear();\n    thash.clear();\n    int treeRoot = initTree(0, n - 1);\n    rootFor = vector<int>(n);\n    walk(root, -1, treeRoot);\n    for (int qi = 0; qi < q; ++qi) {\n      int u, v, l, r;\n      cin >> u >> v >> l >> r;\n      --u; --v; --l; --r;\n      int w = lca(u, v);\n      int rootU = rootFor[u];\n      int rootV = rootFor[v];\n      rootU = updateTree(rootU, 0, n - 1, a[w]);\n      int c = findDiff(rootU, rootV, 0, n - 1, l, r);\n      if (c >= 0) ++c;\n      cout << c << ""\\n"";\n    }\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    DOddMineralResource solver;\n\n\n    solver.solve();\n    return 0;\n}\n']","['binary search', 'bitmasks', 'brute force', 'data structures', 'probabilities', 'trees']",2900
https://codeforces.com//contest/27/problem/B,B. Tournament,The tournament Sleepyhead 2010 in the rapid falling asleep has just finished in Berland best participants from the country have participated in it The tournament consists of games each of them is a match between two participants games were played during the tournament and each participant had a match with each other participant The rules of the game are quite simple the participant who falls asleep first wins The secretary made a record of each game in the form where and are the numbers of participants The first number in each pair is a winner i e is a winner and is a loser There is no draws Recently researches form the Institute Of Sleep have found that every person is characterized by a value the speed of falling asleep The person who has lower speed wins Every person has its own value constant during the life It is known that all participants of the tournament have distinct speeds of falling asleep Also it was found that the secretary made records about all the games except one You are to find the result of the missing game ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<list>\n#include<set>\n#include<queue>\n#include<cassert>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define LET(x,a) \t__typeof(a) x(a)\n#define IFOR(i,a,b) \tfor(LET(i,a);i!=(b);++i)\n#define EACH(it,v)  \tIFOR(it,v.begin(),v.end())\n#define FOR(i,a,b)  \tfor(int i=(int)(a) ; i < (int)(b);++i)\n#define REP(i,n) \tFOR(i,0,n)\n#define PB\t\tpush_back\n#define MP \t\tmake_pair\n#define EPS\t\t1e-9\n#define INF 2000000000\n\ntypedef vector<int>\tVI;\ntypedef long long\tLL;\ntypedef pair<int,int>\tPI;\n\nint main(){\n\tint n;cin>>n;\n\tint visited[n+2][n+2];\n\tmemset(visited,-1,sizeof(visited));\n\tint num = (n*(n-1))/2 - 1;\n\tREP(i,num){\n\t\tint a,b;\n\t\tscanf(""%d%d"",&a,&b);\n\t\tvisited[a][b] = 1;\n\t\tvisited[b][a] = 0;\n\t}\n\tint np1,np2;\n\tFOR(i,1,n+1)FOR(j,1,n+1)if(i!=j){\n\t\tif(visited[i][j]==-1){\n\t\t\tnp1 = i;\n\t\t\tnp2 = j;\n\t\t}\n\t}\n\tint ans = -1;\n\tFOR(i,1,n+1)if(i!=np1 && i!=np2){\n\t\tif(visited[np1][i]!=visited[np2][i]){\n\t\t\tif(visited[np1][i]==1)ans = 1;\n\t\t\telse ans = 2;\n\t\t}\n\t}\n\tif(ans==1)cout<<np1<<"" ""<<np2<<endl;\n\telse cout<<np2<<"" ""<<np1<<endl;\n\treturn 0;\n}\n']","['bitmasks', 'brute force', 'dfs and similar', 'greedy']",1300
https://codeforces.com//contest/354/problem/A,A. Vasya and Robot,Vasya has items lying in a line The items are consecutively numbered by numbers from to in such a way that the leftmost item has number the rightmost item has number Each item has a weight the th item weights kilograms Vasya needs to collect all these items however he won t do it by himself He uses his brand new robot The robot has two different arms the left one and the right one The robot can consecutively perform the following actions Take the leftmost item with the left hand and spend energy units is a weight of the leftmost item is some parameter If the previous action was the same left hand then the robot spends extra energy units Take the rightmost item with the right hand and spend energy units is a weight of the rightmost item is some parameter If the previous action was the same right hand then the robot spends extra energy units Naturally Vasya wants to program the robot in a way that the robot spends as little energy as possible He asked you to solve this problem Your task is to find the minimum number of energy units robot spends to collect all items ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint N;\nint w[100010];\n\nint main(void){\n    int i;\n    ll l,r,Ql,Qr;\n    \n    cin >> N >> l >> r >> Ql >> Qr;\n    REP(i,N) scanf(""%d"", &w[i]);\n    \n    ll S = 0;\n    REP(i,N) S += w[i];\n    \n    ll ans = (1ll<<60);\n    ll L = 0;\n    \n    REP(i,N+1){\n        if(i != 0) L += w[i-1];\n        ll R = S - L;\n        ll tmp = L * l + R * r;\n        int j = N - i;\n        if(i > j) tmp += (i - j - 1) * Ql;\n        if(i < j) tmp += (j - i - 1) * Qr;\n        ans = min(ans, tmp);\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']","['brute force', 'greedy', 'math']",1500
https://codeforces.com//contest/1381/problem/C,C. Mastermind,In the game of Mastermind there are two players Alice and Bob Alice has a secret code which Bob tries to guess Here a code is defined as a sequence of n colors There are exactly n 1 colors in the entire universe numbered from 1 to n 1 inclusive When Bob guesses a code Alice tells him some information about how good of a guess it is in the form of two integers x and y The first integer x is the number of indices where Bob s guess correctly matches Alice s code The second integer y is the size of the intersection of the two codes as multisets That is if Bob were to change the order of the colors in his guess y is the maximum number of indices he could get correct For example suppose n 5 Alice s code is 3 1 6 1 2 and Bob s guess is 3 1 1 2 5 At indices 1 and 2 colors are equal while in the other indices they are not equal So x 2 And the two codes have the four colors 1 1 2 3 in common so y 4 Solid lines denote a matched color for the same index Dashed lines denote a matched color at a different index x is the number of solid lines and y is the total number of lines You are given Bob s guess and two values x and y Can you find one possibility of Alice s code so that the values of x and y are correct ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n,x,y;\nvi b, ans;\nvi cnt[MX];\nvi oc[MX];\n\nvoid make(int a, int b) { // index, value\n\tassert(sz(cnt[a]));\n\tans[cnt[a].bk] = b;\n\tcnt[a].pop_back();\n}\n\nvoid solve() {\n\tre(n,x,y); b.rsz(n); re(b); ans = vi(n);\n\t//dbg(""OK"",n,x,y,b);\n\tF0R(i,n+2) cnt[i].clear();\n\tF0R(i,n+1) oc[i].clear();\n\tF0R(i,n) cnt[b[i]].pb(i);\n\tint bad = 1; while (sz(cnt[bad])) bad ++;\n\tFOR(i,1,n+2) oc[sz(cnt[i])].pb(i);\n\tint ind = n;\n\t//dbg(""STARTLOOP"");\n\t//dbg(""STARTLOOP"");\n\tF0R(i,x) {\n\t\twhile (!sz(oc[ind])) ind --;\n\t\tint z = oc[ind].bk; //dbg(""CHOOSING"",ind,z);\n\t\toc[ind].pop_back(); make(z,z);\n\t\toc[sz(cnt[z])].pb(z);\n\t}\n\t//dbg(""MIDLOOP"");\n\twhile (!sz(oc[ind])) ind --;\n\tint BIG = oc[ind].bk;\n\tint lef = n-x, des = y-x, mx = min(2*(lef-ind),lef);\n\t//dbg(lef,des,mx);\n\tif (mx < des) {\n\t\tps(""NO"");\n\t\treturn;\n\t}\n\tif (mx == 2*(lef-ind)) {\n\t\tdbg(""HUH"");\n\t\tvi big, small;\n\t\tFOR(i,1,n+2) trav(t,cnt[i]) {\n\t\t\tif (i == BIG) big.pb(i);\n\t\t\telse small.pb(i);\n\t\t}\n\t\tassert(sz(big) >= sz(small));\n\t\tF0R(i,sz(small)) {\n\t\t\tif (des) des --, make(big[i],small[i]);\n\t\t\tif (des) des --, make(small[i],big[i]);\n\t\t}\n\t\tassert(des == 0);\n\t} else {\n\t\tdbg(""NOPE"");\n\t\tvi LEF;\n\t\tFOR(i,1,n+2) trav(t,cnt[i]) LEF.pb(i); // value, index\n\t\tassert(sz(LEF) == lef);\n\t\tF0R(i,des) make(LEF[i],LEF[(i+ind)%sz(LEF)]);\n\t}\n\tps(""YES"");\n\ttrav(t,ans) if (t == 0) t = bad;\n\tps(ans);\n\t// fill up y-x\n}\n\n// choose x to match\n// exactly y-x common, can\'t match\n// can\'t get > max\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","['constructive algorithms', 'graph matchings', 'greedy', 'implementation', 'sortings', 'two pointers']",2500
https://codeforces.com//contest/911/problem/G,G. Mass Change Queries,You are given an array consisting of integers You have to process queries to this array each query is given as four numbers and denoting that for every such that and you have to set equal to Print the array after all queries are processed ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic void adjust(list<int> &X, list<int> &Y, int l, int r)\n{\n    auto it = X.begin();\n    while (it != X.end())\n    {\n        auto nxt = next(it);\n        if (*it >= l && *it < r)\n            Y.splice(Y.begin(), X, it);\n        it = nxt;\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    int S = min(500, N);\n    int M = (N + S - 1) / S;\n    int H = 101;\n    vector<vector<list<int>>> pos(H, vector<list<int>>(M));\n    for (int i = 0; i < N; i++)\n    {\n        int s = i / S;\n        int a;\n        cin >> a;\n        pos[a][s].push_back(i);\n    }\n    int Q;\n    cin >> Q;\n    for (int i = 0; i < Q; i++)\n    {\n        int l, r, x, y;\n        cin >> l >> r >> x >> y;\n        l--;\n        if (x == y)\n            continue;\n        int sl = l / S;\n        int sr = (r - 1) / S;\n        adjust(pos[x][sl], pos[y][sl], l, r);\n        if (sl != sr)\n            adjust(pos[x][sr], pos[y][sr], l, r);\n        for (int i = sl + 1; i < sr; i++)\n            pos[y][i].splice(pos[y][i].begin(), std::move(pos[x][i]));\n    }\n\n    vi a(N);\n    for (int i = 0; i < M; i++)\n        for (int j = 0; j < H; j++)\n            for (int p : pos[j][i])\n                a[p] = j;\n\n    for (int i = 0; i < N; i++)\n        cout << a[i] << \' \';\n    cout << \'\\n\';\n\n    return 0;\n}\n']",['data structures'],2500
https://codeforces.com//contest/1512/problem/A,A. Spy Detected ,You are given an array a consisting of n n ge 3 positive integers It is known that in this array all the numbers except one are the same for example in the array 4 11 4 4 all numbers except one are equal to 4 Print the index of the element that does not equal others The numbers in the array are numbered from one ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=100010;\nconst int mod=1000000007;\nusing namespace std;\n\nint num[def],pos[def];\n\nint main()\n{\tint _=1,__=1,n,x;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=100;i++)num[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&x);\n\t\t\tnum[x]++;\n\t\t\tpos[x]=i;\n\t\t}\n\t\tfor(int i=1;i<=100;i++)if(num[i]==1){\n\t\t\tprintf(""%d\\n"",pos[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}']","['brute force', 'implementation']",800
https://codeforces.com//contest/1904/problem/E,E. Tree Queries,Santa Hayate has a tree with n nodes Hayate now wants you to answer q queries Each query consists of a node x and k other additional nodes a 1 a 2 ldots a k These k 1 nodes are guaranteed to be all distinct For each query you must find the length of the longest simple path starting at node x dagger after removing nodes a 1 a 2 ldots a k along with all edges connected to at least one of nodes a 1 a 2 ldots a k dagger A simple path of length k starting at node x is a sequence of nodes x u 0 u 1 ldots u k such that there exists a edge between nodes u i 1 and u i for all 1 leq i leq k ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nint n, q;\nvector<int> tr[N];\nvector<int> ask[N], ver[N];\nint ans[N];\n\nint dep[N], fa[N], st[N], ed[N], id[N], cnt;\n\nvoid pdfs(int u, int pre) {\n\tdep[u] = dep[pre] + 1, fa[u] = pre;\n\tst[u] = ++cnt, id[cnt] = u;\n\tfor (int v : tr[u])\n\t\tif (v != pre)\n\t\t\tpdfs(v, u);\n\ted[u] = cnt;\n}\n\ninline bool cmp(int i, int j) { return st[i] < st[j]; }\n\n#define ls(x) (x << 1)\n#define rs(x) (x << 1 | 1)\n\nint val[N << 2], add[N << 2];\n\ninline void pushup(int x) {\n\tval[x] = max(val[ls(x)], val[rs(x)]);\n}\n\nvoid build(int x = 1, int l = 1, int r = n) {\n\tif (l == r) {\n\t\tval[x] = dep[id[l]] - 1;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(x), l, mid);\n\tbuild(rs(x), mid + 1, r);\n\tpushup(x);\n}\n\ninline void pushdown(int x) {\n\tif (add[x]) {\n\t\tval[ls(x)] += add[x];\n\t\tval[rs(x)] += add[x];\n\t\tadd[ls(x)] += add[x];\n\t\tadd[rs(x)] += add[x];\n\t\tadd[x] = 0;\n\t}\n}\n\nvoid update(int L, int R, int v, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\tval[x] += v;\n\t\tadd[x] += v;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tpushdown(x);\n\tif (L <= mid) update(L, R, v, ls(x), l, mid);\n\tif (R > mid) update(L, R, v, rs(x), mid + 1, r);\n\tpushup(x);\n}\n\nint query(int L, int R, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) return val[x];\n\tint mid = (l + r) >> 1, res = 0;\n\tpushdown(x);\n\tif (L <= mid) res = max(res, query(L, R, ls(x), l, mid));\n\tif (R > mid) res = max(res, query(L, R, rs(x), mid + 1, r));\n\treturn res;\n}\n\nint len;\npair<int, int> seg[N << 1];\n\nvoid dfs(int u) {\n\tfor (int i : ask[u]) {\n\t\tlen = 0;\n\t\tfor (int x : ver[i]) {\n\t\t\tif (x == u) seg[++len] = pair<int, int>(1, n);\n\t\t\telse if (st[u] >= st[x] && ed[u] <= ed[x]) {\n\t\t\t\tint y = *(upper_bound(tr[x].begin(), tr[x].end(), u, cmp) - 1);\n\t\t\t\tif (st[y] > 1) seg[++len] = pair<int, int>(1, st[y] - 1);\n\t\t\t\tif (ed[y] < n) seg[++len] = pair<int, int>(ed[y] + 1, n);\n\t\t\t} else {\n\t\t\t\tseg[++len] = pair<int, int>(st[x], ed[x]);\n\t\t\t}\n\t\t}\n\t\tsort(seg + 1, seg + len + 1);\n\t\tint mx = 0;\n\t\tfor (int j = 1; j <= len; ++j) {\n\t\t\tint l, r;\n\t\t\ttie(l, r) = seg[j];\n\t\t\tif (mx + 1 <= l - 1) ans[i] = max(ans[i], query(mx + 1, l - 1));\n\t\t\tmx = max(mx, r);\n\t\t}\n\t\tif (mx + 1 <= n) ans[i] = max(ans[i], query(mx + 1, n));\n\t}\n\tfor (int v : tr[u]) {\n\t\tif (v == fa[u]) continue;\n\t\tupdate(1, n, 1), update(st[v], ed[v], -2);\n\t\tdfs(v);\n\t\tupdate(1, n, -1), update(st[v], ed[v], 2);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> q;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint x, k;\n\t\tcin >> x >> k;\n\t\tver[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) cin >> ver[i][j];\n\t\task[x].push_back(i);\n\t}\n\tpdfs(1, 0);\n\tfor (int i = 1; i <= n; ++i) sort(tr[i].begin(), tr[i].end(), cmp);\n\tbuild();\n\tdfs(1);\n\tfor (int i = 1; i <= q; ++i) cout << ans[i] << '\\n';\n\treturn 0;\n}\n""]","['data structures', 'dfs and similar', 'graphs', 'implementation', 'trees']",2500
https://codeforces.com//contest/1452/problem/B,B. Toy Blocks,You are asked to watch your nephew who likes to play with toy blocks in a strange way He has n boxes and the i th box has a i blocks His game consists of two steps he chooses an arbitrary box i he tries to move blocks from the i th box to other boxes If he can make the same number of blocks in each of n 1 other boxes then he will be happy otherwise will be sad Note that your nephew can only move the blocks from the chosen box to the other boxes he cannot move blocks from the other boxes You don t want to make your nephew sad so you decided to put several extra blocks into some boxes in such a way that no matter which box i he chooses he won t be sad What is the minimum number of extra blocks you need to put ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tint mx = 0;\n\t\tll s = 0;\n\t\tint N; scanf(""%d"", &N);\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tint a; scanf(""%d"", &a);\n\t\t\ts += a; mx = max(mx, a);\n\t\t}\n\n\t\tll k = (s + N - 2) / (N - 1);\n\t\tif(mx > k) printf(""%lld\\n"", (ll)mx * (N - 1) - s);\n\t\telse printf(""%lld\\n"", k * (N - 1) - s);\n\t}\n\treturn 0;\n}']","['binary search', 'greedy', 'math', 'sortings']",1400
https://codeforces.com//contest/1065/problem/B,B. Vasya and Isolated Vertices,Vasya has got an undirected graph consisting of n vertices and m edges This graph doesn t contain any self loops or multiple edges Self loop is an edge connecting a vertex to itself Multiple edges are a pair of edges such that they connect the same pair of vertices Since the graph is undirected the pair of edges 1 2 and 2 1 is considered to be multiple edges Isolated vertex of the graph is a vertex such that there is no edge connecting this vertex to any other vertex Vasya wants to know the minimum and maximum possible number of isolated vertices in an undirected graph consisting of n vertices and m edges ,"['/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << "" is "" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(""%d"", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return (\'a\' <= x && x <= \'z\'); }\ninline bool is_upper(char x) { return (\'A\' <= x && x <= \'Z\'); }\ninline bool is_digit(char x) { return (\'0\' <= x && x <= \'9\'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 1e4 + 239;\n\nint main()\n{\n    #ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    ll n, m;\n    cin >> n >> m;\n    ll l = n;\n    ll r = 0;\n    for (ll x = 0; x <= n; x++)\n    {\n        ll v = (n - x);\n        ll e = m;\n        if (e < (v + 1) / 2LL) continue;\n        if (e > ((v * (v - 1)) / 2LL)) continue;\n        l = min(l, x);\n        r = max(r, x);\n    }\n    cout << l << "" "" << r;\n    return 0;\n}\n']","['constructive algorithms', 'graphs']",1300
https://codeforces.com//contest/1218/problem/A,A. BubbleReactor,You are in charge of the BubbleReactor It consists of N BubbleCores connected with N lines of electrical wiring Each electrical wiring connects two distinct BubbleCores There are no BubbleCores connected with more than one line of electrical wiring Your task is to start the BubbleReactor by starting each BubbleCore In order for a BubbleCore to be started it needs to be receiving power from a directly connected BubbleCore which is already started However you can kick start one BubbleCore manually without needing power It is guaranteed that all BubbleCores can be started Before the BubbleCore boot up procedure its potential is calculated as the number of BubbleCores it can power on the number of inactive BubbleCores which are connected to it directly or with any number of inactive BubbleCores in between itself included Start the BubbleReactor so that the sum of all BubbleCores potentials is maximum ,"['#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<""=""<<h<<""\\n""; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != \',\') { cerr<<*sdbg++; } cerr<<""=""<<h<<"",""; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<"" = ""; FORE(itt, (x)) cerr <<*itt <<"", ""; cerr <<""\\n""; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << ""("" << pair.first << "", "" << pair.second << "")"";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << ""("" << t.st << "", "" << t.nd << "", "" << t.rd << "")""; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\n\nconst int N = 3e4 + 5;\nVI slo[N];\nint vis[N];\nVI stos;\nint on_cyc[N];\nVI cyc;\nvoid Dfs1(int v, int par) {\n  vis[v] = 1;\n  stos.PB(v);\n  for (auto nei : slo[v]) {\n    if (nei == par) { continue; }\n    if (vis[nei]) {\n      FORD (ind, SZ(stos) - 1, 0) {\n        cyc.PB(stos[ind]);\n        on_cyc[stos[ind]] = 1;\n        if (stos[ind] == nei) {\n          throw 1;\n        }\n      }\n    }\n    Dfs1(nei, v);\n  }\n  stos.pop_back();\n}\nint sz[N];\nint sum_szs[N];\nvoid Dfs2(int v) {\n  sz[v] = 1;\n  for (auto nei : slo[v]) {\n    if (on_cyc[nei]) { continue; }\n    if (sz[nei]) { continue; }\n    Dfs2(nei);\n    sum_szs[v] += sum_szs[nei];\n    sz[v] += sz[nei];\n  }\n  sum_szs[v] += sz[v];\n}\nint res[N];\nint n;\nvoid Dfs3(int v) {\n  for (auto nei : slo[v]) {\n    if (on_cyc[nei]) { continue; }\n    if (res[nei]) { continue; }\n    res[nei] = res[v] + n - 2 * sz[nei];\n    Dfs3(nei);\n  }\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  cin>>n;\n  RE (i, n) {\n    int a, b;\n    cin>>a>>b;\n    a++;\n    b++;\n    slo[a].PB(b);\n    slo[b].PB(a);\n  }\n  try {\n    Dfs1(n, 0);\n  } catch (...) {\n  }\n  RE (i, n) {\n    debug(i, on_cyc[i]);\n  }\n  \n  VI szs;\n  int bonus = 0;\n  for (auto v : cyc) {\n    Dfs2(v);\n    bonus += sum_szs[v] - sz[v];\n    szs.PB(sz[v]);\n  }\n  for (auto v : cyc) {\n    szs.PB(sz[v]);\n  }\n  VI dp(SZ(szs));\n  for (auto v : cyc) {\n    szs.PB(sz[v]);\n  }\n  debug(cyc);\n  debug(szs);\n  dp.insert(dp.begin(), 0);\n  VI pref_sum = szs;\n  RE (i, SZ(pref_sum) - 1) {\n    pref_sum[i] += pref_sum[i - 1];\n  }\n  FOR (len, 1, SZ(cyc) - 1) {\n    debug(dp);\n    VI ndp(SZ(dp) - 1);\n    REP (i, SZ(dp) - 1) {\n      ndp[i] = pref_sum[i + len] - pref_sum[i] + max(dp[i], dp[i + 1]);\n    }\n    dp = ndp;\n  }\n  debug(dp);\n  REP (i, SZ(cyc)) {\n    int v = cyc[i];\n    res[v] = dp[i] + bonus + n;\n    Dfs3(v);\n    debug(v, res[v]);\n  }\n  int best = 0;\n  RE (i, n) {\n    maxi(best, res[i]);\n    debug(i, res[i]);\n  }\n  cout<<best<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n']","['dp', 'graphs']",2800
https://codeforces.com//contest/1630/problem/E,E. Expected Components,Given a cyclic array a of size n where a i is the value of a in the i th position Let us define that a permutation of a is equal to another permutation of a if and only if their values are the same for each position i or we can transform them to each other by performing some cyclic rotation Let us define for a cyclic array b its number of components as the number of connected components in a graph where the vertices are the positions of b and we add an edge between each pair of adjacent positions of b with equal values note that in a cyclic array the first and last position are also adjacents Find the expected value of components of a permutation of a if we select it equiprobably over the set of all the different permutations of a ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = (int)1e6 + 7;\nint cnt[N];\nint n;\nint a[N];\nint m, g;\nMint dp[N][2];\n\nint gcd(int x, int y) {\n\treturn (y == 0 ? x : gcd(y, x % y));\n}\n\nFactorials F(N);\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx--;\n\t\tcnt[x]++;\n\t}\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cnt[i] != 0)\n\t\t\ta[m++] = cnt[i];\n\tif (m == 1) {\n\t\tprintf(""1\\n"");\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[i][0] = dp[i][1] = 0;\n\tg = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tg = gcd(g, a[i]);\n\tfor (int x = g; x > 0; x--) {\n\t\tif (g % x) continue;\n\t\tassert(n % x == 0);\n\t\tint z = n / x;\n\t\tassert(z > 1);\n\t\tdp[x][1] = 0;\n\t\tdp[x][0] = F.f[z];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint f = a[i] / x;\n\t\t\tdp[x][1] -= Mint(f) * Mint(f - 1);\n\t\t\tdp[x][0] *= F.fi[f];\n\t\t}\n\t\tdp[x][1] /= z - 1;\n\t\tdp[x][1] += z;\n\t\tdp[x][1] *= dp[x][0];\n\t\tfor (int y = 2 * x; y <= g; y += x) {\n\t\t\tif (g % y) continue;\n\t\t\tdp[x][0] -= dp[y][0];\n\t\t\tdp[x][1] -= dp[y][1] * (y / x);\n\t\t}\n\t\t//eprintf(""x = %d, cnt = %u, sum = %u\\n"", x, dp[x][0].x, dp[x][1].x);\n\t}\n\tMint P = 0, Q = 0;\n\tfor (int x = 1; x <= g; x++) if (g % x == 0) {\n\t\tP += (dp[x][1] * x) * x;\n\t\tQ += dp[x][0] * x;\n\t}\n\tprintf(""%u\\n"", (P / Q).x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['combinatorics', 'math', 'number theory', 'probabilities']",2900
https://codeforces.com//contest/1385/problem/E,E. Directing Edges,You are given a graph consisting of n vertices and m edges It is not guaranteed that the given graph is connected Some edges are already directed and you can t change their direction Other edges are undirected and you have to choose some direction for all these edges You have to direct undirected edges in such a way that the resulting graph is directed and acyclic i e the graph with all edges directed and having no directed cycles Note that you have to direct undirected edges You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200010;\n\nbitset <N> vis;\nvector <int> g[N], h[N], st;\nint t, n, m, type[N], U[N], V[N], comp[N], cur, topo[N];\n\nvoid forw (int u) {\n  vis[u] = 1;\n  for (int v : g[u]) if (!vis[v]) forw(v);\n  st.emplace_back(u);\n}\n\nvoid bacw (int u) {\n  comp[u] = cur;\n  for (int v : h[u]) if (!comp[v]) bacw(v);\n}\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(""%d %d"", &n, &m);\n    for (int i = 1; i <= n; ++i) {\n      g[i].clear(), h[i].clear(), vis[i] = comp[i] = 0;\n    }\n    for (int i = 1; i <= m; ++i) {\n      scanf(""%d %d %d"", type + i, U + i, V + i);\n      if (type[i]) {\n        g[U[i]].emplace_back(V[i]);\n        h[V[i]].emplace_back(U[i]);\n      }\n    }\n    st.clear();\n    for (int i = 1; i <= n; ++i) {\n      if (!vis[i]) forw(i);\n    }\n    reverse(st.begin(), st.end());\n    cur = 0;\n    for (int u : st) {\n      if (!comp[u]) ++cur, bacw(u); \n    }\n    bool cyc = 0;\n    for (int i = 1; i <= n; ++i) {\n      for (int j : g[i]) if (comp[i] == comp[j]) {\n        cyc = 1;\n        break;\n      }\n    }\n    if (cyc) {\n      puts(""NO"");\n      continue;\n    }\n    puts(""YES"");\n    for (int i = 0; i < n; ++i) topo[st[i]] = i;\n    for (int i = 1; i <= m; ++i) {\n      int u = U[i], v = V[i];\n      if (!type[i] and topo[u] > topo[v]) swap(u, v);\n      printf(""%d %d\\n"", u, v);\n    }\n  }\n  return 0;\n}\n\n']","['constructive algorithms', 'dfs and similar', 'graphs']",2000
https://codeforces.com//contest/463/problem/D,D. Gargari and Permutations,Gargari got bored to play with the bishops and now after solving the problem about them he is trying to do math homework In a math book he have found permutations Each of them consists of numbers in some order Now he should find the length of the longest common subsequence of these permutations Can you help Gargari You can read about longest common subsequence there ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <functional>\n\ntypedef long long lld;\n\nconst int N = 1000 + 5;\n\nint A[6][N],n,m,tmp[N],dp[N],pos[6][N];\n\nint main() {\n    scanf(""%d%d"",&n,&m);\n    for (int i = 1; i <= m; ++ i) {\n        for (int j = 1; j <= n; ++ j) {\n            scanf(""%d"",&A[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; ++ i) {\n        tmp[A[1][i]] = i;\n    }\n    for (int i = 2; i <= m; ++ i) {\n        for (int j = 1; j <= n; ++ j) {\n            A[i][j] = tmp[A[i][j]];\n            pos[i][A[i][j]] = j;\n        }\n    }\n    memset(dp,0,sizeof(dp));\n    for (int i = 0; i < n; ++ i) {\n        for (int j = i+1; j <= n; ++ j) {\n            if (dp[j]>=dp[i]+1) continue;\n            bool flag = true;\n            for (int k = 2; k <= m; ++ k) {\n                if (pos[k][i] > pos[k][j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                dp[j] = dp[i] + 1;\n            }\n        }\n    }\n    int answer = 0;\n    for (int i = 1; i <= n; ++ i) {\n        answer = std::max(answer,dp[i]);\n    }\n    printf(""%d\\n"",answer);\n    return 0;\n}']","['dfs and similar', 'dp', 'graphs', 'implementation']",1900
https://codeforces.com//contest/493/problem/E,E. Vasya and Polynomial,Vasya is studying in the last class of school and soon he will take exams He decided to study polynomials is a function Numbers are called of a polynomial non negative integer is called a of a polynomial Vasya has made a bet with his friends that he can solve any problem with polynomials They suggested him the problem Determine how many polynomials exist with coefficients so that and where and are given positive integers Vasya does not like losing bets but he has no idea how to solve this task so please help him to solve the problem ,"[""#include <cstdio>\n#include <map>\ntypedef long long LL;\ntypedef std::pair<LL, LL> node;\nconst int mod=1000000007;\n\nLL n, a, b;\ninline LL getint();\ninline void putint(int);\n\nstd::map<node, int> s;\nint solve(LL, LL);\n\nint main()\n{\n\tn=getint(), a=getint(), b=getint();\n\tif (n==1 && a==1)\n\t{\n\t\tif (b!=1) putint(0);\n\t\telse putchar('i'), putchar('n'), putchar('f'), putchar('\\n');\n\t}\n\telse if (n==a && a==b)\n\t\tputint(2);\n\telse\n\t\tputint(solve(a, b));\n\n\treturn 0;\n}\ninline LL getint()\n{\n\tregister LL num=0;\n\tregister char ch;\n\tdo ch=getchar(); while (ch<'0' || ch>'9');\n\tdo num=num*10+ch-'0', ch=getchar(); while (ch>='0' && ch<='9');\n\treturn num;\n}\ninline void putint(int num)\n{\n\tchar stack[11];\n\tregister int top=0;\n\tif (num==0) stack[top=1]='0';\n\tfor ( ;num;num/=10) stack[++top]=num%10+'0';\n\tfor ( ;top;top--) putchar(stack[top]);\n\tputchar('\\n');\n}\nint solve(LL x, LL y)\n{\n\tif (!x && !y) return 1;\n\tif (!x || !y) return 0;\n\tif (s.count(node(x, y))) return s[node(x, y)];\n\tint & t=s[node(x, y)];\n\tt=0;\n\tfor (LL i=y%a;i<=x;i+=a) if ((x-i)%n==0)\n\t\tt=(t+solve((x-i)/n, (y-i)/a))%mod;\n\treturn t;\n}\n""]",['math'],2800
https://codeforces.com//contest/1619/problem/H,H. Permutation and Queries,You are given a permutation p of n elements A permutation of n elements is an array of length n containing each integer from 1 to n exactly once For example 1 2 3 and 4 3 5 1 2 are permutations but 1 2 4 and 4 3 2 1 2 are not permutations You should perform q queries There are two types of queries 1 x y swap p x and p y 2 i k print the number that i will become if we assign i p i k times ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <utility>\n#include <cmath>\n#include <numeric>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pb push_back\n#define endl ""\\n""\n#define all(x) x.begin(), x.end()\nconst int M = 200007;\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst double pi = acos(-1);\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint n, q, p[M], go[M], pref[M];\n\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> n >> q;\n    int block = sqrt(n);\n    for(int i = 1; i <= n; ++i) cin >> p[i];\n    for(int i = 1; i <= n; ++i){\n         pref[p[i]] = i;\n         int x = i;\n         for(int j = 0; j < block; ++j) x = p[x];\n         go[i] = x;\n    }\n    while(q--){\n        int t, x, y;\n        cin >> t >> x >> y;\n        if(t == 1){\n            swap(pref[p[x]], pref[p[y]]);\n            swap(p[x], p[y]);\n            int cur = x;\n            for(int i = 0; i < block; ++i) cur = p[cur];\n            for(int i = 0; i < block; ++i){\n                go[x] = cur;\n                cur = pref[cur];\n                x = pref[x];\n            }\n            cur = y;\n            for(int i = 0; i < block; ++i) cur = p[cur];\n            for(int i = 0; i < block; ++i){\n                go[y] = cur;\n                cur = pref[cur];\n                y = pref[y];\n            }\n        }\n        else{\n            while(y >= block){\n                y -= block;\n                x = go[x];\n            }\n            while(y--) x = p[x];\n            cout << x << endl;\n        }\n    }\n    return 0;\n}\n']","['brute force', 'data structures', 'divide and conquer', 'two pointers']",2400
https://codeforces.com//contest/930/problem/E,E. Coins Exhibition,Arkady and Kirill visited an exhibition of rare coins The coins were located in a row and enumerated from left to right from to each coin either was laid with its obverse front side up or with its reverse back side up Arkady and Kirill made some photos of the coins each photo contained a segment of neighboring coins Akrady is interested in obverses so on each photo made by him there is at least one coin with obverse side up On the contrary Kirill is interested in reverses so on each photo made by him there is at least one coin with its reverse side up The photos are lost now but Arkady and Kirill still remember the bounds of the segments of coins each photo contained Given this information compute the remainder of division by of the number of ways to choose the upper side of each coin in such a way that on each Arkady s photo there is at least one coin with obverse side up and on each Kirill s photo there is at least one coin with reverse side up ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 600001;\n\nconst ll MOD = static_cast<ll>(1e9 + 7);\n\nll pw(ll a, ll b) {\n    if (!b) {\n        return 1;\n    }\n\n    ll v = pw(a, b / 2);\n    v = (v * v) % MOD;\n\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\n\nvoid add(ll& x, ll y) {\n    x = (x + y) % MOD;\n}\n\nvoid sub(ll& x, ll y) {\n    x -= y;\n    x %= MOD;\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\nvector<ll> xs;\n\n\nint la[MAXN];\nint ra[MAXN];\nint lb[MAXN];\nint rb[MAXN];\n\nll f[2][MAXN];\nll tot[2];\nint req[2][MAXN];\nint p[2];\n\nint gt(int x) {\n    return lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n}\n\nvoid ad(int x, int y, ll z) {\n    add(tot[x], z);\n    add(f[x][y], z);\n}\n\nint main() {\n#ifdef BZ\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int k, n, m;\n    cin >> k >> n >> m;\n    xs = { 0, k };\n    for (int i = 0; i < n; ++i) {\n        cin >> la[i] >> ra[i];\n        xs.push_back(--la[i]);\n        xs.push_back(ra[i]);\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        cin >> lb[i] >> rb[i];\n        xs.push_back(--lb[i]);\n        xs.push_back(rb[i]);\n    }\n\n    xs.push_back(-1);\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    int c = xs.size() - 1;\n\n    ad(0, 0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        int& x = req[0][gt(ra[i])];\n        x = max(x, gt(la[i]));\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int& x = req[1][gt(rb[i])];\n        x = max(x, gt(lb[i]));\n    }\n\n    for (int i = 1; i < c; ++i) {\n        ll good = pw(2, xs[i + 1] - xs[i]);\n        ll t[2] = { tot[0], tot[1] };\n\n        good -= 2;\n        if (good < 0) {\n            good += MOD;\n        }\n\n        good = (good * (t[0] + t[1])) % MOD;\n        ad(0, i, good);\n\n        for (int j = 0; j < 2; ++j) {\n            int rj = j ^ 1;\n            ad(j, i - 1, t[rj]);\n\n            while (p[j] < req[rj][i + 1]) {\n                sub(tot[j], f[j][p[j]++]);\n            }\n        }\n    }\n\n    cout << (tot[0] + tot[1]) % MOD;\n}']","['data structures', 'dp', 'math']",2900
https://codeforces.com//contest/1797/problem/A,A. Li Hua and Maze,There is a rectangular maze of size n times m Denote r c as the cell on the r th row from the top and the c th column from the left Two cells are if they share an edge A is a sequence of empty cells Each cell is initially empty Li Hua can choose some cells except x 1 y 1 and x 2 y 2 and place an obstacle in each of them He wants to know the minimum number of obstacles needed to be placed so that there isn t a from x 1 y 1 to x 2 y 2 Suppose you were Li Hua please solve this problem ,"[""// LUOGU_RID: 110066126\n#include<bits/stdc++.h>\n#define int long long\nconst int N=1e5+5,M=305;\nusing namespace std;\nint n,m,x,y,xx,yy,sum1,sum2;\nvoid solve()\n{\n\tcin>>n>>m;sum1=4;sum2=4;\n\tcin>>x>>y>>xx>>yy;\n\tif(x==1||x==n)sum1--;\n\tif(y==1||y==m)sum1--;\n\tif(xx==1||xx==n)sum2--;\n\tif(yy==1||yy==m)sum2--;\n\tcout<<min(sum1,sum2)<<'\\n';\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}""]","['constructive algorithms', 'flows', 'graphs', 'greedy', 'implementation']",800
https://codeforces.com//contest/804/problem/B,B. Minimum number of steps,We have a string of letters and We want to perform some operations on it On each step we choose one of substrings in the string and replace it with the string If we have no as a substring our job is done Print the minimum number of steps we should perform to make our job done modulo The string appears as a substring if there is a letter right after the letter somewhere in the string ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n\n#include <assert.h>\n#include <type_traits>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + "" in line "" + std::to_string(__LINE__) + "" in "" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n\n\n\ntemplate <typename T, typename = std::true_type>\nstruct IdentityHelper;\n\ntemplate <typename T>\nstruct IdentityHelper<T, typename std::is_arithmetic<T>::type> {\n\tstatic T identity() {\n\t\treturn 1;\n\t}\n};\n\ntemplate <typename T>\nT identity() {\n\treturn IdentityHelper<T>::identity();\n}\n\n\n\n/**\n* ax + by = result\n*/\ntemplate <typename T>\nT extendedGcd(T a, T b, T& x, T& y) {\n\tif (a == 0) {\n\t\tx = 0;\n\t\ty = 1;\n\t\treturn b;\n\t}\n\tT d = extendedGcd(b % a, a, y, x);\n\tx -= (b / a) * y;\n\treturn d;\n}\n\ntemplate <typename T>\nclass Zn {\npublic:\n\tZn(): value(0) {\n\t}\n\n\t/**\n\t* Instead of ctor, to allow not to normalize in ctor\n\t*/\n\tstatic Zn valueOf(int value) {\n\t\tint x = value % mod();\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn valueOf(long long value) {\n\t\tint x = static_cast<int>(value % mod());\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn rawValueOf(int value) {\n\t\tSPCPPL_ASSERT(value >= 0 && value < mod());\n\t\treturn Zn(value);\n\t}\n\n\tZn& operator=(int rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator=(long long rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(const Zn& rhs) {\n\t\tvalue += rhs.value;\n\t\tif (value >= mod()) {\n\t\t\tvalue -= mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator+=(int rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(long long rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(const Zn& rhs) {\n\t\tvalue -= rhs.value;\n\t\tif (value < 0) {\n\t\t\tvalue += mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator-=(int rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(long long rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(const Zn& rhs) {\n\t\tlong long result = static_cast<long long>(value) * static_cast<long long>(rhs.value);\n\t\tvalue = static_cast<int>(result % mod());\n\t\treturn *this;\n\t}\n\n\tZn& operator*=(int rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(long long rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn operator-() const {\n\t\tif (value == 0) {\n\t\t\treturn *this;\n\t\t}\n\t\telse {\n\t\t\treturn Zn(mod() - value);\n\t\t}\n\t}\n\n\tZn& operator/=(const Zn& rhs) {\n\t\treturn *this *= rhs.inversed();\n\t}\n\n\tZn& operator/=(int rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator/=(long long rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tbool operator==(const Zn& rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tZn inversed() const {\n\t\tSPCPPL_ASSERT(value != 0);\n\n\t\tint x, y;\n\t\tint gcd = extendedGcd(value, mod(), x, y);\n\t\t(void) gcd;\n\t\tSPCPPL_ASSERT(gcd == 1);\n\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\ttemplate <typename U>\n\tfriend std::ostream& operator<<(std::ostream&, const Zn<U>& zn);\n\n\ttemplate <typename U>\n\tfriend std::istream& operator>>(std::istream&, Zn<U>& zn);\n\n\tint intValue() const {\n\t\treturn value;\n\t}\n\nprivate:\n\t/**\n\t* No normalization performed\n\t*/\n\texplicit Zn(int value): value(value) {\n\t}\n\n\tint value;\n\n\tconstexpr static int mod() {\n\t\treturn T::value;\n\t}\n\n\ttemplate <int N = T::value>\n\tstatic constexpr bool positive_or_runtime(int) {\n\t\treturn N > 0;\n\t}\n\tstatic constexpr bool positive_or_runtime(...) {\n\t\treturn true;\n\t}\n\tstatic_assert(\n\t\t\tstd::is_same<typename std::decay<decltype(T::value)>::type, int>::value,\n\t\t\t""T::value must be int""\n\t);\n\tstatic_assert(positive_or_runtime(0), ""Mod has to be positive integer"");\n};\n\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, int rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(int lhs, const Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, long long rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(long long lhs, Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, int rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(int lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, long long rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(long long rhs, const Zn<T>& lhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(int lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(long long lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(int lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(long long lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(long long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Zn<T>& zn) {\n\treturn stream << zn.value;\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Zn<T>& zn) {\n\tlong long value;\n\tstream >> value;\n\tzn.value = static_cast<int>(value % T::value);\n\treturn stream;\n}\n\ntemplate <typename T>\nstruct IdentityHelper<Zn<T>> {\n\tstatic Zn<T> identity() {\n\t\treturn Zn<T>::valueOf(1);\n\t}\n};\n\ntemplate <int m>\nusing ZnConst = Zn<std::integral_constant<int, m>>;\n\n\nusing namespace std;\n\nclass TaskB {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tstring s;\n\t\tin >> s;\n\t\tusing Z = ZnConst<1000000007>;\n\n\t\tZ pwr = Z::rawValueOf(1);\n\n\t\tZ ans;\n\t\tfor (char c: s) {\n\t\t\tif (c == \'a\') {\n\t\t\t\tpwr *= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += pwr - 1;\n\t\t\t}\n\t\t}\n\n\t\tout << ans << ""\\n"";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskB solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n']","['combinatorics', 'greedy', 'implementation', 'math']",1400
https://codeforces.com//contest/1849/problem/E,E. Max to the Right of Min,You are given a permutation p of length n an array consisting of integers from 1 to n all distinct Let p l r denote a subarray an array formed by writing down elements from index l to index r inclusive Let mathit maxpos l r denote the of the maximum element on p l r Similarly let mathit minpos l r denote the index of the minimum element on it Calculate the number of subarrays p l r such that mathit maxpos l r mathit minpos l r ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n    }\n    \n    std::vector<int> lmin(n, -1), rmin(n, n), lmax(n, -1), rmax(n, n);\n    std::vector<int> smin, smax;\n    for (int i = 0; i < n; i++) {\n        while (!smin.empty() && p[i] < p[smin.back()]) {\n            rmin[smin.back()] = i;\n            smin.pop_back();\n        }\n        if (!smin.empty()) {\n            lmin[i] = smin.back();\n        }\n        smin.push_back(i);\n        \n        while (!smax.empty() && p[i] > p[smax.back()]) {\n            rmax[smax.back()] = i;\n            smax.pop_back();\n        }\n        if (!smax.empty()) {\n            lmax[i] = smax.back();\n        }\n        smax.push_back(i);\n    }\n    \n    i64 ans = 0;\n    std::vector<int> s{-1};\n    std::vector<i64> sum{0LL};\n    for (int i = 0; i < n; i++) {\n        while (s.size() > 1 && p[i] < p[s.back()]) {\n            rmin[s.back()] = i;\n            s.pop_back();\n            sum.pop_back();\n        }\n        int l = std::upper_bound(s.begin(), s.end(), lmax[i]) - s.begin();\n        if (l < s.size()) {\n            ans += 1LL * (s[l] - std::max(s[l - 1], lmax[i]))\n                * (std::min(rmax[i], rmin[s[l]]) - i);\n            l++;\n            int m = std::partition_point(s.begin() + l, s.end(), [&](int x) {\n                return rmin[x] > rmax[i];\n            }) - s.begin();\n            ans += 1LL * (s[m - 1] - s[l - 1]) * rmax[i];\n            ans -= 1LL * (s.back() - s[l - 1]) * i;\n            ans += sum.back() - sum[m - 1];\n        }\n        sum.push_back(sum.back() + 1LL * (i - s.back()) * rmin[i]);\n        s.push_back(i);\n    }\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['binary search', 'data structures', 'divide and conquer', 'dp', 'dsu', 'two pointers']",2300
https://codeforces.com//contest/1028/problem/A,A. Find Square,Consider a table of size n times m initially fully white Rows are numbered 1 through n from top to bottom columns 1 through m from left to right Some square inside the table with side length was painted black Find the center of this square ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint n, m;\nstring s[200];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> s[i];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tif (s[i][j] == \'B\')\n\t\t\t\t++cnt;\n\tint k = 0;\n\twhile (k * k < cnt)\n\t\t++k;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (s[i][j] == \'B\') {\n\t\t\t\tcout << i + 1 + (k - 1) / 2 << "" "" << j + 1 + (k - 1) / 2 << ""\\n"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tassert(false);\n\treturn 0;\n}\n\n\n']",['implementation'],800
https://codeforces.com//contest/1077/problem/F1,F1. Pictures with Kittens  easy version ,Vova likes pictures with kittens The news feed in the social network he uses can be represented as an array of n consecutive pictures with kittens of course Vova likes all these pictures but some are more beautiful than the others the i th picture has beauty a i Vova wants to repost exactly x pictures in such a way that each segment of the news feed of at least k consecutive pictures has at least one picture reposted by Vova the sum of beauty values of reposted pictures is maximum possible For example if k 1 then Vova has to repost all the pictures in the news feed If k 2 then Vova can skip some pictures but between every pair of consecutive pictures Vova has to repost at least one of them Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above or say that there is no way to satisfy all conditions ,"[""#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,k,a[N];\nll f[N][N];\nint main()\n{\n\tn=read(),k=read(),m=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tmemset(f,200,sizeof(f));\n\tf[0][0]=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tfor (int x=i-1;x>=max(0,i-k);x--)\n\t\t\tf[i][j]=max(f[i][j],f[x][j-1]+a[i]);\n\t\t}\n\t}\n\tfor (int i=n-1;i>=max(0,n-k+1);i--) f[n][m]=max(f[n][m],f[i][m]);\n\tif (f[n][m]<0) cout<<-1;\n\telse cout<<f[n][m];\n\treturn 0;\n}\n""]",['dp'],1900
https://codeforces.com//contest/284/problem/B,B. Cows and Poker Game,There are cows playing poker at a table For the current betting phase each player s status is either or and does not change throughout the phase To increase the suspense a player whose current status is not may show his her hand to the table However so as not to affect any betting decisions he she may only do so if all other players have a status of either or The player s own status may be either or Find the number of cows that can currently show their hands without affecting any betting decisions ,"['#include <cstdio>\nconst\tint\tmaxn = 220000;\nchar\ta[maxn];\nint\tn, f1, f2, f3;\nint\tmain()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", a);\n\tf1 = f2 = f3 = 0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tswitch(a[i])\n\t\t{\n\t\t\tcase \'A\': f1 ++; break;\n\t\t\tcase \'F\': f2 ++; break;\n\t\t\tcase \'I\': f3 ++; break;\n\t\t}\n\t}\n\tif (f3 > 1) {printf(""0\\n""); return 0;}\n\tif (f3 == 1) {printf(""1\\n""); return 0;}\n\tprintf(""%d\\n"", f1);\n\treturn 0;\n}']","['brute force', 'implementation']",1000
https://codeforces.com//contest/1667/problem/B,B. Optimal Partition,You are given an array a consisting of n integers You should divide a into continuous non empty subarrays there are 2 n 1 ways to do that Let s a l a l 1 ldots a r The value of a subarray a l a l 1 ldots a r is r l 1 if s 0 0 if s 0 r l 1 if s 0 What is the maximum sum of values you can get with a partition ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, dp[500005];\nLL a[500005];\nvector<LL> val;\nstruct fwt\n{\n\tint m, val[500005];\n\tvoid clear(int cm)\n\t{\n\t\tm = cm;\n\t\trep1(i, m) val[i] = -INF; \n\t}\n\tvoid ins(int id, int x)\n\t{\n\t\tfor(id ++; id <= m; id += id & -id) val[id] = max(val[id], x);\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = -INF;\n\t\tfor(id ++; id > 0; id -= id & -id) ret = max(ret, val[id]);\n\t\treturn ret;\n\t}\n}t0, t1;\nvoid solve()\n{\n\tscanf(""%d"", &n);\n\trep1(i, n) scanf(""%lld"", &a[i]);\n\trep1(i, n) a[i] += a[i - 1];\n\tval.clear();\n\trep(i, n + 1) val.push_back(a[i]);\n\tsort(val.begin(), val.end());\n\tval.resize(unique(val.begin(), val.end()) - val.begin());\n\t\n\tt0.clear(n + 1);\n\tt1.clear(n + 1);\n\trep(i, n + 1) {\n\t\tint cur = lower_bound(val.begin(), val.end(), a[i]) - val.begin();\n\t\tif(i == 0) dp[i] = 0;\n\t\telse dp[i] = max(dp[i - 1] - 1, max(t0.query(cur), t1.query(cur) + i));\n\t\tt0.ins(cur, dp[i]);\n\t\tt1.ins(cur + 1, dp[i] - i);\n\t}\n\tprintf(""%d\\n"", dp[n]);\n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']","['data structures', 'dp']",2100
https://codeforces.com//contest/1859/problem/D,D. Andrey and Escape from Capygrad,An incident occurred in Capygrad the capital of Tyagoland where all the capybaras in the city went crazy and started throwing mandarins Andrey was forced to escape from the city as far as possible using portals Tyagoland is represented by a number line and the city of Capygrad is located at point 0 There are n portals all over Tyagoland each of which is characterised by four integers l i r i a i and b i 1 le l i le a i le b i le r i le 10 9 Note that the segment a i b i in the segment l i r i If Andrey is on the segment l i r i then the portal can teleport him to any point on the segment a i b i Andrey has a pass that allows him to use the portals an unlimited number of times Andrey thinks that the point x is on the segment l r if the inequality l le x le r is satisfied Andrey has q options for where to start his escape each option is characterized by a single integer x i the starting position of the escape He wants to escape from Capygrad as far as possible to the point with the maximum possible coordinate Help Andrey determine how far he could escape from Capygrad starting at each of the q positions ,"['#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt"")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include""dbg.h""\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return\'\\n\';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between \'\\n\'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<\'0\'||c>\'9\'){if(c==\'-\')f*=-1;c=getchar();}x=0;while(c>=\'0\'&&c<=\'9\'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<\'0\'||c>\'9\')&&c!=\'-\'&&c!=\'.\'){if(c==\'-\')f*=-1;c=getchar();}while(c>=\'0\'&&c<=\'9\'&&c!=\'.\')x=x*10+(c^48),c=getchar();if(c==\'.\')c=getchar();else return x*=f,*this;while(c>=\'0\'&&c<=\'9\')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str[len++]=c,c=getchar();str[len]=\'\\0\';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl=\'\\n\';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<\'\\n\';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar(\'0\'),*this;if(x<0)putchar(\'-\'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar(\'-\'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;putchar(\'.\');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nstruct node\n{\n\tint l,r,a,b;\n};\nbool cmp(node a,node b)\n{\n\treturn a.a<b.a;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.l<b.l;\n}\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>ss;\n\t\tvector<node>a(n);\n\t\tfor(int x=0;x<n;x++)\n\t\t\tcin>>a[x].l>>a[x].r>>a[x].a>>a[x].b,ss.push_back(a[x].l),ss.push_back(a[x].r),ss.push_back(a[x].a),ss.push_back(a[x].b);\n\t\tint q;\n\t\tcin>>q;\n\t\tvector<int>ques(q);\n\t\tfor(int x=0;x<q;x++)\n\t\t\tcin>>ques[x],ss.push_back(ques[x]);\n\t\tsort(a.begin(),a.end(),cmp);\n\t\tvector<node>b;\n\t\tfor(int x=0;x<n;x++)\n\t\t\tif(b.empty()||a[x].a>b.back().b)b.push_back(a[x]);\n\t\t\telse b.back().b=max(b.back().b,a[x].b),b.back().l=min(b.back().l,a[x].l),b.back().r=max(b.back().r,a[x].r);\n\t\treverse(b.begin(),b.end());\n\t\tmultiset<int>st;\n\t\tpriority_queue<pair<int,int>>pq;\n\t\tset<pair<int,int>>ans;\n\t\tans.insert({-10000000000,-10000000000});\n\t\tfor(auto q:b)\n\t\t{\n\t\t\twhile(!pq.empty()&&pq.top().first>q.b)st.erase(st.find(pq.top().second)),pq.pop();\n\t\t\tint res=q.b;\n\t\t\tif(!st.empty())res=max(res,*st.rbegin());\n\t\t\tst.insert(res);\n\t\t\tpq.push({q.l,res});\n\t\t\tans.insert({q.l,res});\n\t\t}\n\t\tfor(auto q:ques)\n\t\t\tcout<<max(q,prev(ans.upper_bound({q,10000000000}))->second)<<\' \';cout<<endl;\n\t}\n}']","['binary search', 'data structures', 'dp', 'dsu', 'greedy', 'sortings']",1800
https://codeforces.com//contest/543/problem/A,A. Writing Code,Programmers working on a large project have just received a task to write exactly lines of code There are programmers working on a project the th of them makes exactly bugs in every line of code that he writes Let s call a sequence of non negative integers a if The programmers follow the plan like that in the beginning the first programmer writes the first lines of the given task then the second programmer writes more lines of the given task and so on In the end the last programmer writes the remaining lines of the code Let s call a plan if all the written lines of the task contain at most bugs in total Your task is to determine how many distinct plans are there As the number of plans can be large print the remainder of this number modulo given positive integer ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(""rdtsc"" : ""=A""(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME ""text""\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nint MOD;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= MOD) {\n    x -= MOD;\n  }\n}\n\nint n, m, b;\n\nconst int maxn = 500 + 10;\nint a[maxn];\n\nbool read() {\n  if (scanf(""%d%d%d%d"", &n, &m, &b, &MOD) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(""%d"", &a[i]);\n  }\n  return 1;\n}\n\nint d[maxn][maxn];\n\nvoid solve() {\n  for (int sv = 0; sv <= m; ++sv) {\n    for (int sva = 0; sva <= b; ++sva) {\n      d[sv][sva] = 0;\n    }\n  }\n  d[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int sv = 0; sv < m; ++sv) {\n      for (int sva = 0; sva <= b; ++sva) {\n        int nsv = sv + 1;\n        int nsva = sva + a[i];\n        if (nsva > b) {\n          break;\n        }\n        add(d[nsv][nsva], d[sv][sva]);\n      }\n    }\n  }\n  int res = 0;\n  for (int sva = 0; sva <= b; ++sva) {\n    add(res, d[m][sva]);\n  }\n  printf(""%d\\n"", res);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME"".out"", ""w"", stdout);\n  assert(freopen(TASKNAME"".in"", ""r"", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""%.18lf\\n"", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']",['dp'],1800
https://codeforces.com//contest/1207/problem/G,G. Indie Album,Mishka s favourite experimental indie band has recently dropped a new album Songs of that album share one gimmick Each name s i is one of the following types 1 c a single lowercase Latin letter 2 j c name s j 1 le j i with a single lowercase Latin letter appended to its end Songs are numbered from 1 to n It s guaranteed that the first song is always of type 1 Vova is rather interested in the new album but he really doesn t have the time to listen to it entirely Thus he asks Mishka some questions about it to determine if some song is worth listening to Questions have the following format i t count the number of occurrences of string t in s i the name of the i th song of the album as a continuous substring t consists only of lowercase Latin letters Mishka doesn t question the purpose of that information yet he struggles to provide it Can you please help Mishka answer all Vova s questions ,"['#include <bits/stdc++.h>\nusing namespace std;\nnamespace treeArr {\n    int sum[400010];\n    inline void add(int x, int k) {\n        for(; x <= 400000; x += x & -x) sum[x] += k;\n    }\n    inline int get(int x) {\n        int ans = 0;\n        for(; x; x -= x & -x) ans += sum[x];\n        return ans;\n    }\n}\nnamespace AC {\n    int son[400010][26], cnt;\n    int fail[400010];\n    vector<int> e[400010];\n    int dfn[400010], sze[400010];\n    int dfsnow;\n    inline int add(char *s) {\n        int now = 0;\n        for(int i = 0, n = strlen(s); i < n; i++) {\n            if(son[now][s[i] - \'a\'] == 0) son[now][s[i] - \'a\'] = ++cnt;\n            now = son[now][s[i] - \'a\'];\n        }\n        return now;\n    }\n    inline int getans(int id) {\n        return treeArr :: get(dfn[id] + sze[id] - 1) - treeArr :: get(dfn[id] - 1);\n    }\n    inline void dfs(int now) {\n        dfn[now] = ++dfsnow;\n        sze[now] = 1;\n        for(auto i : e[now]) dfs(i), sze[now] += sze[i];\n    }\n    inline void build() {\n        queue<int> q;\n        for(int i = 0; i < 26; i++) if(son[0][i]) q.push(son[0][i]);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            e[fail[now]].push_back(now);\n            for(int i = 0; i < 26; i++) {\n                if(son[now][i]) fail[son[now][i]] = son[fail[now]][i], q.push(son[now][i]);\n                else son[now][i] = son[fail[now]][i];\n            }\n        }\n        dfs(0);\n    }\n    inline int f(int x, int k) {\n        return son[x][k - \'a\'];\n    }\n}\nchar c[400010];\nint opt[400010];\nvector<int> son[400010];\nint ans[400010];\nvector<pair<int, int> > que[400010];\nvoid dfs(int now, int nowd) {\n    nowd = AC :: f(nowd, c[now]);\n    treeArr :: add(AC :: dfn[nowd], 1);\n    for(auto i : son[now]) dfs(i, nowd);\n    for(auto i : que[now]) {\n        ans[i.second] = AC :: getans(i.first);\n    }\n    treeArr :: add(AC :: dfn[nowd], -1);\n}\nchar s[400010];\nint main() {\n    int n;\n    scanf(""%d"", &n);\n    for(int i = 1, fa; i <= n; i++) {\n        scanf(""%d"", opt + i);\n        if(opt[i] == 2) scanf(""%d"", &fa), son[fa].push_back(i);\n        scanf(""%s"", c + i);\n    }\n    int m;\n    scanf(""%d"", &m);\n    for(int i = 1; i <= m; i++) {\n        int id;\n        scanf(""%d%s"", &id, s);\n        que[id].push_back(make_pair(AC :: add(s), i));\n    }\n    AC :: build();\n    for(int i = 1; i <= n; i++) if(opt[i] == 1) dfs(i, 0);\n    for(int i = 1; i <= m; i++) printf(""%d\\n"", ans[i]);\n    return 0;\n}']","['data structures', 'dfs and similar', 'hashing', 'string suffix structures', 'strings', 'trees']",2700
https://codeforces.com//contest/463/problem/C,C. Gargari and Bishops,Gargari is jealous that his friend Caisa won the game from the previous problem He wants to prove that he is a genius He has a chessboard Each cell of the chessboard has a number written on it Gargari wants to place two bishops on the chessboard in such a way that there is no cell that is attacked by both of them Consider a cell with number written on it if this cell is attacked by one of the bishops Gargari will get dollars for it Tell Gargari how to place bishops on the chessboard to get maximum amount of money We assume a cell is attacked by a bishop if the cell is located on the same diagonal with the bishop the cell where the bishop is also considered attacked by it ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <functional>\n\ntypedef long long lld;\nconst int N = 2000 + 5;\nlld l[N][N],r[N][N],u[N][N],d[N][N],A[N][N];\nint n;\n\nint main() {\n\tscanf(""%d"",&n);\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tscanf(""%I64d"",&A[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tl[i][j] = l[i-1][j-1] + A[i][j];\n\t\t\tr[i][j] = r[i-1][j+1] + A[i][j];\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; -- i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tu[i][j] = u[i+1][j-1] + A[i][j];\n\t\t\td[i][j] = d[i+1][j+1] + A[i][j];\n\t\t}\n\t}\n\tlld sum[2] = {-1,-1};\n\tint x[2],y[2];\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tint c = (i+j&1);\n\t\t\tlld value = l[i][j] + r[i][j] + u[i][j] + d[i][j] - 3*A[i][j];\n\t\t\tif (sum[c] < value) {\n\t\t\t\tsum[c] = value;\n\t\t\t\tx[c] = i;\n\t\t\t\ty[c] = j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%I64d\\n"",sum[0]+sum[1]);\n\tprintf(""%d %d %d %d\\n"",x[0],y[0],x[1],y[1]);\n\treturn 0;\n}\n']","['greedy', 'hashing', 'implementation']",1900
https://codeforces.com//contest/1120/problem/D,D. Power Tree,You are given a rooted tree with n vertices the root of the tree is the vertex 1 Each vertex has some non negative price A leaf of the tree is a non root vertex that has degree 1 Arkady and Vasily play a strange game on the tree The game consists of three stages On the first stage Arkady buys some non empty set of vertices of the tree On the second stage Vasily puts some integers into all leaves of the tree On the third stage Arkady can perform several possibly none operations of the following kind choose some vertex v he bought on the first stage and some integer x and then add x to all integers in the leaves in the subtree of v The integer x can be positive negative of zero A leaf a is in the subtree of a vertex b if and only if the simple path between a and the root goes through b Arkady s task is to make all integers in the leaves equal to zero What is the minimum total cost s he has to pay on the first stage to guarantee his own win independently of the integers Vasily puts on the second stage Also we ask you to find all such vertices that there is an optimal i e with cost s set of vertices containing this one such that Arkady can guarantee his own win buying this set on the first stage ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=200*1007;\nconst ll inf=1e18;\n\nint n;\n\nvi graf[nax];\nll tab[nax];\n\nll dpwsz[nax];\nll dpbez[nax];\n\nint lis[nax];\n\nvi opt;\n\nvoid minuj(ll &a, ll b)\n{\n\ta=min(a, b);\n}\n\nvoid maxuj(ll &a, ll b)\n{\n\ta=max(a, b);\n}\n\nvoid dfs1(int v, int oj)\n{\n\tfor (int &i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t{\n\t\t\tswap(i, graf[v].back());\n\t\t\tgraf[v].pop_back();\n\t\t\tbreak;\n\t\t}\n\t}\n\tlis[v]=(graf[v].empty());\n\tif (lis[v])\n\t{\n\t\tdpwsz[v]=tab[v];\n\t\tdpbez[v]=0;\n\t\treturn;\n\t}\n\tdpwsz[v]=0;\n\tdpbez[v]=0;\n\tvector <pll> wek;\n\tfor (int i : graf[v])\n\t{\n\t\tdfs1(i, v);\n\t\twek.push_back({dpwsz[i], dpbez[i]});\n\t}\n\tll sum=0;\n\tfor (pll i : wek)\n\t\tsum+=i.first;\n\tdpwsz[v]=sum;\n\tdpbez[v]=inf;\n\tfor (pll i : wek)\n\t\tminuj(dpbez[v], sum-i.first+i.second);\n\tminuj(dpwsz[v], dpbez[v]+tab[v]);\n}\n\nvoid dfs2(int v, ll kwsz, ll kbez)\n{\n\t//~ debug() << v << "" "" << kwsz << "" "" << kbez;\n\tvector <pll> wek;\n\tfor (int i : graf[v])\n\t\twek.push_back({dpwsz[i], dpbez[i]});\n\tll sum=0;\n\tfor (pll i : wek)\n\t\tsum+=i.first;\n\tif (kwsz==dpbez[v]+tab[v])\n\t\topt.push_back(v);\n\t//~ if (dpwsz[v]==sum)\n\t//~ {\n\t\t//~ for (int i : graf[v])\n\t\t\t//~ dfs2(i, dpwsz[i]);\n\t\t//~ return;\n\t//~ }\n\t\n\tvector <pair<ll,int> > wek2;\n\tfor (int i : graf[v])\n\t\twek2.push_back({-dpwsz[i]+dpbez[i], i});\n\tsort(wek2.begin(), wek2.end());\n\tfor (int i : graf[v])\n\t{\n\t\tll x=-inf;\n\t\tll y=-inf;\n\t\tmaxuj(y, kbez-(sum-dpwsz[i]));\n\t\tmaxuj(y, kwsz-(sum-dpwsz[i])-tab[v]);\n\t\tmaxuj(x, kwsz-(sum-dpwsz[i]));\n\t\tint num=0;\n\t\tfor (auto j : wek2)\n\t\t{\n\t\t\tif (j.second==i)\n\t\t\t\tcontinue;\n\t\t\tmaxuj(x, kbez-(sum-dpwsz[i])-j.first);\n\t\t\tmaxuj(x, kwsz-(sum-dpwsz[i])-j.first-tab[v]);\n\t\t\t//~ maxuj(y, kbez-(sum-dpwsz[i])-j.first);\n\t\t\t\n\t\t\tnum++;\n\t\t\tif (num>3)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdfs2(i, x, y);\n\t}\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tdfs1(1, 0);\n\tdfs2(1, dpwsz[1], -inf);\n\t\n\t\n\tprintf(""%lld %d\\n"", dpwsz[1], (int)opt.size());\n\tsort(opt.begin(), opt.end());\n\tfor (int i : opt)\n\t\tprintf(""%d "", i);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","['dfs and similar', 'dp', 'dsu', 'graphs', 'greedy', 'trees']",2500
https://codeforces.com//contest/1729/problem/C,C. Jumping on Tiles,Polycarp was given a row of tiles Each tile contains one lowercase letter of the Latin alphabet The entire sequence of tiles forms the string s In other words you are given a string s consisting of lowercase Latin letters Initially Polycarp is on the tile of the row and wants to get to the tile by jumping on the tiles Jumping from i th tile to j th tile has a cost equal to index s i index s j where index c is the index of the letter c in the alphabet for example index 1 index 2 index 26 Polycarp wants to get to the n th tile for the minimum total cost but at the same time make number of jumps In other words among all possible ways to get to the last tile for the total cost he will choose the one with the number of jumps Polycarp can visit each tile Polycarp asks you to help print the sequence of indices of string s on which he should jump ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n    vvi g(26);\n\n    rep(i,0,n)\n    {\n        g[s[i] - \'a\'].pb(i);\n    }\n\n\n    cout << abs(s[0] - s.back()) << \' \';\n\n    vi res;\n\n    if(s[0] < s.back())\n    {\n        fr(i, s[0] - \'a\', s.back() - \'a\')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    else\n    {\n        frev(i, s.back() - \'a\', s[0] - \'a\')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    \n    \n    cout << sz(res) << endl;\n\n    trav(x, res)\n    {\n        cout << x + 1 << \' \';\n    }\n\n    cout << endl;\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']","['constructive algorithms', 'strings']",1100
https://codeforces.com//contest/1218/problem/I,I. The Light Square,For her birthday Alice received an interesting gift from her friends The Light Square The Light Square game is played on an N times N lightbulbs square board with a magical lightbulb bar of size N times 1 that has magical properties At the start of the game some lights on the square board and magical bar are turned on The goal of the game is to transform the starting light square board pattern into some other pattern using the magical bar without rotating the square board The magical bar works as follows It can be placed on any row or column The orientation of the magical lightbulb must be left to right or top to bottom for it to keep its magical properties The entire bar needs to be fully placed on a board The lights of the magical bar never change If the light on the magical bar is the same as the light of the square it is placed on it will switch the light on the square board off otherwise it will switch the light on The magical bar can be used an infinite number of times Alice has a hard time transforming her square board into the pattern Bob gave her Can you help her transform the board or let her know it is impossible If there are multiple solutions print any ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\nconst int N = 2005;\n\nchar str[N];\nint n, a[N][N], b[N], p[4*N], c[4*N], cnt;\n\nint f(int x){\n    if(x == p[x]) return x;\n    return p[x] = f(p[x]);\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> (str+1);\n        for(int j = 1; j <= n; j++) a[i][j] = str[j]&1;\n    }\n    for(int i = 1; i <= n; i++){\n        cin >> (str+1);\n        for(int j = 1; j <= n; j++) a[i][j] ^= str[j]&1;\n    }\n    cin >> (str+1);\n    for(int i = 1; i <= n; i++) b[i] = str[i]&1;\n    iota(p, p + 4*n+3, 0);\n    int T = 4*n+1, F = 4*n+2;\n    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){\n        switch(2*b[i] + b[j]){\n        case 0:\n            if(a[i][j]){ cout << ""-1\\n""; return 0; }\n            break;\n        case 1:\n            p[f(i)] = f(a[i][j] ? T : F);\n            break;\n        case 2:\n            p[f(j + n)] = f(a[i][j] ? T : F);\n            break;\n        case 3:\n            if(a[i][j]){\n                p[f(i)] = f(j + 3*n);\n                p[f(i + 2*n)] = f(j + n);\n            }\n            else{\n                p[f(i)] = f(j + n);\n                p[f(i + 2*n)] = f(j + 3*n);\n            }\n            break;\n        }\n    }\n    c[f(T)] = 1;\n    c[f(F)] = -1;\n    for(int i = 1; i <= 2*n; i++){\n        if(f(i) == f(i + 2*n)){ cout << ""-1\\n""; return 0; }\n        if(c[f(i)] && c[f(i)] == c[f(i + 2*n)]){ cout << ""-1\\n""; return 0; }\n        if(!c[f(i)] && !c[f(i + 2*n)]) c[f(i)] = -1;\n        if(!c[f(i)] && c[f(i + 2*n)]) c[f(i)] = -c[f(i + 2*n)];\n        if(!c[f(i + 2*n)] && c[f(i)]) c[f(i + 2*n)] = -c[f(i)];\n        if(c[f(i)] > 0) cnt++;\n    }\n    cout << cnt << \'\\n\';\n    for(int i = 1; i <= n; i++) if(c[f(i)] > 0) cout << ""row "" << i-1 << \'\\n\';\n    for(int i = 1; i <= n; i++) if(c[f(i + n)] > 0) cout << ""col "" << i-1 << \'\\n\';\n}']","['2-sat', 'dfs and similar', 'greedy']",2100
https://codeforces.com//contest/1194/problem/A,A. Remove a Progression,You have a list of numbers from 1 to n written from left to right on the blackboard You perform an algorithm consisting of several steps steps are 1 indexed On the i th step you wipe the i th number considering only numbers You wipe not one digit When there are less than i numbers remaining you stop your algorithm Now you wonder what is the value of the x th remaining number after the algorithm is stopped ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>\n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint q;\n\nint main() {\n    setIO(); re(q);\n    F0R(i,q) {\n    \tint n,x; re(n,x);\n    \tps(2*x);\n    }\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/']",['math'],800
https://codeforces.com//contest/1607/problem/E,E. Robot on the Board 1,The robot is located on a checkered rectangular board of size n times m n rows m columns The rows in the board are numbered from 1 to n from top to bottom and the columns from 1 to m from left to right The robot is able to move from the current cell to one of the four cells adjacent by side The sequence of commands s executed by the robot is given Each command is denoted by one of the symbols or and triggers the movement to left right down or up respectively The robot can start its movement in cell The robot executes the commands starting from the first one strictly in the order in which they are listed in s If the robot moves beyond the edge of the board it falls and breaks A command that causes the robot to break is successfully executed The robot s task is to execute as many commands as possible without falling off the board For example on board 3 times 3 if the robot starts a sequence of actions s right right down left up up from the central cell the robot will perform one command then the next command will force him to cross the edge If the robot starts moving from the cell 2 1 second row first column then all commands will be executed successfully and the robot will stop at the cell 1 2 first row second column Determine the cell from which the robot should start its movement in order to execute as many commands as possible ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tstring s;\n\t\tcin >> n >> m >> s;\n\t\tint mnx=0,mxx=0,mny=0,mxy=0,x=0,y=0;\n\t\ts+=\'*\'; \n\t\tfor(auto t:s)\n\t\t{\n\t\t\tint l1=mxx,l2=mnx,l3=mxy,l4=mny;\n\t\t\tif(t==\'L\') --y;\n\t\t\telse if(t==\'R\') ++y;\n\t\t\telse if(t==\'U\') --x;\n\t\t\telse if(t==\'D\') ++x;\n\t\t\telse x=1e9;\n\t\t\tmnx=min(mnx,x); \n\t\t\tmny=min(mny,y); \n\t\t\tmxx=max(mxx,x);\n\t\t\tmxy=max(mxy,y);\n\t\t\tif(mxx-mnx+1>n||mxy-mny+1>m)\n\t\t\t{//\n\t\t\t\tmxx=l1,mnx=l2,mxy=l3,mny=l4;\n\t\t\t\tcout << 1-mnx << "" "" << 1-mny << ""\\n"";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",['implementation'],1600
https://codeforces.com//contest/976/problem/C,C. Nested Segments,You are given a sequence of one dimensional segments numbered through Your task is to find two distinct indices and such that segment lies within segment Segment lies within segment iff and Print indices and If there are multiple answers print any of them If no answer exists print ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\npii in[300050];\nint u[300050];\n\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tu[i] = i;\n\t\tscanf(""%d %d"", &in[i].first, &in[i].second);\n\t}\n\tsort(u + 1, u + N + 1, [](int a, int b) {\n\t\tif (in[a].first != in[b].first) return in[a].first < in[b].first;\n\t\telse return in[a].second > in[b].second;\n\t});\n\n\tint mxp = u[1];\n\tfor (i = 2; i <= N; i++) {\n\t\tif (in[u[i]].second <= in[mxp].second) return !printf(""%d %d\\n"", u[i], mxp);\n\t\telse mxp = u[i];\n\t}\n\treturn !printf(""-1 -1\\n"");\n}']","['greedy', 'implementation', 'sortings']",1500
https://codeforces.com//contest/1782/problem/F,F. Bracket Insertion,Vika likes playing with bracket sequences Today she wants to create a new bracket sequence using the following algorithm Initially Vika s sequence is an empty string and then she will repeat the following actions n times Choose a place in the current bracket sequence to insert new brackets uniformly at random If the length of the current sequence is k then there are k 1 such places before the first bracket between the first and the second brackets ldots after the k th bracket In particular there is one such place in an empty bracket sequence Choose string with probability p or string with probability 1 p and insert it into the chosen place The length of the bracket sequence will increase by 2 A bracket sequence is called if it is possible to obtain a correct arithmetic expression by inserting characters and into it For example sequences and are regular while and are not Vika wants to know the probability that her bracket sequence will be a regular one at the end Help her and find this probability modulo 998 244 353 see Output section ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1007, mod = 998244353;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) (mod - mod / i) * inv[mod % i] % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n} \nint C(int x, int y) {\n\treturn x < y || y < 0 ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint n, p, dp[N][N], f[N][N];\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> p;\n\tinit(n * 2);\n\tp = (ll) p * qpow(10000) % mod;\n\tL(i, 0, n) dp[i][0] = 1, f[i][0] = 1;\n\tL(len, 1, n) {\n\t\tL(h, 0, n) { \n\t\t\tL(i, 0, len - 1) \n\t\t\t\t(dp[h][len] += (ll) f[h][i] * \n\t\t\t\t\t((ll) p * dp[h + 1][len - i - 1] % mod + \n\t\t\t\t\t(h == 0 ? 0 : (ll) (mod + 1 - p) * dp[h - 1][len - i - 1] % mod)) % mod\n\t\t\t\t\t* C(len - 1, i) % mod) %= mod;\n//\t\t\tL(i, 0, len - 1) {\n//\t\t\t\tL(j, 0, len - 1 - i) {\n//\t\t\t\t\t(dp[h][len] += (ll) dp[h][i] * dp[h][j] % mod * \n//\t\t\t\t\t\t((ll) p * dp[h + 1][len - i - j - 1] % mod + \n//\t\t\t\t\t\t(h == 0 ? 0 : (ll) (mod + 1 - p) * dp[h - 1][len - i - j - 1] % mod)) % mod\n//\t\t\t\t\t\t* C(len - 1, i + j) % mod * C(i + j, i) % mod) %= mod;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tL(i, 0, len)\n\t\t\t\t(f[h][len] += (ll) dp[h][i] * dp[h][len - i] % mod * C(len, i) % mod) %= mod;\n\t\t}\n\t}\n\tint ns = dp[0][n];\n\tL(i, 1, n) \n\t\tns = (ll) ns * inv[i * 2 - 1] % mod;\n\tcout << ns << '\\n';\n\treturn 0;\n} ""]","['combinatorics', 'dp', 'probabilities', 'trees']",2700
https://codeforces.com//contest/1200/problem/D,D. White Lines,Gildong has bought a famous painting software The working screen of cfpaint is square shaped consisting of n rows and n columns of square cells The rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to n from left to right The position of a cell at row r and column c is represented as r c There are only two colors for the cells in cfpaint black and white There is a tool named in cfpaint The eraser has an integer size k 1 le k le n To use the eraser Gildong needs to click on a cell i j where 1 le i j le n k 1 When a cell i j is clicked all of the cells i j where i le i le i k 1 and j le j le j k 1 become white In other words a square with side equal to k cells and top left corner at i j is colored white A is a row or a column without any black cells Gildong has worked with cfpaint for some time so some of the cells possibly zero or all are currently black He wants to know the maximum number of after using the eraser Help Gildong find the answer to his question ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mxN=2e3;\nint n, k, b[mxN+1][mxN+1];\nstring s[mxN];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> k;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> s[i];\n\tfor(int i=0; i<n; ++i) {\n\t\tint l=0;\n\t\twhile(l<n&&s[i][l]=='W')\n\t\t\t++l;\n\t\tif(l>=n) {\n\t\t\t++b[0][0];\n\t\t\tcontinue;\n\t\t}\n\t\tint r=n-1;\n\t\twhile(~r&&s[i][r]=='W')\n\t\t\t--r;\n\t\tif(r-l+1>k)\n\t\t\tcontinue;\n\t\t//i-k+1, i\n\t\t//r-k+1, l\n\t\tint l1=max(i-k+1, 0), r1=i+1;\n\t\tint l2=max(r-k+1, 0), r2=l+1;\n\t\t++b[l1][l2];\n\t\t--b[l1][r2];\n\t\t--b[r1][l2];\n\t\t++b[r1][r2];\n\t}\n\tfor(int j=0; j<n; ++j) {\n\t\tint l=0;\n\t\twhile(l<n&&s[l][j]=='W')\n\t\t\t++l;\n\t\tif(l>=n) {\n\t\t\t++b[0][0];\n\t\t\tcontinue;\n\t\t}\n\t\tint r=n-1;\n\t\twhile(~r&&s[r][j]=='W')\n\t\t\t--r;\n\t\tif(r-l+1>k)\n\t\t\tcontinue;\n\t\t//r-k+1, l\n\t\t//j-k+1, j\n\t\tint l1=max(r-k+1, 0), r1=l+1;\n\t\tint l2=max(j-k+1, 0), r2=j+1;\n\t\t++b[l1][l2];\n\t\t--b[l1][r2];\n\t\t--b[r1][l2];\n\t\t++b[r1][r2];\n\t}\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tb[i][j+1]+=b[i][j];\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tb[i+1][j]+=b[i][j];\n\tint ans=0;\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tans=max(b[i][j], ans);\n\tcout << ans;\n}""]","['brute force', 'data structures', 'dp', 'implementation', 'two pointers']",1900
https://codeforces.com//contest/1335/problem/E1,E1. Three Blocks Palindrome  easy version , You are given a sequence a consisting of n positive integers Let s define a as the sequence consisting of distinct elements let these elements are a and b a can be equal b and is as follows underbrace a a dots a x underbrace b b dots b y underbrace a a dots a x There x y are integers greater than or equal to 0 For example sequences 2 1 1 1 2 1 1 2 2 1 and 1 1 2 1 1 are but 1 2 3 2 1 1 2 1 2 1 and 1 2 are not Your task is to choose the maximum by length of a that is a You have to answer t independent test cases Recall that the sequence t is a a subsequence of the sequence s if t can be derived from s by removing zero or more elements without changing the order of the remaining elements For example if s 1 2 1 3 1 2 1 then possible subsequences are 1 1 1 1 3 and 1 2 1 3 1 2 1 but not 3 2 3 and 1 1 1 1 2 ,"['#include<bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false),cin.tie(NULL)\n#define fi first\n#define se second\n#define  all(d) d.begin(),d.end()\n#define allr(d) d.rbegin(),d.rend()\n#define For(i,d,c) for(int i = d;i <= c;++i)\nstd::mt19937 rgn(std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace io\n{\n\ttemplate<typename T> inline void read(T&a){\n\t\tint c = getchar(),sign = 0;\n\t\ta = 0;\n\t\twhile(c < \'0\' || c >\'9\') sign += (c == \'-\'),c = getchar();\n\t\twhile (c >=\'0\' && c <=\'9\') a = (a << 1) + (a << 3) + c-48,c = getchar();\n\t\tif (sign&1) a = -a;\n\t}\n\ttemplate<typename T,typename... _T>\n\tinline void read(T&a,_T& ...argc)\n\t{\n\t\tread(a);read(argc...);\n\t}\n\ttemplate<typename T>\n\tinline void Write(T a)\n\t{\n\t\tif (a > 9) Write(a/10);\n\t\tputchar(a % 10 + \'0\');\n\t}\n\ttemplate<typename T>\n\tinline void write(T a,char ch = \' \')\n\t{\n\t\tif (a < 0) putchar(\'-\'),a = -a;\n\t\tWrite(a);\n\t\tputchar(ch);\n\t}\n\ttemplate<typename T> inline void Min(T&a,T b){if (a > b) a = b;}\n\ttemplate<typename T> inline void Max(T&a,T b){if (a < b) a = b;}\n\ttemplate<typename T,typename... _T> inline void Min(T&a,T b,_T ...c){Min(a,b);Min(a,c...);}\n\ttemplate<typename T,typename... _T> inline void Max(T&a,T b,_T ...c){Max(a,b);Max(a,c...);}\n}\nusing namespace io;\nconst int maxn= 1e6 + 3;\nconst int N = 4e5 + 3;\nconst int mod= 1e9 + 7 ;\nint n,m,q;\nint dem[N],id[N],chot[N],a[N],b[N];\nint k,h;\nll t[N + 3];\nstring  s;\nbool kt[N];\nmap<long long,int> maps;\nvector<int> edge[N];\nmap<int,int> ::iterator it;\ntemplate<typename T>\nvoid answer(T x) {cout << x;exit(0);}\nvoid putstring(string x,char ch = \' \') {for (char c:x) putchar(c);putchar(ch);}\n\nint main() {\n\tIOS;\n\tcin >> q;\n\twhile (q--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<vector<int>> dp(n + 1,vector<int>(26,0));\n\t\tvector<int> a(n + 1);\n\t\tvector<vector<int>> pos(26);\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> a[i];\n\t\t\t--a[i];\n\t\t\tdp[i] = dp[i-1];\n\t\t\tdp[i][a[i]]++;\n\t\t\tpos[a[i]].emplace_back(i);\n\t\t}\n\t\tint ans = *max_element(dp[n].begin(),dp[n].end());\n\t\tfor (int a = 0;a < 26;a++) {\n\t\t\tfor (int b = 0;b < 26;b++) {\n\t\t\t\tif (a == b) continue;\n\t\t\t\tfor (int i = 0;i < (int)pos[a].size();i++) {\n\t\t\t\t\tif ((int)pos[a].size() - i - 1 <= i) break;\n\t\t\t\t\tint L = pos[a][i],R = pos[a][(int)pos[a].size() - i - 1];\n\t\t\t\t\tassert(L < R);\n\t\t\t\t\t--R;\n\t\t\t\t\tans = max(ans,2 * i + 2 + dp[R][b] - dp[L][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans <<""\\n"";\n\t}\n}\n\n/*********************************************************************************************************************************************************************************************************\n *ti;.                               .:,:i:          .:,;itt;:      GLDEEGEEEEEEEEEEEEEEEEEEDEEEEEEEEEEE#W#WEKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKKKKKKG.     .::.      f:,...,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:            :,;;iti,    :fDDEEEEEEEEEEEEEEEKEEEEDEEEEEEEEEEEW##WEEEKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWWKKKKKKEG     .::.       .f,::,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:             .,,;iti;.  LDDEEEEEEEEEEKEEEEWEEEDDEEEEEEEEEEE#WWWEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWKKKKKEDj    .::.        .:L;;ijfGDDDDDDDDDEEEEE *\n *ti;.                               .:,:i:              .:,;;iii:LLDEEEEEEEEEEEKEEEEEEEEDEEEEEEEEEEEW#WWEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWKWWWWWWWWWWWWWWKKKKKKKEL    .::.         .:;LijLGGDDDDDDDDEEEEE *\n *ti;.                               .:,:;:                :,;;ittfDEEEEEEEEEEEEEEEEKEEEGEEEEEEEEEEEKWWWEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWKKKKKKKELj   .::.          :,;jffGGDDDDDDDDDEEEE *\n *ti;.                               .:,:i:                 .,;;tGGDEEEEEEEEEEEKEEEKEEEDEEEEEEEEEEEEWWWEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWKWWWWWWKKKKKKKEEL   .::.          .:;itDGGDDDDDDDDDEEEE *\n *ti;.                               .:::;:                   :;ifDEEEEEEEEEEEEKEEEKEEEEEEEEEEEEEEEWWWEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WWWKKKKKKKKEEf   .::.           :,itfGEDDDDDDDDDDDEE *\n *ti;.                               .:::;:                    :GGEEEEEEEEEEEKEKEEKEEEEEEEEEEEEEEEEWWEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKKEEDG  .::.           .,;jfLGKDLDDDDDDEEDD *\n *ti;.                               .:::;:                     fDEEEEEEKKKKKKKKKEKEEEEEEEEEEEEEEE#WEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#KKKKKKKKKKEEf .:::.           .,;tfLGDEDDDDDDDDEEE *\n *ti;.                                :::;:                    fDEEEEEEKKKKKKKKKKWKEEEEEEEEEEEEEEEWKEEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKKKEEft :::.           .,;tfLGDDDKDDDDDDDDD *\n *ti;.                                .::;:                    fDEEEEEEKKKKKKKWKKKKKEEEEEEEEEEEEE#WEEWEEEEEDEEDEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKEEGG :,:.           .,;tfLGGDDDKDDDDDDDD *\n *ti;.                                .:.;:                   tGDEEEEKKKKKKKKKKKKKKKKKEEEEEEEEEEEWEEKWEEEEEEEDEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKKKKKEEDf :::.           .,;tfLGGDDDDEDDDDDDD *\n *ti;.                                .::;:                   fDEEEEEKKKKKKKKKKKWKKKKKKKKEEEEEEEWWEEWEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKEEEft.::.           .,;tfLGGDDDDDDEDDDDD *\n *ti;.                                .:.;:                  tGDEEEKKKKKKKKKKKKKKKKKKKKKKEKEEEEE#EEWWEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKEEEGD:::.           .,;tfLGGDDDDDDDEDDDD *\n *ti;.                                .:.,.                  LDEEEEKKKKKKKKKKWKWKKKKKKKKKKKKEEEKWEKW#EEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKW##KKKKKKEEEEf,,:.           .,;tfLGGDDDDDDDDEDDD *\n *ti;.                               ..:.,.                 LGDEEEEKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEEW#WEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKK##KKKKKEEEEEfi;,.           .,;tfLGGDDDDDDDDDKDD *\n *tt;.                                .:.,:                 jDEEEEKKKKKKKKKKWWKKKKKKKKKKKKKKKKKWKE#WWEEEEEEEEEEEEEEWEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKWWKKKKEEEEDfG;,:           .,;tfLGGDDDDDDDDDDKD *\n *tii,.                               .:.,.                tGDEEEEKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKKWWWKEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKW#KKKKEEEEDGGi;,.          .,;tfLGGDDDDDDDDDDDE *\n *ti;;,:.                             .:.,:                fDEEEEKKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEK#WWKEEEEEEEEEEEEDEEEEEEEEEEEEEEGEEEEEEEEEEEEEEEEEEEKKKKKKKWWKKEEEEEEDDf;;;,.         .,;tfLGGDDDDDDDDDDDD *\n *tii;,,:..                           ...,.               ;LEEEEEKKKKKKWKKKKWKKKKKKKKKKKKKKKKKEKKW#WEEEEEEEEEEEEEjEEEEEEEEEKEEEEGEEEEEEEEEKEEEEEEEEEEEEEEEEE#WKEEEEEEDDf;;;;,:        .,itfLGGDDDDDDDDDDDD *\n *ti;,,,,,:.                          ...,.               LDEEEEKKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKK#W#WEEEEEEEEEEEDDLEEEEEEEEEWEEEEDEEEEEEEEEKEEEEEEEEEEEEEEEEEWWEEEEEEEDDfj,,,,,:.      .,itfGGGDDDDDDDDDDDD *\n *tii,,,,::::.                        ...,:              .fDEEEEKKKKKKWKKKKWWWKKKKKKKKKKKKKKKEKKW#WWEEEEEEEEEEEKiKEEKEEEEEEWEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEEWWEEEEEEEDDLD:::,,,:.     .,ijfGGGDDDDDDDDDDDD *\n *ti;:::::::::..                      .:.,:              LDEEEEKKKKKKKWKKKKWWKKKKKKKKKKKKKKKKtKKWWWWKEEEEEEEEEDiiDEEEEEEEEWWEEEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEWKEEEEEDDDGL:. .:,,,:    .,ijLGGGDDDDDDDDDDDD *\n *tt;. .::::::::..                    ...,:             :fDEEEKKKKKKKKKKKKWW#KKKKKKKKKKKKKKKKfKKWWWWKEEEEEEEEDti,DEKEEEEEEWWEEEDEEEEEEEEEKEEEEEEEEEEEEEDEEEEE#WEEEEEGGDGf:.  .:,;,:.  .,ijLGGDDDDDDDDDDDDD *\n *tt;.   .:::::::..                   ...,:             GDEEEKKKKKKKKWKKKKWWWKKKWKKKKKKKWWWKDEKLWWWWKKEEEEEEDEi,LDEEEEEEEEWWEEEEEEEEEEEEEEEEEEEEEEEEEDEDEEEEEW#EEEEDDDDGf,.    :,,,:...,ijLGGGDDDDDDDDDDDD *\n *tt;.    .....::::..                 ...,:             fDEEEKKKKKKKKWKKKKWWWWKKKWKKKKKKKKKKfWKiWWW#KKEEEEEEEi;.EDfEEEDEEiWWEEEEEEEEEEEEDGKEEEEEEEEEEDEEEEEEEWWEEEEDDDGGLi.     .,;,:::,ijLGGGDDDDDDDDDDDD *\n *tt;.      ....:::::.                ...,.            iDEEEEKKKKKKKKWKKWKWWWWWKKWWWKKKKKKKKtWKt#WWWKKEEEEEDji..DDKDDEDEGiWKEEEEEEEEEEDDEjEEEEEEEEEEEDEEEEEEEKWKEEDDDDGGff.      .:,;,,;ijLGGGDDDDDDDDDDDD *\n *tt;.        ....::::..              .:.,:           .LDEEEKKKKKKKKKKKKWWWWKWWWWWWWWWWKKKKWtKKiDWWWKKKEEEEKi:..DEDDDDDDiiWKEEEEEEEEEEDDEijDEEEEEKEEEEEEEEEEEEWWEEGDDDGGLG.       .:,;;iijLGGGDDDDDDDDDDDD *\n *tt;.          .....:::..            ...,.           .fEEEEKKKKKKKKWKKKKWWWWWWWWWWWWWWKWKKKiKDiLWWWWKEEEEEi,..fD:DDDDDti;WEEEEEEEEEEKDDi:iDDEEEEWEEEEEEEEEEEE#WEEGDDDDGGG.         :,iitjLGGGDDDDDDDDDDDD *\n *tti.            .....:::..          ...,.           GDEEEKKKKKKKKKWKKKWWW#WWWWWWWWWWWKWKKjiEjitWWWKKWEEEDi...DDLDDDDji;;WEEEEEEEEEEEDEj.iDDEEEEWEEEEEEEEEEEEWWEEDDDDDDGf.          .,;tjfLGGDDDDDDDDDDDD *\n *tti.              ....::::..        ...,.           fEEEKKKKKKKKKKKKKKKW#WWWWWWWWWWWWWWWWtiEiiiWWWKKEWKEi....D.EDDDEi;.fWEEEEEEEEEEDDfL.;EDDEEEWEEEEEEEEEEEEWWEEEDDDDDGf.           :;ijfLGGDDDDDDDDDDDD *\n *tti.                ....::::..      ...,.          LDEEEKKKKKKKKKKKKKKWWWWWWWWWWWWWWWW####WKiiiWWWKKKEEK,...:E:DDDEii..GWEEEEEEEEDWDDiL.,KDDEEEWEEEEEEEEEEEEWWKEEDDDDDGf:           .,itfLGGDDDDDDDDDDDD *\n *tti.                 .....:::..     ...,.          fDEEEKKKKKKKKKWKKKKWWWWWWWWWWWWW########WLiiWWWKKKEEjD...G,DDDDi;...EWEEEEEEEEDKDEii..LDDEEEWEEEEEEEEEEEEWWWEEDDDDDGfi           .,;tfLGGGDDDDDDDDDDD *\n *tti.                   .....:::..   ...,.         iGEEEKKKKKKKKKKWKKKKWWWWWWWWWWWW###########KiWWWKKEEE,.D..D.DDDii:...KKEEEEEEEEEDDj:...tEDEEEWEEEEEEEEEEEEWWWEEEDDDDDLL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                     ....::::......:.         LEEEKKKKKKKKKKWWKKKWWW#KWWWWWWWW#####W####W##KWWKKEEL..:D.jjDDi;,....KKEEEEEEEDfDDi...:iKDEEEWKEEEEEEEEEEEWWWEEEEDDDDLG           .,;tjLLGGDDDDDDDDDDD *\n *tti.                        ...::::::..,.        :GEEEKKKKKKKKKKKKWWWWW##WWWWWWWWW##WKWK#W#W####WWKEEK.....G.DDti,.....KKEEEEEEDWGDf.,...iKDEEEWWEEEEEEEEEEEW#WEEEEEDDDGL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                         ....::::::,.        GDEEKKKKKKKKKKKKKWWWW###WWWWWWWWWW#WWWK###W#####WKEKK.....jDDL;;......KKEEEEEEEEEDi.f...;KDEEEWWEEEEEEEEEEEWWWWEEEEEDDGf           .,;tjLLGGDDDDDDDDDDD *\n *tti.                           ....:::,,.       .LEEEKKKKKWKKKKKWWWWWW###WWWWWWWWWW#WWKW#WW##W#WWWKEKD:....:DD:;......;KEEEEEEEKiDD..f...,KKEEEWWEEEEEEEEEEEWWWWEEEEEDDDf           .:;tjLLGGGDDDDDDDDDD *\n *tti.                             ...::,,,:.     GDEEKKKKKKKKKKKKWWWWWWW#WWWWWWWWWWW#KjKWWWWWWWWWWWWEK.j,..;fD.;.......fKEEEEEDKG:Di..,....DKEEEWWEEEEEEKEKKKWWWWEEEEEEDDf           .:;tjLLGGDDDDDDDDDDD *\n *jti.                              ...::,,,,:.  .fEEEKKKKKWKKKKKKWWWWWWW#WWWWWWWWWWK#KKKWWWWWWWWWWWWWK..f:.:G.,:.......EKEEEEEKK;:E:.......fKEEEWWKEKEKKKKKKKW#WWEEEEEEDDf:          .,;tfLLGGDDDDDDDDDDD *\n *tti.                               ...:,,,;;,: iDEEKKKKKWKKKKKKKWWWWWWW#WWWWWWWWWWK#WDKWWKKWWWWWWWWWE..;G:G..,........KKEEEEEKi.Gi..:.....tKEEKWWWKKKKKKKKKKW##WKEEEEEEDfi          .,;tfLLGGGDDDDDDDDDD *\n *tti.                               ....::,,;;;,LEEKKKKKKWKKKKKWWWWWWW###WWWWWWWWWWKWWDKWEEEWKKWWWWWKKj.:LG..;.........EKEEEEKG;.G...;.....;KKEKWWWKKKKKKKKKKW##WWKEEEEEDfL          .,;tfLGGGDDDDDDDDDDD *\n *jti.                                ...::::,;ijDEEKKKKKWKKKKKKWKWWWWW##WWWWWWWWWWWKK#KKGDGDWEEWKKWKKGE,.i;.:.........:EKEEEKE;.:L...j.....,KWEKWWWKKKKKKKKKK####WKKEEEEDLG          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:...,,;GEEKKKKKWWKKKKKWWWWWWWW###WWWWWWWWWKKKWWKiLGGEDEDEKGKKiEG..;...........jKEEEKK;:.G....,.....:KKEWWWWKKKKKKKWKK####WKKKKEEEGL          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:.  .:,GEEKKKKKWKKKKKWWWWWWWW####WWWWWWWWWKKKWWKii;fDLGDK: EEi:E:.............EKEEKK;;..L...........KKKWWWWKKKKKKKWKK####WKKKWKEEDf          .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    ,EEKKKKKWWKKKKKWWWWWWWWW###WWWWWWWWKKKKfWWLt;i,. fi  EG..D:.............EKEKK;;..t....:.......KWKWWWWKKKKKKKWKK####WKKKWEEEDf:.        .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEEKKKKKWKKKKKWWWWWWWWW####WWWWWWWKKKKKt;KKEfff     .;t.................KKKKi;:..GtGGfG.......KWWWWWWKKKKKKKWKK###WWWKKKKEEEf,,:       .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEKKKKKWWKKKKKWWWWWWWWWW##WWWWWWWKKKKKKt;EiKKKK,   ...t................jEKKG;;..,.....,LGi....KWWWWWWKKKKKKWKKKW####WKKKKKEEL,,,:.     .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  .GEEKKKKKWKKKKKWWWWWWWWWW###WWWWWWWKKKKKKtiE::tGG........................EEEj;;...,.........:D..DKWWWWWWKKKKK#KKW###W#WKKKKKEEfj:,,,:.   .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.   DEKKKKKWWKKKKKWWWWWWWWW####WWWWWWWKKKKKKiiE:::.::.......................EEi;;...j.....f......:iDKWWWWWWKKKKK#WW######WKKKKKEELG :,,,,:. .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  fEEKKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKK;tE::..........................DD;.;,.::......;........EWWWWWWWKKKKW#WW#####WWKKKWKKELG  .:,,,:::,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. .DEKEKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKE,iD::..........................D..,;.,;tLffi...........DWDWWWW#KKKWWWWW#####W#KKKWKEEGL    .:,;,,,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. ;EEKKKKWWKKKKKWWWWWW#WWWW####WWWWWWKKKKKEL:iD:..........................j ..;..;;:.....i,........DKtWWWWWKKWWWWWW#####WWWKKKEKEDf     .:,;;;itfGGGDDDDDDDDDDDD *\n *jti.                                ...:. DEKKKKKWWKKKKWWWWWWW#WWWW####WWWWWWKKKKKEj:iG...............................:....................GKiWWWWWKKWW#WWW######WWKKKKKEEf       .,;iitfGGGDDDDDDDDDDDD *\n *jti.                                ...:.:EKKKKKWWKKKKKWWWWWWW#WWW#####WWWWWKWKKKKEi:if:.................................iEKEKKKKKKDj......DKiWWWWWKWK##WW#######WWKKK:KEEL        .:;itfGGGDDDDDDDDDDDD *\n *jji.                                ...:,DEEKKKWWWKWKKWWWWWWWWWWWW#####WWWWWWWKKKKEi:it..................................j.  KKKKKKKKKKKf..DKiWWWWWKWW##WW#######WWKKK,KEEf         .,;tfGGGDDDDDDDDDDDD *\n *jji.                                ..L:iDEEKKKWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKKi.i;..................................  . KKKWWWWWWWWK..DGiWWWWWKK##WWW#####W#WWKKKjEKEL,        .:;tfGGGDDDDDDDDDDDD *\n *jji.                               .f:::EEEKKKWWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKK;.i,.................................::  KKEKWWWWWWfWK..EiiWWWWWKWW#WW##########KKKD,KELj        .:;tfGGDDDDDDDDDDDDD *\n *jji.                             .t::::,DEEKKKWWKKKKWWWWWWWWW#WWWW#####WWWWKKWKKKEK;.i:.................................GDDEEEKKKWWWWWtWWD.E;iWWWWWW###WW#########WWKKK.EEDG        .:;tfGGGDDDDDDDDDDDD *\n *jji.                          . j..::::EKEKKKWWWKKKKWWWWWWWWW#WWW######WWWWKKWKKKEK;.t:.................................ELLEDDEEEWWWWEtWK,.KiiWWWWWW###W##########WWKKK:EEEG     .;tjfLLGDDDDDDDDDDDDDDD *\n *jji.                          i.::::::,EEEKKWWWKKKKKWWWWWWWWW#WWW#####WWWWWKWKKKKEE,.t..................................DfiEGDDDEEKKKttKWG.KiiWWWWW##WWW##########WWKKK:fEEL  ,fGGGDDDDDDDDEEEDDDDDDDDDD *\n *jji.                        .;:..:::::DEEEKKWWWKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKED,.t..................................ifjDDGGEGDKK.ttKKE.DiWWWWW###WW##########WWWKKK:.KELiLGGGGDDDDDDDDDDDDEEEDDDDDDD *\n *jji.                       i.:.::::::,KEEKKWWWKKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKEL:.j..................................GGf,;ifLLED .iiKKi:fWWWWWW##W#W##########WWWKKK:.KKLGGDDDDDDDDDDDDDDDDEDDEEDDDDD *\n *jji.                     .j:.::::::::EEEKKKWWWKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKf:.f..................................:EEfftf .,. ;iE,..jWWWWWWW###W############WWKKK,:KKGDDDDDDDDDDDDDDDDDDDDDDDEDDDD *\n *jji.                    .:.::::::::,,EEEKKWWWKKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKt..G....................................EEELL;   .j....tKWWWWWWW################WWWKKtfGKGEDDDDDDDDDDDDDDDDDDDDDDDEEDD *\n *jji.                   :...:::::::,,jEEKKWWWWKKKKKKWWWWWWWWW##KWW#####KWWWWWWKKKKEi..D....................................:jEEE.........;KKWWWWWWWW#WW##W##########WWKKDLGKEKDDDDDDDDDDDDDDDDDDDDDDDDDED *\n *jji.                  i:.::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWW##WWW#####WWWWWWWKKKKKi..D......................................:::::......,KKKWWWWWWWWW#####W########WWWKKKGGKKEGGGGGGGGDDDDDDDDDDDDDDDDDDE *\n *jji.                 i..:::::::::,,tEEKKWWWWKKKKKWWWWWWWWWWW##WW######WWWWWWWKKKKKi..D......................................::::......:EKKKWWWWWWWWWWW##WW########W#WKKWGGKKGGGGGGGGGGGGGGGDDDDDDDDDDDDD *\n *jji.                .:::::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWWW##WW#####WWWWWWWWKKKKKi..D....................................:::::::::..tELii;KWWWWWWWWWW##WW######WWWWWWKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGDG *\n *jjt.                :.::::::::,,,,fEEKKWWWWKKKKKKWWWWWWWWWW###WW####WWWWWWW#WKKKKKi..D....................................:::::::.:.,;;;;;;,KKWWWWWWWWW#WW########WWWKKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *jji.               ;.::::::::,,,,;EEEKWWWWWKKKKKWWWWWWWWWWWW##WW###WKWWWWWK#WKKKKKi..G......................................:::::::,;;;;:...KKKWWWWWWWWWKWW#######WWWWKKGLGKDGGGGGGLLGGGGGGGGGGGGGGGGGGG *\n *jjt.              f.:::::::::,,,,fEEKKWWWWWKKKKKWWWWWWWWWWW###WW##WKKWWWWWW#WKKKKK;.jt........i.............................:::::::;j;;....:E.KKKWWWWWWWKWW#####W#WWWWKKLLGWEEGGGGGLGGGGGGGGGGGGGGGGGGGG *\n *jjt.             ...:::::::,,,,,;DEEKWWWWWKKKKKWWWWWWWWWWWW####WWWKKKWWWWWWWWKKKKK;.E;.........t.............................:::::ii;;.....D...KKWWWWWWWKWW#####WWEWWWKKGGGEKKGGGGGLGGGGGGGGGGGGGLGGGGGG *\n *fji.             ;.:::::::,,,,,;LEEKKWWWWWKKKKKWWWWWWWWWWWW####KWKKKKWWWWWWWWKKKKKi.D;..........j.............................:::tt;,.....:.....KKWWWWWWKWWWW##WWWGWWWKKGGGGKEGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fji.            t::::::::,,,,,,;EEEKWWWWWKKKKKKKWWWWWWWWWWW##WKWKKKKKWWWWWWWWKKKKKi:D;............j...........................::LL;,.............KKWWWWWKWWWWWWWWWGWWWKKGGGGKGGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fjt:            .:::::::,,,,,,,DEEKWWWWWWKKKKKKKWWWWWWWWWWWWKKWKKKKKKWWWWK#WWKKKKWitE;........... ............................:G;;:...............KKKWWKKWWWWWWWWWGWWWKKGGGGWGGGGGGGGGGGGGGGGGGGGGGGGGGL *\n *fjji;:.       .f:::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWWKKKKKKKKKKKWWKWWWWWKKKKWGKD;........................................L;;..................DKKWKKWWWWWWWWWGWWWKKDGGGKDGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *fjjtii;,:.     :::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWKKKKKKKKKKKKWWWWWW#WWKKKKWiEj;......................................:i,;....,...............;KKEKWWWWWWWWWGKWWKKDDGGDEGGGDGGGGGDGGGGGGGGGGGGGGGG *\n *fjtiiiii;;:.  j::::::,,,,,,,;;EEEKWWWWW#KKKKKWWWWWWWWWKKKKKKWKKKKKKKWWWWWWWWWKKKKWtEL;:....................................;;;:...,;j................:KEEWWWWWWWWWDDWWKKDDDDDKDDDDDDDDDDDDDDDGGGGGGGGGGG *\n *fjti;;iiii;;,:::::::,,,,,,,,;EEEKWWWWWWWKKKKWWWWWWWWKKKKKKKWKKKKKKKWWWWWWW#W#KKKKWEEii;...................................f;:....,;L...................EEKWWWWWWWWDDWWKKDDDDDKEDDDDDDDDDDDDDDDDDDDDDGGGG *\n *fjt,,,;;;;ii;f::::::,,,,,,,;;EEKWWWWWWWKKKKKWWWKWWKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWKEij;:...............................:G;,.....,;f....................:tKKWWWWWWWDDWWKKDDDDDKKDDDDDDDDDDDDDDDDDDDDDDDDD *\n *jjt. ..:,;;;;,::::,,,,,,,,;;GEEWWWWWWWWKKKKWKKWKKKKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWEDi;j;............................,Li;L;;;..,;;f........................KKKKWWWKDDWWKKDDDGDKKGGGGGGGGDGDDDDDDDDDDDDDDD *\n *fjt.    .:,,,:::::,,,,,,,;;;EEKWWWWWWWKKKKKKWKKKKKKKKKKKKKKKKKKKKKWKKKWKW##W#KKKKWEti;;G;........................tEEEL;;;;;;;;;;L..........................DKKKKKEDDWWKEDGftiLE;;;;itjLGGGGGGDDDDDDDDDDD *\n *fjt.       .j::::,,,,,,,;;;DEEWWWWWWWWKKKKWKKKKKKKKKKKKKKKKKKKKKKKWKKWWWK##W#KKKKKEii;;;L;...................iDEEEEEEKKi;j;;;;jD.....:......................,KKKKDGGEKKE:::::;E::::::::::,tLGGDDDDDDDDDD *\n *fjt.       .;:::,,,,,,,;;;;EEKWWWWWWWWKWKKKKKKKKKKKKKKKWKKKKKKKKKKWKKWWWW#WW#KKKKKKii;;;;f;.............:tDEEEEEKKKKKKKKEti;;;L...............................EEKf;:iKKE::::::E::::::::::::::ifDDDDDDDDD *\n *fjt:        :::,,,,,,,,;;;DEEWWWWWWWWWEKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####KKKKKEiii;;;;f,.........iDEEEEKKKKKKKKKKKKKKKf;iG......i..........................fK::::KKE::::::E::::::::::::::::,tGGDDDDD *\n *fjt:       t:::,,,,,,;;;;iDEKWWWWWWKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####WKKKKLiii;;;;;L,....,Li;EDEEEEKKKKKKKKKKKKKKKKiG......;:...........................:i:::KKE:::::,E,::::::::::::::::::iGDDDD *\n *jjt.       f::,,,,,,,;;;;GEEWWWWKEEKEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKWWWWW###WWKKKKiii;;;;;;;G,;L;;iiEEEEEEEKKKKKKKKKKKKKWWKE......;t.........:....................j::KEE:,::,,D,,::::,,,,,,:::::::::tDDD *\n *fjt:.      ,::,,,,,,,;;;;EEWWKEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKKWWWWW#W#KKKKKKiiiiii;;;;;i;;iiiEEKEEKKWKKKKKKKWKKKKKWWWGi;...;t......,;;;;,....................:,EEE,,,,,,D,,,,,,,,,,,,,,,,::,::::tG *\n *fjt:.     ,::,,,,,,,;;;;DEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWW#W#KKKKKKiiiii;;i;;;;;iiiKKKEKKKKWWKWWWWWWKKKKWWWWW;;;:;L.....;;;;;;;;;....................,KEE,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,; *\n *fjt:.     f:,,,,,,,;;;;jEDEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWW#W##KKKKKKiiiiiiii;i;;iiiEKKKKKKKKWKWWWWWWWWKKKWWWWWKi;;i.....,jEEfGi;;;;;...................EED,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.    .f::,,,,,,;;jEEDEEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWKWWWWW###KKKKKLiiiiiiiiiiiiiiEEKKKKKKKKWWWWWWWWWWWWKWWWWWWGi;i;,..;jDDDKEGi;;;;;;:................EED,,,,,,D,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.  .. ;::,,,,,;;EDDEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKW#WW####KWKKKiiiiiiiiiiiiijKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWt;i;;;;i;DDDDDDGi;;;;;;;;:.............EDf;,,,;,G;;;;;;;;;;;;;;;,,,,,,,,,, *\n *fjt:......:,,,,,,;LDDDEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWWKWWWW####KKKKKiiiiiiiiiiijKEKKWKKKKKKKWWWWWWWWWWWWWWWWWWWWWWiLiii;i;DEEEEDDE;i;;;;;;;;;:..........EDi,;;;;;L;;;;;;;;;;;;;;;;;;,,,,,,, *\n *fjt:......:,,,,,;EDDDEEKEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKWWWWKKWWW##W#KWKKWEiiiiiijGKKKKKWWKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKi;iiiiDDEEEEEEDEi;;;;;;;;;;;;;,:.....ED;;;;;;;j;;;;;;;;;;;;;;;;;;;;;;;,, *\n *fjt:.....t,,,,,;DDDDEEEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKWWWW##WKWKKWKiiiKKKKKKKKKWWKKKKKKKKWWWWWWWWWWWWWWW#WWWWWWWWWiiiiifLEEEEEEEEDi;i;;;;;;;;;;;;.....DD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....G,,,,,GDDDEEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKKWWWKKKWWW###WKWKKWKitKKKKKKKKKWKKKKKKKKKKWWWWWWWWWWWWWW###WWWWWWWWEiiiiiiiEEEEEEEEDGiiii;;;;;;;;;.....GD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....L,,,,;GDDDEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWDGWWW###KKWWKWKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWW####WWWWWWWWWiiiiiiiiEEEEEEEEEEDi;i;;;;;;;;.....Lj;;;;;;i;iiiiii;;;;;;ii;;;;;;;;;;; *\n ***********************************************************************************************************************************************************************************************************/\n']","['binary search', 'brute force', 'data structures', 'dp', 'two pointers']",1700
https://codeforces.com//contest/1787/problem/E,E. The Harmonization of XOR,You are given an array of exactly n numbers 1 2 3 ldots n along with integers k and x Partition the array in exactly k non empty disjoint subsequences such that the bitwise XOR of all numbers in each subsequence is x and each number is in exactly one subsequence Notice that there are no constraints on the length of each subsequence A sequence a is a subsequence of a sequence b if a can be obtained from b by the deletion of several possibly zero or all elements For example for n 15 k 6 x 7 the following scheme is valid 6 10 11 6 oplus 10 oplus 11 7 5 12 14 5 oplus 12 oplus 14 7 3 9 13 3 oplus 9 oplus 13 7 1 2 4 1 oplus 2 oplus 4 7 8 15 8 oplus 15 7 7 7 7 where oplus represents the bitwise XOR operation The following scheme is invalid since 8 15 do not appear 6 10 11 6 oplus 10 oplus 11 7 5 12 14 5 oplus 12 oplus 14 7 3 9 13 3 oplus 9 oplus 13 7 1 2 4 1 oplus 2 oplus 4 7 7 7 7 The following scheme is invalid since 3 appears twice and 1 2 do not appear 6 10 11 6 oplus 10 oplus 11 7 5 12 14 5 oplus 12 oplus 14 7 3 9 13 3 oplus 9 oplus 13 7 3 4 3 oplus 4 7 8 15 8 oplus 15 7 7 7 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nconst int MAXN = 200005;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k, x;\n\t\tcin >> n >> k >> x;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tsum ^= i;\n\t\tif (sum != (k % 2 == 0 ? 0 : x)) {\n\t\t\tcout << ""NO\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> vis(n + 1);\n\t\tvector<vector<int>> grp;\n\t\tif (x <= n)\n\t\t\tgrp.push_back({x}), vis[x] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == x)\n\t\t\t\tcontinue;\n\t\t\tint j = i ^ x;\n\t\t\tif (j < i)\n\t\t\t\tgrp.push_back({i, j}), vis[i] = vis[j] = 1;\n\t\t}\n\t\t{\n\t\t\tvector<int> vect;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (!vis[i])\n\t\t\t\t\tvect.push_back(i);\n\t\t\t}\n\t\t\tif (sz(vect))\n\t\t\t\tgrp.push_back(vect);\n\t\t}\n\t\tif (sz(grp) < k) {\n\t\t\tcout << ""NO\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ""YES\\n"";\n\t\tfor (int i = k; i < sz(grp); i++) {\n\t\t\tfor (auto &z : grp[i])\n\t\t\t\tgrp[k - 1].push_back(z);\n\t\t}\n\t\tgrp.resize(k);\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tsort(all(grp[i]));\n\t\t\tcout << sz(grp[i]);\n\t\t\tfor (auto &j : grp[i])\n\t\t\t\tcout << "" "" << j;\n\t\t\tcout << ""\\n"";\n\t\t}\n\t}\n}\n']","['bitmasks', 'constructive algorithms', 'greedy', 'math']",2100
https://codeforces.com//contest/1500/problem/A,A. Going Home,It was the third month of remote learning Nastya got sick of staying at dormitory so she decided to return to her hometown In order to make her trip more entertaining one of Nastya s friend presented her an integer array a Several hours after starting her journey home Nastya remembered about the present To entertain herself she decided to check are there four indices x y z w such that a x a y a z a w Her train has already arrived the destination but she still hasn t found the answer Can you help her unravel the mystery ,"['/**\n *    author:  tourist\n *    created: 13.03.2021 12:04:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  int mx = *max_element(a.begin(), a.end()) + 1;\n  vector<int> p1(mx, -1);\n  vector<int> p2(mx, -1);\n  vector<int> p3(mx, -1);\n  for (int i = 0; i < n; i++) {\n    if (p1[a[i]] == -1) {\n      p1[a[i]] = i;\n      continue;\n    }\n    if (p2[a[i]] == -1) {\n      p2[a[i]] = i;\n      continue;\n    }\n    if (p3[a[i]] == -1) {\n      p3[a[i]] = i;\n      continue;\n    }\n    cout << ""YES"" << \'\\n\';\n    cout << p1[a[i]] + 1 << "" "" << p2[a[i]] + 1 << "" "" << p3[a[i]] + 1 << "" "" << i + 1 << \'\\n\';\n    return 0;\n  }\n  vector<int> ind;\n  int two = -1;\n  for (int i = 0; i < mx; i++) {\n    if (p1[i] == -1) {\n      continue;\n    }\n    ind.push_back(p1[i]);\n    if (p2[i] == -1) {\n      continue;\n    }\n    if (two != -1) {\n      cout << ""YES"" << \'\\n\';\n      cout << p1[two] + 1 << "" "" << p1[i] + 1 << "" "" << p2[two] + 1 << "" "" << p2[i] + 1 << \'\\n\';\n      return 0;\n    }\n    two = i;\n  }\n  vector<pair<int, int>> met(2 * mx, make_pair(-1, -1));\n  sort(ind.begin(), ind.end());\n  if (two != -1) {\n    met[two + two] = make_pair(p1[two], p2[two]);\n  }\n  for (int i = 0; i < (int) ind.size(); i++) {\n    for (int j = i + 1; j < (int) ind.size(); j++) {\n      int sum = a[ind[i]] + a[ind[j]];\n      if (met[sum].first != -1) {\n        cout << ""YES"" << \'\\n\';\n        cout << met[sum].first + 1 << "" "" << met[sum].second + 1 << "" "" << ind[i] + 1 << "" "" << ind[j] + 1 << \'\\n\';\n        return 0;\n      }\n      met[sum] = make_pair(ind[i], ind[j]);\n    }\n  }\n  cout << ""NO"" << \'\\n\';\n  return 0;\n}\n']","['brute force', 'hashing', 'implementation', 'math']",1800
https://codeforces.com//contest/1215/problem/E,E. Marbles,Monocarp has arranged n colored marbles in a row The color of the i th marble is a i Monocarp likes ordered things so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment and there is only one such segment for each color In other words Monocarp wants to rearrange marbles so that for every color j if the leftmost marble of color j is l th in the row and the rightmost marble of this color has position r in the row then every marble from l to r has color j To achieve his goal Monocarp can do the following operation any number of times choose two neighbouring marbles and swap them You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles Note that the order of segments of marbles having equal color does not matter it is only required that for every color all the marbles of this color form exactly one contiguous segment ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,x,S[25];\nll pr[25][25],f[(1<<20)];\nint main(){\n\tscanf(""%d"",&n);\n\tFor(i,1,n){\n\t\tscanf(""%d"",&x); --x;\n\t\tFor(j,0,19) if (x!=j) pr[j][x]+=S[j];\n\t\t++S[x];\n\t}\n\t//printf(""%d\\n"",pr[2][3]);\n\tmemset(f,60,sizeof(f));\n\tf[0]=0;\n\tFor(i,0,(1<<20)-1)\n\t\tFor(j,0,19) if (!(i&(1<<j))){\n\t\t\tll s=f[i];\n\t\t\tFor(k,0,19) if (i&(1<<k))\n\t\t\t\ts+=pr[j][k];\n\t\t\tf[i|(1<<j)]=min(f[i|(1<<j)],s);\n\t\t}\n\tprintf(""%lld\\n"",f[(1<<20)-1]);\n}']","['bitmasks', 'dp']",2200
https://codeforces.com//contest/1717/problem/C,C. Madoka and Formal Statement,Given an array of integer a 1 a 2 ldots a n In one operation you can make a i a i 1 if i n and a i leq a i 1 or i n and a i leq a 1 You need to check whether the array a 1 a 2 ldots a n can become equal to the array b 1 b 2 ldots b n in some number of operations possibly zero Two arrays a and b of length n are called equal if a i b i for all integers i from 1 to n ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nint n, a[N], b[N];\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        cin >> b[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (b[i] < a[i]) {\n            cout << ""NO\\n"";\n            return;\n        }\n        if (b[i] > a[i]) {\n            int j = i == n ? 1 : (i + 1);\n            if (b[j] < b[i] - 1) {\n                cout << ""NO\\n"";\n                return;\n            }\n        }\n    }\n    cout << ""YES\\n"";\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}']",['greedy'],1300
