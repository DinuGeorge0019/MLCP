problem_link,problem_id,problem_idx,short_id,contest_number,problem_name,problem_statement,problem_solution,problem_input,problem_output,problem_tags,problem_dificulty,file_name,editorial_link,problem_editorial
https://codeforces.com//contest/815/problem/A,110359,A,815A,815,A. Karen and Game,On the way to school Karen became fixated on the puzzle game on her phone The game is played as follows In each level you have a grid with rows and columns Each cell originally contains the number One move consists of choosing one row or column and adding to all of the cells in that row or column To win the level after all the moves the number in the cell at the th row and th column should be equal to Karen is stuck on one level and wants to know a way to beat this level using the minimum number of moves Please help her with this task ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=107;\nconst int inf=1e6;\n\nint n, m;\n\nint tab[nax][nax];\n\nvector < pair <int,int> > wek;\n\nvoid check()\n{\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tif (tab[i][j])\n\t\t\t{\n\t\t\t\tprintf(""-1\\n"");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tscanf(""%d"", &tab[i][j]);\n\t\t\t\n\tint naj=inf;\n\tfor (int i=1; i<=m; i++)\n\t\tnaj=min(naj, tab[1][i]);\n\t\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\twhile(tab[1][i]!=naj)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\ttab[j][i]--;\n\t\t\twek.push_back({0, i});\n\t\t}\n\t}\n\tnaj=inf;\n\tfor (int i=1; i<=n; i++)\n\t\tnaj=min(naj, tab[i][1]);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twhile(tab[i][1]!=naj)\n\t\t{\n\t\t\tfor (int j=1; j<=m; j++)\n\t\t\t\ttab[i][j]--;\n\t\t\twek.push_back({1, i});\n\t\t}\n\t}\n\t\n\tnaj=tab[1][1];\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\ttab[i][j]-=naj;\n\t\n\tif (n<m)\n\t{\n\t\tfor (int i=1; i<=n; i++)\t\n\t\t\tfor (int j=1; j<=naj; j++)\n\t\t\t\twek.push_back({1, i});\n\t}\n\telse\n\t{\n\t\tfor (int i=1; i<=m; i++)\t\n\t\t\tfor (int j=1; j<=naj; j++)\n\t\t\t\twek.push_back({0, i});\n\t}\n\t\n\tcheck();\n\tprintf(""%d\\n"", (int)wek.size());\n\tfor (auto i : wek)\n\t{\n\t\tif (i.first)\n\t\t\tprintf(""row "");\n\t\telse\n\t\t\tprintf(""col "");\n\t\tprintf(""%d\\n"", i.second);\n\t}\n\t\n\treturn 0;\n}\n']",,,"['brute force', 'greedy', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Karen and Game.json,https://codeforces.com//blog/entry/52742,Fix the number of times we choose the first row Say we choose the first row times This actually uniquely determines the rest of the solution consider the cells on the first row There is no other way to increase these cells except by choosing the columns they are on and so we need to choose the th column times Now once we know the number of times we have to choose each column we will also know how many times to choose the remaining rows At this point for any given row the remaining number of times we have to choose it is this should be the same for all in a given row otherwise there is no solution We can simply try all see if they can form a valid solution and if so calculate how many moves it will take Find the smallest required number of moves and then recover the solution Implemented properly it should run in time which should be fast enough Note that there are possible choices for and testing a certain can be done in time A solution will have at most moves so printing them will take that much time Overall this solution hence runs in time which is acceptable There is a faster solution to this both in terms of runtime and implementation time which we will describe below Notice that when there is a on the grid all the moves are already fixed If the is at then we need to choose row exactly times and column exactly times What if there is no on the grid Well we intuitively want to reduce numbers as much as possible and in fact the greedy algorithm works here If there are not more rows we should keep choosing rows and if there are fewer columns we should keep choosing columns until there is a It doesn t even matter which particular rows or columns we choose for example if we could just keep choosing row until a appears or we could choose all rows in order and just keep cycling through them The end result will be the same We can just check that the grid is correct at the end and print otherwise Implemented properly this runs in which is asymptotically optimal it takes at least time to read the input and to print the output 
https://codeforces.com//contest/960/problem/C,172420,C,960C,960,C. Subsequence Counting,Pikachu had an array with him He wrote down all the non empty subsequences of the array on paper Note that an array of size has non empty subsequences in it Pikachu being mischievous as he always is removed all the subsequences in which Pikachu was finally left with subsequences However he lost the initial array he had and now is in serious trouble He still remembers the numbers and He now wants you to construct any such array which will satisfy the above conditions All the numbers in the final array should be positive integers less than Note the number of elements in the output array should not be more than If no answer is possible print ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint X,d;\nll cur;\nvector<ll> ret;\nint main() {\n\tscanf(""%d%d"",&X,&d);\n\tcur=1;\n\twhile (X) {\n\t\tper(i,0,30) {\n\t\t\tif (X>=(1<<i)-1) {\n\t\t\t\trep(j,0,i) ret.pb(cur);\n\t\t\t\tX-=(1<<i)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcur+=d+1;\n\t}\n\tprintf(""%d\\n"",SZ(ret));\n\tfor (auto p:ret) printf(""%lld "",p); puts("""");\n}\n']",,,"['bitmasks', 'constructive algorithms', 'greedy', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Subsequence Counting.json,https://codeforces.com//blog/entry/58802,Let s call a subsequence valid if the difference of maximum element and minimum element is less than d For an array of size with all the elements equal there are non empty subsequences and all of them are valid This is because for any subsequence the difference of maximum element and minimum element is always zero We will use this observation in constructing the answer Let s look at the binary representation of If the bit is set in X we will add equal elements let s say in our final array However this would give us non empty valid subsequences To correct this we will add a separate element in the final array so that the final contribution of bit becomes We will carry out the same process for all the bits keeping a counter of the previous In this way the length of the final array will never exceed 600 elements Expected Complexity O logX logX 
https://codeforces.com//contest/385/problem/E,5935,E,385E,385,E. Bear in the Field,Our bear s forest has a checkered field The checkered field is an table the rows are numbered from 1 to from top to bottom the columns are numbered from 1 to from left to right Let s denote a cell of the field on the intersection of row and column by record Each cell of the field contains growing raspberry at that the cell of the field contains raspberry bushes The bear came out to walk across the field At the beginning of the walk his speed is Then the bear spends exactly seconds on the field Each second the following takes place Let s suppose that at the current moment the bear is in cell First the bear eats the raspberry from all the bushes he has in the current cell After the bear eats the raspberry from bushes he increases each component of his speed by In other words if before eating the bushes of raspberry his speed was then after eating the berry his speed equals Let s denote the current speed of the bear it was increased after the previous step Then the bear moves from cell to cell Then one additional raspberry bush grows in each cell of the field You task is to predict the bear s actions Find the cell he ends up in if he starts from cell Assume that each bush has infinitely much raspberry and the bear will never eat all of it ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int kMat[6][6] = {\n    2, 1, 1, 0, 1, 2,\n    1, 2, 0, 1, 1, 2,\n    1, 1, 1, 0, 1, 2,\n    1, 1, 0, 1, 1, 2,\n    0, 0, 0, 0, 1, 1,\n    0, 0, 0, 0, 0, 1\n};\nint n, sx, sy, dx, dy;\nll t;\n\nstruct Matrix {\n    int v[6][6];\n    void clear() {\n        memset(v, 0, sizeof(v));\n    }\n    Matrix() {\n        clear();\n    }\n} e, f, a;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n    Matrix c;\n    for (int i = 0; i < 6; ++ i)\n        for (int j = 0; j < 6; ++ j)\n            for (int k = 0; k < 6; ++ k)\n                c.v[i][j] = (c.v[i][j] + (ll)a.v[i][k] * b.v[k][j] % n) % n;\n    return c;\n}\n\nMatrix mat_pow(const Matrix &a, ll b) {\n    Matrix res = e, tmp = a;\n    while (b) {\n        if (b & 1) res = res * tmp;\n        b >>= 1;\n        tmp = tmp * tmp;\n    }\n    return res;\n}\n\nint main() {\n    scanf(""%d%d%d%d%d%I64d"", &n, &sx, &sy, &dx, &dy, &t);\n    -- sx, -- sy;\n    dx = (dx % n + n) % n;\n    dy = (dy % n + n) % n;\n    for (int i = 0; i < 6; ++ i) e.v[i][i] = 1;\n    memcpy(f.v, kMat, sizeof(kMat));\n    a.v[0][0] = sx, a.v[1][0] = sy;\n    a.v[2][0] = dx, a.v[3][0] = dy;\n    a.v[4][0] = 0, a.v[5][0] = 1;\n    a = mat_pow(f, t) * a;\n    printf(""%d %d\\n"", a.v[0][0] + 1, a.v[1][0] + 1);\n    return 0;\n}\n']",,,"['math', 'matrices']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Bear in the Field.json,https://codeforces.com//blog/entry/10514,In this task there are several problems that should be concerned 1 Simple modeling of bear movement would cause TLE due to 2 Task can t be solved by separating and axes because and depends on each other 3 Also we can t use standart method of cycle finding via modeling for a short time and checking on collisions because coordinates limitations are very large Let s say we have matrix If we multiply previous matrix by following matrix long long base 6 6 2 1 1 1 0 0 1 2 1 1 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 1 1 1 0 0 0 2 2 1 1 we will have get parameters on next step Where did the matrix Let us write out how to change parameters with each step and see the similarity matrix So if we calculate power of and then multiply by it we will calculate parameters at moment Power of matrix can be calculated via binary power modulo algo due to associativity of matrix multiplication More info at http e maxx ru algo binary pow Using trivial matrix multiplication algo we will solve this task in time proportional 
https://codeforces.com//contest/1624/problem/C,1256439,C,1624C,1624,C. Division by Two and Permutation,You are given an array a consisting of n positive integers You can perform operations on it In one operation you can replace any element of the array a i with lfloor frac a i 2 rfloor that is by an integer part of dividing a i by 2 rounding down See if you can apply the operation some number of times possible 0 to make the array a become a permutation of numbers from 1 to n that is so that it contains all numbers from 1 to n each exactly once For example if a 1 8 25 2 n 4 then the answer is yes You could do the following Replace 8 with lfloor frac 8 2 rfloor 4 then a 1 4 25 2 Replace 25 with lfloor frac 25 2 rfloor 12 then a 1 4 12 2 Replace 12 with lfloor frac 12 2 rfloor 6 then a 1 4 6 2 Replace 6 with lfloor frac 6 2 rfloor 3 then a 1 4 3 2 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << \' \', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 50 + 10;\nconst int mod = 998244353;\nint c[N];\nint a[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        bool ok = true;\n        for (int i = 1; i <= n; ++i) {\n            cin >> a[i];\n        }\n        memset(c, 0, sizeof c);\n        sort(a + 1, a + 1 + n);\n        reverse(a + 1, a + 1 + n);\n        for (int i = 1; i <= n; ++i) {\n            int x = a[i];\n            for (; x > n; x /= 2)\n                ;\n            for (; x > 0 && c[x]; x /= 2)\n                ;\n            if (x == 0) {\n                ok = false;\n                break;\n            }\n            c[x] = true;\n        }\n        cout << (ok ? ""YES"" : ""NO"") << \'\\n\';\n    }\n}']",,,"['constructive algorithms', 'flows', 'graph matchings', 'greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Division by Two and Permutation.json,https://codeforces.com//blog/entry/98942,Let s sort the array in descending order of the values of its elements Then let s create a logical array where will have the value if we already got element of the permutation we are looking for and the value otherwise We loop through the elements of the array and assign We ll divide by as long as it exceeds or as long as is If it turns out that then all the numbers that could be obtained from have already been obtained before Since each element of the array must produce a new value from to the answer cannot be constructed output Otherwise assign a value of this means that the number which is an element of the permutation we will get exactly from the original number After processing all elements of the array we can output 
https://codeforces.com//contest/911/problem/B,142496,B,911B,911,B. Two Cakes,It s New Year s Eve soon so Ivan decided it s high time he started setting the table Ivan has bought two cakes and cut them into pieces the first cake has been cut into pieces and the second one into pieces Ivan knows that there will be people at the celebration including himself so Ivan has set plates for the cakes Now he is thinking about how to distribute the cakes between the plates Ivan wants to do it in such a way that all following conditions are met Each piece of each cake is put on some plate Each plate contains at least one piece of cake No plate contains pieces of both cakes To make his guests happy Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized Formally Ivan wants to know the maximum possible number such that he can distribute the cakes according to the aforementioned conditions and each plate will contain at least pieces of cake Help Ivan to calculate this number ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int n, a, b;\n    cin >> n >> a >> b;\n    for (int x = min(a, b); ; x--)\n    {\n        int p = a / x;\n        int q = b / x;\n        if (p + q >= n)\n        {\n            cout << x << \'\\n\';\n            return 0;\n        }\n    }\n\n    return 0;\n}\n']",,,"['binary search', 'brute force', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Two Cakes.json,https://codeforces.com/blog/entry/56771,Let s fix number of plates to have pieces of the first cake plates left for the other cake Obviously the most optimal way to distribute pieces to plates will lead to the minimum of pieces on a plate Now try every possible and take maximum of Overall complexity 
https://codeforces.com//contest/1496/problem/B,920581,B,1496B,1496,B. Max and Mex,You are given a multiset S initially consisting of n distinct non negative integers A multiset is a set that can contain some elements multiple times You will perform the following operation k times Add the element lceil frac a b 2 rceil rounded up into S where a operatorname mex S and b max S If this number is already in the set it is added again Here operatorname max of a multiset denotes the maximum integer in the multiset and operatorname mex of a multiset denotes the smallest non negative integer that is not present in the multiset For example operatorname mex 1 4 0 2 3 operatorname mex 2 5 1 0 Your task is to calculate the number of elements in S after k operations will be done ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\nconst int N=100005;\nint n,k,a[N],T;\nmap<int,int>flag;\nint main(){\n\tcin>>T;\n\twhile (T--){\n\t\tcin>>n>>k;\n\t\tfor (int i=1;i<=n;i++)cin>>a[i];\n\t\tif (!k){\n\t\t\tprintf(""%d\\n"",n);\n\t\t\tcontinue;\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tint mex=0,Max=0;\n\t\tfor (int i=1;i<=n;i++)flag[a[i]]=1,Max=max(Max,a[i]);\n\t\twhile (flag[mex])mex++;\n\t\tif (mex>Max)printf(""%d\\n"",n+k);\n\t\telse if (!flag[(mex+Max+1)/2])printf(""%d\\n"",n+1);\n\t\telse printf(""%d\\n"",n);\n\t\tfor (int i=1;i<=n;i++)flag[a[i]]=0;\n\t}\n}\n']",,,['math'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Max and Mex.json,https://codeforces.com//blog/entry/88533,Let When the answer is Otherwise if then so It s not hard to find out that so the set always satisfies So the answer is when Otherwise So In that case is always true So the element we add in all operations is always Just check whether it is in at first The time complexity is or for each test case depending on your implementation 
https://codeforces.com//contest/342/problem/D,3441,D,342D,342,D. Xenia and Dominoes,Xenia likes puzzles very much She is especially fond of the puzzles that consist of domino pieces Look at the picture that shows one of such puzzles A puzzle is a table with forbidden cells black squares containing dominoes colored rectangles on the picture A puzzle is called if it meets the following conditions each domino occupies exactly two non forbidden cells of the table no two dominoes occupy the same table cell exactly one non forbidden cell of the table is unoccupied by any domino it is marked by a circle in the picture To solve the puzzle you need multiple steps to transport an empty cell from the starting position to some specified position A move is transporting a domino to the empty cell provided that the puzzle stays correct The picture shows a probable move Xenia has a table with forbidden cells and a cell marked with a circle Also Xenia has very many identical dominoes Now Xenia is wondering how many distinct correct puzzles she can make if she puts dominoes on the existing table Also Xenia wants the circle marked cell to be empty in the resulting puzzle The puzzle must contain at least one move Help Xenia count the described number of puzzles As the described number can be rather large print the remainder after dividing it by ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#define lson step << 1\n#define rson step << 1 | 1\n#define lowbit(x) (x & (-x))\n#define Key_value ch[ch[root][1]][0] \nusing namespace std;\ntypedef long long LL;\nconst int N = 10005;\nconst int MOD = 1000000007;\nchar str[3][N];\nint n , sx , sy;\nvector<pair<pair<int ,int> , pair<int , int> > > v;\nint dp[N][1 << 3];\nvoid add (int &a , int b) {\n    a = (a + b) % MOD;\n    a = (a + MOD) % MOD;\n}\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n        // freopen (""output.txt"" , ""w"" , stdout);\n    #endif\n    cin >> n;\n    int ans = 0;\n    for (int i = 0 ; i < 3 ; i ++) {\n        scanf (""%s"" , str[i] + 1);\n        for (int j = 1 ; j <= n ; j ++)\n            if (str[i][j] == \'O\') {\n                sx = i ; sy = j ;\n            }\n    }\n    if (sx == 0) {\n        if (str[sx + 1][sy] == \'.\' && str[sx + 2][sy] == \'.\') {\n            v.push_back (make_pair(make_pair(sx + 1 , sy) , make_pair(sx + 2 , sy)));\n        }\n    }\n    if (sx == 2) {\n        if (str[sx - 1][sy] == \'.\' && str[sx - 2][sy] == \'.\') {\n            v.push_back (make_pair(make_pair(sx - 1 , sy) , make_pair(sx - 2 , sy)));\n        }\n    }\n    if (sy > 2) {\n        if (str[sx][sy - 1] == \'.\' && str[sx][sy - 2] == \'.\') {\n            v.push_back (make_pair(make_pair(sx , sy - 1) , make_pair(sx, sy - 2)));\n        }\n    }\n    if (sy <= n - 2) {\n        if (str[sx][sy + 1] == \'.\' && str[sx][sy + 2] == \'.\') {\n            v.push_back (make_pair(make_pair(sx , sy + 1) , make_pair(sx, sy + 2)));\n        }\n    }\n    int m = v.size();\n    for (int mask = 1 ; mask < (1 << m) ; mask ++) {\n        int cnt = 0;\n        for (int j = 0 ; j < m ; j ++) {\n            if (mask & (1 << j)) {\n                cnt ++;\n                str[v[j].first.first][v[j].first.second] = \'X\';\n                str[v[j].second.first][v[j].second.second] = \'X\';\n            }\n        }\n            memset (dp , 0 ,sizeof(dp));\n            dp[1][0] = 1;\n            for (int i = 1 ; i <= n ; i ++) {\n                for (int j = 0 ; j < (1 << 3) ; j ++) {\n                    if (dp[i][j] == 0) continue;\n                    int remain = 7 - j;\n                    for (int k = 0 ; k < 3; k  ++)\n                        if ((remain & (1 << k)) && str[k][i] != \'.\')\n                            remain -= 1 << k;\n                    if (remain == 0) {\n                        add (dp[i + 1][0] , dp[i][j]);\n                    }\n                    for (int k = 0 ; k < 3 ; k ++) {\n                        if ((1 << k) == remain) {\n                            if (str[k][i + 1] == \'.\') {\n                                add (dp[i + 1][1 << k] , dp[i][j]);\n                            }\n                        }\n                    }\n                    if (remain == 3) {\n                        add (dp[i + 1][0] , dp[i][j]);\n                        if (str[0][i + 1] == \'.\' && str[1][i + 1] == \'.\')\n                            add (dp[i + 1][3] , dp[i][j]);\n                    }\n                    if (remain == 6) {\n                        add (dp[i + 1][0] , dp[i][j]);\n                        if (str[2][i + 1] == \'.\' && str[1][i + 1] == \'.\')\n                            add (dp[i + 1][6] , dp[i][j]);\n                    }\n                    if (remain == 5) {\n                        if (str[2][i + 1] == \'.\' && str[0][i + 1] == \'.\')\n                            add (dp[i + 1][5] , dp[i][j]);\n                    }\n                    if (remain == 7) {\n                        if (str[2][i + 1] == \'.\' && str[0][i + 1] == \'.\' && str[1][i + 1] == \'.\')\n                            add (dp[i + 1][7] , dp[i][j]);\n                        if (str[0][i + 1] == \'.\')\n                            add (dp[i + 1][1] , dp[i][j]);\n                        if (str[2][i + 1] == \'.\')\n                            add (dp[i + 1][4] , dp[i][j]);\n                    }\n                }\n            }\n        if (cnt & 1) add (ans , dp[n + 1][0]);\n        else add (ans , -dp[n + 1][0]);\n        for (int j = 0 ; j < m ; j ++) {\n            if (mask & (1 << j)) {\n                str[v[j].first.first][v[j].first.second] = \'.\';\n                str[v[j].second.first][v[j].second.second] = \'.\';\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}       \n\n']",,,"['bitmasks', 'dfs and similar', 'dp']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Xenia and Dominoes.json,https://codeforces.com/blog/entry/8800,In the problem you can count number of correct puzzles or substract number of incorrect puzzles from number of all puzzles In any case you should count DP where the state is number of the last full column mask of the last column This problem is equivalent to the well known problem about domino tiling or the problem about parquet To get the solution of the whole problem I did the following I try to attach one domino to each of 4 directions then paint all three cells in black and count the number of correct puzzles But in this case you will count some solutions several number of times So you need to use inclusion exclusion formula for these 4 directions 
https://codeforces.com//contest/246/problem/C,2237,C,246C,246,C. Beauty Pageant,General Payne has a battalion of soldiers The soldiers beauty contest is coming up it will last for days Payne decided that his battalion will participate in the pageant Now he has choose the participants All soldiers in the battalion have different beauty that is represented by a positive integer The value represents the beauty of the th soldier On each of days Generals has to send a detachment of soldiers to the pageant The beauty of the detachment is the sum of the beauties of the soldiers who are part of this detachment Payne wants to surprise the jury of the beauty pageant so each of days the beauty of the sent detachment should be unique In other words all beauties of the sent detachments must be distinct numbers Help Payne choose detachments of different beauties for the pageant Please note that Payne cannot just forget to send soldiers on one day that is the detachment of soldiers he sends to the pageant should never be empty ,"['#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n\nint a[100], n;\nint q[100*100], s[100*100][100], t, k;\nint main()\n{\n    scanf(""%d %d"", &n, &k);\n    for (int i=0; i<n; i++) scanf(""%d"", &a[i]);\n    sort(a, a+n);\n    for (int i=0; i<n; i++)\n    {\n        for (int j=0; j+i<n; j++)\n        {\n            for (int l=0; l<i; l++)\n                s[t][q[t]++]=a[n-l-1];\n            s[t][q[t]++]=a[j];\n            t++;\n        }\n    }\n    for (int i=0; i<k;i++)\n    {\n        printf(""%d"", q[i]);\n        for (int j=0; j<q[i]; j++)\n            printf("" %d"", s[i][j]);\n        puts("""");\n    }\n    return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Beauty Pageant.json,https://codeforces.com//blog/entry/5934,This problem was rather mathematical The correct solution is firstly take every element once then take the maximum and any other then two maximums and any other then three maximums and any other and so on In this case you get as many sets as you need in this problem It is easy to check that all sums will be different 
https://codeforces.com//contest/916/problem/C,148026,C,916C,916,C. Jamie and Interesting Graph,Jamie has recently found undirected weighted graphs with the following properties very The graph is connected and contains exactly vertices and edges All edge weights are integers and are in range inclusive The length of shortest path from to is a prime number The sum of edges weights in the minimum spanning tree MST of the graph is a prime number The graph contains no loops or multi edges If you are not familiar with some terms from the statement you can find definitions of them in notes section Help Jamie construct any graph with given number of vertices and edges that is ,"[""#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint q,i,j,k,n,m,y,z,c,mx2,t,s;\nint a,b,p,A,B,H[100005];\nint x = 384437;\nint main(){\n    cin >> n >> m;\n\n    cout << x << ' ' << x << endl;\n\n    for(i=1 ; i<n-1 ; i++)\n        cout << i << ' ' << i+1 << ' ' << 1 << endl;\n\n    cout << i << ' ' << i+1 << ' ' << x-(n-2) << endl;\n\n    m -= n-1;\n\n    for(i=1 ; i<=n ; i++){\n        for(j=i+2 ; j<=n and m; j++){\n            m--;\n            cout << i << ' ' << j << ' ' << 100000000 << endl;\n        }\n    }\n\n}\n""]",,,"['constructive algorithms', 'graphs', 'shortest paths']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Jamie and Interesting Graph.json,https://codeforces.com//blog/entry/57223,First observe that only edges are required to fulfil the requirement so we will make the other edges with a very large number so they would not contribute to the shortest path or the MST Now the problem is reduced to building a tree with prime weight sum and two nodes in the tree have prime distance Recall that a path graph is also a tree If we join for all the shortest path will lie on the whole tree We are left with a problem finding numbers that sum to a prime Let s make 1 edge with weight and others with weight Choosing a prime slightly larger than e g will fulfil the requirement for all cases My implementation 34342305 
https://codeforces.com//contest/1856/problem/C,2145354,C,1856C,1856,C. To Become Max,You are given an array of integers a of length n In one operation you Choose an index i such that 1 le i le n 1 and a i le a i 1 Increase a i by 1 Find the maximum possible value of max a 1 a 2 ldots a n that you can get after performing this operation at most k times ,"['#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\n\nconst int N = 1005;\nint n, k;\nll a[N];\n\nbool can(int id, ll what, int ops){\n    if(id > n) return false;\n    if(ops < 0) return false;\n    ll used = max(0LL, what - a[id]);\n    if(a[id] >= what) return true;\n    return can(id + 1, what - 1, ops - used);\n}\n\nvoid solve(){\n    cin >> n >> k;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        ll lo = 0;\n        ll hi = 1e9;\n        while(lo < hi){\n            ll mid = (lo + hi + 1) / 2;\n            if(can(i, mid, k)) lo = mid;\n            else hi = mid - 1;\n        }\n        ans = max(ans, lo);\n    }\n    cout << ans << ""\\n"";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n']",,,"['binary search', 'brute force', 'data structures', 'dp']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. To Become Max.json,https://codeforces.com//blog/entry/119058,We will do binary search on the answer The lower bound can be set to while is clearly enough for the upper bound Let be some resulting array after performing at most operations Suppose for some we want to check if we can get in at most operations That is there must exist some index such that So let s iterate from to and check if it possible to have in at most operations Let be the minimum number of operations needed to make Then for all for all and for and all It is easy to see that calculating takes time for one call in the worst case Thus our check consists of comparing and for all from to If at least one of the values is it is possible to have some in at most operations and we increase the lower bound in the binary search after updating the current answer Otherwise it is impossible and we decrease the upper bound Complexity where A is the maximum possible value of and Notes You can get a solution by setting the lower bound in the binary search to and the upper bound to There exists a dp solution that relies on the fact that the answer lies in the range 
https://codeforces.com//contest/837/problem/F,116712,F,837F,837,F. Prefix Sums,Consider the function where is an array of integers which returns an array consisting of integers such that is equal to the sum of first elements of array You have an infinite sequence of arrays where is given in the input and for each Also you have a positive integer You have to find minimum possible such that contains a number which is larger or equal than ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 3234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nll mymul(ll a, ll b) {\n\tif (a == 0 || b == 0) return 0;\n\tif (LL_INF / b < a) return LL_INF;\n\treturn min(LL_INF, a*b);\n}\n\nll C1[1050][1050];\nll C2[2200050][11];\nll C(ll a, ll b) {\n\tif (a <= 1000) return C1[a][b];\n\t\n\tif (b >= a / 2) b = a - b;\n\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tif (b == 2) return mymul(a, a - 1) / 2;\n\tif (a >= 2200000) return LL_INF;\n\tif (b <= 10) return C2[a][b];\n\telse return LL_INF;\n}\n\nll in[200050];\nint main() {\n\tint i, j;\n\tfor (i = 0; i <= 1000; i++) {\n\t\tC1[i][0] = C1[i][i] = 1;\n\t\tfor (j = 1; j < i; j++) C1[i][j] = min(C1[i - 1][j] + C1[i - 1][j - 1], LL_INF);\n\t}\n\tfor (i = 0; i <= 2200000; i++) {\n\t\tC2[i][0] = 1;\n\t\tif (i <= 10) C2[i][i] = 1;\n\t\tfor (j = 1; j < i && j <= 10; j++) C2[i][j] = min(C2[i - 1][j] + C2[i - 1][j - 1], LL_INF);\n\t}\n\n\tint N;\n\tll K;\n\tscanf(""%d %lld"", &N, &K);\n\tint st = N;\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(""%lld"", &in[i]);\n\t\tif (in[i] >= K) return !printf(""0\\n"");\n\t\tif (in[i]) st = min(st, i);\n\t}\n\t\n\tll s = 1, e = LL_INF, m, r = LL_INF + 1;\n\tif (st < N - 2) e = 2000000;\n\n\twhile (s <= e) {\n\t\tm = (s + e) / 2;\n\n\t\tll v = 0;\n\t\tfor (i = 1; i <= N; i++) v = min(LL_INF, v + mymul(C(N - i + m - 1, m - 1), in[i]));\n\t\tif (v >= K) {\n\t\t\tr = m;\n\t\t\te = m - 1;\n\t\t}\n\t\telse s = m + 1;\n\t}\n\treturn !printf(""%lld\\n"", r);\n}']",,,"['binary search', 'brute force', 'combinatorics', 'math', 'matrices']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Prefix Sums.json,https://codeforces.com//blog/entry/53662,Let s delete all zeroes from the beginning of the array they won t affect the answer Also we will return an array of elements when calculating prefix sums sum of zero elements becomes a zero in the beginning of the array and so has to be removed If the size of array is at least then we will get after calculating only a few prefix sums so we can use simple iteration So now we have to obtain the solution in case array has less than elements If we remove zeroes from the beginning of each array then where is a matrix if otherwise Then we can use matrix exponentiation to check whether contains a number which is equal to or greater than and we can use binary search to find the answer To avoid overflows each time we get a number greater than we can set it to 
https://codeforces.com//contest/976/problem/D,179788,D,976D,976,D. Degree Set,You are given a sequence of positive integers Your task is to construct an undirected graph such that there are exactly vertices there are no self loops there are no multiple edges there are no more than edges its is equal to Vertices should be numbered through is an array with length equal to the number of vertices in a graph such that is the number of vertices adjacent to th vertex is a sorted in increasing order sequence of all distinct values from the It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than edges Print the resulting graph ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in[305];\n\nbool chk[1050][1050];\nint main() {\n\tint N, i, j, k;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in[i]);\n\n\tint X = in[N] + 1;\n\n\tint st = 1, en = in[N] + 1;\n\tint sti = 1, eni = N;\n\twhile (1) {\n\t\tif (sti == eni) {\n\t\t\tfor (i = st; i <= en; i++) for (j = i + 1; j <= en; j++) chk[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (sti + 1 == eni) {\n\t\t\tfor (i = st; i < st + in[sti]; i++) for (j = st; j <= en; j++) chk[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = sti + 1; i <= eni - 1; i++) in[i] -= in[sti];\n\n\t\tfor (i = st; i < st + in[sti]; i++) for (j = st; j <= en; j++) chk[i][j] = true;\n\t\tst = st + in[sti];\n\t\ten = st + in[eni - 1];\n\t\tsti++, eni--;\n\t}\n\t\n\tvector <pii> Va;\n\tfor (i = 1; i <= X; i++) for (j = i + 1; j <= X; j++) if (chk[i][j] || chk[j][i]) Va.emplace_back(i, j);\n\n\tprintf(""%d\\n"", (int)Va.size());\n\tfor (auto it : Va) printf(""%d %d\\n"", it.first, it.second);\n}']",,,"['constructive algorithms', 'graphs', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Degree Set.json,https://codeforces.com//blog/entry/59195,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
https://codeforces.com//contest/1729/problem/A,1538782,A,1729A,1729,A. Two Elevators,Vlad went into his appartment house entrance now he is on the 1 th floor He was going to call the elevator to go up to his apartment There are only two elevators in his house Vlad knows for sure that the first elevator is currently on the floor a it is currently motionless the second elevator is located on floor b and goes to floor c b ne c Please note if b 1 then the elevator is already leaving the floor 1 and Vlad does not have time to enter it If you call the first elevator it will immediately start to go to the floor 1 If you call the second one then first it will reach the floor c and only then it will go to the floor 1 It takes x y seconds for each elevator to move from floor x to floor y Vlad wants to call an elevator that will come to him faster Help him choose such an elevator ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    int a, b, c;\n    cin >> a >> b >> c;\n\n    int t1 = a - 1;\n    int t2 = abs(b - c) + c - 1;\n\n\n    if(t1 < t2)\n        done(1);\n\n    if(t1 > t2)\n        done(2);\n\n    done(3);\n\n\n    \n    \n\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']",,,['math'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Two Elevators.json,https://codeforces.com//blog/entry/106916,You had to to calculate the time that each elevator would need and compare them Let the time required by the first elevator be and the time required by the second one be Then the answer is if if and if 
https://codeforces.com//contest/1517/problem/C,965873,C,1517C,1517,C. Fillomino 2,Fillomino is a classic logic puzzle You do not need to know Fillomino in order to solve this problem In one classroom in Yunqi town some volunteers are playing a board game variant of it Consider an n by n chessboard Its rows are numbered from 1 to n from the top to the bottom Its columns are numbered from 1 to n from the left to the right A cell on an intersection of x th row and y th column is denoted x y The main diagonal of the chessboard is cells x x for all 1 le x le n A permutation of 1 2 3 dots n is written on the main diagonal of the chessboard There is exactly one number written on each of the cells The problem is to partition the cells under and on the main diagonal there are exactly 1 2 ldots n such cells into n connected regions satisfying the following constraints Every region should be connected That means that we can move from any cell of a region to any other cell of the same region visiting only cells of the same region and moving from a cell to an adjacent cell The x th region should contain cell on the main diagonal with number x for all 1 le x le n The number of cells that belong to the x th region should be equal to x for all 1 le x le n Each cell under and on the main diagonal should belong to exactly one region ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint main() {\n\tsetIO();\n\tints(N);\n\tvi P(N); re(P);\n\tV<vi> ans(N,vi(N));\n\tF0R(i,N) ans[i][i] = P[i];\n\tdbg(""HA"",ans);\n\tF0R(diag,N-1) {\n\t\tpi nex{diag+1,0};\n\t\tF0R(i,N-diag) {\n\t\t\tif (ans[diag+i][i] == 1) continue;\n\t\t\t// dbg(""WUT"",nex,mp(i,diag+i));\n\t\t\tans[nex.f][nex.s] = ans[diag+i][i]-1;\n\t\t\t++nex.f,++nex.s;\n\t\t}\n\t}\n\tF0R(i,N) {\n\t\tF0R(j,i+1) {\n\t\t\tpr(ans[i][j]+i-j,\' \');\n\t\t}\n\t\tps();\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']",,,"['constructive algorithms', 'dfs and similar', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Fillomino 2.json,https://codeforces.com//blog/entry/89968,The answer is unique and always exists There are two ways to construct the answer Construction 1 Start with the main diagonal There is one cell with number on it That cell must form a region by itself For each cell on the main diagonal that is above the cell belongs to the same region as We write the number on minus on the cell and make belong to the same region as For each cell on the main diagonal that is below the cell belongs to the same region as We write the number on minus on the cell and make belong to the same region as Then a permutation of are written on the cells We can continue this process on this subdiagonal Then a oermutation of will be written on the cells Repeat until all cells have numbers written on them Note that the numbers written on the cells are not the output Put for the region with size after constructing the regions This construction proves that the solution always exists and is unique Construction 2 Construct the region for in order When starting at we walk from for steps where is the number written on For each step if the cell to the left of your current cell is empty we go to that cell and write on it Otherwise we go down and write there We can prove that the second construction produces exactly the same answer as the first construction They only differ in their orders of processing The regions are always paths 
https://codeforces.com//contest/1256/problem/D,459827,D,1256D,1256,D. Binary String Minimizing,You are given a binary string of length n i e a string consisting of n characters and In one move you can swap two adjacent characters of the string What is the lexicographically minimum possible string you can obtain from the given one if you can perform than k moves It is possible that you do not perform any moves at all Note that you can swap the same pair of adjacent characters with indices i and i 1 arbitrary possibly zero number of times Each such swap is considered a separate move You have to answer q independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXA=2e6;\nlong long sum,k;\nchar s[MAXA];\nint n,j;\nvoid solve(){\n    sum=0;\n    scanf(""%d%lld"",&n,&k);\n    scanf(""%s"",s+1);\n    for(int i=1;i<=n;i++){\n\tif(s[i]==\'1\'){\n\t    sum++;\n\t}else{\n\t    if(k>=sum) k-=sum;\n\t    else{\n\t\tsum-=k;\n\t\tfor(j=i;k;j--)\n\t\t    if(k>0)\n\t\t\tk--,s[j]=\'1\';\n\t\tif(j) s[j--]=\'0\';\n\t\tfor(;j;j--)\n\t\t    if(sum>0) sum--,s[j]=\'1\';\n\t\t    else s[j]=\'0\';\n\t\tk=-1;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if(k>=0)\n\tfor(int i=n;i;i--)\n\t    if(sum>0) sum--,s[i]=\'1\';\n\t    else s[i]=\'0\';\n    for(int i=1;i<=n;i++) printf(""%c"",s[i]);\n    printf(""\\n"");\n}\nint main(){\n    int T;\n    scanf(""%d"",&T);\n    while(T--) solve();\n}']",,,['greedy'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Binary String Minimizing.json,https://codeforces.com//blog/entry/71184,This problem has a very standard solution let s take the leftmost zero place it as left as possible and solve the problem without this zero and all operations we spent But we should do it fast Let s go from left to right and carry the number of ones on the prefix If we meet let s just increase and continue the algorithm It is obvious that if we meet we need to make exactly swaps to place it before all ones If we can do it let s just add to the answer decrease by and continue Otherwise this zero will be between some of these ones and we can place it naively In this case the suffix of the string will not change If after all operations we didn t meet the case above let s add all ones to the suffix of the resulting string Time complexity 
https://codeforces.com//contest/58/problem/A,302,A,58A,58,A. Chat room,Vasya has recently learned to type and log on to the Internet He immediately entered a chat room and decided to say hello to everybody Vasya typed the word It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word For example if Vasya types the word it will be considered that he said hello and if he types it will be considered that Vasya got misunderstood and he didn t manage to say hello Determine whether Vasya managed to say hello by the given word ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define MM(a , x) memset(a , x , sizeof(a))\n#define sqr(x) ((x) * (x))\n#define abs(x) ((x > 0) ? (x) : -(x))\n#define REP(i , n) for ((i) = 0; (i) < (n); ++(i))\n#define FOR(i , a , b) for ((i) = (a); (i) <= (b); ++(i))\n#define FORD(i , a , b) for ((i) = (a); (i) >= (b); --(i))\ntypedef long long LL;\n\nstring st , pat;\n\nint main()\n{\n\tcin >> st;\n\tpat += ""hello"";\n\tint i , j , k;\n\tj = 0;\n\tREP (i , st.length())\n\t{\n\t\tif (st[i] == pat[j]) j++;\n\t\tif (j == 5) break;\n\t}\n\tif (j == 5) printf(""YES\\n""); else printf(""NO\\n"");\n\treturn 0;\n}\n']",,,"['greedy', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Chat room.json,https://codeforces.com//blog/entry/1771,Solution is greedy algorithm The first thing we do is find in our string the first letter h Then we find letter e which is righter that found h If we find the whole word hello in such way obliviously answer is YES Now let s prove that if answer exists we find it Let see on position of the h in right answer If we move it to the first h in our string nothing changes But now we can say that our greedy algorithm correctly Now let s do such with the second letter and so on We have greedy algorithm with work time O n where n length of the input 
https://codeforces.com//contest/864/problem/A,124133,A,864A,864,A. Fair Game,Petya and Vasya decided to play a game They have cards is an even number A single integer is written on each card Before the game Petya will choose an integer and after that Vasya will choose another integer from the number that Petya chose During the game each player takes all the cards with number he chose For example if Petya chose number before the game he will take all cards on which is written and if Vasya chose number before the game he will take all cards on which is written The game is considered fair if Petya and Vasya can take all cards and the number of cards each player gets is the same Determine whether Petya and Vasya can choose integer numbers before the game so that the game is fair ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint a[110];\nint main()\n{\n\tint n;\n\tscanf(""%d"",&n);\n\tif(n&1)\n\t{\n\t\tprintf(""NO\\n"");\n\t\treturn 0;\n\t}\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(""%d"",&a[i]);\n\tsort(a+1,a+n+1);\n\tint m=n/2;\n\tfor(i=1;i<m;i++)\n\t\tif(a[i]!=a[i+1])\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=m+1;i<n;i++)\n\t\tif(a[i]!=a[i+1])\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\tif(a[m]==a[m+1])\n\t{\n\t\tprintf(""No\\n"");\n\t\treturn 0;\n\t}\n\tprintf(""YES\\n"");\n\tprintf(""%d %d\\n"",a[1],a[m+1]);\n\treturn 0;\n}']",,,"['implementation', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Fair Game.json,https://codeforces.com//blog/entry/54765,This problem has many different solutions Let s consider one of them At first sort all numbers in non descending order Then the first numbers must be equal to each other the following numbers must be equal to each other and the number from the first half must be different from the number from the second half So if all conditions are met after sorting the answer is Vasya must choose before the game number and Petya or vice versa If at least one from the described conditions is failed the answer is 
https://codeforces.com//contest/204/problem/C,1544,C,204C,204,C. Little Elephant and Furik and Rubik,Little Elephant loves Furik and Rubik who he met in a small city Kremenchug The Little Elephant has two strings of equal length and consisting only of uppercase English letters The Little Elephant selects a pair of substrings of equal length the first one from string the second one from string The choice is equiprobable among all possible pairs Let s denote the substring of as and the substring of as The Little Elephant gives string to Furik and string to Rubik Let s assume that is the number of such positions of that where is the length of lines and and are the th characters of strings and correspondingly Help Furik and Rubik find the expected value of ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef double ll;\ntypedef double ull;\n\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nchar a[222222];\nchar b[222222];\n\nvi v1[30];\nvi v2[30];\nint n;\nint u[222222];\nint now;\null same(vi v1,vi v2){\n\tull res = 0;\n\tnow++;\n\tREP(i,v1.size()) u[v1[i]]=now;\n\tREP(i,v2.size()) if(u[v2[i]]==now) res+=ull(v2[i]+1)*(n-v2[i]);\n\treturn res;\n}\n\null solve(vi v1,vi v2){\n\tull res = 0;\n\tull sum = 0;\n\tREP(i,v2.size()) sum += n - v2[i];\n\tint pos = 0;\n\tREP(i,v1.size()){\n\t\twhile(pos<v2.size() && v2[pos]<=v1[i]) sum -= (n - v2[pos]), pos++;\n\t\tres += sum * (v1[i] + 1);\n\t\t//cout<<""add ""<<sum<<""*""<<(v1[i]+1)<<endl;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tcin>>n;\n//\tn=200000;\n\n\tscanf("" %s %s"",a,b);\n\t//REP(i,n) a[i]=b[i]=\'A\';\n\n\tREP(i,n) v1[a[i]-\'A\'].pb(i);\n\tREP(i,n) v2[b[i]-\'A\'].pb(i);\n\n\tll num = 0;\n\tFOR(i,1,n+1){\n\t\tll t = n-i+1;\n\t\tnum += t*t;\n\t}\n\tull c = 0;\n\n\tREP(i,30) if(v1[i].size() && v2[i].size()){\n\t\tc += solve(v1[i], v2[i]);\n\t\tc += solve(v2[i], v1[i]);\n\t\tc += same(v1[i], v2[i]);\n\t}\n\n\tprintf(""%.10lf\\n"",double(c)/num);\n//\tcout<<num<<endl;\n\t//cout<<c<<endl;\n\t//cout<<ll(1e18)<<endl;\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']",,,"['math', 'probabilities']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Little Elephant and Furik and Rubik.json,https://codeforces.com/blog/entry/4849,This problem is to find the expected value Important fact here is the linearity of the expected value This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other but of course equal from the second string The answer will be the sum of all such probabilities Let the current character of the first string be the i th character 1 based numeration Firstly we try to solve problem in O N2 time Namely as it was said above we need to find the number of such pairs of substrings that i th character which is on probably some other position in substring is the same as the corresponding character of the second substring Iterate through all j j i such that Ai Bj The number of such pairs of substrings that have match in that characters is j n i 1 considering 1 based numeration This is O N2 And because we need to find the sum of such values for all possible j we can rewrite it as Si n i 1 where Si equals to the sum of all integers j j i that Ai Bi Array S can be simply computed in a linear time Analogically you should process all indices to the right from i After we know the number of pairs of substrings with the match with the i th character let it be count the probability is count total where total is the total number of pair of substrings it can be found by loop or with some simple formula 
https://codeforces.com//contest/1017/problem/D,205994,D,1017D,1017,D. The Wu,Childan is making up a legendary story and trying to sell his forgery a necklace with a strong sense of to the Kasouras But Mr Kasoura is challenging the truth of Childan s story So he is going to ask a few questions about Childan s so called personal treasure necklace This personal treasure is a multiset S of m A is a string that contains n characters and For example if n 4 strings and are but there are 5 characters not 4 and unallowed characters are not Frequently Mr Kasoura will provide a t and ask Childan how many strings s are in the multiset S such that the value of the pair s t is than k Mrs Kasoura and Mr Kasoura think that if s i t i 1 leq i leq n then the value of the character pair equals to w i otherwise 0 The value of the pair is the sum of the values of every character pair Note that the length of every is equal to n For example if w 4 5 3 6 of is 7 because these strings have equal characters only on the first and third positions so w 1 w 3 4 3 7 You need to help Childan to answer Mr Kasoura s queries That is to find the number of strings in the multiset S such that the value of the pair is not greater than k ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\tvector<int> w(n);\n\tfor (int &i : w) { cin >> i; }\n\n\t// precompute wu value for every subset\n\tvector<int> wu(1 << n);\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i & (1 << j)) { wu[i] += w[j]; }\n\t\t}\n\t}\n\n\t// convert all strings to integers and store count\n\tvector<int> str_count(1 << n);\n\tfor (int i = 0; i < m; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint val = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[j] == \'1\') { val += 1 << j; }\n\t\t}\n\t\tstr_count[val]++;\n\t}\n\n\t/*\n\t * precompute wu value between every pair of possible strings\n\t * .first stores the actual value, .second stores prefix of count\n\t */\n\tvector<vector<pair<int, int>>> pref_wu(1 << n,\n\t                                       vector<pair<int, int>>(1 << n));\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tfor (int j = 0; j < (1 << n); j++) {\n\t\t\tpref_wu[i][j] = {wu.back() - wu[i ^ j], str_count[j]};\n\t\t}\n\t\tsort(pref_wu[i].begin(), pref_wu[i].end());\n\t\t// accumulate prefix sums of count\n\t\tfor (int j = 1; j < (1 << n); j++) {\n\t\t\tpref_wu[i][j].second += pref_wu[i][j - 1].second;\n\t\t}\n\t}\n\n\tfor (int query = 0; query < q; query++) {\n\t\tstring t;\n\t\tint k;\n\t\tcin >> t >> k;\n\t\tint val = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (t[i] == \'1\') { val += 1 << i; }\n\t\t}\n\t\t// binary search for the least element with wu greater than k\n\t\tauto it = upper_bound(pref_wu[val].begin(), pref_wu[val].end(),\n\t\t                      make_pair(k, INT32_MAX));\n\t\tif (it == pref_wu[val].begin()) {\n\t\t\tcout << 0 << ""\\n"";\n\t\t} else {\n\t\t\tcout << prev(it)->second << ""\\n"";\n\t\t}\n\t}\n}']",,,"['bitmasks', 'brute force', 'data structures']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. The Wu.json,https://codeforces.com/blog/entry/61081,We can regard a as a binary number where is bit wise XOR and we can preprocess Notice that so so we can do something like meet in the middle split the numbers into higher bits and lower bits count the number of binary numbers with higher bits equal to and Then one can easily get stores the answer and then answer queries in time If you don t understand see the code Complexity 
https://codeforces.com//contest/1687/problem/E,1419369,E,1687E,1687,E. Become Big For Me,Kijin Seija Shinmyoumaru has a mallet that can turn objects bigger or smaller She is testing it out on a sequence a and a number v whose initial value is 1 She wants to make v gcd limits i ne j a i cdot a j by 10 5 operations gcd limits i ne j a i cdot a j denotes the gcd of all products of two distinct elements of the sequence a In each operation she picks a subsequence b of a and does one of the followings v v cdot mathrm lcm b v frac v mathrm lcm b Note that she does need to guarantee that v is an integer that is v does need to be a multiple of mathrm lcm b when performing Reduce Moreover she wants to guarantee that the total length of b chosen over the operations does not exceed 10 6 Fine a possible operation sequence for her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint d[N];\nint cntDif[N];\nint c[N][3];\nbool u[N];\n\nvector<pair<vector<int>, int>> getGcd(int ban) {\n\tint g = 0;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tg = gcd(g, a[i]);\n\t}\n\tint gg = 0;\n\tvector<int> w;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tint ng = gcd(gg, a[i]);\n\t\tif (ng == gg) continue;\n\t\tif (gg == 0 || cntDif[gg / g] != cntDif[ng / g]) {\n\t\t\tw.push_back(i);\n\t\t}\n\t\tgg = ng;\n\t}\n\tvector<pair<vector<int>, int>> ans;\n\tint sz = (int)w.size();\n\tassert(sz > 0);\n\tfor (int mask = 1; mask < (1 << sz); mask++) {\n\t\tint t = 1;\n\t\tvector<int> cur;\n\t\tfor (int i = 0; i < sz; i++) if ((mask >> i) & 1) {\n\t\t\tt ^= 1;\n\t\t\tcur.push_back(w[i]);\n\t\t}\n\t\tans.push_back(mp(cur, t));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int x = 2; x < N; x++) {\n\t\tif (d[x] != 0) continue;\n\t\tc[x][0] = 0;\n\t\tc[x][1] = 30;\n\t\tc[x][2] = -1;\n\t\tfor (int y = x; y < N; y += x)\n\t\t\tif (d[y] == 0)\n\t\t\t\td[y] = x;\n\t}\n\tcntDif[1] = 0;\n\tfor (int x = 2; x < N; x++) {\n\t\tint y = x;\n\t\twhile(d[y] == d[x]) y /= d[x];\n\t\tcntDif[x] = cntDif[y] + 1;\n\t}\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tint x = a[i];\n\t\twhile(x > 1) {\n\t\t\tint p = d[x];\n\t\t\tint k = 0;\n\t\t\twhile(x % p == 0) {\n\t\t\t\tx /= p;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tc[p][0]++;\n\t\t\tif (k < c[p][1]) {\n\t\t\t\tc[p][1] = k;\n\t\t\t\tc[p][2] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int p = 2; p < N; p++) if (d[p] == p) {\n\t\tif (c[p][0] <= n - 2) continue;\n\t\tif (c[p][0] == n - 1) {\n\t\t\tint v = 0;\n\t\t\twhile(a[v] % p == 0) v++;\n\t\t\tu[v] = 1;\n\t\t} else {\n\t\t\tu[c[p][2]] = 1;\n\t\t}\n\t}\n\tvector<int> zz;\n\tfor (int i = 0; i < n; i++)\n\t\tif (u[i])\n\t\t\tzz.push_back(i);\n\tvector<pair<vector<int>, int>> ans;\n\tvector<pair<vector<int>, int>> ans0 = getGcd(-1);\n\tint w = 2 - (int)zz.size();\n\tif (w > 0) {\n\t\tfor (int it = 0; it < w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(z);\n\t} else {\n\t\tfor (int it = 0; it < -w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(mp(z.first, z.second ^ 1));\n\t}\n\tfor (int x : zz) {\n\t\tans0 = getGcd(x);\n\t\tfor (auto z : ans0)\n\t\t\tans.push_back(z);\n\t}\n\tprintf(""%d\\n"", (int)ans.size());\n\tfor (auto z : ans) {\n\t\tprintf(""%d %d"", z.second, (int)z.first.size());\n\t\tsort(all(z.first));\n\t\tfor (int id : z.first)\n\t\t\tprintf("" %d"", id + 1);\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'greedy', 'math', 'number theory']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Become Big For Me.json,https://codeforces.com//blog/entry/103493,Solution Let be the maximum integer satisfying For each prime WLOG assuming then Consider the Inclusion Exclusion Principle So Then We can solve the task by choosing a short subsequence satisfying and enumerating its subsets To fit in the constraint the length of should be no longer than Think of an easier task choosing a small subset satisfying If we can solve it we can construct by choosing if does not exceed First choose an arbitrary element in as the only element of and factorize into For each if then add an arbitrary element in satisfying to Now obviously but We can prove that and do not hold at the same time then we can solve the task by choosing Consider the necessary condition of According to how we choose so Since and But causing a conflict So does not hold The time complexity is Worth mentioning with this conclusion such small set exists we can solve it much more easier Just choose a small set by greedy and enumerate its subset of size 
https://codeforces.com//contest/1820/problem/B,1880610,B,1820B,1820,B. JoJo s Incredible Adventures,Did you think there was going to be a JoJo legend here But no that was me Dio Given a binary string s of length n consisting of characters and Let s build a table of size n times n consisting of and characters as follows In the first row of the table write the original string s In the second row of the table write of the string s by one to the right In the third row of the table write the cyclic shift of line s by two to the right And so on Thus the row with number k will contain a cyclic shift of string s by k to the right The rows In the resulting table we need to find the rectangle consisting only of ones that has the largest area We call a rectangle the set of all cells i j in the table such that x 1 le i le x 2 and y 1 le j le y 2 for some integers 0 le x 1 le x 2 n and 0 le y 1 le y 2 n Recall that the cyclic shift of string s by k to the right is the string s n k 1 ldots s n s 1 s 2 ldots s n k For example the cyclic shift of the string by 0 to the right is the string itself its cyclic shift by 3 to the right is the string ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FORI(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n \nmt19937 rnd(time(0));\n\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define endl \'\\n\'\n\n#define mp(m, n) make_pair((m), (n))\n \ntemplate<typename T>\nvoid read(vector<T> &t) {FOR(i, t.size()) {cin >> t[i];}}\ntemplate<typename T> string tostring(T a) { istringstream sin; sin >> a; return sin.str(); }\n \n// #define DEBUG\n \n#ifdef DEBUG\ntemplate<typename T>\nvoid _debug(string s, T x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, unordered_map<T, K> x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << it->first << "":"" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, map<T, K> x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << it->first << "":"" << it->second;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, set<T, K> x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, vector<pair<T, K> > x) {\n    cerr << s << "":"";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << "" "" << it->first << "","" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, pair<T, K> x) {\n    cerr << s << "": "" << x.first << "","" << x.second << endl;\n}\n \nvoid _debug(string s, int x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, long long x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, double x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, string x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, char x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, size_t x) {\n    cerr << s << "": "" << x << endl;\n}\nvoid _debug(string s, bool x) {\n    cerr << s << "": "" << x << endl;\n}\n \n#define debug(x) _debug(#x, (x))\n#else\n#define debug(x)\n#endif\n \n#define db debug\n\ntemplate <class T>\nvoid print(vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        cout << v[i];\n        if (i == v.size() - 1) {\n            cout << endl;\n        } else {\n            cout << "" "";\n        }\n    }\n}\n\nvoid solve();\n \nvoid pre_init();\n\nint main() {\n    ios_base::sync_with_stdio(false); std::cin.tie(0);\n    pre_init();\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}\n \nvoid pre_init() {}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    ll n = s.size();\n    int has0 = false;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \'0\') has0 = true;\n        s += s[i];\n    }\n    if (!has0) {\n        cout << n * n << endl;\n        return;\n    }\n    ll max_cnt = 0;\n    ll now = 0;\n    debug(s);\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == \'0\') now = 0;\n        else now += 1;\n        max_cnt = max(max_cnt, now);\n    }\n    debug(max_cnt);\n    cout << (max_cnt / 2 + 1) * ((max_cnt + 1) / 2) << endl;\n    \n}']",,,"['math', 'strings', 'two pointers']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. JoJo s Incredible Adventures.json,https://codeforces.com//blog/entry/115133,First of all consider the cases if the given string consists only of ones and only of zeros It s easy to see that answers for these cases are and In all other cases let s split all strings into segments that consist only of ones Also if the first and the last characters of the string equals to these two characters will be in one segment In other words the pair of ones will lay inside one group if there exists cyclic shift that these two ones are consecutive Let the maximum length of such segment be equal to Then it can be shown that the answer equals to We will proof this fact in such way If there exists some rectangle of size Considering its first row we can see that it has consecutive ones But it means that Without loss of generality if we can do the following replacements It means that Time complexity 
https://codeforces.com//contest/1187/problem/B,365118,B,1187B,1187,B. Letters Shop,The letters shop showcase is a string s consisting of n lowercase Latin letters As the name tells letters are sold in the shop Letters are sold one by one from the leftmost to the rightmost Any customer can only buy some prefix of letters from the string s There are m friends the i th of them is named t i Each of them is planning to estimate the following value how many letters the length of the shortest prefix would s he need to buy if s he wanted to construct her his name of bought letters The name can be constructed if each letter is presented in the equal or greater amount For example for s and t i 5 letters have to be bought For example for s and t i 6 letters have to be bought For example for s and t i 5 letters have to be bought For example for s and t i 2 letters have to be bought For example for s and t i all 9 letters have to be bought It is guaranteed that every friend can construct her his name using the letters from the string s Note that the values for friends are independent friends are only estimating them but not actually buying the letters ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nvi gdz[nax];\n\nint m;\nchar wcz[nax];\n\nint ile[nax];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=0; i<26; i++)\n\t\tgdz[i].push_back(0);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t\tgdz[wcz[i]-\'a\'].push_back(i);\n\t//~ for (int i=0; i<26; i++)\n\t\t//~ debug() << i << "" "" << gdz[i];\n\tscanf(""%d"", &m);\n\twhile(m--)\n\t{\n\t\tfor (int i=0; i<26; i++)\n\t\t\tile[i]=0;\n\t\tscanf(""%s"", wcz+1);\n\t\tint k=strlen(wcz+1);\n\t\t//~ debug() << range(wcz+1, wcz+1+k);\n\t\tfor (int i=1; i<=k; i++)\n\t\t\tile[wcz[i]-\'a\']++;\n\t\tint wyn=0;\n\t\t//~ debug() << range(ile, ile+26);\n\t\tfor (int i=0; i<26; i++)\n\t\t\twyn=max(wyn, gdz[i][ile[i]]);\n\t\tprintf(""%d\\n"", wyn);\n\t}\n\treturn 0;\n}\n']",,,"['binary search', 'implementation', 'strings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Letters Shop.json,https://codeforces.com//blog/entry/68111,Let s construct the answer letter by letter How to get enough letters a for the name Surely the taken letters will be the first a the second a up to th a in string where is the amount of letters a in the name It s never profitable to skip the letter you need Do the same for all letters presented in the name The answer will the maximum position of these last taken letters How to obtain the th letter fast Well just precalculate the list of positions for each letter and take the needed one from it Overall complexity 
https://codeforces.com//contest/896/problem/B,137081,B,896B,896,B. Ithea Plays With Chtholly,Ithea and Chtholly want to play a game in order to determine who can use the kitchen tonight Initially Ithea puts clear sheets of paper in a line They are numbered from to from left to right This game will go on for rounds In each round Ithea will give Chtholly an integer between and and Chtholly needs to choose one of the sheets to write down this number if there is already a number before she will erase the original one and replace it with the new one Chtholly wins if at any time all the sheets are filled with a number and the numbers are in non decreasing order looking from left to right from sheet to sheet and if after rounds she still doesn t win she loses the game Chtholly really wants to win the game as she wants to cook something for Willem But she doesn t know how to win the game So Chtholly finds you and your task is to write a program to receive numbers that Ithea gives Chtholly and help her make the decision on which sheet of paper write this number ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#define _CRT_SECURE_NO_WARNINGS\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n\n#ifdef LOCAL\n# include <opencv2/core/core.hpp>\n# include <opencv2/highgui/highgui.hpp>\n# include <opencv2/imgproc/imgproc.hpp>\n#endif\n\nusing namespace std;\n\n// Let\'s define unordered map\n# ifdef __GNUC__\n# if __cplusplus > 199711L\n# include <unordered_set>\n# include <unordered_map>\n# else\n# include <tr1/unordered_map>\n# include <tr1/unordered_set>\nusing namespace tr1;\n# endif\n# else\n# include <unordered_map>\n# include <unordered_set>\n# endif\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define DBN1(a)           cerr<<#a<<""=""<<(a)<<""\\n""\n#define DBN2(a,b)         cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<""\\n""\n#define DBN3(a,b,c)       cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<""\\n""\n#define DBN4(a,b,c,d)     cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<""\\n""\n#define DBN5(a,b,c,d,e)   cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<""\\n""\n#define DBN6(a,b,c,d,e,f) cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<"", ""<<#f<<""=""<<(f)<<""\\n""\n#define DBN(...) macro_dispatcher(DBN, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,n) cerr<<#a<<""=[""; printarray(a,n); cerr<<""]\\n""\n#define DAR(a,n,s) cerr<<#a<<""[""<<s<<""-""<<n-1<<""]=[""; printarray(a,n,s); cerr<<""]\\n""\n\n#ifdef _MSC_VER\n#define PREFETCH(ptr, rw, level) ((void)0)\n#else\n#define PREFETCH(ptr, rw, level) __builtin_prefetch(ptr, rw, level)\n#endif\n\n#ifdef LOCAL\n#define CURTIME() cerr << clock() * 1.0 / CLOCKS_PER_SEC << endl\n#else\n#define CURTIME()\n#endif\n\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef int itn;\n\ntemplate<class T1, class T2, class T3>\nstruct triple{ T1 a; T2 b; T3 c; triple() : a(T1()), b(T2()), c(T3()) {}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };\ntemplate<class T1, class T2, class T3>\nbool operator<(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a<t2.a;else if(t1.b!=t2.b)return t1.b<t2.b;else return t1.c<t2.c;}\ntemplate<class T1, class T2, class T3>\nbool operator>(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a>t2.a;else if(t1.b!=t2.b)return t1.b>t2.b;else return t1.c>t2.c;}\n#define tri triple<int,int,int>\n#define trll triple<ll,ll,ll>\n\n#define FI(n) for(int i=0;i<(n);++i)\n#define FJ(n) for(int j=0;j<(n);++j)\n#define FK(n) for(int k=0;k<(n);++k)\n#define FL(n) for(int l=0;l<(n);++l)\n#define FQ(n) for(int q=0;q<(n);++q)\n#define FOR(i,a,b) for(int i = (a), __e = (int) (b); i < __e; ++i)\n#define all(a) std::begin(a), std::end(a)\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(1.0 * (x))\n#define pow(x, n) pow(1.0 * (x), n)\n\n#define COMPARE(obj) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b)\n#define COMPARE_BY(obj, field) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b) { return a.field < b.field; }\n\n#define checkbit(n, b) (((n) >> (b)) & 1)\n#define setbit(n, b) ((n) | (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define removebit(n, b) ((n) & ~(static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define flipbit(n, b) ((n) ^ (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\ninline int countBits(uint v){v=v-((v>>1)&0x55555555);v=(v&0x33333333)+((v>>2)&0x33333333);return((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24;}\ninline int countBits(ull v){uint t=v>>32;uint p=(v & ((1ULL << 32) - 1)); return countBits(t) + countBits(p); }\ninline int countBits(ll v){return countBits((ull)v); }\ninline int countBits(int v){return countBits((uint)v); }\nunsigned int reverseBits(uint x){ x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }\ntemplate<class T> inline int sign(T x){ return x > 0 ? 1 : x < 0 ? -1 : 0; }\ninline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }\nconstexpr ll power(ll x, int p) { return p == 0 ? 1 : (x * power(x, p - 1)); }\ntemplate<class T1, class T2, class T3> T1 inline clamp(T1 x, const T2& a, const T3& b) { if (x < a) return a; else if (x > b) return b; else return x; }\nunsigned long long rdtsc() { unsigned long long ret = 0;\n#ifdef __clang__\n    return __builtin_readcyclecounter();\n#endif\n#ifndef _MSC_VER\n    asm volatile(""rdtsc"" : ""=A"" (ret) : :);\n#endif\n    return ret; }\n// Fast IO ********************************************************************************************************\nconst int __BS = 4096;\nstatic char __bur[__BS + 16], *__er = __bur + __BS, *__ir = __er;\ntemplate<class T = int> T readInt() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && (*__ir < \'0\' || *__ir > \'9\') && *__ir != \'-\') ++__ir; c();\n    bool m = false; if (*__ir == \'-\') ++__ir, c(), m = true;\n    T r = 0; while (*__ir >= \'0\' && *__ir <= \'9\') r = r * 10 + *__ir - \'0\', ++__ir, c();\n    ++__ir; return m ? -r : r;\n}\nstatic char __buw[__BS + 20], *__iw = __buw, *__ew = __buw + __BS;\ntemplate<class T>\nvoid writeInt(T x, char endc = \'\\n\') {\n    if (x < 0) *__iw++ = \'-\', x = -x; if (x == 0) *__iw++ = \'0\';\n    char* s = __iw;\n    while (x) { T t = x / 10; char c = x - 10 * t + \'0\'; *__iw++ = c; x = t; }\n    char* f = __iw - 1; while (s < f) swap(*s, *f), ++s, --f;\n    if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw;\n    *__iw++ = endc;\n}\ntemplate<class T>\nvoid writeStr(const T& str) {\n    int i = 0; while (str[i]) { *__iw++ = str[i++]; if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw; }\n}\nstruct __FL__ { ~__FL__() { if (__iw != __buw) cout.write(__buw, __iw - __buw); } };\nstatic __FL__ __flushVar__;\n\n//STL output *****************************************************************************************************\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p);\nTT1 ostream& operator << (ostream& os, const vector<T>& v);\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, const multiset<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v);\nTT1T2T3 ostream& operator << (ostream& os, const map<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const multimap<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t);\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<""(""<<p.first<<"", ""<< p.second<<"")""; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << ""[""; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << "", ""; f = 0; os << x; } return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t){ return os << ""("" << t.a << "", "" << t.b << "", "" << t.c << "")""; }\nTT1T2 void printarray(const T1& a, T2 sz, T2 beg = 0){ for (T2 i = beg; i<sz; i++) cout << a[i] << "" ""; cout << endl; }\n\n//STL input *****************************************************************************************************\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t);\nTT1T2 inline istream& operator >> (istream& os, pair<T1, T2>& p) { return os >> p.first >> p.second; }\nTT1 inline istream& operator >> (istream& os, vector<T>& v) {\n    if (v.size()) for (T& t : v) os >> t; else {\n        string s; T obj; while (s.empty()) {getline(os, s); if (!os) return os;}\n        stringstream ss(s); while (ss >> obj) v.push_back(obj);\n    }\n    return os;\n}\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t) { return os >> t.a >> t.b >> t.c; }\n\n//Pair magic *****************************************************************************************************\n#define PT1T2 pair<T1, T2>\nTT1T2 inline PT1T2 operator+(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first + p2.first, p1.second + p2.second); }\nTT1T2 inline PT1T2& operator+=(PT1T2 &p1 , const PT1T2 &p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\nTT1T2 inline PT1T2 operator-(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first - p2.first, p1.second - p2.second); }\nTT1T2 inline PT1T2& operator-=(PT1T2 &p1 , const PT1T2 &p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\n\n#undef TT1\n#undef TT1T2\n#undef TT1T2T3\n\n#define FREIN(FILE) freopen(FILE, ""rt"", stdin)\n#define FREOUT(FILE) freopen(FILE, ""wt"", stdout)\n#ifdef LOCAL\n#define BEGIN_PROFILE(idx, name) int profileIdx = idx; profileName[profileIdx] = name; totalTime[profileIdx] -= rdtsc() / 1e3;\n#define END_PROFILE totalTime[profileIdx] += rdtsc() / 1e3; totalCount[profileIdx]++;\n#else\n#define BEGIN_PROFILE(idx, name)\n#define END_PROFILE\n#endif\n\ntemplate<class T> inline void normmod(T &x, T m) { x %= m; if (x < 0) x += m; }\ntemplate<class T1, class T2> inline T2 summodfast(T1 x, T1 y, T2 m) { T2 res = x + y; if (res >= m) res -= m; return res; }\ntemplate<class T1, class T2, class T3> inline void addmodfast(T1 &x, T2 y, T3 m) { x += y; if (x >= m) x -= m; }\ntemplate<class T1, class T2, class T3> inline void submodfast(T1 &x, T2 y, T3 m) { x -= y; if (x < 0) x += m; }\n#if INTPTR_MAX == INT32_MAX or !defined(__SIZEOF_INT128__)\ninline ll mulmod(ll x, ll n, ll m){ ll r = 0; normmod(x, m); normmod(n, m); while (n) { if (n & 1) r += x; x += x; if (r >= m) r -= m; if (x >= m) x -= m; n /= 2; } return r; }\n#else\nusing int128 = __int128;\ninline ll mulmod(ll x, ll n, ll m){ return __int128(x) * n % m; }\n#endif\ninline ll powmod(ll x, ll n, ll m){ ll r = 1; normmod(x, m); while (n){ if (n & 1)r = (r*x) % m; x = (x*x) % m; n /= 2; }return r; }\ninline ll powmulmod(ll x, ll n, ll m) { ll res = 1; normmod(x, m); while (n){ if (n & 1)res = mulmod(res, x, m); x = mulmod(x, x, m); n /= 2; } return res; }\ntemplate<class T> inline T gcd(T a, T b) { while (b) { a %= b; T t = a; a = b; b = t; } return a; }\ninline ll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntemplate<class T> inline T gcd(T a, T b, T c){ return gcd(gcd(a, b), c); }\nll gcdex(ll a, ll b, ll& x, ll& y) {\n    if (!a) { x = 0; y = 1; return b; }\n    ll y1; ll d = gcdex(b % a, a, y, y1); x = y1 - (b / a) * y;\n    return d;\n}\ntemplate<class T> bool isPrime(T x) { if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n    for (T i = 5; i * i <= x; i += 6) if (x % i == 0 || x % (i + 2) == 0) return 0; return 1; }\nbool millerRabin(long long n) {\n    if (n <= 1000) return isPrime(n);\n    long long s = n - 1; int t = 0; while (s % 2 == 0) s /= 2, ++t;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) { if (!(a %= n)) return true;\n        long long f = powmulmod(a, s, n); if (f == 1 || f == n - 1) continue;\n        for (int i = 1; i < t; ++i) if ((f = mulmod(f, f, n)) == n - 1) goto nextp;\n        return false; nextp:;\n    } return true;\n}\n\n// Useful constants\n\n//int some_primes[7] = {24443, 100271, 1000003, 1000333, 5000321, 98765431, 1000000123};\n#define T9          1000000000\n#define T18         1000000000000000000LL\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define mod         1000000007\n#define EPS         (double)1e-10\n#define PI          3.14159265358979323846264\n#define link        asaxlajrewqwe\n#define rank        wahayawehasdakw\n//*************************************************************************************\n\nint32_t solve();\nint32_t main(int argc, char** argv) {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef LOCAL\n    //    FREIN(""input.txt"");\n    //            FREOUT(""out.txt"");\n#endif\n    return solve();\n}\nint a[10101];\nint solve() {\n    int n, m, c;\n    cin >> n >> m >> c;\n    FI(n) {\n        a[i] = INF;\n    }\n    int b = 0, e = 0;\n    while (m--) {\n//        printarray(a, n);\n        int x;\n        cin >> x;\n        int pos;\n        if (x <= c / 2) {\n            pos = int(upper_bound(a, a + b, x) - a);\n            if (pos == b) {\n                ++b;\n            }\n        } else {\n            pos = int(lower_bound(a + n - e, a + n, x) - a - 1);\n            if (pos == n - 1 - e) {\n                ++e;\n            }\n        }\n//        DBN(b, e);\n        a[pos] = x;\n        cout << pos + 1 << endl;\n        if (b + e == n) return 0;\n    }\n    \n    return 0;\n}\n\n']",,,"['binary search', 'constructive algorithms', 'games', 'greedy', 'interactive']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Ithea Plays With Chtholly.json,https://codeforces.com//blog/entry/56135,As the initial sheet has already in a non decreasing order although it has no numbers what we should do is just maintain this order We use a simple method to do so find the first sheet whose number is strictly greater than the given number or it s an empty sheet and replace it with the new number For each round we either replace an existing number with a strictly smaller one or fill in an empty sheet The first case will happen at most times for each sheet and the second case will happen only once for each sheet Thus in total we will modify a sheet for at most times Thus the total rounds won t be more than To pass all the tests we only need to maintain 2 similar sequences one non decreasing from the first and one non increasing from the last which makes a total round of precisely and use binary search or brute force to complete the finding process 
https://codeforces.com//contest/671/problem/D,60095,D,671D,671,D. Roads in Yusland,Mayor of Yusland just won the lottery and decided to spent money on something good for town For example repair all the roads in the town Yusland consists of intersections connected by bidirectional roads One can travel from any intersection to any other intersection using only these roads There is only one road repairing company in town named RC company Company s center is located at the intersection RC company doesn t repair roads you tell them Instead they have workers at some intersections who can repair only some specific paths The th worker can be paid coins and then he repairs on a path from to some that from to intersection Mayor asks you to choose the cheapest way to hire some subset of workers in order to repair all the roads in Yusland It s allowed that some roads will be repaired more than once If it s impossible to repair all roads print ,"['#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 311111\n\n#define TASK ""1""\n\nusing namespace std;\n\nvector<int> v[N], ch[N];\nvector<pair<int, int> > z[N];\nint n, m;\n\nint d[N];\n\n\nvoid dfs(int x, int pr, int de) {\n\td[x] = de;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tint to = v[x][i];\n\t\tif (to != pr) {\n\t\t\tdfs(to, x, de + 1);\n\t\t\tch[x].pb(to);\n\t\t}\n\t}\n}\n\n\nlong long dp[N];\n\nset<pair<long long, int > > Q[N];\nlong long ad[N];\nint bad = 0;\n\nvoid calc(int x) {\n\tif (ch[x].size() == 0) {\n\t\tad[x] = 0;\n\t\tfor (int i = 0; i < z[x].size(); i++) Q[x].insert(mp(z[x][i].S, z[x][i].F));\n\t\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\t\tif (Q[x].size() == 0) {\n\t\t\tbad = 1;\n\t\t\tdp[x] = 0;\n\t\t} else {\n\t\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < ch[x].size(); i++) calc(ch[x][i]);\n\tlong long sum = 0;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tsum += dp[ch[x][i]];\n\t}\n\tint la = -1;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tad[ch[x][i]] += sum - dp[ch[x][i]];\n\t\tif (la == -1 || Q[ch[x][i]].size() > Q[la].size()) la = ch[x][i];\n\t}\n\n\tfor (int i = 0; i < ch[x].size(); i++) if (ch[x][i] != la) {\n\t\tint u = ch[x][i];\n\t\tfor (auto it = Q[u].begin(); it != Q[u].end(); ++it) {\n\t\t\tlong long cost = (*it).F + ad[u] - ad[la];\n\t\t\tQ[la].insert(mp(cost, (*it).S));\n\t\t}\n\t}\n\tfor (int i = 0; i < z[x].size(); i++) {\n\t\tlong long cost = z[x][i].S + sum - ad[la];\n\t\tQ[la].insert(mp(cost, z[x][i].F));\n\t}\n\tswap(Q[la], Q[x]);\n\tad[x] = ad[la];\n\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\tif (Q[x].size() == 0) {\n\t\tbad = 1;\n\t\tdp[x] = 0;\n\t} else {\n\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t}\n}\n\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK"".in"",""r"",stdin);\t\n\t\tfreopen(TASK"".out"",""w"",stdout);\n\t#endif\t\t\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(0, 0, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, co;\n\t\tscanf(""%d%d%d"", &x, &y, &co);\n\t\tx--;\n\t\ty--;\n\t\tif (d[x] < d[y]) swap(x, y);\n\n\t\tz[x].pb(mp(d[y], co));\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tcalc(v[0][i]);\n\t\tans += dp[v[0][i]];\n\t}\n\tif (bad) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}']",,,"['data structures', 'dp', 'greedy']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Roads in Yusland.json,https://codeforces.com//blog/entry/44821,I want to thank GlebsHP i originally came up with another problem similar to it GlebsHP suggested to use this one in stead of it Let s look for a optimal subset of paths paths may intersect To prevent from this let s change the problem litte bit A worker can repair all nodes between and some where is in the path between and with cost also paths must not intersect In this way we will never find better solution from original problem and we can express optimal subset in original problem without any path intersections in new problem Let s keep a array keeps minimum cost to cover all edges in subtree of node also the edge between and How to find answer of some Let s choose a worker which is in the subtree of and is a parent of node Then if we choose this worker answer must be where is child of a node in the path from to for all s Of course we have to exclude nodes chosen as and in the path from to since we will cover them with th worker We will construct a segment tree by dfs travel times so that for all nodes workers which start his path in subtree of this node can be reached by looking a contiguous segment in tree In node segment will keep values what will be equal to if we choose this worker to cover path between and We will travel our tree with dfs in each after we calculated node s children dp s we will update our segment in following way add all workers to segment where with value sum of node s children dp s For all workers equal to we must delete it from segment this is assigning to it The only thing we didn t handle is what to do with workers under this node Imagine all updates in subtree of node where is a child of node We have to increase all of them by sum of node s children dp s After applying all of this operations answer will be minimum value of workers start their path from a node in subtree of in segment tree Overall complexity will be Please look at the code to be more clear 
https://codeforces.com//contest/357/problem/A,3671,A,357A,357,A. Group of Students,At the beginning of the school year Berland State University starts two city school programming groups for beginners and for intermediate coders The children were tested in order to sort them into groups According to the results each student got some score from 1 to points We know that schoolchildren got 1 point children got 2 points children got points Now you need to set the passing rate integer from 1 to all schoolchildren who got less than points go to the beginner group and those who get at strictly least points go to the intermediate group We know that if the size of a group is more than then the university won t find a room for them We also know that if a group has less than schoolchildren then it is too small and there s no point in having classes with it So you need to split all schoolchildren into two groups so that the size of each group was from to inclusive Help the university pick the passing rate in a way that meets these requirements ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\nint n;\nint a[120],s[120],x,y;\nint main()\n{\n    while(~scanf(""%d"",&n))\n    {\n        s[0]=0;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(""%d"",&a[i]);\n            s[i]=s[i-1]+a[i];\n        }\n        scanf(""%d%d"",&x,&y);\n        int ret=0;\n        for(int i=1;i<=n;i++)\n        if(s[i-1]>=x&&s[i-1]<=y&&s[n]-s[i-1]>=x&&s[n]-s[i-1]<=y)\n        ret=i;\n        printf(""%d\\n"",ret);\n    }\n    return 0;\n}\n']",,,"['brute force', 'greedy', 'implementation']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Group of Students.json,https://codeforces.com//blog/entry/9210,In this problem you need to iterate over all possible values of passing rate from 1 to 100 and for each value calculate the sizes of two groups 
https://codeforces.com//contest/1472/problem/D,854354,D,1472D,1472,D. Even-Odd Game,During their New Year holidays Alice and Bob play the following game using an array a of n integers Players take turns Alice moves first Each turn a player chooses any element and removes it from the array If Alice chooses then she adds it to her score If the chosen value is odd Alice s score does not change Similarly if Bob chooses then he adds it to his score If the chosen value is even then Bob s score does not change If there are no numbers left in the array then the game ends The player with the highest score wins If the scores of the players are equal then a draw is declared For example if n 4 and a 5 2 7 3 then the game could go as follows there are other options On the first move Alice chooses 2 and get two points Her score is now 2 The array a is now 5 7 3 On the second move Bob chooses 5 and get five points His score is now 5 The array a is now 7 3 On the third move Alice chooses 7 and get no points Her score is now 2 The array a is now 3 On the last move Bob chooses 3 and get three points His score is now 8 The array a is empty now Since Bob has more points at the end of the game he is the winner You want to find out who will win if both players play optimally ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nint a[N_MAX];\n\nvector <int> x, y;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        x.clear();\n        y.clear();\n        for(int i = 1; i <= n; i++)\n        {\n            x.push_back(0);\n            y.push_back(0);\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            if(a[i] & 1)\n                y.push_back(a[i]);\n            else\n                x.push_back(a[i]);\n        }\n        sort(x.begin(), x.end());\n        sort(y.begin(), y.end());\n        ll s1 = 0, s2 = 0;\n        bool turn = 0;\n        while(n--)\n        {\n            if(turn == 0)\n            {\n                if((int)x.back() > (int)y.back())\n                {\n                    s1 += x.back();\n                    x.pop_back();\n                }\n                else\n                    y.pop_back();\n            }\n            else\n            {\n                if((int)y.back() > (int)x.back())\n                {\n                    s2 += y.back();\n                    y.pop_back();\n                }\n                else\n                    x.pop_back();\n            }\n            turn = !turn;\n        }\n        if(s1 < s2)\n            cout << ""Bob\\n"";\n        else if(s1 == s2)\n            cout << ""Tie\\n"";\n        else\n            cout << ""Alice\\n"";\n    }\n    return 0;\n}\n']",,,"['dp', 'games', 'greedy', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Even-Odd Game.json,https://codeforces.com//blog/entry/86406,Let s look at an analogy for this game If Alice takes an even number she adds points to the global result otherwise If Bob takes an odd number he adds points to the global result otherwise Alice wants to maximize the global result and Bob wants to minimize it Obviously this game is completely equivalent to the conditional game Suppose now it s Alice s move Let s look at some number in the array If this number is even then taking it will add points and giving it to Bob will add points If this number is odd then taking it will add points and giving it to Bob will add points So taking the number by points is more profitable than not taking it regardless of the parity To maximize the result Alice should always take the maximum number in the array Similar reasoning can be done for Bob In the task it was necessary to sort the array and simulate the game 
https://codeforces.com//contest/1815/problem/C,1871721,C,1815C,1815,C. Between,You are given an integer n as well as m pairs of integers a i b i where 1 leq a i b i leq n a i ne b i You want to construct a sequence satisfying the following requirements All elements in the sequence are integers between 1 and n There is exactly one element with value 1 in the sequence For each i 1 le i le m between any two elements on different positions in the sequence with value a i there is at least one element with value b i The sequence constructed has the length among all possible sequences satisfying the above properties Sometimes it is possible that such a sequence can be arbitrarily long in which case you should output Otherwise you should output and the sequence itself If there are multiple possible constructions that yield the maximum length output any ,"['/**\n *    author:  tourist\n *    created: 09.04.2023 11:03:05       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[y].push_back(x);\n    }\n    vector<int> d(n, -1);\n    vector<int> que(1, 0);\n    d[0] = 1;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (d[u] == -1) {\n          que.push_back(u);\n          d[u] = d[que[b]] + 1;\n        }\n      }\n    }\n    if (*min_element(d.begin(), d.end()) == -1) {\n      cout << ""INFINITE"" << \'\\n\';\n      continue;\n    }\n    cout << ""FINITE"" << \'\\n\';\n    vector<vector<int>> at(n + 1);\n    for (int i = 0; i < n; i++) {\n      at[d[i]].push_back(i);\n    }\n    vector<int> seq;\n    for (int from = 1; from <= n; from++) {\n      for (int val = n; val >= from; val--) {\n        for (int x : at[val]) {\n          seq.push_back(x);\n        }\n      }\n    }\n    cout << seq.size() << \'\\n\';\n    for (int i = 0; i < (int) seq.size(); i++) {\n      cout << seq[i] + 1 << "" \\n""[i == (int) seq.size() - 1];\n    }\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Between.json,https://codeforces.com//blog/entry/114899,Editorial Construct a graph with vertices and add a directed edge if between every two there must be a Let be the number of occurrences of The key observation is that if then Suppose is a directed path where Then since we must have In other words where is one plus the length of the shortest directed path from to Therefore the total array length does not exceed We claim that we can achieve this It is easy to calculate the by a BFS Let consists of vertices such that Let the largest value of among all Consider where for each vertices in various occurrences of must be arranged in the same order It is easy to check that this construction satisfies all the constraints and achieve the upper bound Thus this output is correct The sequence can be arbitrarily long if and only if there is some that does not have a path directed to To see this let be the set of vertices that do not have path directed to then the following construction gives an arbitrarily long output that satisfy all constraints 
https://codeforces.com//contest/490/problem/F,17900,F,490F,490,F. Treeland Tour,The Road Accident band is planning an unprecedented tour around Treeland The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have Treeland consists of cities some pairs of cities are connected by bidirectional roads Overall the country has roads We know that it is possible to get to any city from any other one The cities are numbered by integers from 1 to For every city we know its value the number of people in it We know that the band will travel along some path having concerts in cities along the path The band s path will not pass one city twice each time they move to the city that hasn t been previously visited Thus the musicians will travel along some path without visiting any city twice and in some not necessarily all cities along the way they will have concerts The band plans to gather all the big stadiums and concert halls during the tour so every time they will perform in a city which population is than the population of the previously visited city In other words the sequence of population in the cities where the concerts will be held is In a recent interview with the leader of the road accident band promised to the fans that the band will in the largest possible number of cities Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities so that the population number will increase and the number of concerts will be the largest possible The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland Looks like they can t manage without some help from a real programmer Help the fans find the sought number of concerts ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct node{\n     node *next;\n     int where;\n} *first[10001], a[100001];\n\nint ans, l, v[10001], dist[10001], n, c[10001], f[10001], len;\nbool b[6001];\n\ninline void makelist(int x, int y){\n     a[++l].where = y;\n     a[l].next = first[x];\n     first[x] = &a[l];\n}\n\ninline void soso(int now){\n     b[now] = true;\n     if (!len || v[now] > f[len]) \n     {\n          f[++len] = v[now];\n          ans = max(ans, len); \n          for (node *x = first[now]; x; x = x->next) \n               if (!b[x->where]) soso(x->where);\n          --len;\n     }\n     else\n     {\n          int Left = 0, Right = len, Mid = (Left + Right) >> 1;\n          for (; Left + 1 < Right; Mid = (Left + Right) >> 1)\n               if (v[now] > f[Mid]) Left = Mid;\n               else Right = Mid;\n          if (v[now] < f[Right]) \n          {\n               int dhh = f[Right];\n               f[Right] = v[now];\n               for (node *x = first[now]; x; x = x->next) \n                    if (!b[x->where]) soso(x->where);\n               f[Right] = dhh;\n          }\n          else\n               for (node *x = first[now]; x; x = x->next) \n                    if (!b[x->where]) soso(x->where);\n     }\n}         \n          \nint main(){\n    // freopen(""f.in"", ""r"", stdin);\n    // freopen(""f.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 1; i <= n; i++) scanf(""%d"", &v[i]);\n     memset(first, 0, sizeof(first)); l = 0;\n     for (int i = 1; i < n; i++)\n     {\n          int x, y;\n          scanf(""%d%d"", &x, &y);\n          makelist(x, y); makelist(y, x);\n     }\n     ans = 0;\n     for (int i = 1; i <= n; i++)\n     {\n          memset(b, false, sizeof(b));\n          len = 0; \n          soso(i);\n     }\n     printf(""%d\\n"", ans);\n}\n']",,,"['data structures', 'dfs and similar', 'dp', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Treeland Tour.json,https://codeforces.com//blog/entry/14849,The problem is generalization of finding maximal increasing subsequence in array so it probably can be solved using dynamic programming We will cal dynamic the state is directed edge in tree Value means the maximum number of vertices where the band will have concerts on some simple path ended in vertex going through vertex Also the concert in vertex must be certainly To calc we should consider all such edges that there is simple path started in going through and ended in These edges can be found using dfs from vertex which is not going through vertex All edges used by dfs should be reoriented So if then The solution needs time and memory The memory could be if you get indexes of directed edges without two dimensional array 
https://codeforces.com//contest/1867/problem/E1,2204235,E1,1867E1,1867,E1. Salyg1n and Array  simple version ,salyg1n has given you a positive integer k and wants to play a game with you He has chosen an array of n integers a 1 a 2 ldots a n 1 leq a i leq 10 9 You must print a 1 oplus a 2 oplus ldots oplus a n where oplus denotes the bitwise XOR operation You can make queries of the following type i in response to this query you will receive a i oplus a i 1 oplus ldots oplus a i k 1 Also after this query the subarray a i a i 1 ldots a i k 1 will be reversed i e the chosen array a will become a 1 a 2 ldots a i 1 a i k 1 a i k 2 ldots a i 1 a i a i k ldots a n You can make no more than 100 queries to answer the problem ,"['#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define pb push_back\nusing namespace std;\nusing pii=pair <int,int>;\nusing tii=pair <pii,int>;\nvoid solve(){\n    int n,k;\n    cin>>n>>k;\n    int ans=0;\n    for (int i=1; i+k-1<=n; i+=k){\n        cout<<""? ""<<i<<endl;\n        int t; cin>>t; ans^=t;\n    }\n    if (n%k==0){\n        cout<<""! ""<<ans<<endl;\n        return;\n    }\n    for (int i=n/k*k-k+2; i+k-1<=n; i++){\n        cout<<""? ""<<i<<endl;\n        int t; cin>>t; ans^=t;\n    }\n    cout<<""! ""<<ans<<endl;\n}\nsigned main(){\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\n\tint t=1;\n\tcin>>t;\n\twhile (t--) solve();\n}']",,,"['constructive algorithms', 'interactive', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Salyg1n and Array  simple version .json,https://codeforces.com//blog/entry/120353,TutorialLet s make queries to subarrays starting at positions as long as these queries are valid meaning their right boundary does not exceed Let s save the of all the answers to these queries We will call these queries primary Now we will shift the last subarray of the query one unit to the right and make a new query as long as the right boundary does not exceed We will call these queries secondary It is claimed that the of the entire array will be equal to the of all the queries Let s prove this Let be the position at which the first secondary query starts Notice that after this query the subarray i will turn into the subarray and reverse After the next query the same thing will happen the subarray will shift one unit to the right and reverse Therefore the prefixes of length of each secondary query will be the same up to the reversal which does not affect the Since the number of secondary queries is equal to which is an even number the of these prefixes will not affect the of all the secondary queries which will therefore be equal to the of the elements a i k1 a n that is all the elements that we did not consider in the primary queries The number of primary queries is equal to since The number of secondary queries is equal to since The total number of queries does not exceed 
https://codeforces.com//contest/486/problem/B,17060,B,486B,486,B. OR in Matrix,Let s define logical as an operation on two logical values i e values that belong to the set that is equal to if either or both of the logical values is set to otherwise it is We can define logical of three or more logical values in the same manner where is equal to if some otherwise it is equal to Nam has a matrix consisting of rows and columns The rows are numbered from to columns are numbered from to Element at row and column is denoted as All elements of are either 0 or 1 From matrix Nam creates another matrix of the same size using formula is of all elements in row and column of matrix Nam gives you matrix and challenges you to guess matrix Although Nam is smart he could probably make a mistake while calculating matrix since size of can be large ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 110\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nchar map[maxn][maxn];\nint nRow,nCol,a[maxn][maxn];\nvoid read()\n{\n    cin>>nRow>>nCol;\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            map[i][j]=\'1\';\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n        {\n            scanf(""%d"",&a[i][j]);\n            if(!a[i][j])\n            {\n                for(int k=1;k<=nRow;++k)\n                    map[k][j]=\'0\';\n                for(int k=1;k<=nCol;++k)\n                    map[i][k]=\'0\';\n            }\n        }\n}\nvoid print()\n{\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            if(a[i][j])\n            {\n                int s=0;\n                for(int k=1;k<=nRow;++k)\n                    s+=map[k][j]-\'0\';\n                for(int k=1;k<=nCol;++k)\n                    s+=map[i][k]-\'0\';\n                if(!s)\n                {\n                    printf(""NO\\n"");\n                    return ;\n                }\n            }\n    printf(""YES\\n"");\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            printf(""%c%c"",map[i][j],j<nCol?\' \':\'\\n\');\n}\nint main()\n{\n    read();\n    print();\n    return 0;\n}\n']",,,"['greedy', 'hashing', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. OR in Matrix.json,https://codeforces.com//blog/entry/14678,Hint of this problem is presented in its statement where is equal to if some otherwise it is equal to To solve this problem do 3 following steps Complexity We can implement this algorithm in but it s not neccesary since 
https://codeforces.com//contest/381/problem/B,5525,B,381B,381,B. Sereja and Stairs,Sereja loves integer sequences very much He especially likes stairs Sequence is the length of the sequence is stairs if there is such index that the following condition is met For example sequences 1 2 3 2 and 4 2 are stairs and sequence 3 1 2 isn t Sereja has cards with numbers He wants to put some cards on the table in a row to get a stair sequence What maximum number of cards can he put on the table ,"['#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector> \n#include<cstring>\n#include<string>\n#define mp make_pair\n#define scn second\n#define frs first\n#define pb push_back\n#define NAME ""a""\n#define fop freopen(NAME "".in"", ""r"", stdin); freopen(NAME "".out"", ""w"", stdout); \nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pi;\nvoid dout() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n  cerr << H << \' \';\n  dout(T...);\n}\nint was[100010], n, a[100100];\nint ans[500000];\n\nint main(){\n\t#ifdef LocalHost\n\t\tfop;\n\t#endif\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tint l = 100001, r = 100001;\n\tans[l] = a[n - 1];\n\t--l, ++r;\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\tif (ans[l + 1] != a[i])\n\t\t\tans[l] = a[i], --l;\n\t\telse {\n\t\t\tif (ans[r - 1] != a[i])\n\t\t\t\tans[r] = a[i], ++r;\n\t\t}\t\n\t}\n\t\n\tprintf(""%d\\n"", r - l - 1);\n\tfor (int i = l + 1; i < r; ++i)\n\t\tprintf(""%d "", ans[i]);\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Sereja and Stairs.json,https://codeforces.com//blog/entry/10363,Calculate the amount of each number For all the different numbers maximum possible times of use isn t more than 2 times For the maximum is is only 1 
https://codeforces.com//contest/1996/problem/G,2778594,G,1996G,1996,G. Penacony,On there exists n houses and n roads There exists a road between house i and i 1 for all 1 leq i leq n 1 and a road between house n and house 1 All roads are bidirectional However due to the crisis on Penacony the overseeing family has gone into debt and may not be able to maintain all roads There are m pairs of friendships between the residents of Penacony If the resident living in house a is friends with the resident living in house b there must be a path between houses a and b through maintained roads What is the minimum number of roads that must be maintained ,"['/**   - dwuy -\xa0\u3000\u3000\u3000\u3000\u3000 ／＞\u3000   フ\u3000\u3000\u3000\u3000\u3000 | \u3000_\u3000 _|\u3000 \u3000\u3000\u3000 ／`ミ _x ノ\u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\u3000\u3000\u3000 /\u3000  ヽ\u3000\u3000 ?\u3000／￣|\u3000\u3000 |\u3000|\u3000|\u3000| (￣ヽ＿_ヽ_)_)\u3000＼二つ\xa0**/#include <bits/stdc++.h>\xa0#define fastIO ios_base::sync_with_stdio(false); cin.tie(NULL)#define file(a) freopen(a"".inp"",""r"",stdin); freopen(a"".out"", ""w"",stdout)#define fi first#define se second#define endl ""\\n""#define len(s) (int)((s).size())#define MASK(k)(1LL<<(k))#define TASK ""test""#define int long long\xa0using namespace std;\xa0typedef tuple<int, int, int> tpiii;typedef pair<double, double> pdd;typedef pair<int, int> pii;typedef long long ll;\xa0const long long OO = 1e18;const int MOD = 1e9 + 7;const int INF = 1e9;const int MX = 500005;\xa0struct Node{    int val;    int sum;     Node(int _val=0, int _sum=0){        val=_val;        sum=_sum;    }}; struct SMT{ /// just a SegMent Tree    int n;    vector<Node> tree;     SMT(int _n=0): n(_n) {        tree.assign(n*4+5, Node());    }     void update(int l, int r, int id, int u, int v, int val){        if (l>v || r<u) return;        if (l>=u && r<=v){            int _id= id<<1;            tree[id].val+=val;            if (tree[id].val==0){                if (l!=r) tree[id].sum = tree[_id].sum + tree[_id|1].sum;                else tree[id].sum=0;            }            else tree[id].sum = r-l+1;            return;        }        int mid = (l+r)>>1;        int _id = id<<1;        update(l, mid, _id, u, v, val);        update(mid+1, r, _id|1, u, v, val);        if (tree[id].val==0) tree[id].sum = tree[_id].sum+tree[_id|1].sum;    }     void update(int u, int v, int val){        update(1, n, 1, u, v, val);    }};\xa0int n, m, k, q;string s, t;int a[MX];int b[MX];vector<int> G[MX];vector<int> rG[MX];\xa0void solve(){    cin >> n >> m;    for(int i=1; i<=n + n; i++) G[i].clear(), rG[i].clear();    for(int i=1; i<=m; i++){        int u, v;        cin >> u >> v;        G[u].push_back(v);        G[v].push_back(u);    }        int ans = n;    int cur = 0;    SMT smt(n + n + 5);    for(int u=1; u<=n; u++){        for(int v: G[u]) if(v > u) smt.update(u, v - 1, 1), rG[u].push_back(v);    }    ans = min(ans, smt.tree[1].sum);    // cout << smt.tree[1].sum << endl;    for(int i=n+1; i<=n+n; i++){        int u = i - n;        for(int v: rG[u]){            smt.update(u, v - 1, -1);            // cout << "" + "" << u << \' \' << v << endl;        }\xa0        // cout << smt.tree[1].sum << endl;        for(int v: G[u]) if(v >= u? v : v + n < i){            smt.update(v >= u? v : v + n, i - 1, 1);            // cout << (v >= u? v : v + n) << \' \' << i - 1 << "" - "" << 1 << endl;            rG[v >= u? v : v + n].push_back(i);        }        ans = min(ans, smt.tree[1].sum);        // cout << "" "" << i << \' \' << u << ""   "" << smt.tree[1].sum << endl;    }    cout << ans << endl;}\xa0int32_t main(){    fastIO;    //file(TASK);\xa0    int q;    cin >> q;    while(q--){        solve();    }\xa0    return 0;}\xa0\xa0\xa0']",,,"['brute force', 'data structures', 'graphs', 'greedy', 'hashing']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\G. Penacony.json,https://codeforces.com//blog/entry/131528,There are two configurations to satisfy every friendship a b activate all the roads from a a 1 b or b n 1 a Let s fix a road we deactivate Say it goes from i i 1 Observe that the configuration for all friendships is fixed to one of the two cases For example if a i b then we must use the second configuration We can try fixing every road and taking the minimum of number of roads This can be done with sweep line Once we reach i a for any friendship we toggle to the second configuration Once we reach b we toggle back to the first We can track maintained roads by performing a range addition on a lazy propagated segment tree for each point covered by the current configuration The number of roads required is n minus the number of occurrences of zeroes in the segment tree which can be tracked with Counting Minimums in a Segment Tree 
https://codeforces.com//contest/1878/problem/E,2229486,E,1878E,1878,E. Iva   Pav,Iva gave Pav an array a of n elements Let s define f l r a l a l 1 dots a r here denotes the bitwise AND operation f l r l r Iva also gave Pav q queries Each query consists of 2 numbers k and l and she wants Pav to find the largest index r l le r le n such that f l r ge k Pav wants to solve this problem fast because he doesn t want to upset Iva He needs your help ,"['#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200001], pre[200001][32];\ninline bool check(int l, int r, int k) {\n\tint ans = 0;\n\tfor (int i = 0; i ^ 32; ++i) {\n\t\tif (pre[r][i] - pre[l - 1][i] == r - l + 1)\n\t\t\tans |= 1 << i;\n\t}\n\treturn ans >= k;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, q;\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tcin >> a[i];\n\t\tcin >> q;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j ^ 32; ++j)\n\t\t\t\tpre[i][j] = pre[i - 1][j] + (a[i] >> j & 1);\n\t\t}\n\t\tfor (; q--;) {\n\t\t\tint L, k;\n\t\t\tcin >> L >> k;\n\t\t\tif (a[L] < k) {\n\t\t\t\tcout << ""-1 "";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = L, r = n, mid;\n\t\t\tfor (; l < r;) {\n\t\t\t\tmid = l + r + 1 >> 1;\n\t\t\t\tif (check(L, mid, k))\n\t\t\t\t\tl = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tcout << r << \' \';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n}']",,,"['binary search', 'bitmasks', 'data structures', 'greedy']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Iva   Pav.json,https://codeforces.com//blog/entry/120813,We can for each bit calculate the prefix sums of the array is the number of occurrences of the th bit in the first elements of the array This can be calculated in We know that if then the th bit is present in all elements of the subsegment of the array which means the value of is equal to the sum of all bits for which this condition is true on the subsegment from to and we can calculate that in Next for each query we can use binary search to find by calculating If then we found an index for which the condition is true so we move the left to else we move the right to This solution works in which is around operations with a low constant factor It is possible to optimize the solution even more by using sparse tables to calculate in therefore removing the factor but we think that sparse tables are a little bit too advanced of a topic for div3 E so we didn t make that solution necessary 
https://codeforces.com//contest/1105/problem/D,284897,D,1105D,1105,D. Kilani and the Game,Kilani is playing a game with his friends This game can be represented as a grid of size n times m where each cell is either empty or blocked and every player has one or more castles in some cells there are no two castles in one cell The game is played in rounds In each round players expand turn by turn firstly the first player expands then the second player expands and so on The expansion happens as follows for each castle the player owns now he tries to expand into the empty cells nearby The player i can expand from a cell with his castle to the empty cell if it s possible to reach it in at most s i where s i is player s expansion speed moves to the left up right or down without going through blocked cells or cells occupied by some other player s castle The player examines the set of cells he can expand to and builds a castle in each of them at once The turned is passed to the next player after that The game ends when no player can make a move You are given the game field and speed of the expansion for each player Kilani wants to know for each player how many cells he will control have a castle their after the game ends ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\nvector<pair<int,int> > v[10],t;\nint n,m,p,s[10],a[1011][1101],ans[10],tn,d[4][2];\nchar str[1101];\n\nbool bfs(int x)\n{\n\tt.clear(),tn=v[x].size();\n\tfor (int i=0; i<tn; i++) t.pb(v[x][i]);\n\tv[x].clear();\n\tfor (int i=0; i<tn; i++)\n\t{\n\t\tint X=t[i].first,Y=t[i].second;\n\t\tfor (int j=0; j<4; j++)\n\t\t\tif (a[X+d[j][0]][Y+d[j][1]]==0) \n\t\t\t\ta[X+d[j][0]][Y+d[j][1]]=x,v[x].pb(mp(X+d[j][0],Y+d[j][1]));\n\t}\n\tif (!v[x].size()) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor (int i=0; i<=1001; i++)\n\t\tfor (int j=0; j<=1001; j++) a[i][j]=-1;\n\td[0][0]=d[1][0]=d[2][1]=d[3][1]=0;\n\td[0][1]=d[2][0]=1; d[1][1]=d[3][0]=-1;\n\tscanf(""%d%d%d"",&n,&m,&p);\n\tfor (int i=1; i<=p; i++) scanf(""%d"",&s[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%s"",str+1);\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (str[j]==\'#\') a[i][j]=-1; else\n\t\t\tif (str[j]==\'.\') a[i][j]=0; else\n\t\t\ta[i][j]=str[j]-\'0\',v[a[i][j]].pb(mp(i,j));\n\t}\n\twhile (1)\n\t{\n\t\tbool bo=0;\n\t\tfor (int i=1; i<=p; i++)\n\t\t\tfor (int j=1; j<=s[i]; j++) \n\t\t\t\tif (!bfs(i)) break; else bo=1;\n\t\tif (!bo) break;\n\t}\n\tmemset(ans,0,sizeof(ans));\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (a[i][j]>0) ans[a[i][j]]++;\n\tfor (int i=1; i<=p; i++) printf(""%d "",ans[i]); puts("""");\n\treturn 0;\n}\n']",,,"['dfs and similar', 'graphs', 'implementation', 'shortest paths']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Kilani and the Game.json,https://codeforces.com//blog/entry/64664,This problem can be solved in many ways one of them uses a bfs Let s process the first round Iterate over players and use a multi source bfs for each player from his starting castles to find cells reachable in at most moves A multi source bfs works just like regular one except you push more vertices in the queue in the beginning While moving we can t enter a blocked cell or an already controlled cell And in the each following turn do the same but start from the cells we stopped on the previous turn instead of starting castles Keep doing this until no player can move anymore Complexity 
https://codeforces.com//contest/1430/problem/B,755154,B,1430B,1430,B. Barrels,You have n barrels lined up in a row numbered from left to right from one Initially the i th barrel contains a i liters of water You can pour water from one barrel to another In one act of pouring you can choose two different barrels x and y the x th barrel shouldn t be empty and pour any possible amount of water from barrel x to barrel y possibly all water You may assume that barrels have infinite capacity so you can pour any amount of water in each of them Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels if you can pour water k times Some examples if you have four barrels each containing 5 liters of water and k 1 you may pour 5 liters from the second barrel into the fourth so the amounts of water in the barrels are 5 0 5 10 and the difference between the maximum and the minimum is 10 if all barrels are empty you can t make any operation so the difference between the maximum and the minimum amount is still 0 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nint n,k,a[200005];\nvoid solve(){\n\tscanf(""%d%d"",&n,&k);\n\tFor(i,1,n) scanf(""%d"",&a[i]);\n\tsort(a+1,a+n+1);\n\tll s1=0;\n\tFor(i,n-k,n) s1+=a[i];\n\tcout<<s1<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']",,,"['greedy', 'implementation', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Barrels.json,https://codeforces.com//blog/entry/83614,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible 
https://codeforces.com//contest/1925/problem/D,2447854,D,1925D,1925,D. Good Trip,There are n children in a class m pairs among them are friends The i th pair who are friends have a friendship value of f i The teacher has to go for k excursions and for each of the excursions she chooses a pair of children randomly equiprobably and independently If a pair of children who are friends is chosen their friendship value increases by 1 for all subsequent excursions the teacher can choose a pair of children more than once The friendship value of a pair who are not friends is considered 0 and it does not change for subsequent excursions Find the expected value of the sum of friendship values of all k pairs chosen for the excursions at the time of being chosen It can be shown that this answer can always be expressed as a fraction dfrac p q where p and q are coprime integers Calculate p cdot q 1 bmod 10 9 7 ,"[""#include <iostream>\n#include <vector>\n#include <string>\n\nconst int64_t MOD = 1000000007LL;\n\nusing namespace std;\n\nbool __hack = ios::sync_with_stdio(false);\nauto __hack1 = cin.tie(nullptr);\n\ntemplate<typename T>\nT next() {\n    T x;\n    cin >> x;\n    return x;\n}\n\nint64_t mod_pow(int64_t a, int64_t b) {\n    int64_t r = 1;\n    while (b) {\n        if (b & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return r;\n}\n\nint64_t mod_inv(int64_t a) {\n    return mod_pow(a, MOD - 2);\n}\n\nint main() {\n    vector<int64_t> fact(200001);\n    fact[0] = 1;\n    for (int i = 1; i < fact.size(); ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    vector<int64_t> inv_fact(200001);\n    inv_fact[fact.size() - 1] = mod_inv(fact[fact.size() - 1]);\n    for (int i = fact.size() - 2; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n    auto binomial = [&](int n, int k) {\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n    };\n    int tests = next<int>();\n    for (int test = 0; test < tests; ++test) {\n        int64_t n = next<int>();\n        int64_t m = next<int>();\n        int64_t k = next<int>();\n        int64_t ans = 0;\n        int64_t p = mod_inv(n * (n - 1) / 2 % MOD);\n        int64_t q = (1 + MOD - p) % MOD;\n        int64_t coeff = k * p % MOD;\n        int64_t add = 0;\n        for (int64_t i = 1; i <= k; ++i) {\n            int64_t s = i * (i - 1) / 2 % MOD;\n            add = (add + s * binomial(k, i) % MOD * mod_pow(p, i) % MOD * mod_pow(q, k - i) % MOD) % MOD;\n        }\n        for (int i = 0; i < m; ++i) {\n            int a = next<int>();\n            int b = next<int>();\n            int64_t f = next<int64_t>();\n            if (f) {\n                ans = (ans + coeff * f + add) % MOD;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n""]",,,"['combinatorics', 'dp', 'math', 'probabilities']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Good Trip.json,https://codeforces.com//blog/entry/125137,TutorialSince expected value is linear we can consider the contribution of initial friendship values and the contribution of increase in friendship values by repeated excursions independently Let denote the total number of pairs of students that can be formed Contribution of the initial friendship values will be Now to calculate the contribution to the answer by the increase in friendship values due to excursions for each pair of friends it will be where is the probability of a pair of friends to be selected for exactly out of the excursions which is given by Since the increase is uniform for all pair of friends we just have to multiply this value by and add it to the answer The time complexity is per test case 
https://codeforces.com//contest/1005/problem/E1,196329,E1,1005E1,1005,E1. Median on Segments  Permutations Edition ,You are given a permutation p 1 p 2 dots p n A permutation of length n is a sequence such that each integer between 1 and n occurs exactly once in the sequence Find the number of pairs of indices l r 1 le l le r le n such that the value of the median of p l p l 1 dots p r is exactly the given number m The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if a 4 2 7 5 then its median is 4 since after sorting the sequence it will look like 2 4 5 7 and the left of two middle elements is equal to 4 The median of 7 1 2 9 6 equals 6 since after sorting the value 6 will be in the middle of the sequence Write a program to find the number of pairs of indices l r 1 le l le r le n such that the value of the median of p l p l 1 dots p r is exactly the given number m ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, pos;\n    vector<int> A;\n    map<int, int> B;\n    ll sc;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    cin >> n >> m;\n\n    A.assign(n, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        if (A[i] == m) {\n            pos = i;\n        }\n    }\n\n    int cur = 0;\n    B[0]++;\n    for (int i = pos+1; i < n; i++) {\n        if (A[i] > m) {\n            cur++;\n        } else {\n            cur--;\n        }\n        B[cur]++;\n    }\n\n    cur = 0;\n    for (int i = pos-1; i >= 0; i--) {\n        if (A[i] > m) {\n            cur++;\n        } else {\n            cur--;\n        }\n        sc += B[-cur] + B[-cur + 1];\n    }\n\n    sc += B[0];\n    sc += B[1];\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n']",,,['sortings'],1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E1. Median on Segments  Permutations Edition .json,https://codeforces.com//blog/entry/60511,The segment has median equals if and only if belongs to it and or where is number of elements in that strictly less than and is number of elements in that strictly greater than Here we ve used a fact that is a permutation on there is exactly one occurrence of In other words belongs and the value equals or Calculate prefix sums where the value on the prefix of the length i e on the subarray For fixed value it is easy to calculate number of such that is suitable At first check that met on Valid values are such indices that no on and or Let s maintain number of prefix sums to the left of for each value We can use just a map where is number of such indices that and is to the left of So for each that contains do where is the current value Time complexity is if a standard map is used or if classical array for is used remember about possible negative indices just use an offset 
https://codeforces.com//contest/529/problem/D,25013,D,529D,529,D. Social Network,Polycarpus got an internship in one well known social network His test task is to count the number of unique users who have visited a social network during the day Polycarpus was provided with information on all user requests for this time period For each query we know its time and nothing else because Polycarpus has already accidentally removed the user IDs corresponding to the requests from the database Thus it is now impossible to determine whether any two requests are made by the same person or by different people But wait something is still known because that day a record was achieved simultaneous users online In addition Polycarpus believes that if a user made a request at second then he was online for seconds after that that is at seconds So the user s time online can be calculated as the union of time intervals of the form over all times of requests from him Guided by these thoughts Polycarpus wants to assign a user ID to each request so that the number of different users online did not exceed at any moment at some second the number of distinct users online reached value the total number of users the number of distinct identifiers was as much as possible Help Polycarpus cope with the test ,"['#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << "" = "" << x << endl\n#define _ << "" _ "" <<\n\ntypedef long long llint;\n\nconst int MAXT = 24*60*60;\nconst int MAXN = 20020;\n\nset<int> st[MAXT+10], en[MAXT+10];\n\nvector<int> E[MAXN];\nint a[MAXN];\nint l[MAXN], r[MAXN];\nint dad[MAXN];\nint ans[MAXN];\n\nstruct cmp {\n  bool operator () (const int &a, const int &b) {\n    if (r[a] != r[b]) return r[a] > r[b];\n    return a < b;\n  }\n};\n\nset<int, cmp> S;\n\nvoid dfs(int x, int a) {\n  ans[x] = a;\n  for (int y: E[x])\n    dfs(y, a);\n}\n\nint main(void) {\n  int n, m, T;\n  scanf(""%d %d %d"", &n, &m, &T);\n  REP(i, n) {\n    int h, m, s;\n    scanf(""%d:%d:%d"", &h, &m, &s);\n    a[i] = (h*60 + m)*60 + s;\n    st[a[i]].insert(i);\n    en[a[i]+T].insert(i);\n    l[i] = a[i], r[i] = a[i] + T;\n    dad[i] = i;\n  }\n\n  bool ok = false;\n  REP(i, MAXT) {\n    for (int j: st[i]) S.insert(j);\n    for (int j: en[i]) if (r[j] == i) S.erase(j);\n    \n    while ((int)S.size() > m) {\n      int x = *S.begin(); S.erase(S.begin());\n      int y = *S.begin(); S.erase(S.begin());\n      \n      en[r[x]].erase(x);\n      en[r[y]].erase(y);\n\n      E[x].push_back(y);\n      dad[y] = x;\n      r[x] = max(r[x], r[y]);\n      en[r[x]].insert(x);\n      S.insert(x);\n    }\n\n    ok |= (int)S.size() == m;\n  }\n\n  if (!ok) {\n    puts(""No solution"");\n    return 0;\n  }\n\n  int R = 0;\n  REP(i, n)\n    if (dad[i] == i) {\n      dfs(i, R);\n      R++;\n    }\n\n  printf(""%d\\n"", R);\n  REP(i, n) printf(""%d\\n"", ans[i]+1);\n  return 0;\n}\n']",,,"['data structures', 'greedy']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Social Network.json,https://codeforces.com//blog/entry/17065,Let s follow greedily in following way Iterate over all requests in a chronological order Let s try to associate each query to the new person Of course we can t always do that when there are already M active users on a site we should associate this request with some existing person Now we need to choose who it will be Let s show that the best way is to associate a request with the most recently active person Indeed such critical state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order If we are currently in the state a1 a2 aM then we can move to the one of the M new states a1 a2 aM 1 0 a1 a2 aM 2 aM 0 a2 a3 aM 0 depending on who we will associate the new request with We can see that the first vector is component wise larger then other ones so it is better than other states since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations So all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity As a such structure one can use anything implementing the priority queue interface priority queue set segment tree or anything else Complexity of such solution is 
https://codeforces.com//contest/967/problem/B,179482,B,967B,967,B. Watering System,Arkady wants to water his only flower Unfortunately he has a very poor watering system that was designed for n flowers and so it looks like a pipe with n holes Arkady can only use the water that flows from the first hole Arkady can block some of the holes and then pour A liters of water into the pipe After that the water will flow out from the non blocked holes proportionally to their sizes s 1 s 2 ldots s n In other words if the sum of sizes of non blocked holes is S and the i th hole is not blocked frac s i cdot A S liters of water will flow out of it What is the minimum number of holes Arkady should block to make at least B liters of water flow out of the first hole ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,u,v,a[120000];\n\nint main(){\n\tscanf(""%d%d%d"",&n,&u,&v);\n\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i);\n\tsort(a+2,a+n+1);\n\tlong long sum=a[1];\n\tfor(int i=2;i<=n;i++){\n\t\tsum+=a[i];\n\t\tif(sum*v>(long long)a[1]*u){\n\t\t\tprintf(""%d\\n"",n-i+1);return 0;\n\t\t}\n\t}\n\tputs(""0"");\n\treturn 0;\n}']",,,"['math', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Watering System.json,https://codeforces.com//blog/entry/59173,It s obvious that we should block several largest holes Let s first sort them After that let s iterate through the number of blocked holes maintaining the sum of sizes of non blocked holes With the value it is easy to compute if the flow from the first hole is large enough or not Just output the number of blocked pipes at the first moment when the flow is large enough The complexity is 
https://codeforces.com//contest/242/problem/E,2151,E,242E,242,E. XOR on Segment,You ve got an array consisting of integers You are allowed to perform two operations on this array Calculate the sum of current array elements on the segment that is count value Apply the xor operation with a given number to each array element on the segment that is execute This operation changes exactly array elements Expression means applying bitwise xor operation to numbers and The given operation exists in all modern programming languages for example in language and it is marked as in as You ve got a list of operations of the indicated type Your task is to perform all given operations for each sum query you should print the result you get ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nconst int maxn = 811111;\n\nstruct tree {\n\tint rev[maxn]; int cnt[maxn];\n\n\tinline void reverse(int x, int st, int ed) {\n\t\trev[x] ^= 1;\n\t\tcnt[x] = ed - st + 1 - cnt[x];\n\t}\n\n\tvoid change(int x, int st, int ed, int p, int q) {\n\t\tif (st == p && ed == q) {\n\t\t\treverse(x, st, ed); return ;\n\t\t}\n\n\t\tint mid = (st + ed) / 2;\n\t\tif (rev[x]) {\n\t\t\treverse(x + x, st, mid);\n\t\t\treverse(x + x + 1, mid + 1, ed);\n\t\t\trev[x] = 0;\n\t\t}\n\n\t\tif (q <= mid) {\n\t\t\tchange(x + x, st, mid, p, q);\n\t\t}\n\t\telse {\n\t\t\tif (p > mid) change(x + x + 1, mid + 1, ed, p, q);\n\t\t\telse {\n\t\t\t\tchange(x + x, st, mid, p, mid);\n\t\t\t\tchange(x + x + 1, mid + 1, ed, mid + 1, q);\n\t\t\t}\n\t\t}\n\n\t\tcnt[x] = cnt[x + x] + cnt[x + x + 1];\n\t}\n\n\tint calc(int x, int st, int ed, int p, int q) {\n\t\tif (st == p && ed == q) {\n\t\t\treturn cnt[x];\n\t\t}\n\n\t\tint mid = (st + ed) / 2;\n\t\tif (rev[x]) {\n\t\t\treverse(x + x, st, mid);\n\t\t\treverse(x + x + 1, mid + 1, ed);\n\t\t\trev[x] = 0;\n\t\t}\n\n\t\tint ret;\n\t\tif (q <= mid) ret = calc(x + x, st, mid, p, q);\n\t\telse {\n\t\t\tif (p > mid) ret =  calc(x + x + 1, mid + 1, ed, p, q);\n\t\t\telse ret = calc(x + x, st, mid, p, mid) + calc(x + x + 1, mid + 1, ed, mid + 1, q);\n\t\t}\n\n\t\tcnt[x] = cnt[x + x] + cnt[x + x + 1];\n\t\treturn ret;\n \t}\n\n} F[20];\n\n\nint main() {\n\tint n; scanf(""%d"", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x; scanf(""%d"", &x);\n\t\tfor (int j = 0; j < 20; ++j)\n\t\t\tif (x & (1 << j)) F[j].change(1, 1, n, i, i);\n\t}\n\tint m; scanf(""%d"", &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint t, p, q; scanf(""%d%d%d"", &t, &p, &q);\n\n\t\tif (t == 1) {\n\t\t\tlong long ans = 0ll;\n\t\t\tfor (int j = 0; j < 20; ++j) ans += (long long) (1 << j) * F[j].calc(1, 1, n, p, q);\n\t\t\tprintf(""%I64d\\n"", ans);\n\t\t}\n\t\telse {\n\t\t\tint x; scanf(""%d"", &x);\n\t\t\tfor (int j = 0; j < 20 ;++j) if (x & (1 << j)) F[j].change(1, 1, n, p, q);\n\t\t}\n\t}\n\n\treturn 0;\n}\n']",,,"['bitmasks', 'data structures']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. XOR on Segment.json,https://codeforces.com//blog/entry/5837,Let s write numbers as a table which has size and is th bit in Then sum of numbers on segment equals The last notation helps us to process queries For fast implementation we should use 20 binary trees like cartesian trees or range trees Every tree matchs one of bits and matchs one of the columns of the table calculation of sum is equal to counting s from th to th operation xor equals reversing all bits from th to th i e changes to changes to The first operation executes for all bit numbers the second executes only for bits in which input number has ones These operations may be easy implemented with binary trees The time is 
https://codeforces.com//contest/1551/problem/F,1055226,F,1551F,1551,F. Equidistant Vertices,A tree is an undirected connected graph without cycles You are given a tree of n vertices Find the number of ways to choose exactly k vertices in this tree i e a k element subset of vertices so that all pairwise distances between the selected vertices are equal in other words there exists an integer c such that for all u v u ne v u v are in selected vertices d u v c where d u v is the distance from u to v Since the answer may be very large you need to output it modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n    \nconst int MOD=1000000007;\nstruct Mint {\n    int val;\n \n    Mint(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n        if (v >= MOD)\n            v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        int g = m, r = a, x = 0, y = 1;\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        } \n        return x < 0 ? x + m : x;\n    } \n    explicit operator int() const {\n        return val;\n    }\n    Mint& operator+=(const Mint &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    Mint& operator-=(const Mint &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n           #if !defined(_WIN32) || defined(_WIN64)\n                return x % m;\n           #endif\n           unsigned x_high = x >> 32, x_low = (unsigned) x;\n           unsigned quot, rem;\n           asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n           return rem;\n    }\n    Mint& operator*=(const Mint &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n    Mint& operator/=(const Mint &other) {\n        return *this *= other.inv();\n    }\n    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }\n    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }\n    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }\n    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }\n    Mint& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n    Mint& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }\n    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }\n    Mint operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n    bool operator==(const Mint &other) const { return val == other.val; }\n    bool operator!=(const Mint &other) const { return val != other.val; }\n    Mint inv() const {\n        return mod_inv(val);\n    }\n    Mint power(long long p) const {\n        assert(p >= 0);\n        Mint a = *this, result = 1;\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n        return result;\n    }\n    friend ostream& operator << (ostream &stream, const Mint &m) {\n        return stream << m.val;\n    }\n    friend istream& operator >> (istream &stream, Mint &m) {\n        return stream>>m.val;   \n    }\n};\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    vector<vector<int>> g(n+1);\n    for(int i=1;i<=n-1;++i)\n    {\n        int x,y;\n        cin >> x >> y;\n        g[x].push_back(y),g[y].push_back(x);\n    }\n    vector<int> dep(n+1);\n    Mint ans = 0;\n    vector<vector<int>> cnt(n+1,vector<int>(n+1,0));\n    int have = 0;\n    function<void(int,int,int)> dfs = [&](int s,int p,int tt)\n    {\n        int cur = 0;\n        ++cnt[dep[s]][tt];\n        for(auto &j:g[s])\n        {\n            if(j != p)\n            {\n                dep[j] = dep[s] + 1;\n                if(p == 0)\n                    dfs(j,s,++cur);\n                else\n                    dfs(j,s,tt);\n            }\n        }\n        if(p == 0)\n            have = cur;\n    };\n    if(k == 2)\n    {\n        cout << Mint(n) * Mint(n-1)/2 << ""\\n"";\n        return 0;\n    }\n    int K = k;\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=0;j<=n;++j)\n        {\n            for(int k=0;k<=n;++k)\n                cnt[j][k] = 0;\n            dep[j] = 0;\n        }\n        dfs(i,0,0);\n        vector<vector<Mint>> dp(have+1,vector<Mint>(k+1,0));\n        debug(have);\n        // continue;\n        for(int j=1;j<=n;++j)\n        {\n            int t = 0;\n            vector<int> want;\n            for(int k=1;k<=have;++k)\n            {\n                if(cnt[j][k] > 0)\n                    want.push_back(cnt[j][k]);\n            }\n            t = sz(want);\n            debug(i,j,want);\n            if(t < K)\n                break;\n            for(int k=1;k<=t;++k)\n                for(int l=0;l<=K;++l)\n                    dp[k][l] = 0;\n            dp[0][0] = 1;\n            for(int x=1;x<=t;++x)\n            {\n                for(int l=0;l<=K;++l)\n                {\n                    if(l == 0)\n                        dp[x][l] = dp[x-1][l];\n                    else\n                        dp[x][l] = dp[x-1][l] + dp[x-1][l-1] * want[x-1];\n                }\n            }\n            ans += dp[t][K];\n        }\n        // debug(i,int(ans));\n    }\n    cout << ans << ""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']",,,"['brute force', 'combinatorics', 'dfs and similar', 'dp', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Equidistant Vertices.json,https://codeforces.com//blog/entry/93149,If any set of two vertices may be taken so the answer is modulo Suppose Consider three vertices such that If this equality is true there s a vertex that belongs to all three paths otherwise either one of the vertices belongs to the path between two others or there is more than one simple path i e path having distinct edges between any of the vertices so the graph isn t a tree Hence the following equalities are true Then hence Suppose Let s select vertices that is a correct desired set of four vertices for the triple of paths let s select a common vertex and for the triple Because is the same vertex as The same procedure we can do for all other pairs of triples of vertices The situation will not be another if we add a new vertex in the set if the set will still meet the problem s conditions So if a vertex exists such that all vertices of the set are equidistant from it Note that for each set only one such exists Let s iterate over all vertices taking them as and hang the tree by The set of vertices equidistant from meets the problem s condition if and only if the vertices of the set are placed in different subtrees of vertices adjacent to in other words the paths from them to must intersect only in Let s calculate the number of desired sets for a given and a layer of equidistant vertices Let be the number of vertices adjacent to and it s the number of subtrees too Let s create an array indexed of size so that the th element will contain the number of the vertices of the layer in the th subtree For the layer of vertices adjacent to this array will be filled with For the other layers we can update the array as follows let s mark and vertices adjacent to as used then for every vertex of the current layer let s decrease by if is the index of the subtree of the vertex then let s increase by the number of the vertices adjacent to the current one but not used Then let s mark the vertices as used After the iteration the array will correspond to the new layer Using the array let s calculate the number of the desired sets of vertices using the concept of dynamic programming Let s create an array indexed of size will contain a number of found sets of vertices if only subtrees have been considered Let s fill the array with except Let s start a loop with parameter from to and the internal one with parameter from to In every step we can either take a vertex from th subtree or take nothing If we take a vertex from the subtree it s possible only if then we have ways to select vertices considering subtrees so that the last vertex belongs to the th subtree This value we must add to that must contain all ways to select vertices from subtrees If we ignore the subtree the number of ways to select vertices from subtrees ignoring the th subtree is It must be added to the number of ways to select vertices from subtrees The answer for the current and the current layer of equidistant vertices is The answer for the whole tree is the sum of the answers for all and for all layers of equidistant vertices Remember that all arithmetical operations must be done modulo The number of possible central vertices is For every central vertex and every layer we perform two actions recalculate the array and calculate the number of the corresponding sets using the concept of dynamic programming The recalculation of works in it s just BFS starting from so for every central vertex it works in O n The dynamic programming for the current and the current layer works in for the current and all layers in The summary time corresponding to the current is The total algorithm work time is The sum of all is a total number of the adjacent vertices to all vertices it s just a double number of edges So the total work time is 
https://codeforces.com//contest/1462/problem/B,833570,B,1462B,1462,B. Last Year's Substring,Polycarp has a string s 1 dots n of length n consisting of decimal digits Polycarp performs the following operation with the string s i e he can perform operation 0 or 1 time Polycarp selects two numbers i and j 1 leq i leq j leq n and removes characters from the s string at the positions i i 1 i 2 ldots j i e removes substring s i dots j More formally Polycarp turns the string s into the string s 1 s 2 ldots s i 1 s j 1 s j 2 ldots s n For example the string s Polycarp can turn into strings in this case i j 3 6 or i j 1 4 in this case i j 6 6 in this case i j 1 5 other operations are also possible only a few of them are listed above Polycarp likes the string very much so he is wondering if it is possible to turn the string s into a string in no more than one operation Note that you can perform zero operations ,"['#include <bits/stdc++.h>\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define si short int\n#define speed ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define pill pair<ll,ll>\n#define f first\n#define s second\n#define pilc pair<ll,char>\n#define all(a) (a).begin(),(a).end()\n#define rep(s,e,step) for(int i = (s); i < (e) ; i += step)\n#define vrep(s,e,step) for(int j = (s); j < (e) ; j += step)\n#define ex exit(0) \n#define sz(a) (a).size()\n#define triple pair<pill, ll>\n#define pinode pair<node*, node*>\n#define quadra pair<pill, pill>\n#define ld long double\nusing namespace std;\n \nconst ll N = 2e5 + 10;\nconst ll M = 2e5 + 1;\nconst ll big = 1e18;\nconst ll hsh2 = 1964325029 ;\nconst long long mod = 1e9 + 7;\nconst long double EPS = 1e-14;\nconst ll block = 1e7;\nconst ll shift = 2e3;\nmt19937_64 rofl(chrono::steady_clock::now().time_since_epoch().count());\n\nll t;\n\nvoid solve() {\n\tll n;\n\tstring a;\n\tcin >> n >> a;\n\tll L = 0, R = 0;\n\tstring x, y, p = ""2020"";\n\tfor(int j = 0; j < 4; j++) {\n\t\tx += a[j];  \t        \n\t\tif(x == p.substr(0, j + 1))\n\t\t\tL = j + 1;\n\t}\n\tfor(int j = n - 1; j >= n - 4; j--) {\n\t\ty = a[j] + y;\n\t\tif(y == p.substr(4 - (n - j), (n - j)))\n\t\t\tR = n - j;\n\t}\n\tif(L + R >= 4)\n\t\tcout << ""yEs\\n"";\n\telse\n\t\tcout << ""nO\\n"";\n}\n\nint main() {\n\tspeed;\n\tcin >> t;\n\twhile(t--)solve(); \t\n}              \n/*\nqiwwqdesw\n1\nd\n \n*/']",,,"['dp', 'implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Last Year's Substring.json,https://codeforces.com//blog/entry/85594,Let s see how the deleted substring should look so that after deleting it the string turns into the string The length of the string must be Then we can iterate over all substrings of the string of length there are no more than five such substrings and look at the string obtained after deleting the substring That is we need to check that one of the following character sequence matches the 
https://codeforces.com//contest/1217/problem/C,404645,C,1217C,1217,C. The Number Of Good Substrings,You are given a binary string s recall that a string is binary if each character is either 0 or 1 Let f t be the decimal representation of integer t written in binary form possibly with leading zeroes For example f 011 3 f 00101 5 f 00001 1 f 10 2 f 000 0 and f 000100 4 The substring s l s l 1 dots s r is good if r l 1 f s l dots s r For example string s 1011 has 5 good substrings s 1 dots s 1 1 s 3 dots s 3 1 s 4 dots s 4 1 s 1 dots s 2 10 and s 2 dots s 4 011 Your task is to calculate the number of good substrings of string s You have to answer t independent queries ,"['#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/05, 23:45:33\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nchar in[200002];\nint L[200001];\nllong solve() {\n    cin >> in + 1;\n    int n = strlen(in + 1);\n    L[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (in[i] == \'0\') L[i] = L[i - 1];\n        else L[i] = i + 1;\n    }\n    llong ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        int x = 0;\n        for (int j = i; j > 0 && i - j <= 20; --j) {\n            if (in[j] == \'1\') x |= 1 << i - j;\n            if (i - j + 1 == x) ++ans;\n        }\n        if (i - 20 > 1) {\n            int l = L[i - 20 - 1];\n            int mn = 22;\n            int mx = i - l + 1;\n            if (mn <= x && x <= mx) ++ans;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) printf(""%lld\\n"", solve());\n    return 0;\n}\n']",,,"['binary search', 'bitmasks', 'brute force']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. The Number Of Good Substrings.json,https://codeforces.com//blog/entry/69605,At first lets precalc the array The value of if equal the maximum position in range such that After that lets iterate over the right boundary of substring and high bit position denote it as and respectively Note that if then So we iterate over such pair that and Lets look at value If then we have to increase the length of substring without increasing the value of So we need to check if there exists a position such that and This position exists if the condition is met is equal to 1 
https://codeforces.com//contest/1238/problem/A,434105,A,1238A,1238,A. Prime Subtraction,You are given two integers x and y it is guaranteed that x y You may choose any integer p and subtract it any number of times from x Is it possible to make x equal to y Recall that a number is a positive integer that has exactly two positive divisors 1 and this integer itself The sequence of prime numbers starts with 2 3 5 7 11 Your program should solve t independent test cases ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint main(){\n\tint q; cin>>q;\n\twhile(q--){\n\t\tll x,y; cin >> x >> y; x -= y;\n\t\tif(x == 1) puts(""NO"");\n\t\telse puts(""YES"");\n\t}\n}']",,,"['math', 'number theory']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Prime Subtraction.json,https://codeforces.com//blog/entry/70450,Let s denote the difference between and as Then if has a prime divisor we can subtract from times The only positive integer that doesn t have any prime divisors is So the answer is if and only if 
https://codeforces.com//contest/1520/problem/C,976798,C,1520C,1520,C. Not Adjacent Matrix,We will consider the numbers a and b as adjacent if they differ by exactly one that is a b 1 We will consider cells of a square matrix n times n as adjacent if they have a common side that is for cell r c cells r c 1 r c 1 r 1 c and r 1 c are adjacent to it For a given number n construct a square matrix n times n such that Each integer from 1 to n 2 occurs in this matrix exactly once If r 1 c 1 and r 2 c 2 are adjacent cells then the numbers written in them ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl ""\\n""\n\n#define sz(x) int((x).size())\n\nmt19937 cowng(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> gen(int n) {\n\twhile(true) {\n\t\tvector<int> arr(n);\n\t\tiota(begin(arr), end(arr), 0);\n\t\tshuffle(begin(arr), end(arr), cowng);\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tif(abs(arr[i] - arr[i + 1]) <= 1) {\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t\tloop:;\n\t}\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tif(n == 1) {\n\t\tcout << 1 << endl;\n\t}else if(n == 2) {\n\t\tcout << -1 << endl;\n\t}else if(n == 3) {\n\t\tcout << ""2 9 7\\n""\n\t\t\t\t""4 6 3\\n""\n\t\t\t\t""1 8 5"" << endl;\n\t}else {\n\t\tvector<int> cur = gen(n);\n\t\tfor(int i = 0; i < n * n; i += n) {\n\t\t\tvector<int> v;\n\t\t\tfor(int j = i + 1; j <= i + n; j++) {\n\t\t\t\tv.push_back(j);\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcout << v[cur[j]] << "" "";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']",,,['constructive algorithms'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Not Adjacent Matrix.json,https://codeforces.com//blog/entry/90342,Note that is the only case where there is no answer For other cases consider the following construction Let s say that the cell is white if is an even number otherwise we will say that the cell is black Let s arrange the cells so that all white cells are first and if the colors are equal the cells will be compared lexicographically Arrange numbers from to in ordered cells For example for the following matrix will be constructed 
https://codeforces.com//contest/276/problem/D,2660,D,276D,276,D. Little Girl and Maximum XOR,A little girl loves problems on bitwise operations very much Here s one of them You are given two integers and Let s consider the values of for all pairs of integers and Your task is to find the maximum value among all considered ones Expression means applying bitwise excluding or operation to integers and The given operation exists in all modern programming languages for example in languages and it is represented as in as ,"['#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll p[62];\nint main()\n{\n    p[0]=1;\n    for(int i=1;i<62;i++)p[i]=p[i-1]*2;\n    ll L,R;\n    cin>>L>>R;\n    for(int i=61;i>=0;i--)\n        if(L>=p[i]&&R>=p[i])L-=p[i],R-=p[i];else \n        if(L<p[i]&&R>=p[i])break;\n    if(L==R){puts(""0"");return 0;}\n    for(int i=61;i>=0;i--)\n        if(L<p[i]&&R>=p[i]){cout<<p[i+1]-1<<endl;return 0;}\n    return 0;\n}']",,,"['bitmasks', 'dp', 'greedy', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Little Girl and Maximum XOR.json,https://codeforces.com//blog/entry/6779,To be honest I am surprised that problem D had so many accepted solution during the contest The author s solution uses dynamic programming In this editorial I ll explain this solution First of all we should convert and to the binary numeral system Now we can solve our problem with dynamic programming using the following state where is current position in binary representation of our numbers and this parameter is in range from to number of bits in or is a variable which shows if current value of is strictly greater than is a variable which shows if current value of is strictly less then are variables which show the similar things for Let s use recursion with memorization for our solution Let s define the base of recursion If we have looked through all the bits we should return Let s define a recursive transition We need to know which bits we can place into binary representation of number in th position We can place if the following condition is true th bit of is equal to or th bit of is equal to and variable shows that current value of is strictly greater then Similarly we can place if the following condition is true th bit of is equal to or th bit of is equal to and variable shows that current value of is strictly less then Similarly we can obtain which bits we can place into binary representation of number in th position Let s iterate through all possible bits values and check the result of xor operation If it is equal to we should add to the answer corresponding power of We also need carefully recalculate values of variables We should choose maximum answer from all valid options Initial state for our recursion is where is number of bits in I hope my code will clarify all the obscure points 
https://codeforces.com//contest/710/problem/E,68763,E,710E,710,E. Generate a String,wants to generate an input file for some programming competition problem His input is a string consisting of letters a He is too lazy to write a generator so he will manually generate the input in a text editor Initially the text editor is empty It takes him seconds to insert or delete a letter a from the text file and seconds to copy the contents of the entire text file and duplicate it wants to find the minimum amount of time needed for him to create the input file of exactly letters a Help him to determine the amount of time needed to generate the input ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <ctype.h>\n#include <deque>\n#include <queue>\n#include <cstring>\n#include <set>\n#include <list>\n#include <map>\n#include <random>\n#include <unordered_map>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<bool> vb;\ntypedef std::vector<string> vs;\ntypedef std::vector<double> vd;\ntypedef std::vector<long long> vll;\ntypedef std::vector<std::vector<int> > vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef std::vector<std::pair<int, int> > vpi;\ntypedef vector<vpi> vvpi;\ntypedef std::pair<int, int> pi;\ntypedef std::pair<ll, ll> pll;\ntypedef std::vector<pll> vpll;\n\nconst long long mod = 1000000007;\n\n#define all(c) (c).begin(),(c).end()\n#define sz(c) (int)(c).size()\n#define forn(i, a, b) for(int i = a; i < b; i++)\n\n#define pb push_back\n#define mp make_pair\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n    int n,x,y;\n    cin>>n>>x>>y;\n    vll ans(n+1);\n    ans[1] = x;\n    forn(k,2,n+1) {\n        ans[k] = ans[k-1] + x;\n        if (k%2 == 0) ans[k] = min(ans[k], ans[k/2] + y);\n        else {\n            ans[k] = min(ans[k], ans[(k+1)/2] + x + y);\n        }\n    }\n    cout<<ans[n];\n    \n    \n    \n}\n\n\n']",,,"['dfs and similar', 'dp']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Generate a String.json,https://codeforces.com//blog/entry/46761,The problem was suggested by Zi Song Yeoh zscoder This problem has a simple solution described by participants in the comments My solution is a little harder Let s solve it using dynamic programming Let be the smallest amount of time needed to get letters a Let s consider transitions the transition for adding one letter a can be simply done Let s process transitions for multiplying by two and subtraction by one simultaneously let s decrease the number times by one right after getting it Easy to see that such updates never include each other so we can store them in queue by adding the new update at the tail of the queue and taking the best update from the head The solution is hard to describe but it is very simple in the code so please check it to understand the idea C solution 
https://codeforces.com//contest/1944/problem/A,2535049,A,1944A,1944,A. Destroying Bridges,There are n islands numbered 1 2 ldots n Initially every pair of islands is connected by a bridge Hence there are a total of frac n n 1 2 bridges Everule lives on island 1 and enjoys visiting the other islands using bridges Dominater has the power to destroy at most k bridges to minimize the number of islands that Everule can reach using possibly multiple bridges Find the minimum number of islands including island 1 that Everule can visit if Dominater destroys bridges optimally ,"['#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl \'\\n\'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nvoid work() {\n\tint n,k; cin>>n>>k;\n\tFor(i,1,n) {\n\t\tif(k>=i*(n-i)) return cout<<i<<endl,void();\n\t}\n}\nint main() {\n#ifdef LOCAL\n\tfreopen("".in"",""r"",stdin);\n\t// freopen("".out"",""w"",stdout);\n\t// freopen("".debug"",""w"",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}']",,,"['graphs', 'greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Destroying Bridges.json,https://codeforces.com//blog/entry/127195,O n SolutionAtleast bridges need to burnt the bridges connecting the reachable islands and the non reachable islands A simple solution is for every from to check if in which case print and break 
https://codeforces.com//contest/1788/problem/D,1767774,D,1788D,1788,D. Moving Dots,We play a game with n dots on a number line The initial coordinate of the i th dot is x i These coordinates are distinct Every dot starts moving simultaneously with the same constant speed Each dot moves in the direction of the closest dot different from itself until it meets another dot In the case of a tie it goes to the left Two dots meet if they are in the same coordinate after that they stop moving After enough time every dot stops moving The result of a game is the number of distinct coordinates where the dots stop Because this game is too easy calculate the sum of results when we play the game for every subset of the given n dots that has at least two dots As the result can be very large print the sum modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n    int x;\n    scanf(""%d"",&x);\n    return x;\n}\nconst int N=3005,mod=1e9+7;\ninline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\nint n,a[N];\nint pw[N];\nint main(){\n    n=in();\n    pw[0]=1;\n    for(int i=1;i<=n;i++)a[i]=in(),pw[i]=add(pw[i-1],pw[i-1]);\n    int ans=0;\n    for(int l=1;l<=n;l++){\n        for(int r=l+1;r<=n;r++){\n            int x=lower_bound(a+1,a+n+1,a[l]+a[l]-a[r])-a-1;\n            int y=lower_bound(a+1,a+n+1,a[r]+a[r]-a[l])-a;\n            ans=add(ans,pw[x+n-y+1]);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}']",,,"['binary search', 'brute force', 'combinatorics', 'math', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Moving Dots.json,https://codeforces.com//blog/entry/112584,Let s think about the original problem where we do not think about subsets We can easily observe that each dot does not change direction during moving Assume that dots gather at coordinate Rightmost dot of dots that have smaller coordinate than should move right and leftmost dot which has bigger coordinate than should move left We can observe that the number of adjacent dot where each move toward each other will be the answer Now let s solve the problem for subsets Instead of counting number of adjacent dot that moves toward each other for each subset of dots we will count the number of subset for each possible where dot moves right and dot moves left and there are no dots between and Let the coordinate of a dot in a subset be We will try to find out which can be in a subset where dot and dot move toward each other Since there are no dot between and dots satisfying should not be in the subset Since dot should move right dots that satisfy and should not be in the subset As the same way for dot dots that satisfy and should not be in the subset Summing these up dots satisfying should not be in the subset By using binary search we can find the number of dots that cannot be in the subset in If there are dots that can be in the subset the number of subset where and moves toward each other will be Summing all will give us the answer Since there are pairs of we can solve the problem in Instead of using binary search we can use the monotonicity of and when increases we can solve the range of dots that cannot be in the subset in by sweeping Both and solutions will be accepted There were some dynamic programming solutions from some testers 
https://codeforces.com//contest/1863/problem/D,2186455,D,1863D,1863,D. Two-Colored Dominoes,There is an n times m board divided into cells There are also some dominoes on this board Each domino covers two adjacent cells that is two cells that share a side and no two dominoes overlap Piet thinks that this board is too boring and it needs to be painted He will paint the cells of the dominoes black and white He calls the painting if all of the following conditions hold for each domino one of its cells is painted white and the other is painted black for each row the number of black cells in this row equals the number of white cells in this row for each column the number of black cells in this column equals the number of white cells in this column Note that the cells that are not covered by dominoes are not painted at all they are counted as neither black nor white Help Piet produce a beautiful painting or tell that it is impossible ,"['/**\n *    author:  tourist\n *    created: 30.08.2023 10:41:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<string> s(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n    }\n    bool fail = false;\n    for (int i = 0; i < n - 1; i++) {\n      vector<int> pos;\n      for (int j = 0; j < m; j++) {\n        if (s[i][j] == \'U\') {\n          pos.push_back(j);\n        }\n      }\n      if (pos.size() % 2 == 1) {\n        fail = true;\n        break;\n      }\n      for (int id = 0; id < (int) pos.size(); id++) {\n        int j = pos[id];\n        if (id % 2 == 0) {\n          s[i][j] = \'W\';\n          s[i + 1][j] = \'B\';\n        } else {\n          s[i][j] = \'B\';\n          s[i + 1][j] = \'W\';\n        }\n      }\n    }\n    for (int j = 0; j < m - 1; j++) {\n      vector<int> pos;\n      for (int i = 0; i < n; i++) {\n        if (s[i][j] == \'L\') {\n          pos.push_back(i);\n        }\n      }\n      if (pos.size() % 2 == 1) {\n        fail = true;\n        break;\n      }\n      for (int id = 0; id < (int) pos.size(); id++) {\n        int i = pos[id];\n        if (id % 2 == 0) {\n          s[i][j] = \'W\';\n          s[i][j + 1] = \'B\';\n        } else {\n          s[i][j] = \'B\';\n          s[i][j + 1] = \'W\';\n        }\n      }\n    }\n    if (fail) {\n      cout << -1 << \'\\n\';\n    } else {\n      for (int i = 0; i < n; i++) {\n        cout << s[i] << \'\\n\';\n      }\n    }\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Two-Colored Dominoes.json,https://codeforces.com//blog/entry/119902,Let s consider the requirement on the rows Clearly all horizontal dominoes since each of them has black and white cell do not influence the black white balance for the rows Thus we are only interested in vertical dominoes Consider the first row and the vertical dominoes that intersect this row Their number has to be even otherwise the first row has an odd number of cells covered by dominoes and the solution is clearly impossible But if there is an even number of such dominoes we have to paint half of them black white and half of them white black What s more it doesn t actually matter the exact order we paint them in because vertical dominoes do not affect the columns balance and we will not influence the balance of the second row anyway So we can freely paint them however we like The same logic applies for rows Now we turn to horizontal dominoes In the first row there once again has to be an even number of dominoes which intersect this column And we can paint half them black white and half of them white black and it doesn t matter which exact way we choose Do the same for columns 
https://codeforces.com//contest/1741/problem/A,1580857,A,1741A,1741,A. Compare T-Shirt Sizes,Two T shirt sizes are given a and b The T shirt size is either a string or a string consisting of several possibly zero characters and one of the characters or For example strings could be the size of some T shirts And the strings are not sizes The letter stands for medium for small for large The letter refers to the degree of size from eXtra For example is extra extra large bigger than and smaller than You need to compare two given sizes of T shirts a and b The T shirts are compared as follows any small size no matter how many letters is smaller than the medium size and any large size any large size regardless of the number of letters is larger than the medium size and any small size the more letters before the smaller the size the more letters in front of the larger the size For example ,"['#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nint parse(string s) {\n  if (s == ""M"") return 0;\n  int i = 0;\n  while (i < s.size() && s[i] == \'X\') i++;\n  i++;\n  if (s.back() == \'S\') i *= -i;\n  return i;\n}\n\nvoid solve() {\n  string s1, s2;\n  cin >> s1 >> s2;\n  if (s1 == s2) {\n    cout << ""=\\n"";\n  } else if (parse(s1) < parse(s2)) {\n    cout << ""<\\n"";\n  } else {\n    cout << "">\\n"";\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n']",,,"['implementation', 'implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Compare T-Shirt Sizes.json,https://codeforces.com//blog/entry/107908,Let are the last characters of lines and respectively And are the sizes of these strings then the answer depends only on and and is uniquely defined as the inverse of to if if since the characters are in reverse order in the alphabet Then the answer is This also covers the case Then the larger the size of the string the smaller the size of the t shirt That is the answer is if and if Then the larger the size of the string the smaller the size of the t shirt That is the answer is if and if 
https://codeforces.com//contest/1005/problem/E2,196330,E2,1005E2,1005,E2. Median on Segments  General Case Edition ,You are given an integer sequence a 1 a 2 dots a n Find the number of pairs of indices l r 1 le l le r le n such that the value of median of a l a l 1 dots a r is exactly the given number m The median of a sequence is the value of an element which is in the middle of the sequence after sorting it in non decreasing order If the length of the sequence is even the left of two middle elements is used For example if a 4 2 7 5 then its median is 4 since after sorting the sequence it will look like 2 4 5 7 and the left of two middle elements is equal to 4 The median of 7 1 2 9 6 equals 6 since after sorting the value 6 will be in the middle of the sequence Write a program to find the number of pairs of indices l r 1 le l le r le n such that the value of median of a l a l 1 dots a r is exactly the given number m ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n , m;\nint a[400020 + 5];\nconst int MAXN = (2e5 + 20) * 25;\n  struct Node {\n    int val, size;\n    Node *ls, *rs;\n    Node(int _val, int _size, Node *_ls, Node *_rs) : val(_val), size(_size), ls(_ls), rs(_rs) {}\n    Node() {}\n    inline void pushup() {\n      if (!ls->size) return ;\n      val = rs->val, size = ls->size + rs->size;\n    }\n  } pool[MAXN<<1], *st[MAXN<<1], *root, *null;\nstruct LFT {\n  int cnt;\n  inline Node *newNode(int val, int size, Node *ls, Node *rs) {\n    return &(*st[cnt++] = Node(val, size, ls, rs));\n  }\n  inline Node *merge(Node *ls, Node *rs) {\n    return newNode(rs->val, ls->size + rs->size, ls, rs);\n  }\n  inline void maintain(Node *cur) {\n    Node *&ls = cur->ls, *&rs = cur->rs;\n    if (ls->size > rs->size * 4)\n      rs = merge(ls->rs, rs), st[--cnt] = ls, ls = ls->ls;\n    if (rs->size > ls->size * 4)\n      ls = merge(ls, rs->ls), st[--cnt] = rs, rs = rs->rs;\n  }\n  void insert(Node *cur, int x) {\n    if (cur->size == 1)\n      cur->ls = newNode(min(cur->val, x), 1, null, null),\n           cur->rs = newNode(max(cur->val, x), 1, null, null);\n    else insert(x > cur->ls->val ? cur->rs : cur->ls, x);\n    cur->pushup();\n    maintain(cur);\n  }\n  int kth(Node *cur, int x) {\n    if (cur->size == 1) return cur->val;\n    return x > cur->ls->size ? kth(cur->rs, x - cur->ls->size): kth(cur->ls, x);\n  }\n  int Rank(Node *cur, int x) {\n    if (cur->size == 1) return x > cur->val;\n    return x > cur->ls->val ? Rank(cur->rs, x) + cur->ls->size : Rank(cur->ls, x);\n  }\n  LFT(){for(int i = 0; i < (MAXN<<1); ++i) st[i] = &pool[i]; root = new Node(2147483647, 1, null, null); null = new Node(0, 0, 0, 0);}\n}T;\nstruct seg\n{\n    int l , r;\n    Node *rt;\n}node[400020 * 4];\nvoid build(int u,int l,int r)\n{\n    node[u].l = l , node[u].r = r;\n    node[u].rt = NULL;\n    if(l == r) {a[l] = u;return;}\n    build(u<<1 , l , (l + r) >> 1);\n    build(u<<1|1 , ((l + r) >> 1) + 1 , r);\n    return;\n}\nvoid upd(int u,int v)\n{\n    while(u){\n        if(!node[u].rt) node[u].rt = T.newNode(v , 1 , null , null);\n        else T.insert(node[u].rt , v);\n        //printf(""INS %d %d %d\\n"",node[u].l,node[u].r,v);\n        u >>= 1;\n    }\n    return;\n}\nint Query(int u,int l,int r,int v)\n{\n    if(r < l) return 0;\n    if(node[u].l == l && node[u].r == r){\n        //printf(""Q %d %d %d\\n"",l,r,v);\n        if(!node[u].rt) return 0;\n        return T.Rank(node[u].rt , v+1);\n    }\n    if(r <= node[u<<1].r) return Query(u<<1 , l , r , v);\n    else if(l >= node[u<<1|1].l) return Query(u<<1|1 , l , r , v);\n    else return Query(u<<1 , l , node[u<<1].r , v) + Query(u<<1|1 , node[u<<1|1].l , r , v);\n}\nint main()\n{\n    //freopen(""in.txt"",""r"",stdin);\n    scanf(""%d%d"",&n,&m);\n    int x = 0, y = 0, L = 0;\n    build(1 , 1 , n*2 + 6);\n    long long ans = 0;\n    for(int i = 1;i <= n;i++){\n        upd(a[n*2 + 2 - (x*2 - L + n + 1)], n*2 + 2 - (y*2 - L + n + 1));\n        //printf(""  UPD %d %d\\n"",x*2-L+n+1,y*2-L+n+1);\n        int p;scanf(""%d"",&p);\n        if(p < m) x++;\n        else if(p > m) y++;\n        L++;\n        int pp = 0;\n        pp = Query(1 , 1 , n*2 + 2 - (x*2 - L + n + 2) , n*2 + 2 -(y*2 - L + n + 1));\n        ans += pp;\n        //printf(""         AT %d %d\\n"",i,pp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n']",,,['sortings'],2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E2. Median on Segments  General Case Edition .json,https://codeforces.com//blog/entry/60511,Let s define a function greaterCount number of subarrays with median greater or equal than In this case the answer on the problem is greaterCount greaterCount The subarray has median greater or equal than if and only if where is the number equal or greater than elements and is the number of less than elements In other words instead of processing you can use the sequence containing or and An element if An element if Now the median of is greater or equal than if and only if Let s iterate over from left to right Maintain the current partial sum Additionally in the array let s maintain the number of partial sum for each its value It means that before increase of you should do So if is the index of the right endpoint of a subarray i e then number of suitable indices is number of such that In other words find sum of all where it is exactly number of indices with partial sum less than Each time partial sum changes on or So the value sum of all where is easy to recalculate on each change If you decrease just subtract the value If you increase before increasing just add Since indices in can be from to you can use 0 based indices using an array In this case initialize as but not as it makes to be non negative on each step This solution works in 
https://codeforces.com//contest/737/problem/B,81050,B,737B,737,B. Sea Battle,Galya is playing one dimensional Sea Battle on a grid In this game ships are placed on the grid Each of the ships consists of consecutive cells No cell can be part of two ships however the ships each other Galya doesn t know the ships location She can shoot to some cells and after each shot she is told if that cell was a part of some ship this case is called hit or not this case is called miss Galya has already made shots all of them were misses Your task is to calculate the minimum number of cells such that if Galya shoot at all of them she would hit at least one ship It is guaranteed that there is at least one valid ships placement ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + "" in line "" + std::to_string(__LINE__) + "" in "" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it\'s reference type is not a reference.\n*\n* It doesn\'t return reference because\n* 1. Anyway it\'ll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It\'ll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it\'s seems to work at least on my implementation.\n*\n* It\'s not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n#include <vector>\n\nusing namespace std;\n\nclass TaskB {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, cnt, len, k;\n\t\tin >> n >> cnt >> len >> k;\n\t\tstring s;\n\t\tin >> s;\n\t\tint cur = 0;\n\t\tint need = 0;\n\t\tvector<int> poses;\n\t\tfor (int i: range(n)) {\n\t\t\tif (s[i] == \'1\') {\n\t\t\t\tcur = 0;\n\t\t\t} else {\n\t\t\t\t++cur;\n\t\t\t}\n\n\t\t\tif (cur == len) {\n\t\t\t\t++need;\n\t\t\t\tcur = 0;\n\t\t\t\tposes.push_back(i + 1);\n\t\t\t}\n\t\t}\n\t\tout << need - cnt + 1 << ""\\n"";\n\t\tfor (int i: range(need - cnt + 1)) {\n\t\t\tout << poses[i] << "" "";\n\t\t}\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskB solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Sea Battle.json,https://codeforces.com//blog/entry/48501,Let s note that in on the field there are b zeroes in a row we must to shoot in at least one of them We suppose that all ships was pressed to the right Let s put the number 2 in cells where ships can be placed Then iterate through the field from the left to the right and shoot in the cell if there is 0 and before it was b 1 zero in a row After iteration ended it is left only to shoot in any cell which value equals to 2 All described shoots are the answer for this problem 
https://codeforces.com//contest/1759/problem/A,1648489,A,1759A,1759,A. Yes-Yes ,You talked to Polycarp and asked him a question You know that when he wants to answer yes he repeats many times in a row Because of the noise you only heard part of the answer some substring of it That is if he answered then you could hear but you couldn t or Determine if it is true that the given string s is a substring of repeated many times in a row ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nvoid solve(){\n    string s;\n    cin >> s;\n    char c = s[0];\n    if(c != \'Y\' and c != \'e\' and c != \'s\') {\n        cout << ""NO"" << endl;\n        return;\n    }\n    for(int i = 1; i < s.size(); ++i) {\n        string str = ""Yes"";\n        int j = 0;\n        for(j = 0; j < 3; ++j) {\n            if(str[j] == s[i - 1]) break;\n        }\n        j = (j + 1) % 3;\n        if(s[i] != str[j]) {\n            cout << ""NO"" << endl;\n            return;\n        }\n    }\n    cout << ""YES"" << endl;\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']",,,"['implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Yes-Yes .json,https://codeforces.com//blog/entry/109254,Note that it is enough to consider the string where is written times since and our substring has size Then we just use the built in function to find out if our string is a substring of the string 
https://codeforces.com//contest/909/problem/E,142271,E,909E,909,E. Coprocessor,You are given a program you want to execute as a set of tasks organized in a dependency graph The dependency graph is a directed acyclic graph each task can depend on results of one or several other tasks and there are no directed circular dependencies between tasks A task can only be executed if all tasks it depends on have already completed Some of the tasks in the graph can only be executed on a coprocessor and the rest can only be executed on the main processor In one coprocessor call you can send it a set of tasks which can only be executed on it For each task of the set all tasks on which it depends must be either already completed or be included in the set The main processor starts the program execution and gets the results of tasks executed on the coprocessor automatically Find the minimal number of coprocessor calls which are necessary to execute the given program ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace program\n{\n\tconst int MAXN = 100000;\n\tint n, m, tot, Deg[MAXN + 10], E[MAXN + 10];\n\tvector<int> R[MAXN + 10];\n\tqueue<int> Q0, Q1;\n\n\tvoid work()\n\t{\n\t\ttot = 0;\n\t\tscanf(""%d%d"", &n, &m);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(""%d"", &E[i]);\n\t\tmemset(Deg, 0, sizeof(int) * n);\n\t\twhile(m--)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(""%d%d"", &u, &v);\n\t\t\tR[v].push_back(u);\n\t\t\tDeg[u]++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(!Deg[i])\n\t\t\t{\n\t\t\t\tif(!E[i])\n\t\t\t\t\tQ0.push(i);\n\t\t\t\telse\n\t\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\twhile(!Q0.empty() || !Q1.empty())\n\t\t{\n\t\t\tint f = 0;\n\t\t\twhile(!Q0.empty())\n\t\t\t{\n\t\t\t\tint u = Q0.front();\n\t\t\t\tQ0.pop();\n\t\t\t\tfor(vector<int>::iterator p = R[u].begin(); p != R[u].end(); p++)\n\t\t\t\t{\n\t\t\t\t\tint v = *p;\n\t\t\t\t\tif(!--Deg[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!E[v])\n\t\t\t\t\t\t\tQ0.push(v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tQ1.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q1.empty())\n\t\t\t{\n\t\t\t\tf = 1;\n\t\t\t\tint u = Q1.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tfor(vector<int>::iterator p = R[u].begin(); p != R[u].end(); p++)\n\t\t\t\t{\n\t\t\t\t\tint v = *p;\n\t\t\t\t\tif(!--Deg[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!E[v])\n\t\t\t\t\t\t\tQ0.push(v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tQ1.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot += f;\n\t\t}\n\t\tprintf(""%d\\n"", tot);\n\t}\n}\n\nint main()\n{\n\tprogram::work();\n\treturn 0;\n}']",,,"['dfs and similar', 'dp', 'graphs', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Coprocessor.json,https://codeforces.com//blog/entry/56666,We want to minimize the number of communications between main processor and the coprocessor Thus we need to always act greedily while there are tasks that can be executed on the main processor right away execute them then switch to the coprocessor and execute all tasks that can be executed there then switch back to the main processor and so on This can be done using breadth first search To run reasonably fast this solution has to be implemented carefully instead of searching for available tasks at each step we want to maintain two queues of available tasks for main processor and coprocessor and add a task to a corresponding queue once all tasks it depends on has been executed Alternatively we can define as the lowest number of coprocessor calls required to execute th task and derive a recurrent formula for If is a task and are its dependencies then clearly for each because must be executed after Moreover if is executed on the main processor and on the coprocessor then executing will require an additional coprocessor call Therefore where if is executed on the coprocessor and on the main processor otherwise Now all can be calculated by recursive traversal of the dependency graph or traversing the tasks in topological order The answer to the problem is 
https://codeforces.com//contest/1175/problem/G,354219,G,1175G,1175,G. Yet Another Partiton Problem,You are given array a 1 a 2 dots a n You need to split it into k subsegments so every element is included in exactly one subsegment The weight of a subsegment a l a l 1 dots a r is equal to r l 1 cdot max limits l le i le r a i The weight of a partition is a total weight of all its segments Find the partition of minimal weight ,"['#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, k;\nconst int maxN = 2 * (int)1e4 + 100;\nvector < pair < ll, ll > > cht[4 * maxN];\nstruct pt{\n    ll x, y;\n    pt(ll _x, ll _y) {\n        x = _x;\n        y = _y;\n    }\n    pt() {}\n};\nvector < pt > all[4 * maxN];\nbool del(const pt& x, const pt& y, const pt& z) {\n    return (y.y - x.y) * (x.x - z.x) <= (z.y - x.y) * (x.x - y.x);\n}\nvoid add(ll x, ll y, vector < pt >& vec) {\n    pt nw(x, y);\n    while (vec.size() >= 2 && del(vec[vec.size() - 1], vec[vec.size() - 2], nw)) {\n        vec.pop_back();\n    }\n    vec.push_back(nw);\n}\nll get(const pt& a, ll y) {\n    return (a.x * y + a.y);\n}\nconst ll INF = 2 * (ll)1e18;\nll get(ll x, vector < pt >& vec) {\n    if (vec.empty()) return -INF;\n    int l = 0;\n    int r = vec.size() - 1;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (get(vec[m], x) > get(vec[m + 1], x)) {\n            r = m;\n        }\n        else l = m;\n    }\n    return max(get(vec[r], x), get(vec[l], x));\n}\nvoid add(int v, int tl, int tr, int l, int r, pair < ll, ll >& who) {\n    if (tl == l &&  tr == r) {\n        cht[v].push_back(who);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) {\n        add(v + v, tl, tm, l, r, who);\n    }\n    else if (l > tm) {\n        add(v + v + 1, tm + 1, tr, l, r, who);\n    }\n    else {\n        add(v + v, tl, tm, l, tm, who);\n        add(v + v + 1, tm + 1, tr, tm + 1, r, who);\n    }\n}\nvoid ch() {\n    for (int i = 1; i <= 4 * n; i++) {\n        cht[i].clear();\n        all[i].clear();\n    }\n}\nvoid build(int v, int tl, int tr) {\n    sort(cht[v].begin(), cht[v].end());\n    reverse(cht[v].begin(), cht[v].end());\n    for (auto t : cht[v]) {\n        add(-t.first, -t.second, all[v]);\n    }\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        build(v + v, tl, tm);\n        build(v + v + 1, tm + 1, tr);\n    }\n}\nll get(int v, int tl, int tr, int pos, ll val) {\n    ll f1 = -get(val, all[v]);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm) f1 = min(f1, get(v + v, tl, tm, pos, val));\n        else f1 = min(f1, get(v + v + 1, tm + 1, tr, pos, val));\n    }\n    return f1;\n}\n\n\nll dp[maxN];\nint a[maxN];\nint nxt[maxN];\nll coefs[maxN];\n\nvector < pt > lines[4 * maxN];\npair < ll, ll > ss[4 * maxN];\nvoid build2(int v, int tl, int tr) {\n    vector < pair < ll, ll > > all;\n    for (int i = tl; i <= tr; i++) {\n        all.push_back(ss[i]);\n    }\n    sort(all.begin(), all.end());\n    reverse(all.begin(), all.end());\n    for (auto it : all) {\n        add(-it.first, -it.second, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (tl != tr) {\n        build2(v + v, tl, tm);\n        build2(v + v + 1, tm + 1, tr);\n    }\n}\nll get_val(int v, int tl, int tr, int l, int r, ll val) {\n    if (tl == l && tr == r) {\n        return -get(val, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) return get_val(v + v, tl, tm, l, r, val);\n    else if (l > tm) return get_val(v + v + 1, tm + 1, tr, l, r, val);\n    else {\n        return min(get_val(v + v, tl, tm, l, tm, val), get_val(v + v + 1, tm + 1, tr, tm + 1, r, val));\n    }\n}\nint en[maxN];\nvoid solve() {\n    vector < pair < int, int > > st;\n    st.push_back(make_pair(1e9, 0));\n    for (int i = 1; i <= 4 * n; i++) lines[i].clear();\n    for (int i = 1; i <= n; i++) {\n        ss[i] = make_pair(-(i - 1), dp[i - 1]);\n    }\n    build2(1, 1, n);\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            st.pop_back();\n        }\n        nxt[i] = st.back().second;\n        st.push_back(make_pair(a[i], i));\n    }\n    for (int i = 1; i <= n; i++) {\n        coefs[i] = get_val(1, 1, n, nxt[i] + 1, i, a[i]);\n    }\n    ch();\n    st.clear();\n    st.push_back(make_pair(1e9, 0));\n    //cout << "" Here"" << endl;\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            en[st.back().second] = i - 1;\n            st  .pop_back();\n        }\n        st.push_back(make_pair(a[i], i));\n    }\n    while (!st.empty()) {\n        en[st.back().second] = n;\n        st.pop_back();\n    }\n    //cout << "" Here"" << endl;\n    for (int i = 1; i <= n; i++) {\n        pair < ll, ll > tt = make_pair(a[i], coefs[i]);\n        add(1, 1, n, i, en[i], tt);\n    }\n    build(1, 1, n);\n    dp[0] = 1e9;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = get(1, 1, n, i, i);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = (ll)1e9;\n    }\n    for (int i = 0; i < k; i++) {\n        solve();\n    }\n    cout << dp[n];\n    return 0;\n}']",,,"['data structures', 'divide and conquer', 'dp', 'geometry', 'two pointers']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Yet Another Partiton Problem.json,https://codeforces.com/blog/entry/67484,Important note the author solution is using both linear Convex hull trick and persistent Li Chao tree As mentioned in commentaries applying the Divide and Conquer technique can help get rid of Li Chao tree More about both structures you can read in this article Let s try to write standard dp we can come up with arrays will be 0 indexed Let be the minimal weight if we splitted prefix of length in subsegments Then we can calculate it as 1 Maximums on segments are inconvenient let s try to group segments by the value of So we can find such sequence of borders where for each In other words and is the closest from the left position where Note that we can maintain this sequence with stack of maximums Ok then for each interval equation 1 transforms to Why did we use variables and Because there are two problems is needed because we iterate over and can t recalculate everything is needed because sequence is changing over time so do the But what we can already see we can maintain for each segment Convex hull with linear functions so we can take in logarithmic time Moreover we can store values in other Convex hull to take minimum over all segments in logarithmic time The problems arise when we try modificate structures while iterating Fortunately segments change not at random but according to stack of maximums So all we should handle are to merge segment on top of the stack with current segment in case when to erase segment on top of the stack along with its value to insert new segment on top of the stack along with its value To handle the third type is easy since all Convex hulls can insert elements There will be at most such operations on a single layer and we can ask value in and insert a line with To handle the second type is harder but possible since we can make Convex hull persistent and store its versions in the stack Persistent Convex hull persistent Li Chao tree There will be also operations in total and they cost us To handle the first type is trickiest part Note that all line coefficients of one convex hull are strictly lower than all line coefficients of the other So we can use linear Convex hulls to make insertions to back in amortized But to merge efficiently we should use Small to Large technique that s why we should be able also push front in and moreover still be able to ask minimum in And here comes the hack in C which can push pop front back in amortized and also have random access iterator to make binary search possible So each element of every segment will be transfered times with cost of amortized on a single layer In the end result complexity is Space complexity is 
https://codeforces.com//contest/1325/problem/D,561456,D,1325D,1325,D. Ehab the Xorcist,Given 2 integers u and v find the shortest array such that bitwise xor of its elements is u and the sum of its elements is v ,"['///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 3e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nll n, m, x, s;\nll cnt[70];\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> x >> s;\n    if(x % 2 != s % 2) return cout<< -1, 0;\n    if(x > s) return cout<< -1, 0;\n\n    if(x == 0 && s == 0)\n        return cout<< 0, 0;\n\n    int X = x, S = s;\n    if(x == s)\n    {\n        cout<< 1 <<""\\n""<< x;\n        return 0;\n    }\n\n    /// 2\n    for(int i = 0; i < 60; i++)\n        if(x&(1ll<<i))\n            s -= (1ll<<i);\n        else\n          cnt[i+1] = 1;\n\n    bool T = 1;\n    for(int i = 0; i < 60; i++)\n        if((s & (1ll<<i)) && !cnt[i])\n            T = 0;\n\n    if(T)\n    {\n        cout<< 2 <<""\\n"";\n        int a = x, b = 0;\n        for(int i = 0; i < 60; i++)\n            if(s & (1ll<<i))\n            {\n                a += (1ll<<(i-1));\n                b += (1ll<<(i-1));\n            }\n        cout<< a <<"" ""<< b;\n        return 0;\n    }\n\n    x = X, s = S;\n    int a = x, b = 0, c = 0;\n    s -= x;\n    for(int i = 0; i < 60; i++)\n        if(s & (1ll<<i))\n        {\n            b += (1ll<<(i-1));\n            c += (1ll<<(i-1));\n        }\n    cout<< 3 <<""\\n""<< a <<"" ""<< b <<"" ""<< c;\n}\n\n']",,,"['bitmasks', 'constructive algorithms', 'greedy', 'number theory']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Ehab the Xorcist.json,https://codeforces.com//blog/entry/74235,First let s look at some special cases If or and have different parities there s no array If the answer is an empty array If the answer is Now the length is at least 2 Let The array satisfies the conditions so the length is at most 3 We just need to figure out whether there s a pair of number and Such that and Notice that so we know that surprise surprise The benefit of getting rid of and looking at instead is that we can look at and bit by bit If has a one in some bit and must both have ones so must have a 0 If has a zero there are absolutely no limitation on So if there s a bit where both and have a one that is to say if you can t find such and and the length will be 3 Otherwise which means so the array works Can you see how this array was constructed We took which more obviously works and merged the first 2 elements benefiting from the fact that Code link https pastebin com 7XuMk1v8 First AC qdai0815 
https://codeforces.com//contest/1117/problem/F,300046,F,1117F,1117,F. Crisp String,You are given a string of length n Each character is one of the first p lowercase Latin letters You are also given a matrix A with binary values of size p times p This matrix is symmetric A ij A ji A ij 1 means that the string can have the i th and j th letters of Latin alphabet adjacent Let s call the string if in it can be adjacent have 1 in the corresponding cell of matrix A You are allowed to do the following move Choose any letter remove and join the remaining parts of the string without changing their order For example removing letter a from abacaba will yield bcb The string you are given is The string should remain You are allowed to do arbitrary number of moves possible zero What is the shortest resulting string you can obtain ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,P;\nstring S;\nint A[17][17];\nint nex[18];\nint num[18];\n\nvector<int> ngpat[1<<17];\nint ok[1<<17];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>P>>S;\n\tFOR(i,P) nex[i]=N;\n\tFORR(c,S) {\n\t\tc-='a';\n\t\tnum[c]++;\n\t}\n\tFOR(y,P) FOR(x,P) cin>>A[y][x];\n\tfor(i=N-1;i>=0;i--) {\n\t\tvector<pair<int,int>> V;\n\t\tFOR(j,P) if(nex[j]<N) V.push_back({nex[j],j});\n\t\tsort(ALL(V));\n\t\tint fixed=(1<<P)-1-(1<<S[i]);\n\t\tint mat=1<<S[i];\n\t\tFORR(v,V) {\n\t\t\tif(v.second!=S[i]) {\n\t\t\t\tfixed ^= 1<<(v.second);\n\t\t\t\tmat^= 1<<(v.second);\n\t\t\t}\n\t\t\tif(A[S[i]][v.second]==0) ngpat[fixed].push_back(mat);\n\t\t\tif(v.second==S[i]) break;\n\t\t\tmat^= 1<<(v.second);\n\t\t}\n\t\tnex[S[i]]=i;\n\t}\n\t\n\tint mask;\n\tFOR(mask,1<<P) ok[mask]=1;\n\tFOR(mask,1<<P) {\n\t\tsort(ALL(ngpat[mask]));\n\t\tngpat[mask].erase(unique(ALL(ngpat[mask])),ngpat[mask].end());\n\t\tfor(int submask=mask; submask>=0; submask--) {\n\t\t\tsubmask&=mask;\n\t\t\tFORR(p,ngpat[mask]) ok[submask|p]=0;\n\t\t}\n\t}\n\t\n\tint ma=0;\n\tFOR(i,P) ma+=num[i];\n\tfor(mask=(1<<P)-2;mask>=0;mask--) if(ok[mask]) {\n\t\tok[mask]=0;\n\t\tFOR(i,P) if((mask&(1<<i))==0 && ok[mask|(1<<i)]) ok[mask]=1;\n\t\tif(ok[mask]) {\n\t\t\tint sum=0;\n\t\t\tFOR(i,P) if(mask&(1<<i)) sum+=num[i];\n\t\t\tma=min(ma,sum);\n\t\t}\n\t}\n\tcout<<ma<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n""]",,,"['bitmasks', 'dp']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Crisp String.json,https://codeforces.com//blog/entry/65365,Each state of the string can be denoted as the set of characters we deleted from it and each such set can be represented as a bit binary mask where th bit is equal to if th character of the alphabet is already deleted and otherwise Let s call a mask if the string formed by this mask is not crisp Let s also say that a pair of characters forbids mask if is a pair of characters that should not be adjacent but they are adjacent in the string formed by mask If we somehow find all bad masks then the solution would be writing simple bitmask dp to find the best mask that is not bad and reachable from the initial mask the one having all bits set to So let s focus on finding all bad masks Obviously if some pair of characters forbids a mask then it s bad and vice versa Let s pick some pair of characters and find all masks forbidden by it we will do the same for every pair of characters that cannot be adjacent Let s check every occurence of in the initial string For each occurence we will find the closest occurence of to the right of it If there s no any or if there s another between them let s ignore the occurence of we have chosen and move to the next one Otherwise let s find all characters that occur at least once between the fixed occurences of and If all those characters are deleted then these occurences of and will be adjacent so pair forbids any mask that has bits representing and set to bits representing every character occuring in between to and all other bits to any values Let s mark all these masks as forbidden as follows we will write a recursive function that marks mask and every its submask that has bits and set to as forbidden This function should check if is not forbidden if not then mark it as forbidden iterate on the bit we may remove from and call recursively but only if is set to in mask and if and If we implement it in such a way then for each pair it will take operations to mark all masks forbidden by this pair of characters so overall complexity will be or depending on your implementation 
https://codeforces.com//contest/559/problem/B,31961,B,559B,559,B. Equivalent Strings,Today on a lecture about strings Gerald learned a new definition of string equivalency Two strings and of equal length are called in one of the two cases They are equal If we split string into two halves of the same size and and string into two halves of the same size and then one of the following is correct is equivalent to and is equivalent to is equivalent to and is equivalent to As a home task the teacher gave two strings to his students and asked to determine if they are equivalent Gerald has already completed this home task Now it s your turn ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nstring s,t;\nstring gao(string a) {\n\tif (SZ(a)%2==1) return a;\n\telse {\n\t\tstring a1="""";\n\t\trep(i,0,SZ(a)/2) a1.pb(a[i]);\n\t\tstring s1=gao(a1);\n\t\ta1.clear();\n\t\trep(i,SZ(a)/2,SZ(a)) a1.pb(a[i]);\n\t\tstring s2=gao(a1);\n\t\tif (s1<s2) return s1+s2; else return s2+s1;\n\t}\n}\nint main() {\n\tcin>>s>>t;\n\tputs(gao(s)==gao(t)?""YES"":""NO"");\n}\n']",,,"['divide and conquer', 'hashing', 'sortings', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Equivalent Strings.json,https://codeforces.com//blog/entry/19237,Let us note that equivalence described in the statements is actually equivalence relation it is reflexively simmetrically and transitive It is meant that set of all string is splits to equivalence classes Let s find lexicographic minimal strings what is equivalent to first and to second given string And then check if its are equals It is remain find the lexicographic minimal strings what is equivalent to given For instance we can do it such a way Every recursive call time works is where is length of strings and string splitten by two twice smaller strings Therefore time of work this function is where is length of strings 
https://codeforces.com//contest/1954/problem/C,2586693,C,1954C,1954,C. Long Multiplication,You are given two integers x and y of the same length consisting of digits from 1 to 9 You can perform the following operation any number of times possibly zero swap the i th digit in x and the i th digit in y For example if x 73 and y 31 you can swap the 2 nd digits and get x 71 and y 33 Your task is to maximize the product of x and y using the aforementioned operation any number of times If there are multiple answers print any of them ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    string s,t; cin >> s >> t;    int n=sz(s);    bool flag=0;    rep(n) if(s[i]!=t[i]){        if(!flag){            if(s[i]<t[i]) swap(s[i],t[i]);        }        else{            if(s[i]>t[i]) swap(s[i],t[i]);        }        flag=1;    }    print(s);    print(t);}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}']",,,"['greedy', 'math', 'number theory']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Long Multiplication.json,https://codeforces.com//blog/entry/128421,There are two observations to solve the problem applying the operation does not change the sum of the numbers the smaller the difference of the numbers the greater their product the proof is given below Proof let s denote the sum of the numbers as the smallest number as and the largest number as Then the product is equal to We can see that the smaller the half of difference the larger the product In order to get the minimum difference we can use the following algorithm let be the smallest index the most significant digit such that and set the maximum digit among and to the number and smallest to the number thus is definitely greater than then the less significant digits should be the maximum possible for the number i e the inequality must hold for all 
https://codeforces.com//contest/1721/problem/F,1521729,F,1721F,1721,F. Matching Reduction,You are given a bipartite graph with n 1 vertices in the first part n 2 vertices in the second part and m edges The maximum matching in this graph is the maximum possible by size subset of edges of this graph such that no vertex is incident to more than one chosen edge You have to process two types of queries to this graph 1 remove the number of vertices from this graph so that the size of the maximum matching gets reduced and print the vertices that you have removed Then find any maximum matching in this graph and print the sum of indices of edges belonging to this matching 2 query of this type will be asked only after a query of type 1 As the answer to this query you have to print the edges forming the maximum matching you have chosen in the previous query Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Flow {\n    const int n;\n    struct Edge {\n        int to;\n        T cap;\n        Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    \n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    \n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T maxFlow(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int nx, ny, m, q;\n    std::cin >> nx >> ny >> m >> q;\n    const int N = nx + ny;\n    \n    Flow<int> flow(nx + ny + 2);\n    const int S = nx + ny, T = S + 1;\n    std::vector<int> x(m), y(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> x[i] >> y[i];\n        x[i]--, y[i]--;\n        flow.addEdge(x[i], nx + y[i], 2);\n    }\n    for (int i = 0; i < nx; i++) {\n        flow.addEdge(S, i, 1);\n    }\n    for (int i = 0; i < ny; i++) {\n        flow.addEdge(nx + i, T, 1);\n    }\n    \n    int M = flow.maxFlow(S, T);\n    i64 sum = 0;\n    std::vector<int> e(N, -1);\n    for (int i = 0; i < m; i++) {\n        if (flow.e[2 * i].cap == 1) {\n            e[x[i]] = e[y[i] + nx] = i;\n            sum += i + 1;\n        }\n    }\n    \n    std::vector<int> cut(N);\n    std::vector<int> seq;\n    for (int i = 0; i < N; i++) {\n        cut[i] = (flow.h[i] == -1);\n        if ((i < nx && cut[i]) || (i >= nx && !cut[i])) {\n            seq.push_back(i);\n        }\n    }\n    \n    while (q--) {\n        int o;\n        std::cin >> o;\n        \n        if (o == 1) {\n            int u = seq.back();\n            seq.pop_back();\n            \n            std::cout << 1 << ""\\n"";\n            if (u < nx) {\n                std::cout << u + 1 << ""\\n"";\n            } else {\n                std::cout << -(u - nx + 1) << ""\\n"";\n            }\n            int j = e[u];\n            sum -= j + 1;\n            e[x[j]] = e[y[j] + nx] = -1;\n            std::cout << sum << std::endl;\n            M--;\n        } else {\n            std::cout << M << ""\\n"";\n            for (int i = 0; i < nx; i++) {\n                if (e[i] != -1) {\n                    std::cout << e[i] + 1 << "" "";\n                }\n            }\n            std::cout << std::endl;\n        }\n    }\n    \n    return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'dfs and similar', 'flows', 'graph matchings', 'graphs', 'interactive']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Matching Reduction.json,https://codeforces.com//blog/entry/106416,Let s start by finding the maximum matching in the given graph Since the constraints are pretty big you need something fast The model solution converts the matching problem into a flow network and uses Dinic to find the matching in but something like heavily optimized Kuhn s algorithm can also work Okay then what about finding the minimum possible number of vertices to delete in order to reduce the maximum matching We claim that it is always enough to remove one vertex and the proof will also provide a way to quickly search for such vertices Let s recall that the size of the maximum matching is equal to the size of the minimum vertex cover So we will try to find a way to reduce the minimum vertex cover by and it s actually pretty easy just remove any vertex belonging to the vertex cover it s obvious that it reduces the vertex cover by and the maximum matching by as well So we can find the minimum vertex cover in the graph using the standard algorithm to convert the MM into MVC or if you re using Dinic to find the maximum matching you can represent the minimum vertex cover as the minimum cut problem and for each query of type just take a vertex from the vertex cover we found Now the only thing that s left is discussing how to maintain the structure of the maximum matching in the graph In fact it s quite easy on the one hand since we remove the vertices belonging to the minimum vertex cover every edge including the edges from the matching will be incident to one of the vertices we will remove on the other hand due to the definition of the maximum matching there is no vertex that is incident to two or more edges from the maximum matching so every vertex from the vertex cover has exactly one edge from the maximum matching that is incident to it and when we remove a vertex we can simply remove the corresponding edge from the maximum matching So the only thing we need to do is to maintain which edge from the matching corresponds to which vertex from the minimum vertex cover and it will allow us to maintain the structure of the maximum matching and since these pairs don t change when we remove a vertex it is enough to get this information right after we have constructed the maximum matching in the given graph we won t need to rebuild it 
https://codeforces.com//contest/429/problem/D,9405,D,429D,429,D. Tricky Function,Iahub and Sorin are the best competitive programmers in their town However they can t both qualify to an important contest The selection will be made with the help of a single problem Blatnatalag a friend of Iahub managed to get hold of the problem before the contest Because he wants to make sure Iahub will be the one qualified he tells Iahub the following task You re given an 1 based array with elements Let s define function as Function g is calculated by the following pseudo code int g int i int j int sum 0 for int k min i j 1 k max i j k k 1 sum sum a k return sum Find a value Probably by now Iahub already figured out the solution to this problem Can you ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint a[100500];\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf(""%d"", &n);\n\tforn(i, n)\n\t\tscanf(""%d"", &a[i]);\n\tint ans = 1 + a[1] * a[1];\n\tfor (int d = 1; d < n; d++) {\n\t\tif (d * d >= ans) break;\n\t\tint s = 0;\n\t\tint q = inf;\n\t\tint l = 1;\n\t\tint r = d + 1;\n\t\tforn (j, d)\n\t\t\ts += a[j + 1];\n\t\tq = min(q, abs(s));\n\t\twhile (r < n) {\n\t\t\ts -= a[l];\n\t\t\ts += a[r];\n\t\t\tl++;\n\t\t\tr++;\n\t\t\tq = min(q, abs(s));\n\t\t}\n\t\tif ((int64)q * q + (int64)d * d < ans)\n\t\t\tans = q * q + d * d;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['data structures', 'divide and conquer', 'geometry']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Tricky Function.json,https://codeforces.com//blog/entry/12265,Let s define S i a 1 a 2 a i Then f i j i j 2 S i S j 2 Trying to minimize this function seems complicated so we need to manipulate the formula more We know from the maths that if f i j is minimized then also f i j sqrt i j 2 S i S j 2 is also minimized Does this function look familiar to you Suppose you get two points in 2D plane one having coordinates i S i and the other one having coordinates j S j One can see that f i j is exactly euclidean distance of those points So if f i j is a distance between two points in plane when is achieved minimal f i j For the closest two points in plane the points which are located at minimal distance So having set of points i S i we need to compute closest two points from this plane There is a classical algorithm that does this in O n logn 
https://codeforces.com//contest/1422/problem/E,748727,E,1422E,1422,E. Minlexes,Some time ago Lesha found an entertaining string s consisting of lowercase English letters Lesha immediately developed an unique algorithm for this string and shared it with you The algorithm is as follows Lesha chooses an arbitrary possibly zero number of pairs on positions i i 1 in such a way that the following conditions are satisfied for each pair i i 1 the inequality 0 le i s 1 holds for each pair i i 1 the equality s i s i 1 holds there is no index that is contained in more than one pair After that Lesha removes all characters on indexes contained in these pairs and the algorithm is over Lesha is interested in the lexicographically smallest strings he can obtain by applying the algorithm to the suffixes of the given string ,"['#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\n#define lambda(RES_TYPE, ...) (function<RES_TYPE(__VA_ARGS__)>)[&](__VA_ARGS__) -> RES_TYPE\n#define method(FUNC_NAME, RES_TYPE, ...) function<RES_TYPE(__VA_ARGS__)> FUNC_NAME = lambda(RES_TYPE, __VA_ARGS__)\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<""LINE ""<<__LINE__<<"": ""<<#x<<"" = ""<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << "" "";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(""%lld"", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nusing P = pair<int,string>;\n\nstring reversed(string str){\n    reverse(all(str));\n    return str;\n}\n\nvector<P> func(){\n    string str = in<string>();\n    reverse(all(str));\n    int n = str.size();\n    vector<pair<char,int>> logger;\n    string sum = """";\n    bool flag = false;\n    vector<P> res(n);\n    method(search,char,char x){\n        per(i,logger.size()){\n            if(logger[i].first==x)continue;\n            return logger[i].first;\n        }\n        return \'a\'-1;\n    };\n    rep(i,n){\n        method(func,void){\n            if(sum.empty()){\n                sum += str[i];\n                logger.clear();\n                logger.emplace_back(str[i],1);\n                flag = false;\n                return;\n            }\n            if(!flag and sum.back()==str[i] and search(str[i]) < str[i]){\n                logger.back().second -= 1;\n                if(logger.back().second==0)logger.pop_back();\n                sum.erase(sum.end()-1);\n                flag = true;\n            }else{\n                sum += str[i];\n                if(logger.back().first!=str[i]){\n                    logger.emplace_back(str[i],1);\n                }else{\n                    ++logger.back().second;\n                }\n                flag = false;\n            }\n        };\n        func();\n        if(sum.size()>10){\n            res[i].first = sum.size();\n            res[i].second = reversed(sum.substr(sum.size()-5)) + ""..."" + reversed(sum.substr(0,2));\n        }else{\n            res[i].first = sum.size();\n            res[i].second = reversed(sum);\n        }\n    }\n    reverse(all(res));\n    return res;\n}\n\nint main(){\n    vector<P> ans = func();\n    foreach(i,ans){\n        cout << i.first;\n        if(i.first){\n            cout << "" "" << i.second;\n        }\n        cout << endl;\n    }\n  return 0;\n}\n']",,,"['dp', 'greedy', 'implementation', 'strings']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Minlexes.json,https://codeforces.com//blog/entry/83452,Let s find the answer for all suffixes starting with the smallest in length is equal to an empty string Then if then and otherwise To quickly find minimum of two strings they can be stored as binary lifts will be equal to the position in the string on which the character will be located and hash from the prefix of length Values for can be obtained from and To restore the answer will be enough for us and for simplicity we can additionally store the length of each answer 
https://codeforces.com//contest/1702/problem/E,1456430,E,1702E,1702,E. Split Into Two Sets,Polycarp was recently given a set of n number n even dominoes Each domino contains two integers from 1 to n Can he divide all the dominoes into two sets so that all the numbers on the dominoes of each set are different Each domino must go into exactly one of the two sets For example if he has 4 dominoes 1 4 1 3 3 2 and 4 2 then Polycarp will be able to divide them into two sets in the required way The first set can include the first and third dominoes 1 4 and 3 2 and the second set the second and fourth ones 1 3 and 4 2 ,"['/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,k,c,a[N],col[N];\nii p[N];\nstring s;\nvector<ll> ke[N];\nbool ok=1;\nvoid dfs (ll u){\n    rv(v,ke[u]) if (!col[v]) col[v]=3-col[u],dfs(v);\n    else if (col[v]==col[u]) ok=0;\n}\nvoid solo()\n{\n    cin>>n;\n    rep(i,1,n) col[i]=a[i]=0,ke[i].clear();\n    ok=1;\n    rep(i,1,n) cin>>p[i].F>>p[i].S,a[p[i].F]++,a[p[i].S]++;\n    rep(i,1,n) if (a[i]!=2 || p[i].F==p[i].S){\n        cout<<""NO"";\n        return;\n    }\n    rep(i,1,n){\n        ke[p[i].F].pb(p[i].S);\n        ke[p[i].S].pb(p[i].F);\n    }\n    rep(i,1,n) if (!col[i]) col[i]=1,dfs(i);\n    if (ok)\n    cout<<""YES"";\n    else cout<<""NO"";\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']",,,"['dfs and similar', 'dsu', 'graphs']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Split Into Two Sets.json,https://codeforces.com//blog/entry/104763,Polycarp has dominoes on each domino there are numbers it turns out there will be numbers in total We need to divide numbers each number from to into two sets so that all numbers in each set are different each set will consist of numbers It turns out that all numbers from to must occur exactly times no more and no less Let s imagine it all as a bipartite graph where there are vertices from to and dominoes are edges Since each number occurs exactly times then we have a lot of cycles In which the edges of each number must be included in different sets in other words the cycles must be of even length This can be checked in by a simple enumeration 
https://codeforces.com//contest/1580/problem/E,1124758,E,1580E,1580,E. Railway Construction,Because the railway system in Gensokyo is often congested as an enthusiastic engineer Kawasiro Nitori plans to construct more railway to ease the congestion There are n stations numbered from 1 to n and m two way railways in Gensokyo Every two way railway connects two different stations and has a positive integer length d No two two way railways connect the same two stations Besides it is possible to travel from any station to any other using those railways Among these n stations station 1 is the main station You can get to any station from any other station using only two way railways Because of the technological limitation Nitori can only construct one way railways whose length can be arbitrary positive integer Constructing a one way railway from station u will costs w u units of resources no matter where the railway ends To ease the congestion Nitori plans that after construction there are at least two shortest paths from station 1 to any other station and these two shortest paths do not pass the same station except station 1 and the terminal Besides Nitori also does not want to change the distance of the shortest path from station 1 to any other station Due to various reasons sometimes the cost of building a new railway will increase uncontrollably There will be a total of q occurrences of this kind of incident and the i th event will add additional amount of x i to the cost of building a new railway from the station k i To save resources before all incidents and after each incident Nitori wants you to help her calculate the minimal cost of railway construction ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//merge で片方が inactive のときはもう片方をそのまま返す，\n//といったときに，lazy の情報までコピーして渡さないようにする\n\n//get の最後の引数は単位元と口では言いつつ・・・？\n//たとえば min で最後の引数を 0 にしても 1 とかが返ってくることはある（一敗）\n\n//VERIFY: yosupo\n//KUPC2017I\n//HDU 5306 Gorgeous Sequence\n//findmin/max CF458E\ntemplate<class N>\nstruct segbeats{\n\tvc<N> x;\n\tint s;\n\tsegbeats(){}\n\ttemplate<class T>\n\tsegbeats(const vc<T>& a){\n\t\tint n=a.size();\n\t\ts=1;\n\t\twhile(s<n)s*=2;\n\t\tx.resize(s*2);\n\t\trep(i,n)\n\t\t\tx[s+i]=N(a[i]);\n\t\tgnr(i,1,s)\n\t\t\tupd(i);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid chr(int l,int r,int i,int b,int e,F f,Args&&... args){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(b<=l&&r<=e&&(x[i].*f)(forward<Args>(args)...))\n\t\t\treturn;\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tchr(l,m,i*2,b,e,f,forward<Args>(args)...);\n\t\tchr(m,r,i*2+1,b,e,f,forward<Args>(args)...);\n\t\tupd(i);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int b,int e,F f,Args&&... args){\n\t\tassert(b<=e);\n\t\tchr(0,s,1,b,e,f,forward<Args>(args)...);\n\t}\n\t//use decltype((declval<N>().*F())()) for old-fashioned judges\n\ttemplate<class F,class G,class H>\n\tauto getr(int l,int r,int i,int b,int e,F f,G g,H h){\n\t\tif(e<=l||r<=b)\n\t\t\treturn h;\n\t\tif(b<=l&&r<=e)\n\t\t\treturn (x[i].*f)();\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\treturn g(getr(l,m,i*2,b,e,f,g,h),getr(m,r,i*2+1,b,e,f,g,h));\n\t}\n\ttemplate<class F,class G,class H>\n\tauto get(int b,int e,F f,G g,H h){\n\t\tassert(b<=e);\n\t\treturn getr(0,s,1,b,e,f,g,h);\n\t}\n\tauto compositer(int l,int r,int i,int b,int e){\n\t\tif(e<=l||r<=b)assert(0);\n\t\tif(b<=l&&r<=e)\n\t\t\treturn x[i];\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tif(e<=m)return compositer(l,m,i*2,b,e);\n\t\tif(m<=b)return compositer(m,r,i*2+1,b,e);\n\t\treturn N::merge(compositer(l,m,i*2,b,e),compositer(m,r,i*2+1,b,e));\n\t}\n\t//work without identity node\n\tauto composite(int b,int e){\n\t\tassert(b<e);\n\t\treturn compositer(0,s,1,b,e);\n\t}\n\tN getall(){return x[1];}\n\t//return minimum index\n\ttemplate<class F,class...Args>\n\tpair<int,N> findminr(int i,int l,int r,int b,int e,F f,Args&&...args){\n\t\tif(e<=l||r<=b)return {e,N()};\n\t\tif(b<=l&&r<=e){\n\t\t\tif(!(x[i].*f)(forward<Args>(args)...))return {e,N()};\n\t\t\tif(r-l==1)return {l,x[i]};\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tauto a=findminr(i*2,l,m,b,e,f,forward<Args>(args)...);\n\t\tif(a.a<e)return a;\n\t\treturn findminr(i*2+1,m,r,b,e,f,forward<Args>(args)...);\n\t}\n\ttemplate<class F,class...Args>\n\tpair<int,N> findmin(int b,int e,F f,Args&&...args){\n\t\tassert(b<=e);\n\t\treturn findminr(1,0,s,b,e,f,forward<Args>(args)...);\n\t}\n\t//return maximum index\n\ttemplate<class F,class...Args>\n\tpair<int,N> findmaxr(int i,int l,int r,int b,int e,F f,Args&&...args){\n\t\tif(e<=l||r<=b)return {b-1,N()};\n\t\tif(b<=l&&r<=e){\n\t\t\tif(!(x[i].*f)(forward<Args>(args)...))return {b-1,N()};\n\t\t\tif(r-l==1)return {l,x[i]};\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tauto a=findmaxr(i*2+1,m,r,b,e,f,forward<Args>(args)...);\n\t\tif(a.a>=b)return a;\n\t\treturn findmaxr(i*2,l,m,b,e,f,forward<Args>(args)...);\n\t}\n\ttemplate<class F,class...Args>\n\tpair<int,N> findmax(int b,int e,F f,Args&&...args){\n\t\tassert(b<=e);\n\t\treturn findmaxr(1,0,s,b,e,f,forward<Args>(args)...);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n\t\n\t//KUPC 2020 G\n\ttemplate<class F,class...Args>\n\tvoid enumerate_by_findr(int l,int r,int i,int b,int e,vc<pair<int,N>>&dst,F f,Args&&...args){\n\t\tif(e<=l||r<=b||!(x[i].*f)(forward<Args>(args)...))\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.eb(l,x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerate_by_findr(l,m,i*2,b,e,dst,f,forward<Args>(args)...);\n\t\tenumerate_by_findr(m,r,i*2+1,b,e,dst,f,forward<Args>(args)...);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid enumerate_by_find(int b,int e,vc<pair<int,N>>&dst,F f,Args&&...args){\n\t\tassert(b<=e);\n\t\tenumerate_by_findr(0,s,1,b,e,dst,f,forward<Args>(args)...);\n\t}\n\tvoid prepare(int i){\n\t\tif(i/=2){\n\t\t\tprepare(i);\n\t\t\tpush(i);\n\t\t}\n\t}\n\t//point_update と lazy を組み合わせたらどうなるかは，わからない・・・\n\tvoid point_set(int i,N w){\n\t\ti+=s;\n\t\tprepare(i);\n\t\tx[i]=w;\n\t\twhile(i/=2)\n\t\t\tupd(i);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid point_change(int i,F f,Args&&...args){\n\t\ti+=s;\n\t\tprepare(i);\n\t\t(x[i].*f)(forward<Args>(args)...);\n\t\twhile(i/=2)\n\t\t\tupd(i);\n\t}\n\t//not verified\n\tN point_get(int i){\n\t\ti+=s;\n\t\tprepare(i);\n\t\treturn x[i];\n\t}\n};\n\n//N::push\n//pushしたあとはclearする\n//N::merge\n\nstruct N{\n\tull mx,cnt,sec,sum,lz;\n\tN(ull v=0):mx(v),cnt(1),sec(0),sum(v),lz(-1){}\n\tbool setlim(ull v){\n\t\tif(mx<=v){\n\t\t\tchmin(lz,v);\n\t\t\treturn true;\n\t\t}\n\t\tif(sec<v){\n\t\t\tchmin(lz,v);\n\t\t\tsum-=(mx-v)*cnt;\n\t\t\tmx=v;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tvoid push(N&x,N&y){\n\t\tbool tmp=x.setlim(lz);\n\t\tassert(tmp);\n\t\ttmp=y.setlim(lz);\n\t\tassert(tmp);\n\t\tlz=-1;\n\t}\n\tstatic N merge(N x,N y){\n\t\tN res;\n\t\tres.mx=max(x.mx,y.mx);\n\t\tres.sec=max(x.sec,y.sec);\n\t\tres.cnt=0;\n\t\tif(res.mx==x.mx)res.cnt+=x.cnt;\n\t\telse chmax(res.sec,x.mx);\n\t\tif(res.mx==y.mx)res.cnt+=y.cnt;\n\t\telse chmax(res.sec,y.mx);\n\t\tres.sum=x.sum+y.sum;\n\t\treturn res;\n\t}\n};\n\ntemplate<class E,class D=ll>\npair<vc<D>,vi> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,infLL);\n\tvi from(n,-1);\n\tconst auto ar=[&](int v,D d,int f){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.emplace(d,v);\n\t\t\tfrom[v]=f;\n\t\t}\n\t};\n\tar(s,0,-1);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tif(dist[v]!=d)continue;\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost,v);\n\t}\n\treturn mp(dist,from);\n}\n\nstruct E{\n\tint to,cost;\n\toperator int()const{return to;}\n};\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\tvi w=readvi(n);\n\tvvc<E> g(n);\n\trep(_,m){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\ta--;b--;\n\t\tg[a].pb({b,c});\n\t\tg[b].pb({a,c});\n\t}\n\tvi dist=dijkstra(g,0).a;\n\tvc<pi> qs(q);\n\trep(i,q){\n\t\tqs[i]=readpi();\n\t\tqs[i].a--;\n\t\tw[qs[i].a]+=qs[i].b;\n\t}\n\tvi ls,cnt(n),idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return dist[i]<dist[j];});\n\tvi pos(n);\n\trep(i,n)pos[idx[i]]=i;\n\trep(i,n){\n\t\tfor(auto e:g[i]){\n\t\t\tif(dist[e.to]==dist[i]+e.cost){\n\t\t\t\tcnt[e.to]++;\n\t\t\t}\n\t\t}\n\t}\n\tvi lds;\n\tfor(auto i:idx){\n\t\tif(cnt[i]==1){\n\t\t\tls.pb(pos[i]);\n\t\t\tlds.pb(dist[i]);\n\t\t}\n\t}\n\tassert(is_sorted(all(ls)));\n\tassert(is_sorted(all(lds)));\n\tvvc<pi> zs(n);\n\trep(i,n){\n\t\tvi cut{lwb(lds,dist[i]+1)-1,si(ls)};\n\t\tif(i)for(auto e:g[i]){\n\t\t\tif(dist[e.to]==dist[i]+e.cost){\n\t\t\t\tauto itr=lower_bound(all(ls),pos[e.to]);\n\t\t\t\tif(itr!=ls.ed&&*itr==pos[e.to]&&cut[0]<itr-ls.bg)\n\t\t\t\t\tcut.pb(itr-ls.bg);\n\t\t\t}\n\t\t}\n\t\tsort(all(cut));\n\t\trep(j,si(cut)-1)if(cut[j]+1<cut[j+1]){\n\t\t\tzs[i].eb(cut[j]+1,cut[j+1]);\n\t\t}\n\t}\n\t//Broken Time Complexity\n\t//I hope weak tests\n\tsegbeats<N> seg(vi(si(ls),*max_element(all(w))));\n\tauto upd=[&](int i,int val){\n\t\tfor(const auto&[l,r]:zs[i])\n\t\t\tseg.ch(l,r,&N::setlim,val);\n\t};\n\tvc<ull> tmp;\n\tauto output=[&](){\n\t\ttmp.pb(seg.x[1].sum);\n\t};\n\trep(i,n)upd(i,w[i]);\n\toutput();\n\tper(i,q){\n\t\tupd(qs[i].a,w[qs[i].a]-=qs[i].b);\n\t\toutput();\n\t}\n\treverse(all(tmp));\n\tfor(auto val:tmp)print(val);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['brute force', 'constructive algorithms', 'data structures', 'graphs', 'shortest paths']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Railway Construction.json,https://codeforces.com//blog/entry/95477,For convenience we first define as the length of the shortest path between node 1 and node and distance of node as and call node is deeper than node if and only if Similarly we call node is lower than node if and only if We will use to denote a a directed edge staring at node and ending at node and use to denote an arbitrary path staring at node and ending at node We call two paths intersect if and only if they pass through at least 1 same node First let s focus on several facts Then let s prove a lemma if every node except node 1 exactly has 2 incoming edges the graph will meet the requirement We will use mathematical induction method to prove the lemma For an arbitrary node we suppose that all nodes whose distance is less than s has met the requirement and we only need to prove that node also meets the requirement Suppose the start of the 2 incoming edges is separately and First if or is node 1 we can simply choose and as the two paths and obviously they don t intersect Thus it meet the requirement Second if and are not node 1 We choose an arbitrary path and call it path 0 According to our assumption we can choose two different paths starting at node 1 and ending at node t and the two paths don t intersect We call them path 1 and path 2 separately If path 0 and path 1 or path 2 doesn t intersect then we can choose path 0 and path 1 to meet the requirement Thus we only need to consider the situation that path 0 intersect with both path 1 and path 2 In this case we first find the lowest and deepest node where path 0 and path 1 or path 2 intersect and call them and separately If the both are the intersect points of path 0 and path 1 like the case below we can choose path 1 a through path 1 i e blue path b s and path 2 Otherwise like the case below we can choose path 1 a t and path 1 b s Both cases are meet the requirement Thus we ve proved the lemma So we only need to make sure that every node except node 1 has at least 2 incoming edges Then we can get the following solution if is fixed For every node which has only 1 incoming edge we record the start point of the incoming edge in an array Then We scan all nodes in the ascending order of nodes distances and maintain the previous minima and second minima of in an array adding edges greedy Note that we only need to maintain the index of instead of its real value This solution consumes to calculate for a fixed so the total complexity is To accelerate the solution let s try maintaining array while changing And we will apply all the changes in reverse order That is we only consider the case that is decreasing According to the value of we can separate the sequence into many subsegments and we can use std set to maintain those subsegments For one change in it will affect a particular suffix of so we can first find the suffix Then we consecutively change the array until is greater than current subsegment s second minima Next we will prove that the solution works in When we change a particular subsegment we separate the operation into 3 types according to the relationship between and the subsegment s Using std set and segment tree all of these operations could be done in at a time Thus the total complexity is In conclusion we can solve this task in solution 
https://codeforces.com//contest/739/problem/E,81536,E,739E,739,E. Gosha is hunting,Gosha is hunting His goal is to catch as many Pokemons as possible Gosha has Poke Balls and Ultra Balls There are Pokemons They are numbered through Gosha knows that if he throws a Poke Ball at the th Pokemon he catches it with probability If he throws an Ultra Ball at the th Pokemon he catches it with probability He can throw at most one Ball of each type at any Pokemon The hunting proceeds as follows at first Gosha chooses no more than Pokemons at which he will throw Poke Balls and no more than Pokemons at which he will throw Ultra Balls After that he throws the chosen Balls at the chosen Pokemons If he throws both Ultra Ball and Poke Ball at some Pokemon he is caught if and only if he is caught by any of these Balls The outcome of a throw doesn t depend on the other throws Gosha would like to know what is the expected number of the Pokemons he catches if he acts in an optimal way In other words he would like to know the maximum possible expected number of Pokemons can catch ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=2010;\nint n,a,b,cnt[N][N];\ndouble p[N],u[N],f[N],dp[N][N];\nint main() {\n\tscanf(""%d%d%d"",&n,&a,&b);\n\trep(i,0,n) scanf(""%lf"",p+i);\n\trep(i,0,n) scanf(""%lf"",u+i),f[i]=p[i]+u[i]-p[i]*u[i];\n\tdouble l=-5e4,r=5e4;\n\twhile (clock()<=4*CLOCKS_PER_SEC) {\n\t\tdouble md=(l+r)*0.5;\n\t\trep(i,0,n+1) rep(j,0,i+1) dp[i][j]=-1e10,cnt[i][j]=0;\n\t\tdp[0][0]=0;\n\t\trep(i,1,n+1) rep(j,0,i+1) {\n\t\t\tif (j<i&&dp[i-1][j]>dp[i][j]) dp[i][j]=dp[i-1][j],cnt[i][j]=cnt[i-1][j];\n\t\t\tif (j>0&&dp[i-1][j-1]+p[i-1]>dp[i][j]) dp[i][j]=dp[i-1][j-1]+p[i-1],cnt[i][j]=cnt[i-1][j-1];\n\t\t\tif (j<i&&dp[i-1][j]+u[i-1]+md>dp[i][j]) dp[i][j]=dp[i-1][j]+u[i-1]+md,cnt[i][j]=cnt[i-1][j]+1;\n\t\t\tif (j>0&&dp[i-1][j-1]+f[i-1]+md>dp[i][j]) dp[i][j]=dp[i-1][j-1]+f[i-1]+md,cnt[i][j]=cnt[i-1][j-1]+1;\n\t\t}\n\t\tif (cnt[n][a]<b) l=md; else r=md;\n\t}\n\tprintf(""%.10f\\n"",dp[n][a]-b*0.5*(l+r));\n}\n']",,,"['brute force', 'data structures', 'dp', 'flows', 'math', 'probabilities', 'sortings']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Gosha is hunting.json,https://codeforces.com//blog/entry/48582,Let s divide Pokemons into 4 types and depending on Balls that we throw to them Let s sort them by in descending order Let s iterate over last Pokemon in which we throw Ultra Ball his type is or Let be the index of this Pokemon It is not hard to prove that there are no Pokemons to the left of that have type and all Pokemons to the right of have type or Let s sort all Pokemons to the left of by in descending order Let s iterate last Pokemon of type Let be his index We can prove that to the left of every Pokemon has type or Let s call this group of Pokemons Between and every Pokemon has type or will call them To the right of only and will call them We know that we throw an Ultra Ball to every Pokemon in So let s add to our answer sum of of all Pokemons in Number of Pokemons in of type equals to the difference between number of Ultra Balls and size of Therefore we know number of Pokemons in of type and we know how many Poke Balls are left for and summarily Not hard to prove that in group we should throw Poke Balls to Pokemons with greatest Now we have to understand in which Pokemons in and we should throw Poke Balls If we throw Poke Ball to Pokemon from it adds to the answer from adds So we should throw Poke Balls to Pokemons with greatest values When we iterate over each iteration one Pokemon moves from to We can keep structure that can add and delete one element find minimum and keep sum of all elements in the structure For example treap or map in c Let s keep 2 such structures for calculating answer for and for calculating answer for throwing Poke Balls to Pokemons in and The complexity O 
https://codeforces.com//contest/1380/problem/G,670989,G,1380G,1380,G. Circular Dungeon,You are creating a level for a video game The level consists of n rooms placed in a circle The rooms are numbered 1 through n Each room contains exactly one exit completing the j th room allows you to go the j 1 th room and completing the n th room allows you to go the 1 st room You are given the description of the multiset of n chests the i th chest has treasure value c i Each chest can be of one of two types regular chest when a player enters a room with this chest he grabs the treasure and proceeds to the next room mimic chest when a player enters a room with this chest the chest eats him alive and he loses The player starts in a random room with each room having an equal probability of being chosen The players earnings is equal to the total value of treasure chests he d collected before he lost You are allowed to choose the order the chests go into the rooms For each k from 1 to n place the chests into the rooms in such a way that each room contains one chest k chests are mimics the expected value of players earnings is possible Please note that for each k the placement is chosen independently It can be shown that it is in the form of frac P Q where P and Q are non negative integers and Q ne 0 Report the values of P cdot Q 1 pmod 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N; cin >> N;\n    vi C(N); F0R(i, N) cin >> C[i];\n\n    mi in = inv(mi(N));\n\n    sort(all(C)); reverse(all(C));\n    mi pre[N+1];\n    pre[0] = 0;\n    F0R(i, N) pre[i+1] = pre[i] + C[i];\n\n    FOR(K, 1, N+1) {\n        mi ans = 0;\n        for (int i = 0; i < N; i += K) {\n            ans += (i / K) * (pre[min(i+K, N)] - pre[i]);\n        }\n        ans *= in;\n        cout << ans << "" "";\n    }\n    cout << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['greedy', 'math', 'probabilities']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Circular Dungeon.json,https://codeforces.com//blog/entry/80054,TutorialAt first let s say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by So we can trasition to minimizing the sum Let s learn how to solve the task for some fixed Fix some arrangement and rotate the rooms so that the last room contains a mimic So now you have regular chests then a single mimic regular chests single mimic regular chests single mimic All and Take a look at some of these intervals of length The last chest in the interval is taken from starting positions the second to last is taken times and so on Now let s find the optimal way to choose Fix some values of Take a look at the smallest of these values and the largest of them Let the values be and If they differ by at least then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one ProofConsider two sequences of coefficients for both intervals and However if you remove one chest then they will be equal to and If you only consider the difference between the numbers of both sequences then you can see that only coefficient got removed and coefficient was added So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to becomes assigned to thus decreasing the total value Now we have all set now The only thing left is to assign chests optimally Write down the union of all the coefficient sequences from all the intervals and sort them in the non decreasing order It s easy to show that the chests should be sorted in the non increasing order really classical thing you can try proving that by showing that any other arrangement can easily be improved once again That allows us to write a solution in Sort all the chests in the beginning after that for some multiply the value of the th chest by and sum up the results Finally let s speed this up with prefix sums Notice that the first values are multiplied by the second values by and so on If is not divisible by then the last block just has length smaller than Thus we can calculate the answer for some in And that s equal to Overall complexity 
https://codeforces.com//contest/807/problem/A,105601,A,807A,807,A. Is it rated ,Here it is The Ultimate Question of Competitive Programming Codeforces and Everything And you are here to answer it Another Codeforces round has been conducted No two participants have the same number of points For each participant from the top to the bottom of the standings their rating before and after the round is known It s known that if at least one participant s rating has changed then the round was rated for sure It s also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating then at least one round participant s rating has changed In this problem you should not make any other assumptions about the rating system Determine if the current round is rated unrated or it s impossible to determine whether it is rated of not ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool rated(vector<pair<int,int> > vec) {\n    for(int i=0;i<vec.size();i++) {\n        if(vec[i].first != vec[i].second) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool unrated(vector<pair<int,int> > vec) {\n    if(rated(vec)) {\n        return false;\n    }\n    for(int i=0;i<vec.size()-1;i++) {\n        if(vec[i].first < vec[i+1].first) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int,int> > vec(n);\n    for(int i=0;i<n;i++) {\n        cin >> vec[i].first >> vec[i].second;\n    }\n    if(rated(vec)) {\n        cout << ""rated"" << endl;\n    } else if(unrated(vec)) {\n        cout << ""unrated"" << endl;\n    } else {\n        cout << ""maybe"" << endl;\n    }\n}']",,,"['implementation', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Is it rated .json,https://codeforces.com/blog/entry/51883,To solve this problem you just had to read the problem statement carefully Looking through the explanations for the example cases was pretty useful How do we check if the round is rated for sure The round is rated for sure if anyone s rating has changed that is if for some How do we check if the round is unrated for sure Given that all the round is unrated for sure if for some we have This can be checked using two nested for loops over and can you check the same using one for loop How do we find that it s impossible to determine if the round is rated or not If none of the conditions from steps 1 and 2 is satisfied the answer is 
https://codeforces.com//contest/1968/problem/C,2623676,C,1968C,1968,C. Assembly via Remainders,You are given an array x 2 x 3 dots x n Your task is to find array a 1 dots a n where 1 le a i le 10 9 for all 1 le i le n x i a i bmod a i 1 for all 2 le i le n Here c bmod d denotes the remainder of the division of the integer c by the integer d For example 5 bmod 2 1 72 bmod 3 0 143 bmod 14 3 ,"['#include <bits/stdc++.h>\xa0using namespace std;\xa0typedef long long ll;\xa0void solve();const int MX = 1010;\xa0vector<pair<int, int>> hw[MX];\xa0int main() {    for (int i = 1; i < MX; ++i) {        for (int j = 1; j < MX; ++j) {            hw[i % j].emplace_back(i, j);        }    }    cin.tie(nullptr)->sync_with_stdio(false);    int _ = 1;    cin >> _;    while (_--) {        solve();    }}\xa0void solve() {    int n;    cin >> n;    vector<int> a(n - 1);    for (auto &i : a) {        cin >> i;    }    int cur = 5000;    cout << cur << \' \';    for (auto &el : a) {        cout << (cur += el) << \' \';    }    cout << ""\\n"";}']",,,"['constructive algorithms', 'number theory']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Assembly via Remainders.json,https://codeforces.com//blog/entry/129096,Notice that for So we may try to generate a sequence with Let us take because is larger than any of Then we can take as since will be hold The maximal value of will be at most what is smaller than 
https://codeforces.com//contest/1039/problem/A,215700,A,1039A,1039,A. Timetable,There are two bus stops denoted A and B and there n buses that go from A to B every day The shortest path from A to B takes t units of time but some buses might take longer paths Moreover buses are allowed to overtake each other during the route At each station one can find a sorted list of moments of time when a bus is at this station We denote this list as a 1 a 2 ldots a n for stop A and as b 1 b 2 ldots b n for stop B The buses always depart from A and arrive to B according to the timetable but the order in which the buses arrive may differ Let s call an order of arrivals valid if each bus arrives at least t units of time later than departs It is known that for an order to be valid the latest possible arrival for the bus that departs at a i is b x i i e x i th in the timetable In other words for each i there exists such a valid order of arrivals that the bus departed i th arrives x i th and all other buses can arrive arbitrary but there is no valid order of arrivals in which the i th departed bus arrives x i 1 th Formally let s call a permutation p 1 p 2 ldots p n valid if b p i ge a i t for all i Then x i is the maximum value of p i among all valid permutations You are given the sequences a 1 a 2 ldots a n and x 1 x 2 ldots x n but not the arrival timetable Find out any suitable timetable for stop B b 1 b 2 ldots b n or determine that there is no such timetable ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nint n;\nll t;\nll a[N];\nll b[N];\nint c[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%lld"", &n, &t);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &c[i]);\n\t\tc[i]--;\n\t\tif (c[i] < i) {\n\t\t\tprintf(""No\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = a[i] + t;\n\tint m = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tm = max(m, c[i]);\n\t\tif (m > i)\n\t\t\tb[i] = max(b[i], a[i + 1] + t);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = max(b[i], b[i - 1] + 1);\n\n\tint r = 0;\n\tfor (int l = 0; l < n; l++) {\n\t\tif (r <= l) r = l + 1;\n\t\twhile(r < n && a[r] + t <= b[r - 1]) r++;\n\t\tif (c[l] != r - 1) {\n\t\t\tprintf(""No\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""Yes\\n"");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%lld "", b[i]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Timetable.json,https://codeforces.com/blog/entry/61668,If there is at least one valid ordering s and it surely exists since the is defined then the ordering is also valid Hence if for some doesn t hold then the answer is no Also from this follows that Otherwise what it means that It means that there is an ordering in which the th bus comes as where the other buses will come then It turns out that the least restricting way to complete the ordering is following Note that since ordering it is also allowed for to go to it wouldn t be too fast but we can doubt whether and etc are good More over since not say it must hold that are good not fast enough but doesn t hold too fast So for each we can use scanline to calculate whether it is good or not And then we can restore s in negative order What conditions must hold on and depending on whether some is good or not or We can go in reverse order and select the value of on the basis of the cases above Also since if there are many options for it is best to select the largest of them 
https://codeforces.com//contest/1999/problem/G2,2800026,G2,1999G2,1999,G2. Ruler  hard version ,mathbf 7 We have a secret ruler that is missing one number x 2 leq x leq 999 When you measure an object of length y the ruler reports the following values If y x the ruler correctly measures the object as having length y If y geq x the ruler incorrectly measures the object as having length y 1 You need to find the value of x To do that you can make queries of the following form texttt a b in response we will measure the side lengths of an a times b rectangle with our ruler and multiply the results reporting the measured area of the rectangle back to you For example if x 4 and you query a 3 times 5 rectangle we will measure its side lengths as 3 times 6 and report 18 back to you Find the value of x You can ask at most mathbf 7 queries ,"['#include<bits/stdc++.h>using namespace std;int T;int solve(int l,int r){\tif(l==r)return l;\tint lmid=(2*l+r)/3,rmid=(2*r+l)/3;\tcout<<""? ""<<lmid<<"" ""<<rmid<<endl;\tint got;cin>>got;\tif(got==lmid*rmid)return solve(rmid+1,r);\tif(got==(lmid+1)*(rmid+1))return solve(l,lmid);\treturn solve(lmid+1,rmid);}int main(){\tcin>>T;\twhile(T--){\t\tint got=solve(2,999);\t\tcout<<""! ""<<got<<endl;\t}\treturn 0;}']",,,"['binary search', 'interactive', 'ternary search']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\G2. Ruler  hard version .json,https://codeforces.com//blog/entry/132373,Consider one query of the form a b for a b That means If a b x the response is a b both a and b are measured correctly If a x b the response is a b 1 a is measured correctly but b is not If x a b the repsone is a 1 b 1 both a and b are measured incorrectly This means that as a result of one query we can cut the list of possible x values into three pieces b 999 a b or 1 a In other words if we choose a and b appropriately the number of possible x goes down by a factor of 3 If we repeat this each time dividing the search space into three equal pieces then the number of queries needed is log3 1000 7 This is similar to the so called ternary search to find the maximum of a unimodal function although it is slightly different You should be careful about the small case when there are only two possible values of x left 
https://codeforces.com//contest/1372/problem/D,665585,D,1372D,1372,D. Omkar and Circle,Danny the local Math Maniac is fascinated by circles Omkar s most recent creation Help him solve this circle problem You are given n nonnegative integers a 1 a 2 dots a n arranged in a circle where n must be odd ie n 1 is divisible by 2 Formally for all i such that 2 leq i leq n the elements a i 1 and a i are considered to be adjacent and a n and a 1 are also considered to be adjacent In one operation you pick a number on the circle replace it with the sum of the two elements adjacent to it and then delete the two adjacent elements from the circle This is repeated until only one number remains in the circle which we call the circular value Help Danny find the maximum possible circular value after some sequences of operations ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef pair<int ,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double rl;\n\ntypedef pii int2;\ntypedef tuple<int, int, int>           int3;\ntypedef tuple<int, int, int, int>      int4;\ntypedef tuple<int, int, int, int, int> int5;\n\ntypedef pll ll2;\ntypedef tuple<ll, ll, ll>         ll3;\ntypedef tuple<ll, ll, ll, ll>     ll4;\ntypedef tuple<ll, ll, ll, ll, ll> ll5;\n\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vll_ll;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\ntypedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n\n#define FOR(i,N) for(int i=0; i<N; i++)\n\n#define popc __builtin_popcountll\n// #define popc __builtin_popcount\n\ntemplate<typename A>\nstring to_string(A* ptr)\n{\n    stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill (\'0\') << std::hex << (uint64_t)(uintptr_t)ptr;\n    return ss.str();\n}\n\nstring to_string(char c)\n{\n    return ((string)""\'""+c)+ ""\'"";\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#if !ONLINE_JUDGE && 1\n#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\nconst int MX=2e5+99;\nint n;\nint k;\nll a[MX];\n\nll& aa(int idx)\n{\n    idx%=n;\n    if(idx<0) idx+=n;\n    return a[idx];\n}\n\nll S[MX];\n\nll solve()\n{\n    if(n==1) return a[0];\n    k=(n-1)/2;\n\n    ll sumOdd=0, sumEven=0;\n    for(int i=0; i<n; i++)\n    {\n        if(i%2==0) sumEven+=a[i];\n        else sumOdd+=a[i];\n    }\n\n    S[0]=a[0];\n    S[1]=a[1];\n    for(int i=2; i<n; i++) S[i]=S[i-2]+a[i];\n\n    ll result=sumEven;\n    for(int i=0; i+1<n; i++)\n    {\n        ll left=S[i];\n        ll right=a[i+1] + ((i+1)%2==0 ? sumEven : sumOdd) - S[i+1];\n        result=max(result, left+right);\n    }\n\n    return result;\n}\n\nint main()\n{\n#if !ONLINE_JUDGE && 0\n    freopen(""D.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n#endif\n#if 0\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n#endif\n\n    int TT;\n#if 0\n    cin >> TT;\n#else\n    TT=1;\n#endif\n    for(int ttt=0; ttt<TT; ttt++)\n    {\n        cin >> n;\n        for(int i=0; i<n; i++) cin >> a[i];\n        cout << solve();\n    }\n\n    return 0;\n}\n']",,,"['brute force', 'dp', 'games', 'greedy']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Omkar and Circle.json,https://codeforces.com//blog/entry/79974,First note that any possible circular value consists of the sum of some elements Now let s think about how these values would look like in the circle Let s consider any one move on index will be replaced with the sum of and wrap around to index or if needed Then let s consider making a move on since it will be adjacent to after the first move Then its value will become This implies that alternating values play a role in the construction of the values contained in the final circular value Now let s consider the final move when there s elements left in the circle This is the only move that takes the sum of two adjacent elements in the initial circle With this observation we can achieve our final construction as follows Choose any elements in the initial circle such that exactly one pair of chosen numbers are adjacent to each other The answer will be the maximum of the circular value over all possible constructions While there are ways involving complicated prefix sums segment trees the cleanest implementation is as follows create an array whose values consists of Append this new array to itself to account for the circular structure Now all you simply have to do is to find the maximum sum over all subarrays of length This can be done with sliding window in time 
https://codeforces.com//contest/1624/problem/E,1256441,E,1624E,1624,E. Masha-forgetful,Masha meets a new friend and learns his phone number s She wants to remember it as soon as possible The phone number is a string of length m that consists of digits from 0 to 9 The phone number may start with Masha already knows n phone numbers all numbers have the same length m It will be easier for her to remember a new number if the s is represented as segments of numbers she already knows Each such segment must be of length otherwise there will be too many segments and Masha will get confused For example Masha needs to remember the number s and she already knows n 4 numbers You can represent s as a 3 segment of number one of number two and of number three There are other ways to represent s Masha asks you for help she asks you to break the string s into segments of length 2 or more of the numbers she already knows If there are several possible answers print of them ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << ' ', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 1e3 + 10;\nconst int mod = 998244353;\nchar a[N][N];\nchar c[N];\nstruct pos {\n    int x, y, id;\n};\npos b[N * 2];\nint f[N];\nint s2i(char x, char y) {\n    return (x - '0') * 10 + y - '0';\n}\nint s2i(char x, char y, char z) {\n    return (x - '0') * 100 + (y - '0') * 10 + z - '0' + 1000;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < 2000; ++i) {\n            b[i].x = b[i].y = b[i].id = -1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            cin >> (a[i] + 1);\n            for (int j = 1; j <= m; ++j) {\n                if (j + 1 <= m) {\n                    int v = s2i(a[i][j], a[i][j + 1]);\n                    b[v].x = j;\n                    b[v].y = j + 1;\n                    b[v].id = i;\n                }\n                if (j + 2 <= m) {\n                    int v = s2i(a[i][j], a[i][j + 1], a[i][j + 2]);\n                    b[v].x = j;\n                    b[v].y = j + 2;\n                    b[v].id = i;\n                }\n            }\n        }\n        cin >> (c + 1);\n        memset(f, -1, sizeof f);\n        f[0] = 0;\n        for (int i = 1; i <= m; ++i) {\n            if (i - 2 >= 0 && f[i - 2] != -1 && b[s2i(c[i - 1], c[i])].id != -1) {\n                f[i] = i - 2;\n            }\n            if (i - 3 >= 0 && f[i - 3] != -1 && b[s2i(c[i - 2], c[i - 1], c[i])].id != -1) {\n                f[i] = i - 3;\n            }\n        }\n        if (f[m] == -1) {\n            cout << -1 << '\\n';\n        } else {\n            vector<pos> ans;\n            for (int i = m; i; i = f[i]) {\n                if (i - f[i] == 2) {\n                    ans.emplace_back(b[s2i(c[i - 1], c[i])]);\n                } else {\n                    ans.emplace_back(b[s2i(c[i - 2], c[i - 1], c[i])]);\n                }\n            }\n            reverse(ans.begin(), ans.end());\n            cout << ans.size() << '\\n';\n            for (auto& i : ans) {\n                cout << i.x << ' ' << i.y << ' ' << i.id << '\\n';\n            }\n        }\n    }\n}""]",,,"['brute force', 'constructive algorithms', 'dp', 'hashing', 'implementation', 'strings']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Masha-forgetful.json,https://codeforces.com//blog/entry/98942,The key idea is that any string of length greater than 3 can be obtained by concatenating strings of length or Then when reading the data remember all occurring substring of length and There are at most Now we will count the dynamics on the prefix if we can get the prefix of length of phone by segments of length and of the known phones Masha Then for the transition we need to look through the lengths and then take a substring of the corresponding length and find out whether such a string occurred in the phones known to Masha Then it will take or time to recalculate the dynamics depending on the implementation But it will still take more time to read the data so the final asymptotic will be or 
https://codeforces.com//contest/1332/problem/G,578667,G,1332G,1332,G. No Monotone Triples,Given a sequence of integers a of length n a tuple i j k is called monotone triples if 1 le i j k le n a i le a j le a k or a i ge a j ge a k is satisfied For example a 5 3 4 5 then 2 3 4 is monotone triples for sequence a while 1 3 4 is not Bob is given a sequence of integers a of length n in a math exam The exams itself contains questions of form L R for each of them he is asked to find any subsequence b of sequence a L a L 1 ldots a R Recall that an sequence b is a subsequence of sequence a if b can be obtained by deletion of several possibly zero or all elements However he hates monotone stuff and he wants to find a subsequence Besides he wants to find one subsequence with the length among all subsequences free from monotone triples for every query Please help Bob find out subsequences meeting the above constraints ,"['#include <bits/stdc++.h>\n#define p2 p << 1\n#define p3 p << 1 | 1\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < \'0\' || c > \'9\') && c != \'-\');\n\tif (c == \'-\') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= \'0\' && c <= \'9\')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntemplate <class T>\ninline T Max(const T &a, const T &b) {return a > b ? a : b;}\n\ntemplate <class T>\ninline T Min(const T &a, const T &b) {return a < b ? a : b;}\n\nconst int N = 2e5 + 5, M = N << 2, E = 20;\n\nint n, q, a[N], top, stk[N], pre0[N], pre1[N], nxt0[N], nxt1[N], pre[N], nxt[N],\nlt[N], mx[M], rmin[N][E], rmax[N][E], Log[N], ml[N], mr[N], l0[N], r0[N],\nl1[N], r1[N];\nstd::vector<int> oz[N];\n\nvoid change(int l, int r, int pos, int v, int p)\n{\n\tmx[p] = Max(mx[p], v); if (l == r) return;\n\tint mid = l + r >> 1;\n\tif (pos <= mid) change(l, mid, pos, v, p2);\n\telse change(mid + 1, r, pos, v, p3);\n}\n\nint query(int l, int r, int x, int p)\n{\n\tif (l == r) return mx[p];\n\tint mid = l + r >> 1;\n\tif (x <= mid) return query(l, mid, x, p2);\n\telse return Max(mx[p2], query(mid + 1, r, x, p3));\n}\n\nint qmin(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmin[l][k]] < a[rmin[r - (1 << k) + 1][k]]\n\t\t? rmin[l][k] : rmin[r - (1 << k) + 1][k];\n}\n\nint qmax(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmax[l][k]] > a[rmax[r - (1 << k) + 1][k]]\n\t\t? rmax[l][k] : rmax[r - (1 << k) + 1][k];\n}\n\nint main()\n{\n\tint l, r;\n\tread(n); read(q);\n\tfor (int i = 1; i <= n; i++) read(a[i]), rmin[i][0] = rmax[i][0] = i;\n\tLog[0] = -1;\n\tfor (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1;\n\tfor (int j = 1; j <= 17; j++)\n\t\tfor (int i = 1; i + (1 << j) - 1 <= n; i++)\n\t\t{\n\t\t\trmin[i][j] = a[rmin[i][j - 1]] < a[rmin[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmin[i][j - 1] : rmin[i + (1 << j - 1)][j - 1];\n\t\t\trmax[i][j] = a[rmax[i][j - 1]] > a[rmax[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmax[i][j - 1] : rmax[i + (1 << j - 1)][j - 1];\n\t\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tpre0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tpre1[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tnxt0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tnxt1[i] = stk[top]; stk[++top] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) pre[i] = std::min(pre0[i], pre1[i]),\n\t\tnxt[i] = std::max(nxt0[i], nxt1[i]), oz[pre[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt[i] <= n) change(1, n, nxt[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tml[i] = ml[i - 1]; mr[i] = mr[i - 1];\n\t\tif (lt[i] > ml[i]) ml[i] = lt[i], mr[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre0[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt0[i] <= n) change(1, n, nxt0[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl0[i] = l0[i - 1]; r0[i] = r0[i - 1];\n\t\tif (lt[i] > l0[i]) l0[i] = lt[i], r0[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre1[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt1[i] <= n) change(1, n, nxt1[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl1[i] = l1[i - 1]; r1[i] = r1[i - 1];\n\t\tif (lt[i] > l1[i]) l1[i] = lt[i], r1[i] = i;\n\t}\n\twhile (q--)\n\t{\n\t\tread(l); read(r);\n\t\tif (ml[r] >= l)\n\t\t{\n\t\t\tputs(""4""); int x = qmin(ml[r], mr[r]), y = qmax(ml[r], mr[r]);\n\t\t\tif (x > y) std::swap(x, y);\n\t\t\tprintf(""%d %d %d %d\\n"", ml[r], x, y, mr[r]);\n\t\t}\n\t\telse if (l0[r] >= l)\n\t\t\tputs(""3""), printf(""%d %d %d\\n"", l0[r], qmin(l0[r], r0[r]), r0[r]);\n\t\telse if (l1[r] >= l)\n\t\t\tputs(""3""), printf(""%d %d %d\\n"", l1[r], qmax(l1[r], r1[r]), r1[r]);\n\t\telse puts(""0"");\n\t}\n\treturn 0;\n}']",,,['data structures'],3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\G. No Monotone Triples.json,https://codeforces.com//blog/entry/75432,We will solve this task with the following observations If an array of length has no monotone triple then one of the following is true If an array of length has no monotone triple then its subsequence has no monotone triple If an array of length 4 has no monotone triple then vice versa WLOG we assume by observation 1 we will know that since we get a monotone triple leading to contradiction Second part can be verified easily For every array of length must have monotone triple WLOG we just need to prove the observation holds when and cases when not all elements are equal In that case one of extremal can be reached in position other than WLOG we will assume that maximum is reached at position However cannot be monotone triple free leading to contradiction Combining those observations or Erdos Szekeres theorem if you know it we would like to get the following solution which runs in If the subsequence is monotone the answer should be 0 If there exists such that and fails to reach maximum and minimum among those four numbers the answer should be 4 Otherwise the answer should be 3 In the following paragraphs we will only focus on the case of Other stuffs can be dealt similarly or easily the observation is crucial to obtain a faster solution Notice that constraint is equivalent to that there exists such that fails to reach maximum and minimum among This observation allows us to solve this task in with some precalculation though it s still not enough to get accepted Let s solve the task for a sequence of a pairwise distinct numbers and then change the conditions to a general sequence Let s fix the leftmost element of and look at what we are asked to find So there should be some position to the right of so that the range of values on positions excluding the greatest and the smallest values includes both and Let s process the array from right to left maintaining two stacks The top element in both stacks is the currently processed one Next element of the first stack is the closest to the right element greater than the top one and the next element of the second stack is the closest to the right smaller than the top one And the stacks go like that until the end of array Iterating over one of these stacks will show the increase of the range of values in one direction iterating over both at the same time will show how the range of values changes in total So I claim that the sequence we are looking for exists iff both stacks include more than element and there is an element to the right of second elements of both stacks such that it is included in neither of the stacks Naturally that condition tells that there is some position in which neither maximum nor minimum values are updated The values that are in neither of stacks can be maintained in a queue or in a BIT Basically the position when the range of values doesn t change is such a value which is both smaller than the maximum value on the segment and greater than the minimum one Thus we can choose the latest elements in both stacks up to that position and that position itself How to deal with not pairwise distinct elements Well it s enough to change the conditions in stacks to the next greater or equal and the next smaller or equal However that will push the elements equal to the current one right next to it to the both stacks Previously we kinda used the fact that no element except the current one is in both stacks I think that the easiest way to deal with it is to get the answer for the rightmost of the consecutive equal elements and then just say that the answer for the rest of them is the same Finally push all these consecutive equal elements to the both stacks As for queries I previously said that we can take the position where the value range doesn t change Basically the first valid position is coincidentally the shortest length valid segment starting from So to find the first position you just need to do a binary search over that queue or BIT of the values which are in neither of the stacks We can easily remember it for each position and then do a range minimum query checking if any of the positions in have their shortest right border smaller than 
https://codeforces.com//contest/940/problem/A,159599,A,940A,940,A. Points on the line,The of a multiset of points on the line is the largest distance between two points from this set For example the diameter of the multiset is 2 Diameter of multiset consisting of one point is 0 You are given points on the line What is the minimum number of points you have to remove so that the diameter of the multiset of the remaining points will not exceed ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint n, d;\nint a[100005];\nint main(){\n\tscanf(""%d%d"", &n, &d);\n\tfor(int i = 1; i <= n; i ++){\n\t\tscanf(""%d"", &a[i]);\n\t}\n\tsort(a + 1, a + n + 1);\n\tint ans = 100;\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = i; j <= n; j ++){\n\t\t\tif(a[j] - a[i] <= d){\n\t\t\t\tans = min(ans, i - 1 + n - j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n} \n']",,,"['brute force', 'greedy', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Points on the line.json,https://codeforces.com//blog/entry/58033,It s clear that diameter of the multiset of points equals to difference of coordinates of point with maximum coordinate and point with minimum coordinate So we can iterate over all possible pairs of maximum and minimum point and check number of remaining points in This solution works in Of course there are faster solutions 
https://codeforces.com//contest/372/problem/A,4182,A,372A,372,A. Counting Kangaroos is Fun,There are kangaroos with pockets Each kangaroo has a size integer number A kangaroo can go into another kangaroo s pocket if and only if the size of kangaroo who hold the kangaroo is at least twice as large as the size of kangaroo who is held Each kangaroo can hold at most one kangaroo and the kangaroo who is held by another kangaroo cannot hold any kangaroos The kangaroo who is held by another kangaroo cannot be visible from outside Please find a plan of holding kangaroos with the minimal number of kangaroos who is visible ,"['#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n//#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(int)n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ACCU accumulate\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<ll> VL;\nconst ll mod=1000000007;\nconst double eps=1e-9;\nconst double pi=acos(0)*2;\nll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\nint n,a[6010000],l,r;\nbool check(int x) {\n\tper(i,0,x) if (i-x+n<x||2*a[i]>a[i-x+n]) return 0;\n\treturn 1;\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d"",a+i);\n\tsort(a,a+n);\n\tl=0;r=n;\n\twhile (l+1<r) {\n\t\tint md=(l+r)/2;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tprintf(""%d\\n"",n-l);\n\treturn 0;\n}\n']",,,"['binary search', 'greedy', 'sortings', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Counting Kangaroos is Fun.json,https://codeforces.com/blog/entry/9944,Because of the number of holding held relations is at most We can assume that first half of kangaroos do not hold any kangaroos and last half of kangaroos are not held by any kangaroos So we can split kangaroos in two set such that first set contains the kangaroos whose size is in smaller half and second set contains the kangaroos whose size is in larger half and use easy greedy algorithm The time conplexity is O N log N for sorting and O N for greedy so the time conplexity is O N log N my solution http ideone com w8ch4w 
https://codeforces.com//contest/1598/problem/C,1138072,C,1598C,1598,C. Delete Two Elements,Monocarp has got an array a consisting of n integers Let s denote k as the mathematic mean of these elements note that it s possible that k is not an integer The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements i e sum divided by n Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining n 2 elements is still equal to k Your task is to calculate the number of pairs of positions i j i j such that if the elements on these positions are deleted the mathematic mean of n 2 remaining elements is equal to k that is it is equal to the mathematic mean of n elements of the original array a ,"[""/**\n *    author:  tourist\n *    created: 10.10.2021 12:09:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    long long sum = accumulate(a.begin(), a.end(), 0LL);\n    // sum / n == sum' / (n - 2)\n    __int128 goal8 = __int128(sum) * (n - 2);\n    if (goal8 % n != 0) {\n      cout << 0 << '\\n';\n      continue;\n    }\n    long long goal = sum - (long long) (goal8 / n);\n    map<long long, int> mp;\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n      auto it = mp.find(a[i]);\n      if (it != mp.end()) {\n        ans += it->second;\n      }\n      mp[goal - a[i]] += 1;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]",,,"['data structures', 'dp', 'implementation', 'math', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Delete Two Elements.json,https://codeforces.com//blog/entry/95890,First of all instead of the mathematic mean let s consider the sum of elements If the mathematic mean is then the sum of elements of the array is Let s denote the sum of elements in the original array as Note is always an integer If we remove two elements from the array the resulting sum of elements should become So the sum of the elements we remove should be exactly If is not an integer the answer is to check that you can simply compare with Otherwise we have to find the number of pairs such that and This is a well known problem To solve it you can calculate the number of occurrences of each element and store it in some associative data structure for example in C Let be the number of occurrences of element Then you should iterate on the element you want to remove and check how many elements match it that is how many elements give exactly if you add to them The number of these elements is just Let s sum up all these values for every element in the array Unfortunately this sum is not the answer yet We need to take care of two things if for some index then matches itself so you have to subtract the number of such elements from the answer every pair of elements is counted twice the first time when we consider the first element of the pair and the second time when we consider the second element of the pair So don t forget to divide the answer by 
https://codeforces.com//contest/1975/problem/D,2665475,D,1975D,1975,D. Paint the Tree,378QAQ has a tree with n vertices Initially all vertices are white There are two chess pieces called P A and P B on the tree P A and P B are initially located on vertices a and b respectively In one step 378QAQ will do the following in order Move P A to a neighboring vertex If the target vertex is white this vertex will be painted red Move P B to a neighboring vertex If the target vertex is colored in red this vertex will be painted blue Initially the vertex a is painted red If a b the vertex a is painted blue instead Note that both the chess pieces be moved in each step Two pieces can be on the same vertex at any given time 378QAQ wants to know the minimum number of steps to paint all vertices blue ,"['/** *    author:  tourist *    created: 25.05.2024 10:41:49**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };\xa0  vector<edge> edges;  vector<vector<int>> g;  int n;\xa0  graph(int _n) : n(_n) {    g.resize(n);  }\xa0  virtual int add(int from, int to, T cost) = 0;};\xa0template <typename T>class forest : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;\xa0  forest(int _n) : graph<T>(_n) {  }\xa0  int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    assert(id < n - 1);    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }};\xa0template <typename T>class dfs_forest : public forest<T> { public:  using forest<T>::edges;  using forest<T>::g;  using forest<T>::n;\xa0  vector<int> pv;  vector<int> pe;  vector<int> order;  vector<int> pos;  vector<int> end;  vector<int> sz;  vector<int> root;  vector<int> depth;  vector<T> dist;\xa0  dfs_forest(int _n) : forest<T>(_n) {  }\xa0  void init() {    pv = vector<int>(n, -1);    pe = vector<int>(n, -1);    order.clear();    pos = vector<int>(n, -1);    end = vector<int>(n, -1);    sz = vector<int>(n, 0);    root = vector<int>(n, -1);    depth = vector<int>(n, -1);    dist = vector<T>(n);  }\xa0  void clear() {    pv.clear();    pe.clear();    order.clear();    pos.clear();    end.clear();    sz.clear();    root.clear();    depth.clear();    dist.clear();  }\xa0 private:  void do_dfs(int v) {    pos[v] = (int) order.size();    order.push_back(v);    sz[v] = 1;    for (int id : g[v]) {      if (id == pe[v]) {        continue;      }      auto &e = edges[id];      int to = e.from ^ e.to ^ v;      depth[to] = depth[v] + 1;      dist[to] = dist[v] + e.cost;      pv[to] = v;      pe[to] = id;      root[to] = (root[v] != -1 ? root[v] : to);      do_dfs(to);      sz[v] += sz[to];    }    end[v] = (int) order.size() - 1;  }\xa0  void do_dfs_from(int v) {    depth[v] = 0;    dist[v] = T{};    root[v] = v;    pv[v] = pe[v] = -1;    do_dfs(v);  }\xa0 public:  void dfs(int v, bool clear_order = true) {    if (pv.empty()) {      init();    } else {      if (clear_order) {        order.clear();      }    }    do_dfs_from(v);  }\xa0  void dfs_all() {    init();    for (int v = 0; v < n; v++) {      if (depth[v] == -1) {        do_dfs_from(v);      }    }    assert((int) order.size() == n);  }};\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    int a, b;    cin >> a >> b;    --a; --b;    dfs_forest<int> g(n);    for (int i = 0; i < n - 1; i++) {      int x, y;      cin >> x >> y;      --x; --y;      g.add(x, y);    }    g.dfs(a);    int ans = 0;    int steps = (g.depth[b] + 1) / 2;    while (steps > 0) {      b = g.pv[b];      ans += 1;      steps -= 1;    }    ans += 2 * (n - 1);    g.dfs(b);    int mx = *max_element(g.depth.begin(), g.depth.end());    cout << ans - mx << \'\\n\';  }  return 0;}']",,,"['brute force', 'dfs and similar', 'dp', 'greedy', 'shortest paths', 'trees']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Paint the Tree.json,https://codeforces.com//blog/entry/129801,SolutionRead the hints In subsequent movements after the first time a vertex is painted blue we can ignore the process of painting vertices red and then painting them blue We call the first vertex painted blue Then it is not difficult to find that arrived at this vertex earlier than Considering all subsequent movements of can restore these movements one by one after reaching then will pass through all vertices have been painted red If we know which vertex is this will be a classic problem assuming the distance between the farthest vertex on the tree from and is then the answer is Then we consider the strategies of and at this time The two must be close to each other and then until the first vertex is painted blue If another vertex is although the value of may increase every time the value of increases by the time when and meet will also increase by at least so the answer will not decrease 
https://codeforces.com//contest/1228/problem/D,424245,D,1228D,1228,D. Complete Tripartite,You have a simple undirected graph consisting of n vertices and m edges The graph doesn t contain self loops there is at most one edge between a pair of vertices The given graph can be disconnected Let s make a definition Let v 1 and v 2 be two some nonempty subsets of vertices that do not intersect Let f v 1 v 2 be true if and only if all the conditions are satisfied There are no edges with both endpoints in vertex set v 1 There are no edges with both endpoints in vertex set v 2 For every two vertices x and y such that x is in v 1 and y is in v 2 there is an edge between x and y Create three vertex sets v 1 v 2 v 3 which satisfy the conditions below All vertex sets should not be empty Each vertex should be assigned to only one vertex set f v 1 v 2 f v 2 v 3 f v 3 v 1 are all true Is it possible to create such three vertex sets If it s possible print matching vertex set for each vertex ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100010, M = 300010;\n\nint n, m;\nint u[M], v[M];\nint color[N];\nset<int> g[N];\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  scanf(""%d%d"", &n, &m);\n  for (int i = 1; i <= m; ++i) {\n    scanf(""%d%d"", &u[i], &v[i]);\n    g[u[i]].insert(v[i]);\n    g[v[i]].insert(u[i]);\n  }\n  int a = 1, b = -1, c = -1;\n  for (int i = 1; i <= m; ++i)\n    if (u[i] == 1) {\n      color[v[i]] = -1;\n    }\n  for (int i = 1; i <= m; ++i)\n    if (color[u[i]] == -1 && color[v[i]] == -1) {\n      b = u[i];\n      c = v[i];\n      break;\n    }\n#define GG do{puts(""-1""); return 0;}while(false)\n  if (b == -1) {\n    GG;\n  }\n  for (int i = 1; i <= n; ++i) {\n    bool fa = g[i].count(a), fb = g[i].count(b), fc = g[i].count(c);\n    if (fa + fb + fc != 2)\n      GG;\n    if (!fa)\n      color[i] = 1;\n    else if (!fb)\n      color[i] = 2;\n    else\n      color[i] = 3;\n  }\n  for (int i = 1; i <= m; ++i)\n    if (color[u[i]] == color[v[i]]) {\n      GG;\n    }\n  int ta= count(color + 1, color + n + 1, 1), tb=count(color + 1, color + n + 1, 2), tc=count(color + 1, color + n + 1, 3);\n  if (m != ta*(ll)tb+tb*(ll)tc+tc*(ll)ta)\n    GG;\n  for (int i = 1; i <= n; ++i)\n    printf(""%d "", color[i]);\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'graphs', 'hashing', 'implementation']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Complete Tripartite.json,https://codeforces.com//blog/entry/70162,You can make answer by following these steps If two vertices and are in same vertex set there should be no edge between them Otherwise there should be edge between them If you choose any as first vertex of specific vertex set then you can simply add all vertices which are not directly connected to in that vertex set Make vertex sets by doing second step multiple times If you can t make sets or there is any vertex which is not in any vertex set then answer is impossible If then answer is impossible means size of th vertex set For all vertices and from different vertex sets if there is no direct connection between and then answer is impossible If you validated all steps then current vertex set assignment is answer Make sure you are doing all steps If you forget any of these steps your solution will print wrong answer Time complexity is 
https://codeforces.com//contest/1921/problem/B,2427792,B,1921B,1921,B. Arranging Cats,Scientists have n boxes in which cats may or may not sit Let the current state of the boxes be denoted by the sequence b 1 dots b n b i 1 if there is a cat in box number i and b i 0 otherwise Fortunately the unlimited production of cats has already been established so in one day the scientists can perform one of the following operations Take a new cat and place it in a box for some i such that b i 0 assign b i 1 Remove a cat from a box and send it into retirement for some i such that b i 1 assign b i 0 Move a cat from one box to another for some i j such that b i 1 b j 0 assign b i 0 b j 1 It has also been found that some boxes were immediately filled with cats Therefore the scientists know the initial position of the cats in the boxes s 1 dots s n and the desired position f 1 dots f n Due to the large amount of paperwork the scientists do not have time to solve this problem Help them for the sake of science and indicate the minimum number of days required to test the hypothesis ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,x=0,y=0,z=0;\n    cin>>n;\n    string a,b;\n    cin>>a>>b;\n    for(ll i=0;i<n;i++){\n        if(a[i]==\'1\') x++;\n        if(b[i]==\'1\') y++;\n        if(a[i]==\'1\'&&b[i]==\'1\') z++;\n    }\n    if(x>=y) cout<<x-z;\n    else cout<<y-z;\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Arranging Cats.json,https://codeforces.com//blog/entry/124757,Denote the amount of indices such that and as Since it is impossible to change 0 to 1 at two different positions in one turn the answer is not less than Analogously if is amount of indices such that and the answer is not less than It turns out that the answer is actually equal to We can simply apply move operation from the index with to with while there are both of these types of indices that will be operations and then add or remove the rest of unsatisfied indices that is exactly operations 
https://codeforces.com//contest/1562/problem/E,1090692,E,1562E,1562,E. Rescue Niwen ,After crossing the Windswept Wastes Ori has finally reached the Windtorn Ruins to find the Heart of the Forest However the ancient repository containing this priceless Willow light did not want to open Ori was taken aback but the Voice of the Forest explained to him that the cunning Gorleks had decided to add protection to the repository The Gorleks were very fond of the string expansion operation They were also very fond of increasing subsequences Suppose a string s 1s 2s 3 ldots s n is given Then its expansion is defined as the sequence of strings s 1 s 1 s 2 s 1 s 2 ldots s n s 2 s 2 s 3 s 2 s 3 ldots s n s 3 s 3 s 4 s n 1 s n s n For example the expansion the string will be the following sequence of strings To open the ancient repository Ori must find the size of the largest increasing subsequence of the expansion of the string s Here strings are compared lexicographically Help Ori with this task A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int N = 5005;\nint t, n, f[N];\nchar a[N];\nint rk[N], tp[N], tax[N], sa[N];\nint d[14][N];\ninline void radix_sort(int m) {\n  for (int i = 0; i <= m; i++) tax[i] = 0;\n  for (int i = 1; i <= n; i++) tax[rk[i]]++;\n  for (int i = 1; i <= m; i++) tax[i] += tax[i - 1];\n  for (int i = n; i; i--) sa[tax[rk[tp[i]]]--] = tp[i];\n}\ninline void suffix_sort() {\n  memset(rk, 0, sizeof rk);\n  memset(tp, 0, sizeof tp);\n  memset(tax, 0, sizeof tax);\n  memset(sa, 0, sizeof sa);\n  for (int i = 1; i <= n; i++) tax[rk[i] = a[i] - \'0\']++;\n  for (int i = 1; i <= \'z\' - \'0\'; i++) tax[i] += tax[i - 1];\n  for (int i = n; i; i--) sa[tax[a[i] - \'0\']--] = i;\n  for (int len = 1, p = 0, m = \'z\' - \'0\'; p < n; m = p, len <<= 1) {\n    p = len;\n    for (int i = 1; i <= len; i++) tp[i] = n - len + i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > len) tp[++p] = sa[i] - len;\n    radix_sort(m);\n    std::swap(tp, rk);\n    rk[sa[1]] = p = 1;\n    for (int i = 2; i <= n; i++)\n      rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + len] == tp[sa[i] + len]) ? p : ++p;\n  }\n  memset(tax, 0, (n + 1) << 2);\n}\ninline void get_height() {\n  memset(d, 0, sizeof d);\n  int j, k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (k) k--;\n    j = sa[rk[i] - 1];\n    while (a[i + k] == a[j + k]) k++;\n    d[0][rk[i]] = k;\n  }\n}\ninline void doubly() {\n  for (int j = 1; (1 << j) <= n; j++)\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n      d[j][i] = min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);\n    }\n}\ninline int query(int x, int y) {\n  if (x > y) swap(x, y);\n  x++;\n  int k = __lg(y - x + 1);\n  return min(d[k][x], d[k][y - (1 << k) + 1]);\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(""%d%s"", &n, a + 1);\n    suffix_sort();\n    get_height();\n    doubly();\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int x = sa[i];\n      f[x] = n - x + 1;\n      for (int j = 1; j < i; j++)\n        if (sa[j] < x) {\n          f[x] = max(f[x], f[sa[j]] + n - x + 1 - query(j, i));\n        }\n      ans = max(ans, f[x]);\n    }\n    cout << ans << endl;\n  }\n}']",,,"['dp', 'greedy', 'string suffix structures', 'strings']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Rescue Niwen .json,https://codeforces.com//blog/entry/94278,The constraints on the problem were chosen so that solutions slower than would not get AC or would get with difficulty The solution could be for example to sort all substrings by assigning numbers to them and then find the largest increasing subsequence in the resulting array Let us describe the solution for The most important thing required for the solution is to understand what the largest increasing subsequence should look like Let a string and the length of the string It can be shown that if the largest increasing subsequence has a substring then it also has a substring I will not give a formal proof I will only give the key idea Let the increasing subsequence first have the string and then the substring with It can be understood that if suffixes and have some common prefix and it has already been included in the largest increasing subsequence then we can drop the prefixes of the suffix and instead of them write exactly the same suffix prefixes of and the size of the increasing subsequence will not change and the condition above will be satisfied If however the suffixes and have no common prefix then we could take the suffix itself together with its prefixes and the answer would only improve Thus the largest increasing subsequence looks like this first comes some substring followed by a substring and so on ending with the suffix After that comes some substring followed by a substring and so on ending with the suffix and so on Moreover knowing which suffixes are included in this subsequence we can establish all other substrings Indeed let the suffixes and be included in the sequence and Then it is not difficult to see that the suffix prefixes can be typed greedily namely to take all substring such that they are larger than the suffix Note that if the substring is larger than the suffix then the substring is also larger than the suffix And so we can use the following algorithm to find out that is to find out which suffix prefix to start typing the subsequence Let be the size of the largest common prefix of suffixes and Then it is easy to see that if the suffix is larger than the suffix then the appropriate is which means that you must start typing all substrings starting from the one that differs from the largest common prefix of the two suffixes So now we are left with two problems The first is you have to learn to quickly recognize the greatest common prefix of the two suffixes The second is to write a DP that would allow you to recognize the answer Let s see how to solve the first problem You can use different string algorties such as a suffix array Or we can write a simple DP that calculates an array of the largest common prefixes over The transitions in this DP and its implementation can be seen in the author s solution code lines 37 48 Now about the DP that calculates the answer Let us use the facts above and do the following Let denote the size of the answer if the last substring in it is the suffix Let and then Now let s do the following We will go through from to doing the following simple steps for each from to denotes the previous suffix in the answer we will check how many substring of the suffix we can take if the suffix is larger than the suffix we calculate this number with the above described algorithm using the array of largest common prefixes Otherwise we will not update because the suffix is less than or equal to the suffix we cannot take it in response It is not difficult to guess that the answer is maximal in all Thus the problem is solved using two uncomplicated dynamics Asymptotics per test case 
https://codeforces.com//contest/2051/problem/F,3099579,F,2051F,2051,F. Joker,Consider a deck of n cards The positions in the deck are numbered from 1 to n from top to bottom A joker is located at position m q operations are applied sequentially to the deck During the i th operation you need to take the card at position a i and move it either to the beginning or to the end of the deck For example if the deck is 2 1 3 5 4 and a i 2 then after the operation the deck will be either 1 2 3 5 4 the card from the second position moved to the beginning or 2 3 5 4 1 the card from the second position moved to the end Your task is to calculate the number of distinct positions where the joker can be after each operation ,"['#include <bits/stdc++.h>#define ll long longusing namespace std;\xa0\xa0static vector<pair<ll,ll>> solve(vector<pair<ll,ll>> &arr) {   vector<pair<ll,ll>> ans;   ans.reserve(arr.size());   for (auto &iv : arr) {       if (ans.empty() || ans.back().second < iv.first - 1) {           ans.push_back(iv);       } else {           ans.back().second = max(ans.back().second, iv.second);       }   }   return ans;}\xa0int main(){   ios::sync_with_stdio(false);   cin.tie(nullptr);\xa0   int t;   cin >> t;   while(t--){       ll n, m;       int q;       cin >> n >> m >> q;\xa0       vector<pair<ll,ll>> arr;       arr.push_back({m,m});\xa0       while(q--){           ll a;           cin >> a;\xa0           vector<pair<ll,ll>> res;           res.reserve(arr.size()*2 + 2);\xa0           for (auto &iv : arr) {               ll l = iv.first, r = iv.second;               if (r < a) {                   res.push_back({l, r});\xa0                   ll l2 = l+1, r2 = r+1;                   if (r2 >= 1 && l2 <= n) {                       l2 = max(l2, 1LL);                       r2 = min(r2, n);                       if (l2 <= r2) {                           res.push_back({l2,r2});                       }                   }               }               else if (l > a) {                   res.push_back({l,r});\xa0                   ll l2 = l-1, r2 = r-1;                   if (r2 >= 1 && l2 <= n) {                       l2 = max(l2, 1LL);                       r2 = min(r2, n);                       if (l2 <= r2) {                           res.push_back({l2,r2});                       }                   }               }               else {                   if (l <= a-1) {                       ll lsub = l, rsub = a-1;                       res.push_back({lsub, rsub});                       ll l2 = lsub+1, r2 = rsub+1;                       if (l2<=r2 && l2<=n && r2>=1) {                           l2 = max(l2,1LL);                           r2 = min(r2,n);                           if (l2<=r2) {                               res.push_back({l2,r2});                           }                       }                   }\xa0                   if (l <= a && a <= r) {                       res.push_back({1,1});                       res.push_back({n,n});                   }\xa0                   if (a+1 <= r) {                       ll ls = a+1;                       ll rs = r;                       res.push_back({ls, rs});                       ll l2 = ls-1, r2 = rs-1;                       if (l2<=r2 && l2>=1 && r2<=n) {                           res.push_back({l2,r2});                       }                   }               }           }\xa0           sort(res.begin(), res.end());           arr = solve(res);\xa0           ll ans = 0;\xa0           for (auto &iv : arr) {               ans += (iv.second - iv.first + 1);           }\xa0           cout << ans << "" "";       }       cout << ""\\n"";   }\xa0   return 0;}']",,,"['brute force', 'greedy', 'implementation', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Joker.json,https://codeforces.com//blog/entry/137623,Let s represent the positions where the joker can be as a set of non overlapping segments Let s consider what happens to the segment after applying the th operation if the possible positions segment becomes since moving the th card to the front does not change the joker s positions while moving it to the back shifts the positions up by if the possible positions segment becomes since moving the th card to the front shifts the positions down by while moving it to the back does not change the joker s positions if let s consider subsegments where the joker can be located positions from the subsegment moves to similarly to the case positions from the subsegment moves to similarly to the case the joker from position moves to one of two positions or Thus in this case the segment remains but we need to add two new segments and to the set Note that when the current segment disappears At first glance it seems that this solution works in since the number of segments can be and we need to update each of them However it is not difficult to notice that there cannot be more than segments Specifically the initial segment which expands to the left and right the segment which expands only to the right and the segment which expands only to the left 
https://codeforces.com//contest/1036/problem/G,216423,G,1036G,1036,G. Sources and Sinks,You are given an acyclic directed graph consisting of n vertices and m edges The graph contains no multiple edges and no self loops The vertex is called a if it has no incoming edges The vertex is called a if it has no outgoing edges These definitions imply that some vertices can be both source and sink The number of sources in the given graph is equal to the number of sinks in it and each of these numbers doesn t exceed 20 The following algorithm is applied to the graph if the graph has no sources and sinks then quit choose arbitrary source s arbitrary sink t add an edge from t to s to the graph and go to step 1 that operation pops s out of sources and t out of sinks Note that s and t may be the same vertex then a self loop is added At the end you check if the graph becomes strongly connected that is any vertex is reachable from any other vertex Your task is to check that the graph becomes strongly connected no matter the choice of sources and sinks on the second step of the algorithm ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=(1<<20);\nvoid build(){\n\n}\nint n, m, od[N], id[N];\nvector<int> v[N];\nint oid[N], iid[N], tot;\nvoid init(){\n  n=getint();\n  m=getint();\n  while(m--){\n    int ui=getint();\n    int vi=getint();\n    od[ui]++;\n    id[vi]++;\n    v[ui].push_back(vi);\n  }\n  int _oid=0, _iid=0;\n  for(int i=1; i<=n; i++){\n    if(od[i]==0) oid[i]=_oid++;\n    else oid[i]=-1;\n    if(id[i]==0) iid[i]=_iid++;\n    else iid[i]=-1;\n  }\n  tot=_oid;\n}\nconst int K=20;\nint to[K], tg[N], stmp;\nvoid go(int st, int now){\n  tg[now]=stmp;\n  if(oid[now] >= 0)\n    to[st]|=(1<<oid[now]);\n  for(int nxt: v[now]){\n    if(tg[nxt] == stmp) continue;\n    go(st, nxt);\n  }\n}\nint msk[1<<K], cb[1<<K];\nvoid solve(){\n  for(int i=1; i<=n; i++)\n    if(iid[i] >= 0){\n      ++stmp;\n      go(iid[i], i);\n    }\n  for(int i=1; i<(1<<tot); i++)\n    cb[i]=cb[i>>1]+(i&1);\n  bool win=false;\n  for(int i=1; i<(1<<tot) and not win; i++){\n    for(int j=0; j<tot; j++)\n      if((i >> j) & 1)\n        msk[i]=msk[i^(1<<j)]|to[j];\n    if(i < (1<<tot)-1){\n      if(cb[i] == cb[msk[i]])\n        win=true;\n    }\n  }\n  puts(win?""NO"":""YES"");\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']",,,"['bitmasks', 'brute force', 'dfs and similar']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Sources and Sinks.json,https://codeforces.com/blog/entry/61727,Since the graph is acyclic then for every vertex there exists a path to some sink and to every vertex there exists a path from some source So our problem can be reduced to the following check that after running our algorithm all vertices from the initial set of sources and sinks belong to the same strongly connected component Let be the number of sources or sinks in the initial graph First of all let s run DFS or any other graph traversal from every source to form a set of reachable sinks for every source This part of solution has complexity of If is some set of sources of the original graph let be the set of sinks such that every sink from is reachable from at least one source from It s easy to see that there exists some set such that and then the answer is if we connected the sinks from with the sources from then any sink not belonging to would be unreachable from any sink belonging to Checking every possible set can be done in or in Let s prove that there is no such set then the answer is Let be an arbitrary sink of the original graph Also if is some set of sinks let be the set of sources containing every source directly connected to some sink from We can use mathematical induction to prove that every source and every sink is reachable from in the resulting graph Initially we state that is reachable from quite obvious If there is a set of sinks reachable from then either and the whole graph is reachable from or the number of sinks reachable from is at least so some set of sinks is reachable from So in fact checking every possible subset of sources is enough 
https://codeforces.com//contest/1703/problem/A,1459215,A,1703A,1703,A. YES or YES ,There is a string s of length 3 consisting of uppercase and lowercase English letters Check if it is equal to without quotes where each letter can be in any case For example are all allowable ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""./debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""./input.txt""); ofstream cout(""output.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n    fstart;\n\n    int T; cin >> T;\n    while (T--) {\n        string s; cin >> s;\n        char ok = (s[0] == \'Y\' || s[0] == \'y\');\n        ok &= (s[1] == \'E\' || s[1] == \'e\');\n        ok &= (s[2] == \'s\' || s[2] == \'S\');\n        cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n\n\n    }\n\n    finish;\n}\n']",,,"['brute force', 'implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\A. YES or YES .json,https://codeforces.com//blog/entry/104786,You should implement what is written in the statement Here are three ways to do it Check that the first character is or check that the second character is or and check the third character is or Make an array storing all acceptable strings there are only and loop and see if any of the strings match the input Use some built in function like in C to make the string all lowercase and check if is equal to The complexity is per test case 
https://codeforces.com//contest/1805/problem/A,1861351,A,1805A,1805,A. We Need the Zero,There is an array a consisting of non negative integers You can choose an integer x and denote b i a i oplus x for all 1 le i le n where oplus denotes the bitwise XOR operation Is it possible to choose such a number x that the value of the expression b 1 oplus b 2 oplus ldots oplus b n equals 0 It can be shown that if a valid number x exists then there also exists x such that 0 le x 2 8 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(""YES"");\n\telse\n\t\tputs(""NO"");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(""yes"");\n\telse\n\t\tputs(""no"");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(""Yes"");\n\telse\n\t\tputs(""No"");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<\'0\'||c>\'9\')\n\t{\n\t\tif(c==\'-\')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>=\'0\'&&c<=\'9\')\n\t{\n\t\tx=x*10+c-\'0\';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar(\'-\'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+\'0\');\n//\tputchar(\'\\n\');\n}\ninline void fre()\n{\n\tfreopen("".in"",""r"",stdin);\n\tfreopen("".out"",""w"",stdout);\n}\nvoid work()\n{\n\tint n,s=0,x;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>x;\n\t\ts^=x;\n\t}\n\tif(s&&(~n&1))\n\t\tputs(""-1"");\n\telse\n\t\tcout<<s<<endl;\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n\tcases();\n//\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n']",,,"['bitmasks', 'brute force']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. We Need the Zero.json,https://codeforces.com//blog/entry/114644,Note that equals if is even or if is odd Then if the length of the array is odd you must print of the whole array And if the length is even we can t change the value of the expression with our operation It turns out that if of the whole array is we can output any number but otherwise there is no answer 
https://codeforces.com//contest/342/problem/B,3439,B,342B,342,B. Xenia and Spies,Xenia the vigorous detective faced foreign spies lined up in a row We ll consider the spies numbered from 1 to from left to right Spy has an important note He has to pass the note to spy Xenia interrogates the spies in several steps During one step the spy keeping the important note can pass the note to one of his neighbours in the row In other words if this spy s number is he can pass the note to another spy either or if or then the spy has only one neighbour Also during a step the spy can keep a note and not pass it to anyone But nothing is that easy During steps Xenia watches some spies attentively Specifically during step steps are numbered from 1 Xenia watches spies numbers Of course if during some step a spy is watched he can t do anything neither give the note nor take it from some other spy Otherwise Xenia reveals the spies cunning plot Nevertheless if the spy at the current step keeps the note Xenia sees nothing suspicious even if she watches him You ve got and Also you have the steps during which Xenia watches spies and which spies she is going to watch during each step Find the best way the spies should act in order to pass the note from spy to spy as quickly as possible in the minimum number of steps ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#define lson step << 1\n#define rson step << 1 | 1\n#define lowbit(x) (x & (-x))\n#define Key_value ch[ch[root][1]][0] \nusing namespace std;\ntypedef long long LL;\nconst int N = 500005;\nconst int inf = 1000000009;\nint n , m , s , f;\nint t[N] , l[N] , r[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n        // freopen (""output.txt"" , ""w"" , stdout);\n    #endif\n    cin >> n >> m >> s >> f;\n    for (int i = 0 ; i < m ; i ++) {\n        cin >> t[i] >> l[i] >> r[i];\n    }\n    int sgn = (f - s) > 0 ? 1 : -1;\n    for (int i = 1 , j = 0 ; ; i ++) {\n        if (s == f) break;\n        int nxt = s + sgn;\n        if (j < m && t[j] == i) {\n            if ((s >= l[j] && s <= r[j]) || (nxt >= l[j] && nxt <= r[j]))\n                putchar (\'X\');\n            else {\n                s = nxt;\n                if (sgn > 0) putchar (\'R\');\n                else putchar (\'L\');\n            }\n            j ++;\n        }\n        else {\n            s = nxt;\n            if (sgn > 0) putchar (\'R\');\n            else putchar (\'L\');\n        }\n    }\n    puts ("""");\n    return 0;\n}       \n\n']",,,"['brute force', 'greedy', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Xenia and Spies.json,https://codeforces.com/blog/entry/8800,The problem is solved by greedy algorithm We will pass the note only in correct direction Also if we can pass the note at the current moment of time we do it In other case we will hold it and don t give it to neighbors we can make this action at any moment of time Obviously this algorithm is correct You should only implement it carefully 
https://codeforces.com//contest/1729/problem/G,1538788,G,1729G,1729,G. Cut Substrings,You are given two non empty strings s and t consisting of Latin letters In one move you can choose an occurrence of the string t in the string s and replace it with dots Your task is to remove all occurrences of the string t in the string s in the minimum number of moves and also calculate how many sequences of moves of the minimum length exist Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string t in s begin differ For example the sets 1 2 3 and 1 2 4 are considered different the sets 2 4 6 and 2 6 too but sets 3 5 and 5 3 not For example let the string s and the string t We can remove all occurrences of the string t in 2 moves by cutting out the occurrences of the string t at the 3th and 9th positions In this case the string s is an example of the form It is also possible to cut occurrences of the string t at the 3th and 11th positions There are two different sequences of minimum length moves Since the answer can be large output it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\n\n\nstruct mint {\n    int x;\n    mint() : x(0) {}\n    mint(int x) : x((x % mod + mod) % mod) {}\n    mint operator -() const { return mint(0) - *this;}\n    mint operator ~() const { return mint(1) / *this;}\n    mint& operator +=(const mint& a) { if((x += a.x) >= mod) x -= mod; return *this;}\n    mint& operator -=(const mint& a) { if((x += mod - a.x) >= mod) x -= mod; return *this;}\n    mint& operator *=(const mint& a) { x = x * a.x % mod; return *this;}\n    mint& operator /=(const mint& a) { x = x * a.pow(mod-2).x % mod; return *this;}\n    mint operator +(const mint& a) const { return mint(*this) += a;}\n    mint operator -(const mint& a) const { return mint(*this) -= a;}\n    mint operator *(const mint& a) const { return mint(*this) *= a;}\n    mint operator /(const mint& a) const { return mint(*this) /= a;}\n    mint pow(int t) const { mint ret(1), pw = mint(*this); while(t){ if(t & 1) ret *= pw; pw *= pw; t /= 2;} return ret;}\n    bool operator <(const mint& a) const { return x < a.x;}\n    bool operator ==(const mint& a) const { return x == a.x;}\n    bool operator !=(const mint& a) const { return x != a.x;}\n    friend istream& operator >>(istream& is, mint& p) { return is >> p.x; }\n    friend ostream& operator <<(ostream& os, mint p){ return os << p.x; }\n};\n\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s, t;\n    cin >> s >> t;\n\n    int n = sz(s), m = sz(t);\n    \n    \n    si h;\n\n    fr(i,0,n-m)\n    {\n        if(s.substr(i, m) == t)\n        {\n            h.insert(i + 1);\n        }\n    }\n\n\n    if(!sz(h))\n    {\n        done(""0 1"");\n    }\n\n\n    vi dp(n + 1, infl);\n    vector<mint> ways(n + 1);\n    dp[0] = 0;\n    ways[0] = 1;\n\n\n    rep(i,0,n)\n    {\n        auto it = h.ub(i);\n\n        int lim = (it == h.end() ? n : min(n, (*it) + 2 * (m - 1)));\n\n        fr(j, i+m, lim)\n        {\n            if(!h.count(j - m + 1))\n                continue;\n\n            if(dp[j] > dp[i] + 1)\n            {\n                dp[j] = dp[i] + 1;\n                ways[j] = ways[i];\n            }\n            else if(dp[j] == dp[i] + 1)\n            {\n                ways[j] += ways[i];\n            }\n        }\n    }\n\n    int mn = infl;\n    mint cnt = 0;\n\n    int lim = (*h.rbegin());\n\n    fr(j,lim,n)\n    {\n        if(dp[j] < mn)\n        {\n            mn = dp[j];\n            cnt = ways[j]; \n        }\n        else if(dp[j] == mn)\n        {\n            cnt += ways[j];\n        }\n    }\n\n\n\n    cout << mn << \' \' << cnt << endl;\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']",,,"['combinatorics', 'dp', 'hashing', 'strings', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Cut Substrings.json,https://codeforces.com//blog/entry/106916,First find all occurrences of in as substrings This can be done using the prefix function To find the minimum number of times we need to cut substrings consider all indexes of occurrences Having considered the index of the occurrence we cut out the rightmost occurrence that intersects with it After that we find the leftmost occurrence that does not intersect with the cut one If it doesn t we end the loop The number of optimal sequences of moves will be calculated using dynamic programming For each occurrence we can count how many ways we can cut out all occurrences of in the suffix starting with this occurrence in the minimum number of moves Considering the occurrence we find the leftmost occurrence that does not intersect with it and then iterate over the occurrences with which we can remove it 
https://codeforces.com//contest/542/problem/C,27151,C,542C,542,C. Idempotent functions,Some time ago Leonid have known about defined on a set is such function that for any the formula holds Let s denote as the function applied times to the value More formally for each You are given some function Your task is to find minimum positive integer such that function is ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 210;\n\nint N;\nint arr[MAXN];\nll mdist, mult;\nbool bad[MAXN];\n\nll gcd (ll a, ll b)\n{\n    if (b == 0) return a;\n    return gcd (b, a % b);\n}\n\nll lcd (ll a, ll b)\n{\n    ll g = gcd (a, b);\n    return a / g * b;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    \n    cin >> N;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        arr[i]--;\n    }\n    \n    mdist = 0, mult = 1;\n    \n    for (int i = 0; i < N; i++)\n        bad[i] = false;\n    \n    for (int i = 0; i < N; i++)\n    {\n        int tot = 1, cloc = i;\n        for (int j = 0; j < N; j++)\n            cloc = arr[cloc];\n        \n        if (bad[cloc]) continue;\n        \n        int lval = cloc;\n        bad[cloc] = true;\n        cloc = arr[cloc];\n        while (lval != cloc)\n        {\n            //cout << cloc << "" 1\\n"";\n            bad[cloc] = true;\n            tot++;\n            cloc = arr[cloc];\n        }\n        \n        //cout << i << "" "" << tot << ""\\n"";\n        if (tot > 0)\n            mult = lcd (mult, (ll) tot);\n    }\n    \n    for (int i = 0; i < N; i++)\n    {\n        int tot = 0, cloc = i;\n        while (!bad[cloc])\n        {\n            //cout << cloc << "" 2\\n"";\n            tot++;\n            cloc = arr[cloc];\n        }\n        \n        mdist = max (mdist, (ll) tot);\n    }\n    \n    //cout << mdist << "" "" << mult << endl;\n    \n    ll res = (mdist / mult + 1) * mult;\n    while (res >= mdist + mult)\n        res -= mult;\n    while (res < mult)\n        res += mult;\n    \n    cout << res << ""\\n"";\n    return 0;\n}']",,,"['constructive algorithms', 'graphs', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Idempotent functions.json,https://codeforces.com//blog/entry/17697,In order to solve this task it s good to understand how does the graph corresponding the function from to itself looks Let s consider a graph on vertices with edges from vertex to the vertex Such graph always looks like a set of cycles with several trees leading to that cycles How should the graph look like for function to be the idempotent It s easy to see that in such graph all cycles should be of length and all vertex that are not cycles of length i e all not fixed points should immediatly lead to some fixed point So we should satisfy two conditions First all cycles should become of length in order to do that should be divisible by where are the lengths of all cycles Second all vertices not lying on cycles should become leading to the vertices lying on cycles In other words should be no less than the distance from any vertex to the cycle it goes into or that the same the length of pre period in the sequence So are task is about finding the smallest number divisible by that is no less than it is not hard at all Challenge What is the maximum possible answer for this task Answer first second 
https://codeforces.com//contest/1635/problem/D,1304250,D,1635D,1635,D. Infinite Set,You are given an array a consisting of n positive integers Let s consider an infinite integer set S which contains all integers x that satisfy at least one of the following conditions x a i for some 1 leq i leq n x 2y 1 and y is in S x 4y and y is in S For example if a 1 2 then the 10 smallest elements in S will be 1 2 3 4 5 7 8 9 11 12 Find the number of elements in S that are strictly smaller than 2 p Since this number may be too large print it modulo 10 9 7 ,"['// Problem: D. Infinite Set\n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=1e9+7;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nint a[1000003],val[1000003];\nset<int> vis;\nint f[1000003];\nsigned main()\n{\n\tint n=read(),m=read(),ans=0;\n\tfor(int i=1; i<=n; ++i) \n\t\tval[i]=read(),vis.insert(val[i]);\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tint q=val[i];\n\t\twhile(q)\n\t\t{\n\t\t\tif(q&1) q>>=1;\n\t\t\telse if(q&2) break;\n\t\t\telse q>>=2;\n\t\t\tif(vis.find(q)!=vis.end()) \n\t\t\t{\n\t\t\t\tvis.erase(val[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i:vis)\n\t{\n\t\tint q=0;\n\t\tint t=i;\n\t\twhile(t) ++q,t>>=1;\n\t\t++a[q];\n\t}\n\tfor(int i=1; i<=m; ++i) \n\t\ta[i+1]=(a[i+1]+a[i])%p,a[i+2]=(a[i+2]+a[i])%p,ans=(ans+a[i])%p;\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}']",,,"['bitmasks', 'dp', 'math', 'matrices', 'number theory', 'strings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Infinite Set.json,https://codeforces.com//blog/entry/100153,First of all let s discuss the problem where and For every integer there is exactly one integer satisfying Let s define Then it s quite easy to find out and This observation leads to a simple dynamic programming solution let be the number of integer where and The base case is and the transition is After computing the array the final answer will be For the general version of the problem in order not to compute the same number two or more times we need to delete all useless numbers A number is called useless if there exists an index such that can generate after a series of operations setting to or After the deletion we can simply do the same thing above only changing the transition a little bit where number of satisfying The final problem is how to find all the useless numbers For every integer there are at most possible parents that can generate it Also such parent must be smaller than So let s sort the array in increasing order Maintain all useful numbers in a set and for each we will check whether its parent exists or not Once we confirm that its parent doesn t exist we will append it to the set of useful numbers This works in Total Complexity 
https://codeforces.com//contest/1333/problem/E,586757,E,1333E,1333,E. Road to 1600,Egor wants to achieve a rating of 1600 points on the well known chess portal ChessForces and he needs your help Before you start solving the problem Egor wants to remind you how the chess pieces move Chess moves along straight lines up and down left and right as many squares as it wants And when it wants it can stop The walks in all directions vertically and diagonally at any distance You can see the examples below To reach the goal Egor should research the next topic There is an N times N board Each cell of the board has a number from 1 to N 2 in it and numbers in all cells are distinct In the beginning some chess figure stands in the cell with the number 1 Note that this cell is already considered as visited After that every move is determined by the following rules Among all yet cells to which the figure can get in one move it goes to the cell that has number If all accessible cells were already visited and some cells are not yet visited then the figure is teleported to the not visited cell that has minimal number If this step happens the piece pays a fee of 1 If all cells are already visited the process is stopped Egor should find an N times N board on which the rook pays than the queen during the round with this numbering Help him to find such N times N numbered board or tell that it doesn t exist ,"['#include <iostream>\n\nusing namespace std;\n\nint const nmax = 500;\nint v[1 + nmax][1 + nmax];\nint sol[16] = {4, 3, 6, 12,7, 5, 9, 15,14, 1, 11, 10, 13, 8, 16, 2};\n\n/*\n124\n538\n967\n*/\n\nint main()\n{\n  int n;\n  cin >> n;\n  if(n <= 2)\n    cout << -1;\n  else if(n == 3){\n    cout << 1 << "" "" << 2 << "" "" << 4 << \'\\n\';\n    cout << 5 << "" "" << 3 << "" "" << 8 << \'\\n\';\n    cout << 9 << "" "" << 6 << "" "" << 7 << \'\\n\';\n  } else {\n    int ptr = 0;\n    int ptr2 = 0;\n    if(n % 2 == 0)\n      for(int i = n - 3; i <= n; i++)\n        for(int j = 1; j <= 4; j++)\n          v[i][j] = 1 * (n * n - 16) + sol[ptr++];\n    else\n      for(int i = n; n - 3 <= i; i--)\n        for(int j = 4; 1 <= j; j--)\n          v[i][j] = 1 * (n * n - 16) + sol[ptr++];\n\n    for(int i = n; 4 <= i; i--){\n      if((n - i) % 2 == 0){\n        for(int j = 1;j <= n; j++)\n          if(v[n - i + 1][j] == 0)\n            v[n - i + 1][j] = ++ ptr2;\n        for(int i2 = 1; i2 <= n; i2++)\n          if(v[i2][i] == 0)\n            v[i2][i] = ++ptr2;\n      } else {\n        for(int i2 = n; 1 <= i2; i2--)\n          if(v[i2][i] == 0)\n            v[i2][i] = ++ptr2;\n        for(int j = n; 1 <= j; j--)\n          if(v[n - i + 1][j] == 0)\n            v[n - i + 1][j] = ++ ptr2;\n      }\n    }\n\n    if(n % 2 == 0)\n      swap(v[n - 4][1], v[n - 4][2]);\n    else if(n % 2 == 1)\n      swap(v[n][5], v[n - 2][5]);\n\n    for(int i = 1;i <= n; i++) {\n      for(int j = 1;j <= n; j++)\n        cout << v[i][j] << "" "";\n      cout << \'\\n\';\n    }\n  }\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Road to 1600.json,https://codeforces.com//blog/entry/75802,First of all notice that there are no such boards for Then you can find an example for by yourself or with counting all cases with program One of possible examples I find it using paper pencil and my hands For large we can walk by spiral like snake to the case Rook and Queen first going in a spiral and arrive to case It can be used any of such spiral not just this one Final time complexity 
https://codeforces.com//contest/1034/problem/D,222953,D,1034D,1034,D. Intervals of Intervals,Little D is a friend of Little C who loves intervals very much instead of number 3 Now he has n intervals on the number axis the i th of which is a i b i Only the n intervals can not satisfy him He defines the value of an l r 1 leq l leq r leq n l and r are both integers as the total length of the union of intervals from the l th to the r th He wants to select exactly k different such that the sum of their values is maximal Please help him calculate the maximal sum ,"['#include<cstdio>\n#include<algorithm>\n#include<set>\nconst int maxn=300010;\nint n,k,a[maxn],b[maxn];\nstruct event{int i,t,x;bool operator<(const event&e)const{return x<e.x||x==e.x&&t<e.t;}}ev[maxn*4],*ne=ev;\nstruct seg{int i,l,r;bool operator<(const seg&s)const{return l<s.l;}};\nint rt[maxn],add[maxn],lt[maxn];\nlong long rs[maxn];\nvoid cmin(int&a,int b){b<a?a=b:1;}\nvoid cmax(int&a,int b){b>a?a=b:1;}\nlong long chk(int L){\n\tfor(int i=0;i<=n;i++)add[i]=0;\n\tevent*e=ev;\n\tlong long c=0;\n\tfor(int i=n,j=n-1,val=0;i--;){\n\t\tfor(;e<ne&&e->i==i;e++)add[e->t]+=e->x,j>=e->t?val+=e->x:1;\n\t\twhile(j&&val-add[j]>=L)val-=add[j--];\n\t\trt[i]=val<L?n+1:j+1;\n\t\tc+=n-rt[i]+1;\n\t}\n\treturn c;\n}\nstd::set<seg>A;\nstd::set<seg>::iterator spl(int x){\n\tstd::set<seg>::iterator it=A.lower_bound((seg){0,x,x});--it;\n\tif(it->l==x)return it;\n\tseg s=*it;A.erase(it);\n\tA.insert((seg){s.i,s.l,x});\n\treturn A.insert((seg){s.i,x,s.r}).first;\n}\nint main(){\n\tscanf(""%d%d"",&n,&k);\n\tfor(int i=0;i<n;i++)scanf(""%d%d"",a+i,b+i);\n\tA.insert((seg){n,0,1000000001});\n\tfor(int i=n;i--;){\n\t\tstd::set<seg>::iterator ir=spl(b[i]),il=spl(a[i]),it;\n\t\twhile(il!=ir){\n\t\t\tit=il++;\n\t\t\t*ne++=(event){i,it->i,it->l-it->r};\n\t\t\tA.erase(it);\n\t\t}\n\t\t*ne++=(event){i,i,b[i]-a[i]}; \n\t\tA.insert((seg){i,a[i],b[i]});\n\t}\n\tint L=0,R=1000000001,mid;\n\twhile(R-L>1)chk(mid=L+R>>1)>k?L=mid:R=mid;\n\tlong long K=chk(R),cur=0,ans=0,tmp;\n\tfor(int i=0;i<n;i++)rs[i+1]=rs[i]+rt[i];\n\tfor(int i=0,j=0;j<=n+1;j++){\n\t\twhile(i<n&&rt[i]<j)i++;\n\t\tlt[j]=i;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tev[i*2]=(event){i,0,a[i]};\n\t\tev[i*2+1]=(event){i,1,b[i]};\n\t}\n\tstd::sort(ev,ev+n*2);\n\tstd::set<int>B;\n\tB.insert(-1);\n\tB.insert(n);\n\tfor(int i=0;i+1<n*2;i++){\n\t\tstd::set<int>::iterator it=ev[i].t?B.find(ev[i].i):B.insert(ev[i].i).first;\n\t\tint l=1+*--it;++it;\n\t\tint m=1+ev[i].i,r=1+*++it;--it;\n\t\tint x=lt[m],y=lt[r];\n\t\tcmax(x,l);cmax(y,l);\n\t\tcmin(x,m);cmin(y,m);\n\t\ttmp=(x-l)*1ll*(r-m)-rs[y]+rs[x]+(y-x)*1ll*r;\n\t\tev[i].t?cur-=tmp:cur+=tmp;\n\t\tans+=cur*(ev[i+1].x-ev[i].x);\n\t\tif(ev[i].t)B.erase(it);\n\t}\n\tprintf(""%lld\\n"",ans+(k-K)*L);\n}\n']",,,"['binary search', 'data structures', 'two pointers']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Intervals of Intervals.json,https://codeforces.com//blog/entry/61993,First we consider how to calculate the value of an interval of intervals We can consider intervals in order from to and for each position on the axis maintain a timestamp denoting the last time it was covered When the th interval is taken into consideration the timestamps for positions should all be updated to Right after that the desired answer of a query is the number of positions whose timestamp is not smaller than We would like to for each keep the desired answer for every To achieve this when we change the timestamps of positions from to the answers for in should each be increased by To do it fast we can merge consecutive positions with the same timestamp into a segment and use a balanced tree e g std set to maintain the segments new segments appear when adding an interval and when a segment is completely covered by later intervals it will be deleted By amortized analysis the total number of balanced tree operations and the number of range modifications of answers see above are both We spend time in this part Now we consider how to get the answer It s obvious that we will select the largest values We can use binary search to find the minimum we finally select i e we should for several integers count how many values of are not smaller than and count the sum of these values by the way to get the answer For each we will select all s such that their interval of intervals values is not smaller than As the value of is not smaller than or it s obvious that all s smaller than an integer will be taken and will be not smaller than Now we can iterate from to maintaining the sum of values of and the value of by maintaining the difference between the answers for and in this way we carry out a range increment in time Similar to the sliding window method we try to increase when changes to Therefore we spend time for each we check with Summing everything up the total time complexity of this problem is 
https://codeforces.com//contest/1750/problem/D,1626960,D,1750D,1750,D. Count GCD,You are given two integers n and m and an array a of n integers For each 1 le i le n it holds that 1 le a i le m Your task is to count the number of different arrays b of length n such that 1 le b i le m for each 1 le i le n and gcd b 1 b 2 b 3 b i a i for each 1 le i le n Here gcd a 1 a 2 dots a i denotes the greatest common divisor GCD of integers a 1 a 2 ldots a i Since this number can be too large print it modulo 998 244 353 ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don\'t silently convert to int\n\tmint() : v(0) {}\n\tmint(ll _v) {\n\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD;\n\t}\n\tbool operator==(const mint &o) const { return v == o.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend void re(mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = mint(x);\n\t}\n\tfriend str ts(mint a) { return ts(a.v); }\n\n\tmint &operator+=(const mint &o) {\n\t\tif ((v += o.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &o) {\n\t\tif ((v -= o.v) < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &o) {\n\t\tv = int((ll)v * o.v % MOD);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\n\nusing mi = mint<MOD, 5>; // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi, mi>;\nusing vpmi = V<pmi>;\n\nV<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, vmi(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\n/**\n * Description: Factors integers.\n * Time: O(\\sqrt N)\n * Source: Own\n * Verification: https://csacademy.com/contest/ceoi-2018-day-2/task/toys-big/\n */\n\nnamespace factorBasic {\ntemplate <class T> vector<pair<T, int>> factor(T x) {\n\tvector<pair<T, int>> pri;\n\tfor (T i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) {\n\t\t\tint t = 0;\n\t\t\twhile (x % i == 0) x /= i, t++;\n\t\t\tpri.pb({i, t});\n\t\t}\n\tif (x > 1) pri.pb({x, 1});\n\treturn pri;\n}\n/* Note:\n * number of operations needed s.t.\n *\t\t\t\t  phi(phi(...phi(n)...))=1\n * is O(log n).\n * Euler\'s theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1\n */\nll phi(ll x) {\n\teach(a, factor(x)) x -= x / a.f;\n\treturn x;\n}\ntemplate <class T>\nvoid tour(vector<pair<T, int>> &v, vector<T> &V, int ind, T cur) {\n\tif (ind == sz(v)) V.pb(cur);\n\telse {\n\t\tT mul = 1;\n\t\tF0R(i, v[ind].s + 1) {\n\t\t\ttour(v, V, ind + 1, cur * mul);\n\t\t\tmul *= v[ind].f;\n\t\t}\n\t}\n}\ntemplate <class T> vector<T> getDivi(T x) {\n\tauto v = factor(x);\n\tvector<T> V;\n\ttour(v, V, 0, (T)1);\n\tsort(all(V));\n\treturn V;\n}\n} // namespace factorBasic\n\nusing namespace factorBasic;\n\nmi count_prime(int up, int num) {\n\tauto f = factor(num);\n\tmi ans = 0;\n\tF0R(i, 1 << sz(f)) {\n\t\tint cur = up;\n\t\tint sgn = 1;\n\t\tF0R(j, sz(f)) if (i & (1 << j)) cur /= f[j].f, sgn *= -1;\n\t\tans += cur * sgn;\n\t}\n\treturn ans;\n}\n\nvoid solve(int tc) {\n\tints(N, M);\n\tvi A(N);\n\tre(A);\n\tmi prod = 1;\n\tFOR(i, 1, sz(A)) {\n\t\tif (A[i - 1] % A[i] != 0) {\n\t\t\tps(0);\n\t\t\treturn;\n\t\t}\n\t\tprod *= count_prime(M / A[i], A[i - 1] / A[i]);\n\t}\n\tps(prod);\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']",,,"['combinatorics', 'math', 'number theory']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Count GCD.json,https://codeforces.com//blog/entry/108504,SolutionWe can notice that if for some is not divisible by then the answer is Else note that all the prime factors of are also prime factors in all the other values Thus after factorizing we can quickly factorize every other value Now let s find the number of ways we can select for every The answer will be the product of these values since each position is independent It s easy to see that there is only one way to select that is Now for we need to find the number of values such that Let we can rephrase as which is also equivalent to We have thus the task reduces to a simple principle of inclusion exclusion problem Time complexity per testcase 
https://codeforces.com//contest/1690/problem/A,1423049,A,1690A,1690,A. Print a Pedestal  Codeforces logo  ,Given the integer n the number of available blocks You must use blocks to build a The consists of 3 platforms for 2 nd 1 st and 3 rd places respectively The platform for the 1 st place must be higher than for the 2 nd place and the platform for the 2 nd place must be higher than for the 3 rd place Also the height of each platform must be greater than zero that is each platform must contain at least one block Among all possible pedestals of n blocks deduce one such that the platform height for the 1 st place as possible If there are several of them output any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1\'000\'000\'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nvoid solve(){\n    int n;\n    cin >> n;\n    int on = n;\n    n -= 3 * ((n - 3) / 3);\n    vector<int> ans = {inf, inf, inf};\n    for (int f = 0; f <= n; f++){\n        for (int s = 0; s <= n; s++){\n            for (int t = 0; t <= n; t++){\n                if (f + s + t != n){\n                    continue;\n                }\n                vector<int> a(3);\n                a[0] = a[1] = a[2] = (on - 3) / 3;\n                a[0] += f, a[1] += s, a[2] += t;\n                if (a[1] > a[0] && a[0] > a[2] && a[1] < ans[1]){\n                    ans = a;\n                }\n            }\n        }\n    }\n    cout << ans[0] << "" "" << ans[1] << "" "" << ans[2] << ""\\n"";\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}']",,,"['constructive algorithms', 'greedy']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Print a Pedestal  Codeforces logo  .json,https://codeforces.com//blog/entry/103658,In the constraints the problem can be solved by brute force we will go through the value for the height for the first place and then select suitable values for and Since we divide the remaining blocks equally between and If it turns out that then we try to decrease by and increase by 1 If we get the right answer output the heights and stop the process We will go through the value of in order of increasing 
https://codeforces.com//contest/1775/problem/E,1730877,E,1775E,1775,E. The Human Equation,Petya and his friend the robot Petya went to BFDMONCON where the costume contest is taking place today While walking through the festival they came across a scientific stand named after Professor Oak and Golfball where they were asked to solve an interesting problem Given a sequence of numbers a 1 a 2 dots a n you can perform several operations on this sequence Each operation should look as follows You choose some subsequence dagger Then you call all the numbers at odd positions in this subsequence and all the numbers at even positions in this subsequence In this case only the position of the number in the subsequence is taken into account not in the original sequence For example consider the sequence 1 4 2 8 5 7 3 6 9 and its subsequence shown in bold 1 mathbf 4 mathbf 2 8 mathbf 5 7 3 mathbf 6 9 Then the numbers 4 and 5 are and the numbers 2 and 6 are After that you can do one of the following add 1 to all northern numbers and subtract 1 from all south numbers or add 1 to all southern numbers and subtract 1 from all northern numbers Thus from the sequence 1 mathbf 4 mathbf 2 8 mathbf 5 7 3 mathbf 6 9 if you choose the subsequence shown in bold you can get either 1 mathbf 5 mathbf 1 8 mathbf 6 7 3 mathbf 5 9 or 1 mathbf 3 mathbf 3 8 mathbf 4 7 3 mathbf 7 9 Then the operation ends Note also that all operations are independent i e the numbers are no longer called or when one operation ends It is necessary to turn all the numbers of the sequence into zeros using the operations described above Since there is very little time left before the costume contest the friends want to know what is the minimum number of operations required for this The friends were unable to solve this problem so can you help them dagger A sequence c is a subsequence of a sequence d if c can be obtained from d by the deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n;\nint arr[200005];\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tcin>>n;\n\t\trep(x,1,n+1) cin>>arr[x];\n\t\t\n\t\tint add=0,sub=0;\n\t\trep(x,1,n+1){\n\t\t\tif (arr[x]>0){\n\t\t\t\tadd=max(add,arr[x]);\n\t\t\t\tadd-=arr[x];\n\t\t\t\tsub+=arr[x];\n\t\t\t}\n\t\t\tif (arr[x]<0){\n\t\t\t\tarr[x]=-arr[x];\n\t\t\t\tsub=max(sub,arr[x]);\n\t\t\t\tsub-=arr[x];\n\t\t\t\tadd+=arr[x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<add+sub<<endl;\n\t}\n}\n']",,,"['greedy', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The Human Equation.json,https://codeforces.com//blog/entry/111286,Let s calculate an array of prefix sums What do the operations look like in this case If we calculate the array of prefix sums we ll see that the operations now look like add 1 on a subsequence or take away 1 on a subsequence Why If we take the indices and and apply our operation to them i e and it will appear that we added on the segment in the prefix sums array We still need to make the array all zeros How We will add to all elements that are less than zero then subtract from all elements that are greater than From this we get that the answer is the difference between the maximum and minimum prefix sums 
https://codeforces.com//contest/1986/problem/G1,2714659,G1,1986G1,1986,G1. Permutation Problem  Simple Version ,You are given a permutation p of length n Calculate the number of index pairs 1 leq i j leq n such that p i cdot p j is divisible by i cdot j without remainder A permutation is a sequence of n integers where each integer from 1 to n occurs exactly once For example 1 3 5 2 1 4 1 3 2 are permutations while 2 3 2 4 3 1 0 are not ,"['#include<bits/stdc++.h>\xa0\xa0#define pb push_back#define fi first#define se secondusing namespace std;using ll = long long;using ld = long double;using ull = unsigned long long;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int maxN = 5e5 + 5;const int mod = 1e9 + 7;const ll oo = 1e18;int n, a[maxN];pair<int, int> b[maxN];vector<int> vc[maxN], vc1[maxN], divs[maxN];int mp[maxN];void prep(){    for(int i=1; i<maxN; i++)        for(int j=i; j<maxN; j+=i)            divs[j].pb(i);}void ReadInput(){    cin >> n;    for(int i=1; i<=n; i++)        cin >> a[i];}void Solve(){    for(int i=1; i<=n; i++)    {        int t = __gcd(a[i], i);        b[i] = {a[i] / t, i / t};    }\xa0    sort(b + 1, b + n + 1);    for(int i=1; i<=n; i++)    {        vc[b[i].fi].pb(b[i].se);        vc1[b[i].se].pb(b[i].fi);    }    for(int i=1; i<=n; i++)    {        sort(vc[i].begin(), vc[i].end());        sort(vc1[i].begin(), vc1[i].end());    }    ll res = 0;    for(int i=1; i<=n; i++)    {        if(vc1[i].empty()) continue;        for(int v : vc1[i])        {            for(int x : divs[v])                mp[x]++;        }        for(int j=i; j<=n; j+=i)        {            for(int v : vc[j])                res += mp[v];        }        for(int v : vc1[i])        {            for(int x : divs[v])                mp[x] = 0;        }    }    for(int i=1; i<=n; i++)    {        if(b[i].se == 1) res--;    }    cout << res / 2 << \'\\n\';    for(int i=1; i<=n; i++)    {        vc[b[i].fi].clear();        vc1[b[i].se].clear();    }}#define taskname ""sol""int32_t main(){    if (fopen(taskname "".inp"", ""r""))    {        freopen(taskname "".inp"", ""r"", stdin);       // freopen(taskname "".out"", ""w"", stdout);    }    ios_base::sync_with_stdio(false);    cin.tie(nullptr);    prep();    int T = 1;    cin >> T;    for(int itest=1; itest<=T; itest++)    {        ReadInput();        Solve();    }}']",,,"['binary search', 'brute force', 'combinatorics', 'data structures', 'math', 'number theory']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G1. Permutation Problem  Simple Version .json,https://codeforces.com//blog/entry/130783,Let ai pigcd i pi bi igcd i pi Notice that we want to calculate the number of index pairs i j such that aj is divisible by bi ai is divisible by bj Let s iterate through the values of bi from 1 to n note that we are not fixing the element i but rather fixing the value of bi Now we know that we are interested in all aj bi k for some positive integer k Let s iterate through all such possible aj and then iterate through all pairs with that value of aj Add all suitable bj to the count array Now for a fixed bi and the constructed count array for it iterate through all ai that exist with this bi We can iterate through all divisors of ai and simply add their count from the count array to the answer because Only those pairs for which aj is divisible by bi are considered in the count array so we have accounted for the first condition We have accounted for the second condition when iterating through the divisors of ai If the above is implemented correctly a solution can be obtained in O nlogn For this we will need to pre calculate all divisors for each i from 1 to n We can iterate through i and mark it as a divisor for all numbers of the form k i Also everything written above works in O nlogn because the array a was obtained from a permutation by dividing some elements so the total number of divisors of all elements in a as well as the array b is no more than the total number of divisors of numbers from 1 to n And the total number of divisors of numbers from 1 to n is at most i 1nni O nlogn 
https://codeforces.com//contest/558/problem/B,31487,B,558B,558,B. Amr and The Large Array,Amr has got a large array of size Amr doesn t like large arrays so he intends to make it smaller Amr doesn t care about anything in the array except the beauty of it The beauty of the array is defined to be the maximum number of times that some number occurs in this array He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array Help Amr by choosing the smallest subsegment possible ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\nint i, j, k, n, m, x, cnt[N], l[N], r[N], ans, le, ri, aaa = inf;;\n\nint main(){\n\t\n\tscanf(""%d"",&n);\n\n\tmemset(l, 12, sizeof l);\n\n\tFOR(i,1,n) {\n\t\t\n\t\tscanf(""%d"",&x);\n\n\t\tl[x] = min(l[x], i);\n\t\tr[x] = max(r[x], i);\n\t\tcnt[x]++;\n\t\tans = max(cnt[x], ans);\n\n\t}\n\n\tFOR(i,1,N-1)\n\t\tif(cnt[i] == ans && r[i]-l[i]+1 < aaa) {\n\t\t\taaa = r[i] - l[i] + 1;\n\t\t\tle = l[i]; \n\t\t\tri = r[i];\n\t\t}\n\t\n\tcout << le << \' \' << ri << endl;\n\n    return 0;\n}\n']",,,['implementation'],1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Amr and The Large Array.json,https://codeforces.com//blog/entry/19212,First observation in this problem is that if the subarray chosen has as a value that has the maximum number of occurrences among other elements then the subarray should be Because if the subarray begins or ends with another element we can delete it and make the subarray smaller So Let s save for every distinct element in the array three numbers the smallest index such that the largest index such that and the number of times it appears in the array And between all the elements that has maximum number of occurrences we want to minimize i e the size of the subarray Time complexity Implementation 
https://codeforces.com//contest/1528/problem/A,994162,A,1528A,1528,A. Parsa s Humongous Tree,Parsa has a humongous tree on n vertices On each vertex v he has written two integers l v and r v To make Parsa s tree look even more majestic Nima wants to assign a number a v l v le a v le r v to each vertex v such that the beauty of Parsa s tree is maximized Nima s sense of the beauty is rather bizarre He defines the beauty of the tree as the sum of a u a v over all edges u v of the tree Since Parsa s tree is too large Nima can t maximize its beauty on his own Your task is to find the possible beauty for Parsa s tree ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nusing ll = int64_t;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > edges(n);\n\tvector<ll> l(n), r(n);\n\tfor(int i = 0; i < n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tpair<ll, ll> res = y_combinator(\n\t\t[&](auto self, int v, int p) -> pair<ll, ll> {\n\t\t\tll lcost = 0;\n\t\t\tll rcost = 0;\n\t\t\tfor(int w : edges[v]){\n\t\t\t\tif(w == p) continue;\n\t\t\t\tauto [a, b] = self(w, v);\n\t\t\t\tlcost += max(abs(l[v] - l[w]) + a, abs(l[v] - r[w]) + b);\n\t\t\t\trcost += max(abs(r[v] - l[w]) + a, abs(r[v] - r[w]) + b);\n\t\t\t}\n\t\t\treturn {lcost, rcost};\n\t\t}\n\t)(0, -1);\n\tcout << max(res.first, res.second) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]",,,"['dfs and similar', 'divide and conquer', 'dp', 'greedy', 'trees']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Parsa s Humongous Tree.json,https://codeforces.com//blog/entry/91058,The solution is based on the fact that an optimal assignment for exists such that for each vertex Proving this fact isn t hard pick any assignment for Assume is a vertex in this assignment such that Let be the number of vertices adjacent to such that Let be the number of vertices adjacent to such that Consider the following cases In this case we can decrease to and get a better result In this case we can increase to and get a better result In this case changing to or will either increase or not change the beauty of the tree Based on this fact we can use dynamic programming to find the answer Define as the maximum beauty of s subtree if is equal to Similarly define as the maximum beauty of s subtree if is equal to is calculated based on s children for each of s children such as we add s contribution to The transitions are It s clear that the answer is equal to complexity 
https://codeforces.com//contest/1895/problem/G,2305461,G,1895G,1895,"G. Two Characters, Two Colors",You are given a string consisting of characters and or You have to paint every character of this string into one of two colors red or blue If you paint the i th character red you get r i coins If you paint it blue you get b i coins After coloring the string you remove every character from it and count the number of inversions in the resulting string i e the number of pairs of characters such that the left character in the pair is and the right character in the pair is For each inversion you have to pay 1 coin What is the maximum number of coins you can earn ,"['#pragma region Macros\n#ifdef noimi\n#include ""my_template.hpp""\n#else\n\n#include <immintrin.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <variant>\n\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl \'\\n\'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < (n); ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= (b); i -= (c))\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define setbits(j, n) for(ll iiiii = (n), j = lowbit(iiiii); iiiii; iiiii ^= 1 << j, j = lowbit(iiiii))\n#define perm(v) for(bool permrepflag = true; (permrepflag ? exchange(permrepflag, false) : next_permutation(all(v)));)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define lbg(c, x) distance((c).begin(), lower_bound(all(c), (x), greater{}))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define ubg(c, x) distance((c).begin(), upper_bound(all(c), (x), greater{}))\n#define rng(v, l, r) v.begin() + (l), v.begin() + (r)\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {""NO"", ""YES""};\nconst string YesNo[2] = {""No"", ""Yes""};\nconst string yesno[2] = {""no"", ""yes""};\nconst string firstsecond[2] = {""second"", ""first""};\nconst string FirstSecond[2] = {""Second"", ""First""};\nconst string possiblestr[2] = {""impossible"", ""possible""};\nconst string Possiblestr[2] = {""Impossible"", ""Possible""};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\nvoid Possible(bool t = 1) { cout << Possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define INTd(...)                                                                                                                                              \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN2(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define LLd(...)                                                                                                                                               \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN2(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VECd(type, name, size)                                                                                                                                 \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN2(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC2d(type, name1, name2, size)                                                                                                                        \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN2(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VEC3d(type, name1, name2, name3, size)                                                                                                                 \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN2(name1[i], name2[i], name3[i])\n#define VEC4(type, name1, name2, name3, name4, size)                                                                                                           \\\n    vector<type> name1(size), name2(size), name3(size), name4(size);                                                                                           \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i]);\n#define VEC4d(type, name1, name2, name3, name4, size)                                                                                                          \\\n    vector<type> name1(size), name2(size), name3(size), name4(size);                                                                                           \\\n    for(int i = 0; i < size; i++) IN2(name1[i], name2[i], name3[i], name4[i]);\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define VVd(type, name, h, w)                                                                                                                                  \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN2(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\nvoid IN2() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class Head, class... Tail> void IN2(Head &head, Tail &...tail) {\n    scan(head);\n    --head;\n    IN2(tail...);\n}\n\ntemplate <int p = -1> void pat() {}\ntemplate <int p = -1, class Head, class... Tail> void pat(Head &h, Tail &...tail) {\n    h += p;\n    pat<p>(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <typename T, typename S, typename U> U bigmul(const T &x, const S &y, const U &lim) { // clamp(x * y, -lim, lim)\n    if(x < 0 and y < 0) return bigmul(-x, -y, lim);\n    if(x < 0) return -bigmul(-x, y, lim);\n    if(y < 0) return -bigmul(x, -y, lim);\n    return y == 0 or x <= lim / y ? x * y : lim;\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\n\ntemplate <typename S> void rearrange(const vector<S> &id) {}\ntemplate <typename S, typename T> void rearrange_exec(const vector<S> &id, vector<T> &v) {\n    vector<T> w(v.size());\n    rep(i, si(id)) w[i] = v[id[i]];\n    v.swap(w);\n}\n// 並び替える順番, 並び替える vector 達\ntemplate <typename S, typename Head, typename... Tail> void rearrange(const vector<S> &id, Head &a, Tail &...tail) {\n    rearrange_exec(id, a);\n    rearrange(id, tail...);\n}\n\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\ntemplate <typename T> void zeta_supersetsum(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b] += f[b | i];\n}\n\ntemplate <typename T> void zeta_subsetsum(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b | i] += f[b];\n}\ntemplate <typename T> void mobius_subset(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b] -= f[b | i];\n}\ntemplate <typename T> void mobius_superset(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b | i] -= f[b];\n}\n// 反時計周りに 90 度回転\ntemplate <typename T> void rot(vector<vector<T>> &v) {\n    if(empty(v)) return;\n    int n = v.size(), m = v[0].size();\n    vector<vector<T>> res(m, vector<T>(n));\n    rep(i, n) rep(j, m) res[m - 1 - j][i] = v[i][j];\n    v.swap(res);\n}\n\nvector<int> counter(const vector<int> &v, int max_num = -1) {\n    if(max_num == -1) max_num = MAX(v);\n    vector<int> res(max_num + 1);\n    fore(e, v) res[e]++;\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\ntemplate <class T, class S> bool inc(const T &x, const pair<S, S> &p) { return p.first <= x and x < p.second; }\n\n// 便利関数\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\nconstexpr ll tri(ll n) { return n * (n + 1) / 2; }\n// l + ... + r\nconstexpr ll tri(ll l, ll r) { return (l + r) * (r - l + 1) / 2; }\nll max(int x, ll y) { return max((ll)x, y); }\nll max(ll x, int y) { return max(x, (ll)y); }\nint min(int x, ll y) { return min((ll)x, y); }\nint min(ll x, int y) { return min(x, (ll)y); }\n// bit 演算系\n#define bit(i) (1LL << i)       // (1 << i)\n#define test(b, i) (b >> i & 1) // b の i bit 目が立っているか\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nstatic inline uint64_t popcount64(uint64_t x) {\n    uint64_t m1 = 0x5555555555555555ll;\n    uint64_t m2 = 0x3333333333333333ll;\n    uint64_t m4 = 0x0F0F0F0F0F0F0F0Fll;\n    uint64_t h01 = 0x0101010101010101ll;\n\n    x -= (x >> 1) & m1;\n    x = (x & m2) + ((x >> 2) & m2);\n    x = (x + (x >> 4)) & m4;\n\n    return (x * h01) >> 56;\n}\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x) { return pair<T, S>(-x.first, -x.second); }\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <class T> vector<T> &operator++(vector<T> &v) {\n    fore(e, v) e++;\n    return v;\n}\ntemplate <class T> vector<T> operator++(vector<T> &v, int) {\n    auto res = v;\n    fore(e, v) e++;\n    return res;\n}\ntemplate <class T> vector<T> &operator--(vector<T> &v) {\n    fore(e, v) e--;\n    return v;\n}\ntemplate <class T> vector<T> operator--(vector<T> &v, int) {\n    auto res = v;\n    fore(e, v) e--;\n    return res;\n}\ntemplate <class T> void connect(vector<T> &l, const vector<T> &r) { fore(e, r) l.eb(e); }\ntemplate <class T> vector<T> operator+(const vector<T> &l, const vector<T> &r) {\n    vector<T> res(max(si(l), si(r)));\n    rep(i, si(l)) res[i] += l[i];\n    rep(i, si(r)) res[i] += r[i];\n    return res;\n}\ntemplate <class T> vector<T> operator-(const vector<T> &l, const vector<T> &r) {\n    vector<T> res(max(si(l), si(r)));\n    rep(i, si(l)) res[i] += l[i];\n    rep(i, si(r)) res[i] -= r[i];\n    return res;\n}\ntemplate <class T> vector<T> &operator+=(const vector<T> &l, const vector<T> &r) {\n    if(si(l) < si(r)) l.resize(si(r));\n    rep(i, si(r)) l[i] += r[i];\n    return l;\n}\ntemplate <class T> vector<T> &operator-=(const vector<T> &l, const vector<T> &r) {\n    if(si(l) < si(r)) l.resize(si(r));\n    rep(i, si(r)) l[i] -= r[i];\n    return l;\n}\ntemplate <class T> vector<T> &operator+=(vector<T> &v, const T &x) {\n    fore(e, v) e += x;\n    return v;\n}\ntemplate <class T> vector<T> &operator-=(vector<T> &v, const T &x) {\n    fore(e, v) e -= x;\n    return v;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, const edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\ntemplate <typename T = int> Edges<T> read_edges(int m, bool weighted = false) {\n    Edges<T> res;\n    res.reserve(m);\n    for(int i = 0; i < m; i++) {\n        int u, v, c = 0;\n        scan(u), scan(v), u--, v--;\n        if(weighted) scan(c);\n        res.eb(u, v, c, i);\n    }\n    return res;\n}\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\ni128 abs(const i128 &x) { return x > 0 ? x : -x; }\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - \'0\'; }\n    }\n    if(s[0] == \'-\') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << ""0""); }\n    i128 num = v;\n    if(v < 0) {\n        os << \'-\';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + \'0\'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? "", "" : "" "");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << \'(\'; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << \')\'; }\n    return os;\n}\ntemplate <typename T, typename S, typename U> std::ostream &operator<<(std::ostream &os, const priority_queue<T, S, U> &_pq) {\n    auto pq = _pq;\n    vector<T> res;\n    while(!empty(pq)) res.emplace_back(pq.top()), pq.pop();\n    return os << res;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << ""("" << p.first << "", "" << p.second << "")""; }\n    return os << p.first << "" "" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << ""["";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? """" : "", "") << y;\n        else\n            os << (f ? """" : "" "") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << ""]"";\n    return os;\n}\n\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << \' \';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\ntemplate <class T, class S> constexpr pair<T, S> inf<pair<T, S>> = {inf<T>, inf<S>};\n\ntemplate <class T> void OUT2(const T &t, T INF = inf<T>, T res = -1) { OUT(t != INF ? t : res); }\ntemplate <class T> void OUT2(vector<T> &v, T INF = inf<T>, T res = -1) {\n    fore(e, v) if(e == INF) e = res;\n    OUT(v);\n    fore(e, v) if(e == res) e = INF;\n}\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nstruct string_converter {\n    char start = 0;\n    char type(const char &c) const { return (islower(c) ? \'a\' : isupper(c) ? \'A\' : isdigit(c) ? \'0\' : 0); }\n    int convert(const char &c) {\n        if(!start) start = type(c);\n        return c - start;\n    }\n    int convert(const char &c, const string &chars) { return chars.find(c); }\n    template <typename T> auto convert(const T &v) {\n        vector<decltype(convert(v[0]))> ret;\n        ret.reserve(size(v));\n        for(auto &&e : v) ret.emplace_back(convert(e));\n        return ret;\n    }\n    template <typename T> auto convert(const T &v, const string &chars) {\n        vector<decltype(convert(v[0], chars))> ret;\n        ret.reserve(size(v));\n        for(auto &&e : v) ret.emplace_back(convert(e, chars));\n        return ret;\n    }\n    int operator()(const char &v, char s = 0) {\n        start = s;\n        return convert(v);\n    }\n    int operator()(const char &v, const string &chars) { return convert(v, chars); }\n    template <typename T> auto operator()(const T &v, char s = 0) {\n        start = s;\n        return convert(v);\n    }\n    template <typename T> auto operator()(const T &v, const string &chars) { return convert(v, chars); }\n} toint;\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        // T mid = (ok + ng) / 2;\n        T mid = sqrtl(ok * ng);\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#endif\n\n#pragma endregion\n\n/**\n * @brief Lazy-Reversible-Splay-Tree(遅延伝搬反転可能Splay木)\n */\ntemplate <typename Monoid = int, typename OperatorMonoid = Monoid> struct LazyReversibleSplayTree {\n  public:\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    using S = function<Monoid(Monoid)>;\n\n    struct Node {\n        Node *l, *r, *p;\n        Monoid key, sum;\n        OperatorMonoid lazy;\n        bool rev;\n        size_t sz;\n\n        bool is_root() const { return !p || (p->l != this && p->r != this); }\n\n        Node(const Monoid &key, const OperatorMonoid &om) : key(key), sum(key), lazy(om), sz(1), rev(false), l(nullptr), r(nullptr), p(nullptr) {}\n    };\n\n    LazyReversibleSplayTree(const F &f, const Monoid &M1)\n        : LazyReversibleSplayTree(\n              f, [](const Monoid &a) { return a; }, M1) {}\n\n    LazyReversibleSplayTree(const F &f, const S &s, const Monoid &M1) : LazyReversibleSplayTree(f, G(), H(), s, M1, OperatorMonoid()) {}\n\n    LazyReversibleSplayTree(const F &f, const G &g, const H &h, const S &s, const Monoid &M1, const OperatorMonoid &OM0)\n        : f(f), g(g), h(h), s(s), M1(M1), OM0(OM0) {}\n\n    inline size_t count(const Node *t) { return t ? t->sz : 0; }\n\n    inline const Monoid &sum(const Node *t) { return t ? t->sum : M1; }\n\n    Node *alloc(const Monoid &v = Monoid()) { return new Node(v, OM0); }\n\n    void splay(Node *t) {\n        push(t);\n        while(!t->is_root()) {\n            auto *q = t->p;\n            if(q->is_root()) {\n                push(q), push(t);\n                if(q->l == t)\n                    rotr(t);\n                else\n                    rotl(t);\n            } else {\n                auto *r = q->p;\n                push(r), push(q), push(t);\n                if(r->l == q) {\n                    if(q->l == t)\n                        rotr(q), rotr(t);\n                    else\n                        rotl(t), rotr(t);\n                } else {\n                    if(q->r == t)\n                        rotl(q), rotl(t);\n                    else\n                        rotr(t), rotl(t);\n                }\n            }\n        }\n    }\n\n    Node *push_front(Node *t, const Monoid &v = Monoid()) {\n        if(!t) {\n            t = alloc(v);\n            return t;\n        } else {\n            splay(t);\n            Node *cur = get_left(t), *z = alloc(v);\n            splay(cur);\n            z->p = cur;\n            cur->l = z;\n            splay(z);\n            return z;\n        }\n    }\n\n    Node *push_back(Node *t, const Monoid &v = Monoid()) {\n        if(!t) {\n            t = alloc(v);\n            return t;\n        } else {\n            splay(t);\n            Node *cur = get_right(t), *z = alloc(v);\n            splay(cur);\n            z->p = cur;\n            cur->r = z;\n            splay(z);\n            return z;\n        }\n    }\n\n    Node *erase(Node *t) {\n        splay(t);\n        Node *x = t->l, *y = t->r;\n        delete t;\n        if(!x) {\n            t = y;\n            if(t) t->p = nullptr;\n        } else if(!y) {\n            t = x;\n            t->p = nullptr;\n        } else {\n            x->p = nullptr;\n            t = get_right(x);\n            splay(t);\n            t->r = y;\n            y->p = t;\n        }\n        return t;\n    }\n\n    Node *get_left(Node *t) const {\n        while(t->l) t = t->l;\n        return t;\n    }\n\n    Node *get_right(Node *t) const {\n        while(t->r) t = t->r;\n        return t;\n    }\n\n    void set_propagate(Node *&t, int a, int b, const OperatorMonoid &pp) {\n        if(!t) return;\n        splay(t);\n        auto x = split(t, a);\n        auto y = split(x.second, b - a);\n        set_propagate(y.first, pp);\n        t = merge(x.first, y.first, y.second);\n    }\n\n    virtual void set_propagate(Node *&t, const OperatorMonoid &pp) {\n        splay(t);\n        propagate(t, pp);\n        push(t);\n    }\n\n    pair<Node *, Node *> split(Node *t, int k) {\n        if(!t) return {nullptr, nullptr};\n        push(t);\n        if(k <= count(t->l)) {\n            auto x = split(t->l, k);\n            t->l = x.second;\n            t->p = nullptr;\n            if(x.second) x.second->p = t;\n            return {x.first, update(t)};\n        } else {\n            auto x = split(t->r, k - count(t->l) - 1);\n            t->r = x.first;\n            t->p = nullptr;\n            if(x.first) x.first->p = t;\n            return {update(t), x.second};\n        }\n    }\n\n    tuple<Node *, Node *, Node *> split3(Node *t, int a, int b) {\n        splay(t);\n        auto x = split(t, a);\n        auto y = split(x.second, b - a);\n        return make_tuple(x.first, y.first, y.second);\n    }\n\n    template <typename... Args> Node *merge(Node *l, Args... rest) {\n        Node *r = merge(rest...);\n        if(!l && !r) return nullptr;\n        if(!l) return splay(r), r;\n        if(!r) return splay(l), l;\n        splay(l), splay(r);\n        l = get_right(l);\n        splay(l);\n        l->r = r;\n        r->p = l;\n        update(l);\n        return l;\n    }\n\n    void insert(Node *&t, int k, const Monoid &v) {\n        splay(t);\n        auto x = split(t, k);\n        t = merge(x.first, alloc(v), x.second);\n    }\n\n    Monoid erase(Node *&t, int k) {\n        splay(t);\n        auto x = split(t, k);\n        auto y = split(x.second, 1);\n        auto v = y.first->c;\n        delete y.first;\n        t = merge(x.first, y.second);\n        return v;\n    }\n\n    Monoid query(Node *&t, int a, int b) {\n        splay(t);\n        auto x = split(t, a);\n        auto y = split(x.second, b - a);\n        auto ret = sum(y.first);\n        t = merge(x.first, y.first, y.second);\n        return ret;\n    }\n\n    Node *build(const vector<Monoid> &v) { return build(0, (int)v.size(), v); }\n\n    void toggle(Node *t) {\n        swap(t->l, t->r);\n        t->sum = s(t->sum);\n        t->rev ^= true;\n    }\n\n    Node *update(Node *t) {\n        t->sz = 1;\n        t->sum = t->key;\n        if(t->l) t->sz += t->l->sz, t->sum = f(t->l->sum, t->sum);\n        if(t->r) t->sz += t->r->sz, t->sum = f(t->sum, t->r->sum);\n        return t;\n    }\n\n    void push(Node *t) {\n        if(t->lazy != OM0) {\n            if(t->l) propagate(t->l, t->lazy);\n            if(t->r) propagate(t->r, t->lazy);\n            t->lazy = OM0;\n        }\n        if(t->rev) {\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev = false;\n        }\n    }\n\n    void set_element(Node *&t, int k, const Monoid &x) {\n        splay(t);\n        sub_set_element(t, k, x);\n    }\n\n  private:\n    const Monoid M1;\n    const OperatorMonoid OM0;\n    const F f;\n    const G g;\n    const H h;\n    const S s;\n\n    Node *build(int l, int r, const vector<Monoid> &v) {\n        // dump(l, r);\n        if(l + 1 >= r) return alloc(v[l]);\n        return merge(build(l, (l + r) >> 1, v), build((l + r) >> 1, r, v));\n    }\n\n    void propagate(Node *t, const OperatorMonoid &x) {\n        t->lazy = h(t->lazy, x);\n        t->key = g(t->key, x);\n        t->sum = g(t->sum, x);\n    }\n\n    void rotr(Node *t) {\n        auto *x = t->p, *y = x->p;\n        if((x->l = t->r)) t->r->p = x;\n        t->r = x, x->p = t;\n        update(x), update(t);\n        if((t->p = y)) {\n            if(y->l == x) y->l = t;\n            if(y->r == x) y->r = t;\n            update(y);\n        }\n    }\n\n    void rotl(Node *t) {\n        auto *x = t->p, *y = x->p;\n        if((x->r = t->l)) t->l->p = x;\n        t->l = x, x->p = t;\n        update(x), update(t);\n        if((t->p = y)) {\n            if(y->l == x) y->l = t;\n            if(y->r == x) y->r = t;\n            update(y);\n        }\n    }\n\n    Node *merge(Node *l) { return l; }\n\n    Node *sub_set_element(Node *&t, int k, const Monoid &x) {\n        push(t);\n        if(k < count(t->l)) {\n            return sub_set_element(t->l, k, x);\n        } else if(k == count(t->l)) {\n            t->key = x;\n            splay(t);\n            return t;\n        } else {\n            return sub_set_element(t->r, k - count(t->l) - 1, x);\n        }\n    }\n\n  public:\n    int lowb(Node *&t, const Monoid &x, int L) {\n        if(!t) return L;\n        push(t);\n        if(t->l and sum(t->l) < x) return lowb(t->l, x, L);\n        L += count(t->l);\n        if(t->key < x) {\n            splay(t);\n            return L;\n        }\n        if(!t->r) {\n            splay(t);\n            return L + 1;\n        }\n        return lowb(t->r, x, L + 1);\n    }\n\n    void ddump(Node *&t, vector<Monoid> &v) {\n        // splay(t);\n        push(t);\n        if(t->l) ddump(t->l, v);\n        v.eb(t->key);\n        if(t->r) ddump(t->r, v);\n    }\n};\n\nll f(ll x, ll y) { return min(x, y); }\nll g(ll x, ll y) { return x + y; }\nll ts(ll x) { return x; }\n\nint main() {\n    TEST {\n        INT(n);\n        STR(s);\n        VEC(ll, r, n);\n        VEC(ll, b, n);\n        ll ans = SUM(b);\n        string t;\n        vl c;\n        rep(i, n) {\n            if(r[i] > b[i]) {\n                c.eb(r[i] - b[i]);\n                t += s[i];\n            }\n        }\n        n = si(t);\n\n        ll k = 0;\n        // vl dp;\n        auto a = toint(t);\n        dump(a);\n        dump(c);\n\n        // LazyReversibleSplayTree<ll, ll, f, f, f, ts> rbst;\n        LazyReversibleSplayTree<ll, ll> rbst(f, g, g, ts, inf<ll>, 0);\n\n        LazyReversibleSplayTree<ll, ll>::Node *root = nullptr;\n        int cnt = 0;\n        rep(i, n) {\n            if(a[i]) {\n                if(root) rbst.splay(root);\n                int k = rbst.lowb(root, c[i], 0);\n                if(!root) {\n                    root = rbst.build(vl{c[i]});\n                } else\n                    rbst.insert(root, k, c[i]);\n                cnt++;\n            } else {\n                int m = min(cnt, c[i]);\n                rbst.set_propagate(root, 0, m, -1);\n\n                k += c[i];\n            }\n\n            // vl dp;\n            // rep(j, cnt) dp.eb(rbst.query(root, j, j + 1));\n            // dump(dp);\n        }\n\n        vl dp;\n        if(root) rbst.ddump(root, dp);\n        // rep(i, cnt) dp.eb(rbst.query(root, i, i + 1));\n\n        ll ma = k;\n        dump(k, dp);\n\n        fore(e, dp) {\n            k += e;\n            chmax(ma, k);\n        }\n        // fore(e, dp) if(e > 0) k += e;\n        OUT(ans + ma);\n    }\n}']",,,"['binary search', 'data structures', 'dp', 'flows', 'greedy']",3100,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Two Characters, Two Colors.json",https://codeforces.com//blog/entry/122034,This problem requires partitioning some object into two parts and imposes different costs depending on how we perform the partition Let s try to model it with minimum cuts Create a flow network with vertices a vertex for every character of the string a source and a sink Using the edges of the network we will try to model the following if we paint the th character red we lose coins we can treat it as always gaining coins no matter what and then losing coins instead of earning them for coloring the characters if we paint the th character blue we lose coins the same applies here if and both and are red we lose coin To model the third constraint let s say that the vertices representing s are red if they belong to the set in the cut or blue if they belong to For the vertices representing s this will be the opposite they will be red if they belong to the set or blue if they belong to the set So if we add a directed edge with capacity from to when and this edge will be cut exactly when both and are red and they create an inversion To model the second constraint for vertices representing s add an incoming edge from the source with capacity and an outgoing edge to the sink with capacity For vertices representing s this will be vice versa since red vertices representing s belong to the edge from the source to that vertex should have capacity not Now we got ourselves a flow network The answer to the problem will be where is the minimum cut in this network But instead of searching for the minimum cut we will try to calculate the maximum flow We are going to do it greedily Let s process the vertices of the network from the vertex representing the st character to the vertex representing the th character Every time we will try to push as much flow as possible through the current vertex When processing a vertex first of all let s try to push flow through the edges connecting the source and the sink with it Then if it is a vertex with a character of type let s remember that we can push flow through it to successive vertices of type let s call this excess flow for that vertex And if it is a vertex representing a character of type let s try to push at most flow into it from the vertices of type we processed earlier but no more than unit of flow from each vertex But when we process a vertex of type how do we choose from which vertices of type we take the flow It can be shown that we can take unit of flow from the vertices with the maximum amount of excess flow the formal proof is kinda long but the main idea is that every optimal flow assignment can be transformed into the one working in this greedy way without breaking anything So to recap when we process a vertex of type we remember that it has some excess flow And when we process a vertex of type we take unit of excess flow from several vertices with the maximum amount of excess flow So we need a data structure that allows us to process the following queries add an integer calculate the number of positive integers in the structure subtract from maximum integers in the structure Model implementation of this data structure is kinda long there are easier ways to do it but I will describe it nevertheless We will use an explicit key treap which stores two values in each vertex an integer belonging to the structure and the quantity of that integer in the structure so it s kinda like a map which counts the number of occurrences of each integer This treap has to support adding to all values in some subtree with lazy propagation Most operations with it are fairly straightforward but how do we actually subtract from maximum values in the tree We will do it in the following way split the treap to extract maximum elements let s denote the first treap as the part without maximums and the second treap as the part with those maximums add to the values in the second treap while the minimum element in the second treap is not greater than the maximum element in the first treap remove the minimum from the second treap and insert it into the first treap merge the treaps It s quite easy to see that if you store the pairs of the form element the number of its occurrences in the treap the third step will require moving at most elements And the resulting complexity of every operation with this data structure becomes so the whole solution works in 
https://codeforces.com//contest/1121/problem/B,306948,B,1121B,1121,B. Mike and Children,Mike decided to teach programming to children in an elementary school He knows that it is not an easy task to interest children in that age to code That is why he decided to give each child sweets Mike has n sweets with sizes a 1 a 2 ldots a n All his sweets have sizes That is there is no such pair i j 1 leq i j leq n such that i ne j and a i a j Since Mike has taught for many years he knows that if he gives two sweets with sizes a i and a j to one child and a k and a p to another where a i a j neq a k a p then a child who has a smaller sum of sizes will be upset That is if there are two children who have different sums of sweets then one of them will be upset Apparently Mike does not want somebody to be upset Mike wants to invite children giving each of them sweets Obviously he can t give one sweet to two or more children His goal is to invite as many children as he can Since Mike is busy preparing to his first lecture in the elementary school he is asking you to find the maximum number of children he can invite giving each of them two sweets in such way that nobody will be upset ,"['#include <bits/stdc++.h>                                                                                                                                                                                                                                                                                            \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace std;\n\nint n;\nint a[1000001];\n\nint used[1000001];\n\nint main(){\n    #ifdef DIAS\n        freopen(""input.txt"", ""r"", stdin);\n        //freopen(""output.txt"", ""w"", stdout);\n    #elif NAME \n    \tfreopen(fn"".in"", ""r"", stdin);\n    \tfreopen(fn"".out"", ""w"", stdout);\n    #endif\n\tcin >> n;\n    for(int i = 1; i <= n; i++){\n    \tcin >> a[i];\n    }\n    int mx = 0;\n    for(int i = 1; i <= n; i++){\n    \tfor(int j = 1; j < i; j++){\n    \t\tused[a[i] + a[j]] ++;\n    \t\tmx = max(mx, used[a[i] + a[j]]);\n    \t}\n    }\n    cout << mx;\n}\n']",,,"['brute force', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Mike and Children.json,https://codeforces.com//blog/entry/65679,Notice that the sum of sweets each child gets cannot exceed so for each of numbers no more than this threshold we can store the number of ways to obtain it as the sum of two sweets It can be done just by considering all possible unordered pairs of sweets and printing the maximal obtained number of ways to represent something as sum of two sweets Indeed if can be represented as a sum of two sweets in several ways then no two of them share a sweet since if then and therefore 
https://codeforces.com//contest/1369/problem/E,651259,E,1369E,1369,E. DeadLee,There are n different types of food and m Lee s best friends Lee has w i plates of the i th type of food and each friend has two different favorite types of food the i th friend s favorite types of food are x i and y i x i ne y i Lee will start calling his friends one by one Whoever is called will go to the kitchen and will try to eat Each of the friends will go to the kitchen exactly once The only problem is the following if a friend will eat at least one plate of food in total then he will be harmless But if there is nothing left for him to eat neither x i nor y i he will eat Lee instead times times Lee can choose the order of friends to call so he d like to determine if he can survive dinner or not Also he d like to know the order itself ,"['// You may love a girl deeply\n// but you can\'t express in it more than 7-8 inches...\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(ass) ass.begin(), ass.end()\nusing namespace std;\n\ntypedef long long ll;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007;\nconst ll N = 2e5 + 85;\nconst ll Inf = 1e18;\nconst ll Log = 69;\n\nvector<ll> G[N];\nll deg[N];\nvector<ll> V, A;\nll mk[N], w[N], u[N], v[N];\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> w[i];\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tG[u[i]].pb(i);\n\t\tG[v[i]].pb(i);\n\t\tdeg[u[i]] ++;\n\t\tdeg[v[i]] ++;\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tif(deg[i] <= w[i]){\n\t\t\tfor(auto x : G[i]){\n\t\t\t\tif(!mk[x]){\n\t\t\t\t\tmk[x] = 1;\n\t\t\t\t\tV.pb(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint p = 0;\n\twhile(p < V.size()){\n\t\tA.pb(V[p]);\n\t\tint fd = u[V[p]];\n\t\tdeg[fd] --;\n\t\tif(deg[fd] == w[fd]){\n\t\t\tfor(auto x : G[fd]){\n\t\t\t\tif(!mk[x]){\n\t\t\t\t\tmk[x] = 1;\n\t\t\t\t\tV.pb(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfd = v[V[p]];\n\t\tdeg[fd] --;\n\t\tif(deg[fd] == w[fd]){\n\t\t\tfor(auto x : G[fd]){\n\t\t\t\tif(!mk[x]){\n\t\t\t\t\tmk[x] = 1;\n\t\t\t\t\tV.pb(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp ++;\n\t}\n\tif(V.size() != m){\n\t\tcout << ""DEAD\\n"";\n\t\treturn 0;\n\t}\n\treverse(all(A));\n\tcout << ""ALIVE\\n"";\n\tfor(auto x : A) cout << x << \' \';\n\tcout << \'\\n\';\n\treturn 0;\n}\n']",,,"['data structures', 'dfs and similar', 'greedy', 'implementation', 'sortings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. DeadLee.json,https://codeforces.com//blog/entry/79235, Define equal to the number of friends who likes food We want to proof that if then no answer exist it can be proved easily by contradiction just look at the last friend in any suitable permutation he will eat Lee as there is no food for him So if it was the case then print and terminate otherwise place all the guys who likes food in the end of the permutation they wont eat Lee as they can always eat food also it s always better to place them in the end as if we place them in the end then they wont eat two plates Continue the process until no friends exist or no exist such that Note that when we erase the friends we have to update also if we should erase food from the set of foods Instead of erasing friends foods just remember if a friend food is erased or not using another array Also updating should not be that much hard when marking th friend decrease and by one if there exist any also you can have the food with maximum with a priority queue or any other data structure in The whole solution will work in time you can also try achieving and then show off it in the comment section 
https://codeforces.com//contest/759/problem/E,89814,E,759E,759,E. Byteland coins,There are types of coins in Byteland Conveniently the denomination of the coin type divides the denomination of the coin type the denomination of the coin type equals tugrick The ratio of the denominations of coin types and equals It is known that for each there are at most coin types of denomination Byteasar has coins of type with him and he needs to pay exactly tugricks It is known that Byteasar never has more than coins with him Byteasar want to know how many ways there are to pay exactly tugricks Two ways are different if there is an integer such that the amount of coins of type differs in these two ways As all Byteland citizens Byteasar wants to know the number of ways modulo ,"['#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, ""/stack:16777216"")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <assert.h>\n#include <time.h>\n#include <complex.h>\n\n\n#include <fstream>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<Int, Int> PII;\n\nconst int INF = 1000000000;\nconst int MAX = 300007;\nconst int MAXD = 20;\nconst int MOD = 1000000007;\n\nconst int BASE = 1000*1000*1000;\n\nVI read(string s)\n{\n    VI a;\n    for (int i=(int)s.length(); i>0; i-=9)\n        if (i < 9)\n            a.push_back (atoi (s.substr (0, i).c_str()));\n        else\n            a.push_back (atoi (s.substr (i-9, 9).c_str()));\n    return a;\n}\n\nint div(VI & a, int b)\n{\n    if (b == 1)\n    {\n        return 0;\n    }\n        \n    \n    if (b == BASE)\n    {\n        int carry = a[0];\n        if (SZ(a) > 0)\n        {\n            a.erase(a.begin());\n        }\n        return carry;\n    }\n    \n    int carry = 0;\n    for (int i=(int)a.size()-1; i>=0; --i) {\n        long long cur = a[i] + carry * 1ll * BASE;\n        a[i] = int (cur / b);\n        carry = int (cur % b);\n    }\n    while (a.size() > 1 && a.back() == 0)\n        a.pop_back();\n    return carry;\n}\n\nVI A[MAX];\nVI C;\nint a[MAX];\nVI B;\n\nint dp[2][MAX];\nint b[MAX];\n\n\nint main()\n{\n    //freopen(""in.txt"" , ""r"" , stdin);\n    //freopen(""out.txt"" , ""w"" , stdout);\n    \n    int n;\n    cin >> n;\n    FOR(i,1,n)\n    {\n        scanf(""%d"", &a[i]);\n    }\n\n    \n    \n    FOR(i,0,n)\n    {\n        scanf(""%d"", &b[i]);\n    }\n    \n    string s;\n    cin >> s;\n    VI num = read(s);\n    FOR(i,1,n)\n    {\n        B.push_back(div(num , a[i]));\n    }\n    if (SZ(num) > 1)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    B.push_back(num[0]);\n    \n    int sz = b[0] + 1;\n    int prev = 0;\n    int next = 1;\n    FOR(i,0,sz)\n    {\n        dp[prev][i] = 1;\n    }\n    \n    FOR(i,0,n - 1)\n    {\n        VI t;\n        int idd = 0;\n        for(int j = B[i]; j < sz; j += a[i + 1])\n        {\n            dp[next][idd ++] = dp[prev][j];\n        }\n        if (idd == 0)\n        {\n            cout << 0 << endl;\n            return 0;\n        }\n        sz = idd;\n        swap(prev , next);\n        int x = b[i + 1];\n        \n        FOR(j,0,sz + b[i + 1])\n        {\n            dp[next][j] = 0;\n            if (j) dp[next][j] = dp[next][j - 1];\n            if (j < sz)\n            {\n                dp[next][j] += dp[prev][j];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n            if (j - x - 1 >= 0)\n            {\n                dp[next][j] += MOD - dp[prev][j - x - 1];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n        }\n        swap(prev , next);\n        sz += x;\n        \n    }\n    \n    if (B[n - 1] >= sz)\n    {\n        cout << 0 << endl;\n    }\n    else\n    {\n        cout << dp[prev][B[n - 1]] << endl;\n    }\n        \n    \n    \n    return 0;\n}\n']",,,"['dp', 'math']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Byteland coins.json,https://codeforces.com//blog/entry/49946,Let s calculate DP pref x number of ways to pay x tugriks using only pref first types Of course x can be very big but we will store DP only for those x which are not bigger than the sum of all the coins of first pref types and can lead to answer x k D m D where D is the last coin denomination Every next layer of this DP can be calculated in O szi time using prefix sums where sz is the size of the new layer Now all that remains is to calculate some info about m D to know what DP elemnts we are interested in We should represent m in a form of i 1nci Di To find ci we should successively divide m by all ai ci will be the reminders All the divisions can be done in time if we will not divide by 1 
https://codeforces.com//contest/1334/problem/C,590683,C,1334C,1334,C. Circle of Monsters,You are playing another computer game and now you have to slay n monsters These monsters are standing in a circle numbered clockwise from 1 to n Initially the i th monster has a i health You may shoot the monsters to kill them Each shot requires exactly one bullet and decreases the health of the targeted monster by 1 deals 1 damage to it Furthermore when the health of some monster i becomes 0 or less than 0 it dies and explodes dealing b i damage to the next monster monster i 1 if i n or monster 1 if i n If the next monster is already dead then nothing happens If the explosion kills the next monster it explodes too damaging the monster after it and possibly triggering another explosion and so on You have to calculate the minimum number of bullets you have to fire to kill all n monsters in the circle ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=301000;\n\nint _,n;\nll extra[N],a[N],b[N];\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d"",&n);\n\t\trep(i,0,n) scanf(""%lld%lld"",a+i,b+i);\n\t\tll s=0,d=1ll<<60;;\n\t\trep(i,0,n) {\n\t\t\textra[i]=max(0ll,a[i]-b[(i+n-1)%n]);\n\t\t\ts+=extra[i];\n\t\t//\tprintf(""%d %lld\\n"",i,extra[i]);\n\t\t}\n\t\trep(i,0,n) d=min(d,s-extra[i]+a[i]);\n\t\tprintf(""%lld\\n"",d);\n\t}\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Circle of Monsters.json,https://codeforces.com//blog/entry/75877,We cannot utilize the explosion of the last monster we kill So the naive approach is to iterate on the monster we kill the last break the circle between this monster and the next one and then shoot the first monster in the broken circle until it s dead then the second one and so on Let s calculate the number of bullets we will fire this way If the circle is broken after the monster then the first monster gets bullets the second one and so on all monsters except the first one get exactly bullets So we should choose an index such that is minimum possible since this is the number of bullets we have to spend additionally since we cannot utilize the explosion of the th monster After breaking the circle between the monsters and you may use a formula to calculate the required number of bullets or just model the shooting 
https://codeforces.com//contest/863/problem/C,123493,C,863C,863,C. 1-2-3,Ilya is working for the company that constructs robots Ilya writes programs for entertainment robots and his current project is Bob a new generation game robot Ilya s boss wants to know his progress so far Especially he is interested if Bob is better at playing different games than the previous model Alice So now Ilya wants to compare his robots performance in a simple game called 1 2 3 This game is similar to the Rock Paper Scissors game both robots secretly choose a number from the set and say it at the same moment If both robots choose the same number then it s a draw and noone gets any points But if chosen numbers are different then one of the robots gets a point beats beats and beats Both robots programs make them choose their numbers in such a way that their choice in th game depends only on the numbers chosen by them in th game Ilya knows that the robots will play games Alice will choose number in the first game and Bob will choose in the first game He also knows both robots programs and can tell what each robot will choose depending on their choices in previous game Ilya doesn t want to wait until robots play all games so he asks you to predict the number of points they will have after the final game ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tlong long K; int a; int b;\n\twhile (~scanf(""%lld%d%d"", &K, &a, &b)) {\n\t\t-- a, -- b;\n\t\tvector<vector<int> > A(3, vector<int>(3));\n\t\tfor (int i = 0; i < 3; ++ i) for (int j = 0; j < 3; ++ j)\n\t\t\tscanf(""%d"", &A[i][j]), -- A[i][j];\n\t\tvector<vector<int> > B(3, vector<int>(3));\n\t\tfor (int i = 0; i < 3; ++ i) for (int j = 0; j < 3; ++ j)\n\t\t\tscanf(""%d"", &B[i][j]), -- B[i][j];\n\t\tstruct Perm {\n\t\t\tarray<pair<int, pair<ll, ll>>, 9> next;\n\t\t\tPerm() {\n\t\t\t\trep(i, 9)\n\t\t\t\t\tnext[i] = { i, {0, 0} };\n\t\t\t}\n\t\t\tPerm operator*(const Perm &that) {\n\t\t\t\tPerm res;\n\t\t\t\trep(i, 9) {\n\t\t\t\t\tint j = next[i].first;\n\t\t\t\t\tres.next[i] = {\n\t\t\t\t\t\tthat.next[j].first,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnext[i].second.first + that.next[j].second.first,\n\t\t\t\t\t\t\tnext[i].second.second + that.next[j].second.second,\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t};\n\t\tPerm perm;\n\t\trep(i, 3) rep(j, 3) {\n\t\t\tint x = A[i][j], y = B[i][j];\n\t\t\tperm.next[i * 3 + j] = { x * 3 + y, {(i + 2) % 3 == j, (j + 2) % 3 == i} };\n\t\t}\n\t\tPerm x = perm, y{};\n\t\twhile (K > 0) {\n\t\t\tif (K & 1) y = y * x;\n\t\t\tx = x * x;\n\t\t\tK >>= 1;\n\t\t}\n\t\tauto ans = y.next[a * 3 + b].second;\n\t\tprintf(""%lld %lld\\n"", ans.first, ans.second);\n\t}\n\treturn 0;\n}\n']",,,"['graphs', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. 1-2-3.json,https://codeforces.com//blog/entry/54708,Notice that there are only possible patterns in this game You can used in a following way Simulate games till one of the patterns get repeated Games between this pair of occurences will get you the same total outcome no matter when they are played Let the distance between the games with the same pattern is and index of these games are and zero indexed Total score of some interval is Then the answer will be 
https://codeforces.com//contest/1580/problem/D,1124757,D,1580D,1580,D. Subsequence,Alice has an integer sequence a of length n and She will choose a subsequence of a of length m and defines the value of a subsequence a b 1 a b 2 ldots a b m as sum i 1 m m cdot a b i sum i 1 m sum j 1 m f min b i b j max b i b j where f i j denotes min a i a i 1 ldots a j Alice wants you to help her to maximize the value of the subsequence she choose A sequence s is a subsequence of a sequence t if s can be obtained from t by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nint n, m, a[4005], cnt;\nLL dp[4005][4005];\n\nint solve(int l, int r, int id)\n{\n\tint mid = l;\n\tfor(int i = l + 1; i <= r; i ++) if(a[i] < a[mid]) mid = i;\n\tint siz;\n\tif(l == r) {\n\t\tsiz = 0;\n\t\tdp[id][0] = 0;\n\t} else if(mid == l) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(mid + 1, r, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else if(mid == r) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(l, mid - 1, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else {\n\t\tint tl = cnt;\n\t\tint ls = solve(l, mid - 1, cnt ++);\n\t\tint tr = cnt;\n\t\tint rs = solve(mid + 1, r, cnt ++);\n\t\tsiz = ls + rs;\n\t\tfor(int i = 0; i <= siz; i ++) dp[id][i] = -INF;\n\t\tfor(int i = 0; i <= ls; i ++) for(int j = 0; j <= rs; j ++)\n\t\tdp[id][i + j] = max(dp[id][i + j], dp[tl][i] + dp[tr][j] - 2LL * i * j * a[mid]);\n\t}\n\t\n\tsiz ++; dp[id][siz] = -INF;\n\tfor(int i = siz; i >= 1; i --) dp[id][i] = max(dp[id][i], dp[id][i - 1] + 1LL * (m + 1 - 2 * i) * a[mid]);\n\treturn siz;\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, n) scanf(""%d"", &a[i]);\n\t\n\tcnt = 1;\n\tsolve(0, n - 1, 0);\n\tprintf(""%lld\\n"", dp[0][m]);\n\treturn 0;\n}']",,,"['brute force', 'divide and conquer', 'dp', 'greedy', 'trees']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Subsequence.json,https://codeforces.com//blog/entry/95477,First we can change the way we calculate the value of a subsequence We can easily see the value of a subsequence is also which is very similar to the distance of two node on a tree Thus we can build the cartesian tree of the sequence and set the weight of a edge between node and as Then we can see what we are going to calculate turns into follows choosing nodes maximize the total distance between every two nodes Thus we can solve this task using dynamic programming with the time complexity 
https://codeforces.com//contest/1559/problem/E,1078717,E,1559E,1559,E. Mocha and Stars,Mocha wants to be an astrologer There are n stars which can be seen in Zhijiang and the brightness of the i th star is a i Mocha considers that these n stars form a constellation and she uses a 1 a 2 ldots a n to show its state A state is called if all of the following three conditions are satisfied For all i 1 le i le n a i is an integer in the range l i r i sum limits i 1 n a i le m gcd a 1 a 2 ldots a n 1 Here gcd a 1 a 2 ldots a n denotes the greatest common divisor GCD of integers a 1 a 2 ldots a n Mocha is wondering how many different mathematical states of this constellation exist Because the answer may be large you must find it modulo 998 244 353 Two states a 1 a 2 ldots a n and b 1 b 2 ldots b n are considered different if there exists i 1 le i le n such that a i ne b i ,"['#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,ssse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nconst int INF = 0x3f3f3f3f;\nconst int NINF = -INF - 1;\nconst int N = 1e5 + 10;\nconst int mod = 998244353;\nint n, m, cnt, maxr;\nint mu[N], prime[N], f[N], sum[N];\nbool vis[N];\nstd::pair<int, int > a[55];\nvoid init() { mu[1] = 1; rep(i, 2, 100000) { if(!vis[i]) mu[i] = -1, prime[++cnt] = i; for(int j = 1; i <= 100000 / prime[j]; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) { mu[i * prime[j]] = 0; break; } mu[i * prime[j]] = -mu[i]; } } }\nvoid Clear(int *b, int l, int r) { rep(i, l, r) b[i] = 0; }\nint query(int x) {\n    int h = m / x, ret=0; std::vector< std::pair <int ,int > > vec;\n    rep(i, 1, n) {\n        if( ( a[i].fi + x -1 ) / x > a[i].se / x ) return 0;\n        vec.eb( ( a[i].fi + x -1 ) / x , a[i].se / x );\n    }\n    rep(i, vec[0].fi, vec[0].se) {\n        if( h < vec[1].fi + i) break;\n        f[vec[1].fi + i] ++, f[std::min(vec[1].se + i, h) + 1] --;\n    }\n    rep(i, 1, h) sum[i] = f[i] + sum[i - 1];Clear(f, 1, h + 1);\n    rep(i, 2, n-1) {\n        rep(j, 1, h) {\n            if(!sum[j]) continue;\n            if(vec[i].fi + j > h ) break;\n            f[vec[i].fi + j] = ( f[vec[i].fi + j] + sum[j] ) % mod;\n            f[std::min(vec [i].se + j, h) + 1] = ( f[std::min(vec [i].se + j, h) + 1] - sum[j] + mod ) % mod;\n        }\n        rep(j, 1, h) sum[j] = ( f[j] + sum[j - 1] ) % mod;Clear(f, 1, h + 1);\n    }\n    rep(i, 1, h) ret = ( sum[i] + ret ) % mod;\n    return ret;\n}\nint solve() {\n    int ans = 0;\n    rep(i, 1, maxr) ans = ( query(i) * mu[i] + ans + mod ) % mod;\n    return ans;\n}\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    init();\n    std::cin >> n >> m;\n    for(int i = 1; i <= n; i++) std::cin >> a[i].fi >> a[i].se, maxr=std::max(maxr, a[i].se);\n    std::cout << solve();\n    return 0;\n}']",,,"['combinatorics', 'dp', 'fft', 'math', 'number theory']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Mocha and Stars.json,https://codeforces.com//blog/entry/93898,We firstly ignore the constraint of let be the number of integers satisfy the following two conditions For all is an integer in the range We can compute it in by Knapsack DP optimized by prefix sums Then we consider about the constraint of let be Mobius function and be if satisfies the two conditions we mentioned about without the constraint of otherwise it will be The answer we want is Since can be changed to it equals So we can compute it in 
https://codeforces.com//contest/1359/problem/F,634677,F,1359F,1359,F. RC Kaboom Show,You know it s hard to conduct a show with lots of participants and spectators at the same place nowadays Still you are not giving up on your dream to make a car crash showcase You decided to replace the real cars with remote controlled ones call the event Remote Control Kaboom Show and stream everything online For the preparation you arranged an arena an infinite 2D field You also bought n remote controlled cars and set them up on the arena Unfortunately the cars you bought can only go forward without turning left right or around So you additionally put the cars in the direction you want them to go To be formal for each car i 1 le i le n you chose its initial position x i y i and a direction vector dx i dy i Moreover each car has a constant speed s i units per second So after car i is launched it stars moving from x i y i in the direction dx i dy i with constant speed s i The goal of the show is to create a car collision as fast as possible You noted that launching every car at the beginning of the show often fails to produce any collisions at all Thus you plan to launch the i th car at some moment t i Note that it s not necessary for t i to be integer and t i is allowed to be equal to t j for any i j The show starts at time 0 The show ends when two cars i and j i ne j collide i e come to the same coordinate at the same time The duration of the show is the time between the start and the end What s the fastest crash you can arrange by choosing all t i If it s possible to arrange a crash then print the shortest possible duration of the show Otherwise report that it s impossible ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst ld EPS = 1E-12;\n\nconst int maxN = 25000 + 10;\nint x[maxN], y[maxN], dx[maxN], dy[maxN], ss[maxN];\nint n;\n\nstruct pt {\n    ld x, y;\n    pt(ld x, ld y) : x(x), y(y) {}\n};\n\nstruct seg {\n    pt p, q;\n    int id;\n    seg(pt& x, pt& y, int& id) : p(x), q(y), id(id) {}\n\n    double get_y (double x) const {\n        if (abs (p.x - q.x) < EPS)  return p.y;\n        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);\n    }\n};\n\n\ninline bool intersect1d (ld l1, ld r1, ld l2, ld r2) {\n    if (l1 > r1)  swap (l1, r1);\n    if (l2 > r2)  swap (l2, r2);\n    return max (l1, l2) <= min (r1, r2) + EPS;\n}\n\ninline int vec (const pt & a, const pt & b, const pt & c) {\n    ld s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    return abs(s)<EPS ? 0 : s>0 ? +1 : -1;\n}\n\nbool intersect (const seg & a, const seg & b) {\n    return intersect1d (a.p.x, a.q.x, b.p.x, b.q.x)\n           && intersect1d (a.p.y, a.q.y, b.p.y, b.q.y)\n           && vec (a.p, a.q, b.p) * vec (a.p, a.q, b.q) <= 0\n           && vec (b.p, b.q, a.p) * vec (b.p, b.q, a.q) <= 0;\n}\n\n\nbool operator< (const seg & a, const seg & b) {\n    double x = max (min (a.p.x, a.q.x), min (b.p.x, b.q.x));\n    return a.get_y(x) < b.get_y(x) - EPS;\n}\n\n\nstruct has_inter {\n\n    struct event {\n        ld x;\n        int tp, id;\n\n        event() {}\n\n        event(ld x, int tp, int id)\n            : x(x), tp(tp), id(id) {}\n\n        bool operator<(const event &e) const {\n            if (abs(x - e.x) > EPS) return x < e.x;\n            return tp > e.tp;\n        }\n    };\n\n    set<seg> s;\n    vector<set<seg>::iterator> where;\n\n    inline set<seg>::iterator prev(set<seg>::iterator it) {\n        return it == s.begin() ? s.end() : --it;\n    }\n\n    inline set<seg>::iterator next(set<seg>::iterator it) {\n        return ++it;\n    }\n\n    pair<int, int> solve(const vector<seg> &a) {\n        int n = (int) a.size();\n        vector<event> e;\n        for (int i = 0; i < n; ++i) {\n            e.push_back(event(min(a[i].p.x, a[i].q.x), +1, i));\n            e.push_back(event(max(a[i].p.x, a[i].q.x), -1, i));\n        }\n        sort(e.begin(), e.end());\n\n        s.clear();\n        where.resize(a.size());\n        for (size_t i = 0; i < e.size(); ++i) {\n            int id = e[i].id;\n            if (e[i].tp == +1) {\n                auto nxt = s.lower_bound(a[id]), prv = prev(nxt);\n                if (nxt != s.end() && intersect(*nxt, a[id]))\n                    return make_pair(nxt->id, id);\n                if (prv != s.end() && intersect(*prv, a[id]))\n                    return make_pair(prv->id, id);\n                where[id] = s.insert(nxt, a[id]);\n            } else {\n                auto nxt = next(where[id]), prv = prev(where[id]);\n                if (nxt != s.end() && prv != s.end() && intersect(*nxt, *prv))\n                    return make_pair(prv->id, nxt->id);\n                s.erase(where[id]);\n            }\n        }\n\n        return make_pair(-1, -1);\n    }\n};\nbool has(ld T) {\n    vector < seg > f;\n    for (int i = 1; i <= n; i++) {\n        pt c1{(ld)x[i], (ld)y[i]};\n        ld D = sqrt(dx[i] * dx[i] + dy[i] * dy[i]);\n        pt c2{x[i] + T * ss[i] * dx[i] / D, y[i] + T * ss[i] * dy[i] / D};\n        f.emplace_back(c1, c2, i);\n    }\n    has_inter Q;\n    return Q.solve(f).first != -1;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> dx[i] >> dy[i] >> ss[i];\n    }\n    ld l = 0;\n    ld r = 2e12;\n    if (!has(r)) {\n        cout << ""No show :("" << \'\\n\';\n    }\n    else {\n        for (int it = 0; it < 75; it++) {\n            ld mid = (l + r) / 2;\n            if (has(mid)) r = mid;\n            else l = mid;\n        }\n        cout << fixed << setprecision(12) << (l + r) / 2 << \'\\n\';\n    }\n    return 0;\n}']",,,"['binary search', 'brute force', 'data structures', 'geometry', 'math']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. RC Kaboom Show.json,https://codeforces.com//blog/entry/78116,Let be true if it s possible to have a collision before time That function is monotonous thus let s binary search for For some fixed car can end up in any point from to units along the ray That makes it a segment So the collision can happen if some pair of segments intersects Let s learn how to find that out The general idea is to use sweep line So let s add the events that the th segment such that opens at and closes at There were no vertical segments so and are always different At every moment of time we want to maintain the segments ordered by their intersection with the line Note that if two segments change their order moving along the sweep line then they intersect So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one When adding a segment to set you want to check it s intersections with the next segment in the order and the previous one When removing a segment you want to check the intersection between the next and the previous segment in the order If any check triggers then return true immediately It s easy to show that if the intersection happens between some pair of segments then the intersection between only these pairs of segment also happens Now for the implementation details Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set The solution I want to tell requires no epsilon comparisons thus it calculates the answer only with the precision of binary search So the first issue rises when we have to erase elements from the set Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point That will not make the answer incorrect that s not trivial to show but it s possible if you consider some cases If you can find it later to remove then it s not an issue at all However that will probably mess up the lower bound in the set Thus let s save the pointer to each element in the set and remove it later by that pointer The second issue comes when you have to check the intersection of two segments The error might appear when one segment let the first point be the original and the second point be calculated depending on has it s intersection point with segment at exactly So the slightest miscalculations could matter a lot Let s learn to intersect in such a way that no epsilon comparisons are required Firstly we can store lines in the set instead of segments Second we can check the intersection of rays first and only then proceed to check the intersection of segments So two rays intersect if their lines intersect easy to check in integers the intersection point lies in the correct direction of both rays the intersection point is always a pair of fractions and you want to compare the signs of and Finally if all the checks hold then you can compare maximum of distances from and to the intersection point and If is greater or equal then they intersect in time There is no way to make that comparison in integers However it s precision only depends on the precision of as in the error here can t affect the answer greatly Overall complexity 
https://codeforces.com//contest/480/problem/C,15740,C,480C,480,C. Riding in a Lift,Imagine that you are in a building that has exactly floors You can move between the floors in a lift Let s number the floors from bottom to top with integers from to Now you re on the floor number You are very bored so you want to take the lift Floor number has a secret lab the entry is forbidden However you already are in the mood and decide to make consecutive trips in the lift Let us suppose that at the moment you are on the floor number initially you were on floor For another trip between floors you choose some floor with number and the lift travels to this floor As you cannot visit floor with the secret lab you decided that the distance from the current floor to the chosen must be strictly less than the distance from the current floor to floor with the secret lab Formally it means that the following inequation must fulfill After the lift successfully transports you to floor you write down number in your notepad Your task is to find the number of distinct number sequences that you could have written in the notebook as the result of trips in the lift As the sought number of trips can be rather large find the remainder after dividing the number by ,"['#include <bits/stdc++.h>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\ntemplate<typename T, T Modulus>\nclass MR\n{\nprivate:\n    struct tag_plus {}; // indicates value is in range [0, 2 * Modulus)\n    struct tag_minus {}; // indicates value is in range (-Modulus, Modulus)\n\n    T value;\n\n    enum\n    {\n        ASSERT_FALSE = 0,\n        ASSERT_TEST = (T(1) << (std::numeric_limits<T>::digits - 1)) / Modulus / Modulus > 0 ? 1 : 0\n    };\n\n    void reduce()\n    {\n        value %= Modulus;\n        if (value < 0)\n            value += Modulus;\n    }\n\n    void reduce(tag_plus)\n    {\n        if (value >= Modulus)\n            value -= Modulus;\n    }\n\n    void reduce(tag_minus)\n    {\n        if (value < 0)\n            value += Modulus;\n    }\n\npublic:\n    typedef T value_type;\n    static const T modulus = Modulus;\n\n    MR() : value(0) {}\n    MR(T value) : value(value) { reduce(); }\n    template<typename tag_t>\n    MR(T value, tag_t tag) : value(value) { reduce(tag); }\n\n    MR &operator=(T value) { this->value = value; reduce(); return *this; }\n\n    MR operator +(MR b) const { return MR(value + b.value, tag_plus()); }\n    MR operator -(MR b) const { return MR(value - b.value, tag_minus()); }\n    MR operator *(MR b) const { return MR(value * b.value); }\n    MR operator -() const { return MR(-value); }\n\n    MR &operator +=(MR b) { value += b.value; reduce(tag_plus()); return *this; }\n    MR &operator -=(MR b) { value -= b.value; reduce(tag_minus()); return *this; }\n    MR &operator *=(MR b) { value *= b.value; reduce(); return *this; }\n\n    bool operator==(MR b) const { return value == b.value; }\n    bool operator!=(MR b) const { return value != b.value; }\n\n    T get() const { return value; }\n};\n\nstatic void redirect(int argc, const char **argv)\n{\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntypedef MR<ll, 1000000007> mr;\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, a, b, K;\n    cin >> N >> a >> b >> K;\n    a--;\n    b--;\n\n    vector<mr> dp(N, 1);\n    dp[b] = 0;\n\n    for (int k = 0; k < K; k++)\n    {\n        vector<mr> sum(N + 1);\n        partial_sum(RA(dp), sum.begin() + 1);\n        for (int i = 0; i < N; i++)\n            if (i != b)\n            {\n                int d = abs(i - b) - 1;\n                int low = max(i - d, 0);\n                int high = min(i + d + 1, N);\n                dp[i] = sum[high] - sum[low] - dp[i];\n            }\n    }\n    cout << dp[a].get() << \'\\n\';\n\n    return 0;\n}\n']",,,"['combinatorics', 'dp', 'implementation']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Riding in a Lift.json,https://codeforces.com//blog/entry/14351,The task is solved by a dynamic programming State is a pair where is the number of trips made and is the current floor Initial state is final states are where is any floor except It is easy to see the transitions to calculate let s see what can be the previous floor It turns out that all possible previous floors form a contiguous segment with a hole at position because we can t visit the same floor twice in a row So is almost equal to the sum of values where belongs to some segment the values of and can be easily derived from the conditions from the problem statement Using pretty standard technique called partial sums we can compute in so overall complexity is Jury solution 8322623 
https://codeforces.com//contest/1092/problem/C,271421,C,1092C,1092,C. Prefixes and Suffixes,Ivan wants to play a game with you He picked some string s of length n consisting only of lowercase Latin letters You don t know this string Ivan has informed you about all its improper prefixes and suffixes i e prefixes and suffixes of lengths from 1 to n 1 but he didn t tell you which strings are prefixes and which are suffixes Ivan wants you to guess which of the given 2n 2 strings are prefixes of the given string and which are suffixes It may be impossible to guess the string Ivan picked since multiple strings may give the same set of suffixes and prefixes but Ivan will accept your answer if there is at least one string that is consistent with it Let the game begin ,"['#include<bits/stdc++.h>\nusing namespace std;\nstruct AA{\n    string s;\n    int id;\n    bool operator<(const AA& b)const{\n        return s.size()<b.s.size();\n    }\n}a[222];\nchar an[222];\nint n;\nvoid check(string s){\n    vector<pair<pair<int,string>,int>>ker;\n    for(int i=1;i<(int)s.size();i++){\n        ker.push_back({{i+1,s.substr(0,i)},0});\n        ker.push_back({{i+1,s.substr(n-i)},1});\n    }\n    sort(ker.begin(),ker.end());\n    for(int i=0;i<n*2-2;i+=2){\n        if(a[i].s==ker[i].first.second&&a[i+1].s==ker[i+1].first.second){\n            an[a[i].id]=ker[i].second?\'S\':\'P\';\n            an[a[i+1].id]=ker[i+1].second?\'S\':\'P\';\n        }\n        else if(a[i].s==ker[i+1].first.second&&a[i+1].s==ker[i].first.second){\n            an[a[i].id]=ker[i+1].second?\'S\':\'P\';\n            an[a[i+1].id]=ker[i].second?\'S\':\'P\';\n        }\n        else return;\n    }\n    printf(""%s\\n"",an);\n    exit(0);\n}\nint main(){\n    scanf(""%d"",&n);\n    for(int i=0;i<n*2-2;i++){\n        cin>>a[i].s;\n        a[i].id=i;\n    }\n    sort(a,a+n*2-2);\n    check(a[n*2-3].s+a[n*2-4].s.back());\n    check(a[n*2-4].s+a[n*2-3].s.back());\n    return 0;\n}\n']",,,['strings'],1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Prefixes and Suffixes.json,https://codeforces.com//blog/entry/63961,The first observation if we will take two strings of length then we can restore the initial string Why Because there are two possible options when the first string of length is a prefix and the second one is the suffix and vice versa Let s write a function which will check if the first string can be the prefix of the guessed string and the second one can be the suffix After we write this function we can run it two times depending on the order of strings of length and find any suitable answer If the first string is the prefix and the second one is the suffix then the whole string indexed where is the concatenation of strings Let s check if we have all prefixes and suffixes of this string in the input We can easy do it with two nested loops and some boolean array which can say us if some string is already used or not Firstly let s iterate over the length of the prefix or suffix and inside let s find any string from the input matching to the current prefix or suffix If we find all strings then the current string is one of the guessed and we can print the answer 
https://codeforces.com//contest/2036/problem/C,2997670,C,2036C,2036,C. Anya and 1100,While rummaging through things in a distant drawer Anya found a beautiful string s consisting only of zeros and ones Now she wants to make it even more beautiful by performing q operations on it Each operation is described by two integers i 1 le i le s and v v in 0 1 and means that the i th character of the string is assigned the value v that is the assignment s i v is performed But Anya loves the number 1100 so after each query she asks you to tell her whether the substring is present in her string i e there exist such 1 le i le s 3 that s i s i 1 s i 2 s i 3 texttt 1100 ,"['#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;const int N = 3e5 + 10;void solve() {\tstring s;\tcin >> s;\tint n = (int)s.size();\ts = ""#"" + s;\tint x = 0;\tfor (int i = 1; i <= n - 3; i++) {\t\tif (s[i] == \'1\' && s[i + 1] == \'1\' && s[i + 2] == \'0\' && s[i + 3] == \'0\') x++;\t}\tint q;\tcin >> q;\twhile (q--) {\t\tint pos;\t\tchar e;\t\tcin >> pos >> e;\t\tfor (int i = max(pos - 3, 1); i <= min(pos, n - 3); i++) {\t\t\tif (s[i] == \'1\' && s[i + 1] == \'1\' && s[i + 2] == \'0\' && s[i + 3] == \'0\') x--;\t\t}\t\ts[pos] = e;\t\tfor (int i = max(pos - 3, 1); i <= min(pos, n - 3); i++) {\t\t\tif (s[i] == \'1\' && s[i + 1] == \'1\' && s[i + 2] == \'0\' && s[i + 3] == \'0\') x++;\t\t}\t\tif (x) cout << ""YES\\n"";\t\telse cout << ""NO\\n"";\t}}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}']",,,"['brute force', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Anya and 1100.json,https://codeforces.com//blog/entry/135849,TutorialFirst in a naive way let s count the number of times 1100 occurs in Then for each of queries we will update consider the substring before changing and find the number of times that 1100 occurs in it Then update and similarly find the number of times that 1100 occurs in after applying the query Thus by doing we get the number of times that 1100 occurs in after the query is applied If the answer to the query is YES otherwise it is NO Complexity 
https://codeforces.com//contest/1854/problem/D,2119350,D,1854D,1854,D. Michael and Hotel,Michael and Brian are stuck in a hotel with n rooms numbered from 1 to n and need to find each other But this hotel s doors are all locked and the only way of getting around is by using the teleporters in each room Room i has a teleporter that will take you to room a i it might be that a i i But they don t know the values of a 1 a 2 dots a n Instead they can call up the front desk to ask queries In one query they give a room u a positive integer k and a set of rooms S The hotel concierge answers whether a person starting in room u and using the teleporters k times ends up in a room in S Brian is in room 1 Michael wants to know the set A of rooms so that if he starts in one of those rooms they can use the teleporters to meet up He can ask at most 2000 queries The values a 1 a 2 dots a n are fixed before the start of the interaction and do not depend on your queries In other words the interactor is not adaptive ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\n\nint n;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint jeszcze=2000;\n\nint pyt(int v, int k, vi wek)\n{\n\tjeszcze--;\n\tif (jeszcze<0)\n\t\twhile(1);\n\tprintf(""? %d %d %d"", v, k, (int)wek.size());\n\tfor (int i : wek)\n\t\tprintf("" %d"", i);\n\tprintf(""\\n"");\n\tff();\n\tint ret;\n\tscanf(""%d"", &ret);\n\treturn ret;\n}\n\nvoid ans(vi wek)\n{\n\tprintf(""! %d"", (int)wek.size());\n\tfor (int i : wek)\n\t\tprintf("" %d"", i);\n\tprintf(""\\n"");\n\tff();\n\texit(0);\n}\n\nvi przedzial(int a, int b)\n{\n\tvi ret;\n\tfor (int i=a; i<=b; i++)\n\t\tret.push_back(i);\n\treturn ret;\n}\n\nint dobre[nax];\n\nvi daj_dobre()\n{\n\tvi ret;\n\tfor (int i=1; i<=n; i++)\n\t\tif (dobre[i])\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tint bsa=1;\n\tint bsb=n;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb)/2;\n\t\tvi tu=przedzial(bsa, bss);\n\t\tif (pyt(1, n, tu))\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\tint c=bsa;\n\tdobre[c]=1;\n\tint u=c;\n\tint urwane=0;\n\tfor (int h=1; h<=130; h++)\n\t{\n\t\tbsa=1;\n\t\tbsb=n;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb)/2;\n\t\t\tvi tu=przedzial(bsa, bss);\n\t\t\tif (pyt(u, 1, tu))\n\t\t\t\tbsb=bss;\n\t\t\telse\n\t\t\t\tbsa=bss+1;\n\t\t}\n\t\tdobre[bsa]=1;\n\t\tu=bsa;\n\t\t//~ debug() << imie(u);\n\t\tif (u==c)\n\t\t{\n\t\t\turwane=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tif (!dobre[i] && pyt(i, 128, daj_dobre()))\n\t\t\tdobre[i]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!dobre[i] && pyt(i, urwane ? n : 253, daj_dobre()))\n\t\t\tdobre[i]=1;\n\tans(daj_dobre());\n\treturn 0;\n}\n']",,,"['binary search', 'interactive', 'trees']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Michael and Hotel.json,https://codeforces.com//blog/entry/118540,Solution The component with node contains a cycle If you know the whole cycle of length you can win in queries by asking for each node if it ends up in the cycle after moves You can get a node in the cycle in queries doing a binary search on the th successor of node How to find the rest of the cycle First find nodes in the cycle doing a binary search on the successor of the last node found These nodes make a set Then check for each node if it s sufficiently close to by asking Now you know either nodes in the cycle or the whole cycle Repeat until you get the whole cycle If you choose you spend at most queries 
https://codeforces.com//contest/2014/problem/H,2892480,H,2014H,2014,H. Robin Hood Archery,Sheriff of Nottingham has organized a tournament in archery It s the final round and Robin Hood is playing against Sheriff There are n targets in a row numbered from 1 to n When a player shoots target i their score increases by a i and the target i is destroyed The game consists of turns and players alternate between whose turn it is Robin Hood always starts the game then Sheriff and so on The game continues until all targets are destroyed Both players start with score 0 At the end of the game the player with most score wins and the other player loses If both players have the same score it s a tie and no one wins or loses In each turn the player can shoot any target that wasn t shot before Both play optimally to get the most score possible Sheriff of Nottingham has a suspicion that he might lose the game This cannot happen you must help Sheriff Sheriff will pose q queries each specifying l and r This means that the game would be played only with targets l l 1 dots r as others would be removed by Sheriff before the game starts For each query l r determine whether the Sheriff can the game when only considering the targets l l 1 dots r ,"['#include <bits/stdc++.h>using namespace std;#define int long long#define endl \'\\n\'#define PII pair<int, int>const int N = 1e6 + 5;const int mod = 1e9 + 7;int n, m, a[N], pre1[N], pre2[N], hs1[N], hs2[N];mt19937 rnd(time(0));void init(){    for (int i = 1; i <= 1e6; i++)        hs1[i] = rnd(), hs2[i] = rnd();}void solve(){    cin >> n >> m;    for (int i = 1; i <= n; i++)        cin >> a[i], pre1[i] = pre1[i - 1] ^ hs1[a[i]], pre2[i] = pre2[i - 1] ^ hs2[a[i]];    while (m--)    {        int l, r;        cin >> l >> r;        if (pre1[r] == pre1[l - 1] && pre2[r] == pre2[l - 1])            cout << ""YES\\n"";        else            cout << ""NO\\n"";    }}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    init();    cin >> t;    while (t--)        solve();    return 0;}']",,,"['data structures', 'divide and conquer', 'greedy', 'hashing']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\H. Robin Hood Archery.json,https://codeforces.com/blog/entry/134093,Sheriff can never win This is quite obvious as Robin is the first to pick and both just keep picking the current biggest number This means that Sheriff can at best get a tie this happens if and only if all elements have even appearance The segment al ar is a tie if and only if there s no element that appears an odd number of times There are multiple ways to solve this problem Two are outlined Mo s algorithm offline We can keep the count of appearances of each element using an array in O 1 time Sort the queries into blocks of size n Keep updating the boundaries of the current segment and the total count of elements that appear an odd number of times Sheriff can tie iff there is no odd appearance Time complexity O n q n Xor hashing Consider the prefixes of all targets If the current segment is al ar there s no element with odd appearance if and only if the set of numbers with odd appearance in a1 al 1 is the same as a1 ar We can check if two prefixes have the same set of elements with odd appearance with xor hashing Time complexity O n q 
https://codeforces.com//contest/1933/problem/F,2499502,F,1933F,1933,F. Turtle Mission  Robot and the Earthquake,The world is a grid with n rows and m columns The rows are numbered 0 1 ldots n 1 while the columns are numbered 0 1 ldots m 1 In this world the columns are i e the top and the bottom cells in each column are adjacent The cell on the i th row and the j th column 0 le i n 0 le j m is denoted as i j the cell i j where 0 le i n 0 le j m contains either a or The state of cell i j can be described using the integer a i j If a i j 1 there is a rock at i j If a i j 0 there is nothing at i j As a result of aftershocks from the earthquake the columns follow tectonic plate movements each column moves cyclically at a velocity of 1 cell per unit of time Formally for some 0 le i n 0 le j m if i j contains a rock at the moment it will move from i j to i 1 j or to n 1 j if i 0 The robot called RT is initially positioned at 0 0 It has to go to n 1 m 1 to carry out an earthquake rescue operation to the bottom rightmost cell The earthquake doesn t change the position of the robot they only change the position of rocks in the world Let RT s current position be x y 0 le x n 0 le y m it can perform the following operations Go one cell cyclically upwards i e from x y to x n 1 bmod n y using 1 unit of time Go one cell cyclically downwards i e x y to x 1 bmod n y using 1 unit of time Go one cell to the right i e x y to x y 1 using 1 unit of time RT may perform this operation only if y m 1 Unfortunately RT will explode upon colliding with a rock As such when RT is at x y and there is a rock at x 1 bmod n y or x 2 bmod n y RT cannot move down or it will be hit by the rock Similarly if y 1 m and there is a rock at x 1 bmod n y 1 RT cannot move right or it will be hit by the rock However it is worth noting that if there is a rock at x bmod n y 1 and x 1 bmod n y RT can still move right safely Find the minimum amount of time RT needs to reach n 1 m 1 without colliding with any rocks If it is impossible to do so output 1 ,"['/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e3+10;\nint n,m;\nint a[N][N],dp[N][N];\nvoid leeminhduc2()\n{\n    cin >> n >> m;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<m;j++)\n            {\n                cin >> a[i][j];\n                dp[i][j]=-1;\n            }\n    dp[0][0]=0ll;\n    queue<ii> q;\n    q.push({0,0});\n    while (sz(q))\n    {\n        \n        auto [u,v]=q.front(); q.pop();\n        \n        if (dp[(u+2)%n][v]==-1&&a[(u+1)%n][v]==0&&a[(u+2)%n][v]==0)\n        {\n            dp[(u+2)%n][v]=dp[u][v]+1;\n            q.push({(u+2)%n,v});\n        }\n        if (v<m-1&&dp[(u+1)%n][(v+1)]==-1&&a[(u+1)%n][(v+1)]==0)\n        {\n            dp[(u+1)%n][(v+1)]=dp[u][v]+1;\n            q.push({(u+1)%n,(v+1)});\n        }\n    }\n    \n     \n    int res=1e9;\n    for (int i=0;i<n;i++) if (dp[i][m-1]!=-1)\n    {\n        int cur=(i-dp[i][m-1]%n+n)%n;\n       \n        if (cur==n-1) res=min(res,dp[i][m-1]);\n        else res=min(res,dp[i][m-1]+cur+1);\n    }\n    if (res==1e9) cout << ""-1\\n"";\n    else cout << res << ""\\n"";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n']",,,"['dfs and similar', 'dp', 'graphs', 'shortest paths']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Turtle Mission  Robot and the Earthquake.json,https://codeforces.com//blog/entry/126560,By viewing the robot s movement relative to the rocks Robot RT s three moves become as follows Up Stationary Down to Right to As staying stationary is not necessary now when we are finding the minimum time we can run a bfs dp from to find the minimum time required to reach every grid in the second last column Finally choose the best among all n tiles after waiting for the endpoint to cycle back 
https://codeforces.com//contest/1592/problem/D,1129222,D,1592D,1592,D. Hemose in ICPC  ,Zeyad knows that Hemose loves tree problems so he gave him a tree problem with a very special device Hemose has a weighted tree with n nodes and n 1 edges Unfortunately Hemose doesn t remember the weights of edges Let s define Dist u v for u neq v as the greatest common divisor of the weights of all edges on the path from node u to node v Hemose has a special device Hemose can give the device a set of nodes and the device will return the largest Dist between any two nodes from the set More formally if Hemose gives the device a set S of nodes the device will return the largest value of Dist u v over all pairs u v with u v in S and u neq v Hemose can use this Device and wants to find any two distinct nodes a b such that Dist a b is maximum possible Can you help him ,"['#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,l,sz[1005],vv[1005];\nint cnt,cur,c;\nint hd[1005],nxt[2005],to[2005],tot=1,vis[2005];\nvector<int> qry,edg;\nvoid add(int x,int y)\n{\n\ttot++;nxt[tot]=hd[x];to[tot]=y;hd[x]=tot;\n}\nvoid dfs(int x,int fa)\n{\n\tvv[x]=sz[x]=1;\n\tif(fa&&(cur+1)*2<=cnt)\n\t{\n\t\tc=1;\n\t\tcur++;edg.push_back(fa/2);\n\t\tqry.push_back(x);\n\t}\n\tint i;\n\tfor(i=hd[x];i;i=nxt[i])if(i/2!=fa/2&&!vis[i/2])\n\t{\n\t\tdfs(to[i],i);\n\t}\n\tif(c&&!fa) qry.push_back(x);\n}\nvoid solve()\n{\n\tcin>>n;\n\trep(i,n-1)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tcout<<""? ""<<n;rep(i,n)cout<<\' \'<<i;cout<<endl<<flush;\n\tint mx;cin>>mx;\n\twhile(1)\n\t{\n\t\tcnt=cur=0;\n\t\trep(i,n-1) cnt+=!vis[i];\n\t\tif(cnt==1) break;\n\t\tmemset(vv,0,sizeof(vv));\n\t\tqry.clear();edg.clear();\n\t\trep(i,n) if(!vv[i]) c=0,dfs(i,0);\n\t\tcout<<""? ""<<qry.size();\n\t\tfor(int i=0;i<qry.size();i++)\n\t\t{\n\t\t\tcout<<\' \'<<qry[i];\n\t\t}\n\t\tcout<<endl<<flush;\n\t\tint tmp;cin>>tmp;\n\t\tif(tmp==mx)\n\t\t{\n\t\t\trep(i,n-1) vis[i]=1;\n\t\t\tfor(int i=0;i<edg.size();i++) vis[edg[i]]=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<edg.size();i++) vis[edg[i]]=1;\n\t\t}\n\t}\n\trep(i,n-1) if(!vis[i])\n\t{\n\t\tcout<<""! ""<<to[i*2]<<\' \'<<to[i*2+1]<<endl<<flush;\n\t}\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}']",,,"['binary search', 'dfs and similar', 'implementation', 'interactive', 'math', 'number theory', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Hemose in ICPC  .json,https://codeforces.com//blog/entry/95583,The maximum gcd of a path equals the maximum weight of an edge in the tree Let be the value of the maximum weight of an edge in the tree We need to find such that there s an edge between and with weight equals Let s find by putting all the nodes in the same query Now we need to find If we have an array of edges such that for any consecutive subarray The component of nodes inside the subarray is connected using the edges inside the subarray Then we can binary search on this array to find the edge with the maximum weight If we put the edges in the array using the order of Euler tour traversal the array will satisfy the condition above and we can solve the problem Total number of queries is 
https://codeforces.com//contest/482/problem/E,15992,E,482E,482,E. ELCA,You have a root tree containing vertexes Let s number the tree vertexes with integers from to The tree root is in the vertex Each vertex except fot the tree root has a direct ancestor Also each vertex has its integer value Your task is to perform following queries If isn t in subtree of you must perform the assignment Otherwise you must perform assignment Note that after this query the graph continues to be a tree consisting of vertexes Perform assignment Your task is following Before starting performing queries and after each query you have to calculate expected value written on the lowest common ancestor of two equiprobably selected vertices and Here lowest common ancestor of and is the deepest vertex that lies on the both of the path from the root to vertex and the path from the root to vertex Please note that the vertices and can be the same in this case their lowest common ancestor coincides with them ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 200010;\nconst int BLOCK = 350;\n\nvector <int> g[N];\nint pv[N];\nint value[N];\nlong long coeff[N];\nbool imp[N];\nint down[N];\nlong long change[N], total[N];\nint up[N];\nlong long sz[N];\nint depth[N];\nlong long ans;\n\nvoid dfs(int v) {\n  coeff[v] = 0;\n  sz[v] = 1;\n  down[v] = -1;\n  int only = -1;\n  for (int j = 0; j < (int)g[v].size(); j++) {\n    int u = g[v][j];\n    depth[u] = depth[v] + 1;\n    dfs(u);\n    sz[v] += sz[u];\n    coeff[v] -= sz[u] * sz[u];\n    if (down[u] != -1) {\n      if (down[v] == -1) {\n        down[v] = down[u];\n        only = u;\n      } else {\n        imp[v] = true;\n      }\n    }\n  }\n  if (imp[v]) {\n    down[v] = v;\n  }\n  coeff[v] += sz[v] * sz[v];\n  ans += value[v] * coeff[v];\n  if (!imp[v] && only != -1) {\n    change[v] = (sz[v] + 1) * (sz[v] + 1) - sz[v] * sz[v];\n    change[v] -= (sz[only] + 1) * (sz[only] + 1) - sz[only] * sz[only];\n    change[v] *= value[v];\n  } else {\n    change[v] = 0;\n  }\n}\n\nchar op[N];\nint arg1[N], arg2[N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 1; i <= n; i++) {\n    g[i].clear();\n  }\n  pv[1] = -1;\n  for (int i = 2; i <= n; i++) {\n    scanf(""%d"", pv + i);\n    g[pv[i]].push_back(i);\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(""%d"", value + i);\n  }\n  int tt;\n  scanf(""%d"", &tt);\n  for (int qq = 1; qq <= tt; qq++) {\n    char ch = getchar();\n    while (ch != \'P\' && ch != \'V\') {\n      ch = getchar();\n    }\n    op[qq] = ch;\n    scanf(""%d %d"", arg1 + qq, arg2 + qq);\n  }\n  int next_q = 1;\n  while (next_q <= tt) {\n    int last_q = next_q + BLOCK - 1;\n    if (last_q > tt) {\n      last_q = tt;\n    }\n    for (int i = 1; i <= n; i++) {\n      imp[i] = false;\n    }\n    for (int qq = next_q; qq <= last_q; qq++) {\n      if (op[qq] == \'P\') {\n        imp[arg1[qq]] = true;\n        imp[arg2[qq]] = true;\n      } else {\n        imp[arg1[qq]] = true;\n      }\n    }\n    ans = 0;\n    depth[1] = 0;\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n      up[i] = i;\n      total[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n      if (down[i] != -1) {\n        total[down[i]] += change[i];\n        if (depth[i] < depth[up[down[i]]]) {\n          up[down[i]] = i;\n        }\n      }\n    }\n    if (next_q == 1) {\n      printf(""%.15lf\\n"", (double)(1.0 * ans / n / n));\n    }\n    for (int qq = next_q; qq <= last_q; qq++) {\n      if (op[qq] == \'P\') {\n        int v = arg1[qq];\n        int u = arg2[qq];\n        int z = u;\n        while (z != v && z != -1) {\n          z = pv[up[z]];\n        }\n        if (z == v) {\n          swap(u, v);\n        }\n        {\n          int z = v;\n          while (z != -1) {\n            ans -= total[z] * sz[v];\n            int new_z = pv[up[z]];\n            if (new_z == -1) {\n              break;\n            }\n            ans -= coeff[new_z] * value[new_z];\n            coeff[new_z] -= sz[new_z] * sz[new_z];\n            sz[new_z] -= sz[v];\n            coeff[new_z] += sz[new_z] * sz[new_z];\n            if (up[z] != z) {\n              coeff[new_z] += sz[up[z]] * sz[up[z]];\n              sz[up[z]] -= sz[v];\n              coeff[new_z] -= sz[up[z]] * sz[up[z]];\n            } else {\n              if (z != v) {\n                coeff[new_z] += (sz[up[z]] + sz[v]) * (sz[up[z]] + sz[v]);\n                coeff[new_z] -= sz[up[z]] * sz[up[z]];\n              } else {\n                coeff[new_z] += sz[up[z]] * sz[up[z]];\n              }\n            }\n            ans += coeff[new_z] * value[new_z];\n            z = new_z;\n          }\n        }\n        {\n          ans -= coeff[u] * value[u];\n          coeff[u] -= sz[u] * sz[u];\n          sz[u] += sz[v];\n          coeff[u] += sz[u] * sz[u];\n          coeff[u] -= sz[v] * sz[v];\n          ans += coeff[u] * value[u];\n        }\n        {\n          int z = u;\n          while (z != -1) {\n            ans += total[z] * sz[v];\n            int new_z = pv[up[z]];\n            if (new_z == -1) {\n              break;\n            }\n            ans -= coeff[new_z] * value[new_z];\n            coeff[new_z] -= sz[new_z] * sz[new_z];\n            sz[new_z] += sz[v];\n            coeff[new_z] += sz[new_z] * sz[new_z];\n            if (up[z] != z) {\n              coeff[new_z] += sz[up[z]] * sz[up[z]];\n              sz[up[z]] += sz[v];\n              coeff[new_z] -= sz[up[z]] * sz[up[z]];\n            } else {\n              coeff[new_z] += (sz[up[z]] - sz[v]) * (sz[up[z]] - sz[v]);\n              coeff[new_z] -= sz[up[z]] * sz[up[z]];\n            }\n            ans += coeff[new_z] * value[new_z];\n            z = new_z;\n          }\n        }\n        pv[v] = u;\n        total[v] = 0;\n        up[v] = v;\n      } else {\n        int v = arg1[qq];\n        ans += (arg2[qq] - value[v]) * coeff[v];\n        value[v] = arg2[qq];\n      }\n      printf(""%.15lf\\n"", (double)(1.0 * ans / n / n));\n    }\n    for (int i = 1; i <= n; i++) {\n      g[i].clear();\n    }\n    for (int i = 2; i <= n; i++) {\n      g[pv[i]].push_back(i);\n    }\n    next_q = last_q + 1;\n  }\n  return 0;\n}\n']",,,"['data structures', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. ELCA.json,https://codeforces.com//blog/entry/14417,Let s split all requests in blocks containing requests each Every block will be processed following way First using dfs we need to calculate for every vertex where is every ancestor of size of subtree of vertex including itself This value shows how will the answer change after removing or adding vertex as child to any other vertex furthermore answer will change exactly by decreasing or increasing Then we will calculate the same way the number of all possible vertex pairs which have LCA in vertex This value shows how the answer changes after changing if changes by answer changes by Then mark all vertexes which occur in our block at least once in worst case their number is Next mark every vertex being LCA of some pair of already marked vertexes using DFS We can prove that final number of these vertexes is at most After all this we got compressed tree containing only needed vertexes Parent of vertex in compressed tree we will call vertex numbered On the image above example of this compression way is given Vertexes colored red are vertexes in request block blue vertexes marked after LCA dotted line edges in compressed tree On such compressed tree we need to calculate one new value for every vertex the size of a vertex lying on a way from to after on main non compressed tree son of a vertex in main tree Now we should process request on changing parent of vertex from to on a compressed tree The answer will change by Now for every vertex lying on a way from root to vertex two values will change will be decreased by but will be decreased by but will stay unchanged For every other vertex only will be changed it will be decreased by After that we got compressed subtree where subtree of a vertex is missing Next doing the same way as above all values are changed considering that and all it s subtree is a children of a vertex Do not forget to change too Let s see how the value changing request of a vertex is to be processed As described above the answer will be changed by For every vertex lying in vertex subtree only will be changed it could be easy done using values all other values stay unchanged This solution has complexity but in case it has to be 8394944 
https://codeforces.com//contest/361/problem/B,3924,B,361B,361,B. Levko and Permutation,Levko loves permutations very much A permutation of length is a sequence of distinct positive integers each is at most Let s assume that value shows the greatest common divisor of numbers and Levko assumes that element of permutation is good if Levko considers a permutation if it has exactly good elements Unfortunately he doesn t know any beautiful permutation Your task is to help him to find at least one of them ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <memory.h>\n#include <time.h>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nint a[222222];\n\nint main(){\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    ios_base::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    if (n==m){\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 1; i<=n; i++) a[i]=i;\n    int j = 1 + m + 1;\n    while (j+1<=n)\n        {\n            swap(a[j],a[j+1]);\n            j+=2;\n        }\n    if (j==n) swap(a[1],a[n]);\n    for (int i = 1; i<=n; i++) cout << a[i] << "" ""; cout << endl;\n    return 0;\n}\n']",,,"['constructive algorithms', 'math', 'number theory']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Levko and Permutation.json,https://codeforces.com//blog/entry/9529, so if there is no suitable permutation It is well known that Lets construct following permutation It has exactly good elements 
https://codeforces.com//contest/449/problem/A,11565,A,449A,449,A. Jzzhu and Chocolate,Jzzhu has a big rectangular chocolate bar that consists of unit squares He wants to cut this bar exactly times Each cut must meet the following requirements each cut should be straight horizontal or vertical each cut should go along edges of unit squares it is prohibited to divide any unit chocolate square with cut each cut should go inside the whole chocolate bar and all cuts must be distinct The picture below shows a possible way to cut a chocolate for times Imagine Jzzhu have made cuts and the big chocolate is splitted into several pieces Consider the smallest by area piece of the chocolate Jzzhu wants this piece to be as large as possible What is the maximum possible area of smallest piece he can get with exactly cuts The area of a chocolate piece is the number of unit squares in it ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000009\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64;\n\ni64 N, M, K;\n\ni64 solve(i64 X)\n{\n\tif (X >= N || (K-X) >= M) return -1;\n\tif(X < 0 || K-X < 0) return -1;\n\n\treturn (N/(X+1)) * (M/(K-X+1));\n}\n\nint main()\n{\n\tcin >> N >> M >> K;\n\n\tif (N+M-2 < K) {\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\n\ti64 ret = 0;\n\tfor(int i=0;i<=100000;i++) {\n\t\tret = max(ret, solve(i));\n\t\tif(i>0) ret = max(ret, solve(min(K, N / i - 1)));\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}\n']",,,"['greedy', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Jzzhu and Chocolate.json,https://codeforces.com//blog/entry/13112,We assume that if we can simply swap and If we finally cut the chocolate into rows and columns we should maximize the narrowest row and maximize the narrowest column so the answer will be There are two algorithms to find the optimal Notice that if is smaller the answer usually will be better Then we can find that if the optimal can only be or If the optimal can only be If the optimal can only be because let has at most values so we can enum it and choose the maximum for each value 
https://codeforces.com//contest/1909/problem/F1,2393926,F1,1909F1,1909,F1. Small Permutation Problem  Easy Version ,You are given an integer n and an array a 1 a 2 dots a n of integers in the range 0 n A permutation p 1 p 2 dots p n of 1 2 dots n is good if for each i the following condition is true the number of values leq i in p 1 p 2 dots p i is exactly a i Count the good permutations of 1 2 dots n modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//対角線を超えず (x,y) に至る方法の数\nmint catalan(int x,int y){\n\tassert(y<=x);\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n//y=x+c を超えず (x,y) に至る方法の数\nmint catalan(int x,int y,int c){\n\tassert(y<=x+c);\n\treturn binom(x,y)-binom(x+c+1,y-c-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tif(!is_sorted(all(a))||a[n-1]<n)return print(0);\n\tint pre=0;\n\tmint ans=1;\n\trep(i,n){\n\t\tint dif=a[i]-pre;\n\t\tmint w=1;\n\t\tif(dif==0){\n\t\t\t//do nothing\n\t\t}else if(dif==1){\n\t\t\tw=1+(i-pre)*2;\n\t\t}else if(dif==2){\n\t\t\tw=(i-pre)*(i-pre);\n\t\t}else{\n\t\t\treturn print(0);\n\t\t}\n\t\tans*=w;\n\t\tpre=a[i];\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']",,,"['brute force', 'combinatorics', 'dp', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F1. Small Permutation Problem  Easy Version .json,https://codeforces.com//blog/entry/123584,SolutionDraw a grid with tokens in Consider any and the nearest on the left if it does not exist let s set Then there must be tokens in the subgrid We can suppose we have already inserted the tokens in and we have to insert tokens in the remaining cells of they make an L shape WLOG the tokens in are in the cells Then we can put tokens in the blue cells in the picture PictureThe blue shape can be further split into these two rectangles PictureIterate over the number of tokens in the first rectangle Then you have to insert tokens into a rectangle and the remaining tokens into a rectangle The number of ways to insert tokens into a rectangle is equal to the product of the number of ways to choose rows the number of ways to choose columns and the number of ways to fill the resulting subgrid the result is automatically if and the answer is If the non negative are non decreasing the sum of the i e the over which you have to iterate is so the algorithm is efficient enough Otherwise the answer is Complexity 
https://codeforces.com//contest/22/problem/B,100,B,22B,22,B. Bargaining Table,Bob wants to put a new bargaining table in his office To do so he measured the office room thoroughly and drew its plan Bob s office room is a rectangular room meters Each square meter of the room is either occupied by some furniture or free A bargaining table is rectangular and should be placed so that its sides are parallel to the office walls Bob doesn t want to change or rearrange anything that s why all the squares that will be occupied by the table should be initially free Bob wants the new table to sit as many people as possible thus its perimeter should be maximal Help Bob find out the maximum possible perimeter of a bargaining table for his office ,"[""#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main(){\n   \n    int n,m;\n    cin>>n>>m;\n    int a[50][50];\n    int b[50][50];\n    char ch;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            cin>>ch;\n            a[i][j]=ch-'0';\n            b[i][j]=a[i][j];\n        }\n    }\n    for(int i=1; i<m; i++){\n        b[0][i]+=b[0][i-1];\n    }\n    for(int i=1; i<n; i++){\n        b[i][0]+=b[i-1][0];\n    }\n    for(int i=1; i<n; i++){\n        for(int j=1; j<m; j++){\n            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n        }\n    }\n    int mx=0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            for(int x=i; x<n; x++){\n                for(int y=j; y<m; y++){\n                    int t=b[x][y];\n                    if(i-1>=0){\n                        t-=b[i-1][y];\n                    }\n                    if(j-1>=0){\n                        t-=b[x][j-1];\n                    }\n                    if(i-1>=0 && j-1>=0){\n                        t+=b[i-1][j-1];\n                    }\n                    if(t==0){\n                        mx=max(mx,2*(x-i+1+y-j+1));\n                    }\n                }\n            }\n        }\n    }\n    cout<<mx;\n    return 0;\n}""]",,,"['brute force', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Bargaining Table.json,https://codeforces.com//blog/entry/507,In this problem one should find the maximal perimeter of a rectangle that contains no 1 Define these rectangles correct To solve a problem you are to check each possible rectangle for correctness and calculate its perimeter The easiest way to check all rectangles is using 6 nested cycles Using 4 of them you fix the coordinates while other 2 will look for 1 So the complexity is O n m 3 It seems slow but those who wrote such a solution says that it hasn t any problems with TL One may interest in much faster solution Using simple DP solution one can get a solution with an O n m 2 complexity It s clear that rectangle with coordinates x1 y1 x2 y2 is correct if and only if rectangles x1 y1 x2 1 y2 and x1 y1 x2 y2 1 are correct and board x2 y2 0 So each of rectangles can be checked in O 1 and totally there will be O n m 2 operations 
https://codeforces.com//contest/670/problem/B,59595,B,670B,670,B. Game of Robots,In late autumn evening robots gathered in the cheerful company of friends Each robot has a unique identifier an integer from to At some moment robots decided to play the game Snowball Below there are the rules of this game First all robots stand in a row Then the first robot says his identifier After that the second robot says the identifier of the first robot and then says his own identifier Then the third robot says the identifier of the first robot then says the identifier of the second robot and after that says his own This process continues from left to right until the th robot says his identifier Your task is to determine the th identifier to be pronounced ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nint main() {\n\n   // freopen(""input.txt"", ""r"", stdin);\n //   freopen(""output.txt"", ""w"", stdout);\n\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n\n    vector <int> a(n);\n    for (int i =0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    int i = 0;\n    while(k - (i + 1) > 0) {\n        k -= i + 1;\n        i++;\n    }\n    cout << a[k - 1] << \'\\n\';\n    return 0;\n}\n']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Game of Robots.json,https://codeforces.com//blog/entry/44715,To solve this problem we need to brute how many identifiers will called robots in the order from left to right Let s solve this problem in one indexing Let the current robot will call identifiers If let s make and go to the next robot Else we need to print where is the array with robots identifiers and end our algorithm 
https://codeforces.com//contest/2003/problem/A,2836625,A,2003A,2003,A. Turtle and Good Strings,Turtle thinks a string s is a good string if there exists a sequence of strings t 1 t 2 ldots t k k is an arbitrary integer such that k ge 2 s t 1 t 2 ldots t k where represents the concatenation operation For example texttt abc texttt a texttt bc For all 1 le i j le k the first character of t i the last character of t j Turtle is given a string s consisting of lowercase Latin letters Please tell him whether the string s is a good string ,"['#include <bits/stdc++.h>\xa0#define ranges std::ranges#define views std::views\xa0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\xa0using pii = std::pair<int, int>;using a3 = std::array<int, 3>;using a4 = std::array<int, 4>;\xa0const int N = 1e6;const int MAXN = 1e6 + 10;const int inf = 1e9;// const int mod = 1e9 + 7;const int mod = 998244353;\xa0void solve() {    int n;std::cin >> n;    std::string s;std::cin >> s;    std::cout << (s.front() == s.back() ? ""NO"" : ""YES"");}\xa0signed main() {    std::ios::sync_with_stdio(false);    std::cin.tie(0), std::cout.tie(0);    int t;std::cin >> t;    while (t--) {        solve();        std::cout << \'\\n\';    }    return 0;}']",,,"['greedy', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Turtle and Good Strings.json,https://codeforces.com/blog/entry/132953,A necessary condition for to be good is that For a string where let be a string composed of just the single character and let be a string composed of the characters from to In this way the condition is satisfied Therefore if the answer is Yes otherwise the answer is No Time complexity per test case 
https://codeforces.com//contest/1117/problem/D,300044,D,1117D,1117,D. Magic Gems,Reziba has many magic gems Each magic gem can be split into M normal gems The amount of space each magic and normal gem takes is 1 unit A normal gem cannot be split Reziba wants to choose a set of magic gems and split some of them so the total space occupied by the resulting set of gems is N units If a magic gem is chosen and split it takes M units of space since it is split into M gems if a magic gem is not split it takes 1 unit How many different configurations of the resulting set of gems can Reziba have such that the total amount of space taken is N units Print the answer modulo 1000000007 10 9 7 Two configurations are considered different if the number of magic gems Reziba takes to form them differs or the indices of gems Reziba has to split differ ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int MAT=101;\nstruct Mat { ll v[MAT][MAT]; Mat(){ZERO(v);};};\nll mo=1000000007;\n\nMat mulmat(Mat& a,Mat& b,int n=MAT) {\n\tll mo2=4*mo*mo;\n\tint x,y,z; Mat r;\n\tFOR(x,n) FOR(y,n) r.v[x][y]=0;\n\tFOR(x,n) FOR(z,n) FOR(y,n) {\n\t\tr.v[x][y] += a.v[x][z]*b.v[z][y];\n\t\tif(r.v[x][y]>mo2) r.v[x][y] -= mo2;\n\t}\n\tFOR(x,n) FOR(y,n) r.v[x][y]%=mo;\n\treturn r;\n}\n\nMat powmat(ll p,Mat a,int n=MAT) {\n\tint i,x,y; Mat r;\n\tFOR(x,n) FOR(y,n) r.v[x][y]=0;\n\tFOR(i,n) r.v[i][i]=1;\n\twhile(p) {\n\t\tif(p%2) r=mulmat(r,a,n);\n\t\ta=mulmat(a,a,n);\n\t\tp>>=1;\n\t}\n\treturn r;\n}\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nll N,M;\n\nMat A;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\t\n\tif(N<M) return _P(""1\\n"");\n\t\n\tA.v[0][0]=A.v[0][M-1]=1;\n\tfor(i=1;i<M;i++) A.v[i][i-1]=1;\n\tMat B=powmat(N-(M-1),A,M);\n\t\n\tll ret=0;\n\tFOR(i,M) ret+=B.v[0][i];\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']",,,"['dp', 'math', 'matrices']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Magic Gems.json,https://codeforces.com//blog/entry/65365,Let s reformulate the solution to the form of dynamic programming the number of ways to split the gems so that the total amount of space taken is Then there are obvious transitions of either splitting the last gem or not And that can be easily rewritten in such a way that matrix exponentiation becomes the solution Overall complexity 
https://codeforces.com//contest/1634/problem/C,1285095,C,1634C,1634,C. OKEA,People worry that computers will get too smart and take over the world but the real problem is that they re too stupid and they ve already taken over the world Pedro DomingosYou work for a well known department store that uses leading technologies and employs mechanistic work that is robots The department you work in sells n cdot k items The first item costs 1 dollar the second item costs 2 dollars and so on i th item costs i dollars The items are situated on shelves The items form a rectangular grid there are n shelves in total and each shelf contains exactly k items We will denote by a i j the price of j th item counting from the left on the i th shelf 1 le i le n 1 le j le k Occasionally robots get curious and ponder on the following question what is the mean price arithmetic average of items a i l a i l 1 ldots a i r for some shelf i and indices l le r Unfortunately the old robots can only work with whole numbers If the mean price turns out not to be an integer they break down You care about robots welfare You want to arrange the items in such a way that the robots cannot theoretically break Formally you want to choose such a two dimensional array a that Every number from 1 to n cdot k inclusively occurs exactly once For each i l r the mean price of items from l to r on i th shelf is an integer Find out if such an arrangement is possible and if it is give any example of such arrangement ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nint a[555][555];\ninline void solve(){\n\tint n,k;\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<""YES\\n"";\n\t\tfor(int i=1;i<=n;++i)cout<<i<<\'\\n\';\n\t\treturn;\n\t}\n\tif(n%2==1){\n\t\tcout<<""NO\\n"";\n\t\treturn;\n\t}\n\tcout<<""YES\\n"";\n\tfor(int i=1;i<=n;i+=2){\n\t\tint bg=(i-1)*k+1;\n\t\tint tbg=bg+1;\n\t\tfor(int j=1;j<=k;++j)a[i][j]=bg,bg+=2;\n\t\tfor(int j=1;j<=k;++j)a[i+1][j]=tbg,tbg+=2;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=k;++j)cout<<a[i][j]<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}']",,,['constructive algorithms'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. OKEA.json,https://codeforces.com//blog/entry/99563,If you can put items on the shelves in any order Otherwise there are at least 2 items on each shelf If there are items of different parity on the shelf it is obvious that there are two neighboring items of different parity but then the arithmetic mean of these two items won t be whole which is against the constraints Therefore all items on each shelf are of the same parity Notice that if the number of shelves is odd we cannot arrange the items correctly because the number of shelves with even and odd items must be the same that is if Let us show that for even there is always an answer On th shelf we will place items with prices We can use the formula for the sum of an arithmetic progression to compute the sum of prices of a subsegment with coordinates up to The length of the segment always divides this sum since is even Therefore this arrangement fits the requirements of the problem 
https://codeforces.com//contest/29/problem/D,137,D,29D,29,D. Ant on the Tree,Connected undirected graph without cycles is called a tree Trees is a class of graphs which is interesting not only for people but for ants too An ant stands at the root of some tree He sees that there are vertexes in the tree and they are connected by edges so that there is a path between any pair of vertexes A leaf is a distinct from root vertex which is connected with exactly one other vertex The ant wants to visit every vertex in the tree and return to the root passing every edge twice In addition he wants to visit the leaves in a specific order You are to find some possible route of the ant ,"['/*\nID: espr1t\nLANG: C++\nTASK: Demo\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 1024\n\nusing namespace std;\nFILE *in; FILE *out;\n\n\nint n, idx;\nvector <int> order, ans;\nmap < int, int > level;\nmap < int, vector <int> > v;\nmap < int, set <int> > children;\n\nvoid getLevels(int node, int lvl)\n{\n\tlevel[node] = lvl;\n\tfor (int i = 0; i < (int)v[node].size(); i++)\n\t\tif (level.find(v[node][i]) == level.end())\n\t\t\tgetLevels(v[node][i], lvl + 1);\n}\n\nvoid getChildren(int node)\n{\n\tfor (int i = 0; i < (int)v[node].size(); i++)\n\t{\n\t\tif (level[v[node][i]] > level[node])\n\t\t{\n\t\t\tchildren[node].insert(v[node][i]);\n\t\t\tgetChildren(v[node][i]);\n\t\t\tchildren[node].insert(children[v[node][i]].begin(), children[v[node][i]].end());\n\t\t}\n\t}\n}\n\nvoid recurse(int node)\n{\n\tans.push_back(node);\n\tif (ans.size() > (n - 1) * 2 + 1) return;\n\n//\tcout << ""Currently at node "" << node << endl;\n\twhile (idx < (int)order.size())\n\t{\n\t\tint found = 0;\n\t\tif (ans.size() > (n - 1) * 2 + 1) return;\n\t\tfor (int i = 0; i < (int)v[node].size(); i++) if (level[v[node][i]] > level[node])\n\t\t{\n//\t\t\tcout << ""Trying child "" << v[node][i] << endl;\n\t\t\tif (v[node][i] == order[idx])\n\t\t\t{\n\t\t\t\tans.push_back(v[node][i]);\n\t\t\t\tans.push_back(node);\n\t\t\t\tidx++; found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (children[v[node][i]].find(order[idx]) != children[v[node][i]].end())\n\t\t\t\t{\n\t\t\t\t\tfound = 1;\n\t\t\t\t\trecurse(v[node][i]);\n\t\t\t\t\tans.push_back(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found) break;\n\t}\n}\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(""D.in"", ""rt""); out = fopen(""D.out"", ""wt"");\n\t\n\tfscanf(in, ""%d"", &n);\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint n1, n2;\n\t\tfscanf(in, ""%d %d"", &n1, &n2);\n\t\tv[n1].push_back(n2);\n\t\tv[n2].push_back(n1);\n\t}\n\t\n\tgetLevels(1, 0);\n\tgetChildren(1);\n\t\n\t/*\n\tfor (map <int, set <int> > :: iterator it = children.begin(); it != children.end(); it++)\n\t{\n\t\tcout << ""Children for node "" << it->first << "":"";\n\t\tfor (set <int> :: iterator it2 = it->second.begin(); it2 != it->second.end(); it2++)\n\t\t\tcout << "" "" << *it2;\n\t\tcout << endl; \n\t}\n\tsystem(""pause"");\n\t*/\n\n\tint numLeafs = 0;\n\tfor (map < int, set <int> > :: iterator it = children.begin(); it != children.end(); it++)\n\t\tif (it->second.size() == 0) numLeafs++;\n\n\tfor (int i = 0; i < numLeafs; i++)\n\t{\n\t\tint cur;\n\t\tfscanf(in, ""%d"", &cur);\n\t\torder.push_back(cur);\n\t}\n\tidx = 0;\n\trecurse(1);\n\tif (ans.size() != (n - 1) * 2 + 1)\n\t\tfprintf(out, ""-1\\n"");\n\telse\n\t{\n\t\tfor (int i = 0; i < (int)ans.size(); i++)\n\t\t\tfprintf(out, ""%d%c"", ans[i], i + 1 == (int)ans.size() ? \'\\n\' : \' \');\n\t}\n\t/*\n\tcout << ""Found answer:"";\n\tfor (int i = 0; i < (int)ans.size(); i++)\n\t\tcout << "" "" << ans[i]; cout << endl;\n\tsystem(""pause"");\n\t*/\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Ant on the Tree.json,https://codeforces.com//blog/entry/686,First Floyd pretreat the path from I to J and save the path Then get the answer The order is a1 a2 ak K is the number of the leaves we can assume a0 ak 1 1 the root then answer push back the path ai ai 1 if the ans size 2 N 1 cout 1 else cout the answer 
https://codeforces.com//contest/217/problem/A,1607,A,217A,217,A. Ice Skating,Bajtek is learning to skate on ice He s a beginner so his only mode of transportation is pushing off from a snow drift to the north east south or west and sliding until he lands in another snow drift He has noticed that in this way it s impossible to get from some snow drifts to some other by any sequence of moves He now wants to heap up some additional snow drifts so that he can get from any snow drift to any other one He asked you to find the minimal number of snow drifts that need to be created We assume that Bajtek can only heap up snow drifts at integer coordinates ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint x[110],y[110];\nbool graph[110][110];\n\nint main(void){\n    int N,i,j,k;\n    \n    cin >> N;\n    REP(i,N) cin >> x[i] >> y[i];\n    \n    REP(i,N) graph[i][i] = true;\n    REP(i,N) REP(j,N) if(x[i] == x[j] || y[i] == y[j]) graph[i][j] = graph[j][i] = true;\n    REP(k,N) REP(i,N) REP(j,N) if(graph[i][k] && graph[k][j]) graph[i][j] = true;\n    \n    int comp = 0;\n    REP(i,N){\n        bool root = true;\n        REP(j,i) if(graph[i][j]) root = false;\n        if(root) comp++;\n    }\n    \n    cout << comp - 1 << endl;\n    \n    return 0;\n}\n']",,,"['brute force', 'dfs and similar', 'dsu', 'graphs']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Ice Skating.json,https://codeforces.com//blog/entry/5285,Notice that the existence of a snow drift at the point x y implies that if I m on the horizontal line at y then I am certainly able to get to the vertical line at x and vice versa Thus the snow drifts are the edges of a bipartite graph between x and y coordinates The number of snow drifts that need to be added to make this as well as the original graph connected is the number of its connected components reduced by one 
https://codeforces.com//contest/1142/problem/A,322161,A,1142A,1142,A. The Beatles,Recently a Golden Circle of Beetlovers was found in Byteland It is a circle route going through n cdot k cities The cities are numerated from 1 to n cdot k the distance between the neighboring cities is exactly 1 km Sergey does not like beetles he loves burgers Fortunately for him there are n fast food restaurants on the circle they are located in the 1 st the k 1 st the 2k 1 st and so on the n 1 k 1 st cities i e the distance between the neighboring cities with fast food restaurants is k km Sergey began his journey at some city s and traveled along the circle making stops at cities each l km l 0 until he stopped in s once again Sergey then forgot numbers s and l but he remembers that the distance from the city s to the nearest fast food restaurant was a km and the distance from the city he stopped at after traveling the first l km from s to the nearest fast food restaurant was b km Sergey always traveled in the same direction along the circle but when he calculated distances to the restaurants he considered both directions Now Sergey is interested in two integers The first integer x is the minimum number of stops excluding the first Sergey could have done before returning to s The second integer y is the maximum number of stops excluding the first Sergey could have done before returning to s ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tll n, k, a, b;\n\tcin >> n >> k >> a >> b;\n\tll ans1 = n * k + 1, ans2 = 0;\n\n\tfor (int f = 0; f < 2; f++)\n\t\tfor (int g = 0; g < 2; g++) {\n\t\t\tll x = a, y = b;\n\t\t\tif (f == 1) x = (k - a) % k;\n\t\t\tif (g == 1) y = (k - b) % k;\n\t\t\tx -= y;\n\t\t\tif (x < 0) x += k;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ty = x + i * k;\t\n\t\t\t\ty = gcd(y, n * k);\n\t\t\t\ty = (n * k) / y;\n\t\t\t\tans1 = min(ans1, y);\n\t\t\t\tans2 = max(ans2, y);\n\t\t\t}\n\t\t}\n\tcout << ans1 << "" "" << ans2 << endl;\n\n\treturn 0;\n}\n']",,,"['brute force', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. The Beatles.json,https://codeforces.com//blog/entry/66301,Let s assume that we know the length of the jump and it is equal to Then in order to be back at the starting point Sergey will need to make exactly moves where is the greatest common divider Let where and are non negative integers So if we know and than can only take values where means modulo It is clear that only can be considered Then we iterate over all the variants of the pair and for each we find the number of moves to the starting point The minimum and maximum of the resulting numbers will be the answer 
https://codeforces.com//contest/1945/problem/E,2540240,E,1945E,1945,E. Binary Search,Anton got bored during the hike and wanted to solve something He asked Kirill if he had any new problems and of course Kirill had one You are given a permutation p of size n and a number x that needs to be found A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array You decided that you are a cool programmer so you will use an advanced algorithm for the search binary search However you forgot that for binary search the array must be sorted You did not give up and decided to apply this algorithm anyway and in order to get the correct answer you can perform the following operation 2 times before running the algorithm choose the indices i j 1 le i j le n and swap the elements at positions i and j After that the binary search is performed At the beginning of the algorithm two variables l 1 and r n 1 are declared Then the following loop is executed If r l 1 end the loop m lfloor frac r l 2 rfloor If p m le x assign l m otherwise r m The goal is to rearrange the numbers in the permutation before the algorithm so that after the algorithm is executed p l is equal to x It can be shown that 2 operations are always sufficient ,"['#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll INF = LLONG_MAX, MOD = 1e9 + 7, P = 239;\nconst ld PI = 3.1415926535897938462643383279502, EPS = 1e-7;\n\ntemplate <typename T>\ninline ll sz(const T &a) {\n    return a.size();\n}\n\ntemplate <typename T, typename C>\nistream &operator >> (istream &in, pair<T, C> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <typename T, typename C>\nostream &operator << (ostream &out, pair<T, C> a) {\n    return out << a.first << \' \' << a.second;\n}\n\ntemplate <typename T>\nistream & operator >> (istream &in, vector<T> &a) {\n    for (auto &i : a) {\n        in >> i;\n    }\n    return in;\n}\n\ntemplate <typename T>\nostream &operator << (ostream &out, vector<T> a) {\n    for (auto i : a) {\n        out << i << \' \';\n    }\n    return out;\n}\n\ntemplate <typename T>\nvoid print(vector<T> a, string c = ""\\n"") {\n    for (T i : a) {\n        cout << i << c;\n    }\n}\n\nvoid solve() {\n    ll n, x;\n    cin >> n >> x;\n    vector<ll> p(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> p[i];\n    }\n    ll pos = -1;\n    for (int i = 1; i <= n; ++i) {\n        if (p[i] == x) {\n            pos = i;\n        }\n    }\n    ll l = 1, r = n + 1;\n    vector<bool> change(n + 1), tryed(n + 1);\n//    while (r - l > 1) {\n//        ll m = (r + l) / 2;\n//        tryed[m] = true;\n//        if (p[m] <= x) {\n//            l = m;\n//            if (pos < m) {\n//                change[m] = true;\n//                r = m;\n//            }\n//        } else {\n//            r = m;\n//            if (pos >= m) {\n//                change[m] = true;\n//                l = m;\n//            }\n//        }\n//    }\n//    vector<ll> nc;\n//    for (int i = 1; i <= n; ++i) {\n//        if (change[i]) {\n//            nc.push_back(i);\n//        }\n//    }\n    while (r - l > 1) {\n        ll m = (r + l) / 2;\n        tryed[m] = true;\n        if (p[m] <= x) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    ll last = l;\n    if (last == pos) {\n        return void(cout << 0);\n    }\n    vector<pair<int, int>> ans;\n    ans.push_back({pos, l});\n    if (tryed[pos]) {\n        for (int i = 1; i <= n; ++i) {\n            if (p[i] <= x && !tryed[i]) {\n                ans.push_back({i, pos});\n                break;\n            }\n        }\n    }\n    cout << sz(ans) << \'\\n\';\n    print(ans);\n}\n\nsigned main() {\n#ifdef LOCAL\n    freopen(""inp.txt"", ""r"", stdin);\n    freopen(""out.txt"", ""w"", stdout);\n    freopen(""err.txt"", ""w"", stderr);\n\n    auto start_time = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int times = 1;\n    cin >> times;\n    while (times--)\n        solve(), cout << \'\\n\';\n\n#ifdef LOCAL\n    auto end_time = clock();\n    cerr << setprecision(3) << fixed << ""Execution time: "" << (end_time - start_time) * (int) 1e3 / CLOCKS_PER_SEC << "" ms\\n"";\n#endif\n    return 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Binary Search.json,https://codeforces.com//blog/entry/127377,In fact the problem can be solved in a single operation Let s start a binary search on the initial permutation We will get some index Then it is enough to swap and Now our binary search will stop exactly at the number Notice that in the search any number less than or equal to affects the result like Indeed remains true if we replace with Note that if we swapped two numbers that give the same result in the condition of the binary search then the final will not change The previous statements assumed that Indeed in the algorithm description after changing the number cannot become greater than It is also necessary to consider the case when after executing the algorithm If then at each iteration of the algorithm in particular this means that was never equal to In this case swapping and will also not affect the result of the binary search Complexity 
https://codeforces.com//contest/427/problem/C,9095,C,427C,427,C. Checkposts,Your city has junctions There are roads between the junctions As a mayor of the city you have to ensure the security of all the junctions To ensure the security you have to build some police checkposts Checkposts can only be built in a junction A checkpost at junction can protect junction if either or the police patrol car can go to from and then come back to Building checkposts costs some money As some areas of the city are more expensive than others building checkpost at some junctions might cost more money than other junctions You have to determine the minimum possible money needed to ensure the security of all the junctions Also you have to find the number of ways to ensure the security in minimum price and Two ways are different if any of the junctions contains a checkpost in one of them and do not contain in the other ,"['#include <stdio.h>\n#include <string.h>\n\ntypedef long long LL;\nconst LL MOD = 1000000007LL;\n\nstruct edge\n{\n  int b;\n  edge* next;\n};\nedge ea[1000000];\nint nea = 0;\nedge* ealloc()\n{\n  return &ea[nea++];\n}\n\nint vc[120000];\nedge* ve[120000];\nedge* vr[120000];\nvoid add(int a, int b)\n{\n  edge* e = ealloc();\n  e->b = b; e->next = ve[a]; ve[a] = e;\n  e = ealloc();\n  e->b = a; e->next = vr[b]; vr[b] = e;\n}\n\nint vis[120000];\nint vo[120000];\nint nvo = 0;\n\nvoid dfs1(int v)\n{\n  vis[v] = 1;\n  for (edge* e = ve[v]; e; e = e->next)\n    if (!vis[e->b])\n      dfs1(e->b);\n  vo[nvo++] = v;\n}\n\nint bestv = 0;\nint bestn = 0;\nvoid dfs2(int v)\n{\n  vis[v] = 1;\n  if (vc[v] < bestv)\n    bestv = vc[v], bestn = 0;\n  if (vc[v] == bestv)\n    bestn++;\n  for (edge* e = vr[v]; e; e = e->next)\n    if (!vis[e->b])\n      dfs2(e->b);\n}\n\nint main()\n{\n  //freopen(""input.txt"", ""rt"", stdin);\n  //freopen(""output.txt"", ""wt"", stdout);\n\n  memset(ve, 0, sizeof ve);\n  memset(vr, 0, sizeof vr);\n\n  int n, m;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n; i++)\n    scanf(""%d"", &vc[i]);\n  scanf(""%d"", &m);\n  for (int i = 0; i < m; i++)\n  {\n    int a, b;\n    scanf(""%d %d"", &a, &b);\n    add(a - 1, b - 1);\n  }\n\n  memset(vis, 0, sizeof vis);\n  for (int i = 0; i < n; i++)\n    if (!vis[i])\n      dfs1(i);\n  \n  memset(vis, 0, sizeof vis);\n  LL total = 0;\n  LL count = 1;\n  for (int i = n - 1; i >= 0; i--)\n  {\n    int v = vo[i];\n    if (!vis[v])\n    {\n      bestv = 1000000001;\n      bestn = 0;\n      dfs2(v);\n      total += LL(bestv);\n      count = (count * LL(bestn)) % MOD;\n    }\n  }\n  printf(""%I64d %I64d"", total, count);\n\n  return 0;\n}\n']",,,"['dfs and similar', 'graphs', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Checkposts.json,https://codeforces.com//blog/entry/12082,Find the strongly connected components of the graph From each component we need to choose a node with the lowest cost If there are more than one nodes with lowest cost then there are more than one way to choose node from this component Model solution 6546275 
https://codeforces.com//contest/1334/problem/D,590684,D,1334D,1334,D. Minimum Euler Cycle,You are given a graph K n with n vertices each pair of vertices u neq v in K n have both directed edges u v and v u there are no self loops You should find such a cycle in K n that visits every directed edge exactly once allowing for revisiting vertices We can write such cycle as a list of n n 1 1 vertices v 1 v 2 v 3 dots v n n 1 1 v n n 1 v n n 1 1 v 1 a visiting order where each v i v i 1 occurs exactly once Find the such cycle It s not hard to prove that the cycle always exists Since the answer can be too large print its l r segment in other words v l v l 1 dots v r ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint _,n;\nll l,r,s[N];\n\nint calc(ll x) {\n\tif (x>s[n-1]) return 1;\n\tauto a=lower_bound(s+1,s+n,x)-s;\n\tint b=x-s[a-1];\n\tif (b%2==1) return a;\n\telse return b/2+a;\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d%lld%lld"",&n,&l,&r);\n\t\trep(i,1,n+1) s[i]=s[i-1]+2*(n-i);\n\t\tfor (ll i=l;i<=r;i++)\n\t\t \tprintf(""%d "",calc(i));\n\t\tputs("""");\n\t}\n}\n']",,,"['constructive algorithms', 'graphs', 'greedy', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Minimum Euler Cycle.json,https://codeforces.com//blog/entry/75877,The solution of the problem can be found clearly in constructive way An example for 1 2 1 3 1 4 1 5 2 3 2 4 2 5 3 4 3 5 4 5 1 where brackets mean that we call here some recursive function Since on each level of recursion we have only elements and there levels then the generation of the certificate is quite easy if on the currect level of recursion we can skip the whole part let s just skip it Otherwise let s build this part Anyway the built part of the cycle will have only length so the whole algorithm has complexity The answer is lexicographically minimum by the construction since on each level of recursion there is no way to build lexicographically smaller sequence 
https://codeforces.com//contest/837/problem/D,116710,D,837D,837,D. Round Subset,Let s call the of the number the number of zeros to which it ends You have an array of numbers You need to choose a subset of exactly numbers so that the of the product of the selected numbers will be maximum possible ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nint dp[205][8010];\nint tdp[205][8010];\nint in[205][2];\nint main() {\n\tint N, K, i, j, k;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tll t;\n\t\tscanf(""%lld"", &t);\n\t\twhile (t % 2 == 0) {\n\t\t\tin[i][0]++;\n\t\t\tt /= 2;\n\t\t}\n\t\twhile (t % 5 == 0) {\n\t\t\tin[i][1]++;\n\t\t\tt /= 5;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) tdp[j][k] = dp[j][k];\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tfor (k = 0; k <= 8000; k++) {\n\t\t\t\tint j2 = j + 1, k2 = k + in[i][1];\n\t\t\t\tif (k2 <= 8000) tdp[j2][k2] = max(tdp[j2][k2], dp[j][k] + in[i][0]);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) dp[j][k] = tdp[j][k];\n\t}\n\n\tint ans = 0;\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) ans = max(ans, min(j, dp[i][j]));\n\treturn !printf(""%d\\n"", ans);\n}']",,,"['dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Round Subset.json,https://codeforces.com//blog/entry/53662,Let s use dynamic programming to solve this task Obviously the of the number is determined by minimum of powers of and in the number Let be the maximal power of in the number and be the maximal power of Let be the maximum amount of twos we can collect by checking first numbers taking of them with total power of five equal to It is usually called the knapsack problem There are two types of transitions You can either take current element or skip it The answer will be maximum of for every Also keeping this many states can cause ML the first dimension should be stored in two layers and recalced on the fly Overall complexity 
https://codeforces.com//contest/519/problem/D,23226,D,519D,519,D. A and B and Interesting Substrings,After several years of doing sports programming and solving many problems that require calculating all sorts of abstract objects A and B also developed rather peculiar tastes A likes lowercase letters of the Latin alphabet He has assigned to each letter a number that shows how much he likes that letter he has assigned negative numbers to the letters he dislikes B likes substrings He especially likes the ones that start and end with the same letter their length must exceed one Also A and B have a string Now they are trying to find out how many substrings of a string are interesting to B that is starts and ends with the same letter and its length is larger than one and also the sum of values of all letters assigned by A is equal to zero Naturally A and B have quickly found the number of substrings that are interesting to them Can you do it ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint val[27];\nchar a[N];\nint n;\nmap<long long, int> h[26];\n\nint main() {\n    int i;\n   // freopen(""ttt"", ""r"", stdin);\n\n    for(i = 0; i < 26; ++i) {\n        cin >> val[i];\n    }\n    cin >> (a + 1);\n        n = strlen(a + 1);\n\n    long long sc = 0, rez = 0;\n\n    for(i = 1; i <= n; ++i) {\n        a[i] -= \'a\';\n        sc += val[a[i]];\n\n        rez += h[a[i]][sc - val[a[i]]];\n        h[a[i]][sc]++;\n    }\n\n    cout << rez;\n\n    return 0;\n}\n']",,,"['data structures', 'dp', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. A and B and Interesting Substrings.json,https://codeforces.com/blog/entry/16687,In this problem you were asked to find number of substrings of given string such that each substring starts and finishes with one and the same letter and sum of weight of letters of that substring without first and last letter is zero Solution Let s denote sum i as sum of weights of first i letters Create 26 map longlong int s 1 for each letter Suppose we are on position number i and current character s map is m Then add m sum i 1 to the answer and add sum i to the m 
https://codeforces.com//contest/757/problem/G,88534,G,757G,757,G. Can Bash Save the Day ,Whoa You did a great job helping Team Rocket who managed to capture all the Pokemons sent by Bash Meowth part of Team Rocket having already mastered the human language now wants to become a master in programming as well He agrees to free the Pokemons if Bash can answer his questions Initially Meowth gives Bash a weighted tree containing nodes and a sequence which is a permutation of Now Mewoth makes queries of one of the following forms meaning Bash should report where is the length of the shortest path from node to node in the given tree meaning Bash should swap and in the given sequence This new sequence is used for later queries Help Bash to answer the questions ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long inf = (long long) 1e18;\n\nconst int N = 400010;\n\nvector < pair <int, long long> > forc[N];\nvector < pair <int, long long> > centroid[N];\nlong long dist[N];\nlong long last_dist[N];\nint sub[N];\nbool alive[N];\nvector < pair <int, int> > g[N];\nint perm[N], pos[N];\nint v_goes_to[N];\nvector <int> all;\nvector <int> in_forc[N];\n\nvoid dfs(int v, int pr) {\n  all.push_back(v);\n  sub[v] = 1;\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (!alive[u] || u == pr) {\n      continue;\n    }\n    int len = g[v][j].second;\n    dist[u] = dist[v] + len;\n    dfs(u, v);\n    sub[v] += sub[u];\n  }\n}\n\nvoid build(int v) {\n  all.clear();\n  dfs(v, -1);\n  {\n    // changing the root\n    int old_v = v;\n    int total = sub[v];\n    int pr = -1;\n    while (true) {\n      bool found = false;\n      int sz = g[v].size();\n      for (int j = 0; j < sz; j++) {\n        int u = g[v][j].first;\n        if (!alive[u] || u == pr) {\n          continue;\n        }\n        if (2 * sub[u] >= total) {\n          pr = v;\n          v = u;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        break;\n      }\n    }\n    v_goes_to[old_v] = v;\n  }\n  all.clear();\n  dist[v] = 0;\n  dfs(v, -1);\n  int cnt = all.size();\n  for (int i = 0; i < cnt; i++) {\n    int u = all[i];\n    centroid[u].push_back(make_pair(v, dist[u]));\n  }\n  for (int i = 0; i < cnt; i++) {\n    int u = all[i];\n    forc[v].push_back(make_pair(pos[u], dist[u] - last_dist[u]));\n    last_dist[u] = dist[u];\n  }\n  sort(forc[v].begin(), forc[v].end());\n  for (int j = 1; j < cnt; j++) {\n    forc[v][j].second += forc[v][j - 1].second;\n  }\n  for (int i = 0; i < cnt; i++) {\n    int u = perm[forc[v][i].first];\n    in_forc[u].push_back(i);\n  }\n  vector <int> children;\n  for (int i = 0; i < (int) g[v].size(); i++) {\n    int u = g[v][i].first;\n    if (alive[u]) {\n      children.push_back(u);\n    }\n  }\n  alive[v] = false;\n  for (int i = 0; i < (int) children.size(); i++) {\n    build(children[i]);\n  }\n}\n\nint main() {\n  int n, tt;\n  scanf(""%d %d"", &n, &tt);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", perm + i);\n    perm[i]--;\n    pos[perm[i]] = i;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, z;\n    scanf(""%d %d %d"", &x, &y, &z);\n    x--; y--;\n    g[x].push_back(make_pair(y, z));\n    g[y].push_back(make_pair(x, z));\n  }\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n  }\n  build(0);\n  int last = 0;\n  while (tt--) {\n    int com;\n    scanf(""%d"", &com);\n    if (com == 1) {\n      int from, to, ver;\n      scanf(""%d %d %d"", &from, &to, &ver);\n      from ^= last;\n      to ^= last;\n      ver ^= last;\n      from--; to--; ver--;\n      long long ans = 0;\n      long long prev_d = 0;\n      for (pair <int, long long> p : centroid[ver]) {\n        int v = p.first;\n        long long d = p.second;\n        long long sumd = 0;\n        int cnt = 0;\n        {\n          int pf = lower_bound(forc[v].begin(), forc[v].end(), make_pair(from, -inf)) - forc[v].begin();\n          int pt = lower_bound(forc[v].begin(), forc[v].end(), make_pair(to + 1, -inf)) - forc[v].begin();\n          if (pf < pt) {\n            sumd += forc[v][pt - 1].second;\n            if (pf > 0) {\n              sumd -= forc[v][pf - 1].second;\n            }\n            cnt += pt - pf;\n          }\n        }\n        ans += sumd + cnt * (d - prev_d);\n        prev_d = d;\n      }\n      printf(""%I64d\\n"", ans);\n      last = ans & ((1 << 30) - 1);\n    } else {\n      int x;\n      scanf(""%d"", &x);\n      x ^= last;\n      x--;\n      int v1 = perm[x];\n      int v2 = perm[x + 1];\n      int c1 = centroid[v1].size();\n      int c2 = centroid[v2].size();\n      int i1 = 0;\n      int i2 = 0;\n      long long prev_d2 = 0;\n      while (i1 < c1 && i2 < c2 && centroid[v1][i1].first == centroid[v2][i2].first) {\n        int v = centroid[v1][i1].first;\n        long long d2 = centroid[v2][i2].second;\n        {\n          int at = in_forc[v1][i1];\n          forc[v][at].second = (at == 0 ? 0LL : forc[v][at - 1].second) + d2 - prev_d2;\n          swap(in_forc[v1][i1], in_forc[v2][i2]);\n        }\n        prev_d2 = d2;\n        i1++; i2++;\n      }\n      for (int rot = 0; rot < 2; rot++) {\n        while (i1 < c1) {\n          int v = centroid[v1][i1].first;\n          {\n            int at = in_forc[v1][i1];\n            forc[v][at].first = pos[v2];\n          }\n          i1++;\n        }\n        swap(v1, v2);\n        swap(c1, c2);\n        swap(i1, i2);\n      }\n      swap(perm[x], perm[x + 1]);\n      pos[perm[x]] = x;\n      pos[perm[x + 1]] = x + 1;\n    }\n  }\n  return 0;\n}\n']",,,"['data structures', 'divide and conquer', 'graphs', 'trees']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Can Bash Save the Day .json,https://codeforces.com//blog/entry/49743,Main idea Making the Centroid Tree Persistent Simpler Problem First let s try to solve a much simpler problem given as follows Question Given a weighted tree initially all the nodes of the given tree are inactive We need to support the following operations fast Query v Report the sum of distances of all active nodes from node v in the given tree Activate v Mark node v to be an active node Solution The above problem can be easily solved by a fairly standard technique called Centroid Decomposition You can read more about here Solution Idea Each query of the form L R v can be divided into two queries of form 1 R v 1 L 1 v Hence it is sufficient if we can support the following query i v Report the answer to query 1 i v To answer a single query of the form i v we can think of it as what is the sum of distance of all active nodes from node v if we consider the first i nodes to be active Hence initially if we can preprocess the tree such that we activate nodes from 1 to n and after each update store a copy of the centroid tree then for each query i v we can lookup the centroid tree corresponding to i which would have the first i nodes activated and query for node v in time by looking at it s ancestors To store a copy of the centroid tree for each i we need to make it persistent Persistent Centroid Tree Key Ideas Important thing to note is that single update in the centroid tree affects only the ancestors of the node in the tree Since height of the centroid tree is each update affects only other nodes in the centroid tree The idea is very similar to that of a persistent segment tree BUT unlike segtree here each node of the centroid tree can have arbitrarily many children and hence simply creating a new copy of the affected nodes would not work because linking them to the children of old copy would take for each affected node and this number could be as large as N hence it could take time in total Binarizing the Input Tree To overcome the issue we convert the given tree T into an equivalent binary tree T by adding extra dummy nodes such that degree of each node in the transformed tree T is 3 and the number of dummy nodes added is bounded by The dummy nodes are added such that the structure of the tree is preserved and weights of the edges added are set to 0 To do this consider a node x with degree d 3 and let c1 c2 cd be it s adjacent nodes Add a new node y and change the edges as follows Delete the edges x c3 x c4 x cd and add the edge x y such that degree of node x reduces to 3 from d Add edges y c3 y c4 y cd such that degree of node y is d 1 Recursively call the procedure on node y Since degree of node y is d 1 instead of original degree d of node x it can be proved that we need to add at most new nodes before degree of each node in the tree is 3 Conclusion Hence we perform centroid decomposition of this transformed tree T The centroid tree formed would have the following properties The height of the centroid tree is Each node in the centroid tree has 3 children Now we can easily make this tree persistent by path copying approach To handle the updates Way 1 Observe that swapping A i and A i 1 would affect only the i th persistent centroid tree which can be rebuilt from the tree of i 1 by a single update query In this approach for each update we add new nodes See author s code below for more details Way 2 First we go down to the lca of A x and A x 1 in the x th persistent tree updating the values as we go Now let cl be the child of lca which is an ancestor of A x and let cr be the child which is an ancestor of A x 1 Now we replace cr of x th persistent tree with cr of x 1 th persistent tree Similarly we replace cl of x 1 th persistent tree with cl of x th persistent tree So now A x 1 is active in x th persistent tree and both A x and A x 1 are active in x 1 th persistent tree To deactivate A x in x th persistent tree we replace cl of x th persistent tree with cl of x 1 th persistent tree Hence in this approach we do not need to create new nodes for each update See testers s code below for more details 
https://codeforces.com//contest/2051/problem/A,3099574,A,2051A,2051,A. Preparing for the Olympiad,Monocarp and Stereocarp are preparing for the Olympiad There are n days left until the Olympiad On the i th day if Monocarp plans to practice he will solve a i problems Similarly if Stereocarp plans to practice on the same day he will solve b i problems Monocarp can train on any day he wants However Stereocarp watches Monocarp and follows a different schedule if Monocarp trained on day i and i n then Stereocarp will train on day i 1 Monocarp wants to organize his training process in a way that the difference between the number of problems he solves and the number of problems Stereocarp solves is as large as possible Formally Monocarp wants to maximize the value of m s where m is the number of problems he solves and s is the number of problems Stereocarp solves Help Monocarp determine the maximum possible difference in the number of solved problems between them ,"['#include <bits/stdc++.h>using namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);        int t;    cin >> t;        while(t--){        int n;        cin >> n;                vector<int> a(n);                for(auto &x: a) {            cin >> x;        }\xa0        vector<int> b(n);                for(auto &x: b) {            cin >> x;        }                long long res = a[n-1];                for(int i=0;i<n-1;i++){            if(a[i] > b[i+1]){                res += (a[i] - b[i+1]);            }        }        cout << res << ""\\n"";    }}']",,,['greedy'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Preparing for the Olympiad.json,https://codeforces.com//blog/entry/137623,Let s consider what contribution each day that Monokarp trains makes to the difference For each day except the last one if Monokarp trains on that day then the number of problems he has solved will increase by and the number of problems solved by Stereokarp will increase by Therefore if it is beneficial for Monokarp to train on the th day otherwise it is not beneficial On the last day it is always beneficial to train as Stereokarp will not solve anything on the day following it 
https://codeforces.com//contest/803/problem/D,104509,D,803D,803,D. Magazine Ad,The main city magazine offers its readers an opportunity to publish their ads The format of the ad should be like this There are space separated non empty words of lowercase and uppercase Latin letters There are hyphen characters in some words their positions set word wrapping points Word can include more than one hyphen It is guaranteed that there are no adjacent spaces and no adjacent hyphens No hyphen is adjacent to space There are no spaces and no hyphens before the first word and after the last word When the word is wrapped the part of the word before hyphen and the hyphen itself stay on current line and the next part of the word is put on the next line You can also put line break between two words in that case the space stays on current line Check notes for better understanding The ad can occupy no more that lines and should have minimal width The width of the ad is the maximal length of string letters spaces and hyphens are counted in it You should write a program that will find minimal width of the ad ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9;\nint k;\nstring s;\nint n;\n\nint solve(int w)\n{\n    int ans = 0;\n    int l = 0;\n    while(l < n)\n    {\n        ans++;\n        int r = l + w;\n        if (r >= n) break;\n        while(r > l && s[r - 1] != \' \' && s[r - 1] != \'-\') r--;\n        if (r == l) return INF;\n        l = r;\n    }\n    return ans;\n}\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    cin >> k;\n    getline(cin, s);\n    getline(cin, s);\n\n    n = s.length();\n    int l = 0, r = n;\n    while(r - l > 1)\n    {\n        int m = (l + r) / 2;\n        if (solve(m) <= k)\n            r = m;\n        else\n            l = m;\n    }\n    cout << r << endl;\n\n    return 0;\n}\n']",,,"['binary search', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Magazine Ad.json,https://codeforces.com//blog/entry/51768,Firstly notice that there is no difference between space and hyphen you can replace them with the same character if you want Let s run binary search on answer Fix width and greedily construct ad wrap word only if you don t option to continue on the same line Then check if number of lines doesn t exceed Overall complexity 
https://codeforces.com//contest/1998/problem/E2,2808664,E2,1998E2,1998,E2. Eliminating Balls With Merging  Hard Version ,Sun Tzu You are given two integers n and x x 1 There are n balls lined up in a row numbered from 1 to n from left to right Initially there is a value a i written on the i th ball For each integer i from 1 to n we define a function f i as follows Suppose you have a set S 1 2 ldots i In each operation you have to select an integer l 1 leq l i from S such that l is not the largest element of S Suppose r is the smallest element in S which is greater than l If a l a r you set a l a l a r and remove r from S If a l a r you set a r a l a r and remove l from S If a l a r you choose either the integer l or r to remove from S If you choose to remove l from S you set a r a l a r and remove l from S If you choose to remove r from S you set a l a l a r and remove r from S f i denotes the number of integers j 1 le j le i such that it is possible to obtain S j after performing the above operations exactly i 1 times For each integer i from x to n you need to find f i ,"['#include <bits/stdc++.h>using namespace std;\xa0#define int long long\xa0const int INF=0x3f3f3f3f3f3f3f3f;const int N=2e5+5;\xa0int lc[N], rc[N], stk[N], sum[N], a[N], n;\xa0struct Segment_Tree1{\tint L[N*4], R[N*4], add[N*4], Min[N*4], cnt[N*4], val[N];\xa0\tSegment_Tree1()\t{\t\tmemset(L,0,sizeof(L));\t\tmemset(R,0,sizeof(R));\t\tmemset(add,0,sizeof(add));\t\tmemset(Min,0,sizeof(Min));\t\tmemset(cnt,0,sizeof(cnt));\t\tmemset(val,0,sizeof(val));\t}\xa0\tvoid pushup(int rt)\t{\t\tMin[rt]=min(Min[rt*2],Min[rt*2+1]);\t\tcnt[rt]=0;\t\tif(Min[rt]==Min[rt*2])\t\t\tcnt[rt] += cnt[rt*2];\t\tif(Min[rt]==Min[rt*2+1])\t\t\tcnt[rt] += cnt[rt*2+1];\t}\xa0\tvoid Add(int rt,int val)\t{\t\tadd[rt] += val;\t\tMin[rt] += val;\t}\xa0\tvoid pushdown(int rt)\t{\t\tif(add[rt])\t\t{\t\t\tAdd(rt*2,add[rt]);\t\t\tAdd(rt*2+1,add[rt]);\t\t\tadd[rt]=0;\t\t}\t}\xa0\tvoid update(int rt,int l,int r,int val)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t{\t\t\tAdd(rt,val);\t\t\treturn;\t\t}\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l<=mid)\t\t\tupdate(rt*2,l,r,val);\t\tif(mid+1<=r)\t\t\tupdate(rt*2+1,l,r,val);\t\tpushup(rt);\t}\xa0\tpair<int,int> query(int rt,int l,int r)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t\treturn make_pair(Min[rt],cnt[rt]);\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l>mid)\t\t\treturn query(rt*2+1,l,r);\t\tif(mid+1>r)\t\t\treturn query(rt*2,l,r);\xa0\t\tpair <int,int> L=query(rt*2,l,r);\t\tpair <int,int> R=query(rt*2+1,l,r);\t\tpair <int,int> ans=make_pair(min(L.first,R.first),0);\t\tif(L.first==ans.first)\t\t\tans.second += L.second;\xa0\t\tif(R.first==ans.first)\t\t\tans.second += R.second;\t\treturn ans;\t}\xa0\tint lstpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn 0;\xa0\t\tif(L[rt]==R[rt])\t\t\treturn L[rt];\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn lstpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn lstpos(rt*2+1,l,r,val);\xa0\t\tint rans=lstpos(rt*2+1,l,r,val);\t\tif(rans==0)\t\t\treturn lstpos(rt*2,l,r,val);\t\treturn rans;\t}\xa0\tint firpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn n+1;\xa0\t\tif(L[rt]==R[rt])\t\t\treturn L[rt];\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn firpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn firpos(rt*2+1,l,r,val);\xa0\t\tint lans=firpos(rt*2,l,r,val);\t\tif(lans==n+1)\t\t\treturn firpos(rt*2+1,l,r,val);\t\treturn lans;\t}\xa0\tvoid build(int rt,int l,int r)\t{\t\tL[rt]=l, R[rt]=r, add[rt]=0;\t\tif(l==r)\t\t{\t\t\tMin[rt]=val[l], cnt[rt]=1;\t\t\treturn;\t\t}\xa0\t\tint mid=(l+r)/2;\t\tbuild(rt*2,l,mid);\t\tbuild(rt*2+1,mid+1,r);\t\tpushup(rt);\t}}tr1, tr2, tr3;\xa0int L[N*35], R[N*35], indx;bool del[N*35];\xa0struct Segment_Tree2{\tvector <int> vec[N*4];\xa0\tvoid update(int rt,int l,int r,int ql,int qr,int val)\t{\t\tif(ql<=l && r<=qr)\t\t{\t\t\tvec[rt].push_back(val);\t\t\treturn;\t\t}\xa0\t\tint mid=(l+r)/2;\t\tif(ql<=mid)\t\t\tupdate(rt*2,l,mid,ql,qr,val);\t\tif(mid+1<=qr)\t\t\tupdate(rt*2+1,mid+1,r,ql,qr,val);\t}\xa0\tvoid query(int rt,int l,int r,int pos)\t{\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\tvec[rt].clear();\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tquery(rt*2,l,mid,pos);\t\telse\t\t\tquery(rt*2+1,mid+1,r,pos);\t}\xa0\tvoid queryl(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(L[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec);\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryl(rt*2,l,mid,pos);\t\telse\t\t\tqueryl(rt*2+1,mid+1,r,pos);\t}\xa0\tvoid queryr(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(R[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec);\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryr(rt*2,l,mid,pos);\t\telse\t\t\tqueryr(rt*2+1,mid+1,r,pos);\t}}tr4;\xa0void dfs(int l,int r,int root){\tif(l>r)\t\treturn;\xa0\tif(sum[r]-sum[l-1]<a[l-1] && sum[r]-sum[l-1]<a[r+1])\t{\t\tindx++, L[indx]=l, R[indx]=r;\t\ttr4.update(1,1,n,l,r,indx);\t\ttr1.update(1,l,r,1);\t}\xa0\tdfs(l,root-1,lc[root]);\tdfs(root+1,r,rc[root]);}\xa0void build(){\ta[0]=a[n+1]=INF;\tint top=0, root=0;\tfor(int i=1;i<=n;i++)\t{\t\tstk[top+1]=0;\t\twhile(top && a[stk[top]]<=a[i])\t\t\ttop--;\xa0\t\tif(top)\t\t\trc[stk[top]]=i;\t\telse\t\t\troot=i;\xa0\t\tlc[i]=stk[top+1];\t\tstk[++top]=i;\t}\xa0\tdfs(1,n,root);}\xa0int c[N];\xa0int query_sum(int x){\tint ans=0;\tfor(int i=x;i;i-=i&-i)\t\tans += c[i];\treturn ans;}\xa0void update_sum(int x,int y){\tfor(int i=x;i<=n;i+=i&-i)\t\tc[i] += y;}\xa0void work(){\tint x;\tcin >> n >> x;\tfor(int i=1;i<=indx;i++)\t\tL[i]=R[i]=del[i]=0;\tindx=0;\xa0\tfor(int i=0;i<=n;i++)\t\tc[i]=lc[i]=rc[i]=sum[i]=a[i]=stk[i]=0;\xa0\tfor(int i=0;i<=n*4;i++)\t\ttr4.vec[i].clear();\xa0\tfor(int i=1;i<=n;i++)\t{\t\tscanf(""%lld"",&a[i]);\t\tupdate_sum(i,a[i]);\t\tsum[i]=sum[i-1]+a[i];\t}\xa0\tfor(int i=1;i<=n;i++)\t{\t\ttr2.val[i]=sum[i-1]-a[i];\t\ttr3.val[i]=-a[i]-sum[i];\t}\xa0\ttr1.build(1,1,n), tr2.build(1,1,n), tr3.build(1,1,n);\tbuild();\xa0\tfor(int i=x;i<=n;i++)\t{\t\tint l=1, r=i;\t\tif(l==r)\t\t{\t\t\tprintf(""1\\n"");\t\t\tcontinue;\t\t}\xa0\t\tint pos1=tr2.lstpos(1,l+1,r,query_sum(l-1))-1;\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,1);\xa0\t\tint pos2=tr3.firpos(1,l,r-1,-query_sum(r))+1;\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,1);\xa0\t\tprintf(""%lld\\n"",tr1.query(1,l,r).second);\xa0\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,-1);\xa0\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,-1);\t}}\xa0signed main(){\tint T;\tcin >> T;\twhile(T--)\t\twork();\treturn 0;}']",,,"['binary search', 'brute force', 'data structures', 'divide and conquer', 'greedy', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E2. Eliminating Balls With Merging  Hard Version .json,https://codeforces.com//blog/entry/132512,Hint 1 For each element j there is a range Lj Rj in which it can be present as last elemt Hint 2 Modify the Solve function to now return what is the minimum index Lj instead of boolean earlier Basically find minimum Lj such that element j can become A1 A2 ALj Hint 3 Also for each index i precalcute how much right it can go Use this to calculate Rj based on Lj Hint 4 Otherway around you can also return this range in your solve function 
https://codeforces.com//contest/2033/problem/F,2975322,F,2033F,2033,F. Kosuke s Sloth,Kosuke is too lazy He will not give you any legend just the task Fibonacci numbers are defined as follows f 1 f 2 1 f n f n 1 f n 2 3 le n We denote G n k as an index of the n th Fibonacci number that is divisible by k For given n and k compute G n k As this number can be too big output it by modulo 10 9 7 For example G 3 2 9 because the 3 rd Fibonacci number that is divisible by 2 is 34 1 1 textbf 2 3 5 textbf 8 13 21 textbf 34 ,"['#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/rope>\xa0using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;\xa0// /*//                                                //////////**DEFINES - START**//////////\xa0#define ret return#define fi first#define se second#define mp make_pair#define all(x) x.begin(), x.end()#define be(x) x.begin()#define en(x) x.end()#define sz(x) ll(x.size())#define for0(i, n) for (ll   i = 0; i < (n); ++i)#define for1(i, n) for (ll   i = 1; i < (n); ++i)#define rfor0(i, n) for (ll   i = (n) - 1; i >= 0; --i)#define rfor1(i, n) for (ll   i = (n) - 1; i >= 1; --i)#define rep(i, a, n) for (ll   i = a; i < ll(n); ++i)#define rrep(i, a, n) for (ll   i = a - 1; i >= ll(n); --i)#define popcount __builtin_popcount#define popcountll __builtin_popcountll#define fastIO() ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);#define con continue#define pb push_back#define pob pop_back#define deb(x) cout << (#x) << "" is "" << (x) << endl#define ins insert#define len(s) (s).length()#define gi greater<int>()#define gll greater<ll  >()#define gstr greater<string>()#define gpll greater<pair<ll  , ll  >>()#define rast(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))#define rev reverse#define ub upper_bound#define lb lower_bound#define bs binary_search#define rs resize#define last(a) a.back()#define co count#define ba(a) a.back()#define um unordered_map#define rsun(a) a.resize(unique(a.begin(), a.end())-a.begin())#define endl \'\\n\'#ifdef OG_Matveychick1bool local = true;#elsebool local = false;#endif\xa0//                                                \\\\\\\\\\\\\\\\\\\\**DEFINES - END**\\\\\\\\\\\\\\\\\\\\// */\xa0// /*//                                                //////////**TYPEDEFS - START**//////////\xa0typedef vector<int> vi;typedef vector<vi> vvi;typedef vector<char> vc;typedef pair<int, int> pii;typedef vector<pii> vpii;typedef vector<string> vs;typedef long long ll;typedef unsigned long long ull;typedef vector<ull> vull;typedef pair<ll, ll> pll;typedef vector<ll> vll;typedef vector<pll> vpll;typedef pair<double, double> pdd;typedef double ld;typedef double D;typedef vector<ld> vld;typedef vector<pair<ld, ld>>        vpld;typedef string str;typedef set<ll> sll;typedef set<int> si;typedef set<str> ss;typedef set<pii> spii;typedef multiset<int> msi;typedef multiset<ll> msll;typedef multiset<str> mss;typedef multiset<pii> mspii;typedef multiset<pll> mspll;typedef map<str, str> mps;typedef map<int, int> mpi;typedef map<ll, ll> mpll;typedef map<int, vi> mpvi;typedef map<int, vll> mpvll;typedef map<char, int> mpci;typedef multimap<ll, ll> mmpll;typedef multimap<str, str> mmps;typedef multimap<int, int> mmpi;typedef vector<vector<int>> vvi;typedef vector<vector<ll>> vvll;typedef vector<vector<long double>> vvld;typedef vector<vvi> vvvi;typedef vector<vector<char>> vvc;typedef vector<vs> vvs;typedef vector<D> vD;typedef set<pair<ll, ll>>        spll;typedef pair<ull, ull> pull;typedef vector<pull> vpull;typedef vector<bool> vb;typedef vector<vb> vvb;typedef set<char> sc;typedef queue<int> qi;typedef queue<ll> qll;typedef queue<bool> qb;typedef vector<sll> vsll;typedef queue<pair<ll, ll>>        qpll;typedef vector<vector<pair<int, int>>>        vvpii;typedef vector<vector<pair<ll, ll>>>        vvpll;typedef vector<spll> vspll;typedef multiset<char> msc;typedef queue<str> qs;typedef vector<set<int>> vsi;typedef priority_queue<ll> pqll;typedef vector<vsll> vvsll;typedef pair<ld, ld> pld;typedef vector<vvll> vvvll;typedef set<ld> sld;typedef vector<vpld> vvpld;typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_set;typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_multiset;\xa0//                                                \\\\\\\\\\\\\\\\\\\\**TYPEDEFS - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// /*//                                                //////////**CONSTANTS - START**//////////\xa0constexpr long double pi = 3.141592653589793238462643383279;const ll mod1 = 1e9 + 7;const ll mod2 = 998244353;const ll MAXLL = 9223372036854775807;//const ll MAXINT = 2147483647;const long double eps = 1e-9;\xa0//                                                \\\\\\\\\\\\\\\\\\\\**CONSTANTS - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// /*//                                                //////////**TEMPLATES - START**//////////\xa0\xa0template<typename T>istream &operator>>(istream &in, vector<T> &a) {    for (T &i : a) in >> i;    return in;}\xa0template<typename T1, typename T2>istream &operator>>(istream &in, pair<T1, T2> &a) {    in >> a.fi >> a.se;    return in;}\xa0template<typename T1, typename T2>ostream &operator<<(ostream &out, pair<T1, T2> &a) {    out << a.fi << "" "" << a.se;    return out;}\xa0template<typename T1, typename T2>istream &operator>>(istream &in, vector<pair<T1, T2>>\xa0&a) {    for (        pair<T1, T2> &i            : a)        in >> i.fi >> i.                se;    return            in;}\xa0template<typename T>ostream &operator<<(ostream &out, const vector<T> &a) {    for (auto i : a) {        out << i << "" "";    }    return out;}\xa0template<typename T1, typename T2>ostream &operator<<(ostream &out, vector<pair<T1, T2>>\xa0&a) {    for (        pair<T1, T2> i            : a)        out << i.fi << "" "" << i.se <<            endl;    return            out;}\xa0template<typename T1>ostream &operator<<(ostream &out, vector<vector<T1>> &a) {    for (vector<T1> i : a) {        for (T1 j : i) out << j << "" "";        out << endl;    }    return out;}\xa0template<typename T1, typename T2>inline T1 min(T1 a, T2 b) {    b = (T1) b;    return a > b ? b : a;}\xa0template<typename T1, typename T2>inline T1 max(T1 a, T2 b) {    b = (T1) b;    return a > b ? a : b;}\xa0template<typename T1, typename T2>inline void amin(T1 &a, T2 b) {    a = min(a, b);}\xa0template<typename T1, typename T2>inline void amax(T1 &a, T2 b) {    a = max(a, b);}\xa0\xa0//                                                \\\\\\\\\\\\\\\\\\\\**TEMPLATES - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// This bear is a good alternative to duck!!!/*    ????      ??????  ??????????????????? ????????????????  ??????   ???????????  ??????  ???????????? ?? ??????????????????   ??????????????? ?   ?????????????????   ???????   ???    ??    ????  ??????????     ????     ?? ???   ???????????? ?????  ???????????????????? ????????   ??  ??????? ???????         ????? */\xa0\xa0double getTime() {    return clock() / (double) CLOCKS_PER_SEC;}\xa0\xa0mt19937_64 rn(chrono::steady_clock::now().time_since_epoch().count());//mt19937_64 rn(4);\xa0ll rnd(ll l, ll r) {    ll a = rn() % (r - l + 1) + l;    return a;}\xa0void solve();\xa0ll T = 1;\xa0signed main(int argc, char **argv) {    setlocale(LC_ALL, ""RUS"");    fastIO()    cout.precision(12);    cout << fixed;    if (local && argc == 1) {        freopen(""input.txt"", ""r"", stdin);//        freopen(""002.out"", ""w"", stdout);    }    cin >> T;    while (T--) {        solve();    }    if (local && argc == 1) {        cout << endl << fixed << ""time = "" << getTime();    }    return 0;}\xa0\xa0/*    ___        __              __   ______          __        _____ __             __          __  __   /   | _____/ /___  ______ _/ /  / ____/___  ____/ /__     / ___// /_____ ______/ /______   / / / /__  ________  / /| |/ ___/ __/ / / / __ `/ /  / /   / __ \\/ __  / _ \\    \\__ \\/ __/ __ `/ ___/ __/ ___/  / /_/ / _ \\/ ___/ _ \\ / ___ / /__/ /_/ /_/ / /_/ / /  / /___/ /_/ / /_/ /  __/   ___/ / /_/ /_/ / /  / /_(__  )  / __  /  __/ /  /  __//_/  |_\\___/\\__/\\__,_/\\__,_/_/   \\____/\\____/\\__,_/\\___/   /____/\\__/\\__,_/_/   \\__/____/  /_/ /_/\\___/_/   \\___/*/\xa0\xa0\xa0\xa0void solve() {    ll n, k;    cin >> n >> k;    if (k == 1) {        cout << n % mod1 << endl;        ret;    }    vll a = {1, 1};    ll cnt = 0;    while (1) {        a.push_back((a[sz(a) - 1] + a[sz(a) - 2]) % k);        if (a[sz(a) - 1] == 1 && a[sz(a) - 2] == 1 && a[sz(a) - 3] == 0) {            a.pob();            a.pob();            break;        }        cnt += (ba(a) == 0);    }    ll ans = ((n / cnt) % mod1 * sz(a)) % mod1;    n %= cnt;    if (n) {        for0(i, sz(a)) {            ans++;            if (a[i] == 0) {                n--;            }            if (!n) break;        }    }    cout << ans % mod1 << endl;}']",,,"['brute force', 'math', 'number theory']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Kosuke s Sloth.json,https://codeforces.com//blog/entry/135520,This was one of my favourite tasks untill I realised that the amount of numbers in Fibonacci cycle is either or First of all the length of cycle after which our sequence would be repeating for modulo is at most We will just take this as a fact for now it is too long to explain but you can read it here Now if we know that the amount of operations needed to take untill we are in a cycle is at most we can brute force our solution in time Also one last thing that we will need to consider is the fact that if is divisible by then for every is also divisible by Proof as we know so if we take any multiple of as and then the would be equal to And because is divisible by every other multiple of is going to be also divisible by So our final solution would be brute forcing first Fibonacci numbers and their remainder after division by in order to find the first one that is divisible by Then just multiply that number by and we will get the answer for our task Also don t forget to take everything via modulo Someone kept whining about it in comments Total time complexity 
https://codeforces.com//contest/2013/problem/B,2890587,B,2013B,2013,B. Battle for Survive,Eralim being the mafia boss manages a group of n fighters Fighter i has a rating of a i Eralim arranges a tournament of n 1 battles in each of which two not yet eliminated fighters i and j are chosen and as a result of the battle fighter i is eliminated from the tournament and the rating of fighter j is reduced by the rating of fighter i That is a j is decreased by a i Note that fighter j s rating can become negative The fighters indexes do not change Eralim wants to know what maximum rating the last remaining fighter can preserve if he chooses the battles optimally ,"['#include <bits/stdc++.h>using namespace std;\xa0typedef long long ll;using vi = vector<int>;using vvi = vector<vector<int>>;using vll = vector<ll>;using vvll = vector<vector<ll>>;\xa0#define all(x) x.begin(), x.end()#define ckmin(a,b) a = min(a,b)#define ckmax(a,b) a = max(a,b)\xa0void solve() {    int N;    cin >> N;        vll A(N);    for (int i=0;i<N;i++) cin >> A[i];\xa0    ll ans = 0;    for (ll a : A) ans += a;    ans -= 2 * A[N-2];    cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(NULL);\xa0    int T;    cin >> T;    for (int t=0;t<T;t++) solve();\xa0\xa0    return 0;}']",,,"['constructive algorithms', 'greedy', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Battle for Survive.json,https://codeforces.com/blog/entry/134170,SolutionIt can be noted that the value of will always be negative in the final result Therefore we can subtract the sum from and then subtract from Thus the final sum will be This value cannot be exceeded because will always be negative 
https://codeforces.com//contest/621/problem/E,46905,E,621E,621,E. Wet Shark and Blocks,There are blocks of digits Each one consisting of the same digits which are given to you in the input Wet Shark must choose digit from each block and concatenate all of those digits together to form one large integer For example if he chooses digit from the first block and digit from the second block he gets the integer Wet Shark then takes this number modulo Please tell him how many ways he can choose one digit from each block so that he gets exactly as the final result As this number may be too large print it modulo Note that the number of ways to choose some digit in the block is equal to the number of it s occurrences For example there are ways to choose digit from block ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int((x).size()))\n#define bit(x) (1 << (x))\n#define cnt1(x) (__builtin_popcount(x))\n\ntemplate<class T, class U>\ninline void chkmax(T& x, U y) {\n\tif (x < y) x = y;\n}\n\ntemplate<class T, class U>\ninline void chkmin(T& x, U y) {\n\tif (y < x) x = y;\n}\n\ntypedef long long LL;\ntypedef double DB;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\nconst int MX = 105;\nconst int M = 1000000007;\nint x;\nint r[MX][MX], a[MX][MX];\nint tp[MX][MX];\nint c[10];\n\ninline void add(int& x, int y) {\n\tx += y;\n\tif (x >= M) x -= M;\n}\n\nvoid mul(int a[MX][MX], int b[MX][MX]) {\n\tint i, j, k, val;\n\t\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < x; j++) {\n\t\t\tval = 0;\n\t\t\tfor (k = 0; k < x; k++) add(val, LL(a[i][k]) * b[k][j] % M);\n\t\t\ttp[i][j] = val;\n\t\t}\n\t}\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < x; j++) a[i][j] = tp[i][j];\n\t}\n}\n\nint main() {\n//\tfreopen(""in.txt"", ""r"", stdin);\n//\tfreopen(""out.txt"", ""w"", stdout);\n\t\n\tint n, b, k, i, t;\n\t\n\tscanf(""%d%d%d%d"", &n, &b, &k, &x);\n\twhile (n--) {\n\t\tscanf(""%d"", &t);\n\t\tc[t]++;\n\t}\n\tfor (i = 0; i < x; i++) {\n\t\tfor (t = 0; t < 10; t++) {\n\t\t\tadd(a[i][(i * 10 + t) % x], c[t]);\n\t\t}\n\t}\n\tfor (i = 0; i < x; i++) r[i][i]++;\n\tfor (; b; b /= 2) {\n\t\tif (b & 1) mul(r, a);\n\t\tmul(a, a);\n\t}\n\tprintf(""%d\\n"", r[0][k]);\n\treturn 0;\n}']",,,"['dp', 'matrices']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Wet Shark and Blocks.json,https://codeforces.com//blog/entry/23196,First let us build an X by X matrix We will be applying matrix exponentiation on this matrix For each modulo value T from 0 to X 1 and each value in the array with index i between 1 and n we will do matrix T 10 T arr i 
https://codeforces.com//contest/779/problem/C,95637,C,779C,779,C. Dishonest Sellers,Igor found out discounts in a shop and decided to buy items Discounts at the store will last for a week and Igor knows about each item that its price now is and after a week of discounts its price will be Not all of sellers are honest so now some products could be more expensive than after a week of discounts Igor decided that buy of items now but wait with the rest of the week in order to save money as much as possible Your task is to determine the minimum money that Igor can spend to buy all items ,"['#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <stack>\n#define sz size()\n#define pb push_back\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll exp(ll t,ll x){if(x==0) return 1;if(x==1) return t;if(x%2==1) return (t*exp((t*t)%mod,x/2))%mod;if(x%2==0) return exp((t*t)%mod,x/2);} \nll gcd(ll x,ll y){return x%y==0?y:gcd(y,x%y);}\nll lcm(ll x,ll y){return x*(y/gcd(x,y));}\nll bsum(ll u,ll b){return u<b?u:bsum(u/b,b)+u%b;}\nll prival(ll u,ll p){int cn=0;while(u%p==0){cn++;u=u/p;}return cn;}\nbool isprime(ll x){for(ll i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\nvoid YAY(void){cout<<""YES""<<endl;}\nvoid NAY(void){cout<<""NO""<<endl;}\nll a[222222];\nll b[222222];\npair<ll, int> stuf[222222]; // a-b, index\nint n, k, epo;\nll ans;\n\nint main(void)\n{\n\tint i, j;\n\tcin>>n>>k;\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tscanf(""%lld"",&a[i]);\n\t}\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tscanf(""%lld"",&b[i]);\n\t}\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tstuf[i].first=a[i]-b[i];\n\t\tstuf[i].second=i;\n\t}\n\tsort(stuf+1,stuf+n+1);\n\tfor(i=k ; i<=n ; i++)\n\t{\n\t\tif(i==n || stuf[i+1].first>=0)\n\t\t{\n\t\t\tbreak; // ~i use \n\t\t}\n\t}\n\tepo=i;\n\tfor(i=1 ; i<=epo ; i++)\n\t{\n\t\tans+=a[stuf[i].second];\n\t}\n\tfor(i=epo+1 ; i<=n ; i++)\n\t{\n\t\tans+=b[stuf[i].second];\n\t}\n\tcout<<ans;\n\t\n}\n']",,,"['constructive algorithms', 'greedy', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Dishonest Sellers.json,https://codeforces.com//blog/entry/50724,To solve this problem we need at first to sort all items in increasing order of values Then let s iterate through sorted array If for the current item we did not buy items now and if after discounts it will cost not more than now we need to buy it now and pay in the other case we need to buy item after discounts and pay 
https://codeforces.com//contest/796/problem/A,102472,A,796A,796,A. Buying A House,Zane the wizard had never loved anyone before until he fell in love with a girl whose name remains unknown to us The girl lives in house of a village There are houses in that village lining in a straight line from left to right house house house The village is also well structured house and house are exactly meters away In this village some houses are occupied and some are not Indeed unoccupied houses can be purchased You will be given integers that denote the availability and the prices of the houses If house is occupied and therefore cannot be bought then equals Otherwise house can be bought and represents the money required to buy it in dollars As Zane has only dollars to spare it becomes a challenge for him to choose the house to purchase so that he could live as near as possible to his crush Help Zane determine the minimum distance from his crush s house to some house he can afford to help him succeed in his love ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, a[10000];\nint main() {\n\tcin >> n >> m >> k;\n\tint ans = n + 1;\n\tm--;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tif (a[i] != 0 && a[i] <= k) {\n\t\t\tans = min(ans, abs(m - i));\n\t\t}\n\t}\n\tcout << ans * 10 << endl;\n}']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Buying A House.json,https://codeforces.com/blog/entry/51527,This is a simple implementation problem Let the be infinity initially Iterate through the houses Suppose we are considering house update the if and only if1 2 and3 The answer is This solution runs in 
https://codeforces.com//contest/1198/problem/E,380939,E,1198E,1198,E. Rectangle Painting 2,There is a square grid of size n times n Some cells are colored in black all others are colored in white In one operation you can select some rectangle and color all its cells in white It costs min h w to color a rectangle of size h times w You are to make all cells white for minimum total cost The square is large so we give it to you in a compressed way The set of black cells is the union of m rectangles ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int inf=1e9;\n\nusing T = int;\nstruct Flow {\n  struct E {\n    int dest;\n    T orig, *lim, *rev;\n  };\n  int zr, uj, n = 0;\n  vector<unique_ptr<T>> ts;\n  vector<vector<E>> graf;\n  vector<int> ptr, odl;\n  void vert(int v) {\n    n = max(n, v + 1);\n    graf.resize(n);\n    ptr.resize(n);\n    odl.resize(n);\n  }\n  bool iszero(T v) {\n    return !v; // Zmienić dla doubli.\n  }\n  void bfs() {\n    fill(odl.begin(), odl.end(), 0);\n    vector<int> kol = {zr};\n    odl[zr] = 1;\n    for (int i = 0; i < (int) kol.size(); i++) {\n      for (E& e : graf[kol[i]]) {\n        if (!odl[e.dest] and !iszero(*e.lim)) {\n          odl[e.dest] = odl[kol[i]] + 1;\n          kol.push_back(e.dest);\n        }\n      }\n    }\n  }\n  T dfs(int v, T lim) {\n    if (v == uj) return lim;\n    T ret = 0, wez;\n    for (int& i = ptr[v]; i < (int) graf[v].size(); i++) {\n      E& e = graf[v][i];\n      if (odl[e.dest] == odl[v] + 1 and !iszero(*e.lim) and\n          !iszero(wez = dfs(e.dest, min(*e.lim, lim)))) {\n        ret += wez;\n        *e.lim -= wez;\n        *e.rev += wez;\n        lim -= wez;\n        if (iszero(lim)) break;\n      }\n    }\n    return ret;\n  }\n  void add_edge(int u, int v, T lim, bool bi = false /* bidirectional? */) {\n    vert(max(u, v));\n    T *a = new T(lim), *b = new T(lim * bi);\n    ts.emplace_back(a);\n    ts.emplace_back(b);\n    graf[u].push_back(E{v, lim,      a, b});\n    graf[v].push_back(E{u, lim * bi, b, a});\n  }\n  T dinic(int zr_, int uj_) {\n    zr = zr_; uj = uj_;\n    vert(max(zr, uj));\n    T ret = 0;\n    while (true) {\n      bfs();\n      fill(ptr.begin(), ptr.end(), 0);\n      const T sta = dfs(zr, numeric_limits<T>::max());  // Dla doubli można dać\n      if (iszero(sta)) break;                           // infinity() zamiast\n      ret += sta;                                       // max().\n    }\n    return ret;\n  }\n  vector<int> cut() {\n    vector<int> ret;\n    bfs();\n    for (int i = 0; i < n; i++)\n      if (odl[i])\n        ret.push_back(i);\n    return ret;\n  }\n  map<pair<int, int>, T> get_flowing() {  // Tam gdzie plynie 0 może nie być\n    map<pair<int, int>, T> ret;           // krawędzi.\n    for (int i = 0; i < n; i++)\n      for (E& e : graf[i])\n        if (*e.lim < e.orig)\n          ret[make_pair(i, e.dest)] += e.orig - *e.lim;\n    for (auto& i : ret) {\n      const pair<int, int> rev{i.first.second, i.first.first};\n      const T x = min(i.second, ret[rev]);\n      i.second -= x;\n      ret[rev] -= x;\n    }\n    return ret;\n  }\n};\n\nint n, m;\n\npii x[nax];\npii y[nax];\n\nvi tx, ty;\nint k;\nint kx[nax];\nint ky[nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tscanf(""%d%d%d%d"", &x[i].first, &y[i].first, &x[i].second, &y[i].second);\n\t\ttx.push_back(x[i].second);\n\t\ttx.push_back(x[i].first-1);\n\t\tty.push_back(y[i].second);\n\t\tty.push_back(y[i].first-1);\n\t}\n\ttx.push_back(0);\n\tty.push_back(0);\n\ttx.push_back(n);\n\tty.push_back(n);\n\tsort(tx.begin(), tx.end());\n\tsort(ty.begin(), ty.end());\n\ttx.resize(unique(tx.begin(), tx.end())-tx.begin());\n\tty.resize(unique(ty.begin(), ty.end())-ty.begin());\n\tFlow janusz;\n\tfor (int i=1; i<(int)tx.size(); i++)\n\t{\n\t\tk++;\n\t\tkx[i]=k;\n\t\tjanusz.add_edge(0, k, tx[i]-tx[i-1]);\n\t}\n\tfor (int i=1; i<(int)ty.size(); i++)\n\t{\n\t\tk++;\n\t\tky[i]=k;\n\t}\n\tk++;\n\tfor (int i=1; i<(int)ty.size(); i++)\n\t{\n\t\tjanusz.add_edge(ky[i], k, ty[i]-ty[i-1]);\n\t}\n\tdebug() << tx;\n\tdebug() << ty;\n\tdebug() << imie(k);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tfor (int a=1; a<(int)tx.size(); a++)\n\t\t{\n\t\t\tfor (int b=1; b<(int)ty.size(); b++)\n\t\t\t{\n\t\t\t\tif (tx[a]<=x[i].second && tx[a]>=x[i].first && ty[b]<=y[i].second && ty[b]>=y[i].first)\n\t\t\t\t\tjanusz.add_edge(kx[a], ky[b], inf);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", janusz.dinic(0, k));\n\treturn 0;\n}\n']",,,"['flows', 'graph matchings', 'graphs']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Rectangle Painting 2.json,https://codeforces.com/blog/entry/68812,If we use some rectangle then we can change it to without changing the cost Also we can choose rectangles of width instead of one rectangle of width it will not change the cost So we have to choose minimal number of columns and rows such that all black cells are covered by at least one chosen column row If we will build a bipartite graph left part is columns right part is rows there is an edge iff the cell in the intersection of given row and column is black then the answer is minimal vertex cover in this graph Minimal vertex cover is the same size as maximum matching which can be found using flow All that is left is to see that we can compress identical vertices and we will have vertices in both parts With Dinic algorithm complexity is 
https://codeforces.com//contest/148/problem/E,883,E,148E,148,E. Porcelain,During her tantrums the princess usually smashes some collectable porcelain Every furious shriek is accompanied with one item smashed The collection of porcelain is arranged neatly on shelves Within each shelf the items are placed in one row so that one can access only the outermost items the leftmost or the rightmost item not the ones in the middle of the shelf Once an item is taken the next item on that side of the shelf can be accessed see example Once an item is taken it can t be returned to the shelves You are given the values of all items Your task is to find the maximal damage the princess tantrum of shrieks can inflict on the collection of porcelain ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint dp[111][11111],sum[111];\nint a[111][111];\nint main()\n{\n    int i,j,k,n,m;\n    scanf(""%d%d"",&n,&m);\n    clr(a);\n    for (i=0;i<n;i++)\n    {\n        int c;\n        int v[111];\n        scanf(""%d"",&c);\n        for (j=1;j<=c;j++)\n        {\n            scanf(""%d"",v+j);\n        }\n        clr(sum);\n        sum[0]=0;\n        for (j=1;j<=c;j++)\n        {\n            sum[j]=sum[j-1]+v[j];\n        }\n        for (j=1;j<=c;j++)\n        {\n            for (k=0;k<=j;k++)\n            {\n                int t=sum[k]+sum[c]-sum[c-(j-k)];\n                a[i][j]=max(a[i][j],t);\n            }\n        }\n    }\n    //printf(""%d\\n"",a[0][3]);\n    memset(dp,200,sizeof(dp));\n    dp[0][0]=0;\n    for (i=0;i<n;i++)\n    {\n        for (j=0;j<=m;j++)if (dp[i][j]>=0)\n        {\n            for (k=0;k<=100&&j+k<=m;k++)\n            {\n                dp[i+1][j+k]=max(dp[i+1][j+k],dp[i][j]+a[i][k]);\n            }\n        }\n    }\n    printf(""%d\\n"",*max_element(dp[n],dp[n]+m+1));\n    return 0;\n}\n']",,,['dp'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Porcelain.json,https://codeforces.com//blog/entry/3819,This problem involved dynamic programming with precalculation The first part of the solution was to precalculate the maximal cost of i items taken from the shelf i ranging from 1 to the number of items on the shelf for each shelf Note that this can t be done greedily this can be seen on the shelf 6 5 1 10 1 1 5 The second part is a standard dynamic programming which calculates the maximal cost of items taken for index of last shelf used and total number of items taken To advance to the next shelf one has to try all possible numbers of items taken from it and increase the total cost of items taken by corresponding precalculated values 
https://codeforces.com//contest/759/problem/B,89811,B,759B,759,B. Travel Card,A new innovative ticketing systems for public transport is introduced in Bytesburg Now there is a single travel card for all transport To make a trip a passenger scan his card and then he is charged according to the fare The fare is constructed in the following manner There are three types of tickets a ticket for one trip costs byteland rubles a ticket for minutes costs byteland rubles a ticket for one day minutes costs byteland rubles Note that a ticket for minutes activated at time can be used for trips started in time range from to inclusive Assume that all trips take exactly one minute To simplify the choice for the passenger the system automatically chooses the optimal tickets After each trip starts the system analyses all the previous trips and the current trip and chooses a set of tickets for these trips with a minimum total cost Let the minimum total cost of tickets to cover all trips from the first to the current is and the total sum charged before is Then the system charges the passenger the sum You have to write a program that for given trips made by a passenger calculates the sum the passenger is charged after each trip ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100001];\nint d[100001];\n\nint main() {\n\tint i, n;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\td[i] = min(min(d[i - 1] + 20, d[upper_bound(a, a + i, a[i] - 90) - a - 1] + 50), d[upper_bound(a, a + i, a[i] - 1440) - a - 1] + 120);\n\t\tprintf(""%d\\n"", d[i] - d[i - 1]);\n\t}\n}']",,,"['binary search', 'dp', 'greedy', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Travel Card.json,https://codeforces.com//blog/entry/49946,Hint the problem looks difficult because tickets can change however it s can be solved with simple dynamic programming You are asked the difference between neighboring dp s subtasks 
https://codeforces.com//contest/1967/problem/C,2620322,C,1967C,1967,C. Fenwick Tree,Let operatorname lowbit x denote the value of the lowest binary bit of x e g operatorname lowbit 12 4 operatorname lowbit 8 8 For an array a of length n if an array s of length n satisfies s k left sum limits i k operatorname lowbit k 1 k a i right bmod 998 244 353 for all k then s is called the of a Let s denote it as s f a For a positive integer k and an array a f k a is defined as follows f k a begin cases f a textrm if k 1 f f k 1 a textrm otherwise end cases You are given an array b of length n and a positive integer k Find an array a that satisfies 0 le a i 998 244 353 and f k a b It can be proved that an answer always exists If there are multiple possible answers you may print any of them ,"['/** *    author:  tourist *    created: 30.04.2024 11:03:36**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0template <typename T>T inverse(T a, T m) {  T u = 0, v = 1;  while (a != 0) {    T t = m / a;    m -= t * a; swap(a, m);    u -= t * v; swap(u, v);  }  assert(m == 1);  return u;}\xa0template <typename T>class Modular { public:  using Type = typename decay<decltype(T::value)>::type;\xa0  constexpr Modular() : value() {}  template <typename U>  Modular(const U& x) {    value = normalize(x);  }\xa0  template <typename U>  static Type normalize(const U& x) {    Type v;    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);    else v = static_cast<Type>(x % mod());    if (v < 0) v += mod();    return v;  }\xa0  const Type& operator()() const { return value; }  template <typename U>  explicit operator U() const { return static_cast<U>(value); }  constexpr static Type mod() { return T::value; }\xa0  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }  Modular& operator++() { return *this += 1; }  Modular& operator--() { return *this -= 1; }  Modular operator++(int) { Modular result(*this); *this += 1; return result; }  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }  Modular operator-() const { return Modular(-value); }\xa0  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));    return *this;  }  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());    value = normalize(value * rhs.value - q * mod());    return *this;  }  template <typename U = T>  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(value * rhs.value);    return *this;  }\xa0  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\xa0  friend const Type& abs(const Modular& x) { return x.value; }\xa0  template <typename U>  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\xa0  template <typename U>  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\xa0  template <typename V, typename U>  friend V& operator>>(V& stream, Modular<U>& number);\xa0 private:  Type value;};\xa0template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\xa0template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\xa0template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\xa0template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\xa0template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\xa0template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\xa0template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\xa0template<typename T, typename U>Modular<T> power(const Modular<T>& a, const U& b) {  assert(b >= 0);  Modular<T> x = a, res = 1;  U p = b;  while (p > 0) {    if (p & 1) res *= x;    x *= x;    p >>= 1;  }  return res;}\xa0template <typename T>bool IsZero(const Modular<T>& number) {  return number() == 0;}\xa0template <typename T>string to_string(const Modular<T>& number) {  return to_string(number());}\xa0// U == std::ostream? but done this way because of fastoutputtemplate <typename U, typename T>U& operator<<(U& stream, const Modular<T>& number) {  return stream << number();}\xa0// U == std::istream? but done this way because of fastinputtemplate <typename U, typename T>U& operator>>(U& stream, Modular<T>& number) {  typename common_type<typename Modular<T>::Type, long long>::type x;  stream >> x;  number.value = Modular<T>::normalize(x);  return stream;}\xa0/*using ModType = int;\xa0struct VarMod { static ModType value; };ModType VarMod::value;ModType& md = VarMod::value;using Mint = Modular<VarMod>;*/\xa0constexpr int md = 998244353;using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\xa0vector<Mint> fact(1, 1);vector<Mint> inv_fact(1, 1);\xa0Mint C(int n, int k) {  if (k < 0 || k > n) {    return 0;  }  k = min(k, n - k);  while ((int) fact.size() < k + 1) {    fact.push_back(fact.back() * (int) fact.size());    inv_fact.push_back(1 / fact.back());  }  Mint ret = inv_fact[k];  for (int i = 1; i <= k; i++) {    ret *= n - i + 1;  }  return ret;}\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, k;    cin >> n >> k;    vector<Mint> b(n);    for (int i = 0; i < n; i++) {      cin >> b[i];    }    vector<Mint> a(n);    for (int i = 0; i < n; i++) {      int j = 0;      while (i & (1 << j)) {        j += 1;      }      for (int t = 0; t < (1 << j) - 1; t++) {        int who = i - (1 << j) + 1 + t;        int vals = j - __builtin_popcount(t);        b[i] -= a[who] * C(vals + k - 1, k - 1);      }      a[i] = b[i];    }    for (int i = 0; i < n; i++) {      cout << a[i] << "" \\n""[i == n - 1];    }  }  return 0;}']",,,"['bitmasks', 'brute force', 'combinatorics', 'data structures', 'dp', 'math', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Fenwick Tree.json,https://codeforces.com//blog/entry/129027,It s well known that Fenwick Tree is the data structure shown in the image below and the sum of each subtree is stored at each vertex i e and Denote the depth of a vertex as Assume that Consider a vertex and one of its ancestors Let It can be easily proved by using the stars and bars method or generating functions that the coefficient of in is Obviously is satisfied for each leaf Enumerate each vertex whose value is already known just in the increasing order is fine and all its ancestors remove the part from and we can calculate the value of each vertex Time complexity is because the height of a Fenwick Tree is 
https://codeforces.com//contest/1634/problem/F,1285098,F,1634F,1634,F. Fibonacci Additions,One of my most productive days was throwing away 1 000 lines of code Ken Thompson is an operation on an array X of integers parametrized by indices l and r Fibonacci addition increases X l by F 1 increases X l 1 by F 2 and so on up to X r which is increased by F r l 1 F i denotes the i th Fibonacci number F 1 1 F 2 1 F i F i 1 F i 2 for i 2 and You are given two arrays A and B of the same length We will ask you to perform several Fibonacci additions on these arrays with different parameters and after each operation you have to report whether arrays A and B are equal modulo MOD ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n,q,mod,fib[300003],FA[300003],FB[300003],_FA[300003],_FB[300003],df;\nvoid addA(int x,int dt){\n\tif(_FA[x]==_FB[x])df++;\n\t_FA[x]=(_FA[x]+dt)%mod;\n\tif(_FA[x]==_FB[x])df--;\n}\nvoid addB(int x,int dt){\n\tif(_FA[x]==_FB[x])df++;\n\t_FB[x]=(_FB[x]+dt)%mod;\n\tif(_FA[x]==_FB[x])df--;\n}\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n//\tfreopen(""a.out"",""w"",stdout);\n\tcin>>n>>q>>mod;\n\tfib[1]=1%mod;\n\tfib[2]=1%mod;\n\tfor(int i=3;i<300003;i++)\n\t\tfib[i]=(fib[i-1]+fib[i-2])%mod; \n\tfor(int i=1;i<=n;i++)\n\t\tscanf(""%d"",FA+i);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(""%d"",FB+i);\n\t_FA[1]=FA[1];_FA[2]=(FA[2]-FA[1]+mod)%mod;\n\t_FB[1]=FB[1];_FB[2]=(FB[2]-FB[1]+mod)%mod;\n\tfor(int i=3;i<=n;i++){\n\t\t_FA[i]=((FA[i]-FA[i-1]-FA[i-2])%mod+mod)%mod;\n\t\t_FB[i]=((FB[i]-FB[i-1]-FB[i-2])%mod+mod)%mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(_FA[i]!=_FB[i])\n\t\t\tdf++;\n//\tfor(int i=1;i<=n;i++)cout<<_FA[i]<<\' \';cout<<endl;\n//\tfor(int i=1;i<=n;i++)cout<<_FB[i]<<\' \';cout<<endl;\n\twhile(q--){\n\t\tchar c=\'.\';\n\t\tint l,r;\n\t\twhile(c!=\'A\'&&c!=\'B\')c=getchar();\n\t\tscanf(""%d%d"",&l,&r);\n\t\tif(c==\'A\'){\n\t\t\taddA(l,1%mod);\n\t\t\tif(r+1<=n)addB(r+1,fib[r-l+2]);\n\t\t\tif(r+2<=n)addB(r+2,fib[r-l+1]);\n\t\t}else{\n\t\t\taddB(l,1%mod);\n\t\t\tif(r+1<=n)addA(r+1,fib[r-l+2]);\n\t\t\tif(r+2<=n)addA(r+2,fib[r-l+1]);\n\t\t}\n\t\tif(!df)\n\t\t\tprintf(""YES\\n"");\n\t\telse\n\t\t\tprintf(""NO\\n"");\n//\t\tfor(int i=1;i<=n;i++)cout<<_FA[i]<<\' \';cout<<endl;\n//\t\tfor(int i=1;i<=n;i++)cout<<_FB[i]<<\' \';cout<<endl;\n\t}\n}\n']",,,"['brute force', 'data structures', 'hashing', 'implementation', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Fibonacci Additions.json,https://codeforces.com//blog/entry/99563,Let Consider another auxiliary array where and for Notice that arrays and are equal if and only if all elements of are equal to Let s analyze how Fibonacci addition affects If Fibonacci addition is performed on array on a segment from to then will increase by will decrease by and will decrease by Fibonacci addition on can be handled in a similar way Fibonacci numbers modulo can be easily precomputed and therefore the problem can be solved in linear time 
https://codeforces.com//contest/634/problem/B,49945,B,634B,634,B. XOR Equation,Two integers and have a sum of and a bitwise XOR of How many possible values are there for the ordered pair ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nll solve(ll s, ll x)\n{\n\tll os = s;\n\tll ways = 1;\n\tfor (int qaz = 60; qaz >= 0; qaz--)\n\t{\n\t\tll c = 1LL << qaz;\n\t\tif (c & x)\n\t\t{\n\t\t\tways *= 2;\n\t\t\ts -= c;\n\t\t\tif (s < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll change = c*2;\n\t\t\tif (change <= s)\n\t\t\t\ts -= change;\n\t\t}\n\t}\n\tif (s != 0)\n\t\treturn 0;\n\tif (os == x)\n\t\tways -= 2;\n\treturn ways;\n}\n\nint main()\n{\n\tll s, x;\n\trint(s); rint(x);\n\tprintf(""%lld\\n"", solve(s, x));\n}\n']",,,"['constructive algorithms', 'dp', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. XOR Equation.json,https://codeforces.com//blog/entry/43467,For any two integers a and b we have where is the xor and a b is the bitwise AND This is because is non carrying binary addition Thus we can find a b s x 2 if this is not an integer there are no solutions Now for each bit we have 4 cases and If then ai bi so we have one possibility ai bi ai bi If then we must have ai bi 0 otherwise we print 0 and we have two choices ai 1 and bi 0 or vice versa Thus we can return 2n where n is the number of one bits in x Remember to subtract 2 for the cases a 0 or b 0 if necessary 
https://codeforces.com//contest/866/problem/G,125346,G,866G,866,G. Flowers and Chocolate,It s Piegirl s birthday soon and Pieguy has decided to buy her a bouquet of flowers and a basket of chocolates The flower shop has different types of flowers available The th type of flower always has exactly petals Pieguy has decided to buy a bouquet consisting of exactly flowers He may buy the same type of flower multiple times The flowers are then arranged into a bouquet The position of the flowers within a bouquet matters You can think of a bouquet as an ordered list of flower types The chocolate shop sells chocolates in boxes There are different types of boxes available The th type of box contains pieces of chocolate Pieguy can buy any number of boxes and can buy the same type of box multiple times He will then place these boxes into a basket The position of the boxes within the basket matters You can think of the basket as an ordered list of box types Pieguy knows that Piegirl likes to pluck a petal from a flower before eating each piece of chocolate He would like to ensure that she eats the last piece of chocolate from the last box just after plucking the last petal from the last flower That is the total number of petals on all the flowers in the bouquet should equal the total number of pieces of chocolate in all the boxes in the basket How many different bouquet basket combinations can Pieguy buy The answer may be very large so compute it modulo ,"['/**\n *    author:  tourist\n *    created: 06.01.2019 23:15:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular inverse() const {\n    Type a = value, b = mod(), u = 0, v = 1;\n    while (a != 0) {\n      Type t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    assert(b == 1);\n    return Modular(u);\n  }\n  Modular& operator/=(const Modular& other) { return *this *= other.inverse(); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  stream >> number.value;\n  number.value = Modular<T>::normalize(number.value);\n  return stream;\n}\n\nstruct VarMod { static int value; };\nint VarMod::value;\n\n//using Mint = Modular<VarMod>;\nusing Mint = Modular<std::integral_constant<int, (int) 1e9 + 7>>;\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    a.clear();\n  } else {\n    vector<T> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) c.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        a[i + j] += c[i] * b[j];\n      }\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c *= b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> x = b * b * vector<T>(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T> {1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\nnamespace fft {\n\ntypedef double dbl;\n\nstruct num {\n  dbl x, y;\n  num() { x = y = 0; }\n  num(dbl x_, dbl y_) : x(x_), y(y_) {}\n};\n\ninline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\ninline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\ninline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\ninline num conj(num a) { return num(a.x, -a.y); }\n\nint base = 1;\nvector<num> roots = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\n\nconst dbl PI = static_cast<dbl>(acosl(-1.0));\n\nvoid ensure_base(int nbase) {\n  if (nbase <= base) {\n    return;\n  }\n  rev.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); i++) {\n    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n    for (int i = 1 << (base - 1); i < (1 << base); i++) {\n      roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n      dbl angle_i = angle * (2 * i + 1 - (1 << base));\n      roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n    }\n    base++;\n  }\n}\n\nvoid fft(vector<num> &a, int n = -1) {\n  if (n == -1) {\n    n = (int) a.size();\n  }\n  assert((n & (n - 1)) == 0);\n  int zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; i++) {\n    if (i < (rev[i] >> shift)) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        num z = a[i + j + k] * roots[j + k];\n        a[i + j + k] = a[i + j] - z;\n        a[i + j] = a[i + j] + z;\n      }\n    }\n  }\n}\n\nvector<num> fa, fb;\n\nvector<int64_t> square(const vector<int>& a) {\n  if (a.empty()) {\n    return {};\n  }\n  int need = (int) a.size() + (int) a.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if ((sz >> 1) > (int) fa.size()) {\n    fa.resize(sz >> 1);\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n    int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz >> 1);\n  num r(1.0 / (sz >> 1), 0.0);\n  for (int i = 0; i <= (sz >> 2); i++) {\n    int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n    num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n    num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n    num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n    num tmp = fe * fo;\n    fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n    fa[j] = r * (aux + num(0, 2) * tmp);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int64_t> multiply(const vector<int>& a, const vector<int>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (a.size() == b.size() && a == b) {\n    return square(a);\n  }\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < sz; i++) {\n    int x = (i < (int) a.size() ? a[i] : 0);\n    int y = (i < (int) b.size() ? b[i] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz);\n  num r(0, -0.25 / (sz >> 1));\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n    fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n    fa[i] = z;\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n    num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n    fa[i] = A0 + A1 * num(0, 1);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  int eq = (a.size() == b.size() && a == b);\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < (int) a.size(); i++) {\n    int x = (a[i] % m + m) % m;\n    fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n  }\n  fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});\n  fft(fa, sz);\n  if (sz > (int) fb.size()) {\n    fb.resize(sz);\n  }\n  if (eq) {\n    copy(fa.begin(), fa.begin() + sz, fb.begin());\n  } else {\n    for (int i = 0; i < (int) b.size(); i++) {\n      int x = (b[i] % m + m) % m;\n      fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n    }\n    fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});\n    fft(fb, sz);\n  }\n  dbl ratio = 0.25 / sz;\n  num r2(0, -1);\n  num r3(ratio, 0);\n  num r4(0, -ratio);\n  num r5(0, 1);\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num a1 = (fa[i] + conj(fa[j]));\n    num a2 = (fa[i] - conj(fa[j])) * r2;\n    num b1 = (fb[i] + conj(fb[j])) * r3;\n    num b2 = (fb[i] - conj(fb[j])) * r4;\n    if (i != j) {\n      num c1 = (fa[j] + conj(fa[i]));\n      num c2 = (fa[j] - conj(fa[i])) * r2;\n      num d1 = (fb[j] + conj(fb[i])) * r3;\n      num d2 = (fb[j] - conj(fb[i])) * r4;\n      fa[i] = c1 * d1 + c2 * d2 * r5;\n      fb[i] = c1 * d2 + c2 * d1;\n    }\n    fa[j] = a1 * b1 + a2 * b2 * r5;\n    fb[j] = a1 * b2 + a2 * b1;\n  }\n  fft(fa, sz);\n  fft(fb, sz);\n  vector<int> res(need);\n  for (int i = 0; i < need; i++) {\n    int64_t aa = llround(fa[i].x);\n    int64_t bb = llround(fb[i].x);\n    int64_t cc = llround(fa[i].y);\n    res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);\n  }\n  return res;\n}\n\n}  // namespace fft\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type& operator*=(\n    vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  vector<int> A(a.size());\n  for (int i = 0; i < (int) A.size(); i++) {\n    A[i] = static_cast<int>(a[i]);\n  }\n  vector<int> B(b.size());\n  for (int i = 0; i < (int) B.size(); i++) {\n    B[i] = static_cast<int>(b[i]);\n  }\n  vector<int> C = fft::multiply_mod(A, B, T::value);\n  a.resize(C.size());\n  for (int i = 0; i < (int) C.size(); i++) {\n    a[i] = C[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type operator*(\n    const vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  vector<Modular<T>> c = a;\n  return c *= b;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int f, b;\n  long long n;\n  cin >> f >> b >> n;\n  vector<int> p(f);\n  for (int i = 0; i < f; i++) {\n    cin >> p[i];\n  }\n  vector<int> c(b);\n  for (int i = 0; i < b; i++) {\n    cin >> c[i];\n  }\n  int mx = *max_element(c.begin(), c.end());\n  vector<Mint> md(mx + 1);\n  md[mx]++;\n  for (int i = 0; i < b; i++) {\n    md[mx - c[i]]--;\n  }\n  vector<Mint> sum;\n  for (int i = 0; i < f; i++) {\n    sum += power({0, 1}, p[i], md);\n  }\n  vector<Mint> res = power(sum, n, md);\n  vector<Mint> final(mx);\n  final[mx - 1] = 1;\n  res = res * final % md;\n  debug(res);\n  cout << ((int) res.size() <= mx - 1 ? Mint(0) : res[mx - 1]) << \'\\n\';\n  return 0;\n}\n']",,,['math'],3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\G. Flowers and Chocolate.json,https://codeforces.com//blog/entry/54888,Let s first consider how to compute the number of ways to make a bouquet with exactly K petals Define a polynomial Then if we compute P x N the coefficient of xK gives the number of ways to make a bouquet with exactly K petals This is because each possible bouquet produces a term with an exponent equal to its number of petals Now lets consider how to compute the number of ways to make a basket with exactly K chocolates Define a polynomial Then if we compute the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates This can be derived from a Generating Function but we will provide an alternate derivation Now let s define a polynomial Initially W x 1 Lines 3 through 5 add a multiple of Q x to W x and line 6 divides W x by x It follows that the resulting polynomial is congruent to x K modulo Q x The final answer is the sum over all values of K of the number of bouquets with K petals times the number of baskets with K chocolates The number of bouquets is given by the xK coefficient of P x N or equivalently the x K coefficient of P x 1 N and the number of baskets is given by the coefficient of x0 of It follows that the answer is simply the coefficient of x0 of This can be computed using polynomial multiplications each of which takes O max ci 2 time using naive multiplication for a total runtime of 
https://codeforces.com//contest/863/problem/B,123492,B,863B,863,B. Kayaking,Vadim is really keen on travelling Recently he heard about kayaking activity near his town and became very excited about it so he joined a party of kayakers Now the party is ready to start its journey but firstly they have to choose kayaks There are people in the group including Vadim and they have exactly tandem kayaks each of which obviously can carry two people and single kayaks th person s weight is and weight is an important matter in kayaking if the difference between the weights of two people that sit in the same tandem kayak is too large then it can crash And of course people want to distribute their seats in kayaks in order to minimize the chances that kayaks will crash Formally the instability of a single kayak is always and the instability of a tandem kayak is the absolute difference between weights of the people that are in this kayak Instability of the whole journey is the total instability of all kayaks Help the party to determine minimum possible total instability ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n;\n\twhile (~scanf(""%d"", &n)) {\n\t\tvector<int> w(n * 2);\n\t\tfor (int i = 0; i < n * 2; ++ i)\n\t\t\tscanf(""%d"", &w[i]);\n\t\tsort(w.begin(), w.end());\n\t\tvector<vi> dp(n * 2 + 1, vi(3, INF));\n\t\tdp[0][0] = 0;\n\t\trep(i, n * 2) rep(j, 3) {\n\t\t\tint x = dp[i][j];\n\t\t\tif (x == INF) continue;\n\t\t\tif (i + 2 <= n * 2)\n\t\t\t\tamin(dp[i + 2][j], x + (w[i + 1] - w[i]));\n\t\t\tif (j < 2)\n\t\t\t\tamin(dp[i + 1][j + 1], x);\n\t\t}\n\t\tint ans = dp.back()[2];\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'greedy', 'sortings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Kayaking.json,https://codeforces.com//blog/entry/54708,Firstly let s learn how to split persons in pairs as if there are no single kayaks Let there be people with weights and Obviously the lowest instability you can achieve is Swapping any two elements will only make the result greater This greedy strategy can be used to distribute all the seats Now you need to check every pair of persons to seat in single kayaks and calculate total instability for the rest The answer will be the minimun instabily over all pairs Overall complexity 
https://codeforces.com//contest/1592/problem/E,1129223,E,1592E,1592,E. Bored Bakry,Bakry got bored of solving problems related to xor so he asked you to solve this problem for him You are given an array a of n integers a 1 a 2 ldots a n Let s call a subarray a l a l 1 a l 2 ldots a r if a l a l 1 a l 2 ldots a r a l oplus a l 1 oplus a l 2 ldots oplus a r where oplus denotes the bitwise XOR operation and denotes the bitwise AND operation Find the length of the longest good subarray of a or determine that no such subarray exists ,"['#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nconst int mod1=998244353,mod2=19491001;\nint n,a[1000005],b[1000005],ans;\nint f[1048585];\nint sf[1048585],sg[1048585];\nint cnt[1048585];\nint pos[1048585][2];\n/*void mul(int num)\n{\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tsf[i]=1ll*sf[i]*f[i]%mod1;\n\t\tsg[i]=1ll*sg[i]*f[i]%mod2;\n\t}\n}\nbool check(int num,int ss)\n{\n\tint f0=0,g0=0;\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(cnt[i&ss]&1)\n\t\t{\n\t\t\t(f0-=sf[i])%=mod1;\n\t\t\t(g0-=sg[i])%=mod2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(f0+=sf[i])%=mod1;\n\t\t\t(g0+=sg[i])%=mod2;\n\t\t}\n\t}\n\treturn f0!=0||g0!=0;\n}*/\nvoid calc(int x)\n{\n\tmemset(pos,0,sizeof(pos));\n\tint lst=0;pos[b[0]][0]=1; \n\trep(i,n)\n\t{\n\t\tif((a[i]>>x)&1)\n\t\t{\n\t\t\tif(pos[(b[i]>>(x+1))][i&1])\n\t\t\t{\n\t\t\t\tans=max(ans,i-pos[(b[i]>>(x+1))][i&1]+1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=lst;j<i;j++)\n\t\t\t{\n\t\t\t\tpos[(b[j]>>(x+1))][j&1]=0;\n\t\t\t}\n\t\t\tlst=i;\n\t\t}\n\t\tif(!pos[(b[i]>>(x+1))][i&1]) pos[(b[i]>>(x+1))][i&1]=i+1;\n\t}\n\t\n}\nvoid solve()\n{\n\tfor(int i=0;i<(1<<20);i++) cnt[i]=__builtin_popcount(i);\n\tcin>>n;rep(i,n)(cin>>a[i]),b[i]=b[i-1]^a[i];\n\tfor(int i=0;i<20;i++) calc(i);\n\tcout<<ans<<endl;\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}']",,,"['bitmasks', 'greedy', 'math', 'two pointers']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Bored Bakry.json,https://codeforces.com//blog/entry/95583,Let denotes the bitwise and of the elements in subarray in the array and denotes the bitwise xor of the elements in subarray in the array If subarray length is odd then it can t be a good subarray because is a submask of since every bit in occurs odd times so it will be set in If subarray length is even then every bit in will be unset in so we only care about the most significant bit in Let s solve for every bit Let s call bit important bit if For every in the array We need to find the minimum such that is even is set in and all the important bits are unset in Since we only care about the important bits We can make a prefix array where is the prefix xor till the index considering only the important bits So for every we need to find the minimum that satisfy these conditions is even is set in all elements in subarray xor which can be solved easily in 
https://codeforces.com//contest/1260/problem/B,482534,B,1260B,1260,B. Obtain Two Zeroes,You are given two integers a and b You may perform any number of operations on them possibly zero During each operation you should choose any positive integer x and set a a x b b 2x or a a 2x b b x Note that you may choose different values of x in different operations Is it possible to make a and b equal to 0 simultaneously Your program should answer t independent test cases ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    for (int tc = 1; tc <= t; tc++) {\n        int a, b;\n        scanf(""%d %d"", &a, &b);\n        int ans = 1;\n        if ((a + b) % 3 != 0) ans = 0;\n        int xay = (a + b) / 3;\n        int xsy = a - b;\n        int x2 = xay + xsy, y2 = xay - xsy;\n        if (x2 % 2 != 0 || x2 < 0) ans = 0;\n        if (y2 % 2 != 0 || y2 < 0) ans = 0;\n        printf(""%s\\n"", ans ? ""YES"" : ""NO"");\n    }\n}']",,,"['binary search', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Obtain Two Zeroes.json,https://codeforces.com//blog/entry/71805,Let s assume Then the answer is if two following conditions holds because after each operation the value does not change 
https://codeforces.com//contest/1499/problem/G,928255,G,1499G,1499,G. Graph Coloring,You are given a bipartite graph consisting of n 1 vertices in the first part n 2 vertices in the second part and m edges numbered from 1 to m You have to color each edge into one of two colors red and blue You have to minimize the following value sum limits v in V r v b v where V is the set of vertices of the graph r v is the number of red edges incident to v and b v is the number of blue edges incident to v Sounds classical and easy right Well you have to process q queries of the following format 1 v 1 v 2 add a new edge connecting the vertex v 1 of the first part with the vertex v 2 of the second part This edge gets a new index as follows the first added edge gets the index m 1 the second m 2 and so on After adding the edge you have to print the of the current optimal coloring if there are multiple optimal colorings print the of any of them 2 print the optimal coloring of the graph with the same you printed while processing the previous query The query of this type will only be asked after a query of type 1 and there will be at most 10 queries of this type If there are multiple optimal colorings corresponding to this print any of them Note that if an edge was red or blue in some coloring it may change its color in next colorings The of the coloring is calculated as follows let R be the set of indices of red edges then the is sum limits i in R 2 i bmod 998244353 Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query Use functions in and in languages after each writing in your program ,"['#line 1 ""a.cpp""\n#include<cstdio>\n#include<vector>\nusing namespace std;\n#line 2 ""/home/kotatsugame/library/tool/FastIO.cpp""\n#include<cctype>\n#include<string>\nconst int buffer_size=1<<20;\n//input\nint rd_char()\n{\n\tstatic char buf[buffer_size];\n\tstatic int l=buffer_size,r=buffer_size;\n\tif(l==r&&r==buffer_size)\n\t{\n\t\tr=fread(buf,sizeof(char),1<<20,stdin);\n\t\tl=0;\n\t}\n\tif(l==r)return EOF;\n\treturn buf[l++];\n}\nunsigned int rd_uint()\n{\n\tint c;\n\tunsigned int x=0;\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn x;\n}\nint rd_int()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c==\'-\')neg=true;\n\telse x=c-\'0\';\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn neg?-x:x;\n}\nunsigned long long rd_ull()\n{\n\tint c;\n\tunsigned long long x=0;\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn x;\n}\nlong long rd_ll()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c==\'-\')neg=true;\n\telse x=c-\'0\';\n\twhile(\'0\'<=(c=rd_char()))x=x*10+c-\'0\';\n\treturn neg?-x:x;\n}\nstring rd_str()\n{\n\tstring ret;\n\tint c;\n\twhile((c=rd_char())!=\'\\n\'&&c!=\' \'&&c!=EOF)ret+=c;\n\treturn ret;\n}\n//output\nstruct writer_struct{\n\tchar buf[buffer_size];\n\tint l=0;\n\t~writer_struct(){fwrite(buf,sizeof(char),l,stdout);}\n}writer;\nvoid flush()\n{\n\tfwrite(writer.buf,sizeof(char),writer.l,stdout);\n\twriter.l=0;\n}\nvoid wt(char c)\n{\n\tif(writer.l==buffer_size)\n\t{\n\t\tfwrite(writer.buf,sizeof(char),buffer_size,stdout);\n\t\twriter.l=0;\n\t}\n\twriter.buf[writer.l++]=c;\n}\nvoid wt(unsigned int x)\n{\n\tif(x==0)wt(\'0\');\n\telse\n\t{\n\t\tchar f[10];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+\'0\';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(int x)\n{\n\tif(x<0)wt(\'-\'),x=-x;\n\twt((unsigned int)x);\n}\nvoid wt(unsigned long long x)\n{\n\tif(x==0)wt(\'0\');\n\telse\n\t{\n\t\tchar f[20];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+\'0\';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(long long x)\n{\n\tif(x<0)wt(\'-\'),x=-x;\n\twt((unsigned long long)x);\n}\nvoid wt(const char*s){while(*s!=\'\\0\')wt(*s++);}\nvoid wt(const string&s){for(char c:s)wt(c);}\n#line 5 ""a.cpp""\nconst long long mod=998244353;\nint N1,N2,M;\nint pr[4<<17],hs[4<<17],hn[4<<17],pe[4<<17],pc[4<<17];\nint ai[4<<17][2];\nint ans,eh=1,id;\nvector<int>es;\nbool usd[4<<17];\nvoid adj(int ei,vector<int>&a,int j)\n{\n\tint pei=-1;\n\tint cnt=0;\n\twhile(ei!=-1)\n\t{\n\t\tusd[ei]=true;\n\t\tif(cnt==j)a.push_back(ei);\n\t\tint tei=ei;\n\t\tif(pei==ai[ei][0])ei=ai[ei][1];\n\t\telse ei=ai[ei][0];\n\t\tpei=tei;\n\t\tcnt=1-cnt;\n\t}\n}\nvoid add(int ei,int ni)\n{\n\tif(ai[ei][0]==-1)ai[ei][0]=ni;\n\telse ai[ei][1]=ni;\n}\nvoid add_edge(int u,int v)\n{\n\tid++;\n\tai[id][0]=ai[id][1]=-1;\n\tv+=N1;\n\teh=eh*2%mod;\n\tif(pr[u]!=-1)\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tif(pr[v]==u&&pr[u]==v)\n\t\t\t{\n\t\t\t\tif(pc[u]==0)\n\t\t\t\t{\n\t\t\t\t\tadj(pe[u],es,0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tes.push_back(id);\n\t\t\t\t\tadj(pe[u],es,1);\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(pc[u]!=pc[v])\n\t\t\t\t{\n\t\t\t\t\tint rv=pr[v];\n\t\t\t\t\tpc[v]=1-pc[v];\n\t\t\t\t\tpc[rv]=1-pc[rv];\n\t\t\t\t\tans=(ans+mod-hn[v])%mod;\n\t\t\t\t\thn[v]=hn[rv]=(hs[v]-hn[v]+mod)%mod;\n\t\t\t\t\tans=(ans+hn[v])%mod;\n\t\t\t\t}\n\t\t\t\tint ru=pr[u],rv=pr[v];\n\t\t\t\tpr[ru]=rv;pr[rv]=ru;\n\t\t\t\ths[ru]=hs[rv]=((hs[ru]+hs[rv])%mod+eh)%mod;\n\t\t\t\thn[ru]=hn[rv]=(hn[ru]+hn[rv])%mod;\n\t\t\t\tif(pc[u]==1)\n\t\t\t\t{\n\t\t\t\t\thn[ru]=hn[rv]=(hn[ru]+eh)%mod;\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t\tadd(pe[u],id);\n\t\t\t\tadd(id,pe[u]);\n\t\t\t\tadd(pe[v],id);\n\t\t\t\tadd(id,pe[v]);\n\t\t\t}\n\t\t\tpr[u]=pr[v]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ru=pr[u];\n\t\t\tpr[ru]=v;\n\t\t\ths[ru]=(hs[ru]+eh)%mod;\n\t\t\tif(pc[u]==1)\n\t\t\t{\n\t\t\t\thn[ru]=(hn[ru]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[u]=-1;\n\t\t\tpr[v]=ru;\n\t\t\ths[v]=hs[ru];\n\t\t\thn[v]=hn[ru];\n\t\t\tpe[v]=id;\n\t\t\tpc[v]=1-pc[u];\n\t\t\tadd(pe[u],id);\n\t\t\tadd(id,pe[u]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tint rv=pr[v];\n\t\t\tpr[rv]=u;\n\t\t\ths[rv]=(hs[rv]+eh)%mod;\n\t\t\tif(pc[v]==1)\n\t\t\t{\n\t\t\t\thn[rv]=(hn[rv]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[v]=-1;\n\t\t\tpr[u]=rv;\n\t\t\ths[u]=hs[rv];\n\t\t\thn[u]=hn[rv];\n\t\t\tpe[u]=id;\n\t\t\tpc[u]=1-pc[v];\n\t\t\tadd(pe[v],id);\n\t\t\tadd(id,pe[v]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpr[u]=v;\n\t\t\tpr[v]=u;\n\t\t\ths[u]=hs[v]=eh;\n\t\t\thn[u]=hn[v]=eh;\n\t\t\tpe[u]=pe[v]=id;\n\t\t\tpc[u]=pc[v]=0;\n\t\t\tans=(ans+eh)%mod;\n\t\t}\n\t}\n}\nmain()\n{\n\tscanf(""%d%d%d"",&N1,&N2,&M);\n\tfor(int i=0;i<N1+N2;i++)pr[i]=-1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;scanf(""%d%d"",&u,&v);\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\tint Q;\n\tscanf(""%d"",&Q);\n\tfor(int ccc=0;ccc<Q;ccc++)\n\t{\n\t\tint t;scanf(""%d"",&t);\n\t\tif(t==1)\n\t\t{\n\t\t\tint u,v;scanf(""%d%d"",&u,&v);\n\t\t\tu--,v--;\n\t\t\tadd_edge(u,v);\n\t\t\twt(ans);\n\t\t\twt(\'\\n\');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<int>ret=es;\n\t\t\tfor(int i=0;i<=id;i++)usd[i]=false;\n\t\t\tfor(int i=0;i<N1+N2;i++)if(pr[i]!=-1&&!usd[pe[i]])\n\t\t\t{\n\t\t\t\tadj(pe[i],ret,pc[i]);\n\t\t\t}\n\t\t\twt((unsigned int)ret.size());\n\t\t\tfor(int id:ret)wt(\' \'),wt(id);\n\t\t\twt(\'\\n\');\n\t\t}\n\t\tflush();\n\t\tfflush(stdout);\n\t}\n}\n']",,,"['data structures', 'graphs', 'interactive']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Graph Coloring.json,https://codeforces.com//blog/entry/88812,Let s split all edges of the graph into several paths and cycles each edge will belong to exactly one path or cycle Each path and each cycle will be colored in an alternating way the first edge will be red the second blue the third red and so on or vice versa Since the graph is bipartite each cycle can be colored in an alternating way The main idea of the solution is to add the edges one by one maintain the structure of cycles and paths and make sure that for each vertex at most one path starts ends in it If we are able to maintain this invariant then the value of for every vertex will be minimum possible each cycle going through a vertex covers an even number of edges incident to it half of them will be red half of them will be blue so if the degree of a vertex is odd one path will have this vertex as an endpoint and otherwise it won t be an endpoint of any path so Okay how do we maintain this structure Let s add edges one by one even the original edges of the graph and rebuild the structure in online mode For each vertex we will maintain the indices of the paths that have this vertex as an endpoint If some vertex has or more paths as its endpoints we can choose two of them and link them together Whenever we add an edge from to we just create a new path and check if we can link together some paths that have or as their endpoints How do we link the paths together If we try to link a path with itself it means that we try to close a cycle and when we do it we just forget about the resulting cycle its structure won t change in future queries When we link a path with some other path we might need to reverse and or repaint the paths before merging them into one There are at least two possible data structures we can use to do this either an implicit key treap that supports reversing and repainting or a deque with small to large merging whenever we try to link two paths together we repaint and or reverse the smaller one Both of those methods give a solution in or depending on your implementation The model solution uses deques and small to large merging 
https://codeforces.com//contest/1354/problem/G,623450,G,1354G,1354,G. Find a Gift,There are n gift boxes in a row numbered from 1 to n from left to right It s known that exactly k of them contain valuable gifts other boxes contain just lucky stones All boxes look the same and differ only in weight All than boxes with valuable items But valuable gifts may be different so the boxes with valuable items may have different weights You can ask no more than 50 queries printing an answer doesn t count By each query you can compare total weights of two non intersecting subsets of boxes a 1 a 2 dots a k a and b 1 b 2 dots b k b In return you ll get one of four results if subset a 1 a 2 dots a k a is strictly if subset b 1 b 2 dots b k b is strictly if subsets have equal total weights if the query is incorrect or the limit of queries is exceeded Using such queries or maybe intuition find the box with a valuable gift with ,"['#include <random>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(2005171937);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> choose(int N, int K) {\n\tvector<bool> used(N, false);\n\tvector<int> seq;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint p = -1;\n\t\twhile (p == -1 || used[p]) {\n\t\t\tp = rand_rng(0, N);\n\t\t}\n\t\tused[p] = true;\n\t\tseq.push_back(p);\n\t}\n\tsort(seq.begin(), seq.end());\n\treturn seq;\n}\nbool debug = false;\nvector<int> hidden;\nint min_index;\nvoid gen_array(int N, int K) {\n\tvector<int> g = choose(N, K);\n\thidden.resize(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (binary_search(g.begin(), g.end(), i)) {\n\t\t\thidden[i] = rand_rng(1, 100);\n\t\t}\n\t\telse {\n\t\t\thidden[i] = 100;\n\t\t}\n\t}\n\tmin_index = g[0];\n}\nstring ask(vector<int> a, vector<int> b) {\n\tcout << ""? "" << a.size() << \' \' << b.size() << endl;\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tif (i) cout << \' \';\n\t\tcout << a[i] + 1;\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < b.size(); ++i) {\n\t\tif (i) cout << \' \';\n\t\tcout << b[i] + 1;\n\t}\n\tcout << endl;\n\tstring res;\n\tif (!debug) {\n\t\tcin >> res;\n\t}\n\telse {\n\t\tint sa = 0, sb = 0;\n\t\tfor (int i : a) sa += hidden[i];\n\t\tfor (int i : b) sb += hidden[i];\n\t\tif (sa > sb) res = ""FIRST"";\n\t\tif (sa < sb) res = ""SECOND"";\n\t\tif (sa == sb) res = ""EQUAL"";\n\t}\n\treturn res;\n}\nvoid answer(int x) {\n\tcout << ""! "" << x + 1 << endl;\n\tif (debug) {\n\t\tassert(x == min_index);\n\t}\n}\nint main() {\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint N, K;\n\t\tif (!debug) {\n\t\t\tcin >> N >> K;\n\t\t}\n\t\telse {\n\t\t\tN = 4, K = 1;\n\t\t\tgen_array(N, K);\n\t\t}\n\t\tif (N <= 4) {\n\t\t\tint curmax = 0;\n\t\t\tfor (int i = 1; i < N; ++i) {\n\t\t\t\tstring res = ask({ curmax }, { i });\n\t\t\t\tif (res == ""SECOND"") curmax = i;\n\t\t\t}\n\t\t\tint ans = -1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i != curmax) {\n\t\t\t\t\tstring res = ask({ curmax }, { i });\n\t\t\t\t\tif (res == ""FIRST"") {\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer(ans);\n\t\t}\n\t\telse {\n\t\t\t// step #1. find one stone (fail probability <= (1/2)^threshold)\n\t\t\tconst int threshold = 23;\n\t\t\tvector<int> g = choose(N - 2, min(N - 2, threshold));\n\t\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\t\tg[i] += 2;\n\t\t\t}\n\t\t\tint stone = g[0];\n\t\t\tfor (int i = 1; i < g.size(); ++i) {\n\t\t\t\tstring res = ask({ stone }, { g[i] });\n\t\t\t\tif (res == ""SECOND"") {\n\t\t\t\t\tstone = g[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring resp0 = ask({ stone }, { 0 });\n\t\t\tstring resp1 = ask({ stone }, { 1 });\n\t\t\tif (resp0 == ""FIRST"") {\n\t\t\t\tanswer(0);\n\t\t\t}\n\t\t\telse if (resp1 == ""FIRST"") {\n\t\t\t\tanswer(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = 2;\n\t\t\t\twhile (t * 2 <= N) {\n\t\t\t\t\tvector<int> lc(t), rc(t);\n\t\t\t\t\tfor (int i = 0; i < t; ++i) {\n\t\t\t\t\t\tlc[i] = i;\n\t\t\t\t\t\trc[i] = i + t;\n\t\t\t\t\t}\n\t\t\t\t\tstring res = ask(lc, rc);\n\t\t\t\t\tif (res != ""EQUAL"") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt *= 2;\n\t\t\t\t}\n\t\t\t\tint lp = t, rp = min(2 * t, N);\n\t\t\t\twhile (rp - lp > 1) {\n\t\t\t\t\tint m = (lp + rp) >> 1;\n\t\t\t\t\tvector<int> lc(m - t), rc(m - t);\n\t\t\t\t\tfor (int i = 0; i < m - t; ++i) {\n\t\t\t\t\t\tlc[i] = i;\n\t\t\t\t\t\trc[i] = i + t;\n\t\t\t\t\t}\n\t\t\t\t\tstring res = ask(lc, rc);\n\t\t\t\t\tif (res != ""EQUAL"") {\n\t\t\t\t\t\trp = m;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlp = m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tanswer(lp);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['binary search', 'interactive', 'probabilities']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Find a Gift.json,https://codeforces.com//blog/entry/77593,The solution consists of several steps Let s find out does the first box contain stone or valuable gift using random Let s make queries to compare the weight of the first box with the weight of another random box If the first box is lighter than we found an answer otherwise the probability of the first box having stones is at least Let s compare the weights of the first box and the second one If they are equal then let s compare the weights of boxes and If they are equal then let s compare the boxes and and so on In other words let s find the minimum such that contains only boxes with stones but contain at least one box with a valuable gift It s easy to see that we d spend no more than queries We have segment with only stones and with at least one gift Let s just binary search the leftmost gift in the segment using boxes from as reference if we need to know does segment of boxes have at least one gift let s just compare it with segment which have only stones if is lighter then it has otherwise doesn t have This part also requires no more than queries 
https://codeforces.com//contest/1767/problem/C,1697002,C,1767C,1767,C. Count Binary Strings,You are given an integer n You have to calculate the number of binary consisting of characters and or strings s meeting the following constraints For every pair of integers i j such that 1 le i le j le n an integer a i j is given It imposes the following constraint on the string s i s i 1 s i 2 dots s j if a i j 1 all characters in s i s i 1 s i 2 dots s j should be the same if a i j 2 there should be at least two different characters in s i s i 1 s i 2 dots s j if a i j 0 there are no additional constraints on the string s i s i 1 s i 2 dots s j Count the number of binary strings s of length n meeting the aforementioned constraints Since the answer can be large print it modulo 998244353 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 111;\nMint dp[N];\nbool eq[N];\nbool hasDiff[N][N];\nint n;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tint x;\n\t\t\tscanf(""%d"", &x);\n\t\t\tif (x == 0) continue;\n\t\t\tif (x == 1) {\n\t\t\t\tfor (int k = i + 1; k < j; k++)\n\t\t\t\t\teq[k] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thasDiff[i][j] = 1;\n\t\t}\n\tfor (int len = 1; len < n; len++)\n\t\tfor (int l = 0; l + len <= n; l++) if (hasDiff[l][l + len]) {\n\t\t\tif (l > 0) hasDiff[l - 1][l + len] = 1;\n\t\t\tif (l + len < n) hasDiff[l][l + len + 1] = 1;\n\t\t}\n\tdp[0] = 2;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (!eq[j] && !hasDiff[i][j])\n\t\t\t\tdp[j] += dp[i];\n\t\t}\n\tprintf(""%u\\n"", dp[n].x);\n\n\treturn 0;\n}\n']",,,"['data structures', 'dp']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Count Binary Strings.json,https://codeforces.com//blog/entry/110225,Suppose we build the string from left to right and when we place the th character we ensure that all substrings are valid What do we need to know in order to calculate the number of different characters in the string ending with the th character Suppose the character is Let s try going to the left of it The string from to will have the same characters but if there is at least one character before the th position the string will have two different characters What about the strings in the middle The string will contain different characters if and only if there is at least one in since is so we are actually interested in the position of the last character before The same logic applies if the character is we are only interested in the position of the last before and it is enough to check if all substrings ending with the th character are violated What if when we choose the th character we violate some substring that doesn t end in the th position Well you could also check that or you could just ignore it Actually it doesn t matter if this happens because it means that the substring that is violated ends in some position and we will check it when placing the th character So the solution can be formulated with the following dynamic programming let be the number of ways to choose the first characters of the string so that the last character different from was or if there was no such character and all the constraints on the substrings ending no later than position are satisfied The transitions are simple you either place the same character as the last one going from to or a different character going from to and when you place a character you check all the constraints on the substrings ending with the th position Note that the state is actually represented by two strings and This solution works in although or implementations are also possible 
https://codeforces.com//contest/364/problem/A,4041,A,364A,364,A. Matrix,You have a string of decimal digits Let s define Find in matrix the number of such rectangles that the sum for all cells that are the elements of the rectangle equals in each rectangle A rectangle in a matrix is a group of four integers The elements of the rectangle are all cells such that ,"['#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define REPC(I, C) for (int I = 0; !(C); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\nconst int SIZE = 400000;\nchar s[SIZE];\nint cnt[SIZE];\nint main(){\n    int zero=0,non_zero=0;\n    DRI(a);\n    RS(s);\n    int n=LEN(s);\n    REP(i,n){\n        int now=0;\n        REPP(j,i,n){\n            now+=s[j]-\'0\';\n            cnt[now]++;\n            if(now==0)zero++;\n            else non_zero++;\n        }\n    }\n    if(a==0){\n        cout<<(long long)(zero+non_zero)*(zero+non_zero)-(long long)non_zero*non_zero<<endl;\n    }\n    else{\n        long long res=0;\n        for(int i=1;i<SIZE&&i<=a;i++){\n            if(!cnt[i])continue;\n            if(a%i==0&&a/i<SIZE){\n                res+=(long long)cnt[i]*cnt[a/i];\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n']",,,"['combinatorics', 'data structures', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Matrix.json,https://codeforces.com//blog/entry/9657,Let s notice that sum in the rectangle x1 y1 x2 y2 is sum x1 x2 sum y1 y2 Where sum l r sl sl 1 sr Then we have to calc sum l r for every pair l r and count how many segments give us sum x for any possible x 0 x 9 s In the end we should enumerate sum on segemnt x1 x2 and find There is corner case a 0 
https://codeforces.com//contest/1073/problem/D,243299,D,1073D,1073,D. Berland Fair,XXI Berland Annual Fair is coming really soon Traditionally fair consists of n booths arranged in a circle The booths are numbered 1 through n clockwise with n being adjacent to 1 The i th booths sells some candies for the price of a i burles per item Each booth has an unlimited supply of candies Polycarp has decided to spend at most T burles at the fair However he has some plan in mind for his path across the booths at first he visits booth number 1 if he has enough burles to buy candy from the current booth then he buys it immediately then he proceeds to the next booth in the clockwise order regardless of if he bought a candy or not Polycarp s money is finite thus the process will end once he can no longer buy candy at any booth Calculate the number of candies Polycarp will buy ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct BIT {\n  vector<long long> dat;\n\n  BIT(int n) : dat(n + 1) {}\n\n  void update(int k, long long v) {\n    for (int i = k + 1; i < dat.size(); i += i & -i) {\n      dat[i] += v;\n    }\n  }\n  \n  long long query(int k) {\n    long long ans = 0;\n    for (int i = k; i > 0; i -= i & -i) {\n      ans += dat[i];\n    }\n    return ans;\n  }\n\n  long long query(int l, int r) {\n    return query(r) - query(l);\n  }\n};\n\nint main() {\n  int n;\n  long long T;\n  cin >> n >> T;\n  BIT bit0(n * 2);\n  BIT bit1(n * 2);\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", &a[i]);\n    bit0.update(i, 1);\n    bit0.update(i + n, 1);\n    bit1.update(i, a[i]);\n    bit1.update(i + n, a[i]);\n  }\n  int k = 0;\n  long long ans = 0;\n  int left = n;\n  while (left > 0) {\n    long long s = bit1.query(k, k + n);\n    if (s > T) {\n      int l = k;\n      int r = k + n;\n      while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (bit1.query(k, m) <= T) {\n          l = m;\n        } else {\n          r = m;\n        }\n      }\n      ans += bit0.query(k, l);\n      T -= bit1.query(k, l);\n      k = l % n;\n      bit0.update(k, -1);\n      bit0.update(k + n, -1);\n      bit1.update(k, -a[k]);\n      bit1.update(k + n, -a[k]);\n      left--;\n    } else {\n      ans += (T / s) * bit0.query(k, k + n);\n      T %= s;\n    }\n  }\n  cout << ans << endl;\n}\n\n']",,,"['binary search', 'brute force', 'data structures', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Berland Fair.json,https://codeforces.com/blog/entry/62742,Let s code the following process Go one circle across the booths calculate the total cost of sweets bought and the number of sweets bought Now you can decrease you money down to and add to answer It represents that you went maximum number of such circles The later circles will have smaller cost Let s continue this process until becomes smaller than the minimum priced sweet The number of operations made is Let be the amount of money before some operation be the total cost of sweets bought on that operation and is actually smaller than that s how modulo works and smaller than that s also how modulo works And these inequalities imply that That leads to about steps to reach the minimal price Overall complexity 
https://codeforces.com//contest/2039/problem/H1,3044249,H1,2039H1,2039,H1. Cool Swap Walk  Easy Version ,You are given an array a of size n A is the following process In an n times n grid we note the cells in row i and column j as i j You need to walk from 1 1 to n n taking only steps to the right or down Formally if you are in x y currently you can step to either x 1 y or x y 1 but you can not step beyond the boundaries of the grid When you step in i j you swap a i and a j when i neq j You can perform at most 2n 4 Sort the array a 1 a 2 ldots a n in non decreasing order We can show that it s always possible to do so ,"['#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;int n;int a[N];int id[N];int b[N];mt19937 rng;void Main() {\t// n = 10;\t// L(i, 1, n) a[i] = i;\t// shuffle(a + 1, a + n + 1, rng);\tcin >> n;\tL(i, 1, n) cin >> a[i];\tL(i, 1, n) id[i] = i;\tsort(id + 1, id + n + 1, [&] (int x, int y) {\t\treturn a[x] < a[y];\t});\tL(i, 1, n) a[id[i]] = i;\tif(n == 2) {\t\tif(a[1] == 1) {\t\t\tcout << ""0\\n"";\t\t} else {\t\t\tcout << ""1\\nRD\\n"";\t\t}\t\treturn;\t}\tint turn = n * 2 + 4;\t// int turn = 3;\tcout << turn << \'\\n\';\tL(i, 1, n) {\t\tb[i] = a[(i + turn - 1) % n + 1];\t}\tR(j, turn, 1) {\t\tint pos = (-j % n + 1 + n) % n;\t\tif(!pos)pos += n;\t\tstring ans;\t\tL(j, pos + 1, n) {\t\t\tif(j < n && b[j] > b[j + 1]) {\t\t\t\tans += ""RRDD"";\t\t\t\tswap(b[j], b[j + 1]);\t\t\t\t++j;\t\t\t} else {\t\t\t\tans += ""RD"";\t\t\t}\t\t}\t\tL(j, 1, pos - 1) {\t\t\tif(j < pos - 1 && b[j] > b[j + 1]) {\t\t\t\tans += ""RRDD"";\t\t\t\tswap(b[j], b[j + 1]);\t\t\t\t++j;\t\t\t} else {\t\t\t\tans += ""RD"";\t\t\t}\t\t}\t\tcout << ans << \'\\n\';\t\tint x = 1, y = 1;\t\tfor(auto c : ans) {\t\t\tif(c == \'R\') ++y;\t\t\telse ++x;\t\t\tswap(a[x], a[y]);\t\t}\t\t// L(i, 1, n) {\t\t// \tcout << b[i] << \' \';\t\t// }\t\t// cout << endl;\t\t// L(i, 1, n)\t\t// \tcout << a[i] << \' \';\t\t// cout << endl;\t\t// L(i, 1, n) {\t\t// \tcout << a[(i + j - 2 + n) % n + 1] << \' \';\t\t// }\t\t// cout << endl << endl;\t}\t// L(i, 1, n) {\t// \tcout << a[i] << \' \';\t// }\t// cout << endl;}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}']",,,"['constructive algorithms', 'implementation', 'sortings']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H1. Cool Swap Walk  Easy Version .json,https://codeforces.com//blog/entry/136523,TutorialWe can observe that this kind of path is imporatnt when we are in we only perform one of the following two kind of moves Move 1 This move transforms into Move 2 This move transforms into Summary of the path Note the arrays before and after the path as and respectively We can see and can be obtained from through the following transformation Swap any two adjacent numbers of but each number can be swapped at most once This inspires us to use Odd Even Sort algorithm Steps to Achieve the Sorted Array Step Initialize If where is the minimum of the array use the following path This sequence ensures that Then repeat steps and until the array is sorted Step Perform Odd Even Sorting Perform an Odd Even Sort a round of comparison using the key path above on the subarray Step Maintain the orderliness of while repeatedly making After step we want back to the head of the array To achieve this perform the following operations This sequence transforms the array as follows When this is performed after an odd even sort it ensures that is back to the head of the array The subarray has been cyclically shifted Handling Continuous Cyclic Shifts in Odd Even Sort Even Length is even Cyclic shifting does not affect the odd even sort You can continue applying the sort as usual Odd Length is odd A small modification is needed Specifically First compare instead of This adjustment ensures that the odd even sort operates correctly despite the continuous cyclic shifts Overall we obtained a sorted array using walks 
https://codeforces.com//contest/439/problem/D,10097,D,439D,439,D. Devu and his Brother,Devu and his brother love each other a lot As they are super geeks they only like to play with arrays They are given two arrays and by their father The array is given to Devu and to his brother As Devu is really a naughty kid he wants the minimum value of his array should be at least as much as the maximum value of his brother s array Now you have to help Devu in achieving this condition You can perform multiple operations on the arrays In a single operation you are allowed to decrease or increase any element of any of the arrays by 1 Note that you are allowed to apply the operation on any index of the array multiple times You need to find minimum number of operations required to satisfy Devu s condition so that the brothers can play peacefully without fighting ,"['#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<""OK"";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 100100\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(""a.in"");\nofstream g(""a.out"");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nint a[N],b[N],p1,p2,n,m,val;\nll Sa[N],Sb[N],Ra[N],Rb[N],best,cost;\nint cbs(int val)\n{\n    int st=1,dr=n,mij,sol=0;\n    while(st<=dr)\n    {\n        mij=(st+dr)>>1;\n        if(a[mij]<=val)\n        {\n            sol=mij;\n            st=mij+1;\n        }\n        else\n            dr=mij-1;\n    }\n    return sol;\n}\nint cbd(int val)\n{\n    int st=1,dr=m,mij,sol=n+1;\n    while(st<=dr)\n    {\n        mij=(st+dr)>>1;\n        if(b[mij]>=val)\n        {\n            dr=mij-1;\n            sol=mij;\n        }\n        else\n            st=mij+1;\n    }\n    return sol;\n}\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(""a.in"",""r"",stdin);\n    freopen(""a.out"",""w"",stdout);\n    #endif\n    \n    f>>n>>m;\n    FOR(i,1,n)\n    f>>a[i];\n    FOR(i,1,m)\n    f>>b[i];\n    sort(a+1,a+n+1);\n    sort(b+1,b+m+1);\n    FOR(i,1,n)\n    {\n        Sa[i]=Sa[i-1]+a[i];\n    }\n    FOR(i,1,m)\n    {\n        Sb[i]=Sb[i-1]+b[i];\n    }\n    ROF(i,n,1)\n    {\n        Ra[i]=Ra[i+1]+a[i];\n    }\n    ROF(i,m,1)\n    {\n        Rb[i]=Rb[i+1]+b[i];\n    }\n    best=inf;\n    if(b[m]<=a[1])\n    {\n        g<<""0"";\n        return 0;\n    }\n    FOR(i,1,n)\n    {\n        val=a[i];\n        p1=cbd(val);\n        p2=cbs(val);\n        cost=Rb[p1]-1LL*(m-p1+1)*a[i];\n        cost+=1LL*p2*a[i]-Sa[p2];\n        if(cost<best)\n            best=cost;\n    }\n    FOR(i,1,m)\n    {\n        val=b[i];\n        p1=cbd(val);\n        p2=cbs(val);\n        cost=Rb[p1]-1LL*(m-p1+1)*b[i];\n        cost+=1LL*p2*b[i]-Sa[p2];\n        if(cost<best)\n            best=cost;\n    }\n    g<<best;\n    return 0;\n}']",,,"['binary search', 'sortings', 'ternary search', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Devu and his Brother.json,https://codeforces.com//blog/entry/12545,You can solve the problem in two ways Let us define a function f Function f k cost needed to make array a elements k cost needed to make array b elements k Instead of proving it formally try checking the property on many random test cases You will realize that f is convex Claim f is convex Proof It is fairly easy to prove See the derivative of f of elements of b k of elements of a k The first term without sign can only decrease as k increases whereas second term can only increase as k increases So All the extremum points will lie in the elements from the any of the arrays because f is convex and at the event points or the points of array a and b For learning more about ternary search you can see following topcoder discussion Another smart solution Please see following comment of goovie and proof is given in the reply by himank Solutions Code 
https://codeforces.com//contest/165/problem/C,1014,C,165C,165,C. Another Problem on Strings,A string is if it consists only of characters and String is a of string if it has a non zero length and can be read starting from some position in string For example string has six substrings Two substrings are considered different if their positions of occurrence are different So if some string occurs multiple times we should consider it the number of times it occurs You are given a binary string Your task is to find the number of its substrings containing exactly characters ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nchar s[1100000];\nint sum[1100000];\nint main(){\n\tint k;\n\twhile( scanf(""%d %s"", &k, s+1)!=EOF ){\n\t\tint len=strlen(s+1);\n\t\trep(i, 1, len+1){\n\t\t\tsum[i]=sum[i-1]+(s[i]==\'1\');\n\t\t}\n\t\tLL ans=0;\n\t\trep(i, 1, len+1){\n\t\t\tint t1=sum[i-1]+k;\n\t\t\tif( sum[len]<t1 ) continue;\n\t\t\tint id1=lower_bound(sum+i, sum+len+1, t1)-sum;\n\t\t\tint id2=upper_bound(sum+i, sum+len+1, t1)-sum;\n\t\t\t\n\t\t\tans+=(id2-id1);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n\n']",,,"['binary search', 'brute force', 'dp', 'math', 'strings', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Another Problem on Strings.json,https://codeforces.com//blog/entry/4124,You was to find number of segments of the strings on which the sum equals to we are working with array of integers and We will count array where the value equals to sum on segment We will count the answer going from left to right Let s say we are in position Now we will add the number of segments on which the sum equals to and ends in position To do it we will count array where number of occurrences of Then in position we add to the answer The complexity is 
https://codeforces.com//contest/1863/problem/C,2186454,C,1863C,1863,C. MEX Repetition,You are given an array a 1 a 2 ldots a n of integers from 0 to n Consider the following operation consecutively for each i from 1 to n in this order replace a i with operatorname MEX a 1 a 2 ldots a n Here operatorname MEX of a collection of integers c 1 c 2 ldots c m is defined as the smallest non negative integer x which does not occur in the collection c For example operatorname MEX 0 2 2 1 4 3 and operatorname MEX 1 2 0 Print the array after applying k such operations ,"['/**\n *    author:  tourist\n *    created: 30.08.2023 10:40:04       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      sum += a[i];\n    }\n    long long last = (long long) n * (n + 1) / 2 - sum;\n    a.push_back((int) last);\n    k %= n + 1;\n    rotate(a.begin(), a.begin() + (n + 1) - k, a.end());\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']",,,"['implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. MEX Repetition.json,https://codeforces.com//blog/entry/119902,Append the initial array with It is easy to see that is a permutation of In this case setting is basically equivalent but after this the new is changed In fact it becomes equal to the old value of since this value is not now present in the array In other words performing the operation on is equivalent to swapping and Performing the operation on can be viewed as swaps It means that the array changes from to i e we simply perform the cyclic shift to the right To finish up the solution first calculate you can do so for example by setting Second calculate and then perform the cyclic shift in 
https://codeforces.com//contest/516/problem/A,22477,A,516A,516,A. Drazil and Factorial,Drazil is playing a math game with Varda Let s define for positive integer as a product of factorials of its digits For example First they choose a decimal number consisting of digits that contains at least one digit larger than This number may possibly start with leading zeroes Then they should find maximum positive number satisfying following two conditions 1 doesn t contain neither digit nor digit 2 Help friends find such number ,"['#include <iostream>\nusing namespace std;\nint p[10];\nvoid go(int x, int sign)\n{\n\tfor (int i = 2; i < 10; i++)\n\t\twhile (x % i == 0)\n\t\t{\n\t\t\tx /= i;\n\t\t\tp[i] += sign;\n\t\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tint val = 1;\n\t\tint f = c - \'0\';\n\t\tfor (int j = 1; j <= f; j++)\n\t\t\tval *= j;\n\t\tgo(val, 1);\n\t}\n\tstring ans = """";\n\tfor (int i = 9; i >= 2; i--)\n\t\twhile (p[i] > 0)\n\t\t{\n\t\t\tans += char(i + \'0\');\n\t\t\tint val = 1;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tval *= j;\n\t\t\tgo(val, -1);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['dp', 'greedy', 'implementation', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Drazil and Factorial.json,https://codeforces.com/blog/entry/16468,Conclusion first First we transform each digit of the original number as follows 0 1 empty 2 2 3 3 4 322 5 5 6 53 7 7 8 7222 9 7332 Then sort all digits in decreasing order as a new number then it will be the answer Proof We can observe that our answer won t contain digits 4 6 8 9 because we can always transform digits 4 6 8 9 to more digits as in the conclusion and it makes the number larger Then how can we make sure that the result is the largest after this transformation We can prove the following lemma For any positive integer x if it can be written as the form 2 c2 3 c3 5 c5 7 c7 there will be only one unique way Suppose that there exists two ways to write down x in this form we can assume that the two ways are 2 a2 3 a3 5 a5 7 a7 and 2 b2 3 b3 5 b5 7 b7 We find the largest i such that ai bi Then we know there exists at least one prime number whose factor is different in the two ways But according to the Fundamental Theorem of Arithmetic there is only one prime factorization of each integer So we get a contradiction After getting the result we don t need to worry about other numbers being larger than ours 
https://codeforces.com//contest/59/problem/C,309,C,59C,59,C. Title,Vasya has recently finished writing a book Now he faces the problem of giving it the title Vasya wants the title to be vague and mysterious for his book to be noticeable among others That s why the title should be represented by a single word containing at least once each of the first Latin letters and not containing any other ones Also the title should be a palindrome that is it should be read similarly from the left to the right and from the right to the left Vasya has already composed the approximate variant of the title You are given the title template consisting of lowercase Latin letters and question marks Your task is to replace all the question marks by lowercase Latin letters so that the resulting word satisfies the requirements described above Each question mark should be replaced by exactly one letter it is not allowed to delete characters or add new ones to the template If there are several suitable titles choose the first in the alphabetical order for Vasya s book to appear as early as possible in all the catalogues ,"['#include <iostream>\n#include <cstring>\nusing namespace std;\nint k;\nchar arr[256];\nint n;\nbool used[256];\nint main()\n{\n\tcin>>k>>arr;\n\tn = strlen(arr);\n\tfor(int i=0; i<n; ++i) {\n\t\tif (arr[i]!=\'?\') {\n\t\t\tint a = n-1-i;\n\t\t\tif (arr[a]==\'?\') arr[a]=arr[i];\n\t\t\tif (arr[a]!=arr[i]) {\n\t\t\t\tcout<<""IMPOSSIBLE\\n"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; ++i) used[(int)arr[i]] = 1;\n\tint c = \'a\' + (k-1);\n\tfor(int i=(n+0)/2; i>=0; --i) {\n\t\twhile(c>=\'a\' && used[c]) --c;\n\t\tif (arr[i]!=\'?\') continue;\n\t\tint a = n-1-i;\n\t\tif (c>=\'a\') {\n\t\t\tarr[a] = arr[i] = c--;\n\t\t} else {\n\t\t\tarr[a] = arr[i] = \'a\';\n\t\t}\n\t}\n\twhile(c>=\'a\' && used[c]) --c;\n\tif (c>=\'a\') {\n\t\tcout<<""IMPOSSIBLE\\n"";\n\t\treturn 0;\n\t}\n\tcout<<arr<<\'\\n\';\n}\n']",,,['expression parsing'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Title.json,https://codeforces.com//blog/entry/1276,This was a very nice problem My approach was to first flag all the letters which have already appeared Notice that we have to output the lexicographically smallest palindrome So start from the middle of the letter and iterate one side If you get a stop and check if the corresponding position on the other side also has a If yes then fill both with the lexicographically biggest letter which hasn t appeared yet in the word and also flag that letter Once you have exhausted all the letters and there are still left then simply fill them with a Now simply iterate over the word again and see if there are any question marks left if yes copy the values in the corresponding block on the other side At the same time check if at any time the two opposite values match or not If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome 
https://codeforces.com//contest/1887/problem/B,2278998,B,1887B,1887,B. Time Travel,Berland is a country with ancient history where roads were built and destroyed for centuries It is known that there always were n cities in Berland You also have records of t key moments in the history of the country numbered from 1 to t Each record contains a list of roads between some pairs of cities which could be used for travel in Berland at a specific moment in time You have discovered a time machine that transports you between key moments Unfortunately you cannot choose what point in time to end up at but you know the order consisting of k moments in time a i in which the machine will transport you Since there is little time between the travels when you find yourself in the next key moment in time you can travel on at most one existing road at that moment coming out from the city you were in before time travel Currently you are in city 1 and the time machine has already transported you to moment a 1 You want to reach city n as quickly as possible Determine the minimum number of time travels that you need to make in order to reach city n ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, t;\n    std::cin >> n >> t;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < t; i++) {\n        int m;\n        std::cin >> m;\n        \n        for (int j = 0; j < m; j++) {\n            int x, y;\n            std::cin >> x >> y;\n            x--, y--;\n            adj[x].emplace_back(y, i);\n            adj[y].emplace_back(x, i);\n        }\n    }\n    \n    int k;\n    std::cin >> k;\n    std::vector<int> a(k);\n    std::vector<std::vector<int>> pos(t);\n    for (int i = 0; i < k; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        pos[a[i]].push_back(i);\n    }\n    \n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> q;\n    q.emplace(0, 0);\n    std::vector dis(n, -1);\n    \n    while (!q.empty()) {\n        auto [d, x] = q.top();\n        q.pop();\n        \n        if (dis[x] != -1) {\n            continue;\n        }\n        dis[x] = d;\n        \n        for (auto [y, i] : adj[x]) {\n            auto it = std::lower_bound(pos[i].begin(), pos[i].end(), d);\n            if (it != pos[i].end()) {\n                q.emplace(*it + 1, y);\n            }\n        }\n    }\n    \n    std::cout << dis[n - 1] << ""\\n"";\n    \n    return 0;\n}\n']",,,"['binary search', 'graphs', 'shortest paths']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Time Travel.json,https://codeforces.com//blog/entry/121621,Let denote the minimum number of moves required to reach vertex Initially for all vertices except where We will gradually mark the vertices for which we know the optimal answer Similar to Dijkstra s algorithm at each iteration we will select the vertex with the minimum value of among the unmarked vertices We will mark it and relax its neighbors let be an edge belonging to record we will find the minimum index such that and then We can find using binary search by saving the indices of occurrences in for each time moments The time complexity of the solution is 
https://codeforces.com//contest/2028/problem/B,3015766,B,2028B,2028,B. Alice s Adventures in Permuting,Alice mixed up the words transmutation and permutation She has an array a specified via three integers n b c the array a has length n and is given via a i b cdot i 1 c for 1 le i le n For example if n 3 b 2 and c 1 then a 2 cdot 0 1 2 cdot 1 1 2 cdot 2 1 1 3 5 Now Alice really enjoys permutations of 0 ldots n 1 text and would like to transform a into a permutation In one operation Alice replaces the maximum element of a with the operatorname MEX text of a If there are multiple maximum elements in a Alice chooses the leftmost one to replace Can you help Alice figure out how many operations she has to do for a to become a permutation for the first time If it is impossible you should report it text A permutation of length n is an array consisting of n distinct integers from 0 to n 1 in arbitrary order For example 1 2 0 4 3 is a permutation but 0 1 1 is not a permutation 1 appears twice in the array and 0 2 3 is also not a permutation n 3 but there is 3 in the array text The operatorname MEX of an array is the smallest non negative integer that does not belong to the array For example the operatorname MEX of 0 3 1 3 is 2 and the operatorname MEX of 5 is 0 ,"['#include<bits/stdc++.h>//#pragma GCC optimize(""Ofast,no-stack-protector,unroll-loops,fast-math"")//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native"")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());ll rint(ll l,ll r){return uniform_int_distribution<ll>(l,r)(rnd);}//const int maxn=;void read(ll &X){\tX=0;\tchar cr=getchar();\twhile(cr<\'0\'||cr>\'9\') cr=getchar();\twhile(cr>=\'0\'&&cr<=\'9\') X=(X<<3)+(X<<1)+(cr^48),cr=getchar();}ll T,n,b,c;//4 2 1//1357//1350 1320int main(){//\tfreopen("".in"",""r"",stdin);//\tfreopen("".out"",""w"",stdout);\tread(T);\twhile(T--)\t{\t\tread(n),read(b),read(c);\t\tif(!b)\t\t{\t\t\tif(c>=n) printf(""%lld\\n"",n);\t\t\telse if(c>=n-2) printf(""%lld\\n"",n-1);\t\t\telse printf(""-1\\n"");\t\t}\t\telse\t\t{\t\t\t//c c+b c+2b;\t\t\t//kb<=n-c-1\t\t\tif(c<=n-1) printf(""%lld\\n"",n-(n-c-1)/b-1);\t\t\telse printf(""%lld\\n"",n);\t\t}\t}\treturn 0;}']",,,"['binary search', 'implementation', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Alice s Adventures in Permuting.json,https://codeforces.com//blog/entry/136096,Suppose that Then if the answer is if or the answer is and otherwise it is for example consider in which case we will end up with and the last two steps alternate Otherwise since has distinct elements we claim that the answer is where is the number of elements in already present in the array Equivalently it is the number of steps until since we always preserve the distinctness of the elements of So we want to find the maximum such that This happens exactly when The expected complexity is per testcase 
https://codeforces.com//contest/1295/problem/E,526704,E,1295E,1295,E. Permutation Separation,You are given a permutation p 1 p 2 dots p n an array where each integer from 1 to n appears exactly once The weight of the i th element of this permutation is a i At first you separate your permutation into two sets prefix and suffix More formally the first set contains elements p 1 p 2 dots p k the second p k 1 p k 2 dots p n where 1 le k n After that you may move elements between sets The operation you are allowed to do is to choose some element of the first set and move it to the second set or vice versa move from the second set to the first You have to pay a i dollars to move the element p i Your goal is to make it so that each element of the first set is less than each element of the second set Note that if one of the sets is empty this condition is met For example if p 3 1 2 and a 7 1 4 then the optimal strategy is separate p into two parts 3 1 and 2 and then move the 2 element into first set it costs 4 And if p 3 5 1 6 2 4 a 9 1 9 9 1 9 then the optimal strategy is separate p into two parts 3 5 1 and 6 2 4 and then move the 2 element into first set it costs 1 and 5 element into second set it also costs 1 Calculate the minimum number of dollars you have to spend ,"[""// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2e5 + 5;\nconst size_t V = N << 2;\n\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n\nLL val[V], tag[V];\n\nvoid pushup(int x) {\n    val[x] = min(val[lc(x)], val[rc(x)]);\n}\n\nvoid update(int x, LL v) {\n    val[x] += v;\n    tag[x] += v;\n}\n\nvoid pushdown(int x) {\n    if (tag[x]) {\n        update(lc(x), tag[x]);\n        update(rc(x), tag[x]);\n        tag[x] = 0;\n    }\n}\n\nvoid modify(int x, int tl, int tr, int l, int r, LL v) {\n    if (tl >= r || tr <= l) return;\n    if (l <= tl && tr <= r) {\n        return update(x, v);\n    }\n    pushdown(x);\n    int mid = (tl + tr) >> 1;\n    modify(lc(x), tl, mid, l, r, v);\n    modify(rc(x), mid, tr, l, r, v);\n    pushup(x);\n}\n\nint p[N], a[N];\n\nint main() {\n    int n = read();\n    generate_n(p, n, read);\n    generate_n(a, n, read);\n    for (int i = 0; i < n; ++i) {\n        modify(1, 0, n + 1, p[i], n + 1, a[i]);\n    }\n    LL ans = 1e18;\n    for (int i = 0; i + 1 < n; ++i) {\n        modify(1, 0, n + 1, p[i], n + 1, -a[i]);\n        modify(1, 0, n + 1, 0, p[i], a[i]);\n        ans = min(ans, val[1]);\n    }\n    cout << ans;\n    return 0;\n}\n""]",,,"['data structures', 'divide and conquer']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Permutation Separation.json,https://codeforces.com//blog/entry/73467, All elements in the left set smaller than all elements in the right set means that there is such value that all elements from the first set less than and all elements from the second set are more or equal to So let s make a sweep line on from to while trying to maintain all answers for each prefix Let s maintain for each the total cost to make sets good if we split the permutation on sets and in such way that after transformations all elements in the first set less than It s easy to see that the total cost is equal to sum of weights where and and where and So what will happen if we increase by Let s define the position of as For each we don t need to move to the second set anymore so we should make On the other hand for each we need to move from the second set to the first one now so we should make The answer will be equal to the It means that we should handle two operations add some value on the segment and ask minimum on the segment So we can store all in pretty standart Segment Tree with add on segment and minimum on segment while iterating over So the total complexity is 
https://codeforces.com//contest/576/problem/A,34883,A,576A,576,A. Vasya and Petya s Game,Vasya and Petya are playing a simple game Vasya thought of number between and and Petya tries to guess the number Petya can ask questions like Is the unknown number divisible by number The game is played by the following rules first Petya asks the questions that interest him also he can ask no questions and then Vasya responds to each question with a yes or a no After receiving all the answers Petya should determine the number that Vasya thought of Unfortunately Petya is not familiar with the number theory Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya s number and the numbers he should ask the questions about ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 1001\nint n;\nbool cz[MAX];\nvector<int> wyn;\nmain(){\n  make(n);\n  F(i,2,n+1){\n    if(cz[i])continue;\n    for(int j=1;j*i <= n;j++)\n      cz[i*j] = 1;\n    int ak = i;\n    while(ak <= n){\n      wyn.PB(ak);\n      ak *= i;\n    }\n  }\n  printf(""%d\\n"",wyn.size());\n  R(i,SZ(wyn))\n    printf(""%d "",wyn[i]);\n  puts("""");\n}\n']",,,"['math', 'number theory']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Vasya and Petya s Game.json,https://codeforces.com//blog/entry/20226,If Petya didn t ask pk where p is prime and k 1 he would not be able to distinguish pk 1 and pk That means he should ask all the numbers pk It s easy to prove that this sequence actually guesses all the numbers from 1 to n The complexity is O N1 5 or O NloglogN depending on primality test 
https://codeforces.com//contest/1213/problem/E,399404,E,1213E,1213,E. Two Small Strings,You are given two strings s and t and both consisting only of characters and Possible examples of strings s and t You have to find a string res consisting of 3n characters n characters should be n characters should be and n characters should be and s and t should not occur in res as substrings A substring of a string is a contiguous subsequence of that string So the strings and are substrings of the string but the strings and are not substrings of the string If there are multiple answers you can print any of them ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\n\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    string per = ""abc"";\n    int n;\n    cin >> n;\n    string a, b;\n    cin >> a >> b;\n    fr(p, 1, 6) {\n        next_permutation(all(per));\n        string lol = per + per;\n        bool pos = 1;\n        fr(i, 0, 2) {\n            if(lol.substr(i, 2) == a || lol.substr(i, 2) == b) pos = 0;\n        }\n        if(pos) {\n            cout << ""YES"" << endl;\n            fr(i, 1, n) {\n                cout << per;\n            }\n            return 0;\n        }\n    }\n    string c = b;\n    reverse(all(c));\n    if(a == c) {\n        cout << ""YES"" << endl;\n        fr(i, 1, n) {\n            cout << a[0];\n        }\n        fr(j, 0, 2) {\n            if((char)(\'a\' + j) == a[0] || (char)(\'a\' + j) == b[0]) continue;\n            fr(i, 1, n)\n                cout << (char)(\'a\' + j);\n            break;\n        }\n        fr(i, 1, n) {\n            cout << a[1];\n        }\n        return 0;\n    }\n    if(a[1] == b[1]) {\n        cout << ""YES"" << endl;\n        fr(i, 1, n) {\n            cout << a[1];\n        }\n        fr(j, 0, 2) {\n            if((char)(\'a\' + j) == a[1]) continue;\n            fr(i, 1, n)\n                cout << (char)(\'a\' + j);\n        }\n        return 0;\n    }\n    else if(a[0] == b[0]) {\n        cout << ""YES"" << endl;\n        fr(j, 0, 2) {\n            if((char)(\'a\' + j) == a[0]) continue;\n            fr(i, 1, n)\n                cout << (char)(\'a\' + j);\n        }\n        fr(i, 1, n) {\n            cout << a[0];\n        }\n        return 0;\n    }\n    cout << ""NO"";\n    return 0;\n}']",,,"['brute force', 'constructive algorithms']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Two Small Strings.json,https://codeforces.com//blog/entry/69464,We can check the following solution by stress testing or maybe prove it somehow let s iterate over all possible permutations of the string Let the first character of the current permutation be the second one be and the third one be Then let s add the following two candidates to the answer the string consisting of copies of and exactly copies of then exactly copies of and exactly copies of Then the answer will be among these strings and we can check each of them naively 
https://codeforces.com//contest/1463/problem/F,836006,F,1463F,1463,F. Max Correct Set,Let s call the set of positive integers S if the following two conditions are met S subseteq 1 2 dots n if a in S and b in S then a b neq x and a b neq y For the given values n x and y you have to find the maximum size of the set ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvoid expr() {\n\tint n, x, y; cin >> n >> x >> y;\n\tfor (x = 1; x <= 22; x++)for (y = 1; y <= 22; y++) {\n\t\tvector<bool> used(101);\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\tused[i] = true;\n\t\t\tif (i - x >= 0 && used[i - x])used[i] = false;\n\t\t\tif (i - y >= 0 && used[i - y])used[i] = false;\n\t\t}\n\t\tint cyc = x + y;\n\t\tint ans = 1;\n\t\trep1(i, cyc) {\n\t\t\tif (used[i] != used[i + cyc]) {\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t}\n\t\tcout << x << "" "" << y << "" "" << ans << ""\\n"";\n\t}\n}\nbool used[100];\nvoid solve() {\n\tint n, x, y; cin >> n >> x >> y;\n\tint d = x + y;\n\tint d1 = d / 2;\n\tint d2 = d - d1;\n\tint c = n / d;\n\tint r = n % d;\n\tvector<int> val(1 << d2,0);\n\trep(i, (1 << d2)) {\n\t\tbool valid = true;\n\t\trep(j, d2)used[j] = false;\n\t\trep(j, d2) {\n\t\t\tif (i & (1 << j))used[j] = true;\n\t\t}\n\t\trep(j, d2)if(used[j]) {\n\t\t\tif (j - x >= 0 && used[j - x])valid = false;\n\t\t\tif (j - y >= 0 && used[j - y])valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint num = 0;\n\t\trep(j, d2)if (used[j])num++;\n\t\tint sum = num * c;\n\t\trep(j, d2)if (j + d1 < r && used[j])sum++;\n\t\tval[i] = sum;\n\t}\n\trep(i, (1 << d2))rep(j, d2)if (i & (1 << j)) {\n\t\tval[i] = max(val[i], val[i ^ (1 << j)]);\n\t}\n\tint ans = 0;\n\trep(i, (1 << d1)) {\n\t\tbool valid = true;\n\t\trep(j, d1)used[j] = false;\n\t\trep(j, d1)if (i & (1 << j))used[j] = true;\n\t\trep(j, d1)if(used[j]) {\n\t\t\tif (j - x >= 0 && used[j - x])valid = false;\n\t\t\tif (j - y >= 0 && used[j - y])valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint ban = 0;\n\t\trep(j, d1)if (used[j]) {\n\t\t\tif (j + x >= d1&&j+x<d) {\n\t\t\t\tban |= (1 << j + x - d1);\n\t\t\t}\n\t\t\tif (j + y >= d1 && j + y < d) {\n\t\t\t\tban |= (1 << j + y - d1);\n\t\t\t}\n\t\t}\n\t\tban = (1 << d2) - 1 - ban;\n\n\t\tint num = 0; rep(j, d1)if (used[j])num++;\n\t\tint sum = num * c;\n\t\trep(j, d1)if (used[j])if (j < r)sum++;\n\t\t\n\t\tans = max(ans, sum + val[ban]);\n\t}\n\tcout << ans << ""\\n"";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']",,,"['bitmasks', 'dp', 'math']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Max Correct Set.json,https://codeforces.com//blog/entry/85707,The key idea of the task is to prove that there is an optimal answer where the chosen elements in has a period equal to Let s work with instead of Firstly let s prove that if we ve chosen correct set in interval then if we take all then set will be corect as well By contradiction suppose we have then or contradiction It means that if we take the correct set in interval we can create a periodic answer by copying this interval several times Next let s prove that there is an optimal periodic answer Let s look at any optimal answer and its indicator vector binary vector of length where iff is in the set Let Let s split the vector in intervals The st rd th segments have length and nd th segments have length If we choose any two consecutive segments its total length will be equal to and we can use it to make periodic answer by replacing all length segments with the chosen one and segments with the other one We can prove that we can always find such two consecutive segments that the induced answer will be greater or equal to the initial one If we create vector where is equal to the sum of in the th segment then the task is equivalent to finding and such that replacing all by and all by won t decrease array sum The proof is down below Now since the answer is periodical taking element is equivalent to taking all elements so for each we can calc the number of integers with the same remainder And for each we either take it or not So we can write where is the maximum sum if we processed elements and last elements are described by mask We start with and when look at the th element either take it if we can or skip it Time complexity is Let s prove that for any array we can find pair such that replacing all with and all with won t decrease the total sum Let s define and Let s make array where and The meaning behind is how changes the total sum if we replace corresponding elements by Note that finding a good pair is equivalent to finding Also note that and analogically Let s prove by contradiction suppose that for any Let s look at But from the other side we know that so otherwise will be negative In the same way since then Analogically we can prove that each but contradiction So there is always a pair i e a pair 
https://codeforces.com//contest/1445/problem/A,781569,A,1445A,1445,A. Array Rearrangment,You are given two arrays a and b each consisting of n positive integers and an integer x Please determine if one can rearrange the elements of b so that a i b i leq x holds for each i 1 le i le n ,"['#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nint T;\n\nconst int N = 50 + 5;\nint n, x, a[N], b[N];\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> T;\n\n    while (T--) {\n        cin >> n >> x;\n\n        for (int i = 0; i < n; i++) cin >> a[i];\n        for (int i = 0; i < n; i++) cin >> b[i];\n\n        sort(a, a + n);\n        sort(b, b + n, greater<int>());\n\n        bool ok = 1;\n        for (int i = 0; i < n; i++) ok &= (a[i] + b[i] <= x);\n\n        cout << (ok? ""Yes"" : ""No"") << \'\\n\';\n    }\n}\n']",,,"['greedy', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Array Rearrangment.json,https://codeforces.com//blog/entry/84248,It s enough to sort in non decreasing order and sort in non increasing order and check whether for all Correctness can be proven by induction let s show that if answer exists there is a solution with minimum in and maximum in are paired Let be minimum in and be maximum in Let be number paired with and be number paired with Since solution is correct and Since Since So can be paired with 
https://codeforces.com//contest/686/problem/B,63498,B,686B,686,B. Little Robber Girl s Zoo,Little Robber Girl likes to scare animals in her zoo for fun She decided to arrange the animals in a row in the order of non decreasing height However the animals were so scared that they couldn t stay in the right places The robber girl was angry at first but then she decided to arrange the animals herself She repeatedly names numbers and such that is even After that animals that occupy positions between and inclusively are rearranged as follows the animal at position swaps places with the animal at position the animal swaps with the animal finally the animal at position swaps with the animal Help the robber girl to arrange the animals in the order of non decreasing height You should name at most segments since otherwise the robber girl will become bored and will start scaring the animals again ,"[""#include<bits/stdc++.h>\nusing namespace std;\nconst double eps(1e-8);\nconst double pi(3.14159265358979);\nconst int N=110;\nint n,a[N]={};\nint main()\n{\t\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor(int i=n;i>=1;--i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tif(a[j+1]<a[j])\n\t\t\t{\n\t\t\t\tcout<<j<<' '<<j+1<<endl;\n\t\t\t\tswap(a[j],a[j+1]);\n\t\t\t}\n\treturn 0;\n}""]",,,"['constructive algorithms', 'implementation', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Little Robber Girl s Zoo.json,https://codeforces.com//blog/entry/45558,We need to sort an array with strange operations namely to swap elements with even and odd indices in subarray of even length Note that we can change the 2 neighboring elements simply doing our exchange action for subarray of length 2 containing these elements Also note that n 100 and it is permission to do 20 000 actions therefore we can write any quadratic sort which changes the neighboring elements in each iteration bubble sort for example 
https://codeforces.com//contest/761/problem/B,90959,B,761B,761,B. Dasha and friends,Running with barriers on the circle track is very popular in the country where Dasha lives so no wonder that on her way to classes she saw the following situation The track is the circle with length in distinct points of which there are barriers Athlete always run the track in counterclockwise direction if you look on him from above All barriers are located at integer distance from each other along the track Her friends the parrot Kefa and the leopard Sasha participated in competitions and each of them ran one lap Each of the friends started from some integral point on the track Both friends wrote the distance from their start along the track to each of the barriers Thus each of them wrote integers in the ascending order each of them was between and inclusively There are several tracks in the country all of them have same length and same number of barriers but the positions of the barriers can differ among different tracks Now Dasha is interested if it is possible that Kefa and Sasha ran the same track or they participated on different tracks Write the program which will check that Kefa s and Sasha s tracks coincide it means that one can be obtained from the other by changing the start position Note that they always run the track in one direction counterclockwise if you look on a track from above ,"['#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == \'-\')\n\t\t\ts = -1, c = getChar();\n\t\twhile (\'0\' <= c && c <= \'9\')\n\t\t\tx = x * 10 + c - \'0\', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar(\'-\'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)(\'0\' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 1e6;\n\nint main()\n{\n\tvector <int> a, b;\n\tint n, l;\n\tcin >> n >> l;\n\tint last;\n\tint st1;\n\tcin >> st1;\n\tlast = st1;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\ta.push_back(x - last);\n\t\tlast = x;\n\t}\n\ta.push_back(l - last + st1);\n\tcin >> st1;\n\tlast = st1;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tb.push_back(x - last);\n\t\tlast = x;\n\t}\n\tb.push_back(l - last + st1);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tbool bad = false;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tif (a[j] != b[(i + j) % n])\n\t\t\t{\n\t\t\t\tbad = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!bad)\n\t\t{\n\t\t\tputs(""YES"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""NO"");\n\treturn 0;\n}\n']",,,"['brute force', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Dasha and friends.json,https://codeforces.com//blog/entry/50179,Let s add distances between pairs of adjacent barriers of both tracks in arrays and check if it possible to get one of them from another using cycling shift of the elements 
https://codeforces.com//contest/746/problem/B,85370,B,746B,746,B. Decoding,Polycarp is mad about coding that is why he writes Sveta encoded messages He calls the in a word the letter which is in the middle of the word If the word s length is even the median letter is the left of the two middle letters In the following examples the median letter is highlighted If the word consists of single letter then according to above definition this letter is the median letter Polycarp encodes each word in the following way he writes down the median letter of the word then deletes it and repeats the process until there are no letters left For example he encodes the word as You are given an encoding of some word your task is to decode it ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)301*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n;\nstring s;\nchar ans[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>s;\n    ll k=n;\n    for(int i=0;i<n;i++)ans[i]='.';\n    for(int i=0;i<s.size();i++)\n    {\n    \tll x=(k-1)/2;\n    \tfor(int j=0;j<n;j++)\n    \t{\n    \t\tif(x==0 && ans[j]=='.'){ans[j]=s[i];break;}\n    \t\tif(ans[j]=='.')x--;\n\t\t}\n    \tk--;\n\t}\n\tfor(int i=0;i<n;i++)cout<<ans[i];\n    return 0;\n}""]",,,"['implementation', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Decoding.json,https://codeforces.com//blog/entry/49160,To find the answer we can iterate through the given string from the left to the right and add each letter in the answer string one letter to the begin next letter to the end next letter to begin and so on If is even than the first letter must be added to the begin and the second letter to the end In the other case the first letter to the end second to the begin We need to make it until we do not add all letters from the given string 
https://codeforces.com//contest/18/problem/A,82,A,18A,18,A. Triangle,At a geometry lesson Bob learnt that a triangle is called right angled if it is nondegenerate and one of its angles is right Bob decided to draw such a triangle immediately on a sheet of paper he drew three points with integer coordinates and joined them with segments of straight lines then he showed the triangle to Peter Peter said that Bob s triangle is not right angled but is right angled the triangle itself is not right angled but it is possible to move one of the points exactly by distance 1 so that all the coordinates remain integer and the triangle become right angled Bob asks you to help him and find out if Peter tricks him By the given coordinates of the triangle you should find out if it is right angled almost right angled or neither of these ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""f""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\nint X[3], Y[3], x[3], y[3];\nbool vp(int x1, int y1, int x2, int y2) {\n    return (x1*x1+y1*y1) && (x2*x2+y2*y2) && !(x1*x2+y1*y2);    \n}\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n    forn(i,3)\n        cin >> x[i] >> y[i];\n    for (int i=0; i<3; i++)\n        for (int j=0; j<3; j++)\n            for (int k=0; k<3; k++)\n                if (i!=j && j!=k && i!=k && vp(x[j]-x[i], y[j]-y[i], x[k]-x[i], y[k]-y[i])) {\n                    cout << ""RIGHT\\n"";\n                    return 0;\n                }\n    for (int q=0; q<3; q++)\n        for (int dx=-1; dx<=1; dx++)\n            for (int dy=-1; dy<=1; dy++) \n                if (abs(dx)+abs(dy)==1) {\n                    for (int p=0; p<3; p++)\n                        X[p]=x[p], Y[p]=y[p];\n                    X[q]=x[q]+dx, Y[q]=y[q]+dy;\n                    for (int i=0; i<3; i++)\n                        for (int j=0; j<3; j++)\n                            for (int k=0; k<3; k++)\n                                if (i!=j && j!=k && i!=k && vp(X[j]-X[i], Y[j]-Y[i], X[k]-X[i], Y[k]-Y[i])) {\n                                    cout << ""ALMOST\\n"";\n                                    return 0;\n                                }\n                }\n    cout << ""NEITHER\\n"";\n    return 0;\n}']",,,"['brute force', 'geometry']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Triangle.json,https://codeforces.com//blog/entry/463,n this problem you should implement a function which takes three points and checks whether they form a right angled triangle There are a lot of ways to do so but the simplest one is using a Pythagorean theorem You should use squared distances instead of taking roots to overcome problems related to precision errors To examine a triangle on almost rightness you can try to move each point in each of four possible directions and check the new triangle using our function It s good and easy to use two arrays dx 1 0 1 0 and dy 0 1 0 1 for moving Then we can get the new coordinates of shifted point simply using the following code 
https://codeforces.com//contest/670/problem/C,59596,C,670C,670,C. Cinema,Moscow is hosting a major international conference which is attended by scientists from different countries Each of the scientists knows exactly one language For convenience we enumerate all languages of the world with integers from to In the evening after the conference all scientists decided to go to the cinema There are movies in the cinema they came to Each of the movies is characterized by two numbers the index of audio language and the index of subtitles language The scientist who came to the movie will be if he knows the audio language of the movie will be if he knows the language of subtitles and will be if he does not know neither one nor the other note that the audio language and the subtitles language for each movie are always different Scientists decided to go together to the same movie You have to help them choose the movie such that the number of very pleased scientists is maximum possible If there are several such movies select among them one that will maximize the number of almost satisfied scientists ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\n\n    map <int, int> a;\n\nint get(int x) {\n    if(a.count(x)) return a[x];\n    return 0;\n}\n\nint main() {\n\n    //freopen(""input.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        a[x]++;\n    }\n    int m;\n    cin >> m;\n    vector <int> b(m);\n    vector <int> c(m);\n    for (int i = 0; i< m; ++i) {\n        cin >> b[i];\n    }\n    for (int i =0; i < m; ++i) {\n        cin >> c[i];\n    }\n\n    pair <int, int> v = make_pair(-1, -1);\n    int idx  = -1;\n    for (int i = 0; i< m; ++i) {\n        pair <int, int> cur = make_pair(get(b[i]), get(c[i]));\n        if (cur > v) {\n            v = cur;\n            idx = i + 1;\n        }\n    }\n    cout << idx << \'\\n\';\n    return 0;\n}\n']",,,"['implementation', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Cinema.json,https://codeforces.com//blog/entry/44715,We need to use let s call it and calculate how many scientists knows every language i e equals to the number of scientists who know the language number Let s use the pair where we will store the number of textit very pleased scientists and the number of textit almost satisfied scientists At first let Now we need to iterate through all movies beginning from the first Let the current movie has the number Then if let s make and update the answer with the number of current movie 
https://codeforces.com//contest/226/problem/E,1854,E,226E,226,E. Noble Knight s Path,In Berland each feudal owns exactly one castle and each castle belongs to exactly one feudal Each feudal except one the King is subordinate to another feudal A feudal can have any number of vassals subordinates Some castles are connected by roads it is allowed to move along the roads in both ways Two castles have a road between them if and only if the owner of one of these castles is a direct subordinate to the other owner Each year exactly one of these two events may happen in Berland The barbarians attacked castle The interesting fact is the barbarians never attacked the same castle twice throughout the whole Berlandian history A noble knight sets off on a journey from castle to castle provided that on his path he encounters each castle not more than once Let s consider the second event in detail As the journey from to is not short then the knight might want to stop at a castle he encounters on his way to have some rest However he can t stop at just any castle his nobility doesn t let him stay in the castle that has been desecrated by the enemy s stench A castle is desecrated if and only if it has been attacked after the year of So the knight chooses the th castle he encounters starting from castles and aren t taken into consideration that hasn t been attacked in years from till current year The knights don t remember which castles were attacked on what years so he asked the court scholar aka you to help them You ve got a sequence of events in the Berland history Tell each knight in what city he should stop or else deliver the sad news that the path from city to city has less than cities that meet his requirements so the knight won t be able to rest ,"['#include <map>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXM = 17;\nconst int MAXN = 1 << MAXM;\n\nstruct TreeDecomposition {\n  vector<int> e[MAXN], c[MAXN];\n  int s[MAXN];    // subtree size\n  int p[MAXN];    // parent id\n  int r[MAXN];    // chain root id\n  int t[MAXN];    // timestamp, index used in segtree\n  int ts;\n\n  void dfs_(int v, int f) {\n    p[v] = f;\n    s[v] = 1;\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f) {\n        dfs_(w, v);\n        s[v] += s[w];\n      }\n    }\n  }\n\n  void decomp_(int v, int f, int k) {\n    t[v] = ts++;\n    c[k].push_back(v);\n    r[v] = k;\n\n    int x = 0, y = -1;\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f) {\n        if (s[w] > x) {\n          x = s[w];\n          y = w;\n        }\n      }\n    }\n    if (y != -1) {\n      decomp_(y, v, k);\n    }\n\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f && w != y) {\n        decomp_(w, v, w);\n      }\n    }\n  }\n\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      e[i].clear();\n    }\n  }\n\n  void add(int a, int b) {\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  void build() {  // !!\n    ts = 0;\n    dfs_(0, 0);\n    decomp_(0, 0, 0);\n  }\n} hld;\n\nstruct LCA {\n  vector<int> e[MAXN];\n  int d[MAXN], p[MAXN][MAXM];\n\n  void dfs_(int v, int f) {\n    p[v][0] = f;\n    for (int i = 1; i < MAXM; ++i) {\n      p[v][i] = p[p[v][i - 1]][i - 1];\n    }\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f) {\n        d[w] = d[v] + 1;\n        dfs_(w, v);\n      }\n    }\n  }\n\n  int up_(int v, int m) {\n    for (int i = 0; i < MAXM; ++i) {\n      if (m & (1 << i)) {\n        v = p[v][i];\n      }\n    }\n    return v;\n  }\n\n  int lca(int a, int b) {\n    if (d[a] > d[b]) {\n      swap(a, b);\n    }\n    b = up_(b, d[b] - d[a]);\n    if (a == b) {\n      return a;\n    } else {\n      for (int i = MAXM - 1; i >= 0; --i) {\n        if (p[a][i] != p[b][i]) {\n          a = p[a][i];\n          b = p[b][i];\n        }\n      }\n      return p[a][0];\n    }\n  }\n\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      e[i].clear();\n    }\n  }\n\n  void add(int a, int b) {\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  void build() {\n    d[0] = 0;\n    dfs_(0, 0);\n  }\n} lca;\n\nstruct SegTree {\n  int n;\n  map<int, int> mp[MAXN + MAXN];\n\n  void init(int m) {\n    n = 1;\n    while (n < m) {\n      n <<= 1;\n    }\n    fill(mp + 1, mp + n + n, map<int, int>());\n  }\n\n  void del(int i, int e) {\n    for (i += n; i > 0; i >>= 1) {\n      mp[i][e];\n    }\n  }\n\n  void build() {\n    for (int i = 1; i < n + n; ++i) {\n      int k = 0;\n      for (auto& j: mp[i]) {\n        j.second = k++;\n      }\n      mp[i][MAXN] = k;  // guard\n    }\n  }\n\n  // [x, y)\n  int bad(int p, int x, int y) const {\n    return mp[p].lower_bound(y)->second - mp[p].lower_bound(x)->second;\n  }\n\n  static int L(int i) { return i << 1; }\n  static int R(int i) { return L(i) ^ 1; }\n\n  int good(int p, int pl, int pr, int l, int r, int x, int y) {\n    l = max(l, pl);\n    r = min(r, pr);\n    if (l >= r) {\n      return 0;\n    } else if (pl == l && pr == r) {\n      return pr - pl - bad(p, x, y);\n    } else {\n      int pm = (pl + pr) / 2;\n      return good(L(p), pl, pm, l, r, x, y) + good(R(p), pm, pr, l, r, x, y);\n    }\n  }\n\n\n  int index(int p, int pl, int pr, int l, int r, int x, int y, int& z) {\n    l = max(l, pl);\n    r = min(r, pr);\n    if (l >= r) {\n      return -1;\n    }\n    if (pl == l && pr == r) {\n      int g = pr - pl - bad(p, x, y);\n      if (z >= g) {\n        z -= g;\n        return -1;\n      }\n    }\n    if (pr - pl == 1) {\n      return pl;\n    }\n    int pm = (pl + pr) / 2;\n    int ret = index(L(p), pl, pm, l, r, x, y, z);\n    if (ret != -1) {\n      return ret;\n    } else {\n      return index(R(p), pm, pr, l, r, x, y, z);\n    }\n  }\n} st;\n\nvector<pair<int, int> > keypath(int a, int b) {\n  int c = lca.lca(a, b);\n  vector<pair<int, int> > pa, pb;\n\n  while (hld.r[a] != hld.r[c]) {\n    pa.push_back({a, hld.r[a]});\n    a = hld.p[hld.r[a]];\n  }\n  while (hld.r[b] != hld.r[c]) {\n    pb.push_back({hld.r[b], b});\n    b = hld.p[hld.r[b]];\n  }\n  pa.push_back({a, b});\n  pa.insert(pa.end(), pb.rbegin(), pb.rend());\n\n  return pa;\n}\n\nstruct Query {\n  int a, b, x, y, k, ans;\n} q[MAXN];\n\nstatic int invt[MAXN];\n\nint main() {\n  int n, m, t;\n\n  scanf(""%d"", &n);\n  hld.init(n);\n  lca.init(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(""%d"", &t);\n    --t;\n    if (t >= 0) {\n      hld.add(i, t);\n      lca.add(i, t);\n    }\n  }\n  hld.build();\n  lca.build();\n  for (int i = 0; i < n; ++i) {\n    invt[hld.t[i]] = i;\n  }\n#ifdef __WATASHI__\n  for (int i = 0; i < n; ++i) {\n    if (hld.c[i].empty()) {\n      continue;\n    }\n    for (int j: hld.c[i]) {\n      printf("" %d"", j);\n    }\n    puts("""");\n  }\n#endif\n\n  scanf(""%d"", &m);\n  st.init(n);\n  for (int i = 0; i < m; ++i) {\n    scanf(""%d%d"", &t, &q[i].a);\n    --q[i].a;\n    if (t == 1) {\n      st.del(hld.t[q[i].a], i);\n      q[i].x = -1;\n    } else {\n      scanf(""%d%d%d"", &q[i].b, &q[i].k, &q[i].x);\n      --q[i].b;\n      --q[i].k;\n      q[i].y = i;\n    }\n  }\n  st.build();\n\n  for (int i = 0; i < m; ++i) {\n    if (q[i].x == -1) {\n      continue;\n    } else {\n      q[i].ans = -1;\n      q[i].k += st.good(1, 0, st.n, hld.t[q[i].a], hld.t[q[i].a] + 1, q[i].x, q[i].y);\n      // q[i].k += st.good(1, 0, st.n, hld.t[q[i].b], hld.t[q[i].b] + 1, q[i].x, q[i].y);\n      for (auto j: keypath(q[i].a, q[i].b)) {\n        int a = hld.t[j.first], b = hld.t[j.second], good;\n        if (a <= b) {\n          good = st.good(1, 0, st.n, a, b + 1, q[i].x, q[i].y);\n        } else {\n          good = st.good(1, 0, st.n, b, a + 1, q[i].x, q[i].y);\n        }\n        // printf(""[%d] %d -> %d (%d)\\n"", i, j.first + 1, j.second + 1, good);\n        // printf(""a = %d, b = %d, k = %d\\n"", a, b, q[i].k);\n        if (q[i].k >= good) {\n          q[i].k -= good;\n        } else if (a <= b) {\n          q[i].ans = st.index(1, 0, st.n, a, b + 1, q[i].x, q[i].y, q[i].k);\n          break;\n        } else {\n          q[i].k = good - 1 - q[i].k;\n          q[i].ans = st.index(1, 0, st.n, b, a + 1, q[i].x, q[i].y, q[i].k);\n          break;\n        }\n      }\n      if (q[i].ans != -1) {\n        q[i].ans = invt[q[i].ans];\n        if (q[i].ans == q[i].b) {\n          q[i].ans = -1;\n        } else {\n          ++q[i].ans;\n        }\n      }\n      printf(""%d\\n"", q[i].ans);\n    }\n  }\n\n  return 0;\n}\n']",,,"['data structures', 'trees']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Noble Knight s Path.json,https://codeforces.com/blog/entry/5378,It s easy to guess that castles form a tree Let s build heavy light decomposition over it Moreover let s build persistent segment tree with sum as the function over each path Tree s vertex will contain 0 if castle wasn t attacked by barbarians and 1 otherwise Each knight s path should be divided into not more than two subpaths each of them lays on the path from one of the route s end to tree s root just use lca in order to do it Now let s solve the problem for each of the subpaths separately We should sequentially process paths from heavy light decomposition and single vertices which lay on subpath We are going to count the amount of vertices which was not visited since year y 1 up to the current year i e in the case of a path of the decomposition such vertices that the difference between values in the current version of persistent segment tree and in the version corresponding to year y use binary search to find required version in the list of versions is equal to zero in case with single vertice it s enough to remember time when vertice was visited As soon as the amount of appropriate vertices become not less than k we should simultaneously walk down in two tree s versions in order to get the answer If the kth vertex isn t found on the first subpath you should pay attention on the fact that as we always go from down to up we should accurately recalculate required vertex s number in order to know it s position in the second subpath from down to up Complexity O m log2 n in each query of the first type it can be necessary to update some segment tree this action takes O log n operations in each query of the second type there are O log n decomposition s paths each of them is processed in O log n firstly binary search through versions list then query to the tree walking down 
https://codeforces.com//contest/739/problem/B,81533,B,739B,739,B. Alyona and a tree,Alyona has a tree with vertices The root of the tree is the vertex In each vertex Alyona wrote an positive integer in the vertex she wrote Moreover the girl wrote a positive integer to every edge of the tree possibly different integers on different edges Let s define as the sum of the integers written on the edges of the simple path from to The vertex controls the vertex if and only if is in the subtree of and Alyona wants to settle in some vertex In order to do this she wants to know for each vertex what is the number of vertices such that controls ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,a[N],p,w,sta[N],fg[N];\nvector<PII> s[N];\nll dis[N];\nvoid dfs(int u,ll d,int f) {\n\tsta[f]=u; dis[f]=d;\n\tint l=lower_bound(dis,dis+f+1,d-a[u])-dis-1;\n\tfg[sta[l]]--; fg[u]++;\n\tfor (auto v:s[u]) {\n\t\tdfs(v.fi,d+v.se,f+1);\n\t\tfg[u]+=fg[v.fi];\n\t}\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,2,n+1) {\n\t\tscanf(""%d%d"",&p,&w);\n\t\ts[p].pb(mp(i,w));\n\t}\n\tdis[0]=-1ll<<60;\n\tdfs(1,0,1);\n\trep(i,1,n+1) printf(""%d "",fg[i]-1);\n\tputs("""");\n}\n']",,,"['binary search', 'data structures', 'dfs and similar', 'graphs', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Alyona and a tree.json,https://codeforces.com//blog/entry/48582,Let s fix a vertex This node adds 1 to all the ancestors whose depth the sum of the weights of edges on the path from the root to the vertex It s a segment of the ancestors ending in v as the depth increases when moving to the leaves It remains to find the first ancestor on the way up it does not hold for him so you can make a binary lifting or binary search if you will be storing the path to the root in dfs With the partial sums you can calculate the answer for each vertices 
https://codeforces.com//contest/1418/problem/A,727423,A,1418A,1418,A. Buying Torches,You are playing a very popular game called Cubecraft Initially you have one stick and want to craft k torches One torch can be crafted using Hopefully you ve met a very handsome wandering trader who has two trade offers exchange 1 stick for x sticks you lose 1 stick and gain x sticks exchange y sticks for 1 coal you lose y sticks and gain 1 coal During one trade you can use of these two trade offers You can use each trade offer any number of times you want to in any order Your task is to find the minimum number of trades you need to craft at least k torches The answer always exists under the given constraints You have to answer t independent test cases ,"[""#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint T;\nsigned main(){\n\trd(T);\n\twhile(T--){\n\t\tint x,y,k;rd(x),rd(y),rd(k);\n\t\t--x;\n\t\tpt(max(0LL,(k+y*k+x-1-1)/x+k),'\\n');\n\t}\n\treturn 0;\n}\n""]",,,['math'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Buying Torches.json,https://codeforces.com//blog/entry/82673,You need additional sticks to get torches sticks for units of coal and also sticks required to craft torches and you get sticks per one trade To buy this number of sticks you need trades And also you need additional trades to turn some sticks into coals And the final answer is 
https://codeforces.com//contest/696/problem/C,65170,C,696C,696,C. PLEASE,As we all know Barney s job is PLEASE and he has not much to do at work That s why he started playing cups and key In this game there are three identical cups arranged in a line from left to right Initially key to Barney s heart is under the middle cup Then at one turn Barney swaps the cup in the middle with any of other two cups randomly he choses each with equal probability so the chosen cup becomes the middle one Game lasts turns and Barney a cup to swap with the middle one within each turn and the key always remains in the cup it was at the start After th turn Barney asks a girl to guess which cup contains the key The girl points to the middle one but Barney was distracted while making turns and doesn t know if the key is under the middle cup That s why he asked you to tell him the probability that girl guessed right Number of game turns can be extremely large that s why Barney did not give it to you Instead he gave you an array such that in other words is multiplication of all elements of the given array Because of precision difficulties Barney asked you to tell him the answer as an irreducible fraction In other words you need to find it as a fraction such that where is the greatest common divisor Since and can be extremely large you only need to find the remainders of dividing each of them by Please note that we want of and to be after dividing by ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint k;\nll x;\nint main() {\n\tscanf(""%d"",&k);\n\tll q=(mod-1)/2,d=2;\n\trep(i,0,k) {\n\t\tscanf(""%lld"",&x);\n\t\tq=powmod(q,x);\n\t\td=powmod(d,x);\n\t}\n\td=d*powmod(2,mod-2)%mod;\n\tq=(q*2+1)%mod*powmod(3,mod-2)%mod;\n\tll p=q*d%mod;\n\tprintf(""%lld/%lld\\n"",p,d);\n}\n']",,,"['combinatorics', 'dp', 'implementation', 'math', 'matrices']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. PLEASE.json,https://codeforces.com//blog/entry/46031,It gets tricky when the problem statement says p and q should be coprimes A wise coder in this situation thinks of a formula to make sure this happens First of all let s solve the problem if we only want to find the fraction Suppose dp i is answer for swapping the cups i times It s obvious that dp 1 0 For i 0 obviously the desired cup shouldn t be in the middle in i 1 th swap and with this condition the probability that after i th swap comes to the middle is 0 5 That s why Some people may use matrix to find p and q using this dp using pair of ints instead of floating point but there s a risk that p and q are not coprimes but fortunately or unfortunately they will be Using some algebra you can prove that if n is even then and q 2n 1 if n is odd then and q 2n 1 You can confirm that in both cases p and q are coprimes since p is odd and q is a power of 2 The only thing left to handle is to find 2n or 2n 1 and parity Finding parity is super easy Also 2n 2a1 a2 ak 2a1 a2 ak So it can be calculated using binary exponential Also dividing can be done using Fermat s little theorem 
https://codeforces.com//contest/2039/problem/B,3044241,B,2039B,2039,B. Shohag Loves Strings,For a string p let f p be the number of distinct non empty substrings text of p Shohag has a string s Help him find a non empty string p such that p is a substring of s and f p is even or state that no such string exists text A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ,"['#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;int n;string s;void Main() {\tcin >> s;\tL(i, 0, sz(s) - 2) {\t\tif(s[i] == s[i + 1]) {\t\t\tcout << s[i] << s[i + 1] << \'\\n\';\t\t\treturn;\t\t}\t}\tL(i, 0, sz(s) - 3) {\t\tif(s[i] != s[i + 2]) {\t\t\tcout << s[i] << s[i + 1] << s[i + 2] << \'\\n\';\t\t\treturn;\t\t}\t}\tcout << ""-1\\n"";}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}']",,,"['constructive algorithms', 'greedy', 'implementation', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Shohag Loves Strings.json,https://codeforces.com//blog/entry/136523,The condition seems hard to track So a good way is to play around with smaller cases and see if we can make some observations Let s start with the smallest string When the number of unique substrings so it s odd and not valid No one length strings are valid Let s try the next smallest strings When so it s even and valid When so it s odd and not valid Two length strings are valid if the adjacent characters are same So if contains two consecutive same characters we can print it right away All that remains is to consider strings without two consecutive same characters Let s try the next smallest strings with adjacent different characters When so it s odd and not valid When so it s even and valid Three length strings are valid if all characters are different So if contains three consecutive different characters we can print it right away All that remains is to consider strings without two adjacent same characters but no three consecutive different characters So all the remaining strings are of the form Let s try to see if we can make some observations about these strings Let s try to calculate the number of unique substrings for a string of the form There are exactly unique substrings of length and There are exactly unique substrings of length and There are exactly unique substrings of length and There are exactly unique substrings of length However the length substring occurs exactly once The number of unique substrings of any length is But only the length substring occurs exactly once So total number of unique substrings is And this is always odd So there is no solution for these strings We have covered all the cases If there are adjacent same characters we can print it right away If there are three consecutive different characters we can print it right away Otherwise there is no solution 
https://codeforces.com//contest/1517/problem/D,965874,D,1517D,1517,D. Explorer Space,You are wandering in the explorer space of the 2050 Conference The explorer space can be viewed as an undirected weighted grid graph with size n times m The set of vertices is i j 1 le i le n 1 le j le m Two vertices i 1 j 1 and i 2 j 2 are connected by an edge if and only if i 1 i 2 j 1 j 2 1 At each step you can walk to any vertex connected by an edge with your current vertex On each edge there are some number of exhibits Since you already know all the exhibits whenever you go through an edge containing x exhibits your increases by x For each starting vertex i j please answer the following question What is the minimum possible boredness if you walk from i j and go back to it after exactly k steps You can use any edge for multiple times but the boredness on those edges are also counted for multiple times At each step you cannot stay on your current vertex You also cannot change direction while going through an edge Before going back to your starting vertex i j after k steps you can visit i j or not freely ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint N,M,K;\nint dp[500][500][11];\nV<vi> fir, sec;\n\nint main() {\n\tsetIO();\n\tre(N,M,K);\n\tsec = V<vi>(N,vi(M-1));\n\tfir = V<vi>(N-1,vi(M));\n\tre(sec,fir);\n\tif (K&1) {\n\t\tF0R(i,N) {\n\t\t\tF0R(j,M) {\n\t\t\t\tpr(-1,\' \');\n\t\t\t}\n\t\t\tps();\n\t\t}\n\t\texit(0);\n\t}\n\tF0R(ti,K/2) {\n\t\tF0R(i,N) F0R(j,M) dp[i][j][ti+1] = MOD;\n\t\tF0R(i,N) F0R(j,M) {\n\t\t\tif (i+1 < N) {\n\t\t\t\tint val = min(dp[i][j][ti],dp[i+1][j][ti]);\n\t\t\t\tval += fir[i][j];\n\t\t\t\tckmin(dp[i][j][ti+1],val);\n\t\t\t\tckmin(dp[i+1][j][ti+1],val);\n\t\t\t}\n\t\t\tif (j+1 < M) {\n\t\t\t\tint val = min(dp[i][j][ti],dp[i][j+1][ti]);\n\t\t\t\tval += sec[i][j];\n\t\t\t\tckmin(dp[i][j][ti+1],val);\n\t\t\t\tckmin(dp[i][j+1][ti+1],val);\n\t\t\t}\n\t\t}\n\t}\n\tF0R(i,N) {\n\t\tF0R(j,M) {\n\t\t\tpr(2*dp[i][j][K/2],\' \');\n\t\t}\n\t\tps();\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']",,,"['dp', 'graphs', 'shortest paths']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Explorer Space.json,https://codeforces.com//blog/entry/89968,Since the graph is bipartite when is odd it is impossible to go back to the vertex after steps Since the graph is undirected we can always find a path with length walk along this path and return We can use dynamic programming to compute the shortest path from with length The time complexity is 
https://codeforces.com//contest/1594/problem/F,1135640,F,1594F,1594,F. Ideal Farm,Theofanis decided to visit his uncle s farm There are s animals and n animal pens on the farm For utility purpose animal pens are constructed in one row Uncle told Theofanis that a farm is if you can distribute all animals in all pens in such a way that there are no empty pens and there is at least one continuous segment of pens that has exactly k animals in total Moreover a farm is if it s lucky for any distribution without empty pens Neither Theofanis nor his uncle knows if their farm is ideal or not Can you help them to figure it out ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint a[1005],n,s,k,qwq=0;\ninline void dfs(int x,int y)\n{\n\tif(x==n)\n\t{\n\tif(qwq) return ;\n\t\ta[n]=y;\n\t\tint flag=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint s=0;\n\t\t\tfor(int j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\ts+=a[j];\n\t\t\t\tif(s==k)\n\t\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tcout << a[i] << ""*"";\n\t\t\tcout << ""\\n"";\n\t\t\tqwq=1;\n\t\t}\n\t\treturn ;\n\t}\n\tif(qwq) return ;\n\tfor(int i=1;i<=y-(n-x);i++)\n\t{\n\t\ta[x]=i,dfs(x+1,y-i);\n\t}\n}\nsigned main(int argc, char** argv) {\n\tint T;\n\tcin >> T;\n\t\n\twhile(T--)\n\t{\n\t\tcin >> s >> n >> k;\n/*\tfor(s=1;s<=10;s++)\n\t{\n\t\tfor(n=1;n<=s;n++)\n\t\t{\n\t\t\tfor(k=1;k<=10;k++)\n\t\t\t{*/\n\t\t\tqwq=0;\n\t\t\tint qaq=n/k*(k*2)+n%k;\n\t\t//\tcout << qwq << ""*\\n"";\n\t\tint ans1,ans2;\n\t//\t\tcout << n << "" "" << k << "" "" << s << ""\\n"";\n\t\t\tif(k>s)\n\t\t\t{\n\t\t\t\tcout << ""NO\\n"";\n\t\t\t\tans1=0;\n\t\t\t}\n\t\t\telse if(k==s)\n\t\t\t{\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\tans1=1;\n\t\t\t}\n\t\t\telse if(s>=qaq)\n\t\t\t{\n\t\t\t\tcout << ""NO\\n"";\n\t\t\t\tans1=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\tans1=1;\n\t\t\t}\n\t\t/*\tdfs(1,s); \n\t\t\tif(qwq)\n\t\t\t{\n\t\t\t\tcout << ""NO\\n\\n"";\n\t\t\t\tans2=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << ""YES\\n\\n"";\n\t\t\t\tans2=1;\n\t\t\t}\n\t\t\tif(ans1!=ans2)\n\t\t\t{\n\t\t\t\tfor(int i=1;i<=1000;i++)\n\t\t\t\t\tcout << n << "" "" << k << "" "" << s << ""\\n"";\n\t\t\t}*/\n//\t}\n}\n\treturn 0;\n}']",,,"['constructive algorithms', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Ideal Farm.json,https://codeforces.com//blog/entry/95525,The problem is the same as We have an array of length where every element of it is a positive integer and the sum of the whole array is If no matter how we construct the array we can find a non zero length subarray which has sum equal to print YES else print NO If then the answer is obviously YES and if then the answer is obviously NO Let indexed All the elements of array pre are different as all are positive integers Let but we also have Again all the elements of are different because all are positive integers Array has size and array has size If and only if an element from is equal to an element from then it means that or If it is the second case then obviously there is a subarray with sum equal to If it s the first case then so the subarray has sum But when do we have an equation in these two arrays There are elements and they can be values from to If the maximum number of distinct elements that we can take is less than the answer is YES else the answer is NO Let be the maximum number of elements that we can take We go through the last k elements and we count the number of elements that have the same modulo For each element in this range if there are odd elements that have the same modulo we can t take all of them because for every element that we add in that we also add to Thus one element would have a out of range Therefore we count all the elements that have odd elements with the same modulo and subtract them from to find 
https://codeforces.com//contest/1435/problem/B,773404,B,1435B,1435,B. A New Technique,All techniques in the ninja world consist of hand seals At the moment Naruto is learning a new technique which consists of n cdot m different seals denoted by distinct numbers All of them were written in an n times m table The table is lost now Naruto managed to remember elements of each row from left to right and elements of each column from top to bottom but he doesn t remember the order of rows and columns Please restore the table consistent with this data so that Naruto will be able to learn the new technique ,"[""#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nconst int N = 500 + 10;\nint T;\n\nint n, m, a[N][N], b[N][N], to[N * N];\nbool mark[N * N];\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> T;\n\n    while (T--) {\n        cin >> n >> m;\n\n        for (int i = 0; i <= n * m; i++)\n            mark[i] = to[i] = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++)\n                cin >> a[i][j];\n\n            mark[a[i][0]] = 1;\n            to[a[i][0]] = i;\n        }\n\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                cin >> b[i][j];\n\n        for (int k = 0; k < m; k++)\n            if (mark[b[k][0]]){\n                for (int ii = 0; ii < n; ii++) {\n                    int i = to[b[k][ii]];\n\n                    for (int j = 0; j < m; j++) cout << a[i][j] << ' ';\n                    cout << '\\n';\n                }\n\n                break;\n            }\n    }\n}\n""]",,,"['constructive algorithms', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. A New Technique.json,https://codeforces.com//blog/entry/84056,To solve this problem it s sufficient to find the position of each row in the table If we consider the first number of each row and find a column containing it we will automatically obtain the position of the row Since all numbers are distinct the positions will be determined uniquely 
https://codeforces.com//contest/568/problem/D,32826,D,568D,568,D. Sign Posts,One Khanate had a lot of roads and very little wood Riding along the roads was inconvenient because the roads did not have road signs indicating the direction to important cities The Han decided that it s time to fix the issue and ordered to put signs on every road The Minister of Transport has to do that but he has only signs Help the minister to solve his problem otherwise the poor guy can lose not only his position but also his head More formally every road in the Khanate is a line on the plane given by an equation of the form and are not equal to 0 at the same time You are required to determine whether you can put signs in at most points so that each road had at least one sign installed ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#ifdef WIN32\n\t#define LLD ""%I64d""\n#else\n\t#define LLD ""%lld""\n#endif\n\n#define pb push_back\n#define all(x) begin(x), end(x)\n\nconst int MAXIT[6] = {0, 1, 6, 13, 20, 25};\n\nstruct line\n{\n    int a, b, c;\n    int id;\n};\n\nvector<line> l;\nint n, k;\nvector<pair<int, int>> answer;\n\nvoid solve(vector<line> &l, int k)\n{\n    int n = l.size();\n    if (k >= (int)n)\n    {\n        for (int i = 0; i < (int)n; i++) answer.pb({l[i].id, -2});\n        printf(""YES\\n"");\n        printf(""%d\\n"", answer.size());\n        for (auto t : answer) printf(""%d %d\\n"", t.first + 1, t.second + 1);\n        exit(0);\n    }\n    if (k == 0) return;\n    for (int IT = 0; IT < MAXIT[k]; IT++)\n    {\n        int wh1 = rand() % n;\n        int wh2 = rand() % (n - 1);\n        if (wh2 >= wh1) wh2++;\n        auto &l1 = l[wh1];\n        auto &l2 = l[wh2];\n        if ((ll)l1.a * l2.b == (ll)l2.a * l1.b) continue;\n        vector<line> next;\n        for (auto &t : l) if ((ll)l1.a * l2.b * t.c + (ll)l1.b * l2.c * t.a + (ll)l1.c * l2.a * t.b !=\n                             (ll)l1.c * l2.b * t.a + (ll)l1.b * l2.a * t.c + (ll)l1.a * l2.c * t.b) next.pb(t);\n        if ((int)next.size() > max((double)k - 1, n * (1.0 - 1.0 / (2 * k)))) continue;\n        answer.pb({l1.id, l2.id});\n        solve(next, k - 1);\n        answer.pop_back();\n    }\n}\n\nint main()\n{\n    scanf(""%d%d"", &n, &k);\n    l.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(""%d%d%d"", &l[i].a, &l[i].b, &l[i].c);\n        l[i].id = i;\n    }\n    solve(l, k);\n    printf(""NO\\n"");\n    return 0;\n}\n']",,,"['brute force', 'geometry', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Sign Posts.json,https://codeforces.com//blog/entry/19705,Suppose that solution exist In case we can put one signpost on each road In other case let s choose any roads By the Dirichlet s principle there are at least two roads among selected which have common signpost Let s simple iterate over all variants with different two roads After choosing roads and we will remove all roads intersecting with and in common points and reduce in our problem This recursive process solves the problem if solution exist Complexity of this solution If implement this solution carefully you will get AC But in case of TL we can add one improvement to our solution Note that if we find point which belongs to or more roads then we must include this point to out answer For sufficiently large for example if this point always exist and we can find it using randomize algorithm If solution exist probability that two arbitrary roads are intersects in such a point not less than Because of it if we times pick two random roads then with probability such a point will be found and we can decrease All operations better to do in integers Complexity 
https://codeforces.com//contest/509/problem/A,21537,A,509A,509,A. Maximum in Table,An table is defined as follows The first row and the first column contain ones that is for all Each of the remaining numbers in the table is equal to the sum of the number above it and the number to the left of it In other words the remaining elements are defined by the formula These conditions define all the values in the table You are given a number You need to determine the maximum value in the table defined by the rules above ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\nlong long a[20][20],n;\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)a[1][i]=1;\n    for(int i=2;i<=n;i++){\n    a[i][1]=1;\n    for(int j=2;j<=n;j++)a[i][j]=a[i-1][j]+a[i][j-1];\n    }\n    cout<<a[n][n]<<endl;\n    return 0;\n}\n']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Maximum in Table.json,https://codeforces.com//blog/entry/16119,In this problem one needed to implement what was written in the statement create matrix two dimensional array using given rules and find maximal value in the table It is also possible to see that maximal element is always in bottom right corner Easier solution with recursion also was enough to get AC One may see the Pascal s triangle in the given matrix and understand that answer is equal to Prepared by riadwawAuthor of editorial riadwaw 
https://codeforces.com//contest/552/problem/A,29861,A,552A,552,A. Vanya and Table,Vanya has a table consisting of rows each row contains cells The rows are numbered by integers from to from bottom to top the columns are numbered from to from left to right In this table Vanya chose rectangles with sides that go along borders of squares some rectangles probably occur multiple times After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it Now he wants to find the sum of values in all cells of the table and as the table is too large he asks you to help him find the result ,"['#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nint N, T;\nint X1, Y1, X2, Y2;\n\nint main(){\n    setup();\n    cin >> N;\n    for(int i=0; i<N; i++){\n        cin >> X1 >> Y1 >> X2 >> Y2;\n        T += (abs(X2 - X1) + 1) * (abs(Y2 - Y1) + 1);\n    }\n\n    cout << T << endl;\n}\n']",,,"['implementation', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Vanya and Table.json,https://codeforces.com//blog/entry/18696,In this problem we can get AC with many solutions 1 With every new rectangle we will add his area to the result so for each line we will add to answer Time complexity 2 We can just do all that is written in the statement create an array and with each new rectangle we can just increment every element inside rectangle In the end we can just add all elements inside this array Time complexity C code Wild Hamster Java code Wild Hamster Python code Zlobober 
https://codeforces.com//contest/1456/problem/A,814136,A,1456A,1456,A. Bouncing Ball,You re creating a game level for some mobile game The level should contain some number of cells aligned in a row from left to right and numbered with consecutive integers starting from 1 and in each cell you can either put a platform or leave it empty In order to pass a level a player must throw a ball from the left so that it first lands on a platform in the cell p then bounces off it then bounces off a platform in the cell p k then a platform in the cell p 2k and so on every k th platform until it goes farther than the last cell If any of these cells has no platform you can t pass the level with these p and k You already have some level pattern a 1 a 2 a 3 a n where a i 0 means there is no platform in the cell i and a i 1 means there is one You want to modify it so that the level can be passed with given p and k In x seconds you can add a platform in some empty cell In y seconds you can remove the first cell completely reducing the number of cells by one and renumerating the other cells keeping their order You can t do any other operation You reduce the number of cells to less than p What is the minimum number of seconds you need to make this level passable with given p and k ,"[""#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, P, K; cin >> N >> P >> K; P--;\n\t\tstring s; cin >> s;\n\t\tvector<int64_t> A(N);\n\n\t\tint64_t X, Y; cin >> X >> Y;\n\t\tint64_t ans = N * X;\n\t\tfor (int i = N-1; i >= P; i--) {\n\t\t\tA[i] = (s[i] == '1' ? 0 : X);\n\t\t\tif (i+K < N) {\n\t\t\t\tA[i] += A[i+K];\n\t\t\t}\n\t\t\tans = min(ans, A[i] + Y * (i - P));\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n""]",,,"['brute force', 'dp', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Bouncing Ball.json,https://codeforces.com//blog/entry/85118,Note that instead of deletion of the first cell we can increase the value of p by one these operations are equivalent Now let s loop through the possible final values of p let it be q p q n Then we need to add missing platforms in cells q q k q 2k and so on Let s compute the array ci the number of cells without a platform among cells i i k i 2k an so on It can be computed using the method of dynamic programming going from large i to small ci ci k 1 ai Now the time required to add the platforms for a given value of q is cq x while the time needed to increase p to q is q p y The total time equals cq x q p y We only have to choose minimum among all possible values of q 
https://codeforces.com//contest/2051/problem/C,3099576,C,2051C,2051,C. Preparing for the Exam,Monocarp is preparing for his first exam at the university There are n different questions which can be asked during the exam numbered from 1 to n There are m different lists of questions each list consists of exactly n 1 different questions Each list i is characterized by one integer a i which is the index of the only question which is in the i th list For example if n 4 and a i 3 the i th list contains questions 1 2 4 During the exam Monocarp will receive one of these m lists of questions Then the professor will make Monocarp answer all questions from the list So Monocarp will pass only if he knows all questions from the list Monocarp knows the answers for k questions q 1 q 2 dots q k For each list determine if Monocarp will pass the exam if he receives that list ,"['#include <bits/stdc++.h>#define ll long longusing namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\xa0    int t;    cin >> t;\xa0    while(t--){        ll n, m, k;        cin >> n >> m >> k;\xa0        vector<ll> a(m);\xa0        for(auto &x: a) {            cin >> x;        }\xa0        vector<ll> q(k);\xa0        for(auto &x: q) {            cin >> x;        }\xa0        vector<char> res(n+1, 0);\xa0        for(auto x: q){            if(x >=1 && x <=n){                res[x] = 1;            }        }\xa0        string ans = """";        for(auto x: a){            if(x >=1 && x <=n && res[x]){                if(k == n){                    ans += \'1\';                }                else{                    ans += \'0\';                }            } else{                if(k == n -1){                    ans += \'1\';                }                else{                    ans += \'0\';                }            }        }\xa0        cout << ans << ""\\n"";    }}']",,,"['constructive algorithms', 'implementation']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Preparing for the Exam.json,https://codeforces.com//blog/entry/137623,For every question list we should check if Monocarp knows all questions from the list i e all numbers appear in the list Searching for every number in the list naively is too slow instead we can make a boolean array such that the th element in it is if and only if Monocarp knows the th question That way we can check if an integer appears in the list in However that is not enough since every list of questions contains questions and there are lists We need to use the fact that every list contains exactly questions somehow If Monocarp knows all questions he can answer any question list since he knows everything If Monocarp knows questions or less he cannot pass at all since every question list contains more questions than he knows The only case that s left if when i e Monocarp knows all questions except for one Let s analyze it in more detail the two next paragraphs will assume that Since every question list has the same size as the set of questions known by Monocarp then in order for Monocarp to pass the exam these two sets of questions must be equal However checking that they are equal by iterating on their contents is too slow instead we will check that two sets of questions are different by Let s check if Monocarp knows the question If he does then the th list of questions is different from the set of questions he knows so he can t pass But if Monocarp doesn t know the th question then he knows every question which is not so he can pass So Monocarp knows the th question list if and only if he does not know the th question and this can be checked in This way we get a solution working in on each test case 
https://codeforces.com//contest/1799/problem/F,1800603,F,1799F,1799,F. Halve or Subtract,You have an array of positive integers a 1 a 2 ldots a n of length n You are also given a positive integer b You are allowed to perform the following operations possibly several times in any order Choose some 1 le i le n and replace a i with lceil frac a i 2 rceil Here lceil x rceil denotes the smallest integer not less than x Choose some 1 le i le n and replace a i with max a i b 0 However you must also follow these rules You can perform at most k 1 operations of type 1 in total You can perform at most k 2 operations of type 2 in total For all 1 le i le n you can perform at most 1 operation of type 1 on element a i For all 1 le i le n you can perform at most 1 operation of type 2 on element a i The of an array is the sum of its elements Find the minimum cost of a you can achieve by performing these operations ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, b, k1, k2;\n    std::cin >> n >> b >> k1 >> k2;\n    \n    i64 sum = 0;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        sum += a[i];\n    }\n    \n    i64 ans = 0;\n    \n    std::sort(a.begin(), a.end(), std::greater());\n    \n    std::vector f(k1 + 1, std::vector<i64>(k2 + 1));\n    int mid = 0;\n    while (mid < n && a[mid] >= b) {\n        mid++;\n    }\n    \n    i64 res = 0;\n    for (int i = 0; i <= k1; i++) {\n        if (i > 0 && i <= mid) {\n            res += a[i - 1] / 2;\n        }\n        int t = std::min(i, mid);\n        i64 v = res;\n        for (int j = 0; j <= k2; j++) {\n            if (j > 0) {\n                if (t + j <= mid) {\n                    v += b;\n                } else if (j <= mid) {\n                    v += std::min(b, (a[t + j - mid - 1] + 1) / 2);\n                }\n            }\n            f[i][j] = v;\n        }\n    }\n    \n    res = 0;\n    for (int i = 0; i <= std::min(k2, n - mid); i++) {\n        if (i > 0) {\n            res += a[mid + i - 1];\n        }\n        i64 v = res;\n        for (int j = 0; j <= std::min(k1, n - i - mid); j++) {\n            if (j > 0) {\n                v += a[mid + i + j - 1] / 2;\n            }\n            ans = std::max(ans, v + f[k1 - j][k2 - i]);\n        }\n    }\n    \n    ans = sum - ans;\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['binary search', 'brute force', 'dp', 'greedy', 'sortings']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Halve or Subtract.json,https://codeforces.com//blog/entry/113321,For convenience let denote and denote First notice that if we apply both operations to some element it will be optimal to apply halving first then subtraction We can prove this with 2 cases In this case and so Since applying either function to a nonnegative integer results in a nonnegative integer Otherwise Then and Since Next suppose there are exactly elements to which we apply both operations Then it will be optimal to apply both operations to the greatest elements in the array This should be somewhat intuitive but here s a proof Suppose there are some such that Suppose we apply both operations to and only one operation to Then applying both operations to and a single operation to instead won t increase the resulting sum We can prove this with two cases We apply to Note that since it s optimal to apply first when applying both operations this case is essentially halve both elements then choose one to apply to And it s better to subtract from the greater element since for We apply to We can analyze this with surprise a few cases Then whichever element we apply both operations to will be and the result will depend only on the other element for so it s better to apply both operations to the greater element If we apply both operations to the greater element we subtract from the sum But applying both operations to the lesser element subtracts from the sum So it s optimal to apply both operations to the greater element And this covers all cases where Let s fix the number of elements we apply both operations to After taking them out we will be left with the smallest elements in the array Suppose we have operations of type 1 left and operations of type 2 left We ll assume otherwise we can apply both operations to more elements Notice that it s optimal to apply our operations to the greatest remaining elements subtracting from a greater element can t decrease the amount we subtract and halving a greater element can t decrease the amount we take away So we re left with elements and we want to choose of them to apply the halving to Let s consider a few cases and try to analyze them Let and suppose we want to apply to one of them and to the other Then it will be optimal to apply to the greater element Then it will be optimal to apply to the smaller element Using this information we can form the final lemma we need for our solution Let Suppose we apply to and and to Then it will not increase the answer to apply to one of or instead There are 4 cases we should consider to prove this lemma Then we should apply to and to the others Then we should apply to and to the others Then we should apply to and to the others Then we should apply to and to the others You can verify that doing this produces the optimal answer And using this lemma we find that the optimal answer has all operations applied to some of the middle elements with all operations applied to the endpoints To summarize the optimal answer will have a form like this assuming is sorted in non increasing order First come some elements to which we apply both operations Second come some elements to which we apply only Third come some elements to which we apply only Fourth come some elements to which we apply only Finally come some elements to which we apply no operations Note that some of these segments may be empty It s easy to verify that it s optimal to use all given operations So if we loop through all possible sizes for the first two segments we can uniquely determine the sizes of the last three Finally using prefix sums to quickly find the sums of elements in a segment we get an solution There is an interesting fact if we will fix the size of the first group and calculate the answer for it the function is convex So the ternary or binary search can be used here to find the minimum in time but it was not necessary 
https://codeforces.com//contest/1684/problem/G,1404377,G,1684G,1684,G. Euclid Guess,Let s consider Euclid s algorithm for finding the greatest common divisor where t is a list function Euclid a b if a b swap a b if b 0 return a r reminder from dividing a by b if r 0 append r to the back of t return Euclid b r There is an array p of pairs of positive integers that are not greater than m Initially the list t is empty Then the function is run on each pair in p After that the list t is shuffled and given to you You have to find an array p not greater than 2 cdot 10 4 that produces the given list t or tell that no such array exists ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 19:34:51       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> t(n);\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n  }\n  for (int i = 0; i < n; i++) {\n    if (2 * t[i] + 1 > m) {\n      cout << -1 << \'\\n\';\n      return 0;\n    }\n  }\n  sort(t.begin(), t.end());\n  int ptr = n;\n  while (ptr > 0 && 3 * t[ptr - 1] > m) {\n    ptr -= 1;\n  }\n  matching mat(n - ptr, ptr);\n  for (int i = 0; i < ptr; i++) {\n    for (int j = ptr; j < n; j++) {\n      if (t[j] % t[i] == 0 && 2 * t[j] + t[i] <= m) {\n        mat.add(j - ptr, i);\n      }\n    }\n  }\n  if (mat.solve() < n - ptr) {\n    cout << -1 << \'\\n\';\n    return 0;\n  }\n  vector<pair<int, int>> res;\n  for (int j = ptr; j < n; j++) {\n    int i = mat.pa[j - ptr];\n    res.emplace_back(2 * t[j] + t[i], t[j] + t[i]);\n  }\n  for (int i = 0; i < ptr; i++) {\n    if (mat.pb[i] == -1) {\n      res.emplace_back(3 * t[i], 2 * t[i]);\n    }\n  }\n  cout << res.size() << \'\\n\';\n  for (auto& p : res) {\n    cout << p.first << "" "" << p.second << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'flows', 'graph matchings', 'math', 'number theory']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Euclid Guess.json,https://codeforces.com//blog/entry/102995,Let s consider some pair and consider a sequence of remainders that is induced by this pair where If then we can just add a pair and we will get the only remainder so these values will not be a problem If if then then because if then which is impossible because if then Then because It means that for each there should be such that and is a divisor of For such values we can consider a bipartite graph where in the left part there are only and in the right part there are only and two integers are connected the integer on the right divies the left one This graph can be built in After that we just have to find such matching that covers each integer in the left part and add all unused integers from the right part using the method above 
https://codeforces.com//contest/934/problem/A,156723,A,934A,934,A. A Compatible Pair,Little Tommy has lanterns and Big Banban has lanterns Tommy s lanterns have brightness and Banban s have brightness respectively Tommy intends to hide one of his lanterns then Banban picks one of Tommy s non hidden lanterns and one of his own lanterns to form a pair The pair s brightness will be the product of the brightness of two lanterns Tommy wants to make the product as small as possible while Banban tries to make it as large as possible You are asked to find the brightness of the chosen pair if both of them choose optimally ,"['#include<bits/stdc++.h>\nusing namespace std;\nint i,j,k,n,m;\nlong long t=1e18,a[64],b[64];\nint main()\n{\n\tscanf(""%d%d"",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(""%lld"",a+i);\n\tfor(i=1;i<=m;++i)scanf(""%lld"",b+i);\n\tfor(k=1;k<=n;++k)\n\t{\n\t\tswap(a[k],a[n]);\n\t\t*a=-1e18;\n\t\tfor(i=1;i<n;++i)\n\t\t\tfor(j=1;j<=m;++j)\n\t\t\t\t*a=max(a[i]*b[j],*a);\n\t\tt=min(t,*a);\n\t\tswap(a[k],a[n]);\n\t}\n\tprintf(""%lld"",t);\n}']",,,"['brute force', 'games']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. A Compatible Pair.json,https://codeforces.com//blog/entry/57763,We can do as what we are supposed to do hide one of the Tommy s lantern and then take one non hidden lantern from Tommy and one lantern from Banban so that the product of their brightness is maximized and the minimum between all cases becomes our answer This is a straightforward solution Also there are many other ways to solve the problem but needs overall consideration By the way there were 10 pretests at first where most of contestants failed on the last one However considering not to make the judger running with heavy loads I took away 3 pretests and the pretest 10 was taken by mistake I must apologize for the extremely weak pretests that make tons of hacks now But it looks not so bad from the result 
https://codeforces.com//contest/1836/problem/A,1971173,A,1836A,1836,A. Destroyer,John is a lead programmer on a destroyer belonging to the space navy of the Confederacy of Independent Operating Systems One of his tasks is checking if the electronic brains of robots were damaged during battles A standard test is to order the robots to form one or several lines in each line the robots should stand one after another After that each robot reports the number of robots standing in front of it The i th robot reported number l i Unfortunately John does not know which line each robot stands in and can t check the reported numbers Please determine if it is possible to form the lines in such a way that all reported numbers are correct or not ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint n; \n\t\tcin >> n;\n\t\tmap<int, int> l;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tl[x]++;\n\t\t}\n\t\t\n\t\tbool possible = true;\n\t\tfor(int i = 1; i < 100; ++i){\n\t\t\tpossible &= l[i] <= l[i - 1];\n\t\t}\n\t\t\n\t\tcout << (possible ? ""YES"" : ""NO"") << endl;\n\t}\n\t\n\treturn 0;\n}\n']",,,"['implementation', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Destroyer.json,https://codeforces.com//blog/entry/117394,We can simplify the statement to the following can we divide the input sequence into multiple arithmetic sequences starting with and a common difference equal to Note that for each such arithmetic sequence if a number belongs to it then must also be included in it Thus if we denote as the number of occurrences of in the input we must have for each We can note that if such a condition is fulfilled we can always divide the input into described arithmetic sequences We can implement it straightforwardly in where is the maximum value in the input 
https://codeforces.com//contest/283/problem/A,2740,A,283A,283,A. Cows and Sequence,Bessie and the cows are playing with sequences and need your help They start with a sequence initially containing just the number 0 and perform operations Each operation is one of the following Add the integer to the first elements of the sequence Append an integer to the end of the sequence And hence the size of the sequence increases by 1 Remove the last element of the sequence So the size of the sequence decreases by one Note that this operation can only be done if there are at least two elements in the sequence After each operation the cows would like to know the average of all the numbers in the sequence Help them ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nlng val[210000];\nlng add[210000];\nlng sum;\nint n;\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tn=1;\n\t\n\tint tc;\n\tcin>>tc;\n\tforn(qqq,tc){\n\t\tint t;\n\t\tscanf(""%d"",&t);\n\t\tif(t==1){\n\t\t\tint a,x;\n\t\t\tscanf(""%d%d"",&a,&x);\n\t\t\t--a;\n\t\t\tadd[a]+=x;\n\t\t\tsum+=(a+1LL)*x;\n\t\t}else if(t==2){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tval[n]=x;\n\t\t\tadd[n]=0;\n\t\t\tsum+=x;\n\t\t\t++n;\n\t\t}else if(t==3){\n\t\t\t--n;\n\t\t\tsum-=val[n]+add[n];\n\t\t\tadd[n-1]+=add[n];\n\t\t}else exit(12);\n\t\tprintf(""%.15lf\\n"",1.*sum/n);\n\t}\n\n\treturn 0;\n}']",,,"['constructive algorithms', 'data structures', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Cows and Sequence.json,https://codeforces.com//blog/entry/7037,If you know some math you can actually solve this problem in You can show that the answer is p 1 where n is the number of positive integers i less than to n with gcd i n 1 To prove this we first show that there is always at least one primitive root for all primes p This is a fairly well known result so I won t prove it here but you can find many proofs online So now assume g is a primitive root Then the set g g2 gp 1 is congruent to the set 1 2 p 1 Furthermore its not hard to show that gi is a primitive root if and only if gcd i p 1 1 try it hence our formula p 1 n can be computed by getting the prime factors of n since so this gives us our algorithm 
https://codeforces.com//contest/1967/problem/F,2620326,F,1967F,1967,F. Next and Prev,Let p 1 ldots p n be a permutation of 1 ldots n Let the q subsequence of p be a permutation of 1 q whose elements are in the same relative order as in p 1 ldots p n That is we extract all elements not exceeding q together from p in the original order and they make the q subsequence of p For a given array a let pre i be the largest value satisfying pre i i and a pre i a i If it does not exist let pre i 10 100 Let nxt i be the smallest value satisfying nxt i i and a nxt i a i If it does not exist let nxt i 10 100 For each q such that 1 leq q leq n let a 1 ldots a q be the q subsequence of p For each i such that 1 leq i leq q pre i and nxt i will be calculated as defined Then you will be given some integer values of x and for each of them you have to calculate sum limits i 1 q min nxt i pre i x ,"['//Author: Kevin#include<bits/stdc++.h>#pragma GCC optimize(3)#pragma GCC target(""sse3"",""sse2"",""sse"")#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")using namespace std;#define ll long long#define ull unsigned ll#define pb emplace_back#define mp make_pair#define ALL(x) (x).begin(),(x).end()#define rALL(x) (x).rbegin(),(x).rend()#define srt(x) sort(ALL(x))#define rev(x) reverse(ALL(x))#define rsrt(x) sort(rALL(x))#define sz(x) (int)(x.size())#define inf 0x3f3f3f3f#define pii pair<int,int>#define lb(v,x) (int)(lower_bound(ALL(v),x)-v.begin())#define ub(v,x) (int)(upper_bound(ALL(v),x)-v.begin())#define uni(v) v.resize(unique(ALL(v))-v.begin())#define longer __int128_tvoid die(string S){puts(S.c_str());exit(0);}const int B=400;int p[300300],pos[300300],n;vector<int> vq[300300];vector<ll> vans[300300];int nxt[300300];vector<ll> vec[300300],psum[300300],vec2[300300],psum2[300300];int cur;int cnt[300300],cnt2[300300],tag[300300],tag2[300300];int mx[300300],mx2[300300];inline int get_ind(int x){return cnt[x/B]+cnt2[x];}void calc(){\tmemset(cnt,0,sizeof(int)*(n+10));\tmemset(cnt2,0,sizeof(int)*(n+10));\tmemset(tag,0,sizeof(int)*(n+10));\tmemset(nxt,inf,sizeof(int)*(n+10));\tmemset(tag2,0,sizeof(int)*(n+10));\tmemset(mx,-inf,sizeof(int)*(n+10));\tmemset(mx2,-inf,sizeof(int)*(n+10));\tfor(int i=0;i<=n/B;i++)\t{\t\tvec[i].clear();\t\tvec2[i].clear();\t\tpsum2[i]={0};\t\tpsum[i]={0};\t}\tfor(cur=1;cur<=n;cur++)\t{\t\tint po=pos[cur];\t\tint b=po/B;\t\tfor(int i=b+1;i<=n/B;i++)\t\t{\t\t\tcnt[i]++;\t\t\ttag[i]++;\t\t}\t\tfor(int i=po+1;i/B==b&&i<=n;i++)\t\t\tcnt2[i]++;\t\tint L=max(1,b*B),R=min(n,b*B+B-1);\t\tint ind=get_ind(po);\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t\tif(nxt[j]==mx[b])\t\t\t\t\tnxt[j]+=tag2[b];\t\ttag2[b]=0;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t\tnxt[j]+=tag[b];\t\ttag[b]=0;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t{\t\t\t\tif(j>po)\t\t\t\t\tnxt[j]++;\t\t\t\telse\t\t\t\t\tnxt[j]=min(nxt[j],ind);\t\t\t}\t\tmx[b]=-inf;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<=cur)\t\t\t\tmx[b]=max(mx[b],nxt[j]);\t\tmx2[b]=-inf;\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur)\t\t\t\tif(nxt[j]<mx[b])\t\t\t\t\tmx2[b]=max(mx2[b],nxt[j]);\t\tvec[b].clear();\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur&&nxt[j]<mx[b])\t\t\t\tvec[b].pb(nxt[j]-get_ind(j));\t\tvec2[b].clear();\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur&&nxt[j]==mx[b])\t\t\t\tvec2[b].pb(nxt[j]-get_ind(j));\t\tsrt(vec[b]);\t\tpsum[b].clear();\t\tpsum[b].pb(0);\t\tfor(auto x:vec[b])\t\t\tpsum[b].pb(psum[b].back()+x);\t\tsrt(vec2[b]);\t\tpsum2[b].clear();\t\tpsum2[b].pb(0);\t\tfor(auto x:vec2[b])\t\t\tpsum2[b].pb(psum2[b].back()+x);\t\tfor(int j=0;j<b;j++) if(tag[j]+mx[j]+tag2[j]>ind)\t\t{\t\t\tif(tag[j]+mx2[j]<ind)\t\t\t{\t\t\t\ttag2[j]=ind-mx[j]-tag[j];\t\t\t\tcontinue;\t\t\t}\t\t\tint L2=max(1,j*B),R2=min(n,j*B+B-1);\t\t\tfor(register int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<cur)\t\t\t\t\tif(nxt[j2]==mx[j])\t\t\t\t\t\tnxt[j2]+=tag2[j];\t\t\ttag2[j]=0;\t\t\tfor(register int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<cur)\t\t\t\t{\t\t\t\t\tnxt[j2]+=tag[j];\t\t\t\t\tnxt[j2]=min(nxt[j2],ind);\t\t\t\t}\t\t\ttag[j]=0;\t\t\tmx[j]=-inf;\t\t\tfor(register int j2=L2;j2<=R2;j2++) if(p[j2]<=cur)\t\t\t\tmx[j]=max(mx[j],nxt[j2]);\t\t\tmx2[j]=-inf;\t\t\tfor(register int j2=L2;j2<=R2;j2++) if(p[j2]<=cur) if(nxt[j2]!=mx[j])\t\t\t\tmx2[j]=max(mx2[j],nxt[j2]);\t\t\tvec[j].clear();\t\t\tfor(int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<=cur) if(nxt[j2]<mx[j])\t\t\t\t\tvec[j].pb(nxt[j2]-get_ind(j2));\t\t\tsrt(vec[j]);\t\t\tpsum[j].clear();\t\t\tpsum[j].pb(0);\t\t\tfor(auto x:vec[j])\t\t\t\tpsum[j].pb(psum[j].back()+x);\t\t\tvec2[j].clear();\t\t\tfor(int j2=L2;j2<=R2;j2++) if(p[j2]<=cur) if(nxt[j2]==mx[j])\t\t\t\tvec2[j].pb(nxt[j2]-get_ind(j2));\t\t\tsrt(vec2[j]);\t\t\tpsum2[j].clear();\t\t\tpsum2[j].pb(0);\t\t\tfor(auto x:vec2[j])\t\t\t\tpsum2[j].pb(psum2[j].back()+x);\t\t}\t\tfor(int qind=0;qind<sz(vq[cur]);qind++) if(!qind||vq[cur][qind]!=vq[cur][qind-1])\t\t{\t\t\tint X=vq[cur][qind];\t\t\tfor(int j=0;j<=n/B;j++)\t\t\t{\t\t\t\tint pos=lb(vec[j],X);\t\t\t\tvans[cur][qind]+=psum[j][pos]+1ll*X*(sz(vec[j])-pos);\t\t\t\tint pos2=lb(vec2[j],X-tag2[j]);\t\t\t\tvans[cur][qind]+=psum2[j][pos2]+1ll*tag2[j]*pos2+1ll*X*(sz(vec2[j])-pos2);\t\t\t}\t\t}\t}}int main(){\tios_base::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tint t;\tcin>>t;\twhile(t--)\t{\t\tcin>>n;\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tcin>>p[i];\t\t\tpos[p[i]]=i;\t\t}\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tint k;\t\t\tcin>>k;\t\t\tvq[i].resize(k);\t\t\tvans[i]=vector<ll>(k,0);\t\t\tfor(auto &x:vq[i])\t\t\t\tcin>>x;\t\t}\t\tcalc();\t\treverse(p+1,p+n+1);\t\tfor(int i=1;i<=n;i++)\t\t\tpos[p[i]]=i;\t\tcalc();\t\tfor(int i=1;i<=n;i++)\t\t\tfor(int j=0;j<sz(vq[i]);j++)\t\t\t\tif(!j||vq[i][j]!=vq[i][j-1])\t\t\t\t\tvans[i][j]-=i+vq[i][j]-1;\t\t\t\telse\t\t\t\t\tvans[i][j]=vans[i][j-1];\t\tfor(int i=1;i<=n;i++)\t\t\tfor(auto x:vans[i])\t\t\t\tcout<<x<<\'\\n\';\t}\treturn 0;}']",,,"['brute force', 'data structures', 'implementation']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Next and Prev.json,https://codeforces.com//blog/entry/129027,Consider an array with length For each integer from to consider s t we tag the untagged that is a position will not be tagged for a second time positions in the range By examining the total number of positions tagged we haveSymmetrically on the other side we only have to compute We want to maintain all in a sorted order so that queries can be done using binary search This can be done with the help of chunking Let the length of each block be In each block we divide the positions into two categories Positions with the maximum hereinafter referred to as and positions without the maximum hereinafter referred to as We sort the positions by for A and for B respectively How does an update affect the values For the block that the new number is inserted we brutely reconstruct it For an affected complete block the update is or A operation can just be handled with a lazy tag For a operation if it only affects the elements with maximum it can be done lazily otherwise you can reconstruct the whole block Let the potential of a block Similar to the segment tree beats each insertion increases by at most and each brute reconstruction takes time and decreases by at least Therefore the overall time complexity for the insertion part would be To answer a query we iterate over all the different blocks If we precalculate the prefix sums of in the sorted order with a simple binary search this part can be done easily in Let The time complexity would be while the space complexity is Merge sorting or fractional cascading will make the time complexity but it runs slower than the previously mentioned solution 
https://codeforces.com//contest/1374/problem/F,659590,F,1374F,1374,F. Cyclic Shifts Sorting,You are given an array a consisting of n integers In one move you can choose some index i 1 le i le n 2 and shift the segment a i a i 1 a i 2 cyclically to the right i e replace the segment a i a i 1 a i 2 with a i 2 a i a i 1 Your task is to sort the initial array by or say that it is impossible to do that You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << "" is "" << x << endl\n// #define endl \'\\n\'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7, N = 505;\n\nvi ans;\nint a[N], b[N];\n\nvoid go(int i) {\n\tans.PB(i);\n\tint t = a[i];\n\ta[i] = a[i + 2];\n\ta[i + 2] = a[i + 1];\n\ta[i + 1] = t;\n}\n\nvoid solve() {\n\tans.clear();\n\tint n;\n\tcin >> n;\n\tunordered_set<int> s;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ts.insert(a[i]);\n\t}\n\tfor(int i = n - 1; i >= 2; i--) {\n\t\tint pos = max_element(a, a + i + 1) - a;\n\t\tif(pos == 0) {\n\t\t\tgo(pos);\n\t\t\tpos++;\n\t\t}\n\t\twhile(pos != i) {\n\t\t\tgo(pos - 1);\n\t\t\tpos++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) b[i] = a[i];\n\tif(a[0] > a[1]) {\n\t\tif(s.size() == n) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tif(a[i] <= a[i + 1]) continue;\n\t\t\tif(i + 1 == n - 1) break;\n\t\t\tif(a[i + 2] == a[i]) {\n\t\t\t\tgo(i), go(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgo(i + 1);\n\t\t\tgo(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tassert(a[i] <= a[i + 1]);\n\t}\n\tcout << ans.size() << endl;\n\tfor(int i:ans) cout << i + 1 << "" "";\n\tcout << endl;\n}\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tsolve();\n\t}\t\n\t\n}\n\n\n\n']",,,"['brute force', 'constructive algorithms', 'implementation', 'sortings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Cyclic Shifts Sorting.json,https://codeforces.com//blog/entry/79517,Firstly let s solve the easier version of the problem Assume we are given a permutation not an array Notice that the given operation applied to some segment of the permutation cannot change the parity of number of inversions the number of inversions is the number of such pairs of indices that and So if the number of inversions in the given permutation is odd then we can t sort this permutation we can t obtain zero inversions But if the number of inversions is even then we can always sort the permutation with the following greedy algorithm let s find the minimum element and move it to the first position If its position is then we can apply the operation to the segment and our element will move by two positions to the left So after all our element is either at the first or at the second position If it s at the second position let s just apply two additional operations to the segment Then let s just cut off the first element and solve the problem without it At the end we have only two numbers that can be not sorted and we can check all three possibilities and choose one which is suitable for us it s always exists because the number of inversions is even How do we solve the problem if we are given the array not the permutation First of all we can prove that if the array contains at least two equal elements we can always sort it we will prove it by construction Let s just renumerate the elements of the given array in a way to obtian the permutation with the even number of inversions Thus if then let s find such a permutation that We can find this permutation easily if we sort the array of pairs in increasing order But there can be one problem this permutation can have odd number of inversions Then we need to find two consecutive pairs with the same first values and swap these two elements in the permutation Because in fact these two numbers are equal in the array and have consecutive values in the permutation we guaranteed change the parity of number of inversions Then we can apply our algorithm for permutations and solve the problem for the array If we failed then the answer is Otherwise the number of operations always does not exceed because this sort works like a bubble sort so our answer is suitable Time complexity 
https://codeforces.com//contest/1416/problem/B,740366,B,1416B,1416,B. Make Them Equal,You are given an array a consisting of n integers numbered from 1 to n You can perform the following operation no more than 3n times choose three integers i j and x 1 le i j le n 0 le x le 10 9 assign a i a i x cdot i a j a j x cdot i After each operation all elements of the array should be Can you find a sequence of no more than 3n operations after which all elements of the array are equal ,"['/**\n *    author:  tourist\n *    created: 27.09.2020 18:16:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n      sum += a[i];\n    }\n    if (sum % n != 0) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    int avg = sum / n;\n    vector<tuple<int, int, int>> ret;\n    auto Do = [&](int i, int j, int x) {\n      assert(a[i] >= x * i);\n      ret.emplace_back(i, j, x);\n      a[i] -= x * i;\n      a[j] += x * i;\n    };\n    for (int i = 2; i <= n; i++) {\n      int r = (i - a[i] % i) % i;\n      Do(1, i, r);\n      assert(a[i] % i == 0);\n      Do(i, 1, a[i] / i);\n    }\n    for (int i = 2; i <= n; i++) {\n      Do(1, i, avg);\n    }\n    cout << ret.size() << \'\\n\';\n    for (auto& t : ret) {\n      cout << get<0>(t) << "" "" << get<1>(t) << "" "" << get<2>(t) << \'\\n\';\n    }\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Make Them Equal.json,https://codeforces.com//blog/entry/83036,Let be the sum of the array If is not divisible by then the answer is obviously Otherwise there always exists a solution which uses no more than queries We will solve this problem in two phases First phase gather the sum in Let s iterate over in increasing order If is divisible by we can immediately transfer it using one operation Otherwise we have to make it divisible by transferring from to Note that this operation does not break a condition on non negativity because all are initially positive This way we successfully finish this phase using at most operations Second phase distribute the sum across all elements Just iterate over all and make a transfer of from to This phase takes exactly operations Time complexity Space complexity 
https://codeforces.com//contest/1174/problem/C,353392,C,1174C,1174,C. Ehab and a Special Coloring Problem,You re given an integer n For every integer i from 2 to n assign a positive integer a i such that the following conditions hold For any pair of integers i j if i and j are coprime a i neq a j The maximal value of all a i should be minimized that is as small as possible A pair of integers is called coprime if their greatest common divisor is 1 ,"[' #include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> mypair;\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == \'-\') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - \'0\';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nint n, a[100005], prime[100005], pcnt = 0, mark[100005], sm[100005];\n\nvoid init(int n)\n{\n\tfor (int i = 2; i <= n; i ++)\n\t{\n\t\tif (!mark[i]) prime[++ pcnt] = i;\n\t\tfor (int j = 1; j <= pcnt; j ++)\n\t\t{\n\t\t\tint np = prime[j], now = np * i;\n\t\t\tif (now > n) break;\n\t\t\tmark[now] = 1;\n\t\t\tsm[now] = np;\n\t\t\tif (i % np == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn = read();\n\tinit(n);\n\tint ind = 0;\n\tfor (int i = 2; i <= n; i ++)\n\t{\n\t\tif (!mark[i]) a[i] = ++ ind;\n\t\telse a[i] = a[sm[i]];\n\t}\n\tfor (int i = 2; i <= n; i ++)\n\t\tprintf(""%d%c"", a[i], i == n ? 10 : 32);\n}']",,,"['constructive algorithms', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Ehab and a Special Coloring Problem.json,https://codeforces.com//blog/entry/67388,Let s call the maximum value in the array Let the number of primes less than or equal to be called Then That s true because a distinct number must be assigned to each prime since all primes are coprime to each other Now if we can construct an answer wherein it ll be optimal Let s first assign a distinct number to each prime Then assign to every composite number the same number as any of its prime divisors This works because for any pair of numbers is given the same number of a divisor and so is so if they re coprime don t share a divisor they can t be given the same number Code link https pastebin com tDbgtnC8 Time complexity 
https://codeforces.com//contest/1059/problem/D,231523,D,1059D,1059,D. Nature Reserve,There is a forest that we model as a plane and live n rare animals Animal number i has its lair in the point x i y i In order to protect them a decision to build a nature reserve has been made The reserve must have a form of a circle containing all lairs There is also a straight river flowing through the forest All animals drink from this river therefore it must have at least one common point with the reserve On the other hand ships constantly sail along the river so the reserve must not have more than one common point with the river For convenience scientists have made a transformation of coordinates so that the river is defined by y 0 Check whether it is possible to build a reserve and if possible find the minimum possible radius of such a reserve ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\nvector<PLL>v;\nbool check(ld radius){\n    ld mxX = 1e20,miX = -1e20;\n//    dbg(radius);\n    for(auto p:v){\n        if(p.se > 2*radius)return false;\n        ld dy = abs(radius-p.se);\n        ld dx = sqrt(radius*radius-dy*dy);\n//        dbg(dx);\n//        dbg(dy);\n        upmin(mxX, p.fi+dx);\n        upmax(miX, p.fi-dx);\n    }\n    if(mxX >= miX)return true;\n    else return false;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return true;\n}\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    ll n;\n    \n    \n    in(n);\n    REP(i,0,n){\n        ll a,b;in(a,b);v.PB(MP(a,b));\n    }\n    int neg = 0,pos = 0;\n    REP(i,0,n){\n        if(v[i].se<0)neg = 1;\n        else pos = 1;\n    }\n    if(pos && neg){\n        cout<<-1;return 0;\n    }\n    if(neg)\n    REP(i,0,n)v[i].se *= -1;\n    \n    \n    \n    ld l = 0.2,r = 1e15;\n    REP(i,0,100){\n        ld mid = (l+r)/2;\n        if(check(mid))r = mid;\n        else l = mid;\n    }\n    printf(""%.15f"",(db)l);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']",,,"['binary search', 'geometry', 'ternary search']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Nature Reserve.json,https://codeforces.com//blog/entry/62238,If there are both positive and negative the answer is Now assume that Key observation the answer can be binary searched How to check if there is a valid circle with radius Firstly the center of such circle is on the line Every point must be not farther than from the center It means that the center is inside or on the boundary of all circles The intersection of every such circle with creates a segment possibly empty If the intersection of all such segments is non empty there exists some valid circle Total complexity is There is also an solution but it s much harder to implement 
https://codeforces.com//contest/1301/problem/E,538758,E,1301E,1301,E. Nanosoft,Warawreh created a great company called Nanosoft The only thing that Warawreh still has to do is to place a large picture containing its logo on top of the company s building The logo of Nanosoft can be described as four squares of the same size merged together into one large square The top left square is colored with red the top right square is colored with green the bottom left square is colored with yellow and the bottom right square is colored with blue An Example of some correct logos An Example of some incorrect logos Warawreh went to Adhami s store in order to buy the needed picture Although Adhami s store is very large he has only one picture that can be described as a grid of n rows and m columns The color of every cell in the picture will be green the symbol red the symbol yellow the symbol or blue the symbol Adhami gave Warawreh q options in every option he gave him a sub rectangle from that picture and told him that he can cut that sub rectangle for him To choose the best option Warawreh needs to know for every option the maximum area of sub square inside the given sub rectangle that can be a Nanosoft logo If there are no such sub squares the answer is 0 Warawreh couldn t find the best option himself so he asked you for help can you help him ,"['#include <bits/stdc++.h>\n\ninline int read() {\n    char c; int x; for (c = getchar(); !isdigit(c); c = getchar());\n    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - \'0\'; } return x;\n}\n\nconst int N = 505;\n\nint n, m, q, lim, ans, a[N][N], s[4][N][N], f[N][N][N];\nchar c[N][N];\n\ninline bool isFill(int x, int y, int _s, int t, int k) {\n    int fil = (_s - x + 1) * (t - y + 1);\n    int tmp = s[k][_s][t] + s[k][x - 1][y - 1] - s[k][_s][y - 1] - s[k][x - 1][t];\n    return fil == tmp;\n}\n\nint main() {\n    n = read(); m = read(); q = read();\n    for (int i = 1; i <= n; i++) {\n        scanf(""%s"", c[i] + 1);\n        for (int j = 1; j <= m; j++) {\n            if (c[i][j] == \'R\') { a[i][j] = 0; }\n            if (c[i][j] == \'G\') { a[i][j] = 1; }\n            if (c[i][j] == \'B\') { a[i][j] = 2; }\n            if (c[i][j] == \'Y\') { a[i][j] = 3; }\n            for (int k = 0; k < 4; k++) {\n                s[k][i][j] = s[k][i - 1][j] + s[k][i][j - 1] - s[k][i - 1][j - 1];\n                if (a[i][j] == k) { s[k][i][j]++; }\n            }\n        }\n    }\n    lim = std::min(n, m);\n    for (int len = 2; len <= lim; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            for (int j = 1; j <= m - len + 1; j++) {\n                f[len][i][j] = std::max(std::max(std::max(f[len - 1][i][j], f[len - 1][i + 1][j]), f[len - 1][i][j + 1]), f[len - 1][i + 1][j + 1]);\n                if (len % 2 == 0) {\n                    int x = i + len / 2, y = j + len / 2;\n                    if (isFill(i, j, x - 1, y - 1, 0) && isFill(i, y, x - 1, j + len - 1, 1) && isFill(x, y, i + len - 1, j + len - 1, 2) && isFill(x, j, i + len - 1, y - 1, 3)) {\n                        f[len][i][j] = std::max(f[len][i][j], len * len);\n                    }\n                }\n            }\n        }\n    }\n    for (int _ = 0; _ < q; _++) {\n        int x = read(), y = read(), r = read(), c = read();\n        int lenx = r - x + 1, leny = c - y + 1;\n        ans = 0;\n        if (lenx >= leny) {\n            for (int i = x; i + leny - 1 <= r; i++) {\n                ans = std::max(ans, f[leny][i][y]);\n            }\n        } else {\n            for (int i = y; i + lenx - 1 <= c; i++) {\n                ans = std::max(ans, f[lenx][x][i]);\n            }\n        }\n        printf(""%d\\n"", ans);\n    }\n    return 0;\n}']",,,"['binary search', 'data structures', 'dp', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Nanosoft.json,https://codeforces.com//blog/entry/73877,For each cell we will calculate the maximum size of a Nanosoft logo in which it is the bottom right cell in the top left square The cell marked with in this picture If we had a grid like this If we take the cell in the second row second column it can make a Nanosoft logo with size being the bottom right cell in the top left square We can calculate the answer for every cell using binary search and checking every sub square using 2D cumulative sum Now we build a 2D array that contains that previous calculated answer lets call it For the previous picture will be like this Now for each query we can do binary search on its answer We check the current mid this way The mid will tell us the length of one of the sides divided by 2 Like if mid 2 the area of the square we are checking is Now we should check the maximum element in the 2D array val in the 2D range The current mid is correct if the maximum element in that 2D range is greater than or equal to We can get the maximum value in a 2D range using 2D sparse table with build in and query in total Complexity is code https ideone com VyYsoc 
https://codeforces.com//contest/1747/problem/C,1620660,C,1747C,1747,C. Swap Game,Alice and Bob are playing a game on an array a of n positive integers Alice and Bob make alternating moves with Alice going first In his her turn the player makes the following move If a 1 0 the player loses the game otherwise Player chooses some i with 2 le i le n Then player decreases the value of a 1 by 1 and swaps a 1 with a i Determine the winner of the game if both players play optimally ,"['// LUOGU_RID: 93003026\n/*\nわんわん……わんだほーいっ☆\nWonderhoy!\n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nchar buf[1<<21],*p1=buf,*p2=buf;\n#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)\nint read()\n{\n\tint x=0;\n\tchar c=getchar();\n\twhile(c<\'0\' || c>\'9\')\tc=getchar();\n\twhile(c>=\'0\' && c<=\'9\')\tx=(x<<1)+(x<<3)+(c^\'0\'),c=getchar();\n\treturn x;\n}\nvoid write(int x)\n{\n\tif(x>9)\twrite(x/10);\n\tputchar(x%10+\'0\');\n}\nconst int MOD=998244353;\ninline int Add(int u,int v){return u+v>=MOD?u+v-MOD:u+v;}\ninline int Sub(int u,int v){return u-v>=0?u-v:u-v+MOD;}\ninline int Mul(int u,int v){return LL(u)*LL(v)%MOD;}\ninline int add(int &u,int v){return u=Add(u,v);}\ninline int sub(int &u,int v){return u=Sub(u,v);}\ninline int mul(int &u,int v){return u=Mul(u,v);}\nint QuickPow(int x,int p=MOD-2)\n{\n\tint ans=1,base=x;\n\twhile(p)\n\t{\n\t\tif(p&1)\tmul(ans,base);\n\t\tmul(base,base);\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nvoid Solve();\nint main(){\n\tint T=read();\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}\nint n,a[100005];\nvoid Solve()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)\ta[i]=read();\n\tint f=1e9,g=1e9;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(a[i]<=f)\tg=f,f=a[i];\n\t\telse if(a[i]<=g)\tg=a[i];\n\t}\n\tint p=f,q=min(a[1]-1,g);\n\tputs(p<=q?""Alice"":""Bob"");\n}']",,,['games'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Swap Game.json,https://codeforces.com//blog/entry/108782,Case 1 a1 min a Alice can force the Bob to always decrease the minimum element by always choosing minimum element of a in her turn Where as Bob can not do much all other elements he would swap with would be greater than or equal to min a Even if there exists multiple minimums in a In first move Alice would decrease from a1 hence in this case Alice would always win Case 2 a1 min a In this case optimal startegy for Bob would be to always chhose minimum element of the array which is a1 Alice would always be swapping the element greater than a1 in her turn hence in the case Bob would always win
https://codeforces.com//contest/698/problem/D,65779,D,698D,698,D. Limak and Shooting Points,Bearland is a dangerous place Limak can t travel on foot Instead he has magic teleportation stones Each stone can be used The th stone allows to teleport to a point Limak can use stones There are monsters in Bearland The th of them stands at The given points are pairwise distinct After each teleportation Limak can shoot an arrow in some direction An arrow will hit the first monster in the chosen direction Then both an arrow and a monster disappear It s dangerous to stay in one place for long so Limak can shoot only one arrow from one place A monster should be afraid if it s possible that Limak will hit it How many monsters should be afraid of Limak ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint k,n,ax[N],ay[N],px[N],py[N];\nvector<PII> vec[N];\nmap<PII,int> hs;\nVI pr[10][N];\nint sht[N],vis[N];\nint gcd(int x,int y) { return x?gcd(y%x,x):y; }\nbool dfs(int rm,VI c) {\n/*\tputs(""-----state begin-----"");\n\tprintf(""%d\\n"",rm);\n\tfor (auto v:c) printf(""%d "",v); puts("""");\n\trep(i,0,n) printf(""%d "",sht[i]); puts("""");\n\trep(i,0,k) printf(""%d "",vis[i]); puts("""");\n\tputs(""-----state end-----"");*/\n\tif (SZ(c)==0) return 1;\n\tif (SZ(c)>rm) return 0;\n\tfor (auto v:c) {\n\t\tsht[v]=1;\n\t\trep(j,0,k) if (!vis[j]&&SZ(pr[j][v])<=7) {\n\t\t\tvis[j]=1;\n\t\t\tbool val=1;\n\t\t\tset<int> d(all(c)); d.erase(v);\n\t\t\tfor (auto pp:pr[j][v]) {\n//\t\t\t\tprintf(""%d %d %d\\n"",j,v,pp);\n\t\t\t\tif (sht[pp]) {\n\t\t\t\t\tval=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td.insert(pp);\n\t\t\t\tif (SZ(d)>rm) {\n\t\t\t\t\tval=0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (val) {\n\t\t\t\tif (dfs(rm-1,VI(all(d)))) return 1;\n\t\t\t}\n\t\t\tvis[j]=0;\n\t\t}\n\t\tsht[v]=0;\n\t}\n\treturn 0;\n}\nint main() {\n\tscanf(""%d%d"",&k,&n);\n\trep(i,0,k) scanf(""%d%d"",ax+i,ay+i);\n\trep(i,0,n) scanf(""%d%d"",px+i,py+i);\n\trep(z,0,k) {\n\t\trep(j,0,n+1) vec[j].clear();\n\t\ths.clear();\n\t\tint tot=0;\n\t\trep(j,0,n) {\n\t\t\tint x=px[j]-ax[z];\n\t\t\tint y=py[j]-ay[z];\n\t\t\tint d=gcd(x,y);\n\t\t\td=abs(d);\n\t\t\tx/=d; y/=d;\n\t\t\tif (!hs.count(mp(x,y))) hs[mp(x,y)]=tot++;\n\t\t\tvec[hs[mp(x,y)]].pb(mp(d,j));\n\t\t}\n\t\trep(i,0,tot) {\n\t\t\tsort(all(vec[i]));\n\t\t\tVI v;\n\t\t\tfor (auto p:vec[i]) {\n\t\t\t\tpr[z][p.se]=v;\n//\t\t\t\tprintf(""%d "",p.se);\n\t\t\t\tv.pb(p.se);\n\t\t\t}\n//\t\t\tputs("""");\n\t\t}\n//\t\tputs(""----"");\n\t}\n\tint ret=0;\n\trep(i,0,n) {\n\t\tmemset(sht,0,sizeof(sht));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(k,VI{i}))ret++;\n\t}\n\tprintf(""%d\\n"",ret);\n}\n']",,,"['brute force', 'geometry', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Limak and Shooting Points.json,https://codeforces.com//blog/entry/46148,Spoiler There are places and monsters For each of places let s sort monsters by angle Thanks to that for each pair place monster we will be able to know which monsters don t allow us do directly hit this monster from this place Let s iterate over monsters and for each of them independently check if it can be hit We want to get the complexity or We fixed a monster We want it to be hit in some moment So let s iterate over places considering which place will eventually hit a monster We fixed a place which will hit Thanks to the preprocessing sorting by angle at the beginning we are able to check if the fixed place can directly hit While we can t hit directly we find any blocking monster it may be e g the first monster in this direction looking from the fixed place Let s call it If we want to succeed then some place must hit Iterate over which place will hit Again check if it can directly hit now If yes then mark this place as used and as killed and go back to checking but with monster killed and thus not blocking us anymore Otherwise find any monster in this direction and again iterate over a place to hit it in the future While checking if a monster may be directly hit by some place remember that some monsters may be already killed and thus they don t block anything The above should give you the rough understanding of the solution Let s talk about the details and the implementation Iterate over a monster to check and over permutations of places Create a recursive function rec int monster to kill list int permutation Take the first place from the list and remove it for ever from the list This will be a place to eventually kill monster to kill maybe not now While there are any alive monsters between the fixed place and monster to kill choose any of those alive monsters and run rec that monster permutation Don t treat permutation as the order of teleportation stones to use It s only the order in which we take them from some stack list It only allows us to nicely simulate iterating over a place from which we want to get rid of some blocking monster Some words about the correctness Is it possible that the described solution isn t able to find a way to kill a monster while there exists a way In such a way there is some place from which Limak will hit the monster We simulated iterating over such a place We can t hit directly at the beginning only if there are some blocking monsters between the place and the monster Each of them must be hit from some place We don t assume anything about the order of monsters or about the order of places from which we hit In the optimal way every monster initially blocking us must be hit in some moment by some place so we can and must iterate over a place from which it will be hit If there are some new blocking monsters then again in the optimal way some place hits it and we iterate over it 
https://codeforces.com//contest/1693/problem/B,1430889,B,1693B,1693,B. Fake Plastic Trees,We are given a rooted tree consisting of n vertices numbered from 1 to n The root of the tree is the vertex 1 and the parent of the vertex v is p v There is a number written on each vertex initially all numbers are equal to 0 Let s denote the number written on the vertex v as a v For each v we want a v to be between l v and r v l v leq a v leq r v In a single operation we do the following Choose some vertex v Let b 1 b 2 ldots b k be vertices on the path from the vertex 1 to vertex v meaning b 1 1 b k v and b i p b i 1 Choose a non decreasing array c of length k of nonnegative integers 0 leq c 1 leq c 2 leq ldots leq c k For each i 1 leq i leq k increase a b i by c i What s the minimum number of operations needed to achieve our goal ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint oj[nax];\nll dol[nax];\nll gor[nax];\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""Yes\\n"");\n\telse\n\t\tprintf(""No\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=0;\n\tfor (int i=2; i<=n; i++)\n\t\tscanf(""%d"", &oj[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld%lld"", &dol[i], &gor[i]);\n\tint wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]<dol[i])\n\t\t{\n\t\t\twyn++;\n\t\t\ttab[i]=gor[i];\n\t\t}\n\t\ttab[oj[i]]+=min(gor[i], tab[i]);\n\t}\n\tprintf(""%d\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dp', 'greedy', 'trees']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Fake Plastic Trees.json,https://codeforces.com//blog/entry/103952,Lemma 1 You won t perform the operation on a particular vertex more than once Because you could merge the operations Lemma 2 If you perform the operation on some vertex you can do it with If there is another operation that helps this vertex you can cut the operation into two pieces and merge one with the operation that starts at And you can just increase if it s not equal to Define as the minimum number of operations needed to satisfy the conditions on the vertices in the subtree of vertex We claim that there is a way to achieve our goal with minimum number of operations in which for each vertex there are exactly operations done in the subtree of vertex Imagine there is a vertex that there are more than operations on vertices in the subtree of vertex We can instead satisfy the subtree by operations and make sure that we perform the operation on vertex Denote as the maximum value that vertex can pass to its ancestors if exactly operations are performed in the subtree of vertex We need to perform the operation on a vertex if and only if If we need to perform the operation on vertex then otherwise Time complexity 
https://codeforces.com//contest/1419/problem/B,729808,B,1419B,1419,B. Stairs,Jett is tired after destroying the town and she wants to have a rest She likes high places that s why for having a rest she wants to get high and she decided to craft staircases A staircase is a squared figure that consists of square cells Each staircase consists of an arbitrary number of stairs If a staircase has n stairs then it is made of n columns the first column is 1 cell high the second column is 2 cells high ldots the n th column if n cells high The lowest cells of all stairs must be in the same row A staircase with n stairs is called nice if it may be covered by n squares made of cells All squares should fully consist of cells of a staircase This is how a nice covered staircase with 7 stairs looks like Find out the maximal number of nice staircases that can be built using no more than x cells No cell can be used more than once ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint pw[MAXN], t[MAXN];\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    int T; cin >> T;\n    pw[0] = 1; For(i, 1, 62) pw[i] = pw[i-1] * 2;\n    For(i, 1, 63) t[i] = t[i-1] + pw[i-1];\n    while(T--) {\n    \tint x; cin >> x;\n    \tFor(i, 1, 63) {\n    \t\tif(x < t[i] * (t[i] + 1) / 2) {\n    \t\t\tprintf(""%d\\n"", i - 1); break;\n\t\t\t}\n\t\t\telse x -= t[i] * (t[i] + 1) / 2;\n\t\t}\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']",,,"['brute force', 'constructive algorithms', 'greedy', 'implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Stairs.json,https://codeforces.com//blog/entry/82817,Let s prove that the minimal amount of squares needed to cover the staircase is not less than where is the height of a staircase To highest cell of each stair is the top left cell of some square That s why we need at least squares You need exactly squares if and only if the top left cell of each stair is a top left cell of some sqaure Let s consider a square that covers the lowest cell in the last stair Its top left corner should contain the highest cell with index for odd Then the staircase is divided into 2 staircases each stairs high These staircases should be nice too It means that nice staircases are stairs high where To maximize the amount of different staircases we should create staircases greedily If is even then we can consider a square that will have the lowest cell of the last stair The top left corner of this square may not contain any top cells of a staircase that s why you will need more than squares This means that a staircase with an even height may not be nice 
https://codeforces.com//contest/401/problem/D,6959,D,401D,401,D. Roman and Numbers,Roman is a young mathematician very famous in Uzhland Unfortunately Sereja doesn t think so To make Sereja change his mind Roman is ready to solve any mathematical problem After some thought Sereja asked Roma to find how many numbers are close to number modulo Number is considered close to number modulo if it can be obtained by rearranging the digits of number it doesn t have any leading zeroes the remainder after dividing number by equals 0 Roman is a good mathematician but the number of such numbers is too huge for him So he asks you to help him ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nlong long n;\nint f[20],num,m,maxn,g[10];\nlong long dp[1<<18][100];\nbool flag;\n\nint main()\n{\n    memset(f,0,sizeof(f));\n    memset(dp,0,sizeof(dp));\n    cin>>n>>m;\n    num=0;\n    if(n%m==0)flag=true;\n    else flag=false;\n    while(n)\n    {\n        f[num++]=n%10;\n        n=n/10;\n    }\n    maxn=1<<num;\n    dp[0][0]=1;\n    for(int k=0;k<num;k++)\n        if(f[k])dp[1<<k][f[k]%m]+=dp[0][0];\n    for(int i=1;i<maxn;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<num;k++)\n                if(!(i&(1<<k)))dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }\n    memset(g,0,sizeof(g));\n    for(int i=0;i<num;i++)\n        g[f[i]]++;\n    long long ans=dp[maxn-1][0];\n    for(int i=0;i<10;i++)\n        for(int j=1;j<=g[i];j++)\n            ans=ans/j;\n    //if(flag)ans--;\n    cout<<ans;\n    return 0;\n}\n']",,,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Roman and Numbers.json,https://codeforces.com//blog/entry/10842,This problem we can be attributed to the dynamic programming We must using mask and dynamic We have dynamic dp i x when i mask of reshuffle and x remainder on dividing by m if we want to add number a j we must using it In the end we must answer to divide by the factorial number of occurrences of each digit Solution D 
https://codeforces.com//contest/1739/problem/C,1559865,C,1739C,1739,C. Card Game,Consider a game with n cards n is even Each card has a number written on it between 1 and n All numbers on the cards are different We say that a card with number x is stronger than a card with number y if x y Two players Alex and Boris play this game In the beginning each of them receives exactly frac n 2 cards so each card belongs to exactly one player Then they take turns Alex goes first then Boris then Alex again and so on On a player s turn he must play of his cards Then if the opponent doesn t have any cards than the card played the opponent loses and the game ends Otherwise the opponent has to play a stronger card exactly one card as well These two cards are removed from the game and the turn ends If there are no cards left the game ends in a draw otherwise it s the opponent s turn Consider all possible ways to distribute the cards between two players so that each of them receives exactly half of the cards You have to calculate three numbers the number of ways to distribute the cards so that Alex wins the number of ways to distribute the cards so that Boris wins the number of ways to distribute the cards so that the game ends in a draw You may assume that both players play optimally i e if a player can win no matter how his opponent plays he wins Two ways to distribute the cards are different if there is at least one card such that in one of these ways it is given to Alex and in the other way it is given to Boris For example suppose n 4 Alex receives the cards 2 3 and Boris receives the cards 1 4 Then the game may go as follows if Alex plays the card 2 then Boris has to respond with the card 4 Then Alex s turn ends and Boris turn starts Boris has only one card left which is 1 he plays it and Alex responds with the card 3 So the game ends in a draw if Alex plays the card 3 then Boris has to respond with the card 4 Then Alex s turn ends and Boris turn starts Boris has only one card left which is 1 he plays it and Alex responds with the card 2 So the game ends in a draw So in this case the game ends in a draw ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include ""library/debug.cpp""\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n    modular& operator+=(const modular& other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(const modular& other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(const modular& other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(const modular& other) {\n        long long a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    friend modular operator+(const modular& lhs, const modular& rhs) { return modular(lhs) += rhs; }\n    friend modular operator-(const modular& lhs, const modular& rhs) { return modular(lhs) -= rhs; }\n    friend modular operator*(const modular& lhs, const modular& rhs) { return modular(lhs) *= rhs; }\n    friend modular operator/(const modular& lhs, const modular& rhs) { return modular(lhs) /= rhs; }\n    modular& operator++() { return *this += 1; }\n    modular& operator--() { return *this -= 1; }\n    modular operator++(int) {\n        modular res(*this);\n        *this += 1;\n        return res;\n    }\n    modular operator--(int) {\n        modular res(*this);\n        *this -= 1;\n        return res;\n    }\n    modular operator-() const { return modular(-value); }\n    bool operator==(const modular& rhs) const { return value == rhs.value; }\n    bool operator!=(const modular& rhs) const { return value != rhs.value; }\n    bool operator<(const modular& rhs) const { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(const modular<mod>& x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, const modular<mod>& x) {\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\n\nconstexpr long long mod = 998244353;\nusing mint = modular<mod>;\n\nmint power(mint a, long long n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<mint> fact(1, 1);\nvector<mint> finv(1, 1);\n\nmint C(int n, int k) {\n    if (n < k || k < 0) {\n        return mint(0);\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.emplace_back(fact.back() * (int) fact.size());\n        finv.emplace_back(mint(1) / fact.back());\n    }\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n;\n        cin >> n;\n        mint a = 0, b = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            if (i % 2 == 1) {\n                a += C(2 * i - 1, i);\n                b += C(2 * i - 2, i);\n            } else {\n                a += C(2 * i - 2, i);\n                b += C(2 * i - 1, i);\n            }\n        }\n        if (n % 4 == 0) {\n            swap(a, b);\n        }\n        cout << a << "" "" << b << "" "" << 1 << \'\\n\';\n    }\n    return 0;\n}']",,,"['combinatorics', 'constructive algorithms', 'dp', 'games']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Card Game.json,https://codeforces.com//blog/entry/107461,The example tests suggest that there is only one possible distribution with a draw Let s find out why it is so We will use a process similar to induction recursion to distribute the cards between the two players so that the game ends in a draw suppose Alex receives the card Then he wins since he can play it immediately So for the game to result in a draw Boris must receive the card suppose Boris receives the card Then he wins since he also has the card he can use it to answer any first move of Alex and then win the game by playing So for the game to result in a draw Alex must receive the card suppose Boris receives the card Then he wins since he also has the card if Alex plays the card Boris responds with and then plays if Alex plays some other card Boris responds with and the plays So for the game to result in a draw Alex must receive the card and so on In fact if Alex receives the card and Boris receives the card Alex must play the card or something equivalent to it on the first move and Boris must respond with the card so we can consider the game without these two cards with the roles swapped So if we consider the distribution of cards as a string with characters and where denotes the card belonging to Alex and denotes the card belonging to Boris and the th character of the string represents the card the only possible distribution for the draw is But there s more to this string representation of the distribution of cards the first character that is different from this pattern denotes the winner if the first different character is in the draw distribution and in the distribution we consider the winner is Boris otherwise the winner is Alex This may lead us to the following ways to count the number of possible distributions which win lose for Alex we can use dynamic programming of the form where is the number of characters we used is the number of characters we used and is or depending on whether our string coincides with the draw string differs from it in a way that Alex wins or differs from it in a way that Boris wins the actual value of must be the number of ways to reach this state of dynamic programming The answer then is stored in the states of the form or we can use combinatorics let s iterate on the length of the prefix that is common in the draw string and in the string representing the distribution of cards and then count the number of ways to distribute the remaining characters with a binomial coefficient To calculate the binomial coefficients we can use one of the following methods Pascal s triangle precalculating factorials and modular inverses to then or calculating factorials with big integers in Java or Python 
https://codeforces.com//contest/1157/problem/C1,336289,C1,1157C1,1157,C1. Increasing Subsequence  easy version , You are given a sequence a consisting of n integers You are making a sequence of moves During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence write it down and remove it from the sequence Your task is to write down a increasing sequence and among all such sequences you should take the longest the length of the sequence is the number of elements in it For example for the sequence 2 1 5 4 3 the answer is 4 you take 2 and the sequence becomes 1 5 4 3 then you take the rightmost element 3 and the sequence becomes 1 5 4 then you take 4 and the sequence becomes 1 5 and then you take 5 and the sequence becomes 1 the obtained increasing sequence is 2 3 4 5 ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tprintf(""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n\n// Optimize\n#define abs(a) ((a)<0?(~(a)+1):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) {a=a^b;b=a^b;a=a^b;}\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define MOD 998244353\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 262144\n\nint n;\nint a[MAXN];\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) Read(a[i]);\n\n\tint l = 1, r = n;\n\tstring ans = """";\n\tint last = -INF;\n\tFor(i,n){\n\t\tbool use_r = 0;\n\t\tif( max(a[l],a[r]) <= last ) break;\n\t\tif( a[l] < a[r] ){\n\t\t\tif( a[l] <= last ) use_r = 1;\n\t\t}else{\n\t\t\tif( a[r] > last ) use_r = 1;\n\t\t}\n\t\tif(use_r){\n\t\t\tlast = a[r];\n\t\t\t--r;\n\t\t\tans += \'R\';\n\t\t}else{\n\t\t\tlast = a[l];\n\t\t\t++l;\n\t\t\tans += \'L\';\n\t\t}\n\t}\n\tcout << ans.length() << endl;\n\tcout << ans << endl;\n\n\tEND();\n}\n']",,,['greedy'],1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C1. Increasing Subsequence  easy version .json,https://codeforces.com/blog/entry/66737,In this problem the following greedy solution works let s maintain the last element of the increasing sequence we got and on each turn choose the minimum element greater than this last element among the leftmost and the rightmost Such turns will maximize the answer You can find details of implementation in the authors solution 
https://codeforces.com//contest/1821/problem/E,1887931,E,1821E,1821,E. Rearrange Brackets,A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not You are given a regular bracket sequence In one move you can remove a pair of brackets such that the left one is an opening bracket and the right one is a closing bracket Then concatenate the resulting parts without changing the order The cost of this move is the number of brackets to the right of the right bracket of this pair The of the regular bracket sequence is the smallest total cost of the moves required to make the sequence empty Actually you are not removing any brackets Instead you are given a regular bracket sequence and an integer k You can perform the following operation extract some bracket from the sequence and insert it back at any position between any two brackets at the start or at the end possibly at the same place it was before After all operations are performed the bracket sequence has to be regular What is the smallest possible of the resulting regular bracket sequence ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[2][7][7][7];\nll rui[MAX];\n\nint main(){\n    \n    std::ifstream in(""text.txt"");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        int K;cin>>K;\n        string S;cin>>S;\n        int N=si(S);\n        for(int i=0;i<=N;i++){\n            rui[i]=0;\n        }\n        \n        for(int s=0;s<2;s++) for(int j=0;j<=K;j++) for(int k=0;k<=K;k++) for(int l=0;l<=K;l++) dp[s][j][k][l]=INF;\n        \n        for(int i=1;i<=N;i++){\n            rui[i]=rui[i-1];\n            if(S[i-1]==\'(\') rui[i]++;\n            if(S[i-1]==\')\') rui[i]--;\n        }\n        \n        dp[0][0][0][0]=0;\n        \n        for(int i=0;i<=N;i++){\n            int s=i&1,t=s^1;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        if(dp[s][al][a][b]==INF) continue;\n                        ll d=rui[i]-a+b;\n                        if(i<N){\n                            chmin(dp[t][al+1][a+(S[i]==\'(\')][b+(S[i]==\')\')],dp[s][al][a][b]);\n                            if(S[i]==\'(\'){\n                                chmin(dp[t][al][a][b],dp[s][al][a][b]+d);\n                            }\n                            if(S[i]==\')\'){\n                                if(d>=1) chmin(dp[t][al][a][b],dp[s][al][a][b]);\n                            }\n                        }\n                        \n                        if(a){\n                            chmin(dp[s][al][a-1][b],dp[s][al][a][b]+d);\n                        }\n                        if(b&&d>=1){\n                            chmin(dp[s][al][a][b-1],dp[s][al][a][b]);\n                        }\n                    }\n                }\n            }\n            if(i==N) break;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        dp[s][al][a][b]=INF;\n                    }\n                }\n            }\n        }\n        \n        ll ans=INF;\n        \n        for(int al=0;al<=K;al++){\n            chmin(ans,dp[N&1][al][0][0]);\n        }\n        \n        cout<<ans<<""\\n"";\n    }\n}\n']",,,"['brute force', 'dp', 'greedy', 'sortings', 'strings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Rearrange Brackets.json,https://codeforces.com//blog/entry/115296,First let s define the cost of an RBS a bit clearer The absolute smallest cost of removing each pair of brackets is the number of bracket pairs it s inside of That can actually be achieved just remove the pairs right to left according to the positions of the opening brackets in pairs So you can instead say that the total cost is the sum of balance values after all closing brackets Or before all opening brackets these are actually the same From that we can code a classic dp Imagine we are not moving brackets but instead doing that in two separate movements put a bracket in some buffer and place it in the string We d love to use the smallest answer if we processed brackets opening brackets are in the buffer closing brackets in the buffer and are performed Sadly that doesn t really allow moving brackets to the left since you would have to first place the bracket then put in it the buffer Does that actually break anything Apparently no You can make these buffer states from to and think of negative values as taking a loan These states are enough to determine the current balance of the string Thus enough to both update the states and check if the string stops being an RBS after placing a closing bracket Overall complexity We can do it faster but our proof isn t that convincing Start by showing that there exists an optimal answer such that each move leaves the sequence an RBS Consider a sequence of moves that ends up being an RBS First you can basically rearrange the moves maybe adjusting the exact positions is required Second there exists a move that performed first leaves an RBS Make it and propagate the proof You can show that such a move exists by studying some cases Then I found it more intuitive to switch to another representation you can look at the forest induced by the bracket sequence The roots of the trees in it are the topmost opening and closing brackets of the RBS Their children are the inner topmost brackets for each of them and so on With that representation the answer is actually the sum of depths of all vertices Now for the moves Let s move an opening bracket to the right We won t move it after its corresponding closing bracket to not break an RBS How will it change the tree It will turn some children of the corresponding vertex into the children of its parent Thus it will decrease their depths by one and the depths of their descendants as well How about to the left That will turn some children of its parent into its own children increasing their depths and the depths of their descendants by one Similar analysis can be performed for the closing brackets The claim is that in the optimal answer you should only move opening brackets and only to the right Then they decrease the answer independently of each other It s pretty clear that the best position to move each bracket to is as much to the right as possible place it next to its respective closing bracket That will decrease the answer by the size of the subtree excluding the vertex itself Finally we want to choose vertices that have the largest sum of their subtrees That can be just done greedily pick largest ones You don t have to build the tree explicitly for that the size of the subtree is half of the number of brackets between an opening bracket and a corresponding closing one So everything can be processed with a stack Overall complexity or 
https://codeforces.com//contest/132/problem/C,708,C,132C,132,C. Logo Turtle,A lot of people associate Logo programming language with turtle graphics In this case the turtle moves along the straight line and accepts commands turn around and move 1 unit forward You are given a list of commands that will be given to the turtle You have to change exactly commands from the list one command can be changed several times How far from the starting point can the turtle move after it follows the commands of the modified list ,"['#pragma comment(linker, ""/STACK:65777216"")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nstring s;\nint n;\nint best = 0;\n\nint a[111][55][211][3];\nvoid go(int pos,int change,int x,int dx){\n\tif(a[pos][change][x+100][dx+1]) return;\n\ta[pos][change][x+100][dx+1]=1;\n\tif(pos==s.size()){\n\t\tif(change==0) best = max(best, abs(x));\n\t\treturn;\n\t}\n\tREP(i,change+1){\n\t\tint val = (s[pos]==\'F\');\n\t\tif(i%2) val^=1;\n\n\t\tgo(pos+1,change-i,x+(val==1?dx:0),dx*(val==0?-1:1));\n\t}\n}\n\nint main(){\n#ifdef LocalHost\n\n    freopen(""input.txt"",""r"",stdin);\n//  freopen(""output.txt"",""w"",stdout);\n#endif\n\t\n\tcin>>s>>n;\n\tgo(0,n,0,1);\n\tcout<<best<<endl;\n \n#ifdef LocalHost\n    cout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']",,,['dp'],1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Logo Turtle.json,https://codeforces.com//blog/entry/3302,This was the only problem of the round which featured a non esoteric language The solution is dynamic programming and it could be used in several ways My solution was to store two three dimensional arrays the leftmost and the rightmost position of a turtle after it used I commands from the list made J changes in these commands and is now facing direction K The initial condition is that left right 0 when I J 0 and the turtle faces right the initial direction can be chosen arbitrarily The rule of moving between states is if currently executed command is T either it is the current command of the list and no change is done or it is a result of a change the coordinate stays the same and the direction changes otherwise the direction stays the same and the coordinate changes accordingly to the direction It s convenient to do at most one change for each command in this case after all the arrays are calculated one has to take the maximal absolute value among all distances which use all commands from the list all facing directions of the turtle and all quantities of changes which have the same parity as the required quantity any command can be changed an even number of times without affecting the result 
https://codeforces.com//contest/1007/problem/A,197246,A,1007A,1007,A. Reorder the Array,You are given an array of integers Vasya can permute change order its integers He wants to do it so that as many as possible integers will become on a place where a smaller integer used to stand Help Vasya find the maximal number of such integers For instance if we are given an array 10 20 30 40 we can permute it so that it becomes 20 40 10 30 Then on the first and the second positions the integers became larger 20 10 40 20 and did not on the third and the fourth so for this permutation the number that Vasya wants to maximize equals 2 Read the note for the first example there is one more demonstrative test case Help Vasya to permute integers in such way that the number of positions in a new array where integers are greater than in the original one is maximal ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << ""["";\n    for (auto p: v) cout << p << "", "";\n    cout << ""]"";\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    int n;\n    cin >> n;\n    V<int> v(n);\n    for (int i = 0; i < n; i++) cin >> v[i];\n    sort(begin(v), end(v));\n    V<int> w = v;\n\n    int ans = 0;\n    while (v.size()) {\n        int d = v.back(); v.pop_back();\n        while (w.size() && w.back() >= d) w.pop_back();\n        if (!w.size()) break;\n        ans++;\n        w.pop_back();\n    }\n    cout << ans << endl;\n    return 0;\n}\n']",,,"['combinatorics', 'data structures', 'math', 'sortings', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Reorder the Array.json,https://codeforces.com//blog/entry/60572,The answer is minus maximal number of equal elements Let the maximal number of equals be Let s proove that is reachable It s clear that for every permutation of the array the answer will be the same so let s sort the array in non decreasing order Now we should just make a left shift on After it the right elements will move to a position of a smaller element Now let s proove that the answer is no more than Let s consider some permutation It s known that every permutation breaks into cycles Let s look at two occurences of the same number in the same cycle Then there is at least one number between them which will move on a postion of a non smaller element Even if it the same occurence and even if the length of the cycle is we can say that for every occurence of this number there is at least one number which moves on a postion of a non smaller one So if some number occurs times there are at least bad positions and therefore no more than good positions To count the number of equals you can for instance use 
https://codeforces.com//contest/1709/problem/A,1473244,A,1709A,1709,A. Three Doors,There are three doors in front of you numbered from 1 to 3 from left to right Each door has a lock on it which can only be opened with a key with the same number on it as the number on the door There are three keys one for each door Two of them are hidden behind the doors so that there is no more than one key behind each door So two doors have one key behind them one door doesn t have a key behind it To obtain a key hidden behind a door you should first unlock that door The remaining key is in your hands Can you open all the doors ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nint a[5];\n\nvoid solve() {\n\teprintf(""solve\\n"");\n\tfor (int i = 0; i < 4; i++)\n\t\tscanf(""%d"", &a[i]);\n\tint p = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tp = a[p];\n\t\teprintf(""%d\\n"", p);\n\t\tif (p == 0) {\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']",,,"['brute force', 'greedy', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Three Doors.json,https://codeforces.com//blog/entry/105164,Note that we never have a choice in what door should we open First we open the door with the same number as the key in our hand Then the door with the same number as the key behind the first opened door Finally the door with the same number as the key behind the second opened door If any of the first and second opened doors didn t have a key behind it then it s impossible Otherwise we open every door Let be the keys behind the corresponding doors Then we should check if is not zero and is not zero Overall complexity per testcase 
https://codeforces.com//contest/1656/problem/B,1341205,B,1656B,1656,B. Subtract Operation,You are given a list of n integers You can perform the following operation you choose an element x from the list erase x from the list and subtract the value of x from all the remaining elements Thus in one operation the length of the list is decreased by exactly 1 Given an integer k k 0 find if there is some sequence of n 1 operations such that after applying the operations the only remaining element of the list is equal to k ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::set s(a.begin(), a.end());\n    for (int i = 0; i < n; i++) {\n        if (s.count(a[i] + k)) {\n            std::cout << ""YES\\n"";\n            \n            return;\n        }\n    }\n    \n    std::cout << ""NO\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['data structures', 'greedy', 'math', 'two pointers']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Subtract Operation.json,https://codeforces.com//blog/entry/101211,Note that after deleting element all numbers in the set are of the form since the previous substractions are cancelled Therefore the final element will be the difference between the last element and the previous element which was erased So we just need to check if is the difference of two elements in the set which can be done by sorting and using the double pointer technique in time 
https://codeforces.com//contest/794/problem/A,106230,A,794A,794,A. Bank Robbery,A robber has attempted to rob a bank but failed to complete his task However he had managed to open all the safes Oleg the bank client loves money who doesn t and decides to take advantage of this failed robbery and steal some money from the safes There are many safes arranged in a line where the th safe from the left is called safe There are banknotes left in all the safes in total The th banknote is in safe Oleg is now at safe There are two security guards one of which guards the safe such that i e the first guard is to the left of Oleg The other guard guards the safe so that i e he is to the right of Oleg The two guards are very lazy so they do not move In every second Oleg can either take all the banknotes from the current safe or move to any of the neighboring safes However he cannot visit any safe that is guarded by security guards at any time becaues he might be charged for stealing Determine the maximum amount of banknotes Oleg can gather ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\t\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tint n, ans = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif ((x > b) && (x < c)) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. Bank Robbery.json,https://codeforces.com/blog/entry/51962,This is a simple implementation problem We iterate through all banknotes one by one and check if Oleg can take each of them If a banknote is at position x then Oleg can take it if and only if b x c This can be checked in O 1 time Thus the total complexity is O n Note that the information on the starting position of Oleg is useless here 
https://codeforces.com//contest/1588/problem/E,1186194,E,1588E,1588,E. Eligible Segments,You are given n points p 1 p 2 ldots p n on the plane and a positive integer R Find the number of pairs of indices i j such that 1 le i j le n and for every possible k 1 le k le n the distance from the point p k to the between points p i and p j is at most R ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing real_t = long double;\nusing pi = pair<real_t, real_t>;\nconst int MAXN = 3005;\nconst real_t PI = acos(-1.0L);\nconst real_t eps = 1e-8L;\n\nbool go[MAXN][MAXN];\nint n, d;\n\ncomplex<real_t> a[MAXN];\n\nreal_t norm(real_t x){\n\treturn fmod(x + 4 * PI, 2 * PI);\n}\n\n// it is quite similar to NEERC 2015 northern kingdom trip\n\nint main(){\n\tcin >> n >> d;\n\tfor(int i=0; i<n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = complex<real_t>(x, y);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tpi rng(-1e9, 1e9);\n\t\treal_t rot;\n\t\tbool fucked = 0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(rng.first < -1e8){\n\t\t\t\tif(abs(a[j] - a[i]) <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trot = PI - arg(a[j] - a[i]);\n\t\t\t}\n\t\t\tauto dir = norm(arg(a[j] - a[i]) + rot);\n\t\t\tauto dist = abs(a[j] - a[i]);\n\t\t\tif(dist <= d) continue;\n\t\t\tauto ang = asin(d / dist);\n\t\t\tauto bound_l = norm(dir - ang);\n\t\t\tauto bound_r = norm(dir + ang);\n\t\t\tif(bound_l > bound_r){\n\t\t\t\tif(bound_l < rng.second){\n\t\t\t\t\trng.first = max(rng.first, bound_l);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trng.second = min(rng.second, bound_r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trng.first = max(rng.first, bound_l);\n\t\t\t\trng.second = min(rng.second, bound_r);\n\t\t\t}\n\t\t\tif(rng.first > rng.second ){\n\t\t\t\tfucked = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fucked) continue;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(rng.first < -1e8){\n\t\t\t\tauto dist = abs(a[j] - a[i]);\n\t\t\t\tassert(dist <= d);\n\t\t\t\tgo[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto dir = norm(arg(a[j] - a[i]) + rot);\n\t\t\tif(rng.first <= dir && dir <= rng.second){\n\t\t\t\tgo[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(go[i][j] && go[j][i]) ret++;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n']",,,"['geometry', 'two pointers']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Eligible Segments.json,https://codeforces.com//blog/entry/96953,The distance from point P to segment AB is equal to the maximum of the distance from point P to ray AB and the distance from point P to ray BA Let s fix a point Pi Now we have to find all points Pj such that distance from every point Pk 1 k n to the ray Pi Pj is less than R For every point Pk let s build two tangents from point Pi to the circle with the center in the point Pk and radius R These tangents form an angle Ak The distance from the point Pk 1 k n to the ray Pi Pj is less than R iff the ray Pi Pj lies inside the angle Ak So we can build all these angles Ak and intersect them after that we only have to check that the ray Pi Pj lies inside the intersection of all angles for all 1 j n 
https://codeforces.com//contest/1854/problem/C,2119348,C,1854C,1854,C. Expected Destruction,You have a set S of n distinct integers between 1 and m Each second you do the following steps Pick an element x in S uniformly at random Remove x from S If x 1 leq m and x 1 is not in S add x 1 to S What is the expected number of seconds until S is empty Output the answer modulo 1 000 000 007 Formally let P 1 000 000 007 It can be shown that the answer can be expressed as an irreducible fraction frac a b where a and b are integers and b not equiv 0 pmod P Output the integer equal to a cdot b 1 bmod P In other words output an integer z such that 0 le z P and z cdot b equiv a pmod P ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst ll mod=1000*1000*1000+7;\nconst ll o2=(mod+1)/2;\n\nll inv(ll v)\n{\n\tif (v<=1)\n\t\treturn v;\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nint n, m;\n\nint tab[nax];\n\nll dp[nax][nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tfor (int j=0; j<i; j++)\n\t\t{\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tdp[i][j]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=(dp[i-1][j]+1+dp[i][j-1])*o2%mod;\n\t\t\t}\n\t\t}\n\t}\n\tll wyn=m+1-tab[n];\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a=m+1-tab[i];\n\t\tint b=m+1-tab[i+1];\n\t\twyn+=dp[a][b];\n\t}\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'math', 'probabilities']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Expected Destruction.json,https://codeforces.com//blog/entry/118540,Solution Consider an grid where the th row initially contains a block in column and row contains a block in column The set is empty if all the blocks are in column i e if every block has reached the block in the following row Every connected component of blocks except the last one represents an element in the set These components move equiprobably Let s calculate the expected time required for the block in row to reach the block in row If you consider a single pair of blocks every block moves with probability unless block is in column So you can calculate expected number of moves of the block before it reaches the block if the block is in position and the block is in position The base cases are because only the block can move and because block has already reached block In the other cases By linearity of expectation the answer is the sum of Complexity 
https://codeforces.com//contest/840/problem/E,118960,E,840E,840,E. In a Trap,Lech got into a tree consisting of vertices with a root in vertex number At each vertex written integer He will not get out until he answers queries of the form Answer for the query is maximal value among all vertices on path from to including and where is number of edges on path from to Also guaranteed that vertex is ancestor of vertex Leha s tastes are very singular he believes that vertex is ancestor of itself Help Leha to get out The expression means the bitwise exclusive to the numbers and Note that vertex is ancestor of vertex if vertex lies on the path from root to the vertex ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct HLD {\n\tvector<vi> paths;\n\tvector<pair<int, int> > pathParent;\n\tvector<pair<int, int> > nodePos;\n\tvector<int> nodeDepth;\n\n\tvoid build(const vector<vi> &g, int root) {\n\t\tint N = g.size();\n\t\tvector<int> t_ord, t_parent(N, -1);\n\t\tnodeDepth.assign(N, 0);\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tstk.push_back(root);\n\t\t\twhile (!stk.empty()) {\n\t\t\t\tint i = stk.back();\n\t\t\t\tstk.pop_back();\n\t\t\t\tt_ord.push_back(i);\n\t\t\t\tfor (int j : g[i]) if (j != root && t_parent[j] == -1) {\n\t\t\t\t\tt_parent[j] = i;\n\t\t\t\t\tnodeDepth[j] = nodeDepth[i] + 1;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> subtsize(N, 1);\n\t\tfor (int ix = N - 1; ix > 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tsubtsize[p] += subtsize[i];\n\t\t}\n\t\tpaths.clear();\n\t\tpaths.push_back(vi());\n\t\tpathParent.emplace_back(-1, 0);\n\t\tdfs(root, -1, g, subtsize);\n\t\tassert(paths.back().empty());\n\t\tpaths.pop_back();\n\t\tassert(paths.size() == pathParent.size());\n\n\t\tnodePos.assign(N, { -1, -1 });\n\t\trep(c, paths.size()) rep(p, paths[c].size())\n\t\t\tnodePos[paths[c][p]] = { c, p };\n\t}\n\n\tvoid get(int u, int &c, int &p) const {\n\t\ttie(c, p) = nodePos[u];\n\t}\n\n\tbool go_up(int &c, int &p) const {\n\t\ttie(c, p) = pathParent[c];\n\t\treturn c != -1;\n\t}\n\n\ttypedef tuple<int, int, int> SubPath;\n\n\tvoid getPath1(int u, int v, vector<SubPath> &path) const {\n\t\tpath.clear();\n\t\tint uc, up, vc, vp;\n\t\tget(u, uc, up);\n\t\tget(v, vc, vp);\n\t\twhile (uc != vc) {\n\t\t\tpath.emplace_back(vc, 0, vp + 1);\n\t\t\tgo_up(vc, vp);\n\t\t}\n\t\tpath.emplace_back(vc, up, vp + 1);\n\t}\n\nprivate:\n\tvoid dfs(int i, int p, const vector<vi> &g, const vector<int> &subtsize) {\n\t\tint color = (int)paths.size() - 1;\n\t\tint pos = paths.back().size();\n\t\tpaths.back().push_back(i);\n\n\t\tint c = -1;\n\t\tfor (int j : g[i]) if (j != p) {\n\t\t\tif (c == -1 || subtsize[c] < subtsize[j])\n\t\t\t\tc = j;\n\t\t}\n\n\t\tif (c == -1) {\n\t\t\tpaths.push_back(vi());\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(c, i, g, subtsize);\n\n\t\tfor (int j : g[i]) if (j != p && j != c) {\n\t\t\tpathParent.emplace_back(color, pos);\n\t\t\tdfs(j, i, g, subtsize);\n\t\t}\n\t}\n};\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(""%d%d"", &n, &q)) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &a[i]);\n\t\tvector<vector<int> > g(n);\n\t\tfor (int i = 0; i < n - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(""%d%d"", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tHLD hld;\n\t\thld.build(g, 0);\n\t\tmap<pii, int> memo;\n\t\tvector<tuple<int, int, int>> path;\n\t\tvector<int> offsets(hld.paths.size() + 1);\n\t\tconst int W = 8;\n\t\trep(i, hld.paths.size())\n\t\t\toffsets[i + 1] = offsets[i] + (hld.paths[i].size() / W + 1) * W;\n\t\tvector<uint16_t> values(offsets.back());\n\t\trep(i, hld.paths.size()) rep(j, hld.paths[i].size())\n\t\t\tvalues[offsets[i] + j] = a[hld.paths[i][hld.paths[i].size() - 1 - j]];\n\t\tll anssum = 0;\n\t\trep(ii, q) {\n\t\t\tint u; int v;\n\t\t\tscanf(""%d%d"", &u, &v), -- u, -- v;\n\t\t\tauto &ans = memo.emplace(make_pair(make_pair(u, v), -1)).first->second;\n\t\t\tif (ans != -1) {\n\t\t\t\tprintf(""%d\\n"", ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thld.getPath1(u, v, path);\n\t\t\tint add = 0;\n\t\t\tint maxi = 0;\n\t\t\tfor (auto t : path) {\n\t\t\t\tint c, L, R;\n\t\t\t\ttie(c, L, R) = t;\n\t\t\t\tauto x = values.data() + offsets[c] + (hld.paths[c].size() - R);\n\t\t\t\tint len = R - L;\n\t\t\t\tfor (int i = 0; i < len; ++ i)\n\t\t\t\t\tamax(maxi, x[i] ^ (add + i));\n\t\t\t\tadd += len;\n\t\t\t}\n\t\t\tans = maxi;\n\t\t\tprintf(""%d\\n"", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n']",,,['trees'],3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. In a Trap.json,https://codeforces.com//blog/entry/53943?locale=en,The path from u to v can be divided into blocks of 256 nodes and possibly a single block with less than 256 nodes We can consider this last block separately by iterating all of its nodes Now we need to deal with the blocks with length exactly 256 They are determined by two numbers x last node in the block and d 8 highest bits We can precalculate this values and then use them to answer the queries Let s now talk about precalculating answer x d Let s fix x and 255 nodes after x It s easy to notice that lowest 8 bits will always be as following 0 1 255 We can xor this values 0 with ax 1 with anextx and so on and store the results in a trie Now we can iterate all possible values of d from 0 to 255 and the only thing left is to find a number stored in a trie say q such that q xor 255 d is maximized 
https://codeforces.com//contest/585/problem/A,37964,A,585A,585,A. Gennady the Dentist,Gennady is one of the best child dentists in Berland Today children got an appointment with him they lined up in front of his office All children love to cry loudly at the reception at the dentist We enumerate the children with integers from to in the order they go in the line Every child is associated with the value of his The children take turns one after another to come into the office each time the child that is the first in the line goes to the doctor While Gennady treats the teeth of the th child the child is crying with the volume of At that the of the first child in the line is reduced by the amount of the second one by value and so on The children in the queue after the th child almost do not hear the crying so their remains unchanged If at any point in time the of the th child is less than zero he begins to cry with the volume of and leaves the line running towards the exit without going to the doctor s office At this the of all the children after the th one in the line is reduced by the amount of All these events occur immediately one after the other in some order Some cries may lead to other cries causing a chain reaction Once in the hallway it is quiet the child who is first in the line goes into the doctor s office Help Gennady the Dentist to determine the numbers of kids whose teeth he will cure Print their numbers in the chronological order ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 4040;\nint n;\nint m;\nint v[N], d[N], p[N];\nint ans[N];\nbool used[N];\nint q[N];\nint topQ;\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n        scanf(""%d%d%d"", &v[i], &d[i], &p[i]);\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (used[i]) continue;\n        ans[m++] = i + 1;\n        int r = v[i];\n        for (int j = i + 1; j < n && r > 0; j++)\n        {\n            if (used[j]) continue;\n            p[j] -= r;\n            if (p[j] < 0)\n            {\n                used[j] = 1;\n                q[topQ++] = j;\n            }\n            r--;\n        }\n        while(k < topQ)\n        {\n            int v = q[k++];\n            for (int j = v + 1; j < n; j++)\n            {\n                if (used[j]) continue;\n                p[j] -= d[v];\n                if (p[j] < 0)\n                {\n                    used[j] = 1;\n                    q[topQ++] = j;\n                }\n            }\n        }\n    }\n    printf(""%d\\n"", m);\n    for (int i = 0; i < m; i++)\n        printf(""%d "", ans[i]);\n\n    return 0;\n}']",,,"['brute force', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Gennady the Dentist.json,https://codeforces.com//blog/entry/20898, Let s store for each child his current confidence value and a boolean indicating whether child had left the queue or visited the dentist office or not Then one could easily process children one by one considering only children who still are in the queue using boolean array and changing stored values Such solution has complexity and requires author s attention much especially the case with possible confidence value overflowing Of course there are much faster solutions not required in our case 
https://codeforces.com//contest/1102/problem/C,280229,C,1102C,1102,C. Doors Breaking and Repairing,You are policeman and you are playing a game with Slavik The game is turn based and each turn consists of two phases During the first phase you make your move and during the second phase Slavik makes his move There are n doors the i th door initially has durability equal to a i During your move you can try to break one of the doors If you choose door i and its current durability is b i then you reduce its durability to max 0 b i x the value x is given During Slavik s move he tries to repair one of the doors If he chooses door i and its current durability is b i then he increases its durability to b i y the value y is given The game lasts 10 100 turns If some player cannot make his move then he has to skip it Your goal is to maximize the number of doors with durability equal to 0 at the end of the game You can assume that Slavik the number of such doors What is the number of such doors in the end if you both play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n,x,y;\nvector<int>v;\nint main(){\n// \tfreopen(""input.txt"",""r"",stdin);\n\tscanf(""%d%d%d"",&n,&x,&y);\n\tif(x > y)return cout << n << endl,0;\n\tfor(int i = 0,a;i < n;i++){\n\t\tscanf(""%d"",&a);\n\t\tif(a <= x)v.push_back(a);\n\t}\n\tcout << (v.size() + 1)/2;\n}']",,,['games'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Doors Breaking and Repairing.json,https://codeforces.com//blog/entry/64439,Let s consider two cases If then the answer is because we can make opposite moves to the Slavik s moves and it always will reduce durability of some door so at some point we will reach the state when all doors will have durability Otherwise and we have to realize the optimal strategy for us If we have some door with durability then let s break it immediately why shouldn t we do this If we don t do it then Slavik will repair this door during his move So what Slavik will do now He will repair some door Which door he has to repair Of course the one with durability because otherwise we will break it during our next move So we can realize that doors with durability are not interesting for us because Slavik will make opposite moves to our moves And what is the answer if the number of doors with durability equals to It is 
https://codeforces.com//contest/468/problem/B,13935,B,468B,468,B. Two Sets,Little X has distinct integers He wants to divide all of them into two sets and The following two conditions must be satisfied If number belongs to set then number must also belong to set If number belongs to set then number must also belong to set Help Little X divide the numbers into two sets or determine that it s impossible ,"['//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""[""#x""] Time : %.3lf s.\\n"", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(""["" x ""] Time : %.3lf s.\\n"", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""B""\n\n#ifdef LOCAL\nstatic struct __timestamper {\n    string what;\n    __timestamper(const char* what) : what(what){};\n    __timestamper(const string& what) : what(what){};\n    ~__timestamper(){\n        TIMESTAMPf(""%s"", what.data());\n    }\n} __TIMESTAMPER(""end"");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\n\nconst int MAXN = 110000;\nint p[MAXN];\nint can[2][MAXN];\n\nint get(int a) {\n    if (a == p[a]) return a;\n    return p[a] = get(p[a]);\n}\n\n\nvoid join(int a, int b) {\n    a = get(a);\n    b = get(b);\n    p[a] = b;\n    can[0][b] &= can[0][a];\n    can[1][b] &= can[1][a];\n}\n\n\nint main(){\n  #ifdef LOCAL\n    assert(freopen(TASKNAME"".in"",""r"",stdin));\n    assert(freopen(TASKNAME"".out"",""w"",stdout));\n  #endif\n    int n, a, b;\n    scanf(""%d%d%d"",&n,&a,&b);\n    vector<pair<int,int>> v(n);\n    for (int i = 0; i < (int)v.size(); i++) \n        scanf(""%d"",&v[i].first), v[i].second = i;\n\n    for (int i = 0; i < n; i++)\n        p[i] = i, can[0][i] = can[1][i] = 1;\n\n    sort(v.begin(), v.end());\n\n    for (int i = 0; i < (int)v.size(); i++) {\n        int x = v[i].first;\n        {\n        int id = lower_bound(v.begin(), v.end(), mp(a - x, -1)) - v.begin();\n        if (id < (int)v.size() && v[id].first == a - x)\n            join(v[i].second, v[id].second);\n        else\n            can[0][get(v[i].second)] = 0;\n        }\n        {\n        int id = lower_bound(v.begin(), v.end(), mp(b - x, -1))  - v.begin();\n        if (id < (int)v.size() && v[id].first == b - x)\n            join(v[i].second, v[id].second);\n        else\n            can[1][get(v[i].second)] = 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n        if (!can[0][i] && !can[1][i] && p[i] == i) {\n            printf(""NO\\n"");\n            return 0;\n        }\n\n    printf(""YES\\n"");\n    for (int i = 0; i < n; i++)\n        printf(""%d%c"", can[1][get(i)], "" \\n""[i==n-1]);\n\n      \n    return 0;\n}']",,,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Two Sets.json,https://codeforces.com/blog/entry/13896,Solution 1 If we have number and they should be in the same set If it s obvious that The contraposition of it is that means if should in the set Same as the number So we can use Disjoint Set Union to merge the number that should be in the same set If doesn t exist can not be in the set If doesn t exist can not be in the set Then check if there are any conflicts among numbers which should be in the same set There are many other solutions to solve this problem based on the fact that should be in the same set like greedy BFS and 2 SAT 7894313 Solution 2 If it s easy to find the solution We regards every number as a node Every number links to number and number The degree of every node is at most So this graph consists of a lot of chains and cycles and some node may have self loop We only need to check if the lengths of all the chains are even or the chain ends with a self loop 7894323 Bonus Prove there is no cycle in the graph described in the solution 2 Divided all the numbers from into two sets that have parameters Can you solved it in 
https://codeforces.com//contest/1088/problem/B,265512,B,1088B,1088,B. Ehab and subtraction,You re given an array a You should repeat the following operation k times find the minimum non zero element in the array print it and then subtract it from all the non zero elements of the array If all the elements are 0s just print 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define _ << "" _ "" <<\n#define TRACE(x) cout << #x << "" = "" << x << endl\n\ntypedef long long ll;\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, k;\n    ll a[100010];\n    ll sum = 0;\n\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n\n    int t = 0;\n\n    for (int i = 0; i < k; i++) {\n        while (t < n && a[t] == sum) t++;\n        if (t == n) cout << ""0\\n"";\n        else {\n            cout << a[t] - sum << ""\\n"";\n            sum = a[t];\n        }\n    }\n\n\n\n\n    \n\n    return 0;\n}\n\n']",,,"['implementation', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Ehab and subtraction.json,https://codeforces.com//blog/entry/63656,Let be the set of numbers in input sorted and distinct In the step is subtracted from all bigger or equal elements and all smaller elements are 0 Thus the answer in the step is Code link https pastebin com bpz1YxBe Time complexity 
https://codeforces.com//contest/1889/problem/A,2253918,A,1889A,1889,A. Qingshan Loves Strings 2,Qingshan has a string s which only contains texttt 0 and texttt 1 A string a of length k is good if and only if a i ne a k i 1 for all i 1 2 ldots k For example texttt 10 texttt 1010 texttt 111000 are good while texttt 11 texttt 101 texttt 001 texttt 001100 are not good Qingshan wants to make s good To do this she can do the following operation 300 times possibly zero insert texttt 01 to any position of s getting a new s Please tell Qingshan if it is possible to make s good If it is possible print a sequence of operations that makes s good ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tdef(int, N);\n\tstr S;\n\tre(S);\n\tif (count(all(S), \'1\') != count(all(S), \'0\')) {\n\t\tps(-1);\n\t\treturn;\n\t}\n\n\tvi ans;\n\tauto mov = [&](int x) {\n\t\tassert(0 <= x && x <= sz(S));\n\t\tS.ins(begin(S) + x, \'1\');\n\t\tS.ins(begin(S) + x, \'0\');\n\t\tans.pb(x);\n\t};\n\twhile (true) {\n\t\tint i = 0;\n\t\twhile (i < sz(S) - 1 - i && S.at(i) != S.at(sz(S) - 1 - i)) ++i;\n\t\tif (i > sz(S) - 1 - i) break;\n\t\tif (S[i] == \'1\') {\n\t\t\tmov(i);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tmov(sz(S) - i);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tps(sz(ans));\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']",,,"['constructive algorithms', 'greedy', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Qingshan Loves Strings 2.json,https://codeforces.com//blog/entry/121813,First there is no solution when the number of s and s are different Otherwise the construction follows If the now we can ignore and and consider as a new If is empty the algorithm ends Now If they are insert to the front otherwise insert to the end Look at this example This operation is actually equivalent to moving the last to the front or moving the first to the end For example in step 2 to 4 above we succeed moving the last to the front So in the worst case every character in the string are moved and we need moves Actually we don t need moves but moves Because for the and deleted in the same operation at most one of them need to be moved Time complexity 
https://codeforces.com//contest/897/problem/A,137064,A,897A,897,A. Scarborough Fair,Willem is taking the girl to the highest building in island No 28 however neither of them knows how to get there Willem asks his friend Grick for directions Grick helped them and gave them a task Although the girl wants to help Willem insists on doing it by himself Grick gave Willem a string of length Willem needs to do operations each operation has four parameters which means that all symbols in range from th to th including and are changed into String is 1 indexed Grick wants to know the final string after all the operations ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    string s;\n    int n, m, a, b;\n    char c1, c2;\n\n    cin >> n >> m;\n    cin >> s;\n\n    while (m--) {\n        cin >> a >> b >> c1 >> c2;\n        for (int i(a - 1); i <= b - 1; i++)\n            if (s[i] == c1)\n                s[i] = c2;\n    }\n\n    cout << s;\n\n    return 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Scarborough Fair.json,https://codeforces.com//blog/entry/56135,For every in range if is then change it into Because are all very small can easily pass it PS You can use binary search tree to solve it in time 
https://codeforces.com//contest/431/problem/C,9654,C,431C,431,C. k-Tree,Quite recently a creative student Lesha had a lecture on trees After the lecture Lesha was inspired and came up with the tree of his own which he called a tree A tree is an infinite rooted tree where each vertex has exactly children each edge has some weight if we look at the edges that goes from some vertex to its children exactly edges then their weights will equal The picture below shows a part of a 3 tree As soon as Dima a good friend of Lesha found out about the tree he immediately wondered How many paths of total weight the sum of all weights of the edges in the path are there starting from the root of a tree and also containing at least one edge of weight at least Help Dima find an answer to his question As the number of ways can be rather large print it modulo ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#define MASK 1000000007\nint n,k,d;\nlong long f1[200][200],f2[200][200],ans1=0,ans2=0;\nint main()\n{\n    scanf(""%d%d%d"",&n,&k,&d);\n    for(int i=1;i<=k;i++) f1[1][i]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int l=1;l<=std::min(j,k);l++) f1[i][j]=(f1[i][j]+f1[i-1][j-l])%MASK;\n        }\n    }\n    for(int i=1;i<d;i++) f2[1][i]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int l=1;l<=std::min(j,d-1);l++) f2[i][j]=(f2[i][j]+f2[i-1][j-l])%MASK;\n        }\n    }\n    for(int i=1;i<=n;i++) ans1=(ans1+f1[i][n])%MASK;\n    for(int i=1;i<=n;i++) ans2=(ans2+f2[i][n])%MASK;\n    printf(""%I64d\\n"",((ans1-ans2)%MASK+MASK)%MASK);\n    return 0;\n}\n']",,,"['dp', 'implementation', 'trees']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. k-Tree.json,https://codeforces.com//blog/entry/12369,This problem can be solved by dinamic programming Let s Dp n is number of ways with length equals to in k tree where if there is exists edge with length at least lengths of all edges less then Initial state Dp 0 0 1 Transition iterate all edges which can be first on the way in k tree then problem transform to the same but with less length of the way because subtree of vertex son is the k tree Dp n 0 Dp n 1 0 Dp n min d 1 n 0 Dp n 1 Dp n 1 1 Dp n min d 1 n 1 Dp n d 0 Dp n d 1 Dp n min n k 0 Dp n min n k 1 See solution for more details Complexity Notice that this solution can be easy midify to complexity only precalc partial sums But it is not neccesary to solve this problem in such way Solution 6676700 
https://codeforces.com//contest/167/problem/A,1060,A,167A,167,A. Wizards and Trolleybuses,In some country live wizards They love to ride trolleybuses A city in this country has a trolleybus depot with trolleybuses Every day the trolleybuses leave the depot one by one and go to the final station The final station is at a distance of meters from the depot We know for the th trolleybus that it leaves at the moment of time seconds can go at a speed of no greater than meters per second and accelerate with an acceleration no greater than meters per second squared A trolleybus can decelerate as quickly as you want magic It can change its acceleration as fast as you want as well Note that the maximum acceleration is the same for all trolleys Despite the magic the trolleys are still powered by an electric circuit and cannot overtake each other the wires are to blame of course If a trolleybus catches up with another one they go together one right after the other until they arrive at the final station Also the drivers are driving so as to arrive at the final station as quickly as possible You as head of the trolleybuses fans club are to determine for each trolley the minimum time by which it can reach the final station At the time of arrival at the destination station the trolleybus does not necessarily have zero speed When a trolley is leaving the depot its speed is considered equal to zero From the point of view of physics the trolleybuses can be considered as material points and also we should ignore the impact on the speed of a trolley bus by everything except for the acceleration and deceleration provided by the engine ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ndouble ans[100010];\n\ndouble func(double a, double d, double v){\n    if(d < v*v / 2.0 / a) return sqrt(2.0 * d / a);\n    return v / a + (d - v*v / 2.0 / a) / v;\n}\n\nint main(void){\n    int N,a,d,t,v,i;\n    \n    scanf(""%d%d%d"",&N,&a,&d);\n    REP(i,N){\n        scanf(""%d%d"",&t,&v);\n        ans[i] = t + func(a,d,v);\n    }\n    \n    REP(i,N-1) ans[i+1] = max(ans[i+1],ans[i]);\n    REP(i,N) printf(""%.9f\\n"",ans[i]);\n    \n    return 0;\n}\n']",,,"['implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Wizards and Trolleybuses.json,https://codeforces.com//blog/entry/4214,This was the first problem where you had a little bit away from translating statements to a programming language Because acceleration trolleybuses are all the same and they can slow down immediately the answer for the next trolleybus is the maximum of the time when it would come if it were not to stop when he reach the rest trolleybuses which was traveling in front of him and the arrival time of the previous trolleybus It remains only to calculate the arrival time of each trolleybus if ignore others Here the easiest way to analyze two cases If then trolley should accelerate as long as it can and the answer is equal to Otherwise the trolley should accelerate all the time and the answer is equal to 
https://codeforces.com//contest/702/problem/E,66882,E,702E,702,E. Analysis of Pathes in Functional Graph,You are given a It is a directed graph in which from each vertex goes exactly one arc The vertices are numerated from to Graph is given as the array where the number of vertex to which goes the only arc from the vertex Besides you are given array with weights of the arcs where the arc weight from to Also you are given the integer the length of the path and you need to find for each vertex two numbers and where the sum of the weights of all arcs of the path with length equals to which starts from the vertex the minimal weight from all arcs on the path with length which starts from the vertex The length of the path is the number of arcs on this path ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll K;\nint F[101010][41];\nll W[101010][41];\nll S[101010][41];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tFOR(i,N) cin>>F[i][0];\n\tFOR(i,N) cin>>W[i][0], S[i][0]=W[i][0];\n\t\n\tFOR(i,40) {\n\t\tFOR(x,N) F[x][i+1]=F[F[x][i]][i];\n\t\tFOR(x,N) W[x][i+1]=min(W[x][i],W[F[x][i]][i]);\n\t\tFOR(x,N) S[x][i+1]=S[x][i]+S[F[x][i]][i];\n\t}\n\t\n\tFOR(i,N) {\n\t\tll X=K;\n\t\tll mi=1LL<<40;\n\t\tll tot=0;\n\t\tint cur=i;\n\t\tFOR(j,40) if(X&(1LL<<j)) {\n\t\t\tmi=min(mi,W[cur][j]);\n\t\t\ttot+=S[cur][j];\n\t\t\tcur=F[cur][j];\n\t\t}\n\t\tcout<<tot<<"" ""<<mi<<endl;\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n']",,,"['data structures', 'graphs']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Analysis of Pathes in Functional Graph.json,https://codeforces.com//blog/entry/46324?locale=en,This problem can be solved with help of the binary exponentiation Let the is a structure which for the vertex store the information about the path from this vertex with length equals to The information which we need the number of vertex in which ends the path with length from the vertex the sum of the arcs weights on the path with length from the vertex the minimal weight of the arc on the path with length from the vertex So if we have this values for all vertices and two fixed values and it is easy to find the values for all i e at first we went to the vertex and then with help of the array we can undrstand where we will stand in the end of the path The structures for the values and are and arrays of the structures indexed with numbers of the graph vertices So we showed that if we have two arrays for and we can get the array for The operation which we described above we can call the multiply of the arrays then the needed values can be found with help of raised values to the power For make it we can use the binary exponentiation Also this problem can be solved with help of binary shifts but in fact it is the same thing that we described above 
https://codeforces.com//contest/1844/problem/A,2009571,A,1844A,1844,A. Subtraction Game,You are given two positive integers a and b a b For some positive integer n two players will play a game starting with a pile of n stones They take turns removing exactly a or exactly b stones from the pile The player who is unable to make a move loses Find a positive integer n such that the second player to move in this game has a winning strategy This means that no matter what moves the first player makes the second player can carefully choose their moves possibly depending on the first player s moves to ensure they win ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nvoid solve()\n{\n\tint a,b;read(a);read(b);\n\tprintf(""%d\\n"",a+b);\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']",,,"['constructive algorithms', 'games']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. Subtraction Game.json,https://codeforces.com//blog/entry/118128,We present two approaches If then works Else if and works Otherwise and so works Printing works because no matter what move the first player makes the second player can respond with the opposite move The time complexity is per test case 
https://codeforces.com//contest/1969/problem/C,2619519,C,1969C,1969,C. Minimizing the Sum,You are given an integer array a of length n You can perform the following operation choose an element of the array and replace it with any of its neighbor s value For example if a 3 1 2 you can get one of the arrays 3 3 2 3 2 2 and 1 1 2 using one operation but not 2 1 2 or 3 4 2 Your task is to calculate the minimum possible total sum of the array if you can perform the aforementioned operation at most k times ,"['#include ""bits/stdc++.h""#pragma GCC optimize (""O3"")#pragma GCC target (""sse4"") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\xa0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\xa0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}void __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}void __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}void __print(bool x) {cerr << (x ? ""true"" : ""false"");}\xa0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}template<typename T>void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}void _print() {cerr << ""]\\n"";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;#else#define dbg(x...)#endif\xa0\xa0const int MOD = 1000000007;const char nl = \'\\n\';const int MX = 100001; \xa0void solve() {    int N, K; cin >> N >> K;    ll dp[N+1][K+1]; F0R(i, N+1) F0R(j, K+1) dp[i][j] = 1e18;    dp[0][0] = 0;    ll A[N]; F0R(i, N) cin >> A[i];    F0R(i, N) {        F0R(j, K+1) {            ll cval = MOD;            F0R(k, min(N-i, K-j+1)) {                ckmin(cval, A[i+k]);                ckmin(dp[i+k+1][j+k], cval * (k+1) + dp[i][j]);            }        }    }\xa0    ll ans = 1e18; F0R(i, K+1) ckmin(ans, dp[N][i]);    cout << ans << nl;\xa0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\xa0    int T = 1;    cin >> T;    while(T--) {        solve();    }\xa0\treturn 0;}\xa0\xa0']",,,"['dp', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Minimizing the Sum.json,https://codeforces.com//blog/entry/129022,The small values of leads to the idea that expected solution is dynamic programming In fact we can actually design a dynamic programming solution Let be the minimum sum if we considered the first elements and already done operations Note that we can turn a segment of length into a minimum on it using operations So the transitions can be done by iterating over the length of the next segment denote it as and we can update with where is the minimum among that can be maintained in a single variable during iteration over There are states in the dynamic programming and transitions from each of them so the solution works in 
https://codeforces.com//contest/1883/problem/E,2278976,E,1883E,1883,E. Look Back,You are given an array of integers a 1 a 2 ldots a n You need to make it non decreasing with the minimum number of operations In one operation you do the following Choose an index 1 leq i leq n Set a i a i cdot 2 An array b 1 b 2 ldots b n is non decreasing if b i leq b i 1 for all 1 leq i n ,"['#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int tt;cin >> tt;\n    while(tt--){\n        int n;cin >> n;\n        vector<long long>v(n);\n        long long ans = 0,curr = 0;\n        for(int i = 0; i < n; i++){\n            cin >> v[i];\n            if(i){\n                int cnt = 0;\n                long long k = v[i];\n                while(v[i - 1] > k){\n                    k *= 2;\n                    cnt++;\n                }\n                while(v[i - 1]*2 <= k and curr){\n                    v[i - 1] *= 2;\n                    curr--;\n                }\n                curr = curr + cnt;\n                ans += curr;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n']",,,"['bitmasks', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Look Back.json,https://codeforces.com//blog/entry/121621,Let s come up with a naive solution we could go from left to right and multiply the element at index by until it is greater than or equal to the previous element But this solution will take a long time as the numbers can become on the order of during the operations Let s not explicitly multiply our numbers by but represent each element as the product where is the power to which we multiplied Let s say we have calculated the value of and now we want to calculate We have two cases If Then we can say that and subtract until and If Then we can say that and add until Note that we do not want to change the values of the array to avoid getting large numbers later so we use additional variables for this 
https://codeforces.com//contest/1883/problem/D,2278975,D,1883D,1883,D. In Love,Initially you have an empty multiset of segments You need to process q operations of two types l r Add the segment l r to the multiset l r Remove one segment l r from the multiset It is guaranteed that this segment exists in the multiset After each operation you need to determine if there exists a pair of segments in the multiset that do not intersect A pair of segments l r and a b do not intersect if there does not exist a point x such that l leq x leq r and a leq x leq b ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvoid solve()\n{\n    int n, l, r; cin>>n;\n    char c;\n\n    multiset<int> sts, ends;\n    while(n--)\n    {\n        cin>>c>>l>>r;\n        if(c == \'+\')sts.insert(l), ends.insert(r);\n        else sts.erase(sts.find(l)), ends.erase(ends.find(r));\n\n        if(ends.size() && *ends.begin() < *sts.rbegin())cout<<""YES\\n"";\n        else cout<<""NO\\n"";\n    }\n}\n\nsigned main()\n{\n    int t = 1;\n    while(t--)solve();\n}']",,,"['data structures', 'greedy']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. In Love.json,https://codeforces.com//blog/entry/121621,Let s learn how to solve the problem for a fixed set The claim is that if the answer exists we can take the segment with the minimum right boundary and the maximum left boundary let s denote these boundaries as and Therefore if it is obvious that this pair of segments is suitable for us Otherwise all pairs of segments intersect because they have common points in the range Now let s maintain all our operations For this we can simply store a multiset of left and right boundaries With the help of this multiset we can find the minimum and maximum elements of any of these sets in The addition and removal operations are also supported by this container 
https://codeforces.com//contest/812/problem/E,108006,E,812E,812,E. Sagheer and Apple Tree,Sagheer is playing a game with his best friend Soliman He brought a tree with nodes numbered from to and rooted at node The th node has apples This tree has a special property the lengths of all paths from the root to any leaf have the same parity i e all paths have even length or all paths have odd length Sagheer and Soliman will take turns to play Soliman will make the first move The player who can t make a move loses In each move the current player will pick a single node take a non empty subset of apples from it and do one of the following two things eat the apples if the node is a leaf move the apples to one of the children if the node is non leaf Before Soliman comes to start playing Sagheer will make to the tree He will pick two different nodes and and swap the apples of with the apples of Can you help Sagheer count the number of ways to make the swap i e to choose and after which he will win the game if both players play optimally and are considered to be the same pair ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#if __cplusplus >= 201103L\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#include <vector>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define FOR(i,a,b) for(int i=a;i<(b);i++)\n#define FORN(i,b) for(int i=0;i<(b);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vii;\n\nint n,a[100005],t;\nvi g[100005];\nint d[100005];\nmap<int,int> c;\n\nvoid dfs(int x, int dd){\n\td[x]=dd;\n\tfor(int y:g[x])dfs(y,dd^1);\n}\n\nint main(){\n\tscanf(""%d"",&n);\n\tFORN(i,n)scanf(""%d"",a+i);\n\tFOR(i,1,n){\n\t\tint p;\n\t\tscanf(""%d"",&p);p--;\n\t\tg[p].pb(i);\n\t}\n\tdfs(0,0);\n\tbool asd=false;\n\tFORN(i,n)if(!g[i].size()&&!d[i]){asd=true;break;}\n\tif(asd)FORN(i,n)d[i]^=1;\n\tFORN(i,n)if(d[i])t^=a[i];\n\tll r=0;\n\tif(t==0){\n\t\tint q[2];\n\t\tq[0]=q[1]=0;\n\t\tFORN(i,n)q[d[i]]++;\n\t\tr+=1LL*q[0]*(q[0]-1)/2;\n\t\tr+=1LL*q[1]*(q[1]-1)/2;\n\t}\n\tFORN(i,n)if(!d[i])c[a[i]]++;\n\tFORN(i,n)if(d[i])r+=c[t^a[i]];\n\tprintf(""%lld\\n"",r);\n\treturn 0;\n}\n']",,,"['games', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Sagheer and Apple Tree.json,https://codeforces.com//blog/entry/52318,In the standard nim game we xor the values of all piles and if the xor value is then the first player loses Otherwise he has a winning strategy One variant of the nim game has an extra move that allows players to add positive number of stones to a single pile given some conditions to make the game finite The solution for this variant is similar to the standard nim game because this extra move will be used by the winning player and whenever the losing player does it the winning player can cancel it by throwing away these added stones This problem can be modeled as the mentioned variant Lets color leaf nodes with blue The parent of a blue node is red and the parent of a red node is blue that s why all paths from root to leaves must have the same parity Blue nodes are our piles while red nodes allow discarding apples or increasing piles If the xor value of blue nodes then Soliman loses on the initial tree To keep this state after the swap Sagheer can swap any two blue nodes or any two red nodes swap a blue node with a red node if they have the same number of apples If the xor value of blue nodes then Sagheer loses on the initial tree To flip this state after the swap Sagheer must swap a blue node with a red node such that Complexity where is the maximum value for apples in a single node Implementation You can read more about games from this link 
https://codeforces.com//contest/891/problem/A,134540,A,891A,891,A. Pride,You have an array with length you can perform operations Each operation is like this choose two elements from say and and replace one of them with where denotes the greatest common divisor What is the minimum number of operations you need to make all of the elements equal to ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=2010;\nint n,a[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\tbool hav1=0;\n\trep(i,1,n+1) if (a[i]==1) hav1=1;\n\tif (hav1) {\n\t\tint cnt=0;\n\t\trep(i,1,n+1) if (a[i]!=1) cnt++;\n\t\tprintf(""%d\\n"",cnt);\n\t\treturn 0;\n\t}\n\tint len=n+1;\n\trep(i,1,n+1) {\n\t\tint d=a[i];\n\t\trep(j,i,n+1) {\n\t\t\td=gcd(d,a[j]);\n\t\t\tif (d==1) len=min(len,j-i+1);\n\t\t}\n\t}\n\tif (len>n) puts(""-1""); else printf(""%d\\n"",len-1+n-1);\n}\n']",,,"['brute force', 'dp', 'greedy', 'math', 'number theory']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Pride.json,https://codeforces.com//blog/entry/55841,Consider cnt1 as number of 1s in the a If 0 cnt1 then the answer is n cnt1 otherwise We should find a segment with its gcd equal to 1 and minimum length consider a segment as L R which L R and it s gcd as D L R We fix L and then iterate through all R in order Consider we know that D L R G then D L R 1 gcd G A R 1 If D L R 1 then you can make all the elements in R L 1 n 1 Answer is minimum possible D L R over all possible segments 
https://codeforces.com//contest/567/problem/C,32462,C,567C,567,C. Geometric Progression,Polycarp loves geometric progressions very much Since he was only three years old he loves only the progressions of length three He also has a favorite integer and a sequence consisting of integers He wants to know how many subsequences of length three can be selected from so that they form a geometric progression with common ratio A subsequence of length three is a combination of three such indexes that That is a subsequence of length three are such groups of three elements that are not necessarily consecutive in the sequence but their indexes are strictly increasing A geometric progression with common ratio is a sequence of numbers of the form Polycarp is only three years old so he can not calculate this number himself Help him to do it ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define ull unsigned long long\n#define pll pair < ll, ll >\n#define forit(s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it ++)\n#define all(s) s.begin(), s.end()\n\nconst int inf = (1ll << 31) - 1;\nconst int maxn = (int) 1e5 + 10;\n\nusing namespace std;\n\nint n;\nmap < int, ll > m[5];\nint k;\n\nint main () {\n    #ifdef LOCAL\n    freopen (""a.in"", ""r"", stdin);\n    freopen (""a.out"", ""w"", stdout);\n    #endif\n    scanf(""%d %d\\n"", &n, &k);\n    ll ans = 0;\n    for(int i = 0, x; i < n; i++){\n        scanf(""%d"", &x);\n        if(abs(x) % k != 0){\n            m[0][x]++;\n        }else {\n            ans += m[1][x/k];\n            m[1][x] += m[0][x/k];\n            m[0][x]++;\n        }\n    }\n    cout << ans << endl;\n\n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n    #endif\n    return 0;\n}\n\n']",,,"['binary search', 'data structures', 'dp']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Geometric Progression.json,https://codeforces.com//blog/entry/19604,Let s solve this problem for fixed middle element of progression This means that if we fix element then the progression must consist of and elements It could not be possible for example if is not divisible by For fixed middle element one could find the number of sequences by counting how many elements are placed left from fixed element and how many are placed right from it and then multiplying this numbers To do this one could use two associative arrays and where for each key will be stored count of occurences of placed left or right respectively from current element This could be done with map structure Sum of values calculated as described above will give the answer to the problem Author solution 
https://codeforces.com//contest/498/problem/A,19899,A,498A,498,A. Crazy Town,Crazy Town is a plane on which there are infinite line roads Each road is defined by the equation where and are not both equal to the zero The roads divide the plane into connected regions possibly of infinite space Let s call each such region a block We define an intersection as the point where at least two different roads intersect Your home is located in one of the blocks Today you need to get to the University also located in some block In one step you can move from one block to another if the length of their common border is nonzero in particular this means that if the blocks are adjacent to one intersection but have no shared nonzero boundary segment then it are not allowed to move from one to another one in one step Determine what is the minimum number of steps you have to perform to get to the block containing the university It is guaranteed that neither your home nor the university is located on the road ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nint sgn(ll x) {\n  return x < 0 ? -1 : !!x;\n}\n\nstruct pt {\n  int x, y;\n};\n\nstruct line {\n  int a, b, c;\n  int side(const pt &p) const {\n    return sgn(ll(a) * p.x + ll(b) * p.y + c);\n  }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n\n  pt st;\n  while (scanf(""%d%d"", &st.x, &st.y) == 2) {\n    pt en;\n    scanf(""%d%d"", &en.x, &en.y);\n\n    int n;\n    scanf(""%d"", &n);\n\n    int ans = 0;\n    while (n --> 0) {\n      line l;\n      scanf(""%d%d%d"", &l.a, &l.b, &l.c);\n      int s1 = l.side(st);\n      int s2 = l.side(en);\n      assert(s1 && s2);\n      if (s1 != s2) ans++;\n    }\n    printf(""%d\\n"", ans);\n  }\n\n  return 0;\n}\n']",,,['geometry'],1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Crazy Town.json,https://codeforces.com//blog/entry/15353,It can be easily proved that if two points from statement are placed on different sides of some line this line will be crossed anyway So all we need to do is to cross all these lines so the answer is the number of these lines To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs Solution complexity 
https://codeforces.com//contest/1909/problem/D,2393924,D,1909D,1909,D. Split Plus K,There are n positive integers a 1 a 2 dots a n on a blackboard You are also given a positive integer k You can perform the following operation some possibly 0 times choose a number x on the blackboard erase one occurrence of x write two integers y z such that y z x k on the blackboard Is it possible to make all the numbers on the blackboard equal If yes what is the minimum number of operations you need ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi a=readvi(n,-k);\n\tif(a==vi(n,0))return print(0);\n\tsoin(a);\n\t\n\tif(0<a[0]){\n\t\t\n\t}else if(a[n-1]<0){\n\t\t\n\t}else{\n\t\treturn print(-1);\n\t}\n\tint g=0;\n\tfor(auto v:a)g=gcd(g,v);\n\tint ans=0;\n\tfor(auto v:a){\n\t\tans+=abs(v/g);\n\t}\n\tprint(ans-n);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']",,,"['greedy', 'math', 'number theory']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Split Plus K.json,https://codeforces.com//blog/entry/123584,SolutionConsider the shifted problem where each on the blackboard at any moment is replaced with Now the operation becomes replace with such that Therefore in the shifted problem Now you can replace every with any number of values with sum and the answer is the amount of numbers on the blackboard at the end minus If we want to make all the values equal to it must be a divisor of every If all the are positive it is optimal to choose If all the are zero the answer is If all the are negative it is optimal to choose Otherwise the answer is Alternative way to get this result You have to split each into pieces equal to and their sum must be equal to Then so must be a divisor of every In both the positive and the negative case you will only write positive elements in the original setup as wanted If all the are positive the numbers you will write on the shifted blackboard are positive so they will be positive also in the original blackboard If all the are negative the numbers you will write on the shifted blackboard are greater than the numbers you will erase so they will be greater than the numbers in input and positive in the original blackboard Complexity 
https://codeforces.com//contest/406/problem/A,7387,A,406A,406,A. Unusual Product,Little Chris is a huge fan of linear algebra This time he has been given a homework about the of a square matrix The of two integer number vectors and of size is the sum of the products of the corresponding components of the vectors The of an square matrix is defined as the sum of dot products The th of them is the dot product of the th row vector and the th column vector in the matrix Fortunately for Chris he has to work only in This means that all operations addition multiplication are calculated modulo 2 In fact the matrix is binary each element of is either 0 or 1 For example consider the following matrix The unusual square of is equal to However there is much more to the homework Chris has to process queries each query can be one of the following given a row index flip all the values in the th row in given a column index flip all the values in the th column in find the unusual square of To flip a bit value means to change it to i e 1 changes to 0 and 0 changes to 1 Given the initial matrix output the answers for each query of the third type Can you solve Chris s homework ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA ""sequence""\n\nint A[1100][1100];\n\nint main(){\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n\t//freopen(TASKA"".in"", ""r"", stdin); freopen(TASKA"".out"", ""w"", stdout);\n#endif\n\t\n\tint n;\n\tcin>>n;\n\tforn(i,n){\n\t\tforn(j,n){\n\t\t\tscanf(""%d"",A[i]+j);\n\t\t}\n\t}\n\tint r=0;\n\tforn(i,n){\n\t\tforn(j,n){\n\t\t\tr^=A[i][j]*A[j][i];\n\t\t}\n\t}\n\tint tc;\n\tcin>>tc;\n\tforn(qqq,tc){\n\t\tint t,a;\n\t\tscanf(""%d"",&t);\n\t\tif(t==3){\n\t\t\tprintf(""%d"",r);\n\t\t\tcontinue;\n\t\t}\n\t\tscanf(""%d"",&a);\n\t\tr^=1;\n\t}\n\t\n\treturn 0;\n}\n']",,,"['implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Unusual Product.json,https://codeforces.com//blog/entry/11186,Written as a formula the problem asks to find the value of Suppose that Then the sum contains summands and Since the sum is taken modulo 2 these summands together give 0 to the sum It follows that the expression is always equal to the sum of the diagonal bits Now each query of type 1 and 2 flips the value of exactly one bit on the diagonal Thus we can calculate the unusual product of the original matrix and flip its value after each query of type 1 and 2 Solution complexity if we don t take the reading of the input into account 
https://codeforces.com//contest/332/problem/D,3362,D,332D,332,D. Theft of Blueprints,Insurgents accidentally got hold of the plan of a top secret research polygon created on a distant planet for the needs of the Galaxy Empire The insurgents suppose that this polygon is developing new deadly weapon The polygon consists of missile silos connected by bidirectional underground passages The passages are linked to laboratories where research is conducted Naturally the passages are guarded severely the passage between silos and is patrolled by war droids The insurgents studied the polygon plan and noticed its unusual structure As it turned out for any element set of silos there is exactly one silo that is directly connected by a passage with each silo from we ll call this silo Having considered that the insurgents decided to act as follows they choose a element set of silos a group of scouts lands from the air into each silo from each group moves along the corresponding passage to the silo adjacent with as the scouts move they check out the laboratories and watch for any signs of weapon blueprints in the silo adjacent with the groups get on the ship and fly away is the total number of droids that patrol the passages through which the scouts will go The danger of the operation obviously only depends on the way to choose set The insurgents haven t yet decided on the exact silos to send the scouts to However they already want to start preparing the weapons for the scout groups To do that the insurgents need to know the mathematical average of the dangers of the operations that correspond to all possible ways to choose set Solve this problem to help the insurgents protect the ideals of the Republic ,"['#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#define  MP(x,y) make_pair((x),(y))\n\nusing namespace std;\n\ntypedef __int64 LL;\n\nconst int Maxn=2100;\nint n,m;\nvector < LL > con[Maxn];\nint cnt[Maxn];\nLL C[Maxn][Maxn];\n\nvoid init()\n{\n    int i,j;\n    C[0][0]=1;\n    for(i=0;i<Maxn;i++)\n    {\n        C[i][0]=1;\n        for(j=1;j<i;j++)\n        C[i][j]=C[i-1][j-1]+C[i-1][j];\n        C[i][i]=1;\n    }\n}\n\nLL getC(int a,int b)\n{\n    if(b>a) return 0;\n    return C[a][b];\n}\n\nint main()\n{\n    int i,j;\n    init();\n    while(~scanf(""%d%d"",&n,&m))\n    {\n        for(i=0;i<n;i++)\n        {\n            cnt[i]=0;\n            con[i].clear();\n        }\n        for(i=0;i<n;i++)\n        {\n            int tmp;\n            for(j=i+1;j<n;j++)\n            {\n                scanf(""%I64d"",&tmp);\n                if(tmp!=-1)\n                {\n                    cnt[i]++;\n                    cnt[j]++;\n                    con[i].push_back(tmp);\n                    con[j].push_back(tmp);\n                }\n            }\n        }\n        LL A=0;\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<con[i].size();j++)\n            {\n               //cout<<i<<"" ""<<cnt[i]-1<<"" ""<<m-1<<"" ""<<getC(cnt[i]-1,m-1)*con[i][j]<<endl;\n                A+=getC(cnt[i]-1,m-1)*con[i][j];\n            }\n        }\n        printf(""%I64d\\n"",A/getC(n,m));\n    }\n    return 0;\n}\n']",,,"['graphs', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Theft of Blueprints.json,https://codeforces.com/blog/entry/8447,In the problem is given the weighted undirected graph without loops and multiple edges satisfying the following property for every set containing vertices there is exactly one vertex adjacent to all vertices from this set this vertex is called adjacent with For any element set of vertices we can calculate the special characteristic the sum of the weights of edges that connect vertices from with vertex adjacent with S It is required to find the mathematical average of the characteristics of all element sets of vertices One can solve this problem using the following fact the proof is now available only in the Russian version of this post if only complete graph containing vertices satisfies the problem statement For complete graphs answer is equal to doubled sum of weights of all edges divided by The same way one can calculate answer if Now let s consider the case Let s iterate through the vertex which is adjacent with our two element set Let s write in ascending order all such numbers that Any two different vertices of this list form the set for which vertex is adjacent and there are no other such sets of vertices Looking over all pairs of vertices in this list we can add characteristics of all these sets to the answer Since it s guaranteed that the graph satisfies the property each pair of vertices will be analyzed only once A similar approach is used in the validator for this problem Asymptotics of the solution Code 
https://codeforces.com//contest/1229/problem/B,419076,B,1229B,1229,B. Kamil and Making a Stream,Kamil likes streaming the competitive programming videos His MeTube channel has recently reached 100 million subscribers In order to celebrate this he posted a video with an interesting problem he couldn t solve yet Can you help him You re given a tree a connected undirected graph consisting of n vertices connected by n 1 edges The tree is rooted at vertex 1 A vertex u is called an of v if it lies on the shortest path between the root and v In particular a vertex is an ancestor of itself Each vertex v is assigned its x v a non negative integer not larger than 10 12 This allows us to define the beauty of a path Let u be an ancestor of v Then we define the beauty f u v as the greatest common divisor of the beauties of all vertices on the shortest path between u and v Formally if u t 1 t 2 t 3 dots t k v are the vertices on the shortest path between u and v then f u v gcd x t 1 x t 2 dots x t k Here gcd denotes the greatest common divisor of a set of numbers In particular f u u gcd x u x u Your task is to find the sum sum u text is an ancestor of v f u v As the result might be too large please output it modulo 10 9 7 Note that for each y gcd 0 y gcd y 0 y In particular gcd 0 0 0 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nconst int N = 100100;\nvector<int> g[N];\nvector<pli> a[N];\nint n;\nll x[N];\n\nvoid dfs(int v, int par) {\n\tif (par != -1) {\n\t\tfor (pli t : a[par]) {\n\t\t\tll y = gcd(t.first, x[v]);\n\t\t\tif (a[v].empty() || a[v].back().first != y) {\n\t\t\t\ta[v].push_back(mp(y, t.second));\n\t\t\t} else {\n\t\t\t\ta[v].back().second += t.second;\n\t\t\t}\n\t\t}\n\t}\n\tif (a[v].empty() || a[v].back().first != x[v]) {\n\t\ta[v].push_back(mp(x[v], 1));\n\t} else {\n\t\ta[v].back().second++;\n\t}\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tdfs(u, v);\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &x[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tll ans = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (pli t : a[v]) {\n\t\t\tans = (ans + t.first * t.second) % MOD;\n\t\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dp', 'graphs', 'math', 'number theory', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Kamil and Making a Stream.json,https://codeforces.com//blog/entry/70008,Let s prove the following observation To prove this observation consider the ancestors of in the order from the bottom most to top most Notice that Therefore each consecutive adds another value to the gcd of all numbers If a gcd of all numbers changes it must be a divisor of the previous gcd Therefore it s easy to see that it can change at most times We can now implement a depth first search If we invoke a recursive call in vertex we will receive the multiset of values We add all these values to the result and run the recursive calls in the children This is currently or but we can improve it by actually using a map from the distinct values in the multiset to the number of their occurrences Then each map will have no more than elements As we need to compute s throughout the algorithm this solution allows us to solve the problem in time and in memory It s also possible to solve the problem using jump pointers Each jump pointer will additionally hold the greatest common divisor of all the numbers we jump over when following the pointer 
https://codeforces.com//contest/1276/problem/C,495590,C,1276C,1276,C. Beautiful Rectangle,You are given n integers You need to choose a subset and put the chosen numbers in a beautiful rectangle rectangular matrix Each chosen number should occupy one of its rectangle cells each cell must be filled with exactly one chosen number Some of the n numbers may not be chosen A rectangle rectangular matrix is called beautiful if in each row and in each column all values are different What is the largest by the total number of cells beautiful rectangle you can construct Print the rectangle itself ,"['#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define N_ 401000\nusing namespace std;\nint n, w[N_];\n\nstruct AA {\n\tint c, a;\n\tbool operator <(const AA &p)const {\n\t\treturn c < p.c;\n\t}\n}U[N_];\n\nint A, B;\n\nvoid UDT(int x, int y) {\n\tif (A*B<x*y) {\n\t\tA = x, B = y;\n\t}\n}\n\nvoid Solve() {\n\tint i, j;\n\tmap<int, int>Map;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &w[i]);\n\t\tMap[w[i]]++;\n\t}\n\tint cnt = 0;\n\tfor (auto &t : Map) {\n\t\tcnt++;\n\t\tU[cnt] = { t.second,t.first };\n\t}\n\tsort(U + 1, U + cnt + 1);\n\tint pv = 0, s = 0;\n\tfor (i = 1; i*i <= n; i++) {\n\t\twhile (pv + 1 <= cnt && U[pv + 1].c <= i) {\n\t\t\ts += U[pv + 1].c;\n\t\t\tpv++;\n\t\t}\n\t\tint tot = (cnt - pv) * i + s;\n\t\tif (tot >= i * i) {\n\t\t\tUDT(i, tot/i);\n\t\t}\n\t}\n\ts = A * B;\n\tfor (i = 1; i <= cnt; i++) {\n\t\tif (U[i].c > A) U[i].c = A;\n\t\tU[i].c = min(U[i].c, s);\n\t\ts -= U[i].c;\n\t}\n\tprintf(""%d\\n%d %d\\n"", A*B, A, B);\n\tvector<vector<int>>V;\n\tV.resize(A);\n\tfor (i = 0; i < A; i++)V[i].resize(B);\n\tsort(U + 1, U + cnt + 1);\n\tint x = 0, y = 0;\n\tfor (i = cnt; i >= 1; i--) {\n\t\twhile (U[i].c) {\n\t\t\tV[x][y%B] = U[i].a;\n\t\t\tU[i].c--;\n\t\t\tx++, y++;\n\t\t\tif (x >= A) {\n\t\t\t\tx -= A;\n\t\t\t\ty -= A - 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < A; i++) {\n\t\tfor (j = 0; j < B; j++) {\n\t\t\tprintf(""%d "", V[i][j]);\n\t\t}\n\t\tputs("""");\n\t}\n}\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin);\n\tint TC = 1;\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}']",,,"['brute force', 'combinatorics', 'constructive algorithms', 'data structures', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Beautiful Rectangle.json,https://codeforces.com//blog/entry/72239,First let s formulate the criteria that from the given set of numbers x1 x2 xk we can create a beautiful rectangle a b where a b k a b Obviously if some number occurs more than a times then among a rows there will be such row that will contain two or more occurrences of the number pigeonhole principle Let s prove that if all numbers in x 1 k occur no more than a times we can create a beautiful rectangle a b where a b k a b We will numerate cells from the upper left corner in the order from one moving diagonally each time Assume rows are numerated from 0 to a 1 and columns are numerated from 0 to b 1 Let s begin from the cell 0 0 and move right down each time If we face to a border we will move cyclically Thus from the cell i j we will move to the cell i 1 moda j 1 modb each time where pmodq is the remainder when divided p by q If we are going to move to a visited cell before moving let s assign i i 1 moda Example of the numeration for rectangles 3 3 and 4 6 We can also prove that while such numeration each row and each column contain numbers that differ by no less than a 1 if we are on a row column we will make a turn before we will be on the row column again Moreover the difference reaches a 1 not a when we move to the previously visited cell and assign i i 1 moda So we can prove that the lengths of such orbits are equal lcm a b lcm is a least common multiple Consequently they are divided by a It means that if we will arrange the numbers from x in the order from the most common at worst case those that meet a times to the least common each row and each column will always contain different numbers Thus we have a plan of the solution find optimal a and b so that the answer is the largest rectangle a b a b For this we will iterate over all possible candidates in a and for each candidate each number v from x we will use it no more than min cv a times where cv is a number of occurrences v in the given sequence So if we choose a the upper bound of a rectangle area is min cv a for all possible different numbers v from the given sequence Consequently the maximal value of b is min cv a a And let s update the answer if for current iteration a b is larger than previously found answer still consider that a b We can maintain the value min cv a while a is incremented by one For doing this we should each time add geq a to this value where geq a is a number of different numbers in the given sequence which occurs at least a times we can precalculate this array 
https://codeforces.com//contest/1464/problem/A,839210,A,1464A,1464,A. Peaceful Rooks,You are given a n times n chessboard Rows and columns of the board are numbered from 1 to n Cell x y lies on the intersection of column number x and row number y Rook is a chess piece that can in one turn move any number of cells vertically or horizontally There are m rooks m n placed on the chessboard in such a way that no pair of rooks attack each other I e there are no pair of rooks that share a row or a column In one turn you can move one of the rooks any number of cells vertically or horizontally Additionally it shouldn t be attacked by any other rook after movement What is the minimum number of moves required to place all the rooks on the main diagonal The main diagonal of the chessboard is all the cells i i where 1 le i le n ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint T,n,m,ans;\nint fa[MAXN];\n\nint getroot(int u)\n{\n\treturn u == fa[u] ? u : fa[u] = getroot(fa[u]);\n}\n\nint main()\n{\n\tscanf(""%d"",&T);\n\twhile (T--)\n\t{\n\t\tscanf(""%d%d"",&n,&m);\n\t\tfor (int i = 1;i <= n;i++)\n\t\t\tfa[i] = i;\n\t\tans = m;\n\t\tfor (int u,v,i = 1;i <= m;i++)\n\t\t{\n\t\t\tscanf(""%d%d"",&u,&v);\n\t\t\tif (u == v)\n\t\t\t{\n\t\t\t\tans--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ru = getroot(u),rv = getroot(v);\n\t\t\tif (ru == rv)\n\t\t\t\tans++;\n\t\t\telse\n\t\t\t\tfa[ru] = rv;\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'dfs and similar', 'dsu', 'graphs']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Peaceful Rooks.json,https://codeforces.com//blog/entry/85792,Consider rooks as edges in a graph The position x y will correspond to an edge x y From the condition that there re at most one edge exits leading from each vertex and at most one edge leading to each vertex it follows that the graph decomposes into cycles paths and loops edges of type v v What happens to the graph when we move the rook The edge changes exactly one of its endpoints By such operations we must turn all edges into loops and the constraint on the number of edges going in and out of a vertex must be satisfied A path is quite easy to turn into loops just start from one end A cycle must first be turned into a path which is always possible We ve only spent one extra move it s not hard to see that this is optimal The answer is the number of rooks minus the number of loops plus the number of cycles 
https://codeforces.com//contest/1383/problem/C,681329,C,1383C,1383,C. String Transformation 2,Koa the Koala has two strings A and B of the same length n A B n consisting of the first 20 lowercase English alphabet letters ie from to In one move Koa selects some subset of positions p 1 p 2 ldots p k k ge 1 1 le p i le n p i neq p j if i neq j of A such that A p 1 A p 2 ldots A p k x ie all letters on this positions are equal to some letter x selects letter y from the first 20 lowercase letters in English alphabet sets each letter in positions p 1 p 2 ldots p k to letter y More formally for each i 1 le i le k Koa sets A p i y Koa wants to know the smallest number of moves she has to do to make strings equal to each other A B or to determine that there is no way to make them equal Help her ,"['/**\n *    author:  tourist\n *    created: 24.07.2020 17:34:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int len;\n    cin >> len;\n    string a, b;\n    cin >> a >> b;\n    int n = 20;\n    dsu d(n);\n    for (int i = 0; i < len; i++) {\n      d.unite((int) (a[i] - \'a\'), (int) (b[i] - \'a\'));\n    }\n    vector<vector<int>> comps(n);\n    for (int i = 0; i < n; i++) {\n      comps[d.get(i)].push_back(i);\n    }\n    vector<int> mask_to(n);\n    for (int i = 0; i < len; i++) {\n      mask_to[(int) (b[i] - \'a\')] |= (1 << ((int) (a[i] - \'a\')));\n    }\n    int ans = 0;\n    for (auto& comp : comps) {\n      int cnt = (int) comp.size();\n      if (cnt == 0) {\n        continue;\n      }\n      vector<int> new_mask(cnt);\n      for (int i = 0; i < cnt; i++) {\n        for (int j = 0; j < cnt; j++) {\n          if (i == j) {\n            continue;\n          }\n          if (mask_to[comp[i]] & (1 << comp[j])) {\n            new_mask[i] |= (1 << j);\n          }\n        }\n      }\n      vector<int> dp(1 << cnt, 0);\n      dp[0] = 0;\n      for (int t = 0; t < (1 << cnt); t++) {\n        for (int i = 0; i < cnt; i++) {\n          if (t & (1 << i)) {\n            continue;\n          }\n          int ft = dp[t];\n          if ((new_mask[i] & t) == new_mask[i]) {\n            ft += 1;\n          }\n          dp[t | (1 << i)] = max(dp[t | (1 << i)], ft);\n        }\n      }\n//      debug(comp, dp.back());\n      ans += 2 * cnt - 1 - dp.back();\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['bitmasks', 'dp', 'graphs', 'trees']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. String Transformation 2.json,https://codeforces.com//blog/entry/80562,The only difference between this problem and the previous problem is that the underlying graph might have cycles Each weakly connected component can be solved independently and the answer is where is the number of nodes in the component and is the size of the largest Directed Acyclic Graph The largest directed acyclic graph can be computed using dynamic programming in For every node store a mask with all nodes it can reach directly Then go through every possible mask from to and check whether this set of nodes is acyclic or not It is acyclic if there exists at least one node the last node in one topological order such that the set without this node is acyclic and this node doesn t reach any other node in this set is dag 0 1for mask in 1 2 n 1 for u in mask is dag mask is dag mask 1 u mask reach u 0 Proof by eatmore Suppose that there is a weakly connected component with vertices and there is a solution with edges Then the size of the largest DAG is at least Proof Let s keep track of current weakly connected components Also in each of the components let s keep track of some DAG Initially each vertex is in a separate component and each DAG consists of a single vertex So there are components and the total size of all DAGs is Processing an edge If and are in the same component if is in the DAG remove it Number of components is unchanged the total size of all DAGs is decreased by at most 1 If and are in different components join the components Concatenate the DAGs DAG of s component comes before DAG of s component Number of components decreases by the total size of all DAGs is unchanged At the end the number of components becomes so edges are used to decrease the number of components The remaining edges could decrease the size of DAGs so the final size is at least From we know that then is minimized when the size of the final DAG is maximized Time complexity per test case 
https://codeforces.com//contest/1626/problem/C,1263149,C,1626C,1626,C. Monsters And Spells,Monocarp is playing a computer game once again He is a wizard apprentice who only knows a single spell Luckily this spell can damage the monsters The level he s currently on contains n monsters The i th of them appears k i seconds after the start of the level and has h i health points As an additional constraint h i le k i for all 1 le i le n All k i are different Monocarp can cast the spell at moments which are positive integer amounts of second after the start of the level 1 2 3 dots The damage of the spell is calculated as follows If he didn t cast the spell at the previous second the damage is 1 Otherwise let the damage at the previous second be x Then he can choose the damage to be either x 1 or 1 A spell uses mana casting a spell with damage x uses x mana Mana doesn t regenerate To kill the i th monster Monocarp has to cast a spell with damage at least h i at the exact moment the monster appears which is k i Note that Monocarp can cast the spell even when there is no monster at the current second The mana amount required to cast the spells is the sum of mana usages for all cast spells Calculate the least amount of mana required for Monocarp to kill all monsters It can be shown that it s always possible to kill all monsters under the constraints of the problem ,"['#pragma region Macros\n//#pragma GCC target(""avx2"")\n// #pragma GCC optimize(""O3"")\n// #pragma comment(linker, ""/stack:200000000"")\n#ifdef ONLINE_JUDGE\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2"")\n// #pragma GCC target(""avx2"")\n#endif\n#pragma GCC optimize(""Ofast"")\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl \'\\n\'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= b; i -= c)\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define rng(v, l, r) v.begin() + l, v.begin() + r\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {""NO"", ""YES""};\nconst string YesNo[2] = {""No"", ""Yes""};\nconst string yesno[2] = {""no"", ""yes""};\nconst string firstsecond[2] = {""second"", ""first""};\nconst string FirstSecond[2] = {""Second"", ""First""};\nconst string possiblestr[2] = {""impossible"", ""possible""};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\n\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\n// bit 演算系\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - \'0\'; }\n    }\n    if(s[0] == \'-\') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << ""0""); }\n    i128 num = v;\n    if(v < 0) {\n        os << \'-\';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + \'0\'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? "", "" : "" "");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << \'(\'; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << \')\'; }\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << ""("" << p.first << "", "" << p.second << "")""; }\n    return os << p.first << "" "" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << ""["";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? """" : "", "") << y;\n        else\n            os << (f ? """" : "" "") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << ""]"";\n    return os;\n}\n\n#ifdef noimi\n#undef endl\nvoid debug() { cerr << endl; }\nvoid debug(bool) { cerr << endl; }\ntemplate <class Head, class... Tail> void debug(bool is_front, Head head, Tail... tail) {\n    if(!is_front) cerr << "", "";\n    cerr << head;\n    debug(false, tail...);\n}\n\n#define dump(args...)                                                                                                                                          \\\n    {                                                                                                                                                          \\\n        vector<string> _debug = _split(#args, \',\');                                                                                                            \\\n        err(true, begin(_debug), args);                                                                                                                        \\\n    }\n\nvector<string> _split(const string &s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while(getline(ss, x, c)) {\n        if(empty(v))\n            v.eb(x);\n        else {\n            bool flag = false;\n            for(auto [c, d] : {pair(\'(\', \')\'), pair(\'[\', \']\'), pair(\'{\', \'}\')}) {\n                if(count(all(v.back()), c) != count(all(v.back()), d)) flag = true;\n            }\n            if(flag)\n                v.back() += "","" + x;\n            else\n                v.eb(x);\n        }\n    }\n    return move(v);\n}\n\nvoid err(bool, vector<string>::iterator) { cerr << endl; }\ntemplate <typename T, typename... Args> void err(bool is_front, vector<string>::iterator it, T a, Args... args) {\n    if(!is_front) cerr << "", "";\n    cerr << it->substr((*it)[0] == \' \', (*it).size()) << "" = "" << a, err(false, ++it, args...);\n}\n\n// #define dump(...) cerr << #__VA_ARGS__ << "" : "", debug(true, __VA_ARGS__)\n#else\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n#endif\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << \' \';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(std::forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, std::forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nint toint(const char &c, const char start = \'a\') { return c - start; }\nint toint(const char &c, const string &chars) { return find(all(chars), c) - begin(chars); }\nint alphabets_to_int(const char &c) { return (islower(c) ? c - \'a\' : c - \'A\' + 26); }\ntemplate <typename T> auto toint(const T &v, const char &start = \'a\') {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\ntemplate <typename T> auto toint(const T &v, const string &start) {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\n// a -> 0, A -> 26\ntemplate <typename T> auto alphabets_to_int(const T &s) {\n    vector<decltype(alphabets_to_int(s[0]))> res;\n    res.reserve(s.size());\n    for(auto &&e : s) { res.emplace_back(alphabets_to_int(e)); }\n    return res;\n}\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        T mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#pragma endregion\n\nint main() {\n    TEST {\n        INT(n);\n        VEC(int, t, n);\n        VEC(int, a, n);\n        vi b(n);\n        rep(i, n) b[i] = t[i] - a[i] + 1;\n        auto tri = [&](ll l, ll r) { return (l + r) * (r - l + 1) / 2; };\n\n        auto id = iota(b);\n        int M = -1;\n        ll ans = 0;\n        ll now = 0;\n        fore(i, id) {\n            dump(b[i]);\n            if(b[i] > M) {\n                ans += tri(1, a[i]);\n                M = t[i];\n                now = a[i];\n            } else {\n                if(t[i] > M) {\n                    ans += tri(now + 1, now + (t[i] - M));\n                    now += t[i] - M;\n                    M = t[i];\n                }\n            }\n            dump(ans, M, now);\n        }\n        OUT(ans);\n    }\n}']",,,"['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'math', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Monsters And Spells.json,https://codeforces.com//blog/entry/99136,Consider the problem with There is a single monster with some health that appears at some second In order to kill it we have to wind up our spell until it has damage So we have to use it from second to second Look at it as a segment on a timeline Actually to avoid handling zero length segments let s instead say that a segment covers the time from non inclusive to inclusive producing a half interval This way the total mana cost will be where is the length of the half interval Now There are two time segments If they don t intersect segments and don t intersect since they are half intervals then it s always better to wind up the spell for the monsters separately instead of saving the damage However if they intersect then we don t have the choice other than to save the damage from the earlier one to the later one Otherwise there won t be enough time to wind up the spell What that means in a mathematic sense The answer is the union of two half intervals If they don t intersect they are left as is Otherwise they become one half interval that covers them both Now add the third monster into the construction The same argument applies While there exists a pair of intersecting half intervals keep uniting them The union of all half intervals can be found in but the constraints allowed slower approaches as well 
https://codeforces.com//contest/389/problem/A,6400,A,389A,389,A. Fox and Number Game,Fox Ciel is playing a game with numbers now Ciel has positive integers She can do the following operation as many times as needed select two different indexes and such that hold and then apply assignment The goal is to make the sum of all numbers as small as possible Please help Ciel to find this minimal sum ,"['#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) { cout << #x << "" = ""; cout << x << endl; }\n#define PR(a,n) { cout << #a << "" = ""; FOR(_,1,n) cout << a[_] << \' \'; cout << endl; }\n#define PR0(a,n) { cout << #a << "" = ""; REP(_,n) cout << a[_] << \' \'; cout << endl; }\nusing namespace std;\n\nint a[111];\n\nint main() {\n    ios :: sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        FOR(i,1,n) cin >> a[i];\n        int g = a[1];\n        FOR(i,2,n) g = __gcd(g, a[i]);\n        cout << g * n << endl;\n    }\n    return 0;\n}\n']",,,"['greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Fox and Number Game.json,https://codeforces.com//blog/entry/10629,First we know that in the optimal solution all number will be equal otherwise we can pick a and b a b then do b b a it will make the answer better Then we need an observation after each operation the GCD Greatest common divisor of all number will remain same It can be proved by this lemma if g is a divisor of all number of x then after the operation g is still the divisor of these numbers and vice versa So in the end all number will become the GCD of x Another solution that can pass is While there exist x i x j then do x i x j We can select arbitrary i and j if there exist more than 1 choice 
https://codeforces.com//contest/1013/problem/B,203186,B,1013B,1013,B. And,There is an array with elements and the number In one operation you can select some and replace element with where denotes the bitwise and operation You want the array to have at least two equal elements after applying some operations possibly none In other words there should be at least two distinct indices such that Determine whether it is possible to achieve and if possible the minimal number of operations to apply ,"['/// In The Name Of God\n/// I wish, that I could leave it all behind me / Go to my own world where no one can find me\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define int long long\n#define ll long long\n#define pii pair <int , int>\n#define ld long double\n#define for2(a,b,c) for(int (a) = (b); (a) < (c); (a)++)\n#define for3(a,b,c) for(    (a) = (b); (a) < (c); (a)++)\n#define setp cout << fixed << setprecision(15)\n#define endl ""\\n""\n#define minit(a,b) a = min(a,b)\n#define maxit(a,b) a = max(a,b)\n#define PII pair<int,int>\n#define Vec vector<int>\n#define error(x) cerr << #x << "" = "" << (x) << endl;\n#define all(x) (x).begin() , (x).end()\n\nint x[1000000];\nint y[1000000];\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,X; cin >> n >> X;\n    int ans = 4;\n    for2(i,0,n){\n        int a,b;\n        cin >> a;\n        b = a&X;\n        if(x[a]){\n            cout << 0 << endl;\n            return 0;\n        }\n        if(y[a] || x[b])ans = 1;\n        if(y[b]) ans = min(ans,2ll);\n        x[a] = y[b] = 1;\n    }\n    if(ans == 4) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n']",,,['greedy'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. And.json,https://codeforces.com//blog/entry/60920,Clearly if it is possible then there are no more than operations needed So we basically need to distinguish outcomes and The answer is zero if there are already equal elements in the array To check if the answer is we can apply the operation to each element of the array If all elements are still distinct then it couldn t be helped To check if the answer is one we can bruteforce the element to apply the operation to and if this operation changes this element we can check if there is an element in the array In all other cases answer is two 
https://codeforces.com//contest/1153/problem/B,329967,B,1153B,1153,B. Serval and Toy Bricks,Luckily Serval got onto the right bus and he came to the kindergarten on time After coming to kindergarten he found the toy bricks very funny He has a special interest to create difficult problems for others to solve This time with many 1 times 1 times 1 toy bricks he builds up a 3 dimensional object We can describe this object with a n times m matrix such that in each cell i j there are h i j bricks standing on the top of each other However Serval doesn t give you any h i j and just give you the front view left view and the top view of this object and he is now asking you to restore the object Note that in the front view there are m columns and in the i th of them the height is the maximum of h 1 i h 2 i dots h n i It is similar for the left view where there are n columns And in the top view there is an n times m matrix t i j where t i j is 0 or 1 If t i j equals 1 that means h i j 0 otherwise h i j 0 However Serval is very lonely because others are bored about his unsolvable problems before and refused to solve this one although this time he promises there will be at least one object satisfying all the views As his best friend can you have a try ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e2;\n\nint n, m, h, a[MAXN], b[MAXN], c[MAXN][MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n >> m >> h;\n\tfor(int i=0; i<m; ++i)\n\t\tcin >> a[i];\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> b[i];\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<m; ++j) {\n\t\t\tcin >> c[i][j];\n\t\t\tif(c[i][j])\n\t\t\t\tc[i][j]=min(a[j], b[i]);\n\t\t\tcout << c[i][j] << "" "";\n\t\t}\n\t\tcout << ""\\n"";\n\t}\n\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Serval and Toy Bricks.json,https://codeforces.com/blog/entry/66539,EditorialFill in all the bricks and then remove all bricks you must remove which in some view there is empty This can be solved in 
https://codeforces.com//contest/766/problem/E,92735,E,766E,766,E. Mahmoud and a xor trip,Mahmoud and Ehab live in a country with cities numbered from to and connected by undirected roads It s guaranteed that you can reach any city from any other using these roads Each city has a number attached to it We define the distance from city to city as the of numbers attached to the cities on the path from to In other words if values attached to the cities on the path from to form an array of length then the distance between them is where is bitwise operation Mahmoud and Ehab want to choose two cities and make a journey from one to another The index of the start city is always less than or equal to the index of the finish city they may start and finish in the same city and in this case the distance equals the number attached to that city They can t determine the two cities so they try every city as a start and every city with greater index as a finish They want to know the total distance between all pairs of cities ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nll n, a[100100], b[100100];\nll cnt[100100][2];\nll sum;\nvector <int> g[100100];\n\nvoid dfs(int v, int pr = -1){\n    cnt[v][0] = cnt[v][1] = 0;\n    cnt[v][b[v]]++;\n    for(int i = 0; i < g[v].size(); ++i){\n        int to = g[v][i];\n        if(to != pr){\n            dfs(to, v);\n            sum += cnt[to][0] * cnt[v][1] + cnt[to][1] * cnt[v][0];\n            cnt[v][b[v]] += cnt[to][0];\n            cnt[v][b[v] ^ 1] += cnt[to][1];\n        }\n    }\n    sum += b[v];\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n    }\n    for(int i = 2, u, v; i <= n; ++i){\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll ans = 0;\n    for(int i = 0; i <= 20; ++i){\n        sum = 0;\n        for(int j = 1; j <= n; ++j){\n            if(a[j] & (1 << i)){\n                b[j] = 1;\n            }else{\n                b[j] = 0;\n            }\n        }\n        dfs(1);\n        ans += (sum << i);\n    }\n    cout << ans << endl;\n}\n']",,,"['bitmasks', 'constructive algorithms', 'data structures', 'dfs and similar', 'dp', 'math', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Mahmoud and a xor trip.json,https://codeforces.com//blog/entry/50294,If we have an array which represents the number of paths that makes the bit sit to Our answer will be Let be the binary value of the bit of the number attached to node just to make work easier There are 2 types of paths from node to node where is less in depth than or equal to Paths going down which are paths with and other paths Let s root the tree at node and dfs let current node be Let be the number of paths going down from node that makes the bit s value equal to A path going down from node is a path going down from a child of with node concatenated to it so let s calculate our A path that isn t going down is a concatenation of 2 paths which are going down from Now we can calculate See the code for formulas Code http pastebin com n2a3kijD Time complexity Problem author me Solution author me Tester mahmoudbadawy 
https://codeforces.com//contest/962/problem/D,173205,D,962D,962,D. Merge Equals,You are given an array of positive integers While there are at least two equal elements we will perform the following operation We choose the smallest value x that occurs in the array 2 or more times Take the first two occurrences of x in this array the two leftmost occurrences Remove the left of these two occurrences and the right one is replaced by the sum of this two values that is 2 cdot x Determine how the array will look after described operations are performed For example consider the given array looks like 3 4 1 2 2 1 1 It will be changed in the following way 3 4 1 2 2 1 1 rightarrow 3 4 2 2 2 1 rightarrow 3 4 4 2 1 rightarrow 3 8 2 1 If the given array is look like 1 1 3 1 1 it will be changed in the following way 1 1 3 1 1 rightarrow 2 3 1 1 rightarrow 2 3 2 rightarrow 3 4 ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n;\nmap<ll,set<int>> m;\nset<pl> en;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n; \n    vi a(n);\n    F0R(i,n) {\n        cin >> a[i]; \n        m[a[i]].insert(i);\n    }\n    while (sz(m)) {\n        auto a = *m.begin(); m.erase(m.begin());\n        while (sz(a.s) >= 2) {\n            a.s.erase(a.s.begin());\n            m[2*a.f].insert(*a.s.begin());\n            a.s.erase(a.s.begin());\n        }\n        if (sz(a.s) == 1) en.insert({*a.s.begin(),a.f});\n    }\n    cout << sz(en) << ""\\n"";\n    for (auto a: en) cout << a.s << "" "";\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)']",,,"['data structures', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Merge Equals.json,https://codeforces.com//blog/entry/58869,To solve this problem we should use a set of pairs let s call it We will store in it all the elements of the current array the first number in the pair and the positions of these elements in the current array the second number in the pair The first elements of pairs should have type because the result of merging the array elements can become large and the type will overflow Initially you need to put in all elements of the given array with their positions While there are elements in we will perform the following algorithm Let be a pair in the beginning of Then look at the next element of If it does not exist the algorithm is complete Otherwise let the next element is equal to If then there is no pair number for the element which is in the position and it will never appear because all elements can only increase So remove from and repeat the algorithm from the beginning Otherwise the number at the position will be deleted and the number in the position will be double up So remove and from put in and repeat the algorithm from the beginning For the convenience of restoring the answer you can mark deleted positions of the given array in an additional array so in this case you need to mark as a deleted position 
https://codeforces.com//contest/1973/problem/A,2652010,A,1973A,1973,A. Chess For Three,Three friends gathered to play a few games of chess together In every game two of them play against each other The winner gets 2 points while the loser gets 0 and in case of a draw both players get 1 point each Note that the same pair of players could have played any non negative number of times possibly zero It is also possible that no games were played at all You ve been told that their scores after all the games were played were p 1 p 2 and p 3 Additionally it is guaranteed that p 1 leq p 2 leq p 3 holds Find the maximum number of draws that could have happened and print it If there isn t any way to obtain p 1 p 2 and p 3 as a result of a non negative number of games between the three players print 1 instead ,"['#include<bits/stdc++.h>using namespace std;int main(){    int T,a[3];scanf(""%d"",&T);while(T--){        scanf(""%d%d%d"",&a[0],&a[1],&a[2]);        if(!((a[0]+a[1]+a[2])&1)){            int ans=0;            while(a[1]&&a[2])                a[1]--,a[2]--,sort(a,a+3),ans++;            printf(""%d\\n"",ans);        }        else puts(""-1"");    }    return 0;}']",,,"['brute force', 'dp', 'implementation', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Chess For Three.json,https://codeforces.com//blog/entry/129556,Solution After each round sum of players scores increases by 2 so if the sum is odd answer is Now as the hints suggest you can try all possible combinations of and with three for loops and check for each combination whether it could result in scores and Specifically it must hold that and the same two conditions for and analogously Now you can find the biggest value of over all valid choices and print it as the answer The time complexity is Implementation in Python 261998440 Bonus There exists an solution with simpler implementation Claim The answer is min Let s prove this if then it s possible that players and played and draws with player after which there can t happen any additional draws in the game if that means so player can first play draws with player Note that if sum is even then will also be even so player can play draws with each of players and thus adding up his score to exactly Finally players and can play draws anong them after which their scores become and respectively Thus it is possible that all rounds played ended with draws making answer equal to Implementation in C 261998652 
https://codeforces.com//contest/318/problem/B,3162,B,318B,318,B. Strings of Power,Volodya likes listening to heavy metal and occasionally reading No wonder Volodya is especially interested in texts concerning his favourite music style Volodya calls a string powerful if it starts with and ends with Finding all powerful substrings by substring Volodya means a subsequence of consecutive characters in a string in a given text makes our hero especially joyful Recently he felt an enormous fit of energy while reading a certain text So Volodya decided to count all powerful substrings in this text and brag about it all day long Help him in this difficult task Two substrings are considered different if they appear at the different positions in the text For simplicity let us assume that Volodya s text can be represented as a single string ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1000010;\nint a[N],b[N];\nchar s[N];\n\nint main()\n{\n\tscanf(""%s"",s + 1);\n\tint n = strlen(s + 1);\n\tmemset(a,0,sizeof(a));\n\tfor(int i = 1; i <= n; i ++) {\n\t\tif(s[i] == \'m\' && s[i + 1] == \'e\' && s[i + 2] == \'t\' && s[i + 3] == \'a\' && s[i + 4] == \'l\') \n\t\t\ta[i] = 1;\n\t}\n\tfor(int i = n; i >= 1; i --) \n\t\ta[i] += a[i + 1];\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(s[i] == \'h\' && s[i + 1] == \'e\' && s[i + 2] == \'a\' && s[i + 3] == \'v\' && s[i + 4] == \'y\')\n\t\t\tans += a[i];\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['implementation', 'strings', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Strings of Power.json,https://codeforces.com/blog/entry/7956,In the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B If we mark black all the starting positions of the entries of the string A in S and white all the starting positions of the entries of the string B then we come to the following problem count the number of pairs black position white position in this order To solve this it is enough to iterate from left to right counting the number of the passed black positions Meeting black position we increment this number by one meeting white position we add to the answer the number of pairs with this white position which is exactly our memorized number of the already passed black positions 
https://codeforces.com//contest/991/problem/B,192851,B,991B,991,B. Getting an A,Translator s note in Russia s most widespread grading system there are four grades 5 4 3 2 the higher the better roughly corresponding to A B C and F respectively in American grading system The term is coming to an end and students start thinking about their grades Today a professor told his students that the grades for his course would be given out automatically he would calculate the simple average arithmetic mean of all grades given out for lab works this term and round to the nearest integer The rounding would be done in favour of the student 4 5 would be rounded up to 5 as in example 3 but 4 4 would be rounded down to 4 This does not bode well for Vasya who didn t think those lab works would influence anything so he may receive a grade worse than 5 maybe even the dreaded 2 However the professor allowed him to redo some of his works of Vasya s choosing to increase his average grade Vasya wants to redo as as few lab works as possible in order to get 5 for the course Of course Vasya will get 5 for the lab works he chooses to redo Help Vasya calculate the minimum amount of lab works Vasya has to redo ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tsum += 2 * a[i];\n\t}\n\tsort(ALL(a));\n\tint i = 0;\n\twhile (sum < 9 * n) {\n\t\tsum -= 2 * a[i];\n\t\tsum += 2 * 5;\n\t\ti++;\n\t}\n\tcout << i << endl;\n\treturn 0;\n}""]",,,"['greedy', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Getting an A.json,https://codeforces.com/blog/entry/60181,EditorialIt is necessary to use the greedy approach of course Vasya should redo the lowest grades firstly So we have to sort the values in the ascending order and begin to replace the values by 5 until we get the desired result In order to check whether the current state is suitable we may calculate the mean value after each iteration complexity in total or just update sum of the grades and calculate the arithmetic mean in with total complexity excluding sorting For example Of course both approaches easily fit TL Finally it is recommended to avoid floating point operations while calculating the mean value 
https://codeforces.com//contest/1606/problem/D,1163615,D,1606D,1606,D. Red-Blue Matrix,You are given a matrix consisting of n rows and m columns The j th cell of the i th row contains an integer a ij First you have to color each row of the matrix either red or blue in such a way that and Then you have to choose an integer k 1 le k m and cut the colored matrix in such a way that the first k columns become a separate matrix the matrix and the last m k columns become a separate matrix the matrix The coloring and the cut are called if two properties hold every red cell in the left matrix contains an integer greater than every blue cell in the left matrix every blue cell in the right matrix contains an integer greater than every red cell in the right matrix Find any perfect coloring and cut or report that there are none ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tint f=1;char c;x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=1000005;\n\nint n,m,a[MAXN];\nint p[MAXN];\nint pl[MAXN],sl[MAXN],pr[MAXN],sr[MAXN];\nint lx[MAXN],ly[MAXN],rx[MAXN],ry[MAXN];\nchar res[MAXN];\nvoid solve()\n{\n\treadint(n),readint(m);\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<m;++j)\n\t\t\treadint(a[i*m+j]);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tlx[i*m]=ly[i*m]=a[i*m];\n\t\tfor(int j=1;j<m;++j)lx[i*m+j]=min(lx[i*m+j-1],a[i*m+j]),ly[i*m+j]=max(ly[i*m+j-1],a[i*m+j]);\n\t\trx[i*m+m-1]=ry[i*m+m-1]=a[i*m+m-1];\n\t\tfor(int j=m-2;j>=0;--j)rx[i*m+j]=min(rx[i*m+j+1],a[i*m+j]),ry[i*m+j]=max(ry[i*m+j+1],a[i*m+j]);\n\t}\n\tfor(int j=0;j<m-1;++j)\n\t{\n\t\tfor(int i=0;i<n;++i)p[i]=i;\n\t\tsort(p,p+n,[&](int x,int y){return ly[x*m+j]<ly[y*m+j];});\n\t\tpl[0]=ly[p[0]*m+j],pr[0]=rx[p[0]*m+j+1];\n\t\tfor(int i=1;i<n;++i)pl[i]=max(pl[i-1],ly[p[i]*m+j]),pr[i]=min(pr[i-1],rx[p[i]*m+j+1]);\n\t\tsl[n-1]=lx[p[n-1]*m+j],sr[n-1]=ry[p[n-1]*m+j+1];\n\t\tfor(int i=n-2;i>=0;--i)sl[i]=min(sl[i+1],lx[p[i]*m+j]),sr[i]=max(sr[i+1],ry[p[i]*m+j+1]);\n\t\tfor(int i=0;i<n-1;++i)\n\t\t\tif(pl[i]<sl[i+1] && pr[i]>sr[i+1])\n\t\t\t{\n\t\t\t\tprintf(""YES\\n"");\n\t\t\t\tfor(int t=0;t<n;++t)res[p[t]]=(t<=i?\'B\':\'R\');\n\t\t\t\tres[n]=\'\\0\';\n\t\t\t\tprintf(""%s %d\\n"",res,j+1);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tprintf(""NO\\n"");\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}']",,,"['brute force', 'constructive algorithms', 'implementation', 'sortings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Red-Blue Matrix.json,https://codeforces.com//blog/entry/96454,Imagine you fixed some cut and then colored one row red Which rows can now be colored red or blue so that the condition on the left matrix is satisfied If the row has at least one number greater or equal than the numbers in the red row then the row must be red Otherwise it can be either red or blue However imagine a weaker condition Let s look only at the first cell in each row Sort the rows by the first cell in them Similarly if a row is colored red all the rows that are further in the sorted order should also be red because they already have a greater or equal number in them It implies that after you sort the rows the only possible colorings are color some prefix of the rows in blue and the remaining suffix in red So there are possible colorings and possible cuts If we learn to check if they are perfect in we can get the solution in Turns out the condition all numbers in the submatrix should be greater than all numbers in the other submatrix is the same as the minimum in the first submatrix should be greater than the maximum in the second submatrix Thus you can first precalculate prefix and suffix minimums and maximums and check a coloring and a cut in Overall complexity per testcase 
https://codeforces.com//contest/193/problem/D,1407,D,193D,193,D. Two Segments,Nick has some permutation consisting of integers from to A segment is a set of elements satisfying Nick calls a pair of segments and good if all their elements when sorted in ascending order form an arithmetic progression with a difference of That is when they sorted in ascending order the elements are in the form for some and Your task is to find the number of distinct pairs of good segments in the given permutation Two pairs of segments are considered distinct if the sets of elements contained in these pairs of segments are distinct For example any segment can be represented as a pair of segments as and As all these pairs consist of the same set of elements they are considered identical See the notes accompanying the sample tests for clarification ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nclass Solver {\n  struct Data {\n    pii vals[3];\n\n    Data() { for (int i = 0; i < 3; i++) vals[i] = mp(INF, 0); }\n    Data(int x) { for (int i = 1; i < 3; i++) vals[i] = mp(INF, 0); vals[0] = mp(x, 1); }\n    void operator+=(const Data &d2) {\n      int p1 = 0, p2 = 0;\n      pii vals2[3];\n\n      for (int p3 = 0; p3 < 3; p3++) {\n        assert(p1 < 3 && p2 < 3);\n        int cmp = vals[p1].first - d2.vals[p2].first;\n        if (cmp < 0) vals2[p3] = vals[p1++];\n        else if (cmp > 0) vals2[p3] = d2.vals[p2++];\n        else {\n          vals2[p3] = mp(vals[p1].first, vals[p1].second + d2.vals[p2].second);\n          p1++; p2++;\n        }\n      }\n      for (int i = 0; i < 3; i++) vals[i] = vals2[i];\n    }\n  };\n\n  vector<Data> tr;\n  vi tradd;\n  int off;\n\n  void norm(int v) {\n    if (!tradd[v]) return;\n    if (v < off) {\n      tradd[2 * v] += tradd[v];\n      tradd[2 * v + 1] += tradd[v];\n    }\n    for (int i = 0; i < 3; i++) tr[v].vals[i].first += tradd[v];\n    tradd[v] = 0;\n  }\n\n  int lr, rr, vr;\n  void _add(int v, int lt, int rt) {\n    if (rt < lr || rr < lt) return;\n    if (lr <= lt && rt <= rr) {\n      tradd[v] += vr;\n      return;\n    }\n    norm(v);\n    int mt = (lt + rt) / 2;\n    _add(2 * v, lt, mt); norm(2 * v);\n    _add(2 * v + 1, mt + 1, rt); norm(2 * v + 1);\n    tr[v] = tr[2 * v];\n    tr[v] += tr[2 * v + 1];\n  }\n\n  public:\n  Solver(int n) {\n    off = 1; while (off < n) off <<= 1;\n    tr = vector<Data>(2 * off);\n    tradd = vi(2 * off, 0);\n\n    for (int i = 0; i < n; i++) {\n      tr[off + i] = 0;\n    }\n    for (int i = off - 1; i >= 1; i--) {\n      tr[i] = tr[2 * i];\n      tr[i] += tr[2 * i + 1];\n    }\n  }\n  int calc() {\n    norm(1);\n    int ans = 0;\n    for (int i = 0; i < 3; i++) {\n      assert(tr[1].vals[i].first >= 0);\n      assert(tr[1].vals[i].second >= 0);\n      if (tr[1].vals[i].first <= 2)\n        ans += tr[1].vals[i].second;\n    }\n    return ans;\n  }\n  void add(int l, int r, int v) {\n    lr = l; rr = r; vr = v;\n    return _add(1, 0, off - 1);\n  }\n};\n\nconst int MAXN = 3e5 + 1e3;\nint n;\nint as[MAXN], pos[MAXN];\n\ninline int calcNeigh(int x, int l) {\n  int cp = pos[x];\n  int ans = 0;\n  if (cp > 0) ans += as[cp - 1] >= l && as[cp - 1] < as[cp];\n  if (cp + 1 < n) ans += as[cp + 1] >= l && as[cp + 1] < as[cp];\n  return ans;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(""std.in"", ""r"", stdin);\n  freopen(""std.out"", ""w"", stdout);\n  #endif\n\n  while (scanf(""%d"", &n) >= 1) {\n    for (int i = 0; i < n; i++)\n      scanf(""%d"", &as[i]), pos[--as[i]] = i;\n\n    ll ans = 0;\n    Solver s(n);\n    {\n      for (int r = 0; r < n; r++)\n        s.add(r, n - 1, -calcNeigh(r, 0) + 1);\n    }\n    for (int l = 0; l < n; l++) {\n      ans += s.calc() - 1 - l;\n      s.add(l, n - 1, calcNeigh(l, l) - 1);\n\n      for (int x = max(0, pos[l] - 1); x < n && x <= pos[l] + 1; x++) if (as[x] != l) {\n        int r = as[x];\n        int oval = -calcNeigh(r, l) + 1;\n        int nval = -calcNeigh(r, l + 1) + 1;\n        s.add(r, n - 1, nval - oval);\n      }\n    }\n    printf(""%I64d\\n"", ans);\n  }\n  return 0;\n}\n']",,,['data structures'],2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Two Segments.json,https://codeforces.com//blog/entry/4673,Main idea inverse the permutation and solve simplified problem see below consider function quantity of segments of permutation that form the given segment of natural series In order to solve this problem we suggest solve another we have a permutation pn we have to calculate the count of segments such that their elements form one or two segments of natural series If we solve the inverse problem for some permutation qn such that we shall get the answer for the initial problem and initial permutation pi Straight forward algo let s bruteforce the segment of permutation and mark its elements in a boolean array Check that in that array there is not more than two marked segments This algo has complexity O n3 Let s notice that during the changeover from l r to l r 1 the quantity of segments changes in some predictable way Let s a b be quantity of segments that form segment a b of permutation There are three cases see picture below If the new element pr 1 is between two marked elements that is both elements with values pr 1 1 and pr 1 1 belong to segment l r then s l r 1 s l r 1 The new element will the segments near it If the new element pr 1 has only one neighbor with value belonging to l r then s l r 1 s l r The new element will lengthen one of existing segments If there are no marked elements near pr 1 the new element forms a new segment s l r 1 s l r 1 The new element is red elements that are marked to this moment are black Improved algo Let s bruteforce position of the left border and for each instance move the right border from left to right During each move we shall recount the actual quantity of segments forming the current segment of permutation s l r Now we have a solution in complexity O n2 It works fast enough even when n 20000 Obviously that is not enough to get AC Move on full solution It is based on previous Now we can calc s l r using s l r 1 Now we should look at way of changing s l 1 r as compared with s l r Let s move left border of segment from the right to left and support some data structure with s l i for every i satisfying l i n and current l This structure should answer queries count numbers 1 and 2 in structure that is count segments l i that generates one or two segments in the original permutaton Let i be s l 1 i s l i l will be equal to 1 because one element form one segment in permutation notice that in final answer we must not consider 1 element segments that s why we must subtract n from answer in the end of solution i determined by the number of neighbors of element l 1 in the segment l 1 i Neighbors of l 1 is elements pl 1 1 and pl 1 1 if they re exist If l 1 hasn t neighbors in this segment i 1 because l 1 froms new 1 element segment If l 1 has one neighbor in this segment i 0 because l 1 join to existing segment of its neighbor If l 1 has two neighbors in this segment i 1 because l 1 connect segments of its neighbors Number of neighbors in segment l 1 i non decreasing with increasing i That s why i non decreasing with increasing i That means that there are only three segments of equivalence of i We are interested only in neighbors of l 1 which positions are right than l 1 Let a is position of first neighbor b is position of second neighbor without loss of generality a b Then elements of permutation are numbered from 0 If a and b aren t exist for all i 1 If only b isn t exist for for Look at example to clear your understanding i is in top right corners l 3 pl 5 Using this facts we can code data structure support following operations Add 1 or 1 on segment Calc number of 1 and 2 in the structure Sum of answers of structure in every iteration for every l is answer to problem Let s notice that all numbers in structure will be positive That s why elements 1 and 2 will be minimal of pre minimal in the structure Using this fact we can code segment tree supports these operations 
https://codeforces.com//contest/439/problem/E,10098,E,439E,439,E. Devu and Birthday Celebration,Today is Devu s birthday For celebrating the occasion he bought sweets from the nearby market He has invited his friends He would like to distribute the sweets among them As he is a nice guy and the occasion is great he doesn t want any friend to be sad so he would ensure to give at least one sweet to each friend He wants to celebrate it in a unique style so he would like to ensure following condition for the distribution of sweets Assume that he has distributed sweets to his friends such that friend is given sweets He wants to make sure that there should not be any positive integer which divides every Please find the number of ways he can distribute sweets to his friends in the required way Note that the order of distribution is important for example 1 2 and 2 1 are distinct distributions As the answer could be very large output answer modulo To make the problem more interesting you are given Each query contains an pair For each query please output the required number of ways modulo ,"['#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<""OK"";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 200100\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(""a.in"");\nofstream g(""a.out"");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nll S;\nint divu[N],n,di,val,aux,t,q,lim,po,nrb,nf;\nll I[N],F[N],adn;\nll put(ll a,ll p)\n{\n    ll sol=1;\n    while(p)\n    {\n        if(p&1)\n            sol=sol*a%mod;\n        a=a*a%mod;\n        p>>=1;\n    }\n    return sol;\n}\nll C(int a,int b)\n{\n    return F[a]*I[b]%mod*I[a-b]%mod;\n}\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(""a.in"",""r"",stdin);\n    freopen(""a.out"",""w"",stdout);\n    #endif\n    \n    F[0]=1;\n    FOR(i,1,200001)\n    F[i]=F[i-1]*i%mod;\n    I[200001]=put(F[200001],mod-2);\n    ROF(i,200000,0)\n    I[i]=I[i+1]*(i+1)%mod;\n    \n    f>>q;\n    \n    while(q--)\n    {\n        f>>n>>nf;\n        aux=n;\n        t=0;\n        for(int i=2;i*i<=aux;++i)\n            if(aux%i==0)\n            {\n                divu[++t]=i;\n                while(aux%i==0)\n                    aux/=i;\n            }\n        if(aux!=1)\n            divu[++t]=aux;\n        lim=(1<<t);\n        lim--;\n        S=0;\n        FOR(i,1,lim)\n        {\n            aux=i;\n            nrb=0;\n            po=0;\n            di=1;\n            while(aux)\n            {\n                ++po;\n                if(aux&1)\n                {\n                    nrb++;\n                    di*=divu[po];\n                }\n                aux>>=1;\n            }\n            if(n/di<nf)\n                continue;\n            val=n/di;\n            val-=nf;\n            adn=C(nf+val-1,nf-1);\n            if(nrb&1)\n                S+=adn;\n            else\n                S-=adn;\n            if(S>=mod)\n                S-=mod;\n            if(S<0)\n                S+=mod;\n        }\n        S=-S;\n        if(S<0)\n            S+=mod;\n        n-=nf;\n        S+=C(nf+n-1,nf-1);\n        if(S>=mod)\n            S-=mod;\n        g<<S<<""\\n"";\n    }\n    \n    return 0;\n}']",,,"['combinatorics', 'dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Devu and Birthday Celebration.json,https://codeforces.com//blog/entry/12545,There are two possible solutions dp solution Let be total number of ways of partitioning into segments such that each is positive With some manipulations of the generating function you can find that this is equal to So Let denotes partitions of into parts such that gcd of all the is Note that sum of over all possible gcd So will be a divisor of In other words As You can implement this solution by a simple dp You can pre calculate factorials which will help you to calculate Complexity of this solution will be over all the test cases Please note that this solution might get time limit exceeded in Java Please read the comment Mathematical solution Note that sum of over all possible gcd such that is a divisor of In other words As Now you have to use M bius inversion formula Theorem If and are two arithmetic functions satisfying then So In our case is and is For proving complexity Use the fact that total number of divisors of a number from to is Please also see xorfire comment for understanding the relation between mobius function and the solution using inclusion exclusion principle Solution Codes 
https://codeforces.com//contest/1671/problem/F,1376220,F,1671F,1671,F. Permutation Counting,Calculate the number of permutations p of size n with exactly k inversions pairs of indices i j such that i j and p i p j and exactly x indices i such that p i p i 1 Yep that s the whole problem Good luck ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:46:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n\n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    for (int i = n - 1; i >= m - 1; i--) {\n      Mint c = a.back() / b.back();\n      for (int j = 0; j < m; j++) {\n        a[i - (m - 1) + j] -= b[j] * c;\n      }\n      a.pop_back();\n    }\n/*    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }*/\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<T> BM(vector<T> a) {\n  vector<T> p = {1};\n  vector<T> q = {1};\n  int l = 0;\n  for (int r = 1; r <= (int) a.size(); r++) {\n    T delta = 0;\n    for (int j = 0; j <= l; j++) {\n      delta += a[r - 1 - j] * p[j];\n    }\n    q.insert(q.begin(), 0);\n    if (delta != 0) {\n      vector<T> t = p;\n      if (q.size() > t.size()) {\n        t.resize(q.size());\n      }\n      for (int i = 0; i < (int) q.size(); i++) {\n        t[i] -= delta * q[i];\n      }\n      if (2 * l <= r - 1) {\n        q = p;\n        T od = 1 / delta;\n        for (T& x : q) {\n          x *= od;\n        }\n        l = r - l;\n      }\n      swap(p, t);\n    }\n  }\n  assert((int) p.size() == l + 1);\n//  assert(l * 2 + 30 < (int) a.size());\n  reverse(p.begin(), p.end());\n  return p;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = 111;\n  vector<vector<vector<vector<Mint>>>> f(N, vector<vector<vector<Mint>>>(N, vector<vector<Mint>>(12, vector<Mint>(12))));\n  f[1][0][0][0] = 1;\n  for (int n = 1; n < N - 1; n++) {\n    for (int p = 0; p < n; p++) {\n      for (int k = 0; k <= 11; k++) {\n        for (int x = 0; x <= 11; x++) {\n          for (int t = 0; t <= n; t++) {\n            int nk = k + (n - t);\n            int nx = x + (t <= p);\n            if (nk <= 11 && nx <= 11) {\n              f[n + 1][t][nk][nx] += f[n][p][k][x];\n            }\n          }\n        }\n      }\n    }\n  }\n  vector<vector<vector<Mint>>> r(12, vector<vector<Mint>>(12));\n  vector<vector<vector<Mint>>> vecs(12, vector<vector<Mint>>(12));\n  for (int k = 1; k <= 11; k++) {\n    for (int x = 1; x <= 11; x++) {\n      vector<Mint>& vec = vecs[k][x];\n      for (int n = 1; n < N; n++) {\n        Mint s = 0;\n        for (int p = 0; p < n; p++) {\n          s += f[n][p][k][x];\n        }\n        vec.push_back(s);\n      }\n      r[k][x] = BM(vec);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k, x;\n    cin >> n >> k >> x;\n    auto y = power(vector<Mint>{0, 1}, n - 1, r[k][x]);\n    Mint ans = 0;\n    for (int i = 0; i < (int) y.size(); i++) {\n      ans += y[i] * vecs[k][x][i];\n    }\n    cout << ans << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']",,,"['brute force', 'combinatorics', 'dp', 'fft', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Permutation Counting.json,https://codeforces.com//blog/entry/102181,A lot of solutions which were written during the contest use Berlekamp Messey or some other algorithms related to analyzing linear recurrences but the model solution is based on other principles First of all if the number of inversions is at most it means that most elements of the permutation will stay at their own places and those which don t stay at their places can t be too far away from them Let s denote a block in a permutation as a segment of indices such that all elements less than are to the left of the block all elements greater than are to the right of the block all elements from belong to the block Let s say that a block is non trivial if it contains at least two elements Suppose we split a permutation into the maximum number of blocks Then for each block we can see that if its length is it has at least inversions to prove it you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation and if we cannot split the block into other blocks it means that we have to swap each pair of adjacent elements in it at least once to sort it if the block is non trivial it has at least one such that From these two facts we can see that there will be at most non trivial blocks there will be at most elements in total belonging to non trivial blocks the maximum possible length of a block is The main idea of the solution is to calculate the following dynamic programming is the number of ways to split elements into non trivial blocks such that there are exactly inversions in them and exactly pairs Then to get the answer for the test case we can iterate on the number of non trivial blocks and the number of elements in them and choose the elements belonging to that blocks with a binomial coefficient The only thing that s left is how to calculate this dynamic programming efficiently There are a few ways to do it but the model solution uses a table the number of different non trivial blocks of length with elements and inversions to handle transitions This table is not very big so you can run an exhaustive search for minutes to calculate it and then just paste its results into the source code of your program Note that you have to make sure that you consider only the blocks which cannot be split any further 
https://codeforces.com//contest/1404/problem/B,718462,B,1404B,1404,B. Tree Tag,Alice and Bob are playing a fun game of tree tag The game is played on a tree of n vertices numbered from 1 to n Recall that a tree on n vertices is an undirected connected graph with n 1 edges Initially Alice is located at vertex a and Bob at vertex b They take turns alternately and Alice makes the first move In a move Alice can jump to a vertex with distance da from the current vertex And in a move Bob can jump to a vertex with distance db from the current vertex The distance between two vertices is defined as the number of edges on the unique simple path between them In particular either player is allowed to stay at the same vertex in a move Note that when performing a move a player only occupies the starting and ending vertices of their move not the vertices between them If after at most 10 100 moves Alice and Bob occupy the same vertex then Alice is declared the winner Otherwise Bob wins Determine the winner if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//AGC33 C\ntemplate<class E>\nstruct treediameter{\n\tconst vvc<E>&g;\n\tint r1,r2;\n\tvi d1,d2;\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vi&d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vvc<E>&gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(all(d1))-d1.bg;\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(all(d1))-d1.bg;\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tint a,b,c,d;cin>>a>>b>>c>>d;\n\ta--;b--;\n\tauto t=readTree(n);\n\t\n\tint dia=treediameter<int>(t).dia;\n\tchmin(c,dia);\n\tchmin(d,dia);\n\t\n\tconst string Alice=""Alice\\n"";\n\tconst string Bob=""Bob\\n"";\n\t\n\tauto dfs=[&](auto self,int v,int p,int dist)->int{\n\t\tif(v==b)return dist;\n\t\tfor(auto to:t[v])if(to!=p){\n\t\t\tint w=self(self,to,v,dist+1);\n\t\t\tif(w!=-1)return w;\n\t\t}\n\t\treturn int(-1);\n\t};\n\tint ini=dfs(dfs,a,-1,0);\n\tif(ini<=c){\n\t\tdmp(ini);\n\t\tcout<<Alice;\n\t\treturn;\n\t}\n\t\n\tif(c*2>=d){\n\t\tdmp2(c,d);\n\t\tcout<<Alice;\n\t\treturn;\n\t}\n\t\n\tcout<<Bob;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;\n\trep(_,t)slv();\n}\n']",,,"['dfs and similar', 'dp', 'games', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Tree Tag.json,https://codeforces.com//blog/entry/82366,Let s consider several cases independently Case 1 dist a b da Unsurprisingly Alice wins in this case by tagging Bob on the first move Case 2 2da tree diameter Here the diameter of a tree is defined as the length of the longest simple path In this case Alice can move to a center of the tree Once Alice is there it doesn t matter where Bob is since Alice can reach any vertex in the tree in just one move winning the game Case 3 db 2da In this case let s describe a strategy for Bob to win Because we are not in case 1 Bob will not lose before his first move Then it is sufficient to show that Bob can always end his turn with distance greater than da from Alice Since we are not in case 2 there is at least one vertex with distance at least da from Alice If Bob is at such a vertex at the start of his turn he should simply stay there Otherwise there is some vertex v with dist a v da 1 Then dist b v dist b a dist a v da da 1 2da 1 db so Bob can jump to v on his turn Case 4 db 2da In this case Alice s strategy will be to capture Bob whenever possible or move one vertex closer to Bob otherwise Let s prove that Alice will win in a finite number of moves with this strategy Let s root the tree at a Bob is located in some subtree of a say with k vertices Alice moves one vertex deeper decreasing Bob s subtree size by at least one vertex Since db 2da Bob cannot move to another subtree without being immediately captured so Bob must stay in this shrinking subtree until he meets his inevitable defeat Solution The only non trivial part in the implementation is checking for cases 1 and 2 Case 1 is simply checked with DFS Case 2 only requires computing the diameter of the tree which is a standard problem 
https://codeforces.com//contest/2021/problem/E1,2929696,E1,2021E1,2021,E1. Digital Village  Easy Version ,Pak Chanek is setting up internet connections for the village of Khuntien The village can be represented as a connected simple graph with n houses and m internet cables connecting house u i and house v i each with a latency of w i There are p houses that require internet Pak Chanek can install servers in at most k of the houses The houses that need internet will then be connected to one of the servers However since each cable has its latency the latency experienced by house s i requiring internet will be the latency of the cables between that house and the server it is connected to For each k 1 2 ldots n help Pak Chanek determine the minimum latency that can be achieved for all the houses requiring internet ,"['#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<\'0\'||ch>\'9\') f|=(ch==\'-\'),ch=getchar();\twhile(ch>=\'0\'&&ch<=\'9\') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}struct Edge{int u,v,w;}l[200010];bool operator<(Edge A,Edge B){return A.w<B.w;}int n,m,p;int rt,fa[200010],siz[200010],cnt[200010];int get_fa(int a){return a==fa[a]?a:fa[a]=get_fa(fa[a]);}long long bas[200010],del,tk;vector<long long> S[200010],tmp;void solve(){\tmemset(cnt,0,(n+1)<<2),memset(bas,0,(n+1)<<2);\xa0\tn=Qread(),m=Qread(),p=Qread();\tfor(int i=1;i<=p;i++) cnt[Qread()]=1;\xa0\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=1,S[i].resize(2,0ll);\xa0\tfor(int i=1;i<=m;i++) l[i].u=Qread(),l[i].v=Qread(),l[i].w=Qread();\tsort(l+1,l+m+1);\xa0\tfor(int i=1,u,v;i<=m;i++) if(get_fa(l[i].u)!=get_fa(l[i].v))\t{\t\tu=get_fa(l[i].u),v=get_fa(l[i].v);\t\tif(siz[u]<siz[v]) swap(u,v);\xa0\t\tS[u][0]=1ll*cnt[u]*l[i].w,\t\tS[v][0]=1ll*cnt[v]*l[i].w;\xa0\t\ttmp.resize(siz[u]+siz[v]+1,0x3f3f3f3f3f3f3f3f);\t\tfor(int i=0;i<=siz[u];i++)\t\tfor(int j=0;j<=siz[v];j++)\t\t\ttmp[i+j]=min(tmp[i+j],S[u][i]+S[v][j]);\xa0\t\tfa[v]=u,siz[u]+=siz[v],cnt[u]+=cnt[v],bas[u]+=bas[v];\t\tswap(S[u],tmp);\t\tvector<long long>().swap(tmp);\t\tvector<long long>().swap(S[v]);\t}\trt=get_fa(1);\tfor(int i=1;i<=n;i++)\t\tprintf(""%lld "",S[rt][i]);\tprintf(""\\n"");\xa0\tvector<long long>().swap(S[rt]);}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}']",,,"['brute force', 'data structures', 'dfs and similar', 'dp', 'dsu', 'fft', 'graphs', 'greedy', 'implementation', 'math', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Digital Village  Easy Version .json,https://codeforces.com//blog/entry/134873,Since the cost of a path uses the maximum edge weight in the path we can use a Kruskal like algorithm that is similar to finding the MST Minimum Spanning Tree Initially the graph has no edges and we add each edge one by one starting from the smallest values of wi while maintaining the connected components in the graph using DSU Disjoint Set Union While doing the MST algorithm we simultaneously construct the reachability tree of the graph whose structure represents the sequence of mergings of connected components in the algorithm Each vertex in the reachability tree corresponds to some connected component at some point in time in the algorithm Each non leaf vertex in the reachability tree always has two children which are the two connected components that are merged to form the connected component represented by that vertex so every time two connected components merge in the algorithm we make a new vertex in the reachability tree that is connected to its two corresponding children After doing all that we ve constructed a reachability tree that is a rooted binary tree with 2n 1 vertices n of which are leaves For each non leaf vertex x we write down weight x which is the weight of the edge that forms its connected component For each leaf we mark it as special if and only if it corresponds to a house that needs internet Then for each vertex x we calculate cnt x which is the number of special leaves in the subtree of x These values will be used later Consider a non leaf x in the reachability tree It can be obtained that two vertices in the original graph corresponding to any two leaves in the subtree of x can have a path between them in the original graph with a weight of at most weight x Let s solve for some value of k For each special vertex x we want to choose a target vertex y that s an ancestor of x Then we choose a set of k leaves for the houses with installed servers We want it such that each chosen target has at least one leaf in its subtree that is a member of the set The total path cost of this is the sum of weight y for all chosen targets y Let s say we ve fixed the set of k leaves Then we mark every ancestor of these leaves If we only consider the marked vertices with the edges between them we have a reduced tree For each special leaf we want to choose its nearest ancestor that is in the reduced tree for its target to get the one with the smallest weight Knowing this we can solve the problem in another point of view Initially we have the original reachability tree We want to reduce it into a reduced tree with k leaves We want to do it while maintaining the chosen targets of the special leaves and their costs Initially for each special leaf we choose itself as its target In one operation we can do the following Choose a vertex that s currently a leaf Move every target that s currently in that leaf to its parent Remove that leaf and the edge connecting it to its parent We want to do that until the reduced tree has k leaves For each edge connecting a vertex x to its parent y in the reachability tree calculate weight y weight x cnt x That is the cost to move every target in vertex x to vertex y Define that as the edge s length We want to do operations with the minimum cost so that the reduced tree has k leaves We want to minimize the sum of lengths of the deleted edges If we look at it in a different way we want to choose edges to be in the reduced tree with the maximum sum of lengths For some value of k the edges of the reduced tree can be decomposed into k paths from some vertex to its descendant We want the total sum of lengths of these paths to be as big as possible But how do we solve it for every k from 1 to n Let s say k 1 We can choose the path from the root to its furthest leaf How do we solve for k 2 onwards It turns out that we can use the optimal solution for some value of k to make the optimal solution for k 1 by just adding the longest possible available path That means for each k from 1 to n we just find the current longest available path and add it to our reduced tree What if at some point there are more than one possible longest paths It can be proven that we can choose any of these paths and the optimal solutions for the next values of k will still be optimal The proof for this greedy strategy involves the convexity of the total length as k goes from 1 to n However we won t explain it in detail here So to solve the problem we do DFS in the reachability tree to calculate for each vertex x the furthest leaf and the second furthest leaf in its subtree For each k from 1 to n we add the current longest available path using this precalculation Time complexity O nlogn mlogm 
https://codeforces.com//contest/1061/problem/E,259561,E,1061E,1061,E. Politics,There are n cities in the country Two candidates are fighting for the post of the President The elections are set in the future and both candidates have already planned how they are going to connect the cities with roads Both plans will connect all cities using n 1 roads only That is each plan can be viewed as a tree Both of the candidates had also specified their choice of the capital among n cities x for the first candidate and y for the second candidate which may or may not be same Each city has a potential of building a port one city can have at most one port Building a port in i th city brings a i amount of money However each candidate has his specific demands The demands are of the form k x which means that the candidate wants to build exactly x ports in the subtree of the k th city of his tree the tree is rooted at the capital of his choice Find out the maximum revenue that can be gained while fulfilling all demands of both candidates or print if it is not possible to do It is additionally guaranteed that each candidate has specified the port demands for the capital of his choice ,"['#include<cstdio>\n#include<limits>\n#include<functional>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nstruct MinCostFlow\n{\n    typedef int cap_t;\n    typedef long long cost_t;\n\n    bool iszerocap(cap_t cap) { return cap == 0; }\n\n    struct edge {\n        int target;\n        cost_t cost;\n        cap_t residual_capacity;\n        cap_t orig_capacity;\n        int revid;\n    };\n\n    vector<vector<edge>> graph;\n    int n;\n    vector<cost_t> pi;\n    bool needNormalize;\n\n    MinCostFlow(int n) : graph(n), n(n), pi(n, 0), needNormalize(false) {}\n    // 한참 돌리던 중간에 추가하는 경우는 고려 안 함\n    void addEdge(int s, int e, cost_t cost, cap_t cap)\n    {\n        int forward_rev = graph[e].size() + ((s == e) ? 1 : 0);\n        int backward_rev = graph[s].size();\n        edge forward = { e, cost, cap, cap, forward_rev };\n        edge backward = { s, -cost, 0, 0, backward_rev };\n        if (cost < 0) {\n            needNormalize = true;\n        }\n        graph[s].emplace_back(forward);\n        graph[e].emplace_back(backward);\n    }\n\n    bool normalize(int s) {\n        auto infinite_cost = numeric_limits<cost_t>::max();\n        vector<cost_t> dist(n, infinite_cost);\n        dist[s] = 0;\n        queue<int> q;\n        vector<int> v(n), relax_count(n);\n        v[s] = 1; q.push(s);\n        while (!q.empty()) {\n            int cur = q.front();\n            v[cur] = 0; q.pop();\n            if (++relax_count[cur] >= n) return false;\n            for (const auto &e : graph[cur]) {\n                if (iszerocap(e.residual_capacity)) continue;\n                auto next = e.target;\n                auto ncost = dist[cur] + e.cost;\n                if (dist[next] > ncost) {\n                    dist[next] = ncost;\n                    if (v[next]) continue;\n                    v[next] = 1; q.push(next);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) pi[i] = dist[i];\n        return true;\n    }\n\n    pair<cost_t, cap_t> augmentShortest(int s, int e, cap_t flow_goal, cap_t flow_limit) {\n        auto infinite_cost = numeric_limits<cost_t>::max();\n        auto infinite_flow = numeric_limits<cap_t>::max();\n        typedef pair<cost_t, int> pq_t;\n        priority_queue<pq_t, vector<pq_t>, greater<pq_t>> pq;\n        vector<pair<cost_t, cap_t>> dist(n, make_pair(infinite_cost, 0));\n        vector<int> from(n, -1), v(n);\n\n        if (needNormalize) {\n            normalize(s);\n            needNormalize = false;\n        }\n\n        dist[s] = pair<cost_t, cap_t>(0, infinite_flow);\n        pq.emplace(dist[s].first, s);\n        while (!pq.empty()) {\n            auto cur = pq.top().second; pq.pop();\n            if (v[cur]) continue;\n            v[cur] = 1;\n            for (const auto &edge : graph[cur]) {\n                auto next = edge.target;\n                if (v[next]) continue;\n                if (iszerocap(edge.residual_capacity)) continue;\n                auto ncost = dist[cur].first + edge.cost - pi[next] + pi[cur];\n                auto nflow = min(dist[cur].second, edge.residual_capacity);\n                if (dist[next].first <= ncost) continue;\n                dist[next] = make_pair(ncost, nflow);\n                from[next] = edge.revid;\n                pq.emplace(dist[next].first, next);\n            }\n        }\n        /** augment the shortest path **/\n        /* update potential, dist[i].first becomes invalid */\n        for (int i = 0; i < n; i++) {\n            if (iszerocap(dist[i].second)) continue;\n            pi[i] += dist[i].first;\n        }\n        auto flow = dist[e].second;\n        // e is unreachable\n        if (iszerocap(flow)) return make_pair(0, 0);\n        // reduced cost of augment path is 0, actual cost is potential difference\n        auto pathcost = pi[e] - pi[s];\n        // always restrict\n        flow = min(flow, flow_limit);\n        // if it costs, we want minimum flow\n        if (pathcost >= 0) flow = min(flow, flow_goal);\n        if (flow <= 0 || iszerocap(flow)) return make_pair(0, 0);\n\n        for (auto cur = e; from[cur] != -1; ) {\n            auto back_edge = from[cur];\n            auto prev = graph[cur][back_edge].target;\n            auto forward_edge = graph[cur][back_edge].revid;\n            graph[cur][back_edge].residual_capacity += flow;\n            graph[prev][forward_edge].residual_capacity -= flow;\n            cur = prev;\n        }\n        return make_pair(pathcost * flow, flow);\n    }\n\n    pair<cost_t, cap_t> solve(int s, int e, cap_t flow_goal = numeric_limits<cap_t>::max(), cap_t flow_limit = numeric_limits<cap_t>::max()) {\n        cost_t total_cost = 0;\n        cap_t total_flow = 0;\n        for (;;) {\n            auto res = augmentShortest(s, e, flow_goal - total_flow, flow_limit - total_flow);\n            if (res.second <= 0) break;\n            total_cost += res.first;\n            total_flow += res.second;\n        }\n        return make_pair(total_cost, total_flow);\n    }\n};\n\nvector<int> g[2][501];\nint R[2];\nint demand[2][501];\n\nvoid dfs1(vector<pair<int,int>>& out, int cand, int u, int p){\n    if(demand[cand][u]){\n        out.push_back({u, demand[cand][u]});\n        return;\n    }\n\n    for(int v:g[cand][u]) if(v!=p){\n        dfs1(out, cand, v, u);\n    }\n}\n\nvector<pair<int,vector<int>>> D[2];\n\nbool block[501];\nvoid dfs2(vector<int>& out, int cand, int u, int p){\n    if(block[u]) return;\n    out.push_back(u);\n    for(int v:g[cand][u]) if(v!=p) dfs2(out, cand, v, u);\n}\n\nvoid dfs0(int cand, int u, int p){\n    if(demand[cand][u]){\n        vector<pair<int,int>> c_demand;\n        for(int v:g[cand][u]) if(v!=p)\n            dfs1(c_demand, cand, v, u);\n        int dsum = 0;\n        for(const auto& elt:c_demand){\n            dsum += elt.second;\n        }\n\n        for(const auto& elt:c_demand){\n            block[elt.first] = true;\n        }\n\n        vector<int> c;\n        dfs2(c, cand, u, p);\n\n        for(const auto& elt:c_demand){\n            block[elt.first] = false;\n        }\n\n        D[cand].push_back({demand[cand][u]-dsum, c});\n    }\n\n    for(int v:g[cand][u]) if(v!=p){\n        dfs0(cand, v, u);\n    }\n}\n\nint A[501];\n\nint main(){\n    int N; scanf(""%d%d%d"",&N,R+0,R+1);\n    for(int i=1;i<=N;i++) scanf(""%d"", A+i);\n\n    for(int cand=0;cand<2;cand++) for(int i=1;i<N;i++){\n        int u,v; scanf(""%d%d"",&u,&v);\n        g[cand][u].push_back(v);\n        g[cand][v].push_back(u);\n    }\n\n    for(int cand=0;cand<2;cand++){\n        int Q; scanf(""%d"",&Q);\n        for(int i=0;i<Q;i++){\n            int u, t; scanf(""%d%d"",&u,&t);\n            if(demand[cand][u]){\n                if(demand[cand][u]!=t) return !printf(""-1"");\n            }\n            demand[cand][u] = t;\n        }\n    }\n\n    for(int cand=0;cand<2;cand++) dfs0(cand, R[cand], 0);\n    MinCostFlow mcf(2+D[0].size()+D[1].size()+N);\n\n    int Tsum = 0, Ssum = 0;\n    int T = D[0].size();\n    for(int i=0;i<D[0].size();i++){\n        const auto& elt = D[0][i];\n        if(elt.first < 0) return !printf(""-1"");\n        Tsum += elt.first;\n\n        mcf.addEdge(0,N+1+i,0,elt.first);\n        for(int u:elt.second) mcf.addEdge(N+1+i, u, -A[u], 1);\n    }\n    int S = D[1].size();\n    for(int i=0;i<D[1].size();i++){\n        const auto& elt = D[1][i];\n        if(elt.first < 0) return !printf(""-1"");\n        Ssum += elt.first;\n\n        mcf.addEdge(N+T+1+i, N+T+S+1, 0, elt.first);\n        for(int u:elt.second) mcf.addEdge(u, N+T+1+i, 0, 1);\n    }\n    if(Tsum!=Ssum) return !printf(""-1"");\n\n    auto res = mcf.solve(0, N+S+T+1);\n\n    if(res.second != Tsum) return !printf(""-1"");\n    printf(""%lld\\n"", -res.first);\n}\n']",,,"['flows', 'graphs']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Politics.json,https://codeforces.com//blog/entry/63384,Let s create a graph with a source sink and two layers Let the left layer denote the nodes of tree and right layer denote the nodes of tree Let s denote as the demand of the node For a demand in tree 1 we add an edge from source to node in the left layer with and such that is not equal to and belongs to the subtree of Similarly for a demand in tree 2 we add an edge from node in the right layer to sink with and such that is not equal to and belongs to the subtree of Now for every node let be the closest node to such that belongs to subtree of and the demand of in tree has been provided Similarly be the closest node to such that belongs to subtree of and the demand of in tree has been provided For every node we add an edge from in left layer to in right layer with and Now when we run min cost max flow on this graph our answer will be negative of the minimum cost obtained Overall Complexity using MCMF with bellman ford using MCMF with Dijkstra 
https://codeforces.com//contest/1004/problem/B,195378,B,1004B,1004,B. Sonya and Exhibition,Sonya decided to organize an exhibition of flowers Since the girl likes only roses and lilies she decided that only these two kinds of flowers should be in this exhibition There are n flowers in a row in the exhibition Sonya can put either a rose or a lily in the i th position Thus each of n positions should contain exactly one flower a rose or a lily She knows that exactly m people will visit this exhibition The i th visitor will visit all flowers from l i to r i inclusive The girl knows that each segment has its own that is equal to the product of the number of roses and the number of lilies Sonya wants her exhibition to be liked by a lot of people That is why she wants to put the flowers in such way that the sum of of all segments would be maximum possible ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PA;\ntypedef long long LL;\n\n#define MAXN 200003\n#define MODP 1000000007\n#define FST first\n#define SCD second\n\n\nLL qpow(LL x, int y) {\n\tLL res = 1;\n\tfor (;y>0;y>>=1, x = x*x%MODP) {\n\t\tif (y&1) res = (res*x)%MODP;\n\t}\n\treturn res;\n}\n\nint q[200];\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.txt"", ""r"", stdin);\n\t#endif\n\tint Tn = 1;\n\t// scanf(""%d"", &Tn);\n\tfor (int ci=1;ci<=Tn;++ci) {\n\t\tint n;\n\t\tcin>>n;\n\t\tfor (int i=0;i<n;++i) \n\t\t\tprintf(""%d"", i&1);\n\t\tputs("""");\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Sonya and Exhibition.json,https://codeforces.com/blog/entry/60443,Note that it is always optimal to use roses in even positions and lilies in odd positions That is the string is always optimal 
https://codeforces.com//contest/593/problem/A,40047,A,593A,593,A. 2Char,Andrew often reads articles in his favorite magazine 2Char The main feature of these articles is that each of them uses at most two distinct letters Andrew decided to send an article to the magazine but as he hasn t written any article he just decided to take a random one from magazine 26Char However before sending it to the magazine 2Char he needs to adapt the text to the format of the journal To do so he removes some words from the chosen article in such a way that the remaining text can be written using no more than two distinct letters Since the payment depends from the number of non space characters in the article Andrew wants to keep the words with the maximum total length ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nstring word[128];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0), cout.precision(15);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> word[i];\n\n    int ans = 0;\n\n    for (char c1 = \'a\'; c1 <= \'z\'; c1++) {\n        for (char c2 = c1 + 1; c2 <= \'z\'; c2++) {\n            int score = 0;\n            for (int i = 0; i < N; i++) {\n                bool incl = true;\n                for (int j = 0; j < word[i].size(); j++) {\n                    incl &= word[i][j] == c1 || word[i][j] == c2;\n                }\n                if (incl) score += word[i].size();\n            }\n            ans = max(ans, score);\n        }\n    }\n\n    cout << ans << ""\\n"";\n}\n\n']",,,"['brute force', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. 2Char.json,https://codeforces.com//blog/entry/21406,For each letter will maintain the total length of words which found it was alone and for each pair of letters will maintain the total length of words that contains only them For each row count a number of different letters in it If it is one then add this letter to the length of the word If two of them then add to the pair of letters word s length Now find a pair of letters that will be the answer For a pair of letters answer is Among all these pairs find the maximum This is the answer The overall complexity is O total length of all strings 26 26 
https://codeforces.com//contest/1017/problem/F,205996,F,1017F,1017,F. The Neutral Zone,After the war destroyed cities in the neutral zone were restored And children went back to school The war changed the world as well as education In those hard days a new math concept was created As we all know logarithm function can be described as log p 1 a 1 p 2 a 2 p k a 2 a 1 log p 1 a 2 log p 2 a k log p k Where p 1 a 1 p 2 a 2 p k a 2 is the prime factorization of a integer A problem is that the function uses itself in the definition That is why it is hard to calculate So the mathematicians from the neutral zone invented this text exlog f p 1 a 1 p 2 a 2 p k a 2 a 1 f p 1 a 2 f p 2 a k f p k Notice that text exlog f 1 is always equal to 0 This concept for any function f was too hard for children So teachers told them that f can only be a polynomial of degree no more than 3 in daily uses i e f x Ax 3 Bx 2 Cx D Class is over Don t forget to do your homework Here it is sum i 1 n text exlog f i Help children to do their homework Since the value can be very big you need to find the answer modulo 2 32 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef unsigned int ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst int MX = 100001;\n\nint n,A,B,C,D;\nll ans;\nvi arr[40001];\n\nll get(int x, int p) {\n    if (x == 0) return 0;\n    return x/p+get(x/p,p);\n}\n\nll eval(ll x) {\n    return ((A*x+B)*x+C)*x+D;\n}\n\nbool prime(int x) {\n    if (x == 1) return 0;\n    for (int i = 2; i*i <= x; ++i) if (x % i == 0) return 0;\n    return 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> A >> B >> C >> D;\n    vi v;\n    FOR(i,1,min(n,20000)+1) if (prime(i)) {\n        ans += get(n,i)*eval(i);\n        v.pb(i);\n    }\n    for (int i: v) {\n        int t = 20001/i;\n        if (t*i < 20001) t ++;\n        arr[t*i-20001].pb(i);\n    }\n    \n    int st = 0;\n    FOR(i,20001,n+1) {\n        if (st == 20000) {\n            F0R(i,20000) swap(arr[i],arr[i+20000]);\n            st = 0;\n        }\n        if (!sz(arr[st])) {\n            ans += get(n,i)*eval(i);\n        } else {\n            for (int x: arr[st]) arr[st+x].pb(x);\n            arr[st].clear();\n        }\n        st ++;\n    }\n    \n    cout << ans;\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']",,,"['brute force', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. The Neutral Zone.json,https://codeforces.com/blog/entry/61081,First forget about the memory limit part Instead of enumerating all integers and count its value we enumerate all primes and count its contribution It is obvious that prime s contribution is The second part is the number of times it occurs in total in integers less than or equal to you can examine and feel that manually Brute force this thing is actually since there are only primes less than or equal to and calculate the second part for each of them cost times Now the problem is on sieving the primes Use Eratosthenes s sieve instead of Euler s then the only memory cost is the cross out table Use a bitset to store the cross out table and you ll get a memory cost for about Key observation except and all primes satisfy Then just store these positions with You can also use this observation to optimize your code s running time Complexity That s the running time of Eratosthenes s sieve 
https://codeforces.com//contest/790/problem/E,98953,E,790E,790,E. Bear and Isomorphic Points,Bearland is a big square on the plane It contains all points with coordinates not exceeding by the absolute value There are houses in Bearland The th of them is located at the point The points are distinct but some subsets of them may be collinear Bear Limak lives in the first house He wants to destroy his house and build a new one somewhere in Bearland Bears don t like big changes For every three points houses and the sign of their cross product should be the same before and after the relocation If it was negative positive zero it should still be negative positive zero respectively This condition should be satisfied for all triples of indices possibly equal to each other or different than Additionally Limak isn t allowed to build the house at the point where some other house already exists but it can be the point where his old house was In the formula above we define the difference and the cross product of points and as Consider a set of possible new placements of Limak s house Your task is to find the area of that set of points Formally let s say that Limak chooses the new placement randomly each coordinate is chosen independently uniformly at random from the interval Let denote the probability of getting the allowed placement of new house Let denote the area of Bearland Your task is to find ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-13;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\nstruct point {\n  ld x, y;\n\n  int read() {\n    double x_, y_;\n    if (scanf(""%lf%lf"", &x_, &y_) < 2) {\n      return 0;\n    }\n    x = x_, y = y_;\n    return 1;\n  }\n\n  point(): x(), y() {}\n  point(ld x, ld y): x(x), y(y) {}\n\n  point operator -(const point & p) const {\n    return point(x - p.x, y - p.y);\n  }\n\n  point operator +(const point & p) const {\n    return point(x + p.x, y + p.y);\n  }\n\n  ld operator *(const point & p) const {\n    return x * p.x + y * p.y;\n  }\n\n  ld operator ^(const point & p) const {\n    return x * p.y - y * p.x;\n  }\n\n  point operator *(const ld & m) const {\n    return point(x * m, y * m);\n  }\n  \n  ld slen() const {\n    return x * x + y * y;\n  }\n\n  ld len() const {\n    return sqrt(slen());\n  }\n\n  point norm() const {\n    ld l = len();\n    assert(l > eps);\n    return point(x / l, y / l);\n  }\n\n  point rot() const {\n    return point(-y, x);\n  }\n\n  bool operator <(const point & p) const {\n    if (abs(x - p.x) > eps) {\n      return x < p.x;\n    }\n    if (abs(y - p.y) > eps) {\n      return y < p.y;\n    }\n    return false;\n  }\n\n  bool operator ==(const point & p) const {\n    return abs(x - p.x) < eps && abs(y - p.y) < eps;\n  }\n\n  int type() const {\n    return y > eps || (y >= -eps && x > eps);\n  }\n};\n\nstruct pointComp {\n  bool operator ()(const point & a, const point & b) {\n    int at = a.type(), bt = b.type();\n    if (at != bt) {\n      return at < bt;\n    }\n    ld prod = a ^ b;\n    if (abs(prod) > eps) {\n      return prod > eps;\n    }\n    return a.slen() < b.slen() - eps;\n  }\n};\n\nstruct line {\n  point o, v;\n\n  line(): o(), v() {}\n  line(const point & a, const point & b) {\n    o = a;\n    v = (b - a).norm();\n  }\n\n  ld dist(const point & p) const {\n    return v ^ (p - o);\n  }\n\n  bool operator <(const line & l) const {\n    if (!(v == l.v)) {\n      return pointComp()(v, l.v);\n    }\n    ld d = dist(l.o);\n    return d < -eps;\n  }\n};\n\n//intersect two lines, assume they do not coincide\nbool intersect(const line & a, const line & b, point & res) { \n  ld coeff = (a.v ^ b.v);\n  if (abs(coeff) < eps) {\n    return false;\n  }\n  ld ka = (b.o ^ b.v) / coeff;\n  ld kb = (a.v ^ a.o) / coeff;\n  res = a.v * ka + b.v * kb;\n\n#ifdef DEBUG\n  assert(abs(a.dist(res)) < eps && abs(b.dist(res)) < eps);\n#endif\n  return true;\n}\n\n\n//a, b, c are on the same line, check if c is in [a,b]\nbool inside(point a, point b, point c) {\n  if (b < a) {\n    swap(a, b);\n  }\n  return !(c < a || b < c);\n}\n\n//intersect [a,b] and [c,d]\n//assume they are not on the same line and have positive length\nbool intersect(point a, point b, point c, point d, point & res) {\n  if (!intersect(line(a, b), line(c, d), res)) {\n    return false;\n  }\n  return inside(a, b, res) && inside(c, d, res);\n}\n\n//intersect line and circle\nbool intersect(line l, point o, ld r, point res[2]) {\n  point n = l.v.rot();\n  ld d = (l.o - o) * n;\n  if (abs(d) > r + eps) {\n    return false;\n  }\n\n  ld x = sqrt(max((ld) 0, r * r - d * d));\n\n  for (int it = 0; it < 2; ++it) {\n    res[it] = o + n * d + l.v * (it ? -x : x);\n  }\n  return true;\n}\n\n//intersect two circles\nbool intersect(point o1, ld r1, point o2, ld r2, point res[2]) {\n  if (r1 < r2 - eps) {\n    swap(o1, o2);\n    swap(r1, r2);\n  }\n  ld d = (o2 - o1).len();\n  if (r1 + r2 < d - eps || r1 - r2 > d + eps) {\n    return false;\n  }\n\n  ld cosa = (r1 * r1 + d * d - r2 * r2) / ((ld) 2 * r1 * d);\n  ld sina = sqrt(max((ld) 0, (ld) 1 - cosa * cosa));\n  point v1 = (o2 - o1).norm() * r1;\n  point v2 = v1.rot();\n\n  for (int it = 0; it < 2; ++it) {\n    res[it] = o1 + v1 * cosa + v2 * (it ? -sina : sina); \n  }\n  return true;\n}\n\nint commonTangents(point o1, ld r1, point o2, ld r2, point *res) {\n  ld d = (o1 - o2).len();\n  if (d < eps) {\n    return 0;\n  }\n  int cnt = 0;\n  for (int i = 0; i < 2; ++i) {\n    ld cosa = (r1 + (i ? -r2 : r2)) / d;\n    if (abs(cosa) < (ld) 1 + eps) {\n      ld sina = sqrt(max((ld) 0, (ld) 1 - cosa * cosa));\n      point v1 = (o2 - o1).norm() * r1;\n      point v2 = v1.rot();\n      for (int it = 0; it < 2; ++it) {\n        res[cnt++] = o1 + v1 * cosa + v2 * (it ? -sina : sina);\n      }\n    }\n  }\n  return cnt;\n}\n\nnamespace Halfplane {\n  const static int maxn = (int) 8e5 + 10;\n  line h[maxn];\n  point p[maxn];\n\n  int intersect(int n, line *_h, point *res) {\n    for (int i = 0; i < n; ++i) {\n      h[i] = _h[i];\n    }\n    static point box[4] = {\n      point(1e6, -1e6),\n      point(1e6, 1e6),\n      point(-1e6, 1e6),\n      point(-1e6, -1e6)\n    };\n    for (int i = 0; i < 4; ++i) {\n      h[n++] = line(box[i], box[(i + 1) % 4]);\n    }\n    sort(h, h + n);\n\n    {\n      int m = 0;\n      for (int i = 0; i < n; ++i) {\n        if (i == 0 || !(h[i].v == h[i - 1].v)) {\n          h[m++] = h[i];\n        }\n      }\n      n = m;\n    }\n\n    int m = 0;\n    int del = 0;\n    for (int i = 1; i < n; ++i) {\n      while (m > del && h[i].dist(p[m - 1]) <= eps) {\n        --m;\n      }\n      while (m > del && h[i].dist(p[del]) <= eps) {\n        ++del;\n      }\n      if (del == m && (h[m].v ^ h[i].v) < eps) {\n        return 0;\n      }\n      point np;\n      assert(intersect(h[i], h[m], np));\n      if (h[del].dist(np) >= -eps) {\n        p[m++] = np;\n        h[m] = h[i];\n      }\n    }\n    rotate(p, p + del, p + m);\n    rotate(h, h + del, h + m + 1);\n    m -= del;\n    if (m == 0) {\n      return 0;\n    }\n\n    point np;\n    assert(intersect(h[0], h[m], np));\n    p[m++] = np;\n    for (int i = 0; i < m; ++i) {\n      res[i] = p[i];\n    }\n    return m;\n  }\n};\n//END ALGO\n\n\nconst int maxn = (int) 2e5 + 10;\npoint ps[maxn];\n\nint n;\n\nint read() {\n  if (scanf(""%d"", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    assert(ps[i].read());\n  }\n  return 1;\n}\n\nline ls[maxn * 4];\n\npoint ans[4 * maxn];\n\npoint qs[maxn];\n\nvoid solve() {\n  point p0 = ps[0];\n  for (int i = 0; i < n; ++i) {\n    qs[i] = ps[i] - p0;\n    if (qs[i].type() == 1) {\n      qs[i] = qs[i] * -1;\n    }\n  }\n\n  sort(qs + 1, qs + n, pointComp());\n\n  for (int i = 1; i < n - 1; ++i) {\n    if (qs[i].type() == qs[i + 1].type() && abs(qs[i] ^ qs[i + 1]) <= eps) {\n      printf(""0\\n"");\n      return;\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    qs[i - 1] = ps[i] - p0;\n  }\n  --n;\n  sort(qs, qs + n, pointComp());\n\n\n  int cntl = 0;\n  for (int i = 0, j = 0; i < n; ++i) {\n    point p = qs[i];\n\n    if (j == i) {\n      j = (j + 1) % n;\n    }\n\n    while (i != j) {\n      if ((p ^ qs[j]) < 0) {\n        break;\n      }\n      j = (j + 1) % n;\n    }\n\n    for (int it = 0; it < 2; ++it) {\n      int cj = (j + n - it) % n;\n      if (cj == i) {\n        continue;\n      }\n\n      ls[cntl] = line(qs[i] + p0, qs[cj] + p0);\n      if (ls[cntl].dist(p0) < 0) {\n        ls[cntl].v = ls[cntl].v * -1;\n      }\n      ++cntl;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    ls[cntl] = line(qs[i] + p0, qs[(i + 1) % n] + p0);\n    if (ls[cntl].dist(p0) < 0) {\n      ls[cntl].v = ls[cntl].v * -1;\n    }\n    ++cntl;\n  }\n\n  int got = Halfplane::intersect(cntl, ls, ans);\n  ans[got] = ans[0];\n\n  ld S = 0;\n  for (int i = 0; i < got; ++i) {\n    S += (ans[i] ^ ans[i + 1]);\n  }\n  S /= 2;\n  printf(""%.18f\\n"", (double) S);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK "".out"", ""w"", stdout);\n  assert(freopen(TASK "".in"", ""r"", stdin));\n#endif\n\n  int t;\n  scanf(""%d"", &t);\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""Time %.2f\\n"", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']",,,['geometry'],3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Bear and Isomorphic Points.json,https://codeforces.com//blog/entry/51068,If p1 is collinear with some two other points we should print 0 Now let s assume that no two points are collinear with p1 The naive solution is to iterate over O n2 pairs of points For each pair of points there is a line going through them both and we know that the new placement of p1 should be on the same side e g on the left from the line otherwise the sign of the cross product will change In other words the new placement must belong to some halfplane What we re looking for is the intersection of those O n2 halfplanes what can be found in We should also remember that the new placement must be inside the big square what can be achieved by adding four halfplanes each for one side of the square It turns out that it s quite easy to improve the complexity of the naive solution Let s first sort other n 1 points by angle One way to approach the problem is to think we are interested in those new placements that don t affect the sorting of those n 1 points this is almost enough to get the intended solution If sorted in the clockwise order points are p2 p3 pn taking into account a halfplane that goes through points pi and pi 1 ensures that pi 1 is further in the clockwise order than pi i e it is more on the right if we look from p1 Usually pi 2 is also more on the right than pi and so on till some point pj that is no longer on the left from pi if we look from p1 For each i let s find the first j that pj is on the left from pi move indices i and j with two pointers and then consider a halfplane that goes through pi and pj To sum up we consider n halfplanes determined by pairs pi pi 1 and n halfplanes determined by pairs pi pj where pi and pj are almost opposite to each other with respect to p1 It turns out that this is already a working solution no other halfplanes are needed The answer is the intersection of found O n halfplanes Let s prove the correctness Let s assume that one of halfplanes going through some pa and pb wasn t considered while it should be because it would affect the answer And let s say that pb is more on the right than pa and a b If a b 1 we surely considered that halfplane Otherwise if there is some other point with index such that it is on the proper side of the line pa pb i e on the same side as p1 halfplanes determined by pairs a m and m b completely cover that a b halfplane Here we must use induction if each halfplane determined by a pair a b for smaller value of b a is either taken or covered by some other taken halfplanes then also halfplanes with greater differences b a will be considered remember that we assumed that there is some other points with index such that The case analysed above is shown on the drawing below Let R denote the red point If halfplanes pa R and R pb are considered or from induction they are covered by something else we don t need considering pa pb What remains is the case when a 1 b and each point with index in a 1 b 1 is on the line pa pb or on the wrong side not the same as p1 It quite easily implies that our line is already covered everywhere except for the segment pa pb see the drawing Now we should take a look at points pb 1 pb 2 If one of them pk is on the wrong side of the line pa pb i e on the side different than p1 the halfplane pk 1 pk covers our segment pa pb and we are done Otherwise all those points are on the proper side the same as p1 Eventually one of them will be the last one that is on the right from pa and let s remember that we consider halfplanes determined by such pairs earlier denoted as pi and pj Since that point is on the proper side of the line pa pb the segment is covered 
https://codeforces.com//contest/1240/problem/C,432408,C,1240C,1240,C. Paint the Tree,You are given a weighted tree consisting of n vertices Recall that a tree is a connected graph without cycles Vertices u i and v i are connected by an edge with weight w i Let s define the k coloring of the tree as an assignment of exactly k colors to vertex so that each color is used no more than two times You can assume that you have infinitely many colors available We say that an edge is in the given k coloring if its endpoints share at least one color i e there exists a color that is assigned to both endpoints Let s also define the of a k coloring as the sum of weights of edges Please calculate the maximum possible of a k coloring of the given tree You have to answer q independent queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=501000;\nint n,k,_;\nll dp[N][2];\nvector<PII> e[N];\nvoid dfs(int u,int f) {\n\tll sm=0;\n\tvector<ll> dd;\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t\t// 0 <=k 1 <= k-1\n\t\tll w0=dp[v][0],w1=dp[v][1]+p.se;\n\t\tsm+=w0;\n\t\tdd.pb(w1-w0);\n\t}\n\tsort(all(dd)); reverse(all(dd));\n\tdp[u][0]=dp[u][1]=sm;\n\trep(i,0,SZ(dd)) {\n\t\tsm+=max(dd[i],0ll);\n\t\tif (i+1<k) dp[u][1]=max(dp[u][1],sm);\n\t\tif (i+1<=k) dp[u][0]=max(dp[u][0],sm);\n\t}\n//\tprintf(""gg %d %lld %lld\\n"",u,dp[u][0],dp[u][1]);\n}\n\nvoid solve() {\n\tscanf(""%d%d"",&n,&k);\n\trep(i,1,n+1) e[i].clear();\n\trep(i,1,n) {\n\t\tint u,v,w;\n\t\tscanf(""%d%d%d"",&u,&v,&w);\n\t\te[u].pb(mp(v,w)); e[v].pb(mp(u,w));\n\t}\n\tdfs(1,0);\n\tprintf(""%lld\\n"",dp[1][0]);\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n']",,,"['dp', 'sortings', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Paint the Tree.json,https://codeforces.com/blog/entry/70358,It is obvious that if we paint two vertices in the same color they should be adjacent to each other otherwise we could paint them in different colors and the answer would not be worse So we can reduce the problem to the following choose a set of edges with maximum cost such that no vertex is adjacent to more than k chosen edges This problem is very similar to maximum weighted matching on the tree and we can try to use some methods that allow us to solve that problem Let s solve the problem using dynamic programming dpv f the answer to the problem for the subtree of the vertex v f is the flag that denotes whether the edge from v to its parent is chosen Depending on the flag f we can choose k or k 1 edges connecting our vertex to its children let s denote the maximum number of edges we can choose as t We have to select no more than t child nodes of the vertex v If we choose an edge leading to node u then dpu 1 wv u is added to the dp value we are currently calculating otherwise dpu 0 is added Based on this formula you have to choose no more than t child nodes of vertex v for which the total sum of dpu 1 wv u dpu 0 is maximum 
https://codeforces.com//contest/888/problem/B,133215,B,888B,888,B. Buggy Robot,Ivan has a robot which is situated on an infinite grid Initially the robot is standing in the starting cell The robot can process commands There are four types of commands it can perform move from the cell to move from to move from to move from to Ivan entered a sequence of commands and the robot processed it After this sequence the robot ended up in the starting cell but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell He thinks that some commands were ignored by robot To acknowledge whether the robot is severely bugged he needs to calculate the maximum possible number of commands that were performed correctly Help Ivan to do the calculations ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 111\nchar c[ N ];\nint n;\nvoid init(){\n  cin >> n >> c;\n}\nvoid solve(){\n  int a = 0 , b = 0;\n  for( int i = 0 ; c[ i ] ; i ++ )\n    if( c[ i ] == \'L\' ) a ++;\n    else if( c[ i ] == \'R\' ) a --;\n    else if( c[ i ] == \'D\' ) b ++;\n    else b --;\n  cout << n - ( abs( a ) + abs( b ) ) << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']",,,['greedy'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Buggy Robot.json,https://codeforces.com//blog/entry/55701,Consider the final cell after original path It has some distance to and to That means the path included at least and in corresponding directions Let s remove just these minimal numbers of moves Finally the answer will be where are distances from the final cell of the original path to Overall complexity 
https://codeforces.com//contest/1382/problem/A,672677,A,1382A,1382,A. Common Subsequence,You are given two arrays of integers a 1 ldots a n and b 1 ldots b m Your task is to find a array c 1 ldots c k that is a subsequence of a 1 ldots a n and also a subsequence of b 1 ldots b m If there are multiple answers find one of the possible length If there are still multiple of the smallest possible length find any If there are no such arrays you should report about it A sequence a is a subsequence of a sequence b if a can be obtained from b by deletion of several possibly zero elements For example 3 1 is a subsequence of 3 2 1 and 4 3 1 but not a subsequence of 1 3 3 7 and 3 10 4 ,"['#pragma comment(linker, ""/STACK:10000000000"")\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <set>\n#include <stack>\n#include <vector>\n#include <time.h>\n#include <random>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <complex>\n#define rt return\n#define mp make_pair\n#define endl \'\\n\'\n#define sqr(x) ((x) * (x))\n#define all(x) (x).begin(), (x).end()\n#define rep(x) for (int rep_iter = 0; rep_iter < x; ++rep_iter)\n#define fnd(x, y) (x.find(y) != x.end())\n#define fndv(x, y) (find(all(x), y) != end(x))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<db, db> pdd;\ntypedef unsigned char bt;\ntypedef unsigned int uint;\nconst int MOD = 1000000007;\nconst int INF = 1000000007LL;\nconst ll INF2 = 1LL << 62LL;\nconst long double EPS = 1e-9;\n#ifdef _DEBUG\nconst int SIZE = 120;\n#endif\n#ifndef _DEBUG\nconst int SIZE = 200010; //200010\n#endif\nmt19937 rng(time(0));\nuniform_int_distribution<int> uid(-1000000000, 1000000000);\n\n\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tint tt;\n\tcin >> tt;\n\trep(tt) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector <int> v(n);\n\t\tfor (auto& i : v)\n\t\t\tcin >> i;\n\t\tbool f = 1;\n\t\trep(m) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif (fndv(v, x) && f) {\n\t\t\t\tcout << ""YES\\n1 "" << x << endl;\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t\tcout << ""NO\\n"";\n\t}\n\n\n\n\treturn 0;\n}']",,,['brute force'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Common Subsequence.json,https://codeforces.com//blog/entry/80427,If there is any common subsequence then there is a common element of and And a common element is also a common subsequence of length Therefore we need only find a common element of the two arrays or say that they share no elements Complexity is if we compare each pair of elements if we sort the arrays and take their intersection or use a set data structure or if we use a hash table 
https://codeforces.com//contest/999/problem/B,192341,B,999B,999,B. Reversing Encryption,A string s of length n can be encrypted by the following algorithm iterate over all divisors of n in decreasing order i e from n to 1 for each divisor d reverse the substring s 1 dots d i e the substring which starts at position 1 and ends at position d For example the above algorithm applied to the string s leads to the following changes to to to to obviously the last reverse operation doesn t change the string because d 1 You are given the encrypted string t Your task is to decrypt this string i e to find a string s such that the above algorithm results in string t It can be proven that this string s always exists and is unique ,"['#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl \'\\n\'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(2e5) + 17;\n\nint n;\nstring s;\n\nbool read() {\n    if (!(cin >> n >> s))\n        return false;\n\n    return true;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; ++i)\n        if (n % i == 0) {\n            reverse(s.begin(), s.begin() + i);\n        }\n\n    cout << s << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand(\'S\' + \'E\' + \'R\' + \'E\' + \'Z\' + \'H\' + \'K\' + \'A\');\n\n#ifdef SEREZHKA\n    freopen(""file.in"", ""r"", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Reversing Encryption.json,https://codeforces.com/blog/entry/60138,To solve the problem we can implement the encryption algorithm with a single change we have to iterate over all divisors of in increasing order Time complexity where is a divisor count function for For example 
https://codeforces.com//contest/1954/problem/A,2586691,A,1954A,1954,A. Painting the Ribbon,Alice and Bob have bought a ribbon consisting of n parts Now they want to paint it First Alice will paint every part of the ribbon into one of m colors For each part she can choose its color arbitrarily Then Bob will choose parts of the ribbon and repaint them he chooses the affected parts and the color arbitrarily Bob would like all parts to have the same color However Alice thinks that this is too dull so she wants to paint the ribbon in such a way that Bob cannot make all parts have the same color Is it possible to paint the ribbon in such a way ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    int n,m,k; cin >> n >> m >> k;    int mx=iceil(n,m);    if(n-mx<=k) print(""NO"");    else print(""YES"");}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}']",,,"['constructive algorithms', 'greedy', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Painting the Ribbon.json,https://codeforces.com//blog/entry/128421,When is Bob able to get a ribbon where each part has color There should be at least parts of color So if the number of parts with color is less than Bob cannot repaint the whole ribbon into color So Alice has to paint the ribbon in such a way that for every color there are at most parts of that color There are at least two ways to check if it is possible for example you can calculate the maximum possible length of the ribbon such that it contains no more than parts of every color or you can calculate the maximum number of parts among all colors if you try to color the ribbon as evenly as possible 
https://codeforces.com//contest/781/problem/E,96953,E,781E,781,E. Andryusha and Nervous Barriers,Andryusha has found a perplexing arcade machine The machine is a vertically adjusted board divided into square cells The board has columns numbered from to from left to right and rows numbered from to from the bottom to the top Further there are barriers in some of board rows There are barriers in total and th of them occupied the cells through of the row Andryusha recollects well that no two barriers share the same row Furthermore no row is completely occupied with a barrier that is at least one cell in each row is free The player can throw a marble to any column of the machine from above A marble falls downwards until it encounters a barrier or falls through the bottom of the board A marble disappears once it encounters a barrier but is replaced by two more marbles immediately to the left and to the right of the same barrier In a situation when the barrier is at an edge of the board both marbles appear next to the barrier at the side opposite to the edge More than one marble can occupy the same place of the board without obstructing each other s movement Ultimately all marbles are bound to fall from the bottom of the machine Peculiarly sometimes marbles can go through barriers as if they were free cells That is so because the barriers are in fact alive and frightened when a marble was coming at them from a very high altitude More specifically if a marble falls towards the barrier from relative height more than that is it started its fall strictly higher than then the barrier evades the marble If a marble is thrown from the top of the board it is considered to appear at height Andryusha remembers to have thrown a marble once in each of the columns Help him find the total number of marbles that came down at the bottom of the machine Since the answer may be large print it modulo ,"['#pragma comment(linker, ""/STACK:1000000000"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\n\nusing namespace std;\n\nconst int MAXN = 100001;\nconst int INF = 1000 * 1000 * 1000 + 2;\nconst int MODULE = 1000 * 1000 * 1000 + 7;\n\nstruct lane\n{\n\tint l, r, s, u;\n};\n\nstack <pair <int, int> > sc[MAXN];\nint top[MAXN];\nlane a[MAXN];\nint rid[MAXN];\n\n\n\nvoid er(int id)\n{\n\tsc[id].pop();\n\ttop[id] = sc[id].top().first;\n}\n\nbool cmp(lane l1, lane l2)\n{\n\treturn l1.s > l2.s;\n}\n\nint rmq[4 * MAXN];\n\ninline int bst(int i1, int i2)\n{\n\treturn (top[i1] < top[i2]) ? i1 : i2;\n}\n\nvoid create_rmq(int v, int l, int r)\n{\n\tif (l == r)\n\t{\n\t\trid[l] = v;\n\t\trmq[v] = l;\n\t\treturn;\n\t}\n\tcreate_rmq(v * 2 + 1, l, (l + r) / 2);\n\tcreate_rmq(v * 2 + 2, (l + r) / 2 + 1, r);\n\trmq[v] = bst(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n}\n\nint lv, rv;\n\nint get_rmq(int v, int l, int r)\n{\n\tif ((lv > r) || (l > rv)) return 0;\n\tif ((lv <= l) && (r <= rv)) return rmq[v];\n\treturn bst(get_rmq(v * 2 + 1, l, (l + r) / 2), get_rmq(v * 2 + 2, (l + r) / 2 + 1, r));\n}\n\nvoid modify_rmq(int l)\n{\n\tint v = rid[l];\n\twhile (v != 0)\n\t{\n\t\tv = (v - 1) / 2;\n\t\trmq[v] = bst(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n\t}\n}\n\nvoid psh(int id, int x, int y)\n{\n\tsc[id].push(mp(x, y));\n\ttop[id] = x;\n\tmodify_rmq(id);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tint h, w, n;\n\tcin >> h >> w >> n;\n\ttop[0] = 2 * INF + 4;\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\tpsh(i, 2 * INF + 3, 0);\n\t\tpsh(i, h + 1, 1);\n\t}\n\tcreate_rmq(0, 1, w);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i].s >> a[i].l >> a[i].r >> a[i].u;\n\t}\n\tsort(a, a + n, cmp);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlv = a[i].l, rv = a[i].r;\n\t\tint y = a[i].s;\n\t\tint ly = a[i].s + a[i].u;\n\t\tint cur = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tint v = get_rmq(0, 1, w);\n\t\t\tif (top[v] > ly) break;\n\t\t\tcur = (cur + sc[v].top().second) % MODULE;\n\t\t\ter(v);\n\t\t\tmodify_rmq(v);\n\t\t}\n\t\tif (lv == 1)\n\t\t\tpsh(rv + 1, y, (cur * 2) % MODULE);\n\t\telse if (rv == w) psh(lv - 1, y, (cur * 2) % MODULE);\n\t\telse psh(lv - 1, y, cur), psh(rv + 1, y, cur);\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\twhile (!sc[i].empty())\n\t\t{\n\t\t\tans += sc[i].top().second;\n\t\t\tans %= MODULE;\n\t\t\tsc[i].pop();\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']",,,['data structures'],2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Andryusha and Nervous Barriers.json,https://codeforces.com//blog/entry/50854,Solution 1 Let us move a sweep line from the bottom to the top and say that th barrier is active if the current coordinate satisfies If we want to find the result of dropping a ball in column at a certain moment we have to find the highest active barrier that covers at the moment Let us store a segment tree with a set of active segments in each tree node When introducing a new active segment we represent it as a union of tree nodes and add this segment in each of these nodes set when a segment becomes non active we delete these entries If at any point we are interested in finding the highest active barrier for a column we consider all tree nodes covering and look at their highest entries only Also for each segment we store the number of resulting balls after hitting this segment this number can be found by making two queries to the tree for the two balls resulting from the collision at the same time we activate the barrier To find the final answer for each column drop a ball in it from height and sum the results Thus the answer can be found in time with the second logarithm for working time Solution 2 Let us go from the top to the bottom instead and maintain positions of all balls to be dropped If any of these balls occupy the same position we group them together and store the size of the group Each column will have a separate stack of groups with lower groups on top of the stack Let s see how a new barrier changes our configuration For each column we want to drop several lowest groups on the barrier which will result in creating at most two new groups next to the barrier Let us store a segment tree of size with th entry equal to the height of the lowest group in column While range minimum in the segment tree is low enough we pop the lowest group from the corresponding stack and update the segment tree accordingly Finally we create the new groups and push them to their respective stacks After processing all barriers the rest groups will fall straight to the bottom A standard amortized estimate shows that operations will be performed for time complexity 
https://codeforces.com//contest/1792/problem/E,1749563,E,1792E,1792,E. Divisors and Table,You are given an n times n multiplication table and a positive integer m m 1 cdot m 2 A n times n multiplication table is a table with n rows and n columns numbered from 1 to n where a i j i cdot j For each divisor d of m check does d occur in the table at least once and if it does what is the row that contains d ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint pri[100005],tsl[100005],cnt;\nint ys[500005],qans[500005],tmp;\nmap<int,int>ma;\nvoid dfs(int x,int now)\n{\n\tif(x==cnt+1)\n\t{\n\t\tys[++tmp]=now;\n\t\treturn;\n\t}\n\tfor(int i=0;i<=tsl[x];i++)\n\t{\n\t\tdfs(x+1,now);\n\t\tnow*=pri[x];\n\t}\n}\nsigned main()\n{\n\tint t,n,m1,m2;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tm1=read();\n\t\tm2=read();\n\t\tcnt=0;\n\t\tfor(int i=2;i*i<=m1||i*i<=m2;i++)\n\t\t{\n\t\t\tif(m1%i!=0&&m2%i!=0)continue;\n\t\t\tpri[++cnt]=i;\n\t\t\ttsl[cnt]=0;\n\t\t\twhile(m1%i==0)m1/=i,tsl[cnt]++;\n\t\t\twhile(m2%i==0)m2/=i,tsl[cnt]++;\n\t\t}\n\t\tif(m1<m2)swap(m1,m2);\n\t\tif(m1>1)\n\t\t{\n\t\t\tpri[++cnt]=m1;\n\t\t\ttsl[cnt]=1;\n\t\t}\n\t\tif(m2>1)\n\t\t{\n\t\t\tif(m1==m2)tsl[cnt]++;\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tpri[++cnt]=m2;\n\t\t\t\ttsl[cnt]=1;\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(1,1);\n\t\tsort(ys+1,ys+tmp+1);\n\t\tma.clear();\n\t\tfor(int i=1;i<=tmp;i++)ma[ys[i]]=i;\n\t\tfor(int i=1;i<=tmp;i++)\n\t\t{\n\t\t\tif(ys[i]<=n)\n\t\t\t{\n\t\t\t\tqans[i]=ys[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqans[i]=-1;\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tif(ys[i]%pri[j]==0)qans[i]=max(qans[i],qans[ma[ys[i]/pri[j]]]);\n\t\t\t}\n\t\t}\n\t\tint sl=0,yh=0;\n\t\tfor(int i=1;i<=tmp;i++)\n\t\t{\n\t\t\tif(qans[i]!=0&&ys[i]/qans[i]<=n)\n\t\t\t{\n\t\t\t\t//printf(""%lld %lld\\n"",ys[i],ys[i]/qans[i]);\n\t\t\t\tsl++;\n\t\t\t\tyh^=(ys[i]/qans[i]); \n\t\t\t}\n\t\t}\n\t\tprintf(""%lld %lld\\n"",sl,yh);\n\t}\n\treturn 0;\n}']",,,"['brute force', 'dfs and similar', 'dp', 'number theory']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Divisors and Table.json,https://codeforces.com//blog/entry/111835,Firstly let s factorize Since we can factorize and separately and then unite divisors For example use can get canonical representations of and to get canonical representation of and then use it to generate all divisors of Let s estimate the number of divisors It s convenient for our purposes to estimate it as More precisely there are at most divisors for search Highly Composite Numbers for more info How to calculate the answer for each divisor There are two ways for each we are searching for the minimum that and Since is fixed the minimum means the maximum So let s find instead In other words for each we need to find the maximum such that divides and We can do it efficiently with on divisors Let be the maximum that is a divisor of and If then obviously Otherwise we know that we are searching Let say that are the prime divisors of the initial number Since is a divisor of and then exists some among the set of prime divisors such that is a divisor of as well So instead of brute search it s enough to take a value In other words if we can calculate Ok now we know value for each divisor Since we found the maximum the last step is to calculate the desired and if we found the answer otherwise it means that is not presented table and The total complexity is per test where is the number of divisors of and is the number of prime divisor of Note that complexity is quite high so you should write it at least a little accurate for example store in an array not map and search position of with There is also a way to get rid of extra factor if you iterate through is a smart way faster easier unproven Let s generate a list of all divisors of as in the increasing order For some divisor we are searching the minimum that is a divisor of and It means that So let s just find the first position such that with and start iterating from onward searching the first that is a divisor of The found would be the minimum we need It looks like in average we will find the correct quite fast or we ll break when 
https://codeforces.com//contest/225/problem/B,1829,B,225B,225,B. Well-known Numbers,Numbers bonacci is integer are a generalization of Fibonacci numbers and are determined as follows for integer for integer Note that we determine the bonacci numbers only for integer values of and You ve got a number represent it as a sum of several at least two bonacci numbers ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n\nusing namespace std;\n\nint a[5000000];\nint sum[5000000];\nint ans[5000000],tot;\nint s,k,n;\n\nint main()\n{\n\tscanf(""%d%d"",&s,&k);\n\ta[1]=1;\n\tsum[1]=1;\n\tfor(int i=2;;i++)\n\t{\n\t\tif(i<=k)\n\t\t\ta[i]=sum[i-1];\n\t\telse a[i]=sum[i-1]-sum[i-k-1];\n\t\tif(a[i]>s) {n=i;break;}\n\t\tsum[i]=sum[i-1]+a[i];\n\t}\n\tfor(int i=n-1;i>=1;i--){\n\t\tif(s-a[i]>=0)\n\t\t{\n\t\t s-=a[i];\n\t\t ans[++tot]=a[i];\n\t\t}\n\t}\n\tif(tot==1) ans[++tot]=0;\n\tprintf(""%d\\n"",tot);\n\tfor(int i=1;i<=tot;i++) printf(""%d "",ans[i]);\n\treturn 0;\n}\n']",,,"['binary search', 'greedy', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Well-known Numbers.json,https://codeforces.com//blog/entry/5322,Firstly you should generate all k bonacci numbers less than n For k 32 you can do it straightforward for bigger k you can see that all k bonacci numbers less 109 are powers of two only and 0 So you will have no more then 100 numbers Then you should use greedy algo You should substract from n maximal possible k bonacci numbers You should repeat this operation while n is not decomposed And in the end you will have answer Why all numbers will be different One of possible proves F k n F k n 1 F k n 2 F k n k F k n 1 F k n 2 F k n 3 F k n k 1 You can substract the 2nd equation from the 1st one and you will recieve F k n F k n k 1 2F k n 1 that equal to 2F k n 1 F k n This unequation also holds for n k Suppose than greedy also constricted 2 equal numbers F k x in decomposition But then in virtue of unequation we should take number F k x 1 insead these 2 numbers ontradiction But you didn t need prove than greedy algo works you might believe that it works 
https://codeforces.com//contest/1527/problem/A,990888,A,1527A,1527,A. And Then There Were K,Given an integer n find the maximum value of integer k such that the following condition holds n n 1 n 2 n 3 k 0 where denotes the bitwise AND operation ,"['/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n//#pragma GCC optimize(""Ofast,no-stack-protector"")\n//#pragma GCC optimize(""fast-math"")\n//#pragma GCC target(""avx2"")\n// if avx2 not supported, use this instead\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n\n// something\n//#pragma GCC optimize(""O3"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""avx"")  //Enable AVX\n\n#include <bits/stdc++.h>\n#ifdef ONPC\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored ""-Wunused-const-variable""\n#endif\n#define all(x) (x).begin(), (x).end()\n#define fr first\n#define sc second\n#define m_p make_pair\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define low_bo(a, x) ((int)(lower_bound(a.begin(), a.end(), x) - a.begin()))\n#define up_bo(a, x) ((int)(upper_bound(a.begin(), a.end(), x) - a.begin()))\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define popcnt(x) __builtin_popcount(x)\n#define shuffle(a) shuffle(a.begin(), a.end(), rnd)\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nusing namespace std;\n\n/*\nconst int MEMSIZE = 1e9;\nchar memory[MEMSIZE];\nint memorypos;\ninline void * operator new(size_t n){\n    if (memorypos + n >= MEMSIZE)\n        memorypos = MEMSIZE / 3;\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\ninline void operator delete(void *){}\n*/\n\nusing ll = long long;\n\n#ifndef ONPC\n#define cerr cerr_maksim\nstruct Cerr : public ostream {\n    template<typename T>\n    Cerr& operator<<(T const&) {\n        return *this;\n    }\n} cerr;\n#endif\n\n#ifdef ONPC\nmt19937 rnd(223);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n\ntemplate<typename T>\nvoid setmin(T &x, T y) {\n    x = min(x, y);\n}\n\ntemplate<typename T>\nvoid setmax(T &x, T y) {\n    x = max(x, y);\n}\n\nnamespace Ment {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n\n    template<typename T>\n    class Modular {\n    public:\n        using Type = typename decay<decltype(T::value)>::type;\n\n        constexpr Modular() : value() {}\n\n        template<typename U>\n        Modular(const U &x) {\n            value = normalize(x);\n        }\n\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n\n        const Type &operator()() const { return value; }\n\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n\n        constexpr static Type mod() { return T::value; }\n\n        Modular &operator+=(const Modular &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n\n        Modular &operator-=(const Modular &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n\n        template<typename U>\n        Modular &operator+=(const U &other) { return *this += Modular(other); }\n\n        template<typename U>\n        Modular &operator-=(const U &other) { return *this -= Modular(other); }\n\n        Modular &operator++() { return *this += 1; }\n\n        Modular &operator--() { return *this -= 1; }\n\n        Modular operator++(int) {\n            Modular result(*this);\n            *this += 1;\n            return result;\n        }\n\n        Modular operator--(int) {\n            Modular result(*this);\n            *this -= 1;\n            return result;\n        }\n\n        Modular operator-() const { return Modular(-value); }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n#ifdef _WIN32\n            uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n            uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n            asm(\n            ""divl %4; \\n\\t""\n            : ""=a"" (d), ""=d"" (m)\n            : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n            );\n            value = m;\n#else\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n\n        Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n        template<typename U>\n        friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\n    private:\n        Type value;\n    };\n\n    template<typename T>\n    bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\n\n    template<typename T, typename U>\n    bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\n\n    template<typename T, typename U>\n    bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\n    template<typename T>\n    bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T>\n    bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\n    template<typename T>\n    Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T>\n    Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T>\n    Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T>\n    Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> power(const Modular<T> &a, const U &b) {\n        assert(b >= 0);\n        Modular<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    string to_string(const Modular<T> &number) {\n        return to_string(number());\n    }\n\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n        return stream << number();\n    }\n\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n        typename common_type<typename Modular<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = Modular<T>::normalize(x);\n        return stream;\n    }\n\n    constexpr int md = 1e9 + 7;\n    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n}\nusing Ment::Mint;\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\n#define TIME (clock() * 1.0 / CLOCKS_PER_SEC)\n\n// WARNING!!!!!!\n// Maksim reads solution\n// be careful!!!!\n\n// solution starts here\n\nusing ld = double;\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 1e5 + 100, maxw = (1 << 20) + 5, inf = 1e9 + 100;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int z = 1;\n    while (z <= n)\n        z *= 2;\n    cout << z / 2 - 1 << \'\\n\';\n}\n\n// check test counter\n\nint main() {\n#ifdef ONPC\n    freopen(""../a.in"", ""r"", stdin);\n    freopen(""../a.out"", ""w"", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(20);\n    //precalc();\n    if (false) {\n        int te = 0;\n        while (1) {\n            cerr << ++te << \'\\n\';\n            solve();\n        }\n    }\n    int ts;\n    ts = 1;\n    cin >> ts;\n    for (int its = 1; its <= ts; its++) {\n        //cerr << ""\\nts "" << its << \'\\n\';\n        //cout << ""Case #"" << its << "": "";\n        solve();\n    }\n#ifdef ONPC\n    cerr << ""\\n\\nConsumed "" << TIME << \'\\n\';\n#endif\n}']",,,['bitmasks'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. And Then There Were K.json,https://codeforces.com//blog/entry/90939,Let If there is at least one integer from to whose bit at the index is then the value of the bit in will also be We can easily observe that the Highest set bit in in will become for the first time when All the other bits will become zero when Thus the answer is 
https://codeforces.com//contest/1809/problem/B,1839362,B,1809B,1809,B. Points on Plane,You are given a two dimensional plane and you need to place n chips on it You can place a chip only at a point with integer coordinates The cost of placing a chip at the point x y is equal to x y where a is the absolute value of a The cost of placing n chips is equal to the among the costs of each chip You need to place n chips on the plane in such a way that the Euclidean distance between each pair of chips is than 1 and the cost is the minimum possible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    i64 x = std::sqrt(n);\n    while (x * x < n) {\n        x += 1;\n    }\n    while ((x - 1) * (x - 1) >= n) {\n        x -= 1;\n    }\n    \n    x -= 1;\n    \n    std::cout << x << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['binary search', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Points on Plane.json,https://codeforces.com//blog/entry/114300,Suppose the answer is What s the maximum number of chips we can place Firstly the allowed points to place chips are such that We can group them by coordinate for there is only one for possible are for possible are in segment and so on For possible are in The negative s are the same Let s calculate the maximum number of chips we can place at each row for it s for there are three s but since we can t place chips at the neighboring s we can place at most chips for we have places but can place only chips for we have places but can occupy only points In total for we can place at most chips Analogically for we can place at most chips In total we can place at most chips with cost at most Note that can actually be reached since the distance between chips on the different rows is greater than So to solve our task it s enough to find minimum such that that can be done with Binary Search Or we can calculate Note that can lose precision since is cast to before taking the square root for example transforms to when converted to So you should either cast to that consists of bits in some C compilers or check value as a possible answer 
https://codeforces.com//contest/1898/problem/D,2335771,D,1898D,1898,D. Absolute Beauty,Kirill has two integer arrays a 1 a 2 ldots a n and b 1 b 2 ldots b n of length n He defines the of the array b as sum i 1 n a i b i Here x denotes the absolute value of x Kirill can perform the following operation select two indices i and j 1 leq i j leq n and swap the values of b i and b j Help him find the maximum possible absolute beauty of the array b after performing swap ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int l = 0, r = 1e9 + 10;\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n        l = max(l, min(a[i], b[i]));\n        r = min(r, max(a[i], b[i]));\n        ans += abs(a[i] - b[i]);\n    }\n    if (l > r) {\n        ans += 2 * (l - r);\n    }\n    cout << ans << ""\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']",,,"['greedy', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Absolute Beauty.json,https://codeforces.com//blog/entry/120960,SolutionThe pair represents some interval and is its length Let us try to maximize the sum of the intervals lengths We present three cases of what a swap does to two arbitrary intervals Notice how the sum of the lengths increases only in the first case We want the distance between the first interval s right endpoint and the second interval s left endpoint to be as large as possible So we choose integers and such that and is maximized We add twice the value if it is positive to the original absolute beauty If the value is or negative we simply do nothing To quickly find the maximum of over all and we find the maximum of and the minimum of Subtracting the two extremum values produces the desired result 
https://codeforces.com//contest/766/problem/D,92734,D,766D,766,D. Mahmoud and a Dictionary,Mahmoud wants to write a new dictionary that contains words and relations between them There are two types of relations synonymy i e the two words mean the same and antonymy i e the two words mean the opposite From time to time he discovers a new relation between two words He know that if two words have a relation between them then each of them has relations with the words that has relations with the other For example if means and is the opposite of then is also the opposite of One more example if is the opposite of and is the opposite of then means and so on Sometimes Mahmoud discovers a wrong relation A wrong relation is a relation that makes two words equal and opposite at the same time For example if he knows that means and is the opposite of and then he figures out that means the last relation is absolutely wrong because it makes and opposite and have the same meaning at the same time After Mahmoud figured out many relations he was worried that some of them were wrong so that they will make other relations also wrong so he decided to tell every relation he figured out to his coder friend Ehab and for every relation he wanted to know is it correct or wrong basing on the previously discovered relations If it is wrong he ignores it and doesn t check with following relations After adding all relations Mahmoud asked Ehab about relations between some words based on the information he had given to him Ehab is busy making a Codeforces round so he asked you for help ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nstring u, v;\nint n, m, q;\nint t;\nstring s[100100];\nmap <string, int> id;\nint p[200200];\n\nint get(int v){\n    if(p[v] == v) return v;\n    return p[v] = get(p[v]);\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n >> m >> q;\n    for(int i = 0; i < n; ++i){\n        cin >> s[i];\n        id[s[i]] = i;\n        p[i] = i;\n        p[i + n] = i + n;\n    }\n    for(int i = 0; i < m; ++i){\n        cin >> t >> u >> v;\n        int x = id[u];\n        int y = id[v];\n        if(t == 1){\n            if(get(x) == get(y + n)) cout << ""NO"" << ""\\n"";\n            else{\n                if(get(x) != get(y)){\n                    p[get(x)] = get(y);\n                }\n                if(get(x + n) != get(y + n)){\n                    p[get(x + n)] = get(y + n);\n                }\n                cout << ""YES"" << ""\\n"";\n            }\n        }else{\n            if(get(x) == get(y)){\n                cout << ""NO"" << ""\\n"";\n            }else{\n                if(get(x) != get(y + n)){\n                    p[get(x)] = get(y + n);\n                }\n                if(get(x + n) != get(y)){\n                    p[get(x + n)] = get(y);\n                }\n                cout << ""YES"" << ""\\n"";\n            }\n        }\n    }\n    for(int i = 0; i < q; ++i){\n        cin >> u >> v;\n        int x = id[u];\n        int y = id[v];\n        if(get(x) == get(y)) cout << 1 << ""\\n"";\n        else{\n            if(get(x) == get(y + n)) cout << 2 << ""\\n"";\n            else cout << 3 << ""\\n"";\n        }\n    }\n}\n']",,,"['data structures', 'dfs and similar', 'dp', 'dsu', 'graphs']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Mahmoud and a Dictionary.json,https://codeforces.com//blog/entry/50294,Let s build a graph containing the words For every relation in the input add a new edge with the weight of if they are equal and if they are opposites If adding the edge doesn t make the graph cyclic Our relation is valid Otherwise it may be valid or invalid so we ll answer them offline Check if adding that edge will make the graph cyclic or not using union find like Kruskal s algorithm Suspend answering relations that will make the graph cyclic Now we have a forest of trees Let be the xor of the weights on the edges in the path from the root of the component of node to node Calculate it using dfs To find the relation between 2 words and Check if they are in the same component using union find If they aren t The answer is otherwise the answer is Now to answer suspended relations Find the relation between the 2 words and check if it s the same as the input relation Then answer the queries Code http pastebin com WqwduaYs Time complexity where is the length of the longest string considering that union find works in constant time Problem author mahmoudbadawy Solution author me Testers me and mahmoudbadawy Wait for a hard version of this problem 
https://codeforces.com//contest/2044/problem/D,3086855,D,2044D,2044,D. Harder Problem,Given a sequence of positive integers a positive integer is called a of the sequence if it occurs the maximum number of times that any positive integer occurs For example the mode of 2 2 3 is 2 Any of 9 8 or 7 can be considered to be a mode of the sequence 9 9 8 8 7 7 You gave UFO an array a of length n To thank you UFO decides to construct another array b of length n such that a i is a mode of the sequence b 1 b 2 ldots b i for all 1 leq i leq n However UFO doesn t know how to construct array b so you must help her Note that 1 leq b i leq n must hold for your array for all 1 leq i leq n ,"['/// YVKNTD#include <bits/stdc++.h>#define int long long#define ld long double#define f(i, a, b) for(int i = a; i <= b; i++)#define fr(i, a, b) for(int i = a; i >= b; i--)#define pii pair <int, int>#define fi first#define se second#define pb push_back#define eb emplace_back#define in insert#define arr(x) array <int, x>#define vvec vector<vector<int>>#define Keiiiii ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\xa0using namespace std;\xa0const int N = 2e5 + 5;const int mod = 1e9 + 7;const int inf = 1e16;int n, a[N];\xa0void READ(){    cin >> n;    f(i, 1, n) cin >> a[i];}\xa0void SOLVE(){    set <int> s;    f(i, 1, n) s.in(i);    f(i, 1, n)    {        if(s.find(a[i]) != s.end()) cout << a[i] << "" "", s.erase(a[i]);        else cout << *s.begin() << "" "", s.erase(s.begin());    }    cout << ""\\n"";}\xa0signed main(){    Keiiiii    if(fopen(""TASK.INP"", ""r""))    {        freopen(""TASK.INP"", ""r"", stdin);        freopen(""TASK.OUT"", ""w"", stdout);    }    #define TASK ""C""    if(fopen(TASK "".INP"", ""r""))    {        freopen(TASK "".INP"", ""r"", stdin);        freopen(TASK "".OUT"", ""w"", stdout);    }    int TEST = 1; cin >> TEST;    while(TEST--)    {        READ();        SOLVE();    }    cerr << ""\\nTime elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << ""s\\n"";    return 0;}\xa0///    /\\_/\\///   (= ._.)///   / >  \\>']",,,"['constructive algorithms', 'greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Harder Problem.json,https://codeforces.com//blog/entry/137306,Problem Credits cry Proof by QED Analysis macaquedev Solution Observe that if you have an array where all elements are unique they will all have frequency therefore they can all be classified as the mode Therefore it follows that the strategy for the construction is to just construct an array where for each prefix the last element of this prefix appears in the array at least once An easy way of doing is this is such For each element if this value has appeared previously in the array you can use a set to check this set equal to some random integer that isn t used elsewhere in the list and keep going Otherwise set 
https://codeforces.com//contest/208/problem/B,1578,B,208B,208,B. Solitaire,A boy named Vasya wants to play an old Russian solitaire called Accordion In this solitaire the player must observe the following rules A deck of cards is carefully shuffled then all cards are put on the table in a line from left to right Before each move the table has several piles of cards lying in a line initially there are piles each pile has one card Let s number the piles from left to right from 1 to During one move a player can take the whole pile with the maximum number that is the rightmost of remaining and put it on the top of pile if it exists or on the top of pile if it exists The player can put one pile on top of another one only if the piles top cards have the same suits or values Please note that if pile goes on top of pile then the top card of pile becomes the top card of the resulting pile Also note that each move decreases the total number of piles by 1 The solitaire is considered completed if all cards are in the same pile Vasya has already shuffled the cards and put them on the table help him understand whether completing this solitaire is possible or not ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<cstring>\n#include<iostream>\n#include<ctype.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<iomanip>\n#include<complex>\n#include<utility>\n\n#define X first\n#define Y second\n#define REP_0(i,n) for(int i=0;i<(n);++i)\n#define REP_1(i,n) for(int i=1;i<=(n);++i)\n#define REP_2(i,a,b) for(int i=(a);i<(b);++i)\n#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))\n#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)\n#define DOW_1(i,n) for(int i=(n);0<i;--i)\n#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)\n#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)\n#define FOREACH(a,b) for(typeof(b.begin()) a=(b).begin();a!=(b).end();++a)\n#define RFOREACH(a,b) for(typeof(b.rbegin()) a=(b).rbegin();a!=b.rend();++a)\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define IS insert\n#define ES erase\n#define IT iterator\n#define RI reserve_iterator\n#define PQ priority_queue\n#define LB lower_bound\n#define UB upper_bound\n\n#define PI 3.1415926535897932384626433832795\n#define EXP 2.7182818284590452353602874713527\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef double DB;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef pair<int,PII> PIII;\ntypedef pair<LD,int> PLDI;\ntypedef vector<PII> VII;\n\ntemplate<class T>\nT By(T x,T y,T P){\n\tT F1=0;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1+=x;\n\t\t\tif(F1<0||F1>=P)F1-=P;\n\t\t}\n\t\tx<<=1;\n\t\tif(x<0||x>=P)x-=P;\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Mul(T x,T y,T P){\n\tT F1=1;x%=P;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1=By(F1,x,P);\n\t\t}\n\t\tx=By(x,x,P);\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Gcd(T x,T y){\n\tif(y==0)return x;\n\tT z;\n\twhile(z=x%y){\n\t\tx=y,y=z;\n\t}\n\treturn y;\n}\n\nstruct EDGE{\n\tint T;EDGE *Nxt;\n};\n\ntemplate<class T>\nvoid UpdataMin(T &x,T y){\n\tif(y<x)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nvoid UpdataMax(T &x,T y){\n\tif(x<y)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nT Sqr(const T x){\n\treturn x*x;\n}\n\n#define MaxBuffer 20000000\nclass ReadBuffer{\n\tchar buff[MaxBuffer];\n\tchar *buf;\n\tvoid init(int size=MaxBuffer)\n\t{\n\t\tfread(buff,1,size,stdin);\n\t}\n\ttemplate<class T>\n\tbool readInterger(T &x)\n\t{\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag;\n\t\tflag=0;\n\t\tif(*buf==\'-\') flag=true;\n\t\telse x=*buf-\'0\';\n\t\twhile(isdigit(*++buf)) x=x*10+*buf-\'0\';\n\t\tif(flag) x=-x;\n\t\treturn true;\n\t}\n\ttemplate<class T>\n\tbool readFloat(T &x)\n\t{\n\t\tlong double nowpos=0.1;\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag,decimal;\n\t\tdecimal=flag=0;\n\t\tif(*buf==\'-\') flag=true,++buf;\n\t\telse if(*buf==\'.\') decimal=true;\n\t\twhile(isdigit(*buf)||*buf==\'.\')\n\t\t{\n\t\t\tif(*buf==\'.\') decimal=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(decimal)\n\t\t\t\t{\n\t\t\t\t\tx+=nowpos*(*buf-\'0\');\n\t\t\t\t\tnowpos*=0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx=x*10+*buf-\'0\';\n\t\t\t\t}\n\t\t\t}\n\t\t\t++buf;\n\t\t}\n\t\treturn true;\n\t}\n\tbool readChar(char c)\n\t{\n\t\tif(*buf==0) return 0;\n\t\treturn c=*buf++,1;\n\t}\n\tbool readString(char *s)\n\t{\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(!*buf) return false;\n\t\twhile(!isspace(*buf)) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn true;\n\t}\n\tint countSpacetonext(){\n\t\tint total=0;\n\t\twhile(*buf&&*buf==\' \') ++total,++buf;\n\t\treturn total;\n\t}\n\tbool splitBycharactor(char *s,char Split=\'\\n\'){\n\t\twhile(*buf&&*buf!=Split) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn *buf!=0;\n\t}\n};\n\nbool dp[55][55][55][55];\n\nchar card[55][5];\nint n;\n\nbool check(int i,int j){\n\treturn card[i][0]==card[j][0]||card[i][1]==card[j][1];\n}\nbool check3(){\n\tREP_1(i,n) if(!check(i,n)) return false;\n\treturn true;\n}\nbool checkall(){\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tif(dp[1][i][j][k]&&check(i,k)&&check(j,k))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n//\tfreopen(""a.out"",""w"",stdout);\n\tscanf(""%d"",&n);\n\tREP_1(i,n)\n\t{\n\t\tscanf(""%s"",card[i]);\n\t}\n\tif(n<=3)\n\t{\n\t\tprintf(""%s\\n"",check3()?""YES"":""NO"");\n\t}\n\telse\n\t{\n\t\tdp[n-2][n-2][n-1][n]=1;\n\t\tfor(int i=n-2;i>1;--i)\n\t\t{\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=1;l<=n;++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(dp[i][j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(check(i-1,l)) dp[i-1][l][j][k]=1;\n\t\t\t\t\t\t\tif(check(k,l)) dp[i-1][i-1][j][l]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(""%s\\n"",checkall()?""YES"":""NO"");\n\t}\n\tcin>>card[0];\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dp']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Solitaire.json,https://codeforces.com/blog/entry/4930,In this problem you could write breadth first search The state is the following four elements number of remaining piles and three strings three rightmost cards on the top of three rightmost piles We have two transitions in general case We can take the rightmost pile and shift it left by or on another pile If the number of remaining piles become at some moment print else print The number of states is the number of transitions so the complexity of solution is 
https://codeforces.com//contest/1899/problem/A,2331128,A,1899A,1899,A. Game with Integers,Vanya and Vova are playing a game Players are given an integer n On their turn the player can add 1 to the current integer or subtract 1 The players take turns Vanya starts If Vanya s move the integer is divisible by 3 then he wins If 10 moves have passed and Vanya has not won then Vova wins Write a program that based on the integer n determines who will win if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int t;\n        cin >> t;\n        while (t--) {\n                int n;\n                cin >> n;\n                cout << (n % 3 ? ""First\\n"" : ""Second\\n"");\n        }\n}']",,,"['games', 'math', 'number theory']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Game with Integers.json,https://codeforces.com//blog/entry/122407,EditorialConsider the remainder from dividing by before the first move If it is equal to or then Vanya can make the number divisible by after the first move i e he wins Let the remainder be then Vanya must change the number after which it will not be divisible by Then Vova can do the same operation as Vanya and make it divisible by again This will go on indefinitely so Vova wins 
https://codeforces.com//contest/1707/problem/D,1465656,D,1707D,1707,D. Partial Virtual Trees,Kawashiro Nitori is a girl who loves competitive programming One day she found a rooted tree consisting of n vertices The root is vertex 1 As an advanced problem setter she quickly thought of a problem Kawashiro Nitori has a vertex set U 1 2 ldots n She s going to play a game with the tree and the set In each operation she will choose a vertex set T where T is a of U and change U into T A vertex set S 1 is a partial virtual tree of a vertex set S 2 if S 1 is a subset of S 2 S 1 neq S 2 and for all pairs of vertices i and j in S 1 operatorname LCA i j is in S 1 where operatorname LCA x y denotes the lowest common ancestor of vertices x and y on the tree Note that a vertex set can have many different partial virtual trees Kawashiro Nitori wants to know for each possible k if she performs the operation k times in how many ways she can make U 1 in the end Two ways are considered different if there exists an integer z 1 le z le k such that after z operations the sets U are different Since the answer could be very large you need to find it modulo p It s guaranteed that p is a prime number ,"['#include <cstdio>\n\nint n;\nint P=998244353;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\nint qsm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint head[100001],nxt[200001],b[200001],k;\nvoid push(int s,int t){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n}\nint f[2010][2010],g[2010][2010];\nint tem[2010][2010],zero[2010][2010];\nvoid dfs(int x,int F){\n\tfor(int i=1;i<=n-1;++i)tem[x][i]=1,zero[x][i]=0;\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=F){\n\t\t\tdfs(b[i],x);\n\t\t\tfor(int j=1,sum=0;j<=n-1;++j){\n\t\t\t\tsum=add(f[b[i]][j],sum);\n\t\t\t\tif(!sum)++zero[x][j];\n\t\t\t\telse tem[x][j]=mul(tem[x][j],sum);\n\t\t\t}\n\t\t}\n\tif(x==1){\n\t\tfor(int i=1;i<=n-1;++i)f[x][i]=(zero[x][i]?0:tem[x][i]);\n\t\treturn;\n\t}\n\tfor(int i=1;i<=n-1;++i)f[x][i]=(zero[x][i]?0:tem[x][i]);\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=F){\n\t\t\tfor(int j=1,sum=0,all=0;j<=n-1;++j){\n\t\t\t\tsum=add(f[b[i]][j],sum);\n\t\t\t\tf[x][j]=add(f[x][j],mul(all,f[b[i]][j]));\n\t\t\t\tall=add(all,((sum!=0)?(zero[x][j]?0:mul(tem[x][j],qsm(sum,P-2))):(zero[x][j]==1?tem[x][j]:0)));\n\t\t\t}\n\t\t}\n\t// printf(""dfs %d: "",x);\n\t// for(int i=1;i<n;++i)printf(""%d "",f[x][i]);putchar(\'\\n\');\n}\nint C[2010][2010];\nint main(){\n\tscanf(""%d%d"",&n,&P);\n\tfor(int i=0;i<=n;++i){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tC[i][j]=add(C[i-1][j],C[i-1][j-1]);\n\t}\n\tfor(int i=1,u,v;i<n;++i)scanf(""%d%d"",&u,&v),push(u,v),push(v,u);\n\tdfs(1,0);\n\tfor(int i=1;i<=n-1;++i){\n\t\tfor(int j=1;j<i;++j)\n\t\t\tf[1][i]=sub(f[1][i],mul(f[1][j],C[i][j]));\n\t\tprintf(""%d "",f[1][i]);\n\t}\n}']",,,"['combinatorics', 'dfs and similar', 'dp', 'math', 'trees']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Partial Virtual Trees.json,https://codeforces.com//blog/entry/104930,First ignore the requirement that the virtual tree cannot be the entire tree Then we count the number of ways without this requirement for all using DP is the number of ways to delete everything in the subtree of in exact operations Node must be deleted at some time and all but at most one child subtree of must be deleted before time Let be the set of s children ThenSpecially when is root is the last one to be deleted So in this case It s not hard to computer this with prefix sums in time Then consider the requirement that the virtual tree cannot be the entire tree Let the real answer be ThenSo we can figure out the real answer in time 
https://codeforces.com//contest/416/problem/C,8297,C,416C,416,C. Booking System,Innovation technologies are on a victorious march around the planet They integrate into all spheres of human activity A restaurant called Dijkstra s Place has started thinking about optimizing the booking system There are booking requests received by now Each request is characterized by two numbers and the size of the group of visitors who will come via this request and the total sum of money they will spend in the restaurant correspondingly We know that for each request all people want to sit at the same table and are going to spend the whole evening in the restaurant from the opening moment at 18 00 to the closing moment Unfortunately there only are tables in the restaurant For each table we know the maximum number of people who can sit at it A table can have only people from the same group sitting at it If you cannot find a large enough table for the whole group then all visitors leave and naturally pay nothing Your task is given the tables and the requests decide which requests to accept and which requests to decline so that the money paid by the happy and full visitors was maximum ,"[""#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 1000 + 10;\n\nint n, k;\nint c[N], p[N], r[N];\nint vis[N];\npair<int, int> b[N];\npair< pair<int, int>, int> a[N];\n\nvoid solve()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tcin >> c[i] >> p[i];\n\t\ta[i] = make_pair(make_pair(p[i], - c[i]), i);\n\t}\n\tsort(a, a + n);\n\tcin >> k;\n\tfor(int i = 0; i < k; ++ i) {\n\t\tcin >> r[i];\n\t\tb[i] = make_pair(r[i], i);\n\t}\n\tsort(b, b + k);\n\n\tint ret = 0;\n\tvector< pair<int, int> > vec;\n\n\tfor(int i = n - 1; i >= 0; -- i) {\n\t\tint tmp = -a[i].first.second;\n\n\t\tfor(int j = 0; j < k; ++ j) {\n\t\t\tif (b[j].first >= tmp && ! vis[j]) {\n\t\t\t\tvis[j] = true;\n\t\t\t\tret += a[i].first.first;\n\t\t\t\tvec.push_back(make_pair(a[i].second + 1, b[j].second + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << vec.size() << ' ' << ret << endl;\n\tfor(int i = 0; i < vec.size(); ++ i) {\n\t\tcout << vec[i].first << ' ' << vec[i].second << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n""]",,,"['binary search', 'dp', 'greedy', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Booking System.json,https://codeforces.com//blog/entry/12277,Let s solve this one greedy All we need to notice is that the optimal solution will be to place first the groups with biggest sum which they are ready to pay For each such group it will be optimal to allocate the smallest matching table The input limits allow to do a full search when looking for a table Submission 6617198 
https://codeforces.com//contest/568/problem/B,32824,B,568B,568,B. Symmetric and Transitive,Little Johnny has recently learned about set theory Now he is studying binary relations You ve probably heard the term equivalence relation These relations are very important in many areas of mathematics For example the equality of the two numbers is an equivalence relation A set of pairs of elements of some set is called a binary relation on set For two elements and of the set we say that they are in relation if pair in this case we use a notation Binary relation is if It is reflexive for any it is true that It is symmetric for any it is true that if then It is transitive if and than Little Johnny is not completely a fool and he noticed that the first condition is not necessary Here is his proof Take any two elements and If then according to property 2 which means according to property 3 It s very simple isn t it However you noticed that Johnny s proof is wrong and decided to show him a lot of examples that prove him wrong Here s your task count the number of binary relations over a set of size such that they are symmetric transitive but not an equivalence relations i e they are not reflexive Since their number may be very large not according to Little Johnny print the remainder of integer division of this number by ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#ifdef WIN32\n\t#define LLD ""%I64d""\n#else\n\t#define LLD ""%lld""\n#endif\n\n#define pb push_back\n#define all(x) begin(x), end(x)\n\nconst int MOD = 1000000007;\n\nconst int maxn = 4005;\n\nint c[maxn][maxn];\nint cnt[maxn], cnt2[maxn];\n\nvoid add(int &a, ll b)\n{\n    a = (a + b) % MOD;\n}\n\nint main()\n{\n    int n;\n    scanf(""%d"", &n);\n    c[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\n    }\n    cnt[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 1; j + i <= n; j++) add(cnt[i + j], (ll)cnt[i] * c[n - i - 1][j - 1]);\n    }\n    cnt2[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 1; j + i <= n; j++) add(cnt2[i + j], (ll)cnt2[i] * c[n - i - 1][j - 1]);\n        add(cnt2[i + 1], cnt2[i]);\n    }\n    int answer = (cnt2[n] - cnt[n] + MOD) % MOD;\n//     for (int i = 0; i < n; i++) add(answer, cnt[i]);\n    cout << answer << endl;\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Symmetric and Transitive.json,https://codeforces.com//blog/entry/19705,Let s find Johnny s mistake It is all right in his proof except If part What if there is no such for an given Then obviously otherwise we ll take We can see that our binary relation is some equivalence relation which was expanded by some empty elements For empty element there is no such that Thus we can divide our solution into two parts Count the number of equivalence relations on sets of size For every size count the number of ways to expand it with some empty elements We can define equivalence relation using its equivalence classes So first part can be solved using dynamic programming the numbers of ways to divide first elements to equivalence classes When we handle next element we can send it to one of the existing equivalence classes or we can create new class Let s solve second part Consider set of size We have found that there are ways to build equivalence relation on this set We have to add empty elements to this set The number of ways to choose their positions is We can calculate all the binomial coefficients using Pascal s triangle So the answer to the problem is Complexity 
https://codeforces.com//contest/330/problem/A,3349,A,330A,330,A. Cakeminator,You are given a rectangular cake represented as an grid Each cell either has an evil strawberry or is empty For example a cake may look as follows The cakeminator is going to eat the cake Each time he eats he chooses a row or a column that does not contain any evil strawberries and contains at least one cake cell that has not been eaten before and eats all the cake cells there He may decide to eat any number of times Please output the maximum number of cake cells that the cakeminator can eat ,"['#include <stdio.h>\n#include <memory.h>\n#define clr(u) memset(u,0,sizeof(u))\n\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n\tint i,j,k;\n\tint ni,nj;\n\tchar s[15][15];\n\tscanf(""%d%d\\n"",&ni,&nj);\n\n\tfor(i=0;i<ni;i++)scanf(""%s"", s[i]);\n\n\tbool vis[15][15];\n\tclr(vis);\n\n\tint ans=0;\n\n\tfor(i=0;i<ni;i++){\n\t\tfor(j=0;j<nj;j++)if(s[i][j]==\'S\')break;\n\t\tif(j==nj){\n\t\t\tfor(j=0;j<nj;j++){\n\t\t\t\tif(!vis[i][j])ans++;\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(j=0;j<nj;j++){\n\t\tfor(i=0;i<ni;i++)if(s[i][j]==\'S\')break;\n\t\tif(i==ni){\n\t\t\tfor(i=0;i<ni;i++){\n\t\t\t\tif(!vis[i][j])ans++;\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Cakeminator.json,https://codeforces.com//blog/entry/8417,Long solution Short solution If there are r rows that cannot be eaten and c columns that cannot be eaten then there are r c cells that cannot be eaten a cell such that both its row and columns cannot be eaten Since all other cells can be eaten answer is R C r c 
https://codeforces.com//contest/1593/problem/G,1142168,G,1593G,1593,G. Changing Brackets,A sequence of round and square brackets is given You can change the sequence by performing the following operations change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket i e you can change to and to you can change to and to The operation costs 0 burles change any bracket to bracket having the same direction i e you can change to but from to similarly you can change to but from to The operation costs 1 burle The operations can be performed in any order any number of times You are given a string s of the length n and q queries of the type where 1 le l r le n For every substring s l dots r find the minimum cost to pay to make it a correct bracket sequence It is guaranteed that the substring s l dots r has an even length The queries must be processed independently i e the changes made in the string for the answer to a question i don t affect the queries j j i In other words for every query the substring s l dots r is given from the initially given string s A correct bracket sequence is a sequence that can be built according the following rules an empty sequence is a correct bracket sequence if is a correct bracket sequence the sequences and are correct bracket sequences if and are correct bracket sequences the sequence the concatenation of the sequences is a correct bracket sequence E g the sequences and are correct bracket sequences whereas and are not ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=1000005;\nint t,sum[N],q,l,r;\nstring s;\nint main() {\n   \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>s;\n        for (int i=0;i<s.length();i++) {\n            sum[i+1]=sum[i];\n            if (s[i]==\'[\'||s[i]==\']\') {\n                if (i%2) sum[i+1]++;\n                else sum[i+1]--;\n            }\n        }\n        cin>>q;\n        for (int i=1;i<=q;i++) {\n            cin>>l>>r;\n            cout<<abs(sum[r]-sum[l-1])<<""\\n"";\n        }\n    }\n}\n']",,,"['constructive algorithms', 'data structures', 'dp', 'greedy']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Changing Brackets.json,https://codeforces.com//blog/entry/96034,Consider a substring Let s call square brackets located in odd positions in the substring brackets and square brackets located in even positions brackets Let be the number of odd brackets be the number of even brackets be the number of all square brackets Let s prove that the string can be turned into a correct bracket sequence for burles if and only if Let s prove the necessary condition Suppose the initial substring has been turned into a correct bracket sequence Since we have paid burles there s no bracket which form has been changed Therefore for the new sequence is the same as for the initial sequence the similar situation happens with Let s say that two square brackets form a pair if the left one is an opening bracket and the right one is a closing bracket and the substring between them is a correct bracket sequence A pair can be formed only by one odd bracket and one even bracket because between them is placed an even number of brackets since it s a correct bracket sequence so the difference between their indices is odd In a correct bracket sequence each square bracket has a pairwise bracket Therefore a correct bracket sequence contains pairs of brackets so Let s prove the sufficient condition Suppose the initial substring contains equal numbers of odd and even brackets Let s prove by induction that the substring may be turned into a correct bracket sequence for burles Suppose So the initial substring contains only round brackets Let s make the first brackets opening and the other brackets closing The resulting sequence is a correct bracket sequence whereas we haven t changed the form of any bracket so the cost is equal to A correct bracket sequence has two important properties after deleting its substring being a correct bracket sequence the resulting string is a correct bracket sequence after inserting at any place any correct bracket sequence the resulting string is a correct bracket sequence These properties can be applied to an incorrect bracket sequence too after deleting a substring being a correct bracket subsequence from an incorrect bracket sequence or inserting a correct bracket sequence into an incorrect one the resulting sequence is an incorrect bracket sequence Consider a substring such that Suppose we have proved before that each substring having decreased by can be turned into a correct bracket sequence for burles Let s find two square brackets such that one of them is odd and another one is even and there are no square brackets between them There s an even number of round brackets between them that can be turned into a correct bracket sequence for burles Let s make the left found bracket opening and the right one closing Then the substring starting at the left found bracket and ending at the right found bracket is a correct bracket sequence Let s remove it from The resulting string contains odd brackets and even brackets so by the assumption of induction it can be turned into a correct bracket sequence for burles Let s do it and then insert the removed string into its place Since we insert a correct bracket sequence into a correct bracket sequence the resulting string is a correct bracket sequence Actually the operations of inserting and removing are not allowed they have been used for clarity the string can be turned into a correct bracket sequence without these operations as follows let s turn the substring we have removed into a correct bracket sequence as it was described above then change the other brackets of the string the same way as it was done with the string that was the result after removing The resulting string is a correct bracket sequence Therefore the illegal operations of inserting and removing are not necessary all other operations cost burles so the substring can be turned into a correct bracket sequence for burles Therefore to turn a substring into a correct bracket sequence we need to get a sequence such that Suppose initiallly Let s pay burles to replace odd brackets with round brackets If let s replace even brackets with round brackets Anyway we must pay burles We cannot pay less than this value because for a correct bracket sequence But there s no need to pay more than this value because if we turn the initial substring into a sequence with we can turn it into a correct bracket sequence for free Therfore the answer for a given question is Since we must answer the queries fast let s use a concept of prefix sums If the given string contains brackets let s create arrays and with the length will contain the number of odd brackets on the prefix of the string with the length the same value for even brackets Let s initialize and then iterate from to Let s initialize and If the th bracket is round then the current values are correct Otherwise let s find out what bracket is it If is odd the bracket is odd so we must increase by If is even the bracket is even so we must increase by To get the answer for a current and let s calculate and is a number of odd brackets that belong to the prefix with the length but not to the prefix with the length so Similarly The remaining thing is to output 
https://codeforces.com//contest/1633/problem/E,1280037,E,1633E,1633,E. Spanning Tree Queries,You are given a connected weighted undirected graph consisting of n vertices and m edges You are asked k queries about it Each query consists of a single integer x For each query you select a spanning tree in the graph Let the weights of its edges be w 1 w 2 dots w n 1 The cost of a spanning tree is sum limits i 1 n 1 w i x the sum of absolute differences between the weights and x The answer to a query is the lowest cost of a spanning tree The queries are given in a compressed format The first p 1 le p le k queries q 1 q 2 dots q p are provided explicitly For queries from p 1 to k q j q j 1 cdot a b mod c Print the xor of answers to all queries ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::array<int, 3>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        std::cin >> u >> v >> w;\n        u--;\n        v--;\n        edges[i] = {w, u, v};\n    }\n    \n    int p, k, a, b, c;\n    std::cin >> p >> k >> a >> b >> c;\n    \n    std::vector<int> q(k);\n    for (int i = 0; i < p; i++) {\n        std::cin >> q[i];\n    }\n    for (int i = p; i < k; i++) {\n        q[i] = (1LL * a * q[i - 1] + b) % c;\n    }\n    \n    std::sort(q.begin(), q.end());\n    \n    std::vector<int> e{0};\n    std::sort(edges.begin(), edges.end());\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = i; j < m; j++) {\n            e.push_back((edges[i][0] + edges[j][0] + 1) / 2);\n        }\n    }\n    \n    std::sort(e.begin(), e.end());\n    \n    i64 coef = 0, cons = 0;\n    \n    i64 ans = 0;\n    \n    for (int i = 0, j = 0; i < k; i++) {\n        int oj = j;\n        while (j < int(e.size()) && q[i] >= e[j]) {\n            j++;\n        }\n        \n        if (oj != j) {\n            std::sort(edges.begin(), edges.end(), [&](auto a, auto b) {\n                int x = std::abs(a[0] - e[j - 1]);\n                int y = std::abs(b[0] - e[j - 1]);\n                if (x != y) {\n                    return x < y;\n                } else {\n                    return a[0] > b[0];\n                }\n            });\n            \n            coef = cons = 0;\n            \n            DSU g(n);\n            for (auto [w, u, v] : edges) {\n                if (g.merge(u, v)) {\n                    if (w > e[j - 1]) {\n                        coef--;\n                        cons += w;\n                    } else {\n                        coef++;\n                        cons -= w;\n                    }\n                }\n            }\n        }\n        \n        ans ^= coef * q[i] + cons;\n    }\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']",,,"['binary search', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'math', 'sortings', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Spanning Tree Queries.json,https://codeforces.com//blog/entry/99539,Consider a naive solution using Kruskal s algorithm for finding MST Given some you arrange the edges in the increasing order of and process them one by one Look closely at the arrangements At the edges are sorted by How does the arrangement change when increases Well some edges swap places Consider a pair of edges with different weights and Edge will go before edge in the arrangement as long as is closer to than So for all up to edge goes before edge And for all from onwards edge goes before edge This tells us that every pair of edge with different weights will swap exactly once So there will be at most swaps Which is at most different arrangements Each of them corresponds to some range of s We can extract the ranges of s for all arrangements and calculate MST at the start of each range We can also find the arrangement that corresponds to some from a query with a binary search However only knowing the weight of the MST at the start of the range is not enough The weights of edges change later in the range and we can t predict how Some edges have their weight increasing some decreasing First let s add more ranges We want each edge to behave the same way on the entire range either increase all the way or decrease all the way If we also add for all into the MST calculation this will hold Second let s store another value for each range the number of edges that have their weight increasing on it With that we can easily recalculate the change in the cost of the spanning tree The TL should be free enough for you to sort the edges for each MST calculation resulting in solution You can also optimize the first part to 
https://codeforces.com//contest/947/problem/F,164142,F,947F,947,F. Public Service,There are cities in Bob s country connected by roads Some pairs of cities are connected by public transport There are two competing transport companies operating buses and running trains When traveling from to a passenger always first selects the mode of transport either bus or train and then embarks on a journey For every pair of cities there are exactly two ways of how to travel between them without visiting any city more than once one using only bus routes and the second using only train routes Furthermore there is no pair of cities that is directly connected by both a bus route and a train route You obtained the plans of each of the networks Unfortunately each of the companies uses different names for the same cities More precisely the bus company numbers the cities using integers from to while the train company uses integers between and Find one possible mapping between those two numbering schemes such that no pair of cities is connected directly by both a bus route and a train route Note that this mapping has to map different cities to different cities ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 10000;\n\nstruct T {\n\tint n;\n\tvector<int> adj[MAXN];\n\n\tbool alive[MAXN]; int nalive;\n\tint deg[MAXN];\n\tint afst[MAXN], alst[MAXN], anxt[MAXN], aprv[MAXN]; // doubly-linked lists for leaves adjacent to a node\n\tint bfst, blst, bnxt[MAXN], bprv[MAXN]; // doubly-linked lists for nodes adjacent to at least one leaf\n\tpriority_queue<pair<int, int> > pq;\n\n\tvoid init() {\n\t\tnalive = n; REP(i, n) alive[i] = true, deg[i] = SZ(adj[i]), afst[i] = alst[i] = -1; bfst = blst = -1;\n\t\tREP(at, n) if (deg[at] == 1) aappend(at, adj[at][0]);\n\t\tREP(at, n) if (afst[at] != -1) bappend(at);\n\t\tpq = priority_queue<pair<int, int> >(); REP(i, n) pq.push(MP(deg[i], i));\n\t}\n\tvoid killleaf(int at) {\n\t\tassert(deg[at] == 1); alive[at] = false; --nalive;\n\t\tint to = -1; REPSZ(i, adj[at]) if (alive[adj[at][i]]) { assert(to == -1); to = adj[at][i]; } assert(to != -1);\n\t\t--deg[at]; if (deg[at] == 0) { aremove(at, to); if (afst[to] == -1) bremove(to); }\n\t\t--deg[to]; pq.push(MP(deg[to], to)); if (deg[to] == 0) { aremove(to, at); if (afst[at] == -1) bremove(at); }\n\t\tif (deg[to] == 1) {\n\t\t\tint oth = -1; REPSZ(i, adj[to]) if (alive[adj[to][i]]) { assert(oth == -1); oth = adj[to][i]; } assert(oth != -1);\n\t\t\taappend(to, oth);\n\t\t\tif (afst[oth] == to&&anxt[to] == -1) bappend(oth);\n\t\t}\n\t}\n\tvoid aappend(int at, int to) {\n\t\taprv[at] = alst[to], anxt[at] = -1; if (aprv[at] == -1) afst[to] = at; else anxt[aprv[at]] = at; alst[to] = at;\n\t}\n\tvoid aremove(int at, int to) {\n\t\tif (aprv[at] == -1) afst[to] = anxt[at]; else anxt[aprv[at]] = anxt[at];\n\t\tif (anxt[at] == -1) alst[to] = aprv[at]; else aprv[anxt[at]] = aprv[at];\n\t}\n\tvoid bappend(int at) {\n\t\tbprv[at] = blst, bnxt[at] = -1; if (bprv[at] == -1) bfst = at; else bnxt[bprv[at]] = at; blst = at;\n\t}\n\tvoid bremove(int at) {\n\t\tif (bprv[at] == -1) bfst = bnxt[at]; else bnxt[bprv[at]] = bnxt[at];\n\t\tif (bnxt[at] == -1) blst = bprv[at]; else bprv[bnxt[at]] = bprv[at];\n\t}\n\tbool getleavesatleastthreeapart(pair<int,int> &u, pair<int,int> &v) {\n\t\tif (bfst == -1 || bnxt[bfst] == -1) return false;\n\t\tint x = bfst, y = bnxt[bfst], r = maxdeg().second; if (afst[r] != -1 && x != r) y = r;\n\t\tu = MP(afst[x], x), v = MP(afst[y], y); assert(u.first != -1 && v.first != -1); return true;\n\t}\n\tpair<int, int> maxdeg() { while (!pq.empty() && (!alive[pq.top().second] || deg[pq.top().second] != pq.top().first)) pq.pop(); return !pq.empty() ? pq.top() : MP(0, -1); }\n\tbool isstar() { return maxdeg().first == nalive - 1; }\n\tbool issemistar() { return maxdeg().first == nalive - 2; }\n\tbool ispath() { return maxdeg().first <= 2; }\n\tbool getsemistar1(vector<int> &rem) {\n\t\tif (!issemistar()) return false; assert(bfst != -1 && bnxt[bfst] != -1 && bnxt[bnxt[bfst]] == -1);\n\t\tint w = maxdeg().second; assert(bfst == w || bnxt[bfst] == w); int v = bfst + bnxt[bfst] - w; assert(afst[v] != -1 && anxt[afst[v]] == -1); int u = afst[v];\n\t\trem.clear(); rem.PB(u); rem.PB(v); rem.PB(w); REP(i, n) if (alive[i] && i != u&&i != v&&i != w) rem.PB(i); return true;\n\t}\n\tbool getsemistar2(vector<int> &rem) {\n\t\tif (isstar()) return false; assert(bfst != -1 && bnxt[bfst] != -1); int u = bfst, w = afst[u], v = afst[bnxt[bfst]]; assert(w != -1 && u != -1);\n\t\trem.clear(); rem.PB(u); rem.PB(v); rem.PB(w); REP(i, n) if (alive[i] && i != u&&i != v&&i != w) rem.PB(i); return true;\n\t}\n\tbool getpath1(vector<int> &rem) {\n\t\tif (!ispath()) return false;\n\t\tint at = -1; REP(i, n) if (alive[i] && deg[i] <= 1) { at = i; break; } assert(at != -1);\n\t\trem.PB(at); while (true) { int to = -1; REPSZ(i, adj[at]) if (alive[adj[at][i]] && (SZ(rem) == 1 || adj[at][i] != rem[SZ(rem) - 2])) { assert(to == -1); to = adj[at][i]; } if (to == -1) break; at = to; rem.PB(at); } return SZ(rem) == 5;\n\t}\n\tbool getpath2(vector<int> &rem) {\n\t\tif (!getpath1(rem)) return false;\n\t\tswap(rem[0], rem[2]); swap(rem[0], rem[4]); swap(rem[0], rem[3]); swap(rem[0], rem[1]); return true;\n\t}\n};\n\nint n;\nT a, b;\nint mp[MAXN];\nstruct Op { pair<int, int> au, av, bu, bv; };\nvector<Op> ops;\n\n\nvoid run() {\n\tscanf(""%d"", &n);\n\ta.n = n; REP(i, n - 1) { int u, v; scanf(""%d%d"", &u, &v); --u, --v; a.adj[u].PB(v); a.adj[v].PB(u); } a.init();\n\tb.n = n; REP(i, n - 1) { int u, v; scanf(""%d%d"", &u, &v); --u, --v; u -= n; v -= n; b.adj[u].PB(v); b.adj[v].PB(u); } b.init();\n\n\tif (a.isstar() || b.isstar()) { printf(""No\\n""); return; }\n\tREP(i, n) mp[i] = -1; ops.clear();\n\twhile (true) {\n\t\t//printf(""maxdeg: (%d,%d) (%d,%d)\\n"", a.maxdeg().first, a.maxdeg().second + 1, b.maxdeg().first, b.maxdeg().second + 1 + n);\n\t\tif (a.issemistar()) {\n\t\t\t//printf(""a semistar\\n"");\n\t\t\tvector<int> arem; assert(a.getsemistar1(arem));\n\t\t\tvector<int> brem; assert(b.getsemistar2(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (b.issemistar()) {\n\t\t\t//printf(""b semistar\\n"");\n\t\t\tvector<int> arem; assert(a.getsemistar2(arem));\n\t\t\tvector<int> brem; assert(b.getsemistar1(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (a.nalive == 5 || b.nalive == 5) {\n\t\t\tassert(a.nalive == 5 && b.nalive == 5 && a.ispath() && b.ispath());\n\t\t\t//printf(""5 path\\n"");\n\t\t\tvector<int> arem; assert(a.getpath1(arem));\n\t\t\tvector<int> brem; assert(b.getpath2(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tassert(a.nalive >= 6 && b.nalive >= 6);\n\t\t//printf(""general case: "");\n\t\tpair<int,int> au, av; assert(a.getleavesatleastthreeapart(au, av));\n\t\tpair<int,int> bu, bv; assert(b.getleavesatleastthreeapart(bu, bv));\n\t\t//printf(""(%d,%d) and (%d,%d)\\n"", au.first + 1, av.first + 1, bu.first + n + 1, bv.first + n + 1);\n\t\ta.killleaf(au.first); a.killleaf(av.first);\n\t\tb.killleaf(bu.first); b.killleaf(bv.first);\n\t\tOp op; op.au = au, op.av = av, op.bu = bu, op.bv = bv; ops.PB(op);\n\t}\n\tfor (int i = SZ(ops) - 1; i >= 0; --i) {\n\t\tpair<int, int> au = ops[i].au, av = ops[i].av, bu = ops[i].bu, bv = ops[i].bv;\n\t\tif (mp[au.second] != bu.second&&mp[av.second] != bv.second) { mp[au.first] = bu.first; mp[av.first] = bv.first; continue; }\n\t\tif (mp[au.second] != bv.second&&mp[av.second] != bu.second) { mp[au.first] = bv.first; mp[av.first] = bu.first; continue; }\n\t\tassert(false);\n\t}\n\tprintf(""Yes\\n"");\n\tREP(i, n) { if (i != 0) printf("" ""); printf(""%d"", mp[i] == -1 ? -1 : mp[i] + n + 1); } puts("""");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']",,,"['constructive algorithms', 'graphs', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Public Service.json,https://codeforces.com//blog/entry/58286,For k 0 we call graph G a k star if we can remove k vertices to form a star and we cannot remove k 1 vertices to form a star In this terminology a 0 star is a star It should be rather obvious that if one of the graphs is a 0 star then the answer is clearly No This is because the minimum degree of a vertex in a tree is 1 and star has a vertex of degree N 1 and the corresponding vertex in the merged graph would have degree at least N which is clearly impossible Surprisingly the answer is Yes in all other cases We prove this by giving an explicit construction There are three cases Assume that one of the graphs is 1 star Without loss of generality let it be G Denote v the vertex that can be removed to turn G into star u its only neighbor and w be the vertex of degree N 2 In graph H find any leaf and denote it w Let its only neighbour be u Furthermore pick v a vertex that is not adjacent to u such vertex always exists as H is not a star Observe that mapping and does not introduce multiedges in the merged graph Furthermore all other edges in G are incident to w but none of the unprocessed edges in H are incident to w We can thus map the remaining N 3 vertices arbitrarily Mapping a 1 star G in red to arbitrary tree H in blue See that there are no multiedges between u v w no multiedges from u v w to the rest of the graph since u v and w have no neighbours there and no multiedges in the rest of the graph since is a graph with zero edges N 4 or N 5 There are only five non isomorphic trees on this many vertices Two of them are 0 stars for which the answer is No two of them are 1 stars that we handled in previous case The only remaining graph is a path on five vertices Two such graphs can always be merged together For simplicity of implementation we can simply try all 5 possible mappings All trees on 4 or 5 vertices Otherwise we use induction In G find two leaves u and v such that d u v 3 and is not a star This is always possible either G is a 2 star and then we can pick one of the neighbouring leaves of the vertex with highest degree and one other leaf or we can pick any two leaves that are not adjacent to the same vertex Do the same thing for H finding u and v Remove these pairs of vertices from the respective graphs and use induction to merge those smaller graphs Now we can either map or as only one of these mappings may introduce a multiedge The above is relatively simple to implement in To turn it into an algorithm we need to maintain a few additional information about the graph Furthemore note that a graph G is a k star if and only if the maximum degree is G k 1 The list vertices sorted by their degree for instance using set of pairs This is so that we can find the vertex with maximum degree easily which is useful for testing k starness the set of vertices with a leaf neighbour and the set of leaves neighbouring a given vertex so that we can find the leaves quickly Using the above we can always find appropriate leaf and remove it in which is sufficient 
https://codeforces.com//contest/521/problem/E,23442,E,521E,521,E. Cycling City,You are organizing a cycling race on the streets of the city The city contains junctions some pairs of them are connected by roads on each road you can move in any direction No two roads connect the same pair of intersections and no road connects the intersection with itself You want the race to be open to both professional athletes and beginner cyclists and that s why you will organize the race in three nominations easy moderate and difficult each participant will choose the more suitable nomination For each nomination you must choose the route the chain of junctions consecutively connected by roads Routes must meet the following conditions all three routes should start at the same intersection and finish at the same intersection place of start and finish can t be the same to avoid collisions no two routes can have common junctions except for the common start and finish and can not go along the same road irrespective of the driving direction on the road for those two routes no route must pass twice through the same intersection or visit the same road twice irrespective of the driving direction on the road for the first and second time of visit Preparing for the competition is about to begin and you need to determine the routes of the race as quickly as possible The length of the routes is not important it is only important that all the given requirements were met ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint N,M;\n\nvector <int> graph[200010];\nvector <int> child[200010];\nint parent[200010];\nbool used[200010];\nint aa[200010],bb[200010];\nint cnt[200010];\nint depth[200010];\nint gparent[20][200010];\n\nint lca(int x, int y){\n    int i;\n    \n    if(depth[x] > depth[y]) swap(x, y);\n    int diff = depth[y] - depth[x];\n    for(i=19;i>=0;i--) if((1<<i) <= diff){\n        diff -= (1<<i);\n        y = gparent[i][y];\n    }\n    \n    if(x == y) return x;\n    \n    for(i=19;i>=0;i--){\n        int x2 = gparent[i][x];\n        int y2 = gparent[i][y];\n        if(x2 != y2){\n            x = x2;\n            y = y2;\n        }\n    }\n    \n    return parent[x];\n}\n\nvector <int> get_path(int t, int s){\n    vector <int> ans;\n    int x = t;\n    ans.push_back(x);\n    while(1){\n        if(x == s) break;\n        x = parent[x];\n        ans.push_back(x);\n    }\n    return ans;\n}\n\nvector <int> merge(vector <int> &v1, vector <int> &v2){\n    vector <int> v;\n    int i;\n    REP(i,v1.size()) v.push_back(v1[i]);\n    REP(i,v2.size()) v.push_back(v2[i]);\n    return v;\n}\n\nvoid print(vector <int> v){\n    int i;\n    cout << v.size();\n    REP(i,v.size()) printf("" %d"", v[i]+1);\n    printf(""\\n"");\n}\n\nvoid construct(int s, int t){\n    int i;\n    int s1 = -1, t1 = -1, s2 = -1, t2 = -1;\n    \n//  cout << s << \' \' << t << endl;\n    \n    REP(i,M){\n        int ss = aa[i], tt = bb[i];\n        if(depth[ss] > depth[tt]) swap(ss, tt);\n        if(ss == s && tt == t) continue;\n        if(lca(s, ss) == ss && lca(t, tt) == t){\n            if(s1 == -1){\n                s1 = ss;\n                t1 = tt;\n            } else {\n                s2 = ss;\n                t2 = tt;\n                break;\n            }\n        }\n    }\n    \n    s = s1 + s2 - lca(s1, s2);\n    t = lca(t1, t2);\n    \n//  cout << s << \' \' << t << \' \' << s1 << \' \' << t1 << \' \' << s2 << \' \' << t2 << endl;\n    \n    vector <int> v1 = get_path(t, s);\n    vector <int> v2 = get_path(t1, t);\n    reverse(v2.begin(),v2.end());\n    vector <int> v3 = get_path(s, s1);\n    reverse(v3.begin(),v3.end());\n    vector <int> v4 = merge(v2, v3);\n    vector <int> v5 = get_path(t2, t);\n    reverse(v5.begin(),v5.end());\n    vector <int> v6 = get_path(s, s2);\n    reverse(v6.begin(),v6.end());\n    vector <int> v7 = merge(v5, v6);\n    \n    print(v1);\n    print(v4);\n    print(v7);\n}\n\nvoid dfs(int x, int d){\n    int i;\n    used[x] = true;\n    depth[x] = d;\n    REP(i,graph[x].size()){\n        int y = graph[x][i];\n        if(!used[y]){\n            dfs(y, d+1);\n            child[x].push_back(y);\n            parent[y] = x;\n        }\n    }\n}\n\nint dfs2(int x){\n    int i;\n    REP(i,child[x].size()) cnt[x] += dfs2(child[x][i]);\n    return cnt[x];\n}\n\nvoid check(int a, int b){\n    if(parent[a] == b || parent[b] == a) return;\n    if(depth[a] < depth[b]) swap(a, b);\n    cnt[a]++;\n    cnt[b]--;\n}\n\nint main(void){\n    int i,j;\n    \n    cin >> N >> M;\n    REP(i,M){\n        int a,b;\n        scanf(""%d%d"", &a, &b);\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        aa[i] = a; bb[i] = b;\n    }\n    \n    REP(i,N) parent[i] = -1;\n    REP(i,N) if(!used[i]) dfs(i, 0);\n    \n    REP(i,N) gparent[0][i] = parent[i];\n    for(i=1;i<20;i++) REP(j,N){\n        int tmp = gparent[i-1][j];\n        gparent[i][j] = ((tmp == -1) ? -1 : gparent[i-1][tmp]);\n    }\n    \n    REP(i,M) check(aa[i], bb[i]);\n    REP(i,N) if(parent[i] == -1) dfs2(i);\n    \n    int x = -1;\n    REP(i,N) if(cnt[i] >= 2) x = i;\n    if(x == -1){\n        cout << ""NO"" << endl;\n        return 0;\n    }\n    \n    cout << ""YES"" << endl;\n    construct(parent[x], x);\n    \n    return 0;\n}\n']",,,"['dfs and similar', 'graphs']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Cycling City.json,https://codeforces.com//blog/entry/16736,We have to find two vertices in an undirected graph such that there exist three vertex and edge independent paths between them This could easily be a flow problem if not for the large constraints First of all we can notice that all the paths between vertices should lie in the same biconnected component of the graph Indeed for every simple cycle all of its edges should lie in the same biconnected component and the three paths system is a union of cycles Thus we can find all the biconnected components of the graph and try to solve the problem for each of them independently The computing of biconnected components can be done in linear time a neat algorithm for doing this is described in the Wikipedia article by the link above Now we have a biconnected component and the same problem as before First of all find any cycle in this component with a simple DFS the only case of a biconnected component that does not contain a cycle is a single edge which is of no interest Suppose that no vertex of this cycle has an adjacent edge that doesn t lie in the cycle this means the cycle is not connected to anything else in the component so the component is this cycle itself in which case there is clearly no solution Otherwise find a vertex v with an adjacent edge e that doesn t lie in the cycle denote it c If we can find a path p starting with e that arrives at a cycle vertex u different from v then we can find three vertex distinct paths between v and u one path is p and two others are halves of the initial cycle To find p start a DFS from the edge e that halts when it arrives to vertex of c that is different from v and recovers all the paths What if we find that no appropriate path p exists Denote C the component traversed by the latter DFS The DFS did not find any path between vertices of C v and c v therefore every such path should pass through v That means that upon deletion of v the component C v becomes separated from all vertices of c v which contradicts with the assumption that the component was biconnected That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge Finally we obtain that the only case when the answer is non existent is when all the biconnected components are single edges or simple cycles that is the graph is a union of disconnected cactuses Otherwise a couple of DFS are sure to find three vertex disjoint paths This yields an O n m solution a few logarithmic factors for simplification here and there are also allowed 
https://codeforces.com//contest/229/problem/C,1892,C,229C,229,C. Triangles,Alice and Bob don t play games anymore Now they study properties of all sorts of graphs together Alice invented the following task she takes a complete undirected graph with vertices chooses some edges and keeps them Bob gets the remaining edges Alice and Bob are fond of triangles in graphs that is cycles of length 3 That s why they wonder what total number of triangles is there in the two graphs formed by Alice and Bob s edges correspondingly ,"['/*\n * c.cpp\n *\n *  Created on: 2012-10-1\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = 1000000 + 10;\nint cnt[MAX_N];\ntypedef long long int64;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\t--a, --b;\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tlong long tot = 1LL * n * (n - 1) * (n - 2) / 6;\n\tlong long bad = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tbad += 1LL * cnt[i] * (n - 1 - cnt[i]);\n\t}\n\tcout << tot - bad / 2 << endl;\n\treturn 0;\n}\n']",,,"['combinatorics', 'graphs', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Triangles.json,https://codeforces.com//blog/entry/5437,Let s call Alice s edges simply edges and Bob s edges the antiedges For each edge pair of the initial complete graph that pass through the same vertices assign a weight for each pair of edges the weight 2 for each pair of edge and antiedge 1 and for each pair of antiedges 2 Now calculate the sum of all the weights Observe that each Alice s or Bob s triangle adds exactly 6 to the sum and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex If the degree of the vertex is then we should add to the final sum Since each triangle adds 6 to the sum then the answer is equal to the sum divided by 6 The complexity of the solution is Sample solution http pastie org 4897512 archived copy 
https://codeforces.com//contest/1528/problem/B,994163,B,1528B,1528,B. Kavi on Pairing Duty,Kavi has 2n points lying on the OX axis i th of which is located at x i Kavi considers all ways to split these 2n points into n pairs Among those he is interested in pairings which are defined as follows Consider n segments with ends at the points in correspondent pairs The pairing is called good if for every 2 different segments A and B among those at least one of the following holds One of the segments A and B lies completely inside the other A and B have the same length Consider the following example A is a good pairing since the red segment lies completely inside the blue segment B is a good pairing since the red and the blue segment have the same length C is not a good pairing since none of the red or blue segments lies inside the other neither do they have the same size Kavi is interested in the number of good pairings so he wants you to find it for him As the result can be large find this number modulo 998244353 Two pairings are called different if some two points are in one pair in some pairing and in different pairs in another ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n;\n\tcin >> n;\n\tvector<num> dp(n+1, 0);\n\tdp[0] = 1;\n\tnum psum = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = i; j <= n; j += i){\n\t\t\tdp[j]++;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tdp[i] += psum;\n\t\tpsum += dp[i];\n\t}\n\tcout << dp[n] << \'\\n\';\n}\n']",,,"['combinatorics', 'dp', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Kavi on Pairing Duty.json,https://codeforces.com//blog/entry/91058,Let be the number of good pairings of points Clearly the answer is Lemma Denote as the point matched with the point Notice that each point belongs to a segment with length equal to s length Proof Assume some point is paired with a point since doesn t lie inside then their size must be the equal for the pairing to be good To compute consider the following cases Similar to lemma mentioned above it can be proved that each point is paired with the point the remaining unpaired points form a continuous subarray which lies inside each of the current pairs thus they can be paired in ways In this case due to the lemma mentioned above all the segments must have the same length thus their length must be a divisor of in this case they can be paired in ways where is the number of divisors of So Note that complexity 
https://codeforces.com//contest/1483/problem/F,931275,F,1483F,1483,F. Exam,This year a Chunin Selection Exam is held again in Konoha and taking part in it are n ninjas named s 1 s 2 s n All names are distinct One of the exam stages consists of fights between the participants This year the rules determining the ninjas for each fight are the following ninjas i and j fight against each other if the following conditions are held i neq j s j is a substring of s i there is no k except i and j that s j is a substring of s k and s k is a substring of s i A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end Your task is to find out how many fights are going to take place this year ,"['#include <bits/stdc++.h>\n\n/** Binary-indexed tree\n *\n *  A binary indexed tree with N nodes of type T provides the\n *  following two functions for 0 <= i <= N:\n *\n *      prefix(int i) -> prefix_iterator<T>\n *      suffix(int i) -> suffix_iterator<T>\n *\n *  such that size(suffix(i) intersect prefix(j)) = (1 if i < j else 0).\n *  Furthermore, the resulting lists always have size at most log_2(N).\n *\n *  This can be used to implement either point-update/(prefix|suffix)-query or\n *  (prefix|suffix)-update/point-query over a virtual array of size N of a\n *  commutative monoid. This can be generalized to implement\n *  point-update/range-query or range-update/point-query over a virtual array\n *  of size N of a commutative group.\n *\n *  With 0-indexed data, prefixes are more natural:\n *   * For range update/query, use for_prefix for the ranges and for_suffix for the points.\n *   * For prefix update/query, no change.\n *   * For suffix update/query, use for_prefix(point + 1); 1-index the data.\n */\ntemplate <typename T> class binary_indexed_tree {\nprivate:\n\tstd::vector<T> dat;\npublic:\n\tbinary_indexed_tree() {}\n\texplicit binary_indexed_tree(size_t N) : dat(N) {}\n\tbinary_indexed_tree(size_t N, const T& t) : dat(N, t) {}\n\n\tsize_t size() const { return dat.size(); }\n\tconst std::vector<T>& data() const { return dat; }\n\tstd::vector<T>& data() { return dat; }\n\nprivate:\n\ttemplate <typename I, typename S = I> struct iterator_range {\n\tprivate:\n\t\tI begin_;\n\t\tS end_;\n\tpublic:\n\t\titerator_range() : begin_(), end_() {}\n\t\titerator_range(const I& begin__, const S& end__) : begin_(begin__), end_(end__) {}\n\t\titerator_range(I&& begin__, S&& end__) : begin_(begin__), end_(end__) {}\n\t\tI begin() const { return begin_; }\n\t\tS end() const { return end_; }\n\t};\n\npublic:\n\tclass const_suffix_iterator {\n\tprivate:\n\t\tconst T* dat;\n\t\tint a;\n\t\tconst_suffix_iterator(const T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const const_suffix_iterator& i, const const_suffix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a < j.a;\n\t\t}\n\t\tconst_suffix_iterator& operator ++ () {\n\t\t\ta |= a+1;\n\t\t\treturn *this;\n\t\t}\n\t\tconst T& operator * () const {\n\t\t\treturn dat[a];\n\t\t}\n\t};\n\tusing const_suffix_range = iterator_range<const_suffix_iterator>;\n\tconst_suffix_range suffix(int a) const {\n\t\tassert(0 <= a && a <= int(dat.size()));\n\t\treturn const_suffix_range{const_suffix_iterator{dat.data(), a}, const_suffix_iterator{nullptr, int(dat.size())}};\n\t}\n\n\tclass suffix_iterator {\n\tprivate:\n\t\tT* dat;\n\t\tint a;\n\t\tsuffix_iterator(T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const suffix_iterator& i, const suffix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a < j.a;\n\t\t}\n\t\tsuffix_iterator& operator ++ () {\n\t\t\ta |= a+1;\n\t\t\treturn *this;\n\t\t}\n\t\tT& operator * () const {\n\t\t\treturn dat[a];\n\t\t}\n\t};\n\tusing suffix_range = iterator_range<suffix_iterator>;\n\tsuffix_range suffix(int a) {\n\t\tassert(0 <= a && a <= int(dat.size()));\n\t\treturn suffix_range{suffix_iterator{dat.data(), a}, suffix_iterator{nullptr, int(dat.size())}};\n\t}\n\n\tclass const_prefix_iterator {\n\tprivate:\n\t\tconst T* dat;\n\t\tint a;\n\t\tconst_prefix_iterator(const T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const const_prefix_iterator& i, const const_prefix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a > 0;\n\t\t}\n\t\tconst_prefix_iterator& operator ++ () {\n\t\t\ta &= a-1;\n\t\t\treturn *this;\n\t\t}\n\t\tconst T& operator * () const {\n\t\t\treturn dat[a-1];\n\t\t}\n\t};\n\tusing const_prefix_range = iterator_range<const_prefix_iterator>;\n\tconst_prefix_range prefix(int a) const {\n\t\treturn const_prefix_range{const_prefix_iterator{dat.data(), a}, const_prefix_iterator{nullptr, 0}};\n\t}\n\n\tclass prefix_iterator {\n\tprivate:\n\t\tT* dat;\n\t\tint a;\n\t\tprefix_iterator(T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const prefix_iterator& i, const prefix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a > 0;\n\t\t}\n\t\tprefix_iterator& operator ++ () {\n\t\t\ta &= a-1;\n\t\t\treturn *this;\n\t\t}\n\t\tT& operator * () const {\n\t\t\treturn dat[a-1];\n\t\t}\n\t};\n\tusing prefix_range = iterator_range<prefix_iterator>;\n\tprefix_range prefix(int a) {\n\t\treturn prefix_range{prefix_iterator{dat.data(), a}, prefix_iterator{nullptr, 0}};\n\t}\n};\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N;\n\tvector<string> W(N);\n\tint totL = 0;\n\tfor (auto& w : W) {\n\t\tcin >> w;\n\t\ttotL += int(w.size());\n\t}\n\n\tvector<array<int, 26>> ch; ch.reserve(totL+1);\n\tvector<int> is_end; is_end.reserve(totL+1);\n\tch.emplace_back(); ch.back().fill(0); is_end.push_back(-1);\n\tfor (int i = 0; i < N; i++) {\n\t\tint cur = 0;\n\t\tfor (char c : W[i]) {\n\t\t\tif (!ch[cur][c-\'a\']) {\n\t\t\t\tch[cur][c-\'a\'] = int(ch.size());\n\t\t\t\tch.emplace_back(); ch.back().fill(0); is_end.push_back(-1);\n\t\t\t}\n\t\t\tcur = ch[cur][c-\'a\'];\n\t\t}\n\t\tis_end[cur] = i;\n\t}\n\n\tint V = int(ch.size());\n\tvector<int> fail(V);\n\tfail[0] = -1;\n\tvector<int> fail_end(V);\n\n\tvector<int> fail_par(N);\n\tvector<vector<int>> fail_ch(N+1);\n\n\tvector<int> q; q.reserve(V);\n\tq.push_back(0);\n\tfor (int z = 0; z < V; z++) {\n\t\tassert(z < int(q.size()));\n\t\tint cur = q[z];\n\t\tfor (int c = 0; c < 26; c++) {\n\t\t\tint fail_val = cur == 0 ? 0 : ch[fail[cur]][c];\n\t\t\tif (ch[cur][c]) {\n\t\t\t\tfail[ch[cur][c]] = fail_val;\n\t\t\t\tq.push_back(ch[cur][c]);\n\t\t\t} else {\n\t\t\t\tch[cur][c] = fail_val;\n\t\t\t}\n\t\t}\n\n\t\tif (is_end[cur] != -1) {\n\t\t\tfail_end[cur] = is_end[cur];\n\n\t\t\tint p = fail_end[fail[cur]];\n\t\t\tfail_par[is_end[cur]] = p;\n\t\t\tfail_ch[p].push_back(is_end[cur]);\n\t\t\t//cerr << ""parent of "" << is_end[cur] << "" "" << W[is_end[cur]] << "" is "" << p << \'\\n\';\n\t\t} else if (cur == 0) {\n\t\t\tfail_end[cur] = N;\n\t\t} else {\n\t\t\tfail_end[cur] = fail_end[fail[cur]];\n\t\t}\n\t}\n\n\tvector<array<int, 2>> bounds(N+1);\n\t{\n\t\tint cur_idx = 0;\n\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\tbounds[cur][0] = cur_idx;\n\t\t\tcur_idx++;\n\t\t\tfor (int nxt : fail_ch[cur]) {\n\t\t\t\tself(nxt);\n\t\t\t}\n\t\t\tbounds[cur][1] = cur_idx;\n\t\t})(N);\n\t}\n\n\tbinary_indexed_tree<int> bit(N+1);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < N; i++) {\n\t\t//cerr << ""running word "" << i << \' \' << W[i] << \'\\n\';\n\n\t\tint L = int(W[i].size());\n\t\tvector<int> states(L+1);\n\t\tstates[0] = 0;\n\t\tfor (int z = 0; z < L; z++) {\n\t\t\tstates[z+1] = ch[states[z]][W[i][z]-\'a\'];\n\t\t}\n\t\tvector<int> bads; bads.reserve(L);\n\t\tvector<int> cnds; cnds.reserve(L);\n\t\tint best_start = L;\n\t\tfor (int z = L; z >= 0; z--) {\n\t\t\tint m = fail_end[states[z]];\n\t\t\tif (z == L) {\n\t\t\t\tassert(m == i);\n\t\t\t\tm = fail_par[m];\n\t\t\t}\n\t\t\tif (m == N) continue;\n\t\t\tint start = z - int(W[m].size());\n\t\t\tif (start < best_start) {\n\t\t\t\tbest_start = start;\n\t\t\t\tcnds.push_back(m);\n\t\t\t\tm = fail_par[m];\n\t\t\t}\n\t\t\tif (m == N) continue;\n\t\t\tbads.push_back(m);\n\t\t}\n\n\t\t//for (int v : bads) { cerr << ""bad "" << v << \' \' << W[v] << \'\\n\'; }\n\t\t//for (int v : cnds) { cerr << ""cnd "" << v << \' \' << W[v] << \'\\n\'; }\n\n\t\tfor (int v : bads) {\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a++;\n\t\t}\n\t\tfor (int v : cnds) {\n\t\t\tint cnt = 0;\n\t\t\tfor (auto a : bit.prefix(bounds[v][0])) cnt -= a;\n\t\t\tfor (auto a : bit.prefix(bounds[v][1])) cnt += a;\n\t\t\tif (!cnt) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a++;\n\t\t}\n\n\t\tfor (int v : bads) {\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a--;\n\t\t}\n\t\tfor (int v : cnds) {\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a--;\n\t\t}\n\t}\n\n\tcout << ans << \'\\n\';\n\n\treturn 0;\n}\n']",,,"['data structures', 'dfs and similar', 'dsu', 'string suffix structures', 'trees']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Exam.json,https://codeforces.com//blog/entry/88963,Fix a particular string s and find all edges outgoing from it For each position i of the string let s find the value of lefti being the starting position of the longest substring which ends at the position i and is one of the strings sj It s easy to see that such strings are the only ones where the outgoing edges from s can lead to What remains is to find out which of them need to be excluded A string needs to be excluded if there is an occurrence of it into s which is entirely covered by an occurrence of another substring So let indi min leftj j i Then the strings to be excluded are precisely the strings among sj s which are suffixes of the substring indi i for some i This can be found via the Aho Corasick structure Since its suffix links represent a tree one can find the vertices corresponding to the substrings indi i and mark the way to the root in the suffix links tree After this one can just check if the vertices of lefti i are marked To mark paths efficiently one can use segment trees or std set The overall complexity is O nlogn 
https://codeforces.com//contest/1659/problem/C,1371413,C,1659C,1659,C. Line Empire,Consider a number axis The capital of your empire is initially at 0 There are n unconquered kingdoms at positions 0 x 1 x 2 ldots x n You want to conquer all other kingdoms There are two actions available to you You can change the location of your capital let its current position be c 1 to any other kingdom let its position be c 2 at a cost of a cdot c 1 c 2 From the current capital let its current position be c 1 you can conquer an unconquered kingdom let its position be c 2 at a cost of b cdot c 1 c 2 You conquer a kingdom if there is an unconquered kingdom between the target and your capital Note that you place the capital at a point without a kingdom In other words at any point your capital can only be at 0 or one of x 1 x 2 ldots x n Also note that conquering a kingdom does not change the position of your capital Find the minimum total cost to conquer all kingdoms Your capital can be anywhere at the end ,"['#include<iostream>\nusing namespace std;\nint a[200010];\nlong long sum[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t\tsum[i]=sum[i-1]+a[i];\n\t\t}\n\t\tlong long ans=1e18,s=0;\n\t\tfor(int i=0; i<=n; i++) {\n\t\t\tif(i) {\n\t\t\t\ts+=a[i]-a[i-1];\n\t\t\t}\n\t\t\tans=min(ans,(long long)x*a[i]+y*(sum[n]-sum[i]-(long long)a[i]*(n-i)+s));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n']",,,"['binary search', 'brute force', 'dp', 'greedy', 'implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Line Empire.json,https://codeforces.com//blog/entry/100938,Clearly we should always move from left to right Also assume for simplicity Let us analyze what our cost would look like It will be composed of a part due to moving capitals and a part due to conquering kingdoms If we shift our capital from to the cost is If we conquer kingdoms from with capital the cost is which can be written as where Now notice that and are linear Also if we isolate the parts involving the sum will be like This means we can simply write the final sum of this part as where is the final position of the capital We can say the same thing about except that the final kingdom conquered is always So the final sum of this part is always so they weren t written explicitly Our final cost then looks like where is composed of terms like If we want to minimise we want to maximise That is achieved if we always increase Then we can write We cannot increase beyond since that is the final position of our capital Hence our final answer is given by Time complexity 
https://codeforces.com//contest/1538/problem/A,1011921,A,1538A,1538,A. Stone Game,Polycarp is playing a new computer game This game has n stones in a row The stone on the position i has integer power a i Each turn Polycarp can destroy either stone on the first position or stone on the last position in other words either the leftmost or the rightmost stone When Polycarp destroys the stone it does not exist any more Now Polycarp wants two achievements He gets them if he destroys the stone with the power and the stone with the power Help Polycarp find out what is the minimum number of moves he should make in order to achieve his goal For example if n 5 and a 1 5 4 3 2 then Polycarp could make the following moves Destroy the leftmost stone After this move a 5 4 3 2 Destroy the rightmost stone After this move a 5 4 3 Destroy the leftmost stone After this move a 4 3 Polycarp destroyed the stones with the greatest and least power so he can end the game Please note that in the example above you can complete the game in two steps For example Destroy the leftmost stone After this move a 5 4 3 2 Destroy the leftmost stone After this move a 4 3 2 Polycarp destroyed the stones with the greatest and least power so he can end the game ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nint n,m,i,j,k,t,t1,u,v,a,b;\nint pos[100001];\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n;\n        for (i=1;i<=n;i++)\n        {\n            cin>>u;\n            pos[u]=i;\n        }\n        cout<<min(n-(abs(pos[n]-pos[1])-1),min(max(pos[1],pos[n]),n-min(pos[1],pos[n])+1))<<endl;\n    }\n}\n']",,,"['brute force', 'dp', 'greedy']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Stone Game.json,https://codeforces.com//blog/entry/91637,If we want to destroy the largest and smallest stone then there are only four options Destroy the stones on the left until we destroy the smallest stone Then destroy the stones on the right until we destroy the largest stone Destroy the stones on the right until we destroy the smallest stone Then destroy the stones on the left until we destroy the largest stone Destroy the stones on the left until we destroy both stones Destroy the stones on the right until we destroy both stones You need to check all four options and choose the minimum answer 
https://codeforces.com//contest/329/problem/B,3355,B,329B,329,B. Biridian Forest,You re a mikemon breeder currently in the middle of your journey to become a mikemon master Your current obstacle is go through the infamous Biridian Forest The Biridian Forest is a two dimensional grid consisting of rows and columns Each cell in Biridian Forest may contain a tree or may be vacant A vacant cell may be occupied by zero or more mikemon breeders there may also be breeders other than you in the forest Mikemon breeders including you cannot enter cells with trees One of the cells is designated as the exit cell The initial grid including your initial position the exit cell and the initial positions of all other breeders will be given to you Here s an example of such grid from the first example Breeders including you may move in the forest In a single move breeders may perform one of the following actions Do nothing Move from the current cell to one of the four adjacent cells two cells are adjacent if they share a side Note that breeders cannot enter cells with trees If you are located on the exit cell you may leave the forest Only you can perform this move all other mikemon breeders will never leave the forest by using this type of movement After each time you make a single move each of the other breeders simultaneously make a single move the choice of which move to make may be different for each of the breeders If you and mikemon breeders are located on the same cell exactly mikemon battles will ensue that time since you will be battling each of those breeders once After the battle all of those breeders will leave the forest to heal their respective mikemons Note that the moment you leave the forest no more mikemon battles can ensue even if another mikemon breeder move to the exit cell immediately after that Also note that a battle only happens between you and another breeders there will be no battle between two other breeders there may be multiple breeders coexisting in a single cell You would like to leave the forest In order to do so you have to make a sequence of moves ending with a move of the final type Before you make any move however you post this sequence on your personal virtual idol Blog Then you will follow this sequence of moves faithfully Because you post the sequence in your Blog the other breeders will all know your exact sequence of moves even before you make your first move All of them will move in such way that will guarantee a mikemon battle with you if possible The breeders that couldn t battle you will do nothing Print the minimum number of mikemon battles that you must participate in assuming that you pick the sequence of moves that minimize this number Note that you are not required to minimize the number of moves you make ,"['/*\nID: espr1t\nTASK: \nKEYWORDS: \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cctype>\n\nusing namespace std;\nFILE *in; FILE *out;\n\nconst int MAX = 1024;\nconst int INF = 1000000001;\n\nint n, m;\nchar a[MAX][MAX];\nint dist[MAX][MAX];\nint dir[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\n\nvoid bfs(int row, int col) {\n    memset(dist, 63, sizeof(dist));\n    queue < pair <int, int> > q;\n    q.push(make_pair(row, col));\n    dist[row][col] = 0;\n    while (!q.empty()) {\n        row = q.front().first;\n        col = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dir[i][0]; if (nrow < 0 || nrow >= n) continue;\n            int ncol = col + dir[i][1]; if (ncol < 0 || ncol >= m) continue;\n            if (a[nrow][ncol] == \'T\')\n                continue;\n            if (dist[row][col] + 1 < dist[nrow][ncol]) {\n                dist[nrow][ncol] = dist[row][col] + 1;\n                q.push(make_pair(nrow, ncol));\n            }\n        }\n    }\n}\n\n\nint main(void) {\n\tin = stdin; out = stdout;\n//\tin = fopen(""B.in"", ""rt""); out = fopen(""B.out"", ""wt"");\n\t\n\tfscanf(in, ""%d %d"", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t    fscanf(in, ""%s"", a[i]);\n\t\n\tint srow = -1, scol = -1;\n\tfor (int i = 0; i < n; i++) {\n\t    for (int c = 0; c < m; c++) {\n\t        if (a[i][c] == \'E\') {\n\t            srow = i;\n\t            scol = c;\n\t            a[i][c] = \'0\';\n\t            break;\n\t        }\n\t    }\n\t    if (srow != -1 || scol != -1)\n\t        break;\n\t}\n\tbfs(srow, scol);\n\t\n\tint len = INF;\n\tfor (int i = 0; i < n; i++)\n\t    for (int c = 0; c < m; c++)\n\t        if (a[i][c] == \'S\') len = dist[i][c], a[i][c] = \'0\';\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t    for (int c = 0; c < m; c++) {\n\t        if (isdigit(a[i][c]) && dist[i][c] <= len)\n\t            ans += a[i][c] - \'0\';\n\t    }\n\t}\n\tfprintf(out, ""%d\\n"", ans);\n\treturn 0;\n}\n']",,,"['dfs and similar', 'shortest paths']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Biridian Forest.json,https://codeforces.com//blog/entry/8417,The only non ad hoc problem in the round sort of Despite the very long problem statement the solution is really simple Thoughts I tried to make this clearer by separating the paragraphs by topic Did it work well Btw mikemon is pronounced mi ke mon not mike mon similar to how Pokemon is pronounced po ke mon not poke mon 
https://codeforces.com//contest/2013/problem/E,2890590,E,2013E,2013,E. Prefix GCD,Since Mansur is tired of making legends there will be no legends for this task You are given an array of positive integer numbers a 1 a 2 ldots a n The elements of the array can be rearranged in any order You need to find the smallest possible value of the expression gcd a 1 gcd a 1 a 2 ldots gcd a 1 a 2 ldots a n where gcd a 1 a 2 ldots a n denotes the greatest common divisor GCD of a 1 a 2 ldots a n ,"['#include <bits/stdc++.h>using namespace std;\xa0typedef long long ll;using vi = vector<int>;using vvi = vector<vector<int>>;using vll = vector<ll>;using vvll = vector<vector<ll>>;\xa0#define all(x) x.begin(), x.end()#define ckmin(a,b) a = min(a,b)#define ckmax(a,b) a = max(a,b)\xa0void solve() {    int N;    cin >> N;    vll A(N);    for (int i=0;i<N;i++) cin >> A[i];\xa0    ll g = A[0];    for (int i=1;i<N;i++) g = gcd(g, A[i]);\xa0    for (int i=0;i<N;i++) A[i] /= g;    sort(all(A));\xa0    ll ans = A[0];    vi used(N, 0);    used[0] = 1;    ll cur = A[0];    ll left = N-1;    while (cur > 1) {        int bestind = -1;        ll bestval = cur;        for (int i=0;i<N;i++) {            if (used[i]) continue;            if (gcd(cur, A[i]) < bestval) {                bestval = gcd(cur, A[i]);                bestind = i;            }        }\xa0        ans += bestval;        cur = bestval;        used[bestind] = 1;        left--;    }    ans += left;    ans *= g;    cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(NULL);\xa0    int T;    cin >> T;    for (int t=0;t<T;t++) solve();\xa0    return 0;}']",,,"['brute force', 'dp', 'greedy', 'math', 'number theory']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Prefix GCD.json,https://codeforces.com/blog/entry/134170,Let be the greatest common divisor of the array We will divide each element by and at the end simply multiply the result by Now consider the following greedy algorithm We will start with an initially empty array and add to the end of array the element that minimizes the GCD with the already existing array It can be observed that the will reach 1 in at most 10 iterations After that the remaining elements can be added in any order ProofLet be the minimum possible GCD for the current prefix of array and let be the optimal answer such that In this case we can first place and then write the sequence in the same order The answer will not worsen since Total time complexty 
https://codeforces.com//contest/552/problem/D,29864,D,552D,552,D. Vanya and Triangles,Vanya got bored and he painted distinct points on the plane After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points He asks you to count the number of the formed triangles with the area ,"['#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nll N, A, T;\npair<ll, ll> pts[2048];\n\nll gcd(ll a, ll b){\n    if(!b) return a;\n    return gcd(b, a%b);\n}\n\nint main(){\n    setup();\n    cin >> N;\n    for(int i=0; i<N; i++)\n        cin >> pts[i].first >> pts[i].second;\n\n    for(int c=0; c<N; c++){\n        vector<pair<ll, ll> > off;\n        for(int i=0; i<N; i++){\n            if(i==c) continue;\n            pair<ll, ll> val = {pts[i].first - pts[c].first,\n                                  pts[i].second - pts[c].second};\n            ll g = gcd(abs(val.first), abs(val.second));\n            val.first /= g;\n            val.second /= g;\n            off.push_back(val);\n        }\n\n        sort(off.begin(), off.end());\n\n        for(int i=0; i<off.size(); ){\n            int j = i+1;\n            while(j<off.size() && off[j] == off[i]) j++;\n            T += (j-i) * (j-i-1) / 2;\n            i = j;\n        }\n    }\n\n    A = N * (N - 1) * (N - 2) / 6;\n    A -= T/2;\n    cout << A << endl;\n}\n']",,,"['brute force', 'combinatorics', 'data structures', 'geometry', 'math', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Vanya and Triangles.json,https://codeforces.com//blog/entry/18696,We can look through all pair of points draw line through each pair and write that this line includes these 2 points We can do it with map If some line includes points then in fact we counted that it has points because we included each point 2 x 1 times in this line We can create an array and add to him values so we can define how many points is on the line Then we can iterate through all lanes and for each line with points we will loose possible triangles from all possible triangles Decide that at first So for every line that includes points we will substract from Time complexity C 11 code Wild Hamster Java code Wild Hamster Java code Zlobober UPD I am sorry that O n3 6 solutions passed my solution with O n3 6 didn t pass before the contest so I decided that TL 4 sec is good it was for Java TL 
https://codeforces.com//contest/1498/problem/D,939725,D,1498D,1498,D. Bananas in a Microwave,You have a malfunctioning microwave in which you want to put some bananas You have n time steps before the microwave stops working completely At each time step it displays a new operation Let k be the number of bananas in the microwave currently Initially k 0 In the i th operation you are given three parameters t i x i y i in the input Based on the value of t i you must do one of the following t i 1 x i y i pick an a i such that 0 le a i le y i and perform the following update a i times k lceil k x i rceil t i 2 x i y i pick an a i such that 0 le a i le y i and perform the following update a i times k lceil k cdot x i rceil Note that See input format for more details Also lceil x rceil is the smallest integer ge x At the i th time step you must apply the i th operation exactly once For each j such that 1 le j le m output the earliest time step at which you can create j bananas If you cannot create j bananas output 1 ,"['#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=1e9+7;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],b[1000002],c[1000002],ans[100002];\nlong double d[1000002];\nsigned main(){\n\tn=read(),m=read();\n\tfor(re int i=1;i<=n;++i)a[i]=read(),b[i]=read(),c[i]=read();\n\tmemset(ans,-1,sizeof(ans));ans[0]=0;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]==1){\n\t\t\tb[i]=(b[i]+99999)/100000;\n\t}\n\t\tfor(re int j=m;~j;--j)\n\t\t\tif(ans[j]>-1){\n\t\t\t\tif(j==0&&a[i]==2)continue;\n\t\t\t\tre int x=j;\n\t\t\t\tre int num=0;\n\t\t\t\twhile(1){\n\t\t\t\t\t++num;\n\t\t\t\t\tif(num>c[i])break;\n\t\t\t\t\tif(a[i]==1)x=x+b[i];\n\t\t\t\t\telse x=(x*b[i]+99999)/100000;\n\t\t\t\t\tre int tmp=x;x=tmp;\n\t\t\t\t\tif(tmp>m)break;\n\t\t\t\t\tif(ans[tmp]>-1)break;\n\t\t\t\t\tans[tmp]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t}\n\tfor(re int i=1;i<=m;++i)printf(""%lld "",ans[i]);\n}\n']",,,"['dfs and similar', 'dp', 'graphs', 'implementation']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Bananas in a Microwave.json,https://codeforces.com//blog/entry/89137,We have a brute force O N M2 solution At every timestep t for each banana bi that has already been reached previously apply this timestep s operation yt times on bi For all the yt bananas reachable from bi update their minimum reachability time if they hadn t been reached previously Why is this correct Simply because we are simulating each possible step of the algorithm exactly as it is described Therefore we cannot get an answer that s better or worse than that of the optimal solution 
https://codeforces.com//contest/1328/problem/A,573967,A,1328A,1328,A. Divisibility Problem,You are given two positive integers a and b In one move you can increase a by 1 replace a with a 1 Your task is to find the minimum number of moves you need to do in order to make a divisible by b It is possible that you have to make 0 moves as a is already divisible by b You have to answer t independent test cases ,"[""// clang-format off\n// powered by c++11\n// by Isaunoya\n#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i=(x);i<=(y);++i)\n#define Rep(i,x,y) for(register int i=(x);i>=(y);--i)\nusing namespace std;using db=double;using ll=long long;\nusing uint=unsigned int;using ull=unsigned long long;\nusing pii=pair<int,int>;\n#define Tp template\n#define fir first\n#define sec second\nTp<class T>void cmax(T&x,const T&y){if(x<y)x=y;}Tp<class T>void cmin(T&x,const T&y){if(x>y)x=y;}\n#define all(v) v.begin(),v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\nTp<class T>void sort(vector<T>&v){sort(all(v));}Tp<class T>void reverse(vector<T>&v){reverse(all(v));}\nTp<class T>void unique(vector<T>&v){sort(all(v)),v.erase(unique(all(v)),v.end());}inline void reverse(string&s){reverse(s.begin(),s.end());}\nconst int SZ=1<<23|233;\nstruct FILEIN{char qwq[SZ],*S=qwq,*T=qwq,ch;\n#ifdef __WIN64\n#define GETC getchar\n#else\ninline char GETC(){return(S==T)&&(T=(S=qwq)+fread(qwq,1,SZ,stdin),S==T)?EOF:*S++;}\n#endif\ninline FILEIN&operator>>(char&c){while(isspace(c=GETC()));return*this;}inline FILEIN&operator>>(string&s){s.clear();while(isspace(ch=GETC()));if(!~ch)return*this;s=ch;while(!isspace(ch=GETC())&&~ch)s+=ch;return*this;}\ninline FILEIN&operator>>(char*str){char*cur=str;while(*cur)*cur++=0;cur=str;while(isspace(ch=GETC()));if(!~ch)return*this;*cur=ch;while(!isspace(ch=GETC())&&~ch)*++cur=ch;*++cur=0;return*this;}\nTp<class T>inline void read(T&x){bool f=0;while((ch=GETC())<48&&~ch)f^=(ch==45);x=~ch?(ch^48):0;while((ch=GETC())>47)x=x*10+(ch^48);x=f?-x:x;}\ninline FILEIN&operator>>(int&x){return read(x),*this;}inline FILEIN&operator>>(ll&x){return read(x),*this;}inline FILEIN&operator>>(uint&x){return read(x),*this;}inline FILEIN&operator>>(ull&x){return read(x),*this;}\ninline FILEIN&operator>>(double&x){read(x);bool f=x<0;x=f?-x:x;if(ch^'.')return*this;double d=0.1;while((ch=GETC())>47)x+=d*(ch^48),d*=.1;return x=f?-x:x,*this;}\n}in;\nstruct FILEOUT{const static int LIMIT=1<<22;char quq[SZ],ST[233];int sz,O,pw[233];\nFILEOUT(){set(7);rep(i,pw[0]=1,9)pw[i]=pw[i-1]*10;}~FILEOUT(){flush();}\ninline void flush(){fwrite(quq,1,O,stdout),fflush(stdout),O=0;}\ninline FILEOUT&operator<<(char c){return quq[O++]=c,*this;}inline FILEOUT&operator<<(string str){if(O>LIMIT)flush();for(char c:str)quq[O++]=c;return*this;}\ninline FILEOUT&operator<<(char*str){if(O>LIMIT)flush();char*cur=str;while(*cur)quq[O++]=(*cur++);return*this;}\nTp<class T>void write(T x){if(O>LIMIT)flush();if(x<0){quq[O++]=45;x=-x;}do{ST[++sz]=x%10^48;x/=10;}while(x);while(sz)quq[O++]=ST[sz--];}\ninline FILEOUT&operator<<(int x){return write(x),*this;}inline FILEOUT&operator<<(ll x){return write(x),*this;}inline FILEOUT&operator<<(uint x){return write(x),*this;}inline FILEOUT&operator<<(ull x){return write(x),*this;}\nint len,lft,rig;void set(int l){len=l;}inline FILEOUT&operator<<(double x){bool f=x<0;x=f?-x:x,lft=x,rig=1.*(x-lft)*pw[len];return write(f?-lft:lft),quq[O++]='.',write(rig),*this;}\n}out;\n#define int long long\nstruct Math{\nvector<int>fac,inv;int mod;\nvoid set(int n,int Mod){fac.resize(n+1),inv.resize(n+1),mod=Mod;rep(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;inv[n]=qpow(fac[n],mod-2);Rep(i,n-1,0)inv[i]=inv[i+1]*(i+1)%mod;}\nint qpow(int x,int y){int ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}int C(int n,int m){if(n<0||m<0||n<m)return 0;return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint gcd(int x,int y){return!y?x:gcd(y,x%y);}int lcm(int x,int y){return x*y/gcd(x,y);}\n}math;\n// clang-format on\nsigned main(){\n\t//code begin.\n\tint _;\n\tin >> _;\n\twhile(_ --) {\n\t\tint a, b;\n\t\tin >> a >> b;\n\t\tint sum = ((a - 1) / b + 1) * b;\n\t\tout << (sum - a) << '\\n';\n\t}\n\treturn 0;\n\t//code end.\n}\n""]",,,['math'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Divisibility Problem.json,https://codeforces.com//blog/entry/75246,If is divisible by just print Otherwise we need exactly moves to make zero remainder of modulo is modulo operation 
https://codeforces.com//contest/1469/problem/B,847527,B,1469B,1469,B. Red and Blue,Monocarp had a sequence a consisting of n m integers a 1 a 2 dots a n m He painted the elements into two colors red and blue n elements were painted red all other m elements were painted blue After painting the elements he has written two sequences r 1 r 2 dots r n and b 1 b 2 dots b m The sequence r consisted of all red elements of a similarly the sequence b consisted of all blue elements of a Unfortunately the original sequence was lost and Monocarp only has the sequences r and b He wants to restore the original sequence In case there are multiple ways to restore it he wants to choose a way to restore that maximizes the value of f a max 0 a 1 a 1 a 2 a 1 a 2 a 3 dots a 1 a 2 a 3 dots a n m Help Monocarp to calculate the maximum possible value of f a ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        int mx0 = 0, mx1 = 0, s = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            std::cin >> x;\n            s += x;\n            mx0 = std::max(mx0, s);\n        }\n        s = 0;\n        int m;\n        std::cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int x;\n            std::cin >> x;\n            s += x;\n            mx1 = std::max(mx1, s);\n        }\n        std::cout << mx0 + mx1 << ""\\n"";\n    }\n    return 0;\n}']",,,"['dp', 'greedy']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Red and Blue.json,https://codeforces.com//blog/entry/86082,Denote as the sum of first elements of and as the sum of first elements of These values can be calculated in with prefix sums The first solution is to use dynamic programming Let be the maximum value of if we placed the first elements of and the first elements of Transitions can be performed in we either place an element from then we go to and update it with or place an element from then we go to and update it with The answer is stored in and this solution works in The second solution observe that the sum of several first elements of is the sum of several first elements of and several first elements of So each prefix sum of and the answer itself is not greater than It s easy to show how to obtain exactly this answer let be the value of such that is maximized and be the value of such that is maximized Let s place the first elements of then the first elements of so the current sum is exactly and place all of the remaining elements in any possible order So the answer is This solution works in 
https://codeforces.com//contest/1996/problem/A,2778588,A,1996A,1996,A. Legs,It s another beautiful day on Farmer John s farm After Farmer John arrived at his farm he counted n legs It is known only chickens and cows live on the farm and a chicken has 2 legs while a cow has 4 What is the minimum number of animals Farmer John can have on his farm assuming he counted the legs of all animals ,"['/**   - dwuy -\xa0\u3000\u3000\u3000\u3000\u3000 ／＞\u3000   フ\u3000\u3000\u3000\u3000\u3000 | \u3000_\u3000 _|\u3000 \u3000\u3000\u3000 ／`ミ _x ノ\u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\u3000\u3000\u3000 /\u3000  ヽ\u3000\u3000 ?\u3000／￣|\u3000\u3000 |\u3000|\u3000|\u3000| (￣ヽ＿_ヽ_)_)\u3000＼二つ\xa0**/#include <bits/stdc++.h>\xa0#define fastIO ios_base::sync_with_stdio(false); cin.tie(NULL)#define file(a) freopen(a"".inp"",""r"",stdin); freopen(a"".out"", ""w"",stdout)#define fi first#define se second#define endl ""\\n""#define len(s) (int)((s).size())#define MASK(k)(1LL<<(k))#define TASK ""test""#define int long long\xa0using namespace std;\xa0typedef tuple<int, int, int> tpiii;typedef pair<double, double> pdd;typedef pair<int, int> pii;typedef long long ll;\xa0const long long OO = 1e18;const int MOD = 1e9 + 7;const int INF = 1e9;const int MX = 300005;\xa0int n, m, k, q;string s, t;int a[MX];int b[MX];\xa0void solve(){    cin >> n;    int ans = 1e18;    for(int i=0; i<=n; i++){        int tmp = n - 2*i;        if(tmp%4 == 0) ans = min(ans, tmp/4 + i);    }    cout << ans << endl;}\xa0int32_t main(){    fastIO;    //file(TASK);\xa0    int q;    cin >> q;    while(q--){        solve();    }\xa0    return 0;}\xa0\xa0\xa0\xa0']",,,"['binary search', 'math', 'ternary search']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Legs.json,https://codeforces.com//blog/entry/131528,If n is a multiple of 4 then you can have n4 cows Otherwise you must have at least one chicken so you can have n 24 cows and 1 chicken 
https://codeforces.com//contest/1174/problem/E,353394,E,1174E,1174,E. Ehab and the Expected GCD Problem,Let s define a function f p on a permutation p as follows Let g i be the greatest common divisor GCD of elements p 1 p 2 p i in other words it is the GCD of the prefix of length i Then f p is the number of elements among g 1 g 2 g n Let f max n be the maximum value of f p among all permutations p of integers 1 2 n Given an integers n count the number of permutations p of integers 1 2 n such that f p is equal to f max n Since the answer may be large print the remainder of its division by 1000 000 007 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 5;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nint add(int a, int b)\n{\n\ta += b;\n\treturn a >= mod ? a - mod : a;\n}\nint sub(int a, int b)\n{\n\ta -= b;\n\treturn a < 0 ? a + mod : a;\n}\nint mul(int a, int b) { return (ll)a * b % mod; }\nint qpow(int a, int b)\n{\n\tint ret = 1;\n\tfor (; b; b >>= 1, a = mul(a, a))\n\t\tif (b & 1)\n\t\t\tret = mul(ret, a);\n\treturn ret;\n}\n/* math */\nint fac[N], ifac[N];\ninline void init(int n)\n{\n\tifac[0] = fac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tifac[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n - 1; i; i--)\n\t\tifac[i] = mul(ifac[i + 1], i + 1);\n}\n\ninline int binom(int a, int b)\n{\n\tif (b > a)\n\t\treturn 0;\n\treturn mul(fac[a], mul(ifac[b], ifac[a - b]));\n}\n\nint f[N], g[N];\nint n;\n\nint main()\n{\n\tinit(2e6);\n\tcin >> n;\n\tfor (int i = n; i; i--)\n\t{\n\t\tif (i * 2 > n)\n\t\t{\n\t\t\tf[i] = g[i] = 1;\n\t\t}\n\t\tfor (int j = 2; j * i <= n; j++)\n\t\t{\n\t\t\tif (f[i * j] + 1 > f[i])\n\t\t\t\tf[i] = f[i * j] + 1, g[i] = 0;\n\t\t\tif (f[i * j] + 1 == f[i])\n\t\t\t{\n\t\t\t\tint t1 = n / (i * j), t2 = n / (i);\n\t\t\t\tg[i] = add(g[i], mul(g[i * j], mul(fac[t2 - t1], binom(n - t1 - 1, t2 - t1 - 1))));\n\t\t\t}\n\t\t}\n\t}\n\tcout << g[1] << endl;\n}']",,,"['combinatorics', 'dp', 'math', 'number theory']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Ehab and the Expected GCD Problem.json,https://codeforces.com//blog/entry/67388,Let s call the permutations from the statement good For starters we ll try to find some characteristics of good permutations Let s call the first element in a good permutation Then must have the maximal possible number of prime divisors Also every time the changes as you move along prefixes you must drop only one prime divisor from it That way we guarantee we have as many distinct s as possible Now there are 2 important observations concerning Observation 1 for some and In other words only and can divide That s because if has some prime divisor you can divide it by and multiply it by That way you ll have more prime divisors Observation 2 That s because if and you can instead replace it with divide it by and multiply it by and you ll have more prime divisors Now we can create the number of ways to fill a good permutation up to index such that its is Let It means the number of multiples of less than or equal to Here are the transitions If your permutation is filled until index and its is you can do one of the following things upon choosing Add a multiple of That way the won t change There are numbers you can add but you already added of them so Reduce by To do that you can add a multiple of that isn t a multiple of so Reduce by To do that you can add a multiple of that isn t a multiple of so As for the base case let You can always start with so Also if you can start with it so The answer is Code link https pastebin com N8FRN9sA Time complexity 
https://codeforces.com//contest/1972/problem/B,2620243,B,1972B,1972,B. Coin Games,There are n coins on the table forming a circle and each coin is either facing up or facing down Alice and Bob take turns to play the following game and Alice goes first In each operation the player chooses a facing up coin removes the coin and flips the two coins that are adjacent to it If before the operation there are only two coins left then one will be removed and the other won t be flipped as it would be flipped twice If before the operation there is only one coin left no coins will be flipped If before the operation there are no facing up coins the player loses Decide who will win the game if they both play optimally It can be proved that the game will end in a finite number of operations and one of them will win ,"['#include<bits/stdc++.h>using namespace std;\xa0#define int int64_t#define pb push_back#define pii pair<int, int>#define st first#define nd second#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()\xa0int32_t main() {\tios_base::sync_with_stdio(false);\tcin.tie(NULL);\t\tint t;\tcin >> t;\twhile(t--) {\t\tint n;\t\tcin >> n;\t\tint cnt = 0;\t\tfor(int i=0;i<n;i++) {\t\t\tchar c;\t\t\tcin >> c;\t\t\tif(c==\'U\') cnt++;\t\t}\t\tif(cnt%2) cout << ""YES\\n"";\t\telse cout << ""NO\\n"";\t}}']",,,['games'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Coin Games.json,https://codeforces.com//blog/entry/129027,It can be proved that Alice will win the game if and only if the number of facing up coins is odd Time complexity for each case Proof Consider all possible operations The number of decreases by The number of decreases by The number of decreases by The number of increases by It can be seen that the parity always changes It s obvious that if the number of is equal to the player loses because there aren t any available operations So Alice wins if and only if the number of is odd 
https://codeforces.com//contest/1821/problem/D,1887930,D,1821D,1821,D. Black Cells,You are playing with a really long strip consisting of 10 18 white cells numbered from left to right as 0 1 2 and so on You are controlling a special pointer that is initially in cell 0 Also you have a Shift button you can press and hold In one move you can do one of three actions move the pointer to the right from cell x to cell x 1 press and hold the Shift button release the Shift button the moment you release Shift all cells that were visited while Shift was pressed are colored in black Of course you can t press Shift if you already hold it Similarly you can t release Shift if you haven t pressed it Your goal is to color at least k cells but there is a restriction you are given n segments l i r i you can color cells only inside these segments i e you can color the cell x if and only if l i le x le r i for some i What is the minimum number of moves you need to make in order to color at least k cells black ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=300005,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(""text.txt"");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        ll N,K;cin>>N>>K;\n        vector<ll> L(N),R(N);\n        ll sum=0;\n        for(int i=0;i<N;i++) cin>>L[i];\n        for(int i=0;i<N;i++) cin>>R[i];\n        \n        for(int i=0;i<N;i++){\n            sum+=R[i]-L[i]+1;\n        }\n        if(sum<K){\n            cout<<-1<<""\\n"";\n            continue;\n        }\n        \n        ll ans=(1LL<<60),ONE=0;\n        sum=0;\n        \n        int i=0;\n        for(ll tar=K;tar<=K+N;tar++){\n            while(i<N){\n                if(sum+R[i]-L[i]+1>=tar){\n                    ll need=L[i]+(tar-sum-1)+2*(i+1);\n                    need-=2*min(ONE,tar-K);\n                    chmin(ans,need);\n                    break;\n                }else{\n                    sum+=R[i]-L[i]+1;\n                    if(L[i]==R[i]) ONE++;\n                    i++;\n                }\n            }\n        }\n        \n        cout<<ans<<""\\n"";\n    }\n}\n']",,,"['binary search', 'brute force', 'greedy', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Black Cells.json,https://codeforces.com//blog/entry/115296,Let s look at what s happening in the task in the end the pointer will move into some position and some segments on the prefix will be colored Note that it s optimal to stop only inside some segment or for some and if we colored segments including the last segment that may be colored partially the answer will be equal to Let s prove that it s not optimal to skip segments with length By contradiction suppose the optimal answer has a skipped segment If we color that segment instead we will make more moves for pressing and releasing Shift but we can make at least right move less So the new answer the contradiction Now we are ready to write a solution Let s iterate over the last segment we will color and therefore the segment where we stop At first let s imagine we colored the whole segment as well Let be the total length of all segments on prefix that are longer than and be the number of segments of length on this prefix There are three cases if stopping inside the th segment is not enough if but we will color all long segments plus several short ones The current answer will be equal to where is where we stop is the number of long segments and is the number of short segments we need if then we don t need any short segments More over we can stop even before reaching So the current answer will be equal to where is the exact position to stop to get exactly black cells and is the number of long segments Note that is indexed in calculations above and we can stop the first moment we met the situation The answer is the minimum among the answers we ve got in the process Since it s easy to update values and when we move from to the total complexity is 
https://codeforces.com//contest/1895/problem/B,2305456,B,1895B,1895,B. Points and Minimum Distance,You are given a sequence of integers a of length 2n You have to split these 2n integers into n pairs each pair will represent the coordinates of a point on a plane Each number from the sequence a should become the x or y coordinate of exactly one point Note that some points can be equal After the points are formed you have to choose a path s that starts from one of these points ends at one of these points and visits all n points at least once The length of path s is the sum of distances between all adjacent points on the path In this problem the distance between two points x 1 y 1 and x 2 y 2 is defined as x 1 x 2 y 1 y 2 Your task is to form n points and choose a path s in such a way that the length of path s is minimized ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<int> A(N*2);\n\trep(i,0,N*2) cin>>A[i];\n\tSo(A);\n\tint ans=0;\n\trep(i,1,N*2) if(i!=N) ans+=A[i]-A[i-1];\n\tcout<<ans<<""\\n"";\n\trep(i,0,N) cout<<A[i]<<"" ""<<A[i+N]<<""\\n"";\n}']",,,"['greedy', 'math', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Points and Minimum Distance.json,https://codeforces.com//blog/entry/122034,Since the order of does not matter let s sort them for convenience Let s treat the resulting path as two one dimensional paths one path and one path The length of the path is equal to the sum of lengths of these two paths If we fix which integers are coordinates and which integers are coordinates it s quite easy to see that it is optimal to place both and in sorted order the length of the path visiting both and should be at least and sorting gives exactly that result the same with coordinates Okay then how do we choose which integers are coordinates and which integers are coordinates The total length of the path will be equal to one of the minimums will be equal to the value of one of the maximums will be equal to the value of so we need to consider the remaining minimum and maximum The minimum coordinate of any type should be less than or equal to at least elements Similarly the maximum coordinate should be greater than or equal to at least elements So the second minimum the minimum which is not is at most the second maximum is at least and the length of the path is at least And it is possible to reach this bound take the first values in as coordinates and the last values as coordinates 
https://codeforces.com//contest/123/problem/D,655,D,123D,123,D. String,You are given a string Each pair of numbers and that fulfill the condition correspond to a substring of the string starting in the position and ending in the position inclusive Let s define the function of two strings like this We ll find a list of such pairs of numbers for which the corresponding substrings of string are equal to string Let s sort this list of pairs according to the pair s first number s increasing The value of function equals the number of non empty continuous sequences in the list For example The list of pairs is as follows Its continuous sequences are Your task is to calculate for the given string the sum for all that belongs to the set of all substrings of a string ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << ""("" << i->first << "", "" << i->second << "") ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= \' \'; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\n\nnamespace SA {\n    #define MAXN 100010\n    int n;\n    char t[MAXN];\n    int ki[MAXN], ik[MAXN], is[MAXN], hh;\n    bool cmp(const int &a, const int &b) {\n        return (a == b) ? 0 : (ik[a] != ik[b]) ? (ik[a] < ik[b]) : (ik[a + hh] < ik[b + hh]);\n    }\n    void makeSA() {\n        n = strlen(t);\n        int i;\n        for (i = 0; i <= n; ++i) ik[ki[i] = i] = t[i];\n        is[0] = is[n] = hh = 0;\n        sort(ki, ki + n + 1, cmp);\n        for (hh = 1; is[n] != n; hh <<= 1) {\n            sort(ki, ki + n + 1, cmp);\n            for (i = 0; i < n; ++i) is[i + 1] = is[i] + (cmp(ki[i], ki[i + 1]) ? 1 : 0);\n            for (i = 0; i <= n; ++i) ik[ki[i]] = is[i];\n        }\n    }\n    int lcp[MAXN];\n    void makeHA() {\n        int h = 0, i, j;\n        for (i = 0; i < n; ++i) {\n            for (j = ki[ik[i] - 1]; t[j + h] == t[i + h]; ++h);\n            lcp[ik[i] - 1] = h;\n            if (h) --h;\n        }\n    }\n}\n\nInt score(Int x) { return x * (x - 1) / 2; }\nint uf[MAXN];\nInt as[MAXN];\nInt now;\n\nint root(int x) { return (uf[x] < 0) ? x : (uf[x] = root(uf[x])); }\nbool conn(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return 0;\n    if (uf[x] > uf[y]) swap(x, y);\n    now -= score(as[x]) + score(as[y]);\n    uf[x] += uf[y]; uf[y] = x;\n    as[x] += as[y];\n    now += score(as[x]);\n    return 1;\n}\n\nint N;\nint A[MAXN];\npint ps[MAXN];\n\nint main() {\n    int i, k;\n    \n    for (; ~scanf(""%s"", SA::t); ) {\n        SA::makeSA();\n        SA::makeHA();\n        N = SA::n;\n        for (i = 0; i < N; ++i) {\n            A[i] = SA::lcp[i];\n        }\n//cout<<""A : "";pv(A,A+N);\n        for (i = 0; i < N; ++i) {\n            ps[i] = mp(A[i], i);\n        }\n        sort(ps, ps + N, greater<pint>());\n        Int ans = (Int)N * (N + 1) / 2;\n        for (i = 0; i <= N; ++i) {\n            as[i] = 1;\n            uf[i] = -1;\n        }\n        now = 0;\n        for (i = 0, k = N; k > 0; --k) {\n            for (; i < N && ps[i].first == k; ++i) {\n                conn(ps[i].second, ps[i].second + 1);\n            }\n//cout<<""uf : "";pv(uf,uf+N+1);\n//cout<<""now = ""<<now<<endl;\n            ans += now;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n    ']",,,['string suffix structures'],2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. String.json,https://codeforces.com//blog/entry/3047,Sort all suffixes of the string denoted by an array of strings ci Then the answer to the problem is the amount of 1 i j s and 1 k that the prefixes of length k in all ci j are equal Options when i j and 1 k ci can calculate at once it is the number of substrings in the string ie s s 1 2 Now let s count the LCP longest common prefix for adjacent suffixes ie ai LCP ci ci 1 for 1 i s Then let s count the number of 1 i j s and 1 k that k min ai j This task is to count the number of rectangles if there is a limit to the height of each column ie ai the maximum height of the rectangle in the column i Solve by a stack or list 
https://codeforces.com//contest/581/problem/B,36591,B,581B,581,B. Luxurious Houses,The capital of Berland has multifloor buildings The architect who built up the capital was very creative so all the houses were built in one row Let s enumerate all the houses from left to right starting with one A house is considered to be if the number of floors in it is strictly greater than in all the houses with larger numbers In other words a house is luxurious if the number of floors in it is strictly greater than in all the houses which are located to the right from it In this task it is assumed that the heights of floors in the houses are the same The new architect is interested in questions th of them is about the following how many floors should be added to the th house to make it luxurious for all from to inclusive You need to help him cope with this task Note that all these questions are independent from each other the answer to the question for house does not affect other answers i e the floors to the houses are not actually added ,"['#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint num[100010],pr[100010];\nint main()\n{\n    int n,n1;\n    cin>>n;\n    for(n1=1;n1<=n;n1++)\n        scanf(""%d"",&num[n1]);\n    int mx=-inf;\n    for(n1=n;n1>=1;n1--)\n    {\n        pr[n1]=max(0,mx-num[n1]+1);\n        mx=max(num[n1],mx);\n    }\n    for(n1=1;n1<=n;n1++)\n        cout<<pr[n1]<<\' \';  \n}\n']",,,"['implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Luxurious Houses.json,https://codeforces.com//blog/entry/20508,This problem can be solved in the following way Let s iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered Then the answer to house number i is number max 0 maxH 1 hi where hi number of floors in house number i 
https://codeforces.com//contest/1245/problem/F,456079,F,1245F,1245,F. Daniel and Spring Cleaning,While doing some spring cleaning Daniel found an old calculator that he loves so much However it seems like it is broken When he tries to compute 1 3 using the calculator he gets 2 instead of 4 But when he tries computing 1 4 he gets the correct answer 5 Puzzled by this mystery he opened up his calculator and found the answer to the riddle the full adders became half adders So when he tries to compute the sum a b using the calculator he instead gets the xorsum a oplus b read the definition by the link https en wikipedia org wiki Exclusive or As he saw earlier the calculator sometimes gives the correct answer And so he wonders given integers l and r how many pairs of integers a b satisfy the following conditions a b a oplus b l leq a leq r l leq b leq rHowever Daniel the Barman is going to the bar and will return in two hours He tells you to solve the problem before he returns or else you will have to enjoy being blocked ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nmap<pair<int, int>, long long > M;\nlong long solve(int a, int b)\n{\n    if(a==-1 || b== -1) return 0LL;\n    if(a == 0 || b == 0) return a+b+1;\n    if(a>b) swap(a, b);\n    auto it = M.find(make_pair(a,b));\n    if(it!=M.end())\n    {\n        return it->second;\n    }\n    int lb = 0;\n    for(int i=30; i>=0; --i)\n    {\n        if( (a&(1<<i))||(b&(1<<i)) )\n        {\n            lb = i;\n            break;\n        }\n    }\n\n    long long ans = 0;\n    // both 0,\n    {\n        int na = min(a, (1<<lb)-1);\n        int nb = min(b, (1<<lb)-1);\n        ans += solve(na, nb);\n    }\n    //a: 1 b = 0;\n    if(a >= (1<<lb))\n    {\n        int na = a-(1<<lb);\n        int nb = min(b, (1<<lb)-1);\n        ans += solve(na, nb);\n    }\n    //a: 0 b = 1;\n    if(b >= (1<<lb))\n    {\n        int na = min(a, (1<<lb)-1);\n        int nb = b-(1<<lb);\n        ans += solve(na, nb);\n    }\n\n\n    return M[make_pair(a, b)] = ans;\n}\nint main()\n{\n    int T; scanf(""%d"", &T);\n    while(T--)\n    {\n        int a, b;\n        scanf(""%d%d"", &a, &b);\n        long long ans = solve(b, b) - 2*solve(b, a-1) + solve(a-1, a-1);\n        printf(""%lld\\n"", ans);\n    }\n}']",,,"['bitmasks', 'brute force', 'combinatorics', 'dp']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Daniel and Spring Cleaning.json,https://codeforces.com/blog/entry/71080,Claim Let be nonnegative integers If then where is the bitwise AND of and Proof Recall that bitwise XOR is just addition in base two without carry So if addition is to be equal to addition in base two without carry then there must be no carry when added in base two which is what we wanted Define a function as follows let and be nonnegative integers then should be the number of pairs of integers such that the following conditions are satisfied Notice that Claim Let and be positive integers Then Proof Let be positive integers Suppose we want the following conditions to be satisfied Consider the binary representations of and There are three ways to choose the rightmost bits of and and And the number of ways to choose the other bits is always Thus What if and are not both even Define a function as follows let and be nonnegative integers then should be the number of integers such that the following conditions are satisfied Then if is odd or Similarly if is odd or Now all that remains is to implement efficiently Define a function as follows let be a positive integer then should be the least significant 1 bit of Next define a function as follows let and be positive integers then should be the number of integers such that the following conditions are satisfied Then if and otherwise Moreover it is easy to implement so that its time complexity is logarithmic with respect to 
https://codeforces.com//contest/1799/problem/H,1800605,H,1799H,1799,H. Tree Cutting,You are given a tree with n vertices A hero k times do the following operation Choose some edge Remove it Take one of the two remaining parts and delete it Write the number of vertices in the remaining part You are given an initial tree and the a sequence of written numbers Find the number of ways to make operations such that the written numbers are equal to the given numbers Due to the answer can be big find it by modulo 998 244 353 Two ways are considered different if on some operation edge or remaining part are selected differently ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % P)} {}\n    \n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += P;\n        }\n        if (x >= P) {\n            x -= P;\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(P - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) {\n        x = 1LL * x * rhs.x % P;\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    int k;\n    std::cin >> k;\n    \n    std::vector<int> s(k + 1);\n    s[0] = n;\n    for (int i = 1; i <= k; i++) {\n        std::cin >> s[i];\n    }\n    \n    for (int i = 0; i < k; i++) {\n        s[i] -= s[i + 1];\n    }\n    \n    k += 1;\n    \n    std::vector<int> sum(1 << k);\n    for (int mask = 1; mask < (1 << k); mask++) {\n        int x = __builtin_ctz(mask);\n        sum[mask] = sum[mask ^ (1 << x)] + s[x];\n    }\n    \n    std::vector dp(n, std::vector(k, std::vector(1 << k, std::array<Z, 2>{})));\n    std::vector<int> siz(n);\n    \n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (int i = 0; i < k; i++) {\n            dp[x][i][0][0] = 1;\n        }\n        siz[x] = 1;\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            self(self, y, x);\n            \n            siz[x] += siz[y];\n            \n            for (int S = (1 << k) - 1; S >= 0; S--) {\n                for (int i = 0; i < k; i++) {\n                    if (S >> i & 1) {\n                        continue;\n                    }\n                    int other = (1 << k) - 1 - S - (1 << i);\n                    auto val = dp[x][i][S];\n                    dp[x][i][S] = {};\n                    for (int T = other; ; T = (T - 1) & other) {\n                        for (int j = 0; j < k; j++) {\n                            if (~T >> j & 1) {\n                                continue;\n                            }\n                            if (siz[y] == sum[T]) {\n                                if (i > j) {\n                                    dp[x][i][S | T][0] += val[0] * dp[y][j][T ^ (1 << j)][0];\n                                    dp[x][i][S | T][1] += val[1] * dp[y][j][T ^ (1 << j)][0];\n                                }\n                                if (i < j) {\n                                    dp[x][i][S | T][1] += val[0] * dp[y][j][T ^ (1 << j)][j < k - 1];\n                                }\n                            }\n                        }\n                        dp[x][i][S | T][0] += val[0] * dp[y][i][T][0];\n                        dp[x][i][S | T][1] += val[0] * dp[y][i][T][1];\n                        dp[x][i][S | T][1] += val[1] * dp[y][i][T][0];\n                        if (T == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    dfs(dfs, 0, -1);\n    \n    Z ans = 0;\n    for (int i = 0; i < k; i++) {\n        ans += dp[0][i][(1 << k) - 1 - (1 << i)][i < k - 1];\n    }\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}\n']",,,"['bitmasks', 'dfs and similar', 'dp']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. Tree Cutting.json,https://codeforces.com//blog/entry/113321,We should calculate the number of ways to choose some edges of our tree and directions of them corresponding to operations such that the operations that will be done with them will result in the given sequence of written numbers To calculate these ways let s consider a subtree for our main tree Here corresponds to subtree of our tree with root in vertex also we include an edge from to the parent into this subtree is a submask of meaning that we have chosen in this subtree edges corresponding to operations from First of all consider the case when the edge from to parent is not chosen to any of the operations So let s iterate over children of and calculate the same dynamic programming for the considered prefix of subtrees To add the new subtree we should iterate over mask of operations that have been done on prefix and mask of operations that have been done in new subtree For these masks the condition should hold In the case when the edge from to parent is chosen let s iterate of the operation corresponding to it After that or should hold If we can choose this edge for the operation and orient it from parent to So the operations in should be with indices Iterate such masks and update the value corresponding to it using dp values already calculated for subtree of for the case when edge to parent is not chosen In the case similarly should hold and operations in should be with indices We can see that the number of ways calculated with such dp is correct because if we assigned operation to some edge with some direction we ensured the written size after the operation is correct and that the operations in the subtree have been done before or after the operation in relation to direction of edge Time complexity but it can be improved to with sum over subsets calculation 
https://codeforces.com//contest/1924/problem/F,2447862,F,1924F,1924,F. Anti-Proxy Attendance,Mr 1048576 is one of those faculty who hates wasting his time in taking class attendance Instead of taking attendance the old fashioned way he decided to try out something new today There are n students in his class having roll numbers 1 to n He knows that today In order to determine who is absent he can ask some queries to the class In each query he can provide two integers l and r 1 leq l leq r leq n and all students whose roll numbers are between l and r inclusive will raise their hands He then counts them to determine if the roll number of the absent student lies between these values Things seemed fine until his teaching assistant noticed something the students are dishonest Some students whose roll numbers lie in the given range may not raise their hands while some other students whose roll number does not lie in the given range may raise their hands But the students don t want to raise much suspicion So only the following 4 cases are possible for a particular query l r True Positive r l 1 students are present and r l 1 students raised their hands True Negative r l students are present and r l students raised their hands False Positive r l students are present but r l 1 students raised their hands False Negative r l 1 students are present but r l students raised their hands In the first two cases the students are said to be answering honestly while in the last two cases the students are said to be answering dishonestly The students can mutually decide upon their strategy not known to Mr 1048576 Also the students do not want to raise any suspicion and at the same time want to create a lot of confusion So their strategy always meets the following two conditions The students will never answer honestly 3 times in a row The students will never answer dishonestly 3 times in a row Mr 1048576 is frustrated by this act of students So he is willing to mark at most 2 students as absent though he knows that only one is The attendance is said to be successful if the student who is actually absent is among those two Also due to limited class time he can only ask up to lceil log 1 116 n rceil 1 queries weird numbers but okay Help him complete a successful attendance ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nint calc_lim(int N) { return ceil(log(N) / log(1.116)) - 1; }\n\nvoid solve(int tc) {\n\tdef(int, N);\n\tvi hist(N);\n\tvi max_with_ans{2, 2, 2, 2};\n\twhile (max_with_ans.bk < max(N, (int)1e5)) {\n\t\tint n = sz(max_with_ans);\n\t\t// len - s_1 <= max_with_ans(n - 2)\n\t\t// len - s_2 <= max_with_ans(n - 3)\n\t\t// len - s_3 <= max_with_ans(n - 4)\n\t\t// s_1 + s_2 + s_3 >= len\n\t\tmax_with_ans.pb((max_with_ans.at(n - 2) + max_with_ans.at(n - 3) +\n\t\t                 max_with_ans.at(n - 4)) /\n\t\t                2);\n\t\t// max_with_ans.pb(max_with_ans.at(n - 2) + max_with_ans.at(n - 3) +\n\t\t//                 max_with_ans.at(n - 4));\n\t}\n\tauto get_ans = [&](int len) {\n\t\tF0R(i, sz(max_with_ans)) if (len <= max_with_ans[i]) return i;\n\t\tassert(false);\n\t};\n\t// dbg(sz(max_with_ans) - 1, get_ans(1e5));\n\tint lim = get_ans(N);\n\t// dbg(max_with_ans);\n\t// dbg(get_ans(1e5));\n\t// dbg(calc_lim(1e5));\n\tvi cands(N);\n\tiota(all(cands), 0);\n\tauto query = [&](int l, int r) -> bool {\n\t\tassert(lim);\n\t\t--lim;\n\t\tps(""?"", 1 + l, 1 + r);\n\t\tcout.flush();\n\t\tint x;\n\t\tre(x);\n\t\tx = r - l + 1 - x;  // if true: x = 1 -> in range\n\t\tassert(0 <= x && x <= 1);\n\t\tvi ncands;\n\t\tfor (int c : cands) {\n\t\t\tbool lie = x ^ (l <= c && c <= r);\n\t\t\tif (lie) {\n\t\t\t\tckmin(hist[c], 0);\n\t\t\t\t--hist[c];\n\t\t\t} else {\n\t\t\t\tckmax(hist[c], 0);\n\t\t\t\t++hist[c];\n\t\t\t}\n\t\t\tif (abs(hist[c]) < 3) ncands.pb(c);\n\t\t}\n\t\tswap(cands, ncands);\n\t\tdbg(cands, hist, x);\n\t\treturn x;\n\t};\n\tauto sgn = [&](int x) {\n\t\tif (x < 0) return -1;\n\t\treturn 1;\n\t};\n\tauto all_same_sign = [&]() {\n\t\tassert(sz(cands));\n\t\tfor (int c : cands) {\n\t\t\tif (hist[c] == 0) return false;\n\t\t\tif (sgn(hist[c]) != sgn(hist[cands.ft])) return false;\n\t\t}\n\t\treturn true;\n\t};\n\twhile (sz(cands) > 2) {\n\t\tconst int len = sz(cands);\n\t\tconst int a = get_ans(len);\n\t\tAR<vi, 3> segs;\n\t\tfor (int c : cands) {\n\t\t\tif (len - sz(segs.at(0)) > max_with_ans.at(a - 2)) {\n\t\t\t\tsegs.at(0).pb(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len - sz(segs.at(1)) > max_with_ans.at(a - 3)) {\n\t\t\t\tsegs.at(1).pb(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsegs.at(2).pb(c);\n\t\t}\n\t\tdbg(len, sz(segs[0]), sz(segs[1]), sz(segs[2]), a);\n\t\tassert(len - sz(segs.at(0)) <= max_with_ans.at(a - 2));\n\t\tassert(len - sz(segs.at(1)) <= max_with_ans.at(a - 3));\n\t\tassert(len - sz(segs.at(2)) <= max_with_ans.at(a - 4));\n\t\tif (!all_same_sign()) query(0, N - 1);\n\t\tassert(all_same_sign());\n\t\tassert(lim >= a - 1);\n\t\tvi state{sgn(hist[cands.ft])};\n\t\twhile (sz(state) < 3) state.pb(state.bk);\n\t\tauto similar = [&](vi expected_state) {\n\t\t\tif (state != expected_state) { each(t, expected_state) t *= -1; }\n\t\t\tassert(state == expected_state);\n\t\t};\n\t\tauto upd = [&](int l, int r, bool res) {\n\t\t\tassert(0 <= l && l <= r && r <= 2);\n\t\t\tF0R(c, 3) {\n\t\t\t\tbool lie = (l <= c && c <= r) ^ res;\n\t\t\t\tif (lie) {\n\t\t\t\t\tckmin(state[c], 0);\n\t\t\t\t\t--state[c];\n\t\t\t\t} else {\n\t\t\t\t\tckmax(state[c], 0);\n\t\t\t\t\t++state[c];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tauto select = [&](int pos) {\n\t\t\tdbg(""SELECT"", pos);\n\t\t\tif (pos == -1) upd(0, 2, query(0, N - 1));\n\t\t\telse upd(pos, pos, query(segs.at(pos).ft, segs.at(pos).bk));\n\t\t};\n\t\tsimilar({1, 1, 1});\n\t\tselect(0);\n\t\tdbg(state);\n\t\tif (abs(state[0]) == 2) {\n\t\t\tsimilar({-2, 1, 1});\n\t\t\tselect(-1);\n\t\t\tif (abs(state[0]) == 3) {\n\t\t\t\tsimilar({-3, -1, -1});  // elim 0, 3 (save)\n\t\t\t} else {\n\t\t\t\tsimilar({1, 2, 2});\n\t\t\t\tselect(1);\n\t\t\t\tif (abs(state[1]) == 3) {\n\t\t\t\t\tsimilar({-1, 3, -1});  // elim 1, 4 (save)\n\t\t\t\t} else {\n\t\t\t\t\tsimilar({2, -1, 3});  // elim 2, 4\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsimilar({1, -2, -2});\n\t\t\tselect(1);\n\t\t\tif (abs(state[1]) == 3) {\n\t\t\t\tsimilar({2, -3, 1});  // elim 1, 3 (save)\n\t\t\t} else {\n\t\t\t\tsimilar({-1, 1, -3});  // elim 2, 3\n\t\t\t}\n\t\t}\n\t}\n\tassert(sz(cands));\n\tfor (int c : cands) {\n\t\tps(""!"", 1 + c);\n\t\tcout.flush();\n\t\tdef(int, y);\n\t\tif (y == 1) {\n\t\t\tps(""#"");\n\t\t\tcout.flush();\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(false);\n}\n\n// 1: 3 (save)\n// 2: 4 (save)\n// 3: 4\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']",,,"['constructive algorithms', 'dp', 'interactive', 'ternary search']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Anti-Proxy Attendance.json,https://codeforces.com//blog/entry/125137,TutorialThere might be multiple strategies to solve this problem I will describe one of them First let s try to solve a slightly easier version where something like queries are allowed and subset queries are allowed instead of range queries The main idea is to maintain a search space of size and reduce it to a search space of size using atmost queries At the end there will be exactly elements remaining in the search space which can be guessed The number of queries required to reduce a search space of size to a search space of size using the above strategy will be equal to Given below is one of the strategies how this can be achieved Let the current search space be Divide into disjoint exhaustive subsets and of nearly equal size Then follow the decision tree given below to discard one of the three subsets using at most queries It can seen that all the leaf nodes discard at least one third of the search space based on the previous three queries Now coming back to the problem where only ranges are allowed to be queried This can be easily solved by choosing and in such a way that all elements of are less than all elements of and all elements of are less than all elements of Then all queries used in the above decision tree can be reduced to range queries since it really doesn t matter what are the actual elements of and Finally there is just one small optimization left to be done Notice that when gets eliminated only queries are used and when and get eliminated queries are used So it must be more optimal to keep the size of smaller than and but by how much The answer is given by the equation It has two imaginary and two real roots out of which only one is positive So by taking the size of the segments approximately and you can do it in lesser number of queries which is less than which is less than 
https://codeforces.com//contest/1857/problem/D,2150545,D,1857D,1857,D. Strong Vertices,Given two arrays a and b both of length n Elements of both arrays indexed from 1 to n You are constructing a directed graph where edge from u to v u neq v exists if a u a v ge b u b v A vertex V is called strong if there exists a path from V to all other vertices A path in a directed graph is a chain of several vertices connected by edges such that moving from the vertex u along the directions of the edges the vertex v can be reached Your task is to find all strong vertices For example if a 3 1 2 4 and b 4 3 2 1 the graph will look like this ,"['#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n \nusing namespace std;\n \n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n \nusing ll = long long;\nusing ld = long double;\n\n/*\n a[u] - b[u] >= a[v] - b[v]\n */\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c(n);\n    for (auto& e : a) cin >> e;\n    for (auto& e : b) cin >> e;\n    for (int i = 0; i < n; ++i) c[i] = a[i] - b[i];\n    ll maxAndCount = INTMAX_MIN;\n    vector<int> indexes;\n    for (int i = 0; i < n; ++i) {\n        if (c[i] > maxAndCount) {\n            indexes.clear();\n            maxAndCount = c[i];\n            indexes.push_back(i);\n        } else if (c[i] == maxAndCount) {\n            indexes.push_back(i);\n        }\n    }\n    cout << indexes.size() << endl;\n    for (auto ind : indexes) cout << ind+1 << "" "";\n    cout << endl;\n}\n \nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n\n']",,,"['math', 'sortings', 'trees']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Strong Vertices.json,https://codeforces.com//blog/entry/119134,The first step is to modify the inequality We can create a new array where and our inequality is transformed to Suppose the set is the set of such vertices that is maximum possible From each there will be a path to all other vertices because is not less than any other so the set is guaranteed will be in our answer Now the question is whether there are other vertices in our answer Let s prove that from any such vertex that is not maximum there is no path to any vertex from The first observation that there is no edge between and any So the path must go through other vertices But even if there exist a path to another vertex will be still less that so it is impossible to get any In such way we proved that the answer will always be the set of such that is maximized The complexity is 
https://codeforces.com//contest/809/problem/E,106954,E,809E,809,E. Surprise me ,Tired of boring dates Leha and Noora decided to play a game Leha found a tree with vertices numbered from to We remind you that tree is an undirected graph without cycles Each vertex of a tree has a number written on it Quite by accident it turned out that all values written on vertices are distinct and are natural numbers between and The game goes in the following way Noora chooses some vertex of a tree uniformly at random and passes a move to Leha Leha in his turn chooses also uniformly at random some vertex from remaining vertices of a tree As you could guess there are variants of choosing vertices by players After that players calculate the value of a function of the chosen vertices where is Euler s totient function and is the shortest distance between vertices and in a tree Soon the game became boring for Noora so Leha decided to defuse the situation and calculate expected value of function over all variants of choosing vertices and hoping of at least somehow surprise the girl Leha asks for your help in calculating this expected value Let this value be representable in the form of an irreducible fraction To further surprise Noora he wants to name her the value Help Leha ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst long long mod=1000*1000*1000+7;\n\nint n;\nint tab[nax];\n\nvector <int> graf[nax];\n\nint sito[nax];\nint czybez[nax];\nlong long dziwne[nax];\nlong long odziwne[nax];\nlong long magia[nax];\nlong long phi[nax];\nint parz[nax];\nvector <int> dzie[nax];\n\nint bylcen[nax];\nint roz[nax];\nint maxroz[nax];\n\nvector <int> spo;\n\nlong long wyn;\n\nlong long dziel(long long a, long long b)\n{\n\tlong long wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t{\n\t\t\ta*=b;\n\t\t\ta%=mod;\n\t\t}\n\t\tb*=b;\n\t\tb%=mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nvoid dfs1(int v, int oj)\n{\n\tspo.push_back(v);\n\troz[v]=1;\n\tmaxroz[v]=0;\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj || bylcen[i])\n\t\t\tcontinue;\n\t\tdfs1(i, v);\n\t\troz[v]+=roz[i];\n\t\tmaxroz[v]=max(maxroz[v], roz[i]);\n\t}\n}\n\nint g;\n\nvector < pair <int,int> > wek[nax];\n\nlong long ile[nax];\n\nvoid dodaj(int v, long long r)\n{\n\tfor (int i : dzie[v])\n\t{\n\t\tile[i]+=r*phi[v];\n\t\tile[i]%=mod;\n\t}\n}\n\nvoid dfs2(int v, int oj, int dlu)\n{\n\twek[g].push_back({tab[v], dlu});\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj || bylcen[i])\n\t\t\tcontinue;\n\t\tdfs2(i, v, dlu+1);\n\t}\n}\n\nvoid szuk(int v)\n{\n\tif (bylcen[v])\n\t\treturn;\n\tspo.clear();\n\tdfs1(v, 0);\n\tint c=-1;\n\tfor (int i : spo)\n\t\tif (maxroz[i]*2<=(int)spo.size() && ((int)spo.size()-roz[i])*2<=(int)spo.size())\n\t\t\tc=i;\n\tassert(c!=-1);\n\tdebug() << c;\n\tbylcen[c]=1;\n\t\n\tg=1;\n\twek[1].clear();\n\twek[1].push_back({tab[c], 0});\n\tfor (int i : graf[c])\n\t{\n\t\tif (bylcen[i])\n\t\t\tcontinue;\n\t\tg++;\n\t\twek[g].clear();\n\t\tdfs2(i, c, 1);\n\t}\n\t\n\tfor (int i=1; i<=g; i++)\n\t\tdebug() << i << "" "" << wek[i];\n\t\n\tfor (int i=1; i<=g; i++)\n\t\tfor (auto j : wek[i])\n\t\t\tdodaj(j.first, 1);\n\t\n\tfor (int i=1; i<=g; i++)\n\t{\n\t\tfor (auto j : wek[i])\n\t\t\tdodaj(j.first, mod-1);\n\t\t\t\n\t\tfor (auto j : wek[i])\n\t\t{\n\t\t\tfor (auto l : dzie[j.first])\n\t\t\t{\n\t\t\t\twyn+=((magia[l]*phi[j.first])%mod)*((j.second*ile[l])%mod);\n\t\t\t\twyn%=mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto j : wek[i])\n\t\t\tdodaj(j.first, 1);\n\t}\n\t\n\tfor (int i=1; i<=g; i++)\n\t\tfor (auto j : wek[i])\n\t\t\tdodaj(j.first, mod-1);\n\t\n\t\n\tfor (int i : graf[c])\n\t\tszuk(i);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tif (!sito[i])\n\t\t\tfor (int j=i; j<=n; j+=i)\n\t\t\t\tsito[j]=i;\n\t}\n\tczybez[1]=1;\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tczybez[i]=czybez[i/sito[i]];\n\t\tif (sito[i/sito[i]]==sito[i])\n\t\t\tczybez[i]=0;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (czybez[i])\n\t\t{\n\t\t\tfor (int j=i; j<=n; j+=i)\n\t\t\t\tdzie[j].push_back(i);\n\t\t\tdziwne[i]=1;\n\t\t\tint v=i;\n\t\t\twhile(v>1)\n\t\t\t{\n\t\t\t\tdziwne[i]=(dziwne[i]*dziel(sito[v]-1, sito[v]))%mod;\n\t\t\t\tv/=sito[v];\n\t\t\t\tparz[i]^=1;\n\t\t\t}\n\t\t\todziwne[i]=dziel(1, dziwne[i]);\n\t\t\t\n\t\t\tfor (int j : dzie[i])\n\t\t\t{\n\t\t\t\tif (parz[j]==parz[i])\n\t\t\t\t\tmagia[i]+=odziwne[j];\n\t\t\t\telse\n\t\t\t\t\tmagia[i]-=odziwne[j];\n\t\t\t}\n\t\t\tmagia[i]%=mod;\n\t\t\tmagia[i]+=mod;\n\t\t\tmagia[i]%=mod;\n\t\t\t\n\t\t\t//debug() << i << "" "" << dziwne[i] << "" "" << (dziwne[i]*i)%mod;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tphi[i]=(i*dziwne[dzie[i].back()])%mod;\n\tdebug() << range(dzie+1, dzie+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint p1, p2;\n\t\tscanf(""%d%d"", &p1, &p2);\n\t\tgraf[p1].push_back(p2);\n\t\tgraf[p2].push_back(p1);\n\t}\n\tszuk(1);\n\twyn=dziel(wyn, n);\n\twyn=dziel(wyn, n-1);\n\twyn*=2;\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['divide and conquer', 'math', 'number theory', 'trees']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Surprise me .json,https://codeforces.com/blog/entry/52099,Here denotes Euler s totient function of is the greatest common divisor of and and denotes the amount of divisors of Small remark We need to find the answer in the form of where Let will be the sum of all pairwise values and is the amount of such pairs i e and let Then and the answer for the problem is which means there is no need to know As it often happens in the problems where you are required to calc anything over all paths of a tree it s a good idea to use so called centroid decomposition of a tree Shortly decomposition chooses some node of a tree processes each path going through it and then deletes this node and solves the problem in the remaining forest recursively It s obvious there is no matter what node we choose the answer will be always calculated correctly but total run time depends on choosing this node It s claimed each tree contains such a vertex with the removal of which all the remaining trees will have a size at least twice less then a size of this tree So if we always choose such a vertex each node of a tree will exist no more than in trees built by desomposition which is good enough Let s build centroid decomposition of the given tree Let s is the root of the current tree Let s solve the problem for this tree let s call it layer and solve it for the sons of recursively after that At first where Also for the current layer where is the distance from to Let s fix some vertex How to calc the sum inside our layer over all such that the path goes through Let s denote the set of such as We want to add to the answer where Considering we need to sum up all such sums over each from the layer the sum current layer increases the total sum equals to So we need to be able to sum up for each Let s understand how to calc for each which means the sum of Euler s totient functions of all such vertices that has Let s imagine we know which denotes the sum of for such that Then the following statement is true We can calculate values of in time each divisor of each number in range from to which is as it known will be counted in layers of the centroid decomposition So we re already able to calc values in the time apparently proprtional to More precisely the number of operations we waste for calculating will be equal to over all such and that where is the amount of divisors of This sum is equivalent to Coding this solution carefully can give you thanks to high we set to solution I can prove only complexity for this solution which is a very high upper bound Can anyone give any better complexity for However we can speed up this solution Here we calculated giving that was equal to leading to complexity for each in the layer Actually the sum for each can be showed as using some coefficients If we find them we ll be able to process each of the layer in time which leads to final complexity Let s precalculate these coefficients in ascending order for each It s easy to see that and for a prime Now let s is a composite number and let s is it s least prime divisor and is such maximum number that is divisible by and Then coefficients for any divisor of can be calculated in the following way If then otherwise Total complexity 
https://codeforces.com//contest/620/problem/E,45931,E,620E,620,E. New Year Tree,The New Year holidays are over but Resha doesn t want to throw away the New Year tree He invited his best friends Kerim and Gural to help him to redecorate the New Year tree The New Year tree is an undirected tree with vertices and root in the vertex You should process the queries of the two types Change the colours of all vertices in the subtree of the vertex to the colour Find the number of different colours in the subtree of the vertex ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 400010;\n\nvector <int> g[N];\nint pos[N], to[N];\nint kw = 0, w[N];\n\nvoid dfs(int v, int pr) {\n  pos[v] = kw;\n  w[kw++] = v;\n  for (int j = 0; j < (int) g[v].size(); j++) {\n    int u = g[v][j];\n    if (u != pr) {\n      dfs(u, v);\n    }\n  }\n  to[v] = kw - 1;\n}\n\nlong long a[4 * N];\nbool put[4 * N];\nint color[N];\n\nvoid build(int x, int l, int r) {\n  if (l < r) {\n    int y = (l + r) >> 1;\n    build(x + x, l, y);\n    build(x + x + 1, y + 1, r);\n    a[x] = a[x + x] | a[x + x + 1];\n    put[x] = false;\n  } else {\n    a[x] = 1LL << color[w[l]];\n    put[x] = true;\n  }\n}\n\ninline void push(int x) {\n  if (put[x]) {\n    a[x + x] = a[x + x + 1] = a[x];\n    put[x + x] = put[x + x + 1] = true;\n    put[x] = false;\n  }\n}\n\ninline void gather(int x) {\n  a[x] = a[x + x] | a[x + x + 1];\n}\n\nvoid modify(int x, int l, int r, int ll, int rr, long long v) {\n  if (r < ll || rr < l) {\n    return;\n  }\n  if (ll <= l && r <= rr) {\n    a[x] = v;\n    put[x] = true;\n    return;\n  }\n  push(x);\n  int y = (l + r) >> 1;\n  modify(x + x, l, y, ll, rr, v);\n  modify(x + x + 1, y + 1, r, ll, rr, v);\n  gather(x);\n}\n\nlong long get(int x, int l, int r, int ll, int rr) {\n  if (r < ll || rr < l) {\n    return 0;\n  }\n  if (ll <= l && r <= rr) {\n    return a[x];\n  }\n  push(x);\n  int y = (l + r) >> 1;\n  long long res = get(x + x, l, y, ll, rr);\n  res |= get(x + x + 1, y + 1, r, ll, rr);\n  gather(x);\n  return res;\n}\n\nint main() {\n  int n, m;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", color + i);\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar;\n    scanf(""%d %d"", &foo, &bar);\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  dfs(0, -1);\n  build(1, 0, n - 1);\n  while (m--) {\n    int type;\n    scanf(""%d"", &type);\n    if (type == 1) {\n      int foo, bar;\n      scanf(""%d %d"", &foo, &bar);\n      foo--;\n      modify(1, 0, n - 1, pos[foo], to[foo], 1LL << bar);\n    } else {\n      int foo;\n      scanf(""%d"", &foo);\n      foo--;\n      long long value = get(1, 0, n - 1, pos[foo], to[foo]);\n      printf(""%d\\n"", __builtin_popcountll(value));\n    }\n  }\n  return 0;\n}\n']",,,"['bitmasks', 'data structures', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. New Year Tree.json,https://codeforces.com//blog/entry/22936,Let s run dfs on the tree and write out the vertices in order of their visisiting by dfs that permutation is called Euler walk Easy to see that subtree of any vertex is a subsegment of that permutation Note that the number of different colours is so we can store the set of colours just as mask of binary bits in bit type long long in C long in Java Let s build the segment tree over the permutation which supports two operations paint subsegment by some colour and find the mask of colours of some segment solution Complexity 
https://codeforces.com//contest/1355/problem/C,621793,C,1355C,1355,C. Count Triangles,Like any unknown mathematician Yuri has favourite numbers A B C and D where A leq B leq C leq D Yuri also likes triangles and once he thought how many non degenerate triangles with integer sides x y and z exist such that A leq x leq B leq y leq C leq z leq D holds Yuri is preparing problems for a new contest now so he is very busy That s why he asked you to calculate the number of triangles with described property The triangle is called non degenerate if and only if its vertices are not collinear ,"['#include <bits/stdc++.h>\n#define ld long double\n#define endl ""\\n""\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\nint32_t main(){\n  fastio;\n  ll a,b,c,d;\n  cin>>a>>b>>c>>d;\n  ll tot=0;\n  for(int z=c;z<=d;z++){\n    int mn = max(a,z-c + 1);\n    if(mn > b)continue;\n\n    int mn2 = max(b,z - mn + 1);\n\n    int ter = (b - mn + 1);   \n\n    int put1 = min(ter,mn2 - b + 1);\n\n    int a1 = c - mn2 + 1;\n\n    tot+=(put1*(a1 + a1 + put1 - 1) / 2);\n\n    ter-=put1;\n    tot+=ter*(c-b+1);\n\n  }\n  cout << tot << endl;\n  \n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}']",,,"['binary search', 'implementation', 'math', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Count Triangles.json,https://codeforces.com//blog/entry/77491,Since x le y le z to be a non degenerate triangle for given triple it is necessary and sufficient to satisfy z x y Let s calculate for all s x y how many ways there are to choose x y To do that we will try all x and add 1 on segment x B x C offline using prefix sums Let s calculate prefix sums once more now we can find in O 1 how many ways there are to choose x y such that their sum if greater than z Try all z calculate the answer Total complexity O C 
https://codeforces.com//contest/894/problem/A,134790,A,894A,894,A. QAQ, QAQ is a word to denote an expression of crying Imagine Q as eyes with tears and A as a mouth Now Diamond has given Bort a string consisting of only uppercase English letters of length There is a great number of QAQ in the string Diamond is so cute Bort wants to know how many subsequences are in the string Diamond has given Note that the letters don t have to be consecutive but the order of letters should be exact ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nchar s[SZ];\nint main()\n{\n\tcin>>s+1; int n=strlen(s+1),ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\tif(s[i]==\'Q\'&&s[k]==\'Q\'&&s[j]==\'A\') ++ans;\n\tcout<<ans<<""\\n"";\n}\n']",,,"['brute force', 'dp']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. QAQ.json,https://codeforces.com//blog/entry/55884,Since we can iterate on the place of first Q A and second Q The brute force solution will work in time which can surely pass If we only iterate on the place of A we can get the number of Q before and after it using prefix sums and it leads to solution 
https://codeforces.com//contest/1404/problem/D,718464,D,1404D,1404,D. Game of Pairs,Consider a fixed positive integer n Two players and play a game as follows considers the 2n numbers 1 2 dots 2n and partitions them as he wants into n disjoint pairs Then chooses exactly one element from each of the pairs that created he chooses elements he wants To determine the winner of the game we compute the sum of the numbers chosen by If the sum of all these numbers is a multiple of 2n then wins Otherwise wins You are given the integer n Your task is to decide which player you wish to play as and win the game ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tif(n%2==0){\n\t\tcout<<""First""<<endl;\n\t\tvi g(n*2);\n\t\trep(i,n*2)g[i]=i%n+1;\n\t\tprint(g);\n\t\tcout.flush();\n\t}else{\n\t\tcout<<""Second""<<endl;\n\t\tvi g=readvi(2*n,-1);\n\t\tdmp(g);\n\t\tvi buf(n,-1);\n\t\tvi p(2*n,-1);\n\t\trep(i,2*n){\n\t\t\tint x=g[i];\n\t\t\tif(buf[x]==-1)buf[x]=i;\n\t\t\telse{\n\t\t\t\tp[buf[x]]=i;\n\t\t\t\tp[i]=buf[x];\n\t\t\t}\n\t\t}\n\t\tdmp(p);\n\t\tvi tp(2*n,-1);\n\t\trep(i,2*n)if(tp[i]==-1){\n\t\t\tint x=i;\n\t\t\twhile(tp[x]==-1){\n\t\t\t\ttp[x]=0;\n\t\t\t\tx=p[x];\n\t\t\t\ttp[x]=1;\n\t\t\t\tif(x<n)x+=n;\n\t\t\t\telse x-=n;\n\t\t\t}\n\t\t}\n\t\tdmp(tp);\n\t\tvi x[2];\n\t\trep(i,2*n)x[tp[i]].pb(i+1);\n\t\tbool done=false;\n\t\trep(k,2){\n\t\t\tint s=accumulate(all(x[k]),int(0));\n\t\t\tif(s%(2*n)==0){\n\t\t\t\tprint(x[k]);\n\t\t\t\tcout.flush();\n\t\t\t\tdone=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(done);\n\t}\n\tint res;cin>>res;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'interactive', 'math', 'number theory']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Game of Pairs.json,https://codeforces.com//blog/entry/82366,We split the problem into two cases We claim that can guarantee a win by forming the pairs Note that no matter which elements chooses he will always take one element having each remainder modulo Thus the total sum isSay then this reduces to Since is an odd integer this is nonzero and the sum isn t even divisible by let alone This is the more difficult part of the problem We claim that now is able to win and present a strategy We have two important claims It is enough for to find a choice of elements from each pair such that the sum of the chosen numbers is divisible by instead of Notice that the sum of all the numbers is which is congruent to If the sum of some numbers one from each pair is divisible by then it is either or In the first case we have already won Otherwise if we take every other number instead the sum of those numbers will be and we will also win It is always possible to take one element from each pair such that each of the remainders modulo appears exactly once Consider a graph with vertices and regard the pairs chosen by as red edges in this graph We will additionally create edges connecting the vertices and for each and paint them blue Then every vertex is adjacent to one red edge and one blue edge In particular all vertices have degree so the graph splits into disjoint cycles Since the edges in each cycle alternate between being red and blue they all have even lengths so it s possible to color their vertices alternately black and white and we can construct such a coloring by a simple DFS Finally after doing this for all cycles take the numbers corresponding to all the white vertices Since no two of them are joined by a red edge they are all in different pairs and since no two of them are joined by a blue edge their residues modulo are all different and thus each one appears exactly once Finally by combining the two previous claims the problem is solved since Complexity 
https://codeforces.com//contest/1400/problem/G,709189,G,1400G,1400,G. Mercenaries,Polycarp plays a yet another strategic computer game In this game he leads an army of mercenaries Polycarp wants to gather his army for a quest There are n mercenaries for hire and the army should consist of some subset of them The i th mercenary can be chosen if the number of chosen mercenaries is not less than l i otherwise he deems the quest to be doomed and not greater than r i he doesn t want to share the trophies with too many other mercenaries Furthermore m pairs of mercenaries hate each other and cannot be chosen for the same quest How many subsets does Polycarp need to consider In other words calculate the number of non empty subsets of mercenaries such that the size of this subset belongs to l i r i for each chosen mercenary and there are no two mercenaries in the subset that hate each other The answer may be large so calculate it modulo 998244353 ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << \'{\'; string sep; for (const auto &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << \'{\'; string sep; for (const auto &x : arr) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n\nvector<mod_int> inv, factorial, inv_factorial;\nint prepared_maximum = -1;\n\nvoid prepare_factorials(int64_t maximum) {\n    static int prepare_calls = 0;\n\n    if (prepare_calls++ == 0) {\n        // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n        for (int p = 2; p * p <= MOD; p += p % 2 + 1)\n            assert(MOD % p != 0);\n\n        inv = {0, 1};\n        factorial = inv_factorial = {1, 1};\n        prepared_maximum = 1;\n    }\n\n    if (maximum > prepared_maximum) {\n        inv.resize(maximum + 1);\n        factorial.resize(maximum + 1);\n        inv_factorial.resize(maximum + 1);\n\n        for (int i = prepared_maximum + 1; i <= maximum; i++) {\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n            factorial[i] = i * factorial[i - 1];\n            inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n        }\n\n        prepared_maximum = int(maximum);\n    }\n}\n\nmod_int choose(int64_t n, int64_t r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(int64_t n, int64_t r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(int64_t n, int64_t r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[n - r];\n}\n\nmod_int inv_permute(int64_t n, int64_t r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[n - r];\n}\n\nstruct union_find {\n    // When data[x] < 0, x is a root and -data[x] is its tree size. When data[x] >= 0, data[x] is x\'s parent.\n    vector<int> data;\n    int components = 0;\n\n    union_find(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    void init(int n) {\n        data.assign(n + 1, -1);\n        components = n;\n    }\n\n    int find(int x) {\n        return data[x] < 0 ? x : data[x] = find(data[x]);\n    }\n\n    int get_size(int x) {\n        return -data[find(x)];\n    }\n\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y)\n            return false;\n\n        if (-data[x] < -data[y])\n            swap(x, y);\n\n        data[x] += data[y];\n        data[y] = x;\n        components--;\n        return true;\n    }\n};\n\n\nint N, M;\nvector<int> L, R;\nvector<vector<int>> adj;\nvector<vector<int>> components;\nvector<vector<vector<int>>> component_dp;\n// vector<int> which_component;\n\nbool edge_exists(int a, int b) {\n    return binary_search(adj[a].begin(), adj[a].end(), b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N >> M;\n    prepare_factorials(N);\n    L.resize(N);\n    R.resize(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> L[i] >> R[i];\n\n    adj.assign(N, {});\n    union_find UF(N);\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        UF.unite(a, b);\n    }\n\n    for (int i = 0; i < N; i++)\n        sort(adj[i].begin(), adj[i].end());\n\n    for (int root = 0; root < N; root++)\n        if (UF.find(root) == root && UF.get_size(root) > 1) {\n            vector<int> component;\n\n            for (int i = 0; i < N; i++)\n                if (UF.find(i) == root)\n                    component.push_back(i);\n\n            components.push_back(component);\n        }\n\n    // which_component.assign(N, -1);\n\n    // for (int c = 0; c < int(components.size()); c++)\n    //     for (int x : components[c])\n    //         which_component[x] = c;\n\n    component_dp.assign(components.size(), {});\n\n    for (int c = 0; c < int(components.size()); c++) {\n        auto &component = components[c];\n        auto &dp = component_dp[c];\n        int C = int(component.size());\n        vector<vector<bool>> bad(C, vector<bool>(C, false));\n\n        for (int i = 0; i < C; i++)\n            for (int j = i + 1; j < C; j++)\n                bad[i][j] = edge_exists(component[i], component[j]);\n\n        dp.assign(1 << C, vector<int>(C + 1, 0));\n\n        for (int mask = 0; mask < 1 << C; mask++) {\n            bool works = true;\n\n            for (int i = 0; i < C && works; i++)\n                if (mask >> i & 1)\n                    for (int j = i + 1; j < C && works; j++)\n                        if ((mask >> j & 1) && bad[i][j])\n                            works = false;\n\n            if (works)\n                dp[mask][__builtin_popcount(mask)] = 1;\n        }\n\n        for (int bit = 0; bit < C; bit++)\n            for (int mask = 0; mask < 1 << C; mask++)\n                if ((mask >> bit & 1) == 0)\n                    for (int i = 0; i < C; i++)\n                        dp[mask | 1 << bit][i] += dp[mask][i];\n\n        dbg(dp);\n    }\n\n    vector<int> freq(N + 2, 0);\n\n    for (int i = 0; i < N; i++) {\n        freq[L[i]]++;\n        freq[R[i] + 1]--;\n    }\n\n    for (int i = 1; i <= N; i++)\n        freq[i] += freq[i - 1];\n\n    mod_int answer = 0;\n\n    for (int num = 1; num <= N; num++) {\n        int merc = freq[num];\n        vector<mod_int> knapsack(2 * M + 1, 0);\n        knapsack[0] = 1;\n        int in_component = 0;\n\n        for (int c = 0; c < int(components.size()); c++) {\n            auto &component = components[c];\n            int C = int(component.size());\n            int mask = 0;\n\n            for (int i = 0; i < C; i++)\n                if (L[component[i]] <= num && num <= R[component[i]])\n                    mask |= 1 << i;\n\n            in_component += __builtin_popcount(mask);\n\n            for (int count = M - 1; count >= 0; count--)\n                for (int add = 1; add <= C; add++)\n                    knapsack[count + add] += knapsack[count] * component_dp[c][mask][add];\n        }\n\n        for (int have = 0; have <= M; have++)\n            answer += knapsack[have] * choose(merc - in_component, num - have);\n    }\n\n    cout << answer << \'\\n\';\n}\n']",,,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'dsu', 'math', 'two pointers']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Mercenaries.json,https://codeforces.com//blog/entry/81916,In order to take care of the and constraints we can iterate on the number of mercenaries we ll choose and find the number of choices for each count The key constraint in this problem is that is at most 20 which means that there can only be a few connected components that aren t just a single node In particular the largest possible connected component size is 21 since a connected graph with edges has at most nodes This means that for each connected component we can iterate over all of the subsets of nodes in that component and check whether the subset is a valid choice i e is an independent set We can then do a DP for each component where dp mask k the number of submasks of mask that have k ones and represent a valid independent set subset of the component Finally we can iterate over the total number of mercenaries we want We can then do a knapsack over each of the components making sure to only consider nodes in each component where and work with our number of mercenaries Finally we determine how many valid mercenaries are available outside of our components and the rest is a simple choose function Code 90977154 
https://codeforces.com//contest/123/problem/A,652,A,123A,123,A. Prime Permutation,You are given a string consisting of small Latin letters Let s denote the length of the string as The characters in the string are numbered starting from Your task is to find out if it is possible to rearrange characters in string so that for any prime number and for any integer ranging from to inclusive the following condition was fulfilled If the answer is positive find one way to rearrange the characters ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << ""("" << i->first << "", "" << i->second << "") ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= \' \'; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\n\nconst int LIM = 1005;\nint isnp[1010];\nvoid prpr() {\n    int i, j;\n    isnp[0] = isnp[1] = 1;\n    for (i = 2; i * i < LIM; ++i) if (!isnp[i]) {\n        for (j = i * i; j < LIM; j += i) isnp[j] = 1;\n    }\n}\n\nint uf[1010];\nint root(int x) { return (uf[x] < 0) ? x : (uf[x] = root(uf[x])); }\nbool conn(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return 0;\n    if (uf[x] > uf[y]) swap(x, y);\n    uf[x] += uf[y]; uf[y] = x;\n    return 1;\n}\n\nvoid gen(int n) {\n    int p, i;\n    memset(uf, ~0, n << 2);\n    for (p = 2; p <= n; ++p) if (!isnp[p]) {\n        for (i = 1; i <= n / p; ++i) {\n            conn(p - 1, p * i - 1);\n        }\n    }\n}\n\nconst int M = 0x100;\n\nint N;\nchar S[1010];\nchar T[1010];\n\npint ps[1010];\n\nint qsLen;\npint qs[1010];\n\nint main() {\n    int i;\n    int c;\n    \n    prpr();\n    \n/*\nfor(int n=1;n<=1000;++n){\ngen(n);\nint cnt=0;for(i=0;i<n;++i)if(-uf[i]>1)++cnt;\nif(cnt!=1)cout<<""n = ""<<n<<endl;\nif(n<=5){cout<<""uf : "";pv(uf,uf+n);}\n}\n//*/\n    \n    for (; ~scanf(""%s"", S); ) {\n        N = strlen(S);\n        gen(N);\n        for (c = 0; c < M; ++c) {\n            ps[c] = mp(0, c);\n        }\n        for (i = 0; i < N; ++i) {\n            ++ps[S[i] - 0].first;\n        }\n        sort(ps, ps + M, greater<pint>());\n        qsLen = 0;\n        for (i = 0; i < N; ++i) if (uf[i] < 0) {\n            qs[qsLen++] = mp(-uf[i], i);\n        }\n        sort(qs, qs + qsLen, greater<pint>());\n        if (ps[0].first < qs[0].first) {\n            puts(""NO"");\n            continue;\n        }\n        for (i = 0; i < N; ++i) if (root(i) == qs[0].second) {\n            T[i] = ps[0].second;\n            --ps[0].first;\n        }\n        int j = 0;\n        for (i = 0; i < N; ++i) if (root(i) != qs[0].second) {\n            for (; ps[j].first == 0; ++j);\n            T[i] = ps[j].second;\n            --ps[j].first;\n        }\n        T[N] = 0;\n        puts(""YES"");\n        puts(T);\n    }\n    \n    return 0;\n}\n']",,,"['implementation', 'number theory', 'strings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Prime Permutation.json,https://codeforces.com//blog/entry/3047,All positions except the first and those whose number is a prime greater s 2 have to have the same symbol Remaining positions can have any symbol Consider positions that should be the same for p 2 is 2 4 6 8 Now let s take a position with the number x s 2 this position should have the same character as the position of 2 as the symbol x must be equal to the character at position 2 x which is equal to the character at position 2 Now consider the position whose number is more than s 2 If this position is not a prime then there is a prime number p to divide the number at our positions and p s 2 So character at position p is equal the character at position 2 and so a symbol at our position is also consistent to the character at position 2 The remaining positions are not combined with any other positions so it does not matter which symbol is situated here Let s find the symbol which occurs the most and try to place the symbol on the position in which the characters have to be equal If this symbol for all positions is not enough then the answer will be NO otherwise arrange the remaining characters by any way at other positions 
https://codeforces.com//contest/652/problem/E,52872,E,652E,652,E. Pursuit For Artifacts,Johnny is playing a well known computer game The game are in some country where the player can freely travel pass quests and gain an experience In that country there are islands and bridges between them so you can travel from any island to any other In the middle of some bridges are lying ancient powerful artifacts Johnny is not interested in artifacts but he can get some money by selling some artifact At the start Johnny is in the island and the artifact dealer is in the island possibly they are on the same island Johnny wants to find some artifact come to the dealer and sell it The only difficulty is that bridges are too old and destroying right after passing over them Johnnie s character can t swim fly and teleport so the problem became too difficult Note that Johnny can t pass the half of the bridge collect the artifact and return to the same island Determine if Johnny can find some artifact and sell it ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nVVI ppi;\nstruct bridges{\n  VVI impl;\n  stack<in> whr;\n  stack<in> hsn;\n  stack<in> ci;\n  VI vst;\n  VI trc;\n  VI hit;\n  in mhsh;\n  stack<in> ts;\n  VI comp,psd,gvh;\n  void ad(in a, in b){\n    impl[a].PB(b);\n    impl[b].PB(a);\n  }\n  void ini(in n){\n    mhsh=n;\n    impl=VVI(mhsh,VI(0));\n  }\n  void hasol(){\n    trc.resize(mhsh,0);\n    vst.resize(mhsh,0);\n    hit.resize(mhsh,0);\n    psd=hit;\n    comp.resize(mhsh,-1);\n    gvh.resize(mhsh,0);\n    in crn=0;\n    in ccp=0;\n    forn(z,mhsh){\n      if(vst[z])\n\tcontinue;\n      crn++;\n      whr.push(z);\n      hsn.push(0);\n      vst[z]=crn;\n      hit[z]=0;\n      in chit=1;\n      ci.push(0);\n      in u,i,ch,v;\n      while(!whr.empty()){\n\tu=whr.top();\n\ti=ci.top();\n\tch=hsn.top();\n\tgvh[u]=ch;\n\tif(!psd[u]){\n\t  ts.push(u);\n\t  psd[u]=1;\n\t}\n\tif(i==sz(impl[u])){\n\t  if(ch>=hit[u]){\n\t    while(1){\n\t      comp[ts.top()]=ccp;\n\t      ts.pop();\n\t      if(comp[u]!=-1)\n\t\tbreak;\n\t    }\n\t    ccp++;\n\t  }\n\t  whr.pop();\n\t  ci.pop();\n\t  hsn.pop();\n\t  continue;\n\t}\n\tv=impl[u][i];\n\tif(trc[u]==v){\n\t  ci.top()++;\n\t  continue;\n\t}\n\tif(vst[v]==0){\n\t  trc[v]=u;\n\t  whr.push(v);\n\t  hsn.push(chit);\n\t  ci.push(0);\n\t  hit[v]=chit++;\n\t  vst[v]=crn;\n\t  continue;\n\t}\n\tif(vst[v]==crn && comp[v]==-1){\n\t  if(gvh[v]<ch){\n\t    hsn.top()=gvh[v];\n\t  }\n\t}\n\tci.top()++;\n      }\n    }\n  }\n};\nVVI egs;\nbridges mbr;\nin n,m;\nVI tx,ty,tbr;\nbool fnd=0;\nVI dfv;\nset<in> gdcp;\nbool isfd(in a){\n  return gdcp.find(a)!=gdcp.end();\n}\nin dfs(in u, in gl){\n  if(dfv[u])\n    return 0;\n  dfv[u]=1;\n  if(u==gl){\n    gdcp.insert(mbr.comp[u]);\n    return 1;\n  }\n  in tt;\n  forv(i,egs[u]){\n    tt=egs[u][i];\n    if(dfs(tt,gl)){\n      gdcp.insert(mbr.comp[u]);\n      return 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n>>m;\n  mbr.ini(n);\n  tx=ty=tbr=VI(m);\n  egs.resize(n);\n  forn(i,m){\n    cin>>tx[i]>>ty[i]>>tbr[i];\n    --tx[i];\n    --ty[i];\n    egs[tx[i]].PB(ty[i]);\n    egs[ty[i]].PB(tx[i]);\n    mbr.ad(tx[i],ty[i]);\n  }\n  mbr.hasol();\n  in id1,id2;\n  cin>>id1>>id2;\n  --id1;\n  --id2;\n  dfv.resize(n);\n  dfs(id1,id2);\n  forn(i,m){\n    if(tbr[i]){\n      if(isfd(mbr.comp[tx[i]])&&isfd(mbr.comp[ty[i]])){\n\tcout<<""YES""<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<""NO""<<endl;\n  return 0;\n}\n']",,,"['dfs and similar', 'dsu', 'graphs', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Pursuit For Artifacts.json,https://codeforces.com//blog/entry/43986,The problem was suggested by Alexey Dergunov dalex Edge biconnected component in an undirected graph is a maximal by inclusion set of vertices so that there are two edge disjoint paths between any pair of vertices Consider the graph with biconnected components as vertices Easy to see that it s a tree if it contains some cycle then the whole cycle is a biconnected component All edges are destroying when we passing over them so we can t returnto the same vertex in the tree after leaving it by some edge Consider the biconncted components that contains the vertices and Let s denote them and Statement the answer is YES if and only if on the path in the tree from the vertex to the vertex there are an edge with an artifact or there are a biconnected component that contains some edge with an artifact Easy to see that the statement is true if there are such edge then we can pass over it in the tree on the path from to or we can pass over it in biconnected component The converse also easy to check Here is one of the ways to find edge biconnected components Let s orient all edges to direction that depth first search passed it for the first time Let s find in new directed graph strongly connected components Statement the strongly connected components in the new graph coincide with the biconnected components in old undirected graph Also you can notice that the edges in tree is the bridges of the graph bridges in terms of graph theory So you can simply find the edges in the graph Not too short C solutionconst int N 500500 M 500500 int n m int eused M vector eid N vector g1 N tg1 N vector w N int a b bool read if cin n m return false forn i m eused i false forn i n g1 i clear tg1 i clear eid i clear w i clear forn i m int x y z assert scanf 
https://codeforces.com//contest/1999/problem/E,2800023,E,1999E,1999,E. Triple Operations,On the board Ivy wrote down all integers from l to r inclusive In an operation she does the following pick two numbers x and y on the board erase them and in their place write the numbers 3x and lfloor frac y 3 rfloor Here lfloor bullet rfloor denotes rounding down to the nearest integer What is the minimum number of operations Ivy needs to make all numbers on the board equal 0 We have a proof that this is always possible ,"['/*Though leaves are many , the root is one.Through all the lying days of my youthI swayed my leaves and flowers in the sun.Now I may wither into the truth.\t  \t  \t- William Butler Yeats*///#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2"")#include<bits/stdc++.h>//#include<ext/pb_ds/assoc_container.hpp>using namespace std;//using namespace __gnu_pbds;const int inf=0x3f3f3f3f;const double eps=1e-6;const int mod=1e9+7;typedef long long ll;#ifndef LOCAL#define cerr if(0)cout#define eprintf(...) 0#else#define eprintf(...) fprintf(stderr, __VA_ARGS__)#endifinline string getstr(string &s,int l,int r){string ret="""";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}int modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}inline int Rand(){return rand()*32768+rand();}int lg[200005],sum[200005];int main(){\tlg[0]=0;lg[1]=1;\tfor(int i=2;i<=2e5;i++)lg[i]=lg[i/3]+1;\tfor(int i=1;i<=2e5;i++)sum[i]=sum[i-1]+lg[i];\tint T;cin>>T;\twhile(T--){\t\tint l,r;\t\tcin>>l>>r;\t\tcout<<lg[l]+sum[r]-sum[l-1]<<endl;\t}\treturn 0;}']",,,"['dp', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Triple Operations.json,https://codeforces.com//blog/entry/132373,Consider writing the numbers in ternary it is like binary but instead we use three digits and for clarity we will use digit in the solution instead of bit or trit In the operation we will add a 0 to the end of the number x and remove the last digit of y For example if x 8 and y 11 then in ternary the numbers are 223 and 1023 After the operation x 24 and y 3 and indeed in ternary they are 2203 and 103 This is because multiplying by 3 is multiplying by 103 and similarly dividing by 3 is like dividing by 103 This means that the total number of digits across all numbers does not change since we add one digit and remove one digit So how is it possible to make all numbers 0 Well there is one exception to the above rule when we use the operation with x 0 we add a 0 to the end of the number 0 but this added digit doesn t count because 3 0 0 This means that if we ever do the operation with x 0 then we will lose one digit total since x doesn t gain a digit but y loses a digit This means the solution is as follows first we make one of the numbers equal to 0 Then we will use this 0 to remove all the digits of all other numbers To use the fewest number of operations possible we should do the first step on the minimum number since it has the fewest digits Let f x denote the number of ternary digits in the number x actually f x log3 x 1 Then the first step takes f l operations since l is the smallest number in the range l r and the second step takes f l f r operations since we need to remove all the digits which is the total number of digits from l to r This means the answer for each test case is f l f l f r To find this sum quickly we can compute prefix sums on f so that the answer is simply f l psum r psum l 1 which takes O 1 time per test case with O n precomputation 
https://codeforces.com//contest/819/problem/C,112025,C,819C,819,C. Mister B and Beacons on Field,Mister B has a house in the middle of a giant plain field which attracted aliens life For convenience aliens specified the Cartesian coordinate system on the field in such a way that Mister B s house has coordinates After that they sent three beacons to the field but something went wrong One beacon was completely destroyed while the other two landed in positions with coordinates and respectively but shut down Mister B was interested in this devices so he decided to take them home He came to the first beacon placed at lifted it up and carried the beacon home choosing the shortest path After that he came to the other beacon placed at and also carried it home choosing the shortest path When first beacon was lifted up the navigation system of the beacons was activated Partially destroyed navigation system started to work in following way At time moments when both survived beacons are at points with integer coordinates the system tries to find a location for the third beacon It succeeds if and only if there is a point with integer coordinates such that the area of the triangle formed by the two survived beacons and this point is equal to In this case the system sends a packet of information with beacon positions to aliens otherwise it doesn t Compute how many packets of information system sent while Mister B was moving the beacons ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\nint n1,n2,n3,m1,m2,m3,s1,s2,s3;\nmap<int,int>M;\nint w[110000][3],len,f[110000];\nlong long ans[110000][110];\nvoid add(int k1,int k2,int k3){\n\tint where=M[k1];// cout<<""add ""<<k1<<"" ""<<k2<<"" ""<<k3<<endl;\n\tif (where==0) M[k1]=++len,where=len,w[len][0]=w[len][1]=w[len][2]=0,f[len]=k1;\n\tw[where][k3]+=k2;\n}\nvoid insert(int k1,int k2){\n\tfor (int i=2;i*i<=k1;i++)\n\t\tif (k1%i==0){\n\t\t\tint num=0;\n\t\t\twhile (k1%i==0) num++,k1/=i;\n\t\t\tadd(i,num,k2);\n\t\t}\n\tif (k1>1) add(k1,1,k2);\n}\nlong long pre[1100000];\nlong long an,m,n,s;\nvoid calc(int k){\n\tfor (int i=0;i<=w[k][0];i++){\n\t\tans[k][i]=0;\n\t\tfor (int j=0;j<=min(i,w[k][2]);j++)\n\t\t\tif (i-j==0) ans[k][i]++; else if (i-j==1) ans[k][i]--;\n\t}\n}\nvoid calc(int k1,long long k2,int k3){\n\tif (k3==0) return;\n\tif (k1>len){\n\t\tan+=(m/k2)*k3; return;\n\t}\n\tfor (int i=0;i<=w[k1][0];i++){\n\t\tcalc(k1+1,k2,k3*ans[k1][i]);\n\t\tif (i!=w[k1][0]) k2*=f[k1];\n\t}\n}\nvoid calc2(int k1,long long k2){\n\tif (k2>n) return;\n\tif (k1>len){\n\t\tan++; return;\n\t}\n\tfor (int i=0;i<=w[k1][2];i++){\n\t\tcalc2(k1+1,k2);\n\t\tif (i!=w[k1][2]) k2*=f[k1];\n\t}\n}\nvoid solve(){\n\tscanf(""%d%d%d"",&n1,&n2,&n3); len=0; an=0;\n\tscanf(""%d%d%d"",&m1,&m2,&m3); m=1ll*m1*m2*m3;\n\tscanf(""%d%d%d"",&s1,&s2,&s3); n=1ll*n1*n2*n3;\n\tM.clear(); s1*=2; s=1ll*s1*s2*s3;\n\tinsert(n1,0); insert(n2,0); insert(n3,0);\n\tinsert(m1,1); insert(m2,1); insert(m3,1);\n\tinsert(s1,2); insert(s2,2); insert(s3,2);\n\tfor (int i=1;i<=len;i++) calc(i);\n\tcalc(1,1,1); //cout<<an<<endl;\n//\tint ww=0;\n//\tfor (int i=1;i<=m;i++) if (s%__gcd((int)n,i)==0) ww++;\n//\tcout<<ww<<endl;\n\t//for (int i=1;i<=len;i++) cout<<f[i]<<"" ""<<w[i][0]<<"" ""<<w[i][1]<<"" ""<<w[i][2]<<endl; \n\tcalc2(1,1);\n\tprintf(""%I64d\\n"",an);\n}\nint main(){\n\tint t; scanf(""%d"",&t);\n\tfor (;t;t--) solve();\n\treturn 0;\n}']",,,['number theory'],2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Mister B and Beacons on Field.json,https://codeforces.com//blog/entry/52946,There 2 stages in this task moving of first beacon and moving of second But at first we need factorization of and Since and are product of integers it can be done in time by Sieve of Eratosthenes Start from when second beacon is moving Position of beacons will look like pair of points where We need to check existing of point such that area of triangle equals to Using cross product After simplifying we get where So we can iterate all divisors of using factorization of and recursive algorithm Complexity of second stage is where number of divisors of and for In the we have such points where We need to check existing of point such that area of triangle equals to Using cross product we can get next equation Then solution exists iff And we need to calculate how many such that We will solve it in next way let s and Look at all that It s obvious that if is divisor of then doesn t divide at In result we have some constrains on like doesn t divide at Finally we have next task calculate number of such that doesn t divide any of It can be done with inclusion exclusion principle where number of which divides is Complexity of first stage is where number of prime divisors of for integers up to Result complexity is per test 
https://codeforces.com//contest/1985/problem/H1,2693244,H1,1985H1,1985,H1. Maximize the Largest Component  Easy Version ,Alex has a grid with n rows and m columns consisting of and characters A set of cells forms a connected component if from any cell in this set it is possible to reach any other cell in this set by only moving to another cell in the set that shares a The size of a connected component is the number of cells in the set In one operation Alex selects any row r 1 le r le n any column c 1 le c le m then sets every cell in row r column c to be Help Alex find the maximum possible size of the largest connected component of cells that he can achieve after performing the operation ,"[""#include <bits/stdc++.h>\xa0using namespace std;\xa0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\xa0struct DSU{\tvector<int> e;\tvoid init(int n)\t{\t\te.assign(n, -1);\t}\tint get(int x)\t{\t\tif (e[x] < 0) return x;\t\treturn e[x] = get(e[x]);\t}\tvoid unite(int x, int y)\t{\t\tx = get(x), y = get(y);\t\tif (x == y) return;\t\tif (e[x] > e[y]) swap(x, y);\t\te[x] += e[y];\t\te[y] = x;\t}};\xa0const int MXN = 1e6 + 5;const int mod = 1e9 + 7;\xa0int A[4] = {0, 0, -1, 1};int B[4] = {-1, 1, 0, 0};int used[MXN];\xa0void _(){\tint n, m;\tcin >> n >> m;\tDSU dsu;\tdsu.init(n * m);\tstring s[n];\tfor (int i = 0; i < n; i++) cin >> s[i];\tfor (int i = 0; i < n; i++)\t{\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m) \t\t\t\t{\t\t\t\t\tif (s[i][j] == '#' && s[x][y] == '#') dsu.unite(i * m + j, x * m + y);\t\t\t\t}\t\t\t}\t\t}\t}\tint mx = max(n, m);\tfor (int i = 0; i < n * m; i++) mx = max(mx, -dsu.e[dsu.get(i)]);\tfor (int i = 0; i < n; i++)\t{\t\tvector<int> v;\t\tint sum = 0;\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tif (s[i][j] == '.') sum++;\t\t\telse if (!used[dsu.get(i * m + j)]) \t\t\t{\t\t\t\tsum += -dsu.e[dsu.get(i * m + j)];\t\t\t\tused[dsu.get(i * m + j)] = 1;\t\t\t\tv.push_back(dsu.get(i * m + j));\t\t\t}\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m)\t\t\t\t{\t\t\t\t\tif (s[x][y] == '#') \t\t\t\t\t{\t\t\t\t\t\tif (!used[dsu.get(x * m + y)])\t\t\t\t\t\t{\t\t\t\t\t\t\tsum += -dsu.e[dsu.get(x * m + y)];\t\t\t\t\t\t\tused[dsu.get(x * m + y)] = 1;\t\t\t\t\t\t\tv.push_back(dsu.get(x * m + y));\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tmx = max(mx, sum);\t\tfor (int i : v) used[i] = 0;\t}\tfor (int j = 0; j < m; j++)\t{\t\tvector<int> v;\t\tint sum = 0;\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\tif (s[i][j] == '.') sum++;\t\t\telse if (!used[dsu.get(i * m + j)]) \t\t\t{\t\t\t\tsum += -dsu.e[dsu.get(i * m + j)];\t\t\t\tused[dsu.get(i * m + j)] = 1;\t\t\t\tv.push_back(dsu.get(i * m + j));\t\t\t}\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m)\t\t\t\t{\t\t\t\t\tif (s[x][y] == '#') \t\t\t\t\t{\t\t\t\t\t\tif (!used[dsu.get(x * m + y)])\t\t\t\t\t\t{\t\t\t\t\t\t\tsum += -dsu.e[dsu.get(x * m + y)];\t\t\t\t\t\t\tused[dsu.get(x * m + y)] = 1;\t\t\t\t\t\t\tv.push_back(dsu.get(x * m + y));\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tmx = max(mx, sum);\t\tfor (int i : v) used[i] = 0;\t}\tcout << mx << '\\n';}\xa0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\tfor (int tt = 1; tt <= t; tt++)\t{\t\t_();\t}}""]",,,"['brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\H1. Maximize the Largest Component  Easy Version .json,https://codeforces.com//blog/entry/129620,Let s first solve the problem if we can only select and fill rows Columns can be handled in the exact same way For each row r we need to find the size of the component formed by filling row r i e the size of the component containing row r if we set all cells in row r to be The size of the component containing row r if we set all cells in row r to be will be the sum of The number of in row r since these cells will be set to Let Fr denote this value for some row r The sum of sizes of components containing a cell in either row r 1 r or r 1 i e components that are touching row r This is since these components will be part of the component containing row r Let Rr denote this value for some row r The challenge is computing the second term quickly For some component let s be the size of the component and let rmin and rmax denote the minimum and maximum row of a cell in the component This means that the component will contain cells with rows rmin rmin 1 rmax Note that we can find these values with a dfs Since the component will contribute s to rows in rmin 1 rmin rmax 1 we add s to Rrmin 1 Rrmin Rrmax 1 This can be done naively or with prefix sums We find the maximum Fr Rr and then handle columns in the same way This solution runs in O nm time 
https://codeforces.com//contest/665/problem/B,55549,B,665B,665,B. Shopping,Ayush is a cashier at the shopping center Recently his department has started a service which allows users to shop online The store contains items customers have already used the above service Each user paid for items Let denote the th item in the th person s order Due to the space limitations all the items are arranged in one single row When Ayush receives the th order he will find one by one all the items in the row Let denote the position of the item in the row at the moment of its collection Then Ayush takes time equal to for the th customer When Ayush accesses the th element he keeps a new stock in the front of the row and takes away the th element Thus the values are updating Your task is to calculate the total time it takes for Ayush to process all the orders You can assume that the market has endless stock ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\n\nint tab[1007];\n\nint wyn;\n\nint x;\n\nint y;\n\nint main()\n{\n    scanf(""%d%d%d"", &n, &m, &k);\n    for (int i=1; i<=k; i++)\n    scanf(""%d"", &tab[i]);\n    for (int i=1; i<=n*m; i++)\n    {\n        scanf(""%d"", &x);\n        for (int i=1; i<=k; i++)\n        {\n            if (tab[i]==x)\n            {\n                y=i;\n            }\n        }\n        while(y>1)\n        {\n            swap(tab[y], tab[y-1]);\n            y--;\n            wyn++;\n        }\n        wyn++;\n    }\n    printf(""%d\\n"", wyn);\n    return 0;\n}\n']",,,['brute force'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Shopping.json,https://codeforces.com//blog/entry/44466,The problem was suggested by Ayush Anand JeanValjean01 In this problem you should simply do what was written in the problem statement There are no tricks C solution 
https://codeforces.com//contest/1420/problem/D,735853,D,1420D,1420,D. Rescue Nibel ,Ori and Sein have overcome many difficult challenges They finally lit the Shrouded Lantern and found Gumon Seal the key to the Forlorn Ruins When they tried to open the door to the ruins nothing happened Ori was very surprised but Sein gave the explanation quickly clever Gumon decided to make an additional defence for the door There are n lamps with Spirit Tree s light Sein knows the time of turning on and off for the i th lamp l i and r i respectively To open the door you have to choose k lamps in such a way that there will be a moment of time when they all will be turned on While Sein decides which of the k lamps to pick Ori is interested how many ways there are to pick such k lamps that the door will open It may happen that Sein may be wrong and there are no such k lamps The answer might be large so print it modulo 998 244 353 ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=1e6+5,Mod=998244353;\nint n,a[N],s1[N],s2[N],fac[N]={1,1},finv[N]={1,1},k,ans,l[N],r[N],cnt;\nint C(int n,int m){\n\tif(m>n||n<0||m<0) return 0;\n\treturn 1ll*fac[n]*finv[m]%Mod*finv[n-m]%Mod;\n}\npair<int,int>b[N];\nint main(){\n\tscanf(""%d%d"",&n,&k);\n\trep(i,2,n) fac[i]=1ll*fac[i-1]*i%Mod;\n\trep(i,2,n) finv[i]=1ll*(Mod-Mod/i)*finv[Mod%i]%Mod;\n\trep(i,1,n) finv[i]=1ll*finv[i-1]*finv[i]%Mod;\n\trep(i,1,n){\n\t\tint l,r; scanf(""%d%d"",&l,&r);\n\t\tb[i*2]=make_pair(l,i*2);\n\t\tb[i*2+1]=make_pair(r,i*2+1);\n\t\t/*s1[l]++,s1[r+1]--;\n\t\ts2[l+1]++,s2[r+1]--;*/\n\t}\n\tsort(b+2,b+2*n+1+1);\n\trep(i,2,2*n+1){\n\t\tint p=b[i].second;\n\t\tif(b[i].first!=b[i-1].first) cnt++;\n\t\tif(p&1){\n\t\t\tr[p/2]=cnt;\n\t\t}else{\n\t\t\tl[p/2]=cnt;\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts1[l[i]]++; s1[r[i]+1]--;\n\t\ts2[l[i]+1]++; s2[r[i]+1]--;\n\t}\n\trep(i,1,cnt) s1[i]=s1[i-1]+s1[i],s2[i]=s2[i-1]+s2[i];\n\trep(i,1,cnt){\n\t\tans=(1ll*ans+C(s1[i],k)+Mod-C(s2[i],k))%Mod;\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']",,,"['combinatorics', 'data structures', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Rescue Nibel .json,https://codeforces.com//blog/entry/82978,In this task we need to find the number of sets of segments such that these segments intersect at least in one point Let s look at the starting point of the intersection This point will always be the beginning of a segment Let us find the number of sets of segments that their intersection begins at the point Let us denote as number of segments that pass through this point and as numbers of segments that start at this point Then all the segments must pass through and at least one segment must start at The number of sets of segments passing through is and the number of sets of segments passing through none of which starts at is From here we obtain that the required number of piece sets is By summing up all possible values we get the answer to the task It should be noted that and can be easily supported using the event method Then the total runtime will be 
https://codeforces.com//contest/1109/problem/B,298870,B,1109B,1109,B. Sasha and One More Name,Reading books is one of Sasha s passions Once while he was reading one book he became acquainted with an unusual character The character told about himself like that Many are my names in many countries Mithrandir among the Elves Thark n to the Dwarves Ol rin I was in my youth in the West that is forgotten in the South Inc nus in the North Gandalf to the East I go not And at that moment Sasha thought how would that character be called in the East In the East all names are palindromes A string is a palindrome if it reads the same backward as forward For example such strings as and are palindromes but strings and are not Sasha believed that the hero would be named after one of the gods of the East As long as there couldn t be two equal names so in the East people did the following they wrote the original name as a string on a piece of paper then cut the paper minimum number of times k so they got k 1 pieces of paper with substrings of the initial string and then unite those pieces together to get a new string Pieces they could be shuffled In this way it s possible to achive a string from the string using 3 cuts by swapping papers with substrings and The string can t be received using the same cuts More formally Sasha wants for the given s find such minimum k that you can cut this string into k 1 parts and then unite them in such a way that the final string will be a palindrome and it won t be equal to the initial string s It there is no answer then print without quotes ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nbool isPal(string s) {\n\tint n = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] != s[n - 1 - i])\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tstring s;\n\tcin >> s;\n\tbool allEq = true;\n\tint n = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tif (n % 2 == 0 || i != n / 2)\n\t\t\tallEq &= s[0] == s[i];\n\tif (allEq) {\n\t\tcout << ""Impossible\\n"";\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t\tstring p = s.substr(i, n - i) + s.substr(0, i);\n\t\tif (p == s || !isPal(p)) continue;\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tcout << 2 << endl;\n\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'hashing', 'strings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Sasha and One More Name.json,https://codeforces.com//blog/entry/65295,Let s be the given string it s length If consists of or when is odd equal characters then there is no way to get the answer Otherwise let s prove that the answer can be always reached in two cuttings Let s the longest prefix of that consists of equal characters has the length equal to Cut and and call the remaining piece as Swap and then unite all three parts together The central part will stay unchanged and then So now we can get the answer in two cuttings Finally you must chech if it is possible to get the result by making just one cutting As soon as one cutting is equal to some cyclic shift then our task is to check if there is a cyclic shift which is a palindrome and not equal to It can be done by fixing each cyclic shift and checking each one separately Complexity 
https://codeforces.com//contest/1530/problem/F,1049173,F,1530F,1530,F. Bingo,Getting ready for VK Fest 2021 you prepared a table with n rows and n columns and filled each cell of this table with some event related with the festival that could either happen or not for example whether you will win a prize on the festival or whether it will rain Forecasting algorithms used in VK have already estimated the probability for each event to happen Event in row i and column j will happen with probability a i j cdot 10 4 All of the events are mutually independent Let s call the table if there exists a line such that all n events on it happen The line could be any horizontal line cells i 1 i 2 ldots i n for some i any vertical line cells 1 j 2 j ldots n j for some j the main diagonal cells 1 1 2 2 ldots n n or the antidiagonal cells 1 n 2 n 1 ldots n 1 Find the probability of your table to be winning and output it modulo 31 607 see Output section ,"['#include <bits/stdc++.h>\n\nconstexpr int P = 31607;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, int b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    const auto inv = Z(10000).inv();\n    \n    std::vector a(n, std::vector<Z>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int x;\n            std::cin >> x;\n            a[i][j] = x * inv;\n        }\n    }\n    \n    Z ans = 1;\n    \n    for (int md = 0; md <= 1; md++) {\n        for (int ad = 0; ad <= 1; ad++) {\n            auto b = a;\n            \n            Z res = ((md + ad) % 2 == 0 ? -1 : 1);\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((md && i == j) || (ad && i + j == n - 1)) {\n                        res *= b[i][j];\n                        b[i][j] = 1;\n                    }\n                }\n            }\n            \n            std::function<void(int, std::vector<Z>, Z)> dfs = [&](int r, std::vector<Z> v, Z coef) {\n                if (r == n) {\n                    for (int i = 0; i < n; i++) {\n                        coef *= 1 - v[i];\n                    }\n                    ans += coef;\n                    return;\n                }\n                Z tmp = -coef;\n                for (int i = 0; i < n; i++) {\n                    tmp *= b[r][i];\n                }\n                dfs(r + 1, v, tmp);\n                for (int i = 0; i < n; i++) {\n                    v[i] *= b[r][i];\n                }\n                dfs(r + 1, v, coef);\n            };\n            dfs(0, std::vector<Z>(n, 1), res);\n        }\n    }\n    \n    std::cout << ans.val() << ""\\n"";\n    \n    return 0;\n}']",,,"['bitmasks', 'combinatorics', 'dp', 'math', 'probabilities']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Bingo.json,https://codeforces.com//blog/entry/92951,Let denote the possible lines that can be formed Let denote the event that line is formed and denote the event that line is formed i e Let s find the probability that our table is winning It is equal to Note that the following two statements are true The first one follows from the law of total probability and the second one follows from the definition of conditional probability These two statements combined allow us to use the following formula We can apply this formula recursively Specifically we can make a function where is a subset of which calculates For and for we can generalize the formula above as follows Here is the probability that line is formed given that lines are formed This is equal to the product of probabilities of all cells belonging to which do not belong to any of The answer to the problem i e the probability that our table is winning is This allows us to implement an solution which is too slow In fact this solution is equivalent to applying inclusion exclusion principle To optimize this solution note that once it becomes easy to calculate we don t have to make any more recursive calls Why would it become easy to calculate though Let s order the lines in such a way that are the horizontal lines of the table Consider a call of the form This call is basically asking what is the probability that none of lines are formed given that lines are formed Note that the horizontal lines are independent and we can actually answer this question in Specifically for any horizontal line the probability that it is not formed is minus the product of probabilities of all its cells not belonging to any of The overall value of is the product of probabilities for individual horizontal lines This way we have built an solution This might be fast enough depending on your implementation but there are at least two ways to optimize it to The first way is to maintain the products of probabilities of untouched cells for horizontal lines on the fly For simplicity assume that and are the diagonal lines For each after we process vertical line we can update the products for all horizontal lines with the cells of in make a recursive call and roll back the updates in again Once we get to instead of going through every cell of the table in we can just multiply horizontal line products in The second way is to define is a bitmask of size to be the product of over all belonging to All values of can be calculated in using dynamic programming and where is any bit set in When we arrive at a call for each of the horizontal lines instead of going through its cells we can construct the mask of cells the values in which we want to multiply and use the corresponding value of in 
https://codeforces.com//contest/1062/problem/A,254593,A,1062A,1062,A. A Prank,JATC and his friend Giraffe are currently in their room solving some problems Giraffe has written on the board an array a 1 a 2 a n of integers such that 1 le a 1 a 2 ldots a n le 10 3 and then went to the bathroom JATC decided to prank his friend by erasing some in the array Since he doesn t want for the prank to go too far he will only erase in a way such that Giraffe can still restore the array using the information from the remaining elements Because Giraffe has created the array he s that it s an increasing array and all the elements are integers in the range 1 10 3 JATC wonders what is the greatest number of elements he can erase ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint a[1006];\n\nint main () {\n\tint n;\n\tcin >> n;\n\tfor (int i=1;i<=n;++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta[x] = 1;\n\t\t//cin >> a[i];\n\t}\n\tint ans = 0;\n\t//from 1 ~ ?\n\tint L,R;\n\tfor (int i=1;i<=1000;++i) {\n\t\tif (!a[i]) {\n\t\t\tans = max(ans, max(0,i-2));\n\t\t\tL = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//from 1000 ~ ?\n\tfor (int i=1000;i>=1;--i) {\n\t\tif (!a[i]) {\n\t\t\tans =max(ans ,max(0,999-i));\n\t\t\tR = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//else\n\tint pre=0;\n\tfor (int i=L+1;i<=R-1;++i) {\n\t\tif (a[i-1] && a[i] && a[i+1]) ++pre;\n\t\telse pre=0;\n\t\tans = max(ans,pre);\n\t}\n\tcout << ans << endl;\n}\n']",,,"['greedy', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. A Prank.json,https://codeforces.com/blog/entry/63199,Since for all let set and For every such that if then we can erase all the elements between and not inclusive So just check for all the valid pairs and maximize the answer Time complexity 
https://codeforces.com//contest/1385/problem/C,675200,C,1385C,1385,C. Make It Good,You are given an array a consisting of n integers You have to find the length of the smallest shortest of elements you need to erase from a to make it a array Recall that the prefix of the array a a 1 a 2 dots a n is a subarray consisting several first elements the prefix of the array a of length k is the array a 1 a 2 dots a k 0 le k le n The array b of length m is called if you can obtain a array c c 1 le c 2 le dots le c m from it repeating the following operation m times initially c is empty select either the first or the last element of b remove it from b and append it to the end of the array c For example if we do 4 operations take b 1 then b m then b m 1 and at last b 2 then b becomes b 3 b 4 dots b m 3 and c b 1 b m b m 1 b 2 Consider the following example b 1 2 3 4 4 2 1 This array is because we can obtain array c from it by the following sequence of operations take the first element of b so b 2 3 4 4 2 1 c 1 take the last element of b so b 2 3 4 4 2 c 1 1 take the last element of b so b 2 3 4 4 c 1 1 2 take the first element of b so b 3 4 4 c 1 1 2 2 take the first element of b so b 4 4 c 1 1 2 2 3 take the last element of b so b 4 c 1 1 2 2 3 4 take the only element of b so b c 1 1 2 2 3 4 4 c is non decreasing Note that the array consisting of one element is Print the length of the shortest prefix of a to delete erase to make a to be a array Note that the required length can be 0 You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint t, n, a[N];\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(""%d"", &n);\n    for (int i = 1; i <= n; ++i) {\n      scanf(""%d"", a + i);\n    }\n    int en = n;\n    while (en > 1 and a[en] <= a[en - 1]) --en;\n    while (en > 1 and a[en] >= a[en - 1]) --en;\n    printf(""%d\\n"", en - 1);\n  }\n  return 0;\n}\n\n']",,,['greedy'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Make It Good.json,https://codeforces.com//blog/entry/80257,Consider the maximum element of the good array of length Then we can notice that the array looks like And this is pretty obvious that if the array doesn t have this structure then it isn t good you can see it yourself So we need to find the longest such suffix It s pretty easy doable with pointer initially the pointer is at the last element Then while and decrease by one If we re done with the previous step we do the same but while and The answer is 
https://codeforces.com//contest/681/problem/C,62559,C,681C,681,C. Heap Operations,Petya has recently learned data structure named Binary heap The heap he is now operating with allows the following operations put the given number into the heap get the value of the minimum element in the heap extract the minimum element from the heap Thus at any moment of time the heap contains several integers possibly none some of them might be equal In order to better learn this data structure Petya took an empty heap and applied some operations above to it Also he carefully wrote down all the operations and their results to his event log following the format put the element with value in the heap the value of the minimum element contained in the heap was equal to the minimum element was extracted from the heap only one instance if there were many All the operations were correct i e there was at least one element in the heap each time or operations were applied While Petya was away for a lunch his little brother Vova came to the room took away some of the pages from Petya s log and used them to make paper boats Now Vova is worried if he made Petya s sequence of operations inconsistent For example if one apply operations one by one in the order they are written in the event log results of operations might differ from the results recorded by Petya and some of or operations may be incorrect as the heap is empty at the moment they are applied Now Vova wants to add some new operation records to the event log in order to make the resulting sequence of operations correct That is the result of each operation is equal to the result in the record and the heap is non empty when ad are applied Vova wants to complete this as fast as possible as the Petya may get back at any moment He asks you to add the least possible number of operation records to the current log Note that arbitrary number of operations may be added at the beginning between any two other operations or at the end of the log ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nmultiset<int> ss;\n\nchar buf[100];\n\nvector<pair<char, int> > vv;\n\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf("" %s"", buf);\n\t\tint x;\n\t\tif (buf[0] == \'i\') {\n\t\t\tscanf(""%d"", &x);\n\t\t\tss.insert(x);\n\t\t\tvv.push_back(make_pair(\'i\', x));\n\t\t}\n\t\telse if (buf[0] == \'g\') {\n\t\t\tscanf(""%d"", &x);\n\t\t\twhile (!ss.empty() && *ss.begin() < x)\n\t\t\t\tvv.push_back(make_pair(\'r\', 0)), ss.erase(ss.begin());\n\t\t\tif (ss.empty() || *ss.begin() > x)\n\t\t\t\tvv.push_back(make_pair(\'i\', x)), ss.insert(x);\n\t\t\tvv.push_back(make_pair(\'g\', x));\n\t\t}\n\t\telse {\n\t\t\tif (ss.empty())\n\t\t\t\tss.insert(1), vv.push_back(make_pair(\'i\', 1));\n\t\t\tss.erase(ss.begin());\n\t\t\tvv.push_back(make_pair(\'r\', 0));\n\t\t}\n\t}\n\tprintf(""%d\\n"", (int)vv.size());\n\tfor (auto i: vv) {\n\t\tif (i.first == \'i\')\n\t\t\tprintf(""insert %d\\n"", i.second);\n\t\telse if (i.first == \'g\')\n\t\t\tprintf(""getMin %d\\n"", i.second);\n\t\telse\n\t\t\tprintf(""removeMin\\n"");\n\t}\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Heap Operations.json,https://codeforces.com//blog/entry/45425,Let s solve this problem with greedy approach Let s apply operations from log in given order If current operation is then add element to heap If current operation is then if heap is not empty then simply remove minimal element otherwise if heap is empty add operation where can be any number and then apply If current operation is then do follows In order to fit time limit you need to use data structure which allows you to apply given operations in time where is a number of elements in it For example std priority queue or std multiset Code 
https://codeforces.com//contest/1609/problem/G,1205815,G,1609G,1609,G. A Stroll Around the Matrix,William has two arrays of numbers a 1 a 2 dots a n and b 1 b 2 dots b m The arrays satisfy the conditions of being convex Formally an array c of length k is considered convex if c i c i 1 c i 1 c i for all i from 2 to k 1 and c 1 c 2 Throughout William s life he observed q changes of two types happening to the arrays Add the arithmetic progression d d cdot 2 d cdot 3 dots d cdot k to the suffix of the array a of length k The array after the change looks like this a 1 a 2 dots a n k a n k 1 d a n k 2 d cdot 2 dots a n d cdot k The same operation but for array b After each change a matrix d is created from arrays a and b of size n times m where d i j a i b j William wants to get from cell 1 1 to cell n m of this matrix From cell x y he can only move to cells x 1 y and x y 1 The length of a path is calculated as the sum of numbers in cells visited by William including the first and the last cells After each change William wants you to help find out the minimal length of the path he could take ,"['/**\n *    author:  tourist\n *    created: 28.11.2021 18:24:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  auto init_b = b;\n  vector<long long> da(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    da[i] = a[i + 1] - a[i];\n  }\n  vector<long long> db(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    db[i] = b[i + 1] - b[i];\n  }\n  fenwick<int> fenw(m - 1);\n  fenwick<long long> fenw2(m - 1);\n  long long ans = 0;\n  for (int i = 0; i < m - 1; i++) {\n    ans += db[i] * (m - 1 - i);\n  }\n  while (q--) {\n    int type, k, d;\n    cin >> type >> k >> d;\n    if (type == 1) {\n      if (k == n) {\n        a[0] += d;\n        k -= 1;\n      }\n      for (int i = 0; i < k; i++) {\n        a[n - k + i] += d * (i + 1);\n        da[n - k + i - 1] += d;\n      }\n    } else {\n      if (k == m) {\n        b[0] += d;\n        k -= 1;\n      }\n      fenw.modify(m - k - 1, d);\n      fenw2.modify(m - k - 1, ((long long) -d) * (m - k - 2));\n      ans += ((long long) d) * k * (k + 1LL) / 2;\n    }\n    long long res = ans;\n    res += (a[0] + b[0]) * (n + m - 1);\n    for (int i = 0; i < n - 1; i++) {\n      int low = 0, high = m - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        if (db[mid] + fenw.get(mid) > da[i]) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      int my_id = (n - 2 - i) + (m - 1 - low) + 1;\n      res += da[i] * my_id;\n      res += init_b[low] - init_b[0];\n      res += fenw.get(low - 1) * (long long) (low - 1) + fenw2.get(low - 1);\n    }\n    cout << res << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['data structures', 'greedy', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. A Stroll Around the Matrix.json,https://codeforces.com//blog/entry/97350,First of all it should be noted that one iteration of the described algorithm of robots movements can be implemented in time For example using stack Let s consider moments of time that are multiple of And segments of time between such two consecutive moments of time Consider two adjacent robots It can be proved that if these two robots touched each other during a segment of time then they will touch each other during any succeeding segment of time One thing that may change in the future is that the left robot will be blocked from moving to the left or the right robot will be blocked from moving to the right Robots just will become closer to each other after such a change It s also possible that the left robot will be blocked from moving to the right or the right robot from moving to the left But then they are touching Similarly if after seconds distance between two robots decreases then it will continue decreasing until they touch during some segment of time And if two robots touch during a segment of time then the distance between them after this segment of time will be less than or equal to the distance between them before this segment Let s simulate the first seconds and then another seconds Let s look at pairs of adjacent robots If the distance between two robots increased or didn t change skip this pair If the distance between two robots decreased If the distance is then robots may touch during the next segment So let s simulate the next seconds again Otherwise let distance be and it decreased by during the last segment of time Then during the next segments of time it will continue decreasing with the same speed units per seconds So we can skip these segments of time and simulate the next after them Let s choose the minimum segment of time that should be simulated Let s skip all till this segment of time and simulate it Then again choose the minimum segment of time till which we can skip simulation It can be proved that there will be simulated segments of time overall This is due to the fact that there re no more than decreases of the distance between two adjacent robots after which we will do the simulation In order to answer questions let s also simulate segments of time that contain moments of time of questions Total time complexity is 
https://codeforces.com//contest/1174/problem/D,353393,D,1174D,1174,D. Ehab and the Expected XOR Problem,Given two integers n and x construct an array that satisfies the following conditions for any element a i in the array 1 le a i 2 n there is no subsegment with bitwise XOR equal to 0 or x its length l should be maximized A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, x;\nint vis[(1 << 18) + 5];\nint main()\n{\n\tcin >> n >> x;\n\tfor (int i = 0; i < 1 << n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t\tvis[i ^ x] = 1;\n\t}\n\tint lst = 0;\n\tvector<int> vec;\n\tfor (int i = 1; i < 1 << n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tvec.push_back(i ^ lst);\n\t\t\tlst = i;\n\t\t}\n\t}\n\tprintf(""%d\\n"", (int)vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++)\n\t\tprintf(""%d "", vec[i]);\n\tputs("""");\n}']",,,"['bitmasks', 'constructive algorithms']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Ehab and the Expected XOR Problem.json,https://codeforces.com//blog/entry/67388,The main idea is to build the prefix xor of the array not the array itself then build the array from it Let the prefix xor array be called Now Thus the problem becomes construct an array such that no pair of numbers has bitwise xor sum equal to 0 or and its length should be maximal Notice that no pair of numbers has bitwise xor sum equal to 0 simply means you can t use the same number twice If no pair of numbers less than will have bitwise xor sum equal to so you can just use all the numbers from 1 to in any order Otherwise you can think of the numbers forming pairs where each pair consists of 2 numbers with bitwise xor sum equal to From any pair if you add one number to the array you can t add the other However the pairs are independent from each other your choice in one pair doesn t affect any other pair Thus you can just choose either number in any pair and add them in any order you want After you construct you can construct using the formula Code link https pastebin com 0gCLC0BP Time complexity 
https://codeforces.com//contest/418/problem/A,8550,A,418A,418,A. Football,One day at the Russian Code Cup event it was decided to play football as an out of competition event All participants was divided into teams and played several matches two teams could not play against each other more than once The appointed Judge was the most experienced member Pavel But since he was the wisest of all he soon got bored of the game and fell asleep Waking up he discovered that the tournament is over and the teams want to know the results of all the matches Pavel didn t want anyone to discover about him sleeping and not keeping an eye on the results so he decided to recover the results of all games To do this he asked all the teams and learned that the real winner was friendship that is each team beat the other teams exactly times Help Pavel come up with chronology of the tournir that meets all the conditions or otherwise report that there is no such table ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  scanf(""%d %d"", &n, &k);\n  if (k > (n - 1) / 2) {\n    printf(""%d\\n"", -1);\n  } else {\n    printf(""%d\\n"", n * k);\n    for (int i = 1; i <= n; i++)\n      for (int j = 0; j < k; j++) printf(""%d %d\\n"", i, (i + j) % n + 1);\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'graphs', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Football.json,https://codeforces.com//blog/entry/11730,Let s consider this tournir as graph Each vertex should have out degree Then the graph should contain exactly edges But the full graph contains because of that if then the answer is otherwise we will connect the th vertex with taking modulo if needed Solution 6396331 
https://codeforces.com//contest/1799/problem/C,1800599,C,1799C,1799,C. Double Lexicographically Minimum,You are given a string s You can reorder the characters to form a string t Define t mathrm max to be the lexicographical maximum of t and t in reverse order Given s determine the lexicographically minimum value of t mathrm max over all reorderings t of s A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    std::string t(n, \'?\');\n    \n    int cnt[26] {};\n    for (auto c : s) {\n        cnt[c - \'a\']++;\n    }\n    \n    int l = 0, r = n - 1;\n    for (int c = 0; c < 26; c++) {\n        while (cnt[c] >= 2) {\n            cnt[c] -= 2;\n            t[l++] = t[r--] = \'a\' + c;\n        }\n        if (cnt[c] == 1) {\n            cnt[c] -= 1;\n            if (l == r) {\n                t[l] = \'a\' + c;\n            } else {\n                int x = c + 1;\n                while (cnt[x] == 0) {\n                    x++;\n                }\n                if (cnt[x] == r - l) {\n                    while (cnt[x] >= 2) {\n                        cnt[x] -= 2;\n                        t[l++] = t[r--] = \'a\' + x;\n                    }\n                    if (cnt[x] == 1) {\n                        cnt[x] -= 1;\n                        t[l++] = \'a\' + x;\n                    }\n                    t[r] = \'a\' + c;\n                } else {\n                    for (; x < 26; x++) {\n                        while (cnt[x] > 0) {\n                            cnt[x] -= 1;\n                            t[l++] = \'a\' + x;\n                        }\n                    }\n                    t[r] = \'a\' + c;\n                }\n            }\n            break;\n        }\n    }\n    \n    std::cout << t << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['greedy', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Double Lexicographically Minimum.json,https://codeforces.com//blog/entry/113321,Let s iterate all symbols of in order from smallest to largest and construct an answer Let the current symbol be If there are at least remaining symbols equal to we should add them to the current prefix and suffix of and continue If there are at most one other symbol is left there are and times left in we should add symbols symbol and symbols to the prefix of and break Otherwise we should add all remaining symbols of excluding to prefix of in the sorted order and after it symbol Time complexity where 
https://codeforces.com//contest/2003/problem/F,2836632,F,2003F,2003,F. Turtle and Three Sequences,Piggy gives Turtle three sequences a 1 a 2 ldots a n b 1 b 2 ldots b n and c 1 c 2 ldots c n Turtle will choose a subsequence of 1 2 ldots n of length m let it be p 1 p 2 ldots p m The subsequence should satisfy the following conditions a p 1 le a p 2 le cdots le a p m All b p i for all indices i are i e there don t exist two different indices i j such that b p i b p j Help him find the maximum value of sum limits i 1 m c p i or tell him that it is impossible to choose a subsequence of length m that satisfies the conditions above Recall that a sequence a is a subsequence of a sequence b if a can be obtained from b by the deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>#define GO cin.tie(0);cout.tie(0);ios::sync_with_stdio(0);typedef long long ll;using namespace std;template<typename type>struct Fenwick {\xa0  vector<type> fen;  int n;\xa0  Fenwick() {}\xa0  Fenwick(int n) {    init(n);  }\xa0  void init(int n) {    this->n = n;    fen.assign(n + 5, 0);  }\xa0  void upd(int pos, type inc) {    for(; pos <= n ; pos = (pos | (pos + 1))) {      //fen[pos] += inc;      fen[pos] = max(fen[pos],inc);    }  }\xa0  // prefix query  type query(int r) {    type sum = 0;    for(; r >= 0 ; r = (r & (r + 1)) - 1) {      sum = max(sum,fen[r]);    }    return sum;  }\xa0  // range query  type query(int l, int r) {    return query(r) - query(l - 1);  }\xa0  // the array should be ones and zeroes only to find the kth one  int find_kth(type k) {    k--;    int x = 0;    for(int i = 1 << std::__lg(n) ; i > 0 ; i >>= 1){      if(x + i <= n && fen[x + i - 1] <= k) {        x += i;        k -= fen[x - 1];      }    }    return x;  }\xa0};\xa0int main(){    GO    srand(time(0));    int n,m;    cin>>n>>m;    int a[n],b[n],c[n];    for(int i=0;i<n;i++){        cin>>a[i];    }    for(int i=0;i<n;i++){        cin>>b[i];    }    for(int i=0;i<n;i++){        cin>>c[i];    }    int ans = 0;    for(int t=0;t<300;t++){        int d[n],g[n + 1];        for(int i=1;i<=n;i++){            g[i] = rand()%m;        }        for(int i=0;i<n;i++){            d[i] = g[b[i]];        }        Fenwick<int>f[(1<<m)];        for(int i=0;i<(1<<m);i++){            f[i].init(n + 1);        }        for(int i=0;i<n;i++){            for(int j=0;j<(1<<m);j++){                if(!(j&(1<<d[i])))                    continue;                int x = f[(j^(1<<d[i]))].query(a[i]);                if(x || (j^(1<<d[i])) == 0)                    f[j].upd(a[i],x + c[i]);            }        }        ans = max(ans,f[(1<<m) - 1].query(n));    }    if(ans == 0){        cout<<""-1\\n"";    }else{        cout<<ans<<\'\\n\';    }    return 0;}']",,,"['brute force', 'data structures', 'dp', 'greedy', 'math', 'probabilities', 'two pointers']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Turtle and Three Sequences.json,https://codeforces.com/blog/entry/132953,If the number of possible values for is small you can use bitmask DP Define as the maximum result considering all numbers up to where is the current set of distinct values in the subsequence and is the value of for the last element of the subsequence The transitions can be optimized using a Fenwick tree Binary Indexed Tree When has many possible values consider using color coding where each is randomly mapped to a number in and then apply bitmask DP The probability of obtaining the optimal solution in one attempt is and the probability of not obtaining the optimal solution after attempts is When the probability of not obtaining the optimal solution is approximately which is acceptable Time complexity 
https://codeforces.com//contest/1362/problem/B,640963,B,1362B,1362,B. Johnny and His Hobbies,Among Johnny s numerous hobbies there are two seemingly harmless ones applying bitwise operations and sneaking into his dad s office As it is usually the case with small children Johnny is unaware that combining these two activities can get him in a lot of trouble There is a set S containing very important numbers on his dad s desk The minute Johnny heard about it he decided that it s a good idea to choose a integer k and replace each element s of the set S with s oplus k oplus denotes the exclusive or operation Help him choose such k that Johnny s dad will not see any difference after his son is done playing i e Johnny will get the same set as before playing It is possible that no such number exists It is also possible that there are many of them In such a case output the smallest one Note that the order of elements in a set doesn t matter i e set 1 2 3 equals to set 2 1 3 Formally find the smallest positive integer k such that s oplus k s in S S or report that there is no such number For example if S 1 3 4 and k 2 new set will be equal to 3 1 6 If S 0 1 2 3 and k 1 after playing set will stay the same ,"[""#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint t; cin >> t;\n\n\twhile (t--) {\n\t\tint n; cin >> n;\n\t\tvector<int> nums(n);\n\t\tset<int> S;\n\t\tfor (auto &x : nums) { cin >> x; S.insert(x); }\n\n\t\tint ans = -1;\n\t\tfor (int k = 1; k < 1024; k++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (S.count(nums[i] ^ k) == 0) { OK = false; break; }\n\t\t\t}\n\t\t\tif (OK) { ans = k; break; }\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n}""]",,,"['bitmasks', 'brute force']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Johnny and His Hobbies.json,https://codeforces.com//blog/entry/78355,Consider th least significant bit indexed If it is set in but not in it will be set in Hence Consider such minimal positive integer that holds for all cannot have the th bit set for any From this follows that So there are only feasible choices of We can verify if a number satisfies the condition from the statement in operations This gives us a solution with complexity Note that in all tests is at most There is also another solution possible It uses the observation that if satisfies the required conditions then for every there exists such that This gives us feasible choices of and thus the complexity of this solution is 
https://codeforces.com//contest/1384/problem/B1,681334,B1,1384B1,1384,B1. Koa and the Beach  Easy Version ,Koa the Koala is at the beach The beach consists from left to right of a shore n 1 meters of sea and an island at n 1 meters from the shore She measured the depth of the sea at 1 2 dots n meters from the shore and saved them in array d d i denotes the depth of the sea at i meters from the shore for 1 le i le n Like any beach this one has tide the intensity of the tide is measured by parameter k and affects all depths in the following way For a total of k seconds each second tide all depths by 1 Then for a total of k seconds each second tide all depths by 1 This process repeats again and again ie depths increase for k seconds then decrease for k seconds and so on Formally let s define 0 indexed array p 0 1 2 ldots k 2 k 1 k k 1 k 2 ldots 2 1 of length 2k At time t 0 le t depth at i meters from the shore equals d i p t bmod 2k t bmod 2k denotes the remainder of the division of t by 2k Note that the changes occur after each second see the notes for better understanding At time t 0 Koa is standing at the shore and wants to get to the island Suppose that at some time t 0 le t she is at x 0 le x le n meters from the shore In one second Koa can swim 1 meter further from the shore x changes to x 1 or not swim at all x stays the same in both cases t changes to t 1 As Koa is a bad swimmer the depth of the sea at the point where she is can t exceed l at integer points of time or she will drown More formally if Koa is at x 1 le x le n meters from the shore at the moment t for some integer t ge 0 the depth of the sea at this point d x p t bmod 2k can t exceed l In other words d x p t bmod 2k le l must hold always Once Koa reaches the island at n 1 meters from the shore she stops and can rest Note that ie she can t drown while swimming Note that and they are solid ground and she won t drown there Koa wants to know whether she can go from the shore to the island Help her ,"['#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n#define m_k make_pair\nusing namespace std;\nconst int N=3*1e5+100;\nint t,n,k,l,a[N],b[N],st;\nsigned main()\n{\n\tscanf(""%d"",&t);\n\twhile (t--)\n\t{\n\t\tscanf(""%d%d%d"",&n,&k,&l);\n\t\tfor (int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n\t\tfor (int i=1;i<=n;i++) b[i]=min(k,l-a[i]);\n\t\tbool bl=1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (b[i]<0)\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bl)\n\t\t{\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tst=b[1];\n\t\tint add;\n\t\tif (st==0) add=1;\n\t\telse add=-1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (st>b[i])\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i==n) break;\n\t\t\tif (b[i]==k) st=b[i+1]+1,add=-1;\n\t\t\telse if (add==-1 && st-1>b[i+1]) st=b[i+1]+1;\n\t\t\tst+=add;\n\t\t\tif (st==0) add=1;\n\t\t\tif (st==k) add=-1;\n\t\t}\n\t\tif (bl) printf(""Yes\\n"");\n\t\telse printf(""No\\n"");\n\t}\n}\n']",,,"['brute force', 'dp', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B1. Koa and the Beach  Easy Version .json,https://codeforces.com//blog/entry/80562,For this version you can just simulate each possible action of Koa Let a state where is the current position of Koa ie is the shore from to is the th meter of sea and is the island is the current increment of the tide and is a boolean that is true if the tide is decreasing and false otherwise You can see each state like a node and each action ie wait or swim like an edge so you can just do a dfs to see if the island is reachable from the shore The number of nodes and edges is Time complexity per testcase 
https://codeforces.com//contest/1535/problem/C,1005284,C,1535C,1535,C. Unstable String,You are given a string s consisting of the characters and Let s call a string if it consists of the characters and and any two adjacent characters are different i e it has the form or Let s call a string if it consists of the characters and and you can replace the characters to or for each character the choice is independent so that the string becomes For example the strings and are beautiful and the strings and are not Calculate the number of beautiful contiguous substrings of the string s ,"[""#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    string s;\n    cin >> s;\n    int N = s.size();\n    vector<vector<int>> a(3);\n    for (int j = 0; j < 3; j++){\n      a[j].push_back(-1);\n    }\n    for (int j = 0; j < N; j++){\n      if (s[j] != '?'){\n        a[2].push_back(j);\n        int d = s[j] - '0';\n        int p = (d + j) % 2;\n        a[p].push_back(j);\n      }\n    }\n    for (int j = 0; j < 3; j++){\n      a[j].push_back(N);\n    }\n    vector<long long> S(3, 0);\n    for (int j = 0; j < 3; j++){\n      int cnt = a[j].size();\n      for (int k = 0; k < cnt - 1; k++){\n        long long d = a[j][k + 1] - a[j][k];\n        S[j] += d * (d - 1) / 2;\n      }\n    }\n    cout << S[0] + S[1] - S[2] << endl;\n  }\n}""]",,,"['binary search', 'dp', 'greedy', 'implementation', 'strings', 'two pointers']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Unstable String.json,https://codeforces.com//blog/entry/91481,Let s find a simple condition when the string is not beautiful A string is not beautiful if there are two characters or two characters at an odd distance or and at an even distance because in this case the string cannot be made unstable Iterate over the right border of the substring Let be the maximum index such that the substring is not beautiful or if the substring is beautiful Then we have to add to the answer since any substring of a beautiful string is also beautiful Denote as the last occurrence of or at the position of parity Let is the parity of then i e find the nearest character that breaks a beautiful substring at an odd distance or at an even distance The case for is similar If then we can choose what this character will be Obviously we need to choose the option with the smaller value of 
https://codeforces.com//contest/1076/problem/G,253931,G,1076G,1076,G. Array Game,Consider a following game between two players There is an array b 1 b 2 b k consisting of positive integers Initially a chip is placed into the first cell of the array and b 1 is decreased by 1 Players move in turns Each turn the current player has to do the following if the index of the cell where the chip is currently placed is x then he or she has to choose an index y in x min k x m such that b y 0 move the chip to the cell y and decrease b y by 1 If it s impossible to make a valid move the current player loses the game Your task is the following you are given an array a consisting of n positive integers and q queries to it There are two types of queries 1 l r d for every i in l r increase a i by d 2 l r tell who is the winner of the game that is played on the subarray of a from index l to index r inclusive Assume both players choose an optimal strategy ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int P = 400;\nconst int G = 600;\nconst int N = 2e5 + 7;\n\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint n, m, q;\nint cur[N];\n\nint p;\nint idx[N];\nint clicked[G];\nint group[G][6][2];\n\nint simulate(int l, int r, bool c){\n\twhile(r >= l){\n\t\tif(cur[r] ^ c)\n\t\t\tr -= m + 1;\n\t\telse\n\t\t\t--r;\n\t}\n\n\treturn l - r - 1;\n}\n\nvoid build(int nr){\n\tint from = max(nr * P - P, 1), to = min(nr * P, n + 1);\n\tfor(int i = from; i < to; ++i)\n\t\tcur[i] ^= clicked[nr];\n\tclicked[nr] = false;\n\t\n\tfor(int i = 0; i <= m; ++i){\n\t\tgroup[nr][i][0] = simulate(from, to - i - 1, 0);\n\t\tgroup[nr][i][1] = simulate(from, to - i - 1, 1);\n\t}\n}\n\nvoid change(int l, int r){\n\tif(idx[l] == idx[r]){\n\t\tfor(int i = l; i <= r; ++i)\n\t\t\tcur[i] ^= 1;\n\n\t\tbuild(idx[l]);\n\t\treturn;\n\t}\n\t\n\tfor(int i = idx[l] + 1; i < idx[r]; ++i)\n\t\tclicked[i] ^= 1;\n\t\n\tfor(int i = l; i < idx[l] * P; ++i)\n\t\tcur[i] ^= 1;\n\tbuild(idx[l]);\n\t\n\tfor(int i = idx[r] * P - P; i <= r; ++i)\n\t\tcur[i] ^= 1;\n\tbuild(idx[r]);\n}\n\nint ask(int l, int r){\n\tif(cur[l] == clicked[idx[l]])\n\t\treturn 1;\n\t\n\tif(idx[l] == idx[r]){\n\t\tint t = simulate(l + 1, r, clicked[idx[l]]);\n\t\treturn t == 0 ? 2 : 1;\n\t}\n\n\tint t = simulate(idx[r] * P - P, r, clicked[idx[r]]);\n\tint curN = idx[r] - 1;\n\t\n\twhile(curN > idx[l]){\n\t\tt = group[curN][t][clicked[curN]];\n\t\t--curN;\n\t}\n\t\n\tt = simulate(l + 1, idx[l] * P - t - 1, clicked[idx[l]]);\n\treturn t == 0 ? 2 : 1;\n}\n\nint main(){\n\tscanf(""%d %d %d"", &n, &m, &q);\n\tfor(int i = 1; i <= n; ++i){\n\t\tLL a;\n\t\tscanf(""%lld"", &a);\n\t\tcur[i] = a % 2;\n\t}\n\t\n\tfor(int i = 1; i <= n; ++i)\n\t\tidx[i] = i / P + 1;\n\t\n\tp = idx[n];\n\tfor(int i = 1; i <= p; ++i)\n\t\tbuild(i);\n\t\n\twhile(q--){\n\t\tint t, l, r;\n\t\tscanf(""%d %d %d"", &t, &l, &r);\n\t\t\n\t\tif(t == 1){\n\t\t\tLL v;\n\t\t\tscanf(""%lld"", &v);\n\n\t\t\tif(v % 2 == 1)\n\t\t\t\tchange(l, r);\n\t\t}\n\t\telse\n\t\t\tprintf(""%d\\n"", ask(l, r));\n\t}\n\n\treturn 0;\n}\n']",,,"['data structures', 'games']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Array Game.json,https://codeforces.com/blog/entry/63151,Suppose there is only one query i e we are given some array and we want to know who is the winner if the game is played on this array One of the obvious solutions is will the current player win if the chip is currently in the cell and the number in cell is We can already see that we don t need to know the exact value of we only want to know whether it s odd if there is a cell such that we can go from to and is a state where current player will lose then we should go to this cell since our opponent will enter a losing state of the game Otherwise we want to force our opponent to move out of cell and we can do so only if is odd So we found a dynamic programming solution with states but what is more important is that we can take all the elements in our array modulo Okay now let s solve the problem when there are only queries of type no modifications Since when calculating the values we are interested only in next cells and there are only variants of whether these cells are winning or losing we may consider each element of the array as a function that maps a mask of next states into a new mask of states if we pushed our new element into the front For example if the th element is even and states are winning losing losing winning and losing respectively and then we may consider a mask of next states as and then we can check if th state is winning and push a bit to the front of this mask discarding the last bit since new state is winning we will get a mask of It allows us to denote two functions and what will be the resulting mask of next states if current mask is and we push an even or odd element to the front Okay what about pushing more than one element We can just take the composition of their functions Since a function can be stored as an array of integers and the composition needs only time to be calculated then we can build a segment tree over the elements of the array and store a composition of all functions on the segment in each node This allows us to answer queries of type in The only thing that s left is additions on segment Adding an even number is easy just ignore this query To be able an odd number let s store another function in each node of the segment tree which would be the composition of all functions on the segment if we would add to all elements on the segment so the elements which were odd become even and vice versa This allows us to use lazy propagation if the query affects the whole node we may just swap two functions in it and push the query to the children of this node Overall complexity is It turns out we didn t think about it before the contest but some contestants submitted such solutions that it can be reduced to if we will use the distance to closest losing state instead of a mask of winning and losing states 
https://codeforces.com//contest/839/problem/A,117992,A,839A,839,A. Arya and Bran,Bran and his older sister Arya are from the same house Bran like candies so much so Arya is going to give him some Candies At first Arya and Bran have Candies There are days at the th day Arya finds candies in a box that is given by the Many Faced God Every day she can give Bran of her candies If she don t give him the candies at the same day they are saved for her and she can give them to him later Your task is to find the minimum number of days Arya needs to give Bran candies the end of the th day Formally you need to output the minimum day index to the end of which candies will be given out the days are indexed from 1 to Print if she can t give him candies during given days ,"['#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nint n;\n\nlong long k;\nlong long zap;\n\nint main()\n{\n    scanf(""%d%lld"", &n, &k);\n    for (int i=1; i<=n; i++)\n    {\n        long long x;\n        scanf(""%lld"", &x);\n        zap+=x;\n        x=min(zap, 8LL);\n        zap-=x;\n        k-=x;\n        if (k<=0)\n        {\n            printf(""%d\\n"", i);\n            return 0;\n        }\n    }\n    printf(""-1\\n"");\n    return 0;\n}\n']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Arya and Bran.json,https://codeforces.com//blog/entry/53815,Let be number of her candies At th day we increase by then we give Bran So we decrease from this value We will print the answer once becomes smaller or equal to Or we will print if it does n happen after days 
https://codeforces.com//contest/1569/problem/D,1103182,D,1569D,1569,D. Inconvenient Pairs,There is a city that can be represented as a square grid with corner points in 0 0 and 10 6 10 6 The city has n vertical and m horizontal streets that goes across the whole city i e the i th vertical streets goes from x i 0 to x i 10 6 and the j th horizontal street goes from 0 y j to 10 6 y j All streets are bidirectional Borders of the city are streets as well There are k persons staying the p th person at point x p y p so either x p equal to some x i or y p equal to some y j or both Let s say that a pair of persons form an if the shortest path from one person to another going only by streets is than the Manhattan distance between them Calculate the number of inconvenient pairs of persons pairs x y and y x are the same pair Let s recall that Manhattan distance between points x 1 y 1 and x 2 y 2 is x 1 x 2 y 1 y 2 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\n\nvoid solve() {\n    int N, M, K; cin >> N >> M >> K;\n    set<int> st[2];\n    F0R(i, N) {\n        int X; cin >> X; st[0].ins(X);\n    }\n    F0R(i, M) {\n        int X; cin >> X; st[1].ins(X);\n    }\n\n    map<int, int> cnt[2];\n    map<pi, int> cnt2[2];\n    st[0].ins(-1); st[1].ins(-1);\n    F0R(i, K) {\n        int X, Y; cin >> X >> Y;\n        if (!st[0].count(X)) {\n            auto it = --(st[0].lb(X));\n            cnt[0][*it]++;\n            cnt2[0][{*it, Y}]++;\n        }\n        if (!st[1].count(Y)) {\n            auto it = --(st[1].lb(Y));\n            cnt[1][*it]++;\n            cnt2[1][{*it, X}]++;\n        }\n    }\n    ll ans = 0;\n    F0R(i, 2) {\n        trav(a, cnt[i]) {\n            ll cur = a.s; ans += cur * (cur - 1) / 2;\n            //dbg(i, a.f, a.s);\n        }\n        trav(a, cnt2[i]) {\n            ll cur = a.s; ans -= cur * (cur - 1) / 2;\n        }\n    }\n    cout << ans << nl;\n\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']",,,"['binary search', 'data structures', 'implementation', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Inconvenient Pairs.json,https://codeforces.com//blog/entry/94721,Firstly let s look at some point Let s find closest to it vertical and horizontal lines We will name the closest vertical lines from left and right as and and and as closest horizontal lines So and we can also note that either or Now let s note that if for some other point either or then to reach from we must go reach either or or or so the shortest distance will be strictly greater than the Manhattan distance If neither nor then we can show that it s always possible to find the shortest path equal to the Manhattan distance As a result for each point we should find the number of points such that and or The exception here is when lies on the same line as so we should not count such points We can note that since either or there is no such point that and simultaneously so we can calculate the pairs by and coordinates independently Let s focus on coordinates to calculate for coordinates we can just swap all coordinates Let s sort all points by coordinate To get rid of the case when points and lies on the same vertical street we can group them by coordinate and process by group since we sorted by groups are just segments There are no problems with the case when points lie on the same horizontal street since then and there are no other with If we store for each horizontal line the number of point inside the interval then when we need for point calculate the number of points with and we can just ask for value assigned to because and are consecutive elements in the array So we go through each group two times first collecting answer then updating values in appropriate s Note that we can calculate and with binary search using built in functions The resulting complexity is 
https://codeforces.com//contest/687/problem/E,63914,E,687E,687,E. TOF,Today Pari gave Arya a cool graph problem Arya wrote a non optimal solution for it because he believes in his ability to optimize non optimal solutions In addition to being non optimal his code was buggy and he tried a lot to optimize it so the code also became dirty He keeps getting Time Limit Exceeds and he is disappointed Suddenly a bright idea came to his mind Here is how his dirty code looks like dfs v set count v count v 1 if count v 1000 foreach u in neighbors v if visited u is equal to false dfs u break set visited v true main input the digraph TOF foreach 1 i n set count i 0 visited i false foreach 1 v n if visited v is equal to false dfs v And do something cool and magical but we can t tell you what He asks you to write the function in order to optimize the running time of the code with minimizing the number of calls of the function The input is a directed graph and in the function you have to rearrange the edges of the graph in the list for each vertex The number of calls of function depends on the arrangement of of each vertex ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <queue>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=5010;\nint dfn[N],low[N],ins[N],st[N],bel[N],dis[N],vis[N];\nint ind,top,n,m,u,v,cnt,maxc;\nVI vec[N],e[N],f[N];\nqueue<int> q;\nvector<PII> E;\nvoid tarjan(int u) {\n\tdfn[u]=low[u]=++ind;\n\tins[u]=1;\n\tst[++top]=u;\n\trep(i,0,SZ(e[u])) {\n\t\tint v=e[u][i];\n\t\tif (!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);\n\t\telse if (ins[v]) low[u]=min(low[u],low[v]);\n\t} \n\tif (dfn[u]==low[u]) {\n\t\t++cnt;\n\t\twhile (1) {\n\t\t\tbel[st[top]]=cnt;\n\t\t\tvec[cnt].pb(st[top]);\n\t\t\tins[st[top]]=0;\n\t\t\tif (st[top--]==u) break;\n\t\t}\n\t}\n}\n\nvoid find(int u) {\n\trep(i,1,n+1) vis[i]=0,dis[i]=n+1;\n\tvis[u]=1; q.push(u); dis[u]=0;\n\twhile (!q.empty()) {\n\t\tint v=q.front(); q.pop();\n\t\tfor (auto w:e[v]) if (!vis[w]) {\n\t\t\tvis[w]=1; dis[w]=dis[v]+1;\n\t\t\tq.push(w);\n\t\t} \n\t}\n//\tprintf(""%d\\n"",u);\n//\trep(i,1,n+1) printf(""%d %d\\n"",i,dis[i]);\n\trep(i,1,n+1) for (auto v:e[i]) if (v==u) {\n\t\tmaxc=min(maxc,dis[i]+1);\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v);\n\t\tE.pb(mp(u,v));\n\t}\n\trep(i,1,n+1) if (!dfn[i]) tarjan(i);\n\trep(i,0,m) {\n\t\tint u=E[i].fi,v=E[i].se;\n\t\tif (bel[u]!=bel[v]) {\n\t\t\tf[bel[u]].pb(bel[v]);\n\t\t}\n\t}\n\tint ret=n;\n\trep(i,1,cnt+1) if (SZ(f[i])==0) {\n\t\tif (SZ(vec[i])==1) continue;\n\t\tmaxc=n;\n\t\tfor (auto u:vec[i]) find(u);\n\t\tret+=998*maxc+1;\n\t}\n\tprintf(""%d\\n"",ret);\n}\n']",,,"['dfs and similar', 'graphs']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. TOF.json,https://codeforces.com//blog/entry/45770,Hint What the actual problem is Looking at the code in the statement you can see only the first edge in neighbors of each node is important So for each vertex with at least one outgoing edge you have to choose one edge and ignore the others After this the graph becomes in the shape of some cycles with possible branches and some paths The number of dfs calls equals to 998 sum of sizes of cycles n number of cycles Solution The goal is to minimize the sum of cycle sizes Or to maximize the number of vertices which are not in any cycle Name them good vertices If there exists a vertex v without any outgoing edge we can make all of the vertices that v is reachable from them good Consider the dfs tree from v in the reverse graph You can choose the edge from this tree as the first edge in neighbors u in order to make all of these vertices good Vertices which are not in the sink strongly connected components could become good too by choosing the edges from a path starting from them and ending in a sink strongly connected component In a sink strongly connected component there exists a path from every vertex to others So we can make every vertex good except a single cycle by choosing the edges in the paths from other nodes to this cycle and the cycle edges So every vertices could become good except a single cycle in every sink strongly connected component And the length of those cycles must be minimized so we can choose the smallest cycle in every sink strongly connected component and make every other vertices good Finding the smallest cycle in a graph with n vertex and m edges could be done in O n n m with running a BFS from every vertex so finding the smallest cycle in every sink strongly connected component is O n n m overall 
https://codeforces.com//contest/1006/problem/B,198026,B,1006B,1006,B. Polycarp's Practice,Polycarp is practicing his problem solving skill He has a list of n problems with difficulties a 1 a 2 dots a n respectively His plan is to practice for exactly k days Each day he has to solve at least one problem from his list Polycarp solves the problems in the order they are given in his list he cannot skip any problem from his list He has to solve all n problems in exactly k days Thus each day Polycarp solves a contiguous sequence of consecutive problems from the start of the list He can t skip problems or solve them multiple times As a result in k days he will solve all the n problems The of the j th day of Polycarp s practice is the maximum among all the difficulties of problems Polycarp solves during the j th day i e if he solves problems with indices from l to r during a day then the of the day is max limits l le i le r a i The of his practice is the sum of the over all k days of his practice You want to help Polycarp to get the maximum possible over all valid ways to solve problems Your task is to distribute all n problems between k days satisfying the conditions above in such a way that the is maximum For example if n 8 k 3 and a 5 4 2 6 5 1 9 2 one of the possible distributions with maximum is 5 4 2 6 5 1 9 2 Here the equals 5 6 9 20 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e3;\n\nint n, k;\npair<int, int> a[MAX_N + 1];\n\nint main() {\n\t//freopen(""input.inp"", ""r"", stdin);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + 1 + n, greater<pair<int, int> >());\n\tvector<int> v;\n\tv.push_back(0);\n\tint profit = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tv.push_back(a[i].second);\n\t\tprofit += a[i].first;\n\t}\n\tsort(v.begin(), v.end());\n\tcout << profit << \'\\n\';\n\tfor (int i = 1; i < v.size() - 1; ++i) {\n\t\tcout << v[i] - v[i - 1] << \' \';\n\t\tn -= v[i] - v[i - 1];\n\t}\n\tcout << n;\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Polycarp's Practice.json,https://codeforces.com//blog/entry/60672,The maximum possible you can obtain is the sum of the largest values of the given array This is obvious because we can always separate these maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array I suggest the following extract largest values of the given array and place a separator right after each of them except the rightmost one Overall complexity is 
https://codeforces.com//contest/1339/problem/B,590527,B,1339B,1339,B. Sorted Adjacent Differences,You have array of n numbers a 1 a 2 ldots a n Rearrange these numbers to satisfy a 1 a 2 le a 2 a 3 le ldots le a n 1 a n where x denotes absolute value of x It s always possible to find such rearrangement Note that all numbers in a are not necessarily different In other words some numbers of a may be same You have to answer independent t test cases ,"['\ufeff#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Loop() {\n\t\tUL N; cin >> N;\n\t\tvector<int> A(N); rep(i, N) cin >> A[i];\n\t\tsort(A.begin(), A.end());\n\t\tint p = 0, q = N - 1;\n\t\tvector<int> ans;\n\t\twhile (p <= q) {\n\t\t\tans.push_back(A[p]);\n\t\t\tif (p < q) ans.push_back(A[q]);\n\t\t\tp++; q--;\n\t\t}\n\t\treverse(ans.begin(), ans.end());\n\t\trep(i, N) {\n\t\t\tif (i) cout << "" "";\n\t\t\tcout << ans[i];\n\t\t} cout << endl;\n\t}\n\n\tvoid Solve() {\n\t\tUL Q; cin >> Q;\n\t\trep(i, Q) {\n\t\t\tLoop();\n\t\t}\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n']",,,"['constructive algorithms', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Sorted Adjacent Differences.json,https://codeforces.com//blog/entry/75913,Sort the list and make an oscillation centered on middle element like picture below In this way you will always achieve to make for all Time complexity is 
https://codeforces.com//contest/871/problem/A,128426,A,871A,871,A. Maximum splitting,You are given several queries In the th query you are given a single positive integer You are to represent as a sum of maximum possible number of composite summands and print this maximum number or print if there are no such splittings An integer greater than is composite if it is not prime i e if it has positive divisors not equal to and the integer itself ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << \' \';\\\n    cerr << \'\\n\'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nint solve(int x) {\n    if (x % 2 == 0) {\n        if (x == 2) return -1;\n        else return x / 4;\n    }\n    if (x < 9) return -1;\n    int y = solve(x - 9);\n    if (y == -1) return -1;\n    else return 1 + y;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); \n    srand((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());\n    int q;\n    cin >> q;\n    while (q--) {\n        int x;\n        cin >> x;\n        cout << solve(x) << \'\\n\';\n    }\n}\n']",,,"['dp', 'greedy', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Maximum splitting.json,https://codeforces.com//blog/entry/55200,Note that minimal composite number is equal to 4 So it is quite logical that there will be a lot of 4 in splitting of big numbers Let s write for small numbers 1 M n dpn number of composite summands in splitting of n If our query n is small number let s print dpn Else let s find minimal number k such that n 4 k is small number Then print k dpn 4 k We can find dpn in O M2 or any other reasonable complexity We even can find all dpn by hands if we set M to 15 or something like that it will be proved later that 15 is enough So now we have right solution but it is not obvious why this solution works Proof not very beautiful but such thoughts can lead to correct solution Let s find answer for all numbers from 1 to 15 Several observations 1 Only 4 6 9 occurs in optimal splittings 2 It is not beneficial to use 6 or 9 more than once because 6 6 4 4 4 9 9 6 6 6 3 12 13 14 15 have valid splittings Let s prove that all numbers that are greater than 15 will have 4 in optimal splitting Let s guess that it is incorrect If minimal number in splitting is neither 4 nor 6 nor 9 than this number will have some non trivial splitting by induction If this number either 6 or 9 and we will decrease query by this number then we will sooner or later get some small number which is less or equal than 15 There is no splitting of small numbers or it contains 4 in splitting and it contradicts with minimality of the first number or it contains 6 and 9 So we have contradiction in all cases We can subtract 4 from any big query and our solution is correct 
https://codeforces.com//contest/991/problem/C,192852,C,991C,991,C. Candies,After passing a test Vasya got himself a box of n candies He decided to eat an equal amount of candies each morning until there are no more candies However Petya also noticed the box and decided to get some candies for himself This means the process of eating candies is the following in the beginning Vasya chooses a single integer k same for all days After that in the morning he eats k candies from the box if there are less than k candies in the box he eats them all then in the evening Petya eats 10 ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tll n;\n\tcin >> n;\n\tll lo = 1, hi = 2e18;\n\twhile (lo < hi) {\n\t\tll mid = lo + hi >> 1;\n\t\tll tmp = n;\n\t\tll x = 0, y = 0;\n\t\twhile (tmp) {\n\t\t\tx += min(mid, tmp);\n\t\t\ttmp -= min(mid, tmp);\n\t\t\ty += tmp / 10;\n\t\t\ttmp -= tmp / 10;\n\t\t}\n\t\t//cout << mid << ' ' << x << ' ' << y << endl;\n\t\tif (x >= y) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tcout << lo << endl;\n\treturn 0;\n}""]",,,"['binary search', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Candies.json,https://codeforces.com/blog/entry/60181,EditorialIt is easy to check that if for some value the necessary condition is met Vasya eats at least half of the candies then it is met for each integer greater ProofLet s consider the number of candies remaining at the evening of each day for some selected let candies remain at day If Vasya will use another number we will have less candies in the first day So Petya will eat no more candies than in the first case for but in the next day the number of candies will be not greater than in the first case if then The same way including that at the evening of the second day we get and so on In general for each we have so Petya will eat not more candies than in the first case in total It means that Vasya will eat not less candies than in the first case So this problem can be solved using the binary search answer approach In order to check whether selected is applicable it necessary just to implement the process described in the problem statement Since Petya eats of candies its amount decreases exponentially so there will be only few days before all the candies will be eaten In the worst case it is necessary 378 days Formally the complexity of the solution is Like in the previous problem it is recommended to avoid floating operations and to use only integer types 
https://codeforces.com//contest/1761/problem/G,1651708,G,1761G,1761,G. Centroid Guess, There is an unknown tree consisting of n nodes which has centroid You only know n at first and your task is to find the centroid of the tree You can ask the distance between any two vertices for at most 2 cdot10 5 times Note that the interactor is adaptive That is the tree is fixed in each test beforehand and does not depend on your queries A vertex is called a centroid if its removal splits the tree into subtrees with at most lfloor frac n 2 rfloor vertices each ,"['//DUEL\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#pragma GCC optimize(""unroll-loops"")\n#define shandom_ruffle(a, b) shuffle(a, b, rng)\n#define vi vector<int>\n#define vl vector<ll>\n#define popcnt __builtin_popcountll\n#define all(a) begin(a),end(a)\n//for kactl\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nusing ll=long long;\nusing ull=unsigned long long;\nusing ld=long double;\nint MOD=1000000007;\nint MOD2=998244353;\nvector<int> bases;\nconst ll LLINF=1ll<<60;\nconst char en=\'\\n\';\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid yes() {cout<<""YES""<<en; exit(0);}\nvoid no() {cout<<""NO""<<en; exit(0);}\ninline int rund() {int x576363482791fuweh=rng();return abs(x576363482791fuweh)%RAND_MAX;}\ntemplate<class T>\nvoid prVec(vector<T> w,bool fl=false)\n{\n\tcout<<w.size()<<en;\n\tfor (int i=0;i<int(w.size())-1;++i) cout<<w[i]<<\' \';\n\tif (w.size()) cout<<w[w.size()-1]<<en;\n\tif (fl) cout<<flush;\n}\n\nvoid M998()\n{\n\tswap(MOD,MOD2);\n}\n\nll raand()\n{\n\tll a=rund();\n\ta*=RAND_MAX;\n\ta+=rund();\n    return a;\n}\n\n#define rand raand\n\nll raaand()\n{\n\treturn raand()*(MOD-7)+raand();\n}\n\ntemplate<class T>\nvi compress(vector<T>&v)\n{\n\tset<T> s;\n\tfor (auto a: v) s.insert(a);\n\tvector<T> o(all(s));\n\tvi nv;\n\tfor (int i=0;i<(int)v.size();++i) nv.pb(lower_bound(all(o),v[i])-o.begin());\n\treturn nv;\n}\n\nstring to_upper(string a)\n{\n\tfor (int i=0;i<(int)a.size();++i) if (a[i]>=\'a\' && a[i]<=\'z\') a[i]-=\'a\'-\'A\';\n\treturn a;\n}\n\nstring to_lower(string a)\n{\n\tfor (int i=0;i<(int)a.size();++i) if (a[i]>=\'A\' && a[i]<=\'Z\') a[i]+=\'a\'-\'A\';\n\treturn a;\n}\n\nll sti(string a,int base=10)\n{\n\tll k=0;\n\tfor (int i=0;i<(int)a.size();++i)\n\t{\n\t\tk*=base;\n\t\tk+=a[i]-\'0\';\n\t}\n\treturn k;\n}\n\ntemplate<class T>\nvoid eras(vector<T>& a,T b)\n{\n\ta.erase(find(a.begin(),a.end(),b));\n}\n\nstring its(ll k,int base=10)\n{\n\tif (k==0) return ""0"";\n\tstring a;\n\twhile (k)\n\t{\n\t\ta.push_back((k%base)+\'0\');\n\t\tk/=base;\n\t}\n\treverse(a.begin(),a.end());\n\treturn a;\n}\n\nll min(ll a,int b)\n{\n\tif (a<b) return a;\n\treturn b;\n}\n\nll min(int a,ll b)\n{\n\tif (a<b) return a;\n\treturn b;\n}\n\nll max(ll a,int b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nll max(int a,ll b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nll gcd(ll a,ll b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b)\n{\n\treturn a/gcd(a,b)*b;\n}\n\ntemplate<class T,class K>\npair<T,K> mp(T a,K b)\n{\n\treturn make_pair(a,b);\n}\n\ninline int mult(ll a,ll b)\n{\n\treturn (a*b)%MOD;\n}\n\ninline int pot(int n,int k)\n{\n\tif (k==0) return 1;\n\tll a=pot(n,k/2);\n\ta=mult(a,a);\n\tif (k%2) return mult(a,n);\n\telse return a;\n}\n\nint divide(int a,int b)\n{\n\treturn mult(a,pot(b,MOD-2));\n}\n\ninline int sub(int a,int b)\n{\n\tif (a-b>=0) return a-b;\n\treturn a-b+MOD;\n}\n\ninline int add(int a,int b)\n{\n\tif (a+b>=MOD) return a+b-MOD;\n\treturn a+b;\n}\n\nvoid ad(int&a,int b)\n{\n\ta+=b;\n\tif (a>=MOD) a-=MOD;\n}\n\nvoid su(int&a,int b)\n{\n\ta-=b;\n\tif (a<0) a+=MOD;\n}\n\nbool prime(ll a)\n{\n\tif (a==1) return 0;\n\tfor (int i=2;i<=round(sqrt(a));++i)\n\t{\n\t\tif (a%i==0) return 0;\n\t}\n\treturn 1;\n}\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nconst int N=75010,KO=20,OT=350;\nint remq=199900;\nint n,de[N],cn[N],cn2[N];\nmap<pii,int> bi;\n\nint dis(int u,int v)\n{\n\tif (u==v) return 0;\n\tif (bi[{u,v}]) return bi[{u,v}];\n\t--remq;\n\tcout<<""? ""<<u<<\' \'<<v<<endl;\n\tint x;\n\tcin>>x;\n\tbi[{u,v}]=bi[{v,u}]=x;\n\treturn x;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor (int i=0;i<10;++i) bases.push_back(rand()%(MOD-13893829*2)+13893829);\n\tcin>>n;\n\tint ro=rand()%n+1;\n\tfor (int i=1;i<=n;++i) de[i]=dis(ro,i);\n\tvector<pii> po;\n\tfor (int i=0;i<KO;++i)\n\t{\n\t\tvi od;\n\t\tint no=rand()%n+1;\n\t\tfor (int j=0;j<OT;++j)\n\t\t{\n\t\t\tint dr=rand()%n+1;\n\t\t\tod.pb((de[no]+de[dr]-dis(no,dr))/2);\n\t\t}\n\t\tsort(all(od));\n\t\tpo.pb({od[OT/2],no});\n\t}\n\tsort(all(po));\n\treverse(all(po));\n\tint poc=po[0].y;\n\tfor (int i=1;i<=n;++i) ++cn[(de[poc]+de[i]-dis(poc,i))/2];\n\tfor (int i=n-1;i>=0;--i) cn[i]+=cn[i+1];\n\tfor (int i=n;i>=0;--i) if (cn[i]>n/2)\n\t{\n\t\tif (remq>=n-cn[i+1])\n\t\t{\n\t\t\tfor (int u=1;u<KO;++u)\n\t\t\t{\n\t\t\t\tint cno=po[u].y;\n\t\t\t\tint ndu=(de[poc]+de[cno]-dis(poc,cno))/2;\n\t\t\t\tif (ndu==i)\n\t\t\t\t{\n\t\t\t\t\tcn2[i]=cn[i+1];\n\t\t\t\t\tfor (int k=1;k<=n;++k) if ((de[poc]+de[k]-dis(poc,k))/2<=i) ++cn2[(de[cno]+de[k]-dis(cno,k))/2];\n\t\t\t\t\tfor (int k=n-1;k>=0;--k) cn2[k]+=cn2[k+1];\n\t\t\t\t\tint mu=i;\n\t\t\t\t\twhile (cn2[mu+1]>n/2) ++mu;\n\t\t\t\t\tfor (int k=1;k<=n;++k) if ((de[poc]+de[k]-dis(poc,k))/2<=i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (de[k]==mu && de[k]+dis(cno,k)==de[cno])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout<<""! ""<<k<<endl;\n\t\t\t\t\t\t\texit(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tassert(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k=1;k<=n;++k) if (de[k]==i && de[k]+dis(poc,k)==de[poc])\n\t\t{\n\t\t\tcout<<""! ""<<k<<endl;\n\t\t\texit(0);\n\t\t}\n\t}\n}\n\n\n\n\n']",,,"['interactive', 'probabilities', 'trees']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Centroid Guess.json,https://codeforces.com//blog/entry/109256,Assuming we have already determined that the centroid of the tree is located on the path between and we may now consider how to locate it Let be the vertices on the path from to Let be the set of vertices reachable from including if we erase all other vertices on the path from to Then we may find that are a division of all vertices Let be the size of Then there must exist a vertex on the path satisfying that Notice that the vertices that do not satisfy the condition could not be a centroid and it is already determined that the centroid is on the path so is exactly the centroid of the tree Then we may consider finding out which set each vertex belongs to with queries so that we can calculate the value of For each vertex we may query and For any two vertices and that belong to the same set should be equal to Let and then Thus we have found out the sets each vertex belongs to as well as the value of as well as the centroid This process requires at most queries Now the problem remains to find a pair of vertices and such that the centroid locates on the path from to We can pick a constant satisfying that then select vertices on the tree randomly and query the distances between every pair of selected vertices This requires queries Let these vertices be We can build a virtual tree with being the root that contains all the LCAs of each pair of vertices Observe that if and only if is located on the path between and For a vertex we can find out all vertices on the path from to and then find out the closest vertex to and connect them It is exactly the deepest ancestor of Now that we have constructed the virtual tree without the LCAs with being the root we will then add the LCAs into the virtual tree Start DFS from Assume the current vertex is Enumerate through the nodes adjacent to Assume the current vertex is If there exists another vertex which is adjacent to satisfying that is not on the path between and then and should be both in the subtree of one of s child nodes After finding out all vertices that are in the same subtree as it would be easy to calculate the depth of their LCAs as well as the distance between an LCA vertex and all other vertices in the virtual tree Then remove the old edge and then add edges between the LCA and all vertices found in the same subtree as Lastly add an edge between the LCA and Then repeat the process above until any two vertices adjacent to are not in the same subtree of a child node of Then DFS the child nodes of We will get the whole virtual tree after all DFS are done For the vertices chosen from the beginning we assume that their weights are all while other vertices have weight Then we may find the weighted centroid of the virtual tree when there are multiple such centroids arbitrarily pick one and then make it the root Then for the two vertices with the largest and second largest subtree of the root DFS them recursively find their child vertex with the largest subtree We will be resulted with leaf nodes Then the centroid of the hidden tree is highly possible to be located on the path between these nodes The number of queries in both parts would not exceed Proof of correctness If the centroid is not on the path between and assume the centroid of the virtual tree is in the subtree of the centroid of the hidden tree If the subtrees other than contain at least of the vertices then the centroid of the hidden tree must be on the path between and So there will be at most of the vertices not being in In other words for each of vertices it has a possibility greater than of not being in and there will be at most of the vertices which are not in The possibility of the algorithm being wrong is not greater than let then the value would be approximately 
https://codeforces.com//contest/1979/problem/F,2684284,F,1979F,1979,F. Kostyanych s Theorem,Kostyanych has chosen a complete undirected graph dagger with n vertices and then removed exactly n 2 edges from it You can ask queries of the following type d Kostyanych tells you the number of vertex v with a degree d Among all possible such vertices he selects the vertex and if there are several such vertices he selects the one with the minimum number He also tells you the number of another vertex in the graph with which v is not connected by an edge if none is found then 0 is reported Among all possible such vertices he selects the one with the minimum number Then he removes the vertex v and all edges coming out of it If the required vertex v is not found then 0 0 is reported Find a Hamiltonian path ddagger in the graph in at most n queries It can be proven that under these constraints a Hamiltonian path always exists dagger A complete undirected graph is a graph in which there is exactly one undirected edge between any pair of distinct vertices Thus a complete undirected graph with n vertices contains frac n n 1 2 edges ddagger A Hamiltonian path in a graph is a path that passes through each vertex exactly once ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));int n,m;deque<int> q;pair<int,int> ask(int x){\tcout<<""? ""<<x<<endl;\tint y;cin>>x>>y;\treturn MP(x,y);}void solve(int x){\tif(x==1){\t\tq.push_back(ask(0).first);\t\treturn;\t}\tauto p=ask(x-2);\tif(p.second==0){\t\tauto t=ask(0);\t\tif(x>2) solve(x-2);\t\tq.push_back(p.first),q.push_back(t.first);\t}else{\t\tsolve(x-1);\t\tif(q.front()!=p.second) q.push_front(p.first);\t\telse q.push_back(p.first);\t}}void solve(){\tcin>>n;\tsolve(n);\tcout<<""! "";\twhile(!q.empty()){\t\tcout<<q.front()<<\' \';\t\tq.pop_front();\t}\tcout<<endl;}int main(){\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}']",,,"['brute force', 'constructive algorithms', 'graphs', 'interactive']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Kostyanych s Theorem.json,https://codeforces.com//blog/entry/130213,SolutionLet s consider the following recursive algorithm We will store the Hamiltonian path as a double ended queue maintaining the start and end In case there are only or vertices left in the graph the problem is solved trivially Suppose we know that the current graph has vertices and there are at most edges missing Then the total number of edges in such a graph is at least Let all vertices in the graph have a degree of at most then the total number of edges does not exceed which is less than the stated value Hence we conclude that there is at least one vertex with a degree greater than If there exists a vertex with a degree of then it is sufficient to run our recursive algorithm for the remaining graph Since is only not connected by an edge to one vertex is connected either to the start or the end of the maintained path in the remaining graph Thus we can insert the vertex either at the beginning or at the end of the path Otherwise let be the vertex with a degree of There is at least one vertex with a degree not exceeding Remove and from the graph Notice that the number of edges in such a graph does not exceed The invariant is preserved so we can run the algorithm for the remaining graph Then we can arrange the vertices in the following order where the start of the Hamiltonian path in the remaining graph It remains to understand how to use queries Make a query Let be the second number in the response to our query If the degree of vertex is Run our recursive algorithm and then compare the start and end of the obtained path with Otherwise if it means the degree of vertex is In this case ask about any vertex with a low degree this can be done with a query Then simply arrange the vertices in the order mentioned above We will make no more than queries and the final asymptotic will be 
https://codeforces.com//contest/899/problem/D,139223,D,899D,899,D. Shovel Sale,There are shovels in Polycarp s shop The th shovel costs burles that is the first shovel costs burle the second shovel costs burles the third shovel costs burles and so on Polycarps wants to sell shovels in pairs Visitors are more likely to buy a pair of shovels if their total cost ends with several s Because of this Polycarp wants to choose a pair of shovels to sell in such a way that the sum of their costs ends with maximum possible number of nines For example if he chooses shovels with costs and their total cost is it ends with two nines You are to compute the number of pairs of shovels such that their total cost ends with maximum possible number of nines Two pairs are considered different if there is a shovel presented in one pair but not in the other ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,dp[20][2][2][2][2],a[20];\nvoid DP(){\n\tint mx=0;\n\tlong long MX=0;\n\tfor(;;){\n\t\tMX=MX*10+9;\n\t\tif(MX>=n*2){\n\t\t\tMX/=10;\n\t\t\tbreak;\n\t\t}\n\t\tmx++;\n\t}\n\tint sz=0;\n\twhile(n)a[sz++]=n%10,n/=10;\n\tfor(int l=0,r=sz-1;l<r;l++,r--)swap(a[l],a[r]);\n\tif(sz==mx){\n\t\tfor(int i=0;i<=a[0];i++)\n\t\t\tif(9-i<=i)\n\t\t\t\tdp[0][(i==9-i)][(i==a[0])][(i==0)][(9-i==0)]++;\n\t}else {\n\t\tfor(int i=0;i<=a[0];i++)\n\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t\tdp[0][(i==j)][(i==a[0])][(i==0)][(j==0)]++;\n\t}\n\tsz--;\n\tfor(int i=0,p=1,s1,s2,s3,s4;i<sz;i++,p++)\n\t\tfor(int j=0;j<2;j++)\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t\tfor(int l=0;l<2;l++)\n\t\t\t\t\tfor(int o=0;o<2;o++)\n\t\t\t\t\t\tfor(int A=0,B=9;A<=9;A++,B--){\n\t\t\t\t\t\t\tif(j&&A<B)continue;\n\t\t\t\t\t\t\tif(k&&A>a[p])continue;\n\t\t\t\t\t\t\ts1=j&(A==B);\n\t\t\t\t\t\t\ts2=k&(A==a[p]);\n\t\t\t\t\t\t\ts3=l&(A==0);\n\t\t\t\t\t\t\ts4=o&(B==0);\n\t\t\t\t\t\t\tdp[p][s1][s2][s3][s4]+=dp[i][j][k][l][o];\n\t\t\t\t\t\t}\n\tint ans=dp[sz][0][0][0][0]+dp[sz][0][1][0][0];\n\tprintf(""%d\\n"",ans);\n}\nint main(){\n\tscanf(""%d"",&n);\n\tDP();\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Shovel Sale.json,https://codeforces.com//blog/entry/56392,At first let s check that the sum consisting of only digits nine If it is true then the answer is In the other case we should calculate the number of digits in the number Let this value if We should construct the number which consisting of digits nine After that we should try to write each digit from to to the beginning of Let we wrote next digit and became equal to i e the first digit is and other digits are nines So we need to add to the answer the number of ways to take two different digits from to in such a way that their sum equals to If we should add to the answer If we should to add to the answer nothing Else we should add to the answer the value 
https://codeforces.com//contest/800/problem/C,103097,C,800C,800,C. Vulnerable Kerbals,You are given an integer and a list of distinct integers between and You would like to construct a sequence satisfying the properties Each element is an integer between and inclusive All prefix products of the sequence modulo are distinct No prefix product modulo appears as an element of the input list The length of the sequence is maximized Construct any sequence satisfying the properties above ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 200000;\n\nstruct Input {\n\tint n, m;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> m)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d"", &a[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tvi ans;\n\t\n\tvoid write () {\n\t\tcout << sz(ans) << endl;\n\t\tforn (i, sz(ans)) {\n\t\t\tif (i) {\n\t\t\t\tprintf("" "");\n\t\t\t}\n\t\t\tprintf(""%d"", ans[i]);\n\t\t}\n\t\tputs("""");\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\t\n\t\tint gcd (int x, int y) {\n\t\t\tif (!x) {\n\t\t\t\treturn y;\n\t\t\t}\n\t\t\treturn gcd(y % x, x);\n\t\t}\n\t\t\n\t\tset<int> v[N + 1];\n\t\t\n\t\tint d[N + 1], pr[N + 1];\n\t\tll rev[N];\n\t\t\n\t\tll cur;\n\t\t\n\t\tvoid rec (int i) {\n\t\t\tif (pr[i] != -1) {\n\t\t\t\trec(pr[i]);\n\t\t\t}\n\t\t\tfor (ll x : v[i]) {\n\t\t\t\tll p = x;\n\t\t\t\tll q = cur;\n\t\t\t\tll g = gcd(p, q);\n\t\t\t\tp /= g;\n\t\t\t\tq /= g;\n\t\t\t\tll val = p * rev[q] % m;\n\t\t\t\tans.pb(val);\n\t\t\t\tcur = cur * val % m;\n\t\t\t\tassert(cur == x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tint phi = m;\n\t\t\t{\n\t\t\t\tint m0 = m;\n\t\t\t\tforn (i, 2, N + 1) {\n\t\t\t\t\tif (m0 % i == 0) {\n\t\t\t\t\t\twhile (m0 % i == 0) {\n\t\t\t\t\t\t\tm0 /= i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphi /= i;\n\t\t\t\t\t\tphi *= i - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, m) {\n\t\t\t\trev[i] = 1;\n\t\t\t\tll x = i;\n\t\t\t\tll pw = phi - 1;\n\t\t\t\twhile (pw) {\n\t\t\t\t\tif (pw & 1) {\n\t\t\t\t\t\t(rev[i] *= x) %= m;\n\t\t\t\t\t}\n\t\t\t\t\t(x *= x) %= m;\n\t\t\t\t\tpw >>= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tforn (i, m) {\n\t\t\t\tv[gcd(i, m)].insert(i);\n\t\t\t}\n\t\t\tforn (i, n) {\n\t\t\t\tv[gcd(a[i], m)].erase(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tmemset(d, 0, sizeof d);\n\t\t\tmemset(pr, -1, sizeof pr);\n\t\t\tforn (i, m + 1) {\n\t\t\t\td[i] = sz(v[i]);\n\t\t\t}\n\t\t\tforn (i, 1, m + 1) {\n\t\t\t\tfor (int j = 2 * i; j <= m; j += i) {\n\t\t\t\t\tif (umx(d[j], d[i] + sz(v[j]))) {\n\t\t\t\t\t\tpr[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bst = 0;\n\t\t\tint mx = 0;\n\t\t\tforn (i, m + 1) {\n\t\t\t\tif (umx(mx, d[i])) {\n\t\t\t\t\tbst = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = 1;\n\t\t\tdebug(mx);\n\t\t\trec(bst);\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + "".in"").c_str(), ""r"", stdin);\n//\t\tfreopen((problemname + "".out"").c_str(), ""w"", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'math', 'number theory']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Vulnerable Kerbals.json,https://codeforces.com//blog/entry/51598,Let s consider a directed graph with m nodes labeled from 1 to m where there is an edge between nodes i and node j if there exists a number x such that Now we can notice there is an edge between node i and node j if and only if gcd n i divides gcd n j So there are two directed edges between two nodes i and j if and only if gcd n i gcd n j So these form some directed cliques in our graphs We can also notice that this happens to form the SCC decomposition of our graph i e condensation So this problem reduces to finding the heaviest path in a DAG with weights on nodes The nodes in this dag correspond to divisors of n and the weight corresponds to the number of allowed numbers with that gcd 
https://codeforces.com//contest/1017/problem/E,205995,E,1017E,1017,E. The Supersonic Rocket,After the war the supersonic rocket became the most common public transportation Each supersonic rocket consists of Each engine is a set of The first engine has n power sources and the second one has m power sources A power source can be described as a point x i y i on a 2 D plane All points in each engine are different You can manipulate each engine There are two operations that you can do with each engine You can do each operation as many times as you want For every power source as a whole in that engine x i y i becomes x i a y i b a and b can be any real numbers In other words all power sources will be shifted For every power source as a whole in that engine x i y i becomes x i cos theta y i sin theta x i sin theta y i cos theta theta can be any real number In other words all power sources will be rotated The engines work as follows after the two engines are powered their power sources are being combined here power sources of different engines may coincide If two power sources A x a y a and B x b y b exist then for all real number k that 0 lt k lt 1 a new power source will be created C k kx a 1 k x b ky a 1 k y b After that the from all power sources will be generated can be considered as an infinite set of all power sources occurred A supersonic rocket is if and only if after you manipulate the engines destroying any power source and then power the engine the power field generated won t be changed comparing to the situation where no power source erased Two power fields are considered the same if and only if any power source in one field belongs to the other one as well Given a supersonic rocket check whether it is safe or not ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n,m;\n\nll dist(pi A, pi B) {\n    A.f -= B.f, A.s -= B.s;\n    return (ll)A.f*A.f+(ll)A.s*A.s;\n}\n\nll dot(pi O, pi A, pi B) {\n    return (ll)(A.f-O.f)*(B.f-O.f)+(ll)(A.s-O.s)*(B.s-O.s);\n}\n\nll cross(pi O, pi A, pi B) {\n    return (ll)(A.f-O.f)*(B.s-O.s)\n            -(ll)(A.s-O.s)*(B.f-O.f);\n}\n\nvpi convex_hull(vpi P) {\n    sort(all(P)); P.erase(unique(all(P)),P.end());\n    int n = sz(P);\n    if (n == 1) return P;\n    \n    vpi bot = {P[0]};\n    FOR(i,1,n) {\n        while (sz(bot) > 1 && cross(bot[sz(bot)-2], bot.back(), P[i]) <= 0) bot.pop_back();\n        bot.pb(P[i]);\n    }\n    bot.pop_back();\n    \n    vpi up = {P[n-1]};\n    F0Rd(i,n-1) {\n        while (sz(up) > 1 && cross(up[sz(up)-2], up.back(), P[i]) <= 0) up.pop_back();\n        up.pb(P[i]);\n    }\n    up.pop_back();\n    \n    bot.insert(bot.end(),all(up));\n    return bot;\n}\n\nint min_rotation(vl s) {\n\tint a=0, N=sz(s); \n\ts.insert(s.end(),all(s));\n\tF0R(b,N) F0R(i,N) {\n\t\tif (a+i == b || s[a+i] < s[b+i]) {b += max(0, i-1); break;}\n\t\tif (s[a+i] > s[b+i]) { a = b; break; }\n\t}\n\treturn a;\n}\n\nvl rot_min(vl v) {\n    int x = min_rotation(v);\n    rotate(v.begin(),v.begin()+x,v.end());\n    return v;\n}\n\nvl hsh(vpi x) {\n    vl v;\n    F0R(i,sz(x)) {\n        v.pb(dist(x[i],x[(i+1)%sz(x)]));\n        v.pb(4*INF+dot(x[i],x[(i+1)%sz(x)],x[(i+2)%sz(x)]));\n    }\n    return v;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    vpi x(n), y(m);\n    F0R(i,n) cin >> x[i].f >> x[i].s;\n    F0R(i,m) cin >> y[i].f >> y[i].s;\n    x = convex_hull(x), y = convex_hull(y);\n    vl X = hsh(x), Y = hsh(y);\n    X = rot_min(X);\n    Y = rot_min(Y);\n    //for (auto a: X) cout << a << "" "";\n    //cout << ""\\n"";\n    if (X == Y) cout << ""YES"";\n    else cout << ""NO"";\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']",,,"['geometry', 'hashing', 'strings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. The Supersonic Rocket.json,https://codeforces.com/blog/entry/61081,The statement is complicated it is actually Given two sets of points check whether their convex hulls are isomorphic The standard solution is get the convex hulls make it into a string of traversal edge angle edge angle edge Then double the first string and KMP them There can be other ways to solve this problem because there is a useful condition all coordinates are integers Complexity 
https://codeforces.com//contest/1272/problem/D,494356,D,1272D,1272,D. Remove One Element,You are given an array a consisting of n integers You can remove element from this array Thus the final length of the array is n 1 or n Your task is to calculate the maximum possible length of the contiguous subarray of the remaining array Recall that the contiguous subarray a with indices from l to r is a l dots r a l a l 1 dots a r The subarray a l dots r is called strictly increasing if a l a l 1 dots a r ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n;\nint a[N], l[N], r[N];\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    for (int i = 1; i <= n; i++)\n        l[i] = (a[i] > a[i - 1] ? l[i - 1] + 1 : 1);\n    for (int i = n; i >= 1; i--)\n        r[i] = (a[i] < a[i + 1] ? r[i + 1] + 1 : 1);\n    int res = 0;\n    for (int i = 1; i <= n; i++)\n        res = max(res, max(l[i], r[i]));\n    for (int i = 2; i < n; i++)\n        if (a[i - 1] < a[i + 1])\n            res = max(res, l[i - 1] + r[i + 1]);\n    cout << res;\n}\n']",,,"['brute force', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Remove One Element.json,https://codeforces.com//blog/entry/72132,Firstly let s calculate for each from to two following values and means the maximum length of the increasing sequence starting in the position and means the maximum length of the increasing sequence ending in the position Initially all values are the element itself The array can be calculated in order from right to left with the following condition if then otherwise it still remain The same with the array but we have to calculate its values in order from left to right and if then otherwise it still remain Having these arrays we can calculate the answer The initial answer if we don t remove any element is the maximum value of the array And if we remove the th element where then we can update the answer with the value if Time complexity 
https://codeforces.com//contest/1680/problem/B,1398256,B,1680B,1680,B. Robots,There is a field divided into n rows and m columns Some cells are empty denoted as other cells contain robots denoted as You can send a command to at the same time The command can be of one of the four types move up move right move down move left When you send a command attempt to take one step in the direction you picked If a robot tries to move outside the field it explodes otherwise moves to an adjacent cell in the chosen direction You can send as many commands as you want possibly zero in any order Your goal is to make at least one robot reach the upper left corner of the field Can you do this without forcing any of the robots to explode ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(string& x : s) cin >> x;\n\tint rx = -1, ry = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'E\') continue;\n\t\t\tif(rx == -1){\n\t\t\t\trx = i;\n\t\t\t\try = j;\n\t\t\t}\n\t\t\tif(i < rx || j < ry){\n\t\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ""YES"" << \'\\n\';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Robots.json,https://codeforces.com//blog/entry/102852,Let s assume that the rows are numbered from to from top to bottom and columns are numbered from to from left to right If there is no robot in the cell initially we have to perform several moves up and or left If the first row with at least one robot is the th row then we can make at most steps up and we should do at least steps up since otherwise there will me no robot in the upper row Similarly if the first column with at least one robot is the th column then we can make at most steps to the left and we should do at least steps to the left since otherwise there will me no robot in the leftmost column Now there are two possible solutions both starting with finding and we afterwards either simulate moves up and moves to the left and check that everything is fine or just check that there is a robot in the cell since only this robot can end up in 
https://codeforces.com//contest/1459/problem/A,837948,A,1459A,1459,A. Red-Blue Shuffle,There are n cards numbered 1 ldots n The card i has a red digit r i and a blue digit b i written on it We arrange all n cards in random order from left to right with all permutations of 1 ldots n having the same probability We then read all red digits on the cards from left to right and obtain an integer R In the same way we read all blue digits and obtain an integer B When reading a number leading zeros can be ignored If all digits in a number are zeros then the number is equal to 0 Below is an illustration of a possible rearrangement of three cards and how R and B can be found Two players Red and Blue are involved in a bet Red bets that after the shuffle R B and Blue bets that R B If in the end R B the bet results in a draw and neither player wins Determine which of the two players is more likely has higher probability to win the bet or that their chances are equal Refer to the Note section for a formal discussion of comparing probabilities ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define N 1000002\ntypedef long long ll;\nint n,T;\nchar a[N],b[N];\nint main()\n{\n\tscanf(""%d"",&T);\n\twhile(T--)\n\t{\n\t\tscanf(""%d"",&n);\n\t\tscanf(""%s%s"",a+1,b+1);\n\t\tint c1=0,c2=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-\'0\'<b[i]-\'0\')c1++;\n\t\t\telse if(a[i]-\'0\'>b[i]-\'0\')c2++;\n\t\t}\n\t\tif(c1==c2)puts(""EQUAL"");\n\t\telse if(c1<c2)puts(""RED"");\n\t\telse puts(""BLUE"");\n\t}\n}\n\n']",,,"['math', 'probabilities']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Red-Blue Shuffle.json,https://codeforces.com//blog/entry/85750,First we can observe that if a card has then if doesn t affect the comparison between and regardless of its position We can forget about all such cards Formally if we erase all such cards after the permutation then and are still compared in the same way and further all the remaining cards are still permuted equiprobably Now we only have cards with let s call them Red favourable and call them Blue favourable But then the comparison between and will only be decided by whether the first card is Red or Blue favourable Naturally if say there are more Red favourable cards than Blue favourable cards then Red is more likely to win If there is an equal number of Red and Blue favourable cards then the chances are equal Thus for the solution purposes we only need to count indices with and those with and compare these two numbers 
https://codeforces.com//contest/1311/problem/F,547481,F,1311F,1311,F. Moving Points,There are n points on a coordinate axis OX The i th point is located at the integer point x i and has a speed v i It is guaranteed that no two points occupy the same coordinate All n points move with the constant speed the coordinate of the i th point at the moment t t is calculated as x i t cdot v i Consider two points i and j Let d i j be the minimum possible distance between these two points over any possible moments of time even It means that if two points i and j coincide at some moment the value d i j will be 0 Your task is to calculate the value sum limits 1 le i j le n d i j the sum of minimum distances over all pairs of points ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\npair<int,int> p[200005];\nint d1[200005],d2[200005];\nlong long BIT1[200005],BIT2[200005],BITcnt1[200005],BITcnt2[200005];\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(long long* BIT,int x,long long d)\n{\n    while(x<=200004)\n    {\n        BIT[x]+=d;\n        x+=lowbit(x);\n    }\n}\nlong long query(long long* BIT,int x)\n{\n    long long ret=0;\n    while(x)\n    {\n        ret+=BIT[x];\n        x-=lowbit(x);\n    }\n    return ret;\n}\nint main()\n{\n    int n,cnt1,cnt2;\n    long long ans;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&p[i].first);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&p[i].second);\n    sort(p,p+n);\n    cnt1=0;\n    cnt2=0;\n    for(int i=0;i<n;i++)\n        if(p[i].second>=0)\n            d1[cnt1++]=p[i].second;\n        else d2[cnt2++]=-p[i].second;\n    sort(d1,d1+cnt1);\n    sort(d2,d2+cnt2);\n    cnt1=unique(d1,d1+cnt1)-d1;\n    cnt2=unique(d2,d2+cnt2)-d2;\n    ans=0;\n    for(int i=n-1;i>=0;i--)\n    {\n        if(p[i].second>=0)\n        {\n            ans+=(query(BIT1,cnt1)-query(BIT1,lower_bound(d1,d1+cnt1,p[i].second)-d1))-(query(BITcnt1,cnt1)-query(BITcnt1,lower_bound(d1,d1+cnt1,p[i].second)-d1))*p[i].first;\n            update(BIT1,lower_bound(d1,d1+cnt1,p[i].second)-d1+1,p[i].first);\n            update(BITcnt1,lower_bound(d1,d1+cnt1,p[i].second)-d1+1,1);\n        }\n        else\n        {\n            ans+=query(BIT2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1)-query(BITcnt2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1)*p[i].first;\n            ans+=query(BIT1,cnt1)-query(BITcnt1,cnt1)*p[i].first;\n            update(BIT2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1,p[i].first);\n            update(BITcnt2,lower_bound(d2,d2+cnt2,-p[i].second)-d2+1,1);\n        }\n    }\n    printf(""%lld\\n"",ans);\n    return 0;\n}\n']",,,"['data structures', 'divide and conquer', 'implementation', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Moving Points.json,https://codeforces.com//blog/entry/74224,Let s understand when two points and coincide Let Then they are coincide when Otherwise these two points will never coincide and the distance between them will only increase So we need to consider only the initial positions of points Let s sort all points by and consider them one by one from left to right Let the th point be the rightmost in the pair of points that we want to add to the answer We need to find the number of points such that and and the sum of for such points as well We can do this using two BITs Fenwick trees if we compress coordinates all values and do some kind of scanline by values Let the number of such points be and the sum of coordinates of such points be Then we can increase the answer by and add our current point to the Fenwick trees add to the position in the first tree and to the position in the second tree When we want to find the number of required points and the sum of its coordinates we just need to find the sum on the prefix two times in Fenwick trees Note that you can use any online logarithmic data structure you like in this solution such as treap and segment tree There is also another solution that uses pbds Let s do the same thing but there is one problem Such data structure does not have sum on prefix function so we have to replace it somehow To do this let s calculate only part when we go from left to right Then let s clear our structure go among all points again but from right to left and calculate the same thing but with the opposite sign find the number of points such that and When we go from right to left we need to decrease the answer by It is some kind of contribution to the sum technique Time complexity 
https://codeforces.com//contest/387/problem/E,6210,E,387E,387,E. George and Cards,George is a cat so he loves playing very much Vitaly put cards in a row in front of George Each card has one integer written on it All cards had distinct numbers written on them Let s number the cards from the left to the right with integers from to Then the th card from the left contains number Vitaly wants the row to have exactly cards left He also wants the th card from left to have number written on it Vitaly gave a task to George to get the required sequence of cards using the remove operation times In one George can choose is not greater than the current number of cards in the row contiguous cards contiguous subsegment of cards Let s denote the numbers written on these card as from the left to the right After that George can remove the card such that for each After the described operation George gets pieces of sausage George wondered what maximum number of pieces of sausage will he get in total if he reaches his goal and acts optimally well Help George find an answer to his question ,"['#include <algorithm>\n#include <stdio.h>\n#include <memory.h>\n#include <ctype.h>\n\nusing namespace std;\n\ntypedef long long INT;\ntypedef pair<int, int> pii;\n\n#define NN 1100000\n\nint N;\nint t1[NN], t2[NN], t[NN];\nint p[NN], pos[NN], pre[NN], nxt[NN];\nint fix[NN];\n\nvoid update1(int u, int val) {\n\twhile (u<=N) {\n\t\tt1[u]=max(t1[u], val);\n\t\tu+=u&-u;\n\t}\n}\n\nint calc1(int u) {\n\tint res=0;\n\twhile (u) {\n\t\tres=max(res, t1[u]);\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\n\nvoid update2(int u, int val) {\n\twhile (u<=N) {\n\t\tt2[u]=min(t2[u], val);\n\t\tu+=u&-u;\n\t}\n}\n\nint calc2(int u) {\n\tint res=N+1;\n\twhile (u) {\n\t\tres=min(res, t2[u]);\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\n\nint calc(int u) {\n\tint res=0;\n\twhile (u) {\n\t\tres+=t[u];\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\n\nvoid update(int u, int val) {\n\twhile (u<=N) {\n\t\tt[u]+=val;\n\t\tu+=u&-u;\n\t}\n}\n\nint main() {\n\tint K, i, j, b;\n\tINT ans;\n\t\n\tscanf(""%d%d"", &N, &K);\n\tfor (i=0; i<N; i++) scanf(""%d"", &p[i]);\n\tfor (i=0; i<K; i++) {\n\t\tscanf(""%d"", &b);\n\t\tfix[b]=1;\n\t}\n\t\n\tfor (i=0; i<N; i++) pos[p[i]]=i;\n\t\n\tfor (i=0; i<N; i++) {\n\t\tif (fix[p[i]]) {\n\t\t\tupdate1(p[i], i+1);\n\t\t} else {\n\t\t\tpre[i]=calc1(p[i]);\n\t\t}\n\t}\n\t\n\tfor (i=0; i<=N; i++) t2[i]=N+1;\n\t\n\tfor (i=N-1; i>=0; i--) {\n\t\tif (fix[p[i]]) {\n\t\t\tupdate2(p[i], i+1);\n\t\t} else {\n\t\t\tnxt[i]=calc2(p[i])-1;\n\t\t}\n\t}\n\t\n\tfor (i=1; i<=N; i++) {\n\t\tt[i]=(1<<__builtin_ctz(i));\n\t}\n\tans=0;\n\tfor (j=1; j<=N; j++) {\n\t\tif (fix[j]) continue;\n\t\ti=pos[j];\n\t\tans+=calc(nxt[i])-calc(pre[i]);\n\t\tupdate(i+1, -1);\n\t}\n\t\n\tprintf(""%I64d\\n"", ans);\n\t\n\treturn 0;\n}']",,,"['binary search', 'data structures']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. George and Cards.json,https://codeforces.com//blog/entry/10583,Let s calculate arrays position of number in permutation and equals to one if we should remove number from permutation and zero if we shouldn t remove from permutation Let s numvers which we should remove It is clear to understand that we should remove these number in increasing order It is simple to proof this statement Let s iterate from to to Also we the current number we will have special set set in TreeSet in Java of positions of non erased numbers which are smaller then of permutation These position can create an obstacle for current position of number It is simple to support this special set Also we can add to this set numbers and Now it is easy to find length og the maximal sub array where current number is a minimum You can prosess such query by using standart functions of programming language lower and higher in Java After that we should use Fenwick tree to determine quantity of numbers which are not removed on the maximal sub array The complexity is time memory Very simple implementation on Java 5850986 
https://codeforces.com//contest/1371/problem/D,658031,D,1371D,1371,D. Grid-00100,A mad scientist Dr Jubal has made a competitive programming task Try to solve it You are given integers n k Construct a grid A with size n times n The very important condition should be satisfied the sum of all elements in the grid is exactly k In other words the number of 1 in the grid is equal to k Let s define A i j as the integer in the i th row and the j th column R i A i 1 A i 2 A i n for all 1 le i le n C j A 1 j A 2 j A n j for all 1 le j le n In other words R i are row sums and C j are column sums of the grid A For the grid A let s define the value f A max R min R 2 max C min C 2 here for an integer sequence X we define max X as the maximum value in X and min X as the minimum value in X Find any grid A which satisfies the following condition Among such grids find any for which the value f A is the minimum possible Among such tables you can find any ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 305;\nint T, n, k;\nbool a[Maxn][Maxn];\nint main()\n{\n\tscanf(""%d"", &T);\n\twhile (T--)\n\t{\n\t\tscanf(""%d%d"", &n, &k);\n\t\tif (!k)\n\t\t{\n\t\t\tputs(""0"");\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\tputchar(\'0\');\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint tmp_k = k;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\ta[i][j] = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint pos = i;\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\ta[j][pos] = true, pos = pos % n + 1, tmp_k--;\n\t\t\t\tif (!tmp_k) goto A;\n\t\t\t}\n\t\t}\n\t\tA:if (k % n == 0) puts(""0"");\n\t\telse puts(""2"");\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tputchar(a[i][j] + \'0\');\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Grid-00100.json,https://codeforces.com//blog/entry/79624,We can construct a grid which has if otherwise the values are smallest almost obviously in following method First initialize for all Then change a into times by using following pseudo code Total complexity 
https://codeforces.com//contest/744/problem/A,85239,A,744A,744,A. Hongcow Builds A Nation,Hongcow is ruler of the world As ruler of the world he wants to make it easier for people to travel by road within their own countries The world can be modeled as an undirected graph with nodes and edges of the nodes are home to the governments of the countries that make up the world There is at most one edge connecting any two nodes and no edge connects a node to itself Furthermore for any two nodes corresponding to governments Any graph that satisfies all of these conditions is Hongcow wants to add as many edges as possible to the graph while keeping it stable Determine the maximum number of edges Hongcow can add ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nvector <int> g[N];\nint cap[N];\nbool was[N];\nint x[N];\nvector <int> yes, no;\n\nint main() {\n  int n, m, k;\n  scanf(""%d %d %d"", &n, &m, &k);\n  for (int i = 0; i < k; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    foo--;\n    cap[foo] = 1;\n  }\n  for (int i = 0; i < m; i++) {\n    int foo, bar;\n    scanf(""%d %d"", &foo, &bar);\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  for (int i = 0; i < n; i++) {\n    was[i] = false;\n  }\n  for (int i = 0; i < n; i++) {\n    if (was[i]) {\n      continue;\n    }\n    int b = 0, e = 1;\n    x[0] = i;\n    was[i] = true;\n    while (b < e) {\n      for (int j = 0; j < (int) g[x[b]].size(); j++) {\n        int u = g[x[b]][j];\n        if (!was[u]) {\n          x[e] = u;\n          was[u] = true;\n          e++;\n        }\n      }\n      b++;\n    }\n    int have = 0;\n    for (int j = 0; j < e; j++) {\n      have += cap[x[j]];\n    }\n    if (have) {\n      yes.push_back(e);\n    } else {\n      no.push_back(e);\n    }\n  }\n  int all_no = 0;\n  int max_yes = 0;\n  for (int i = 0; i < (int) yes.size(); i++) {\n    max_yes = max(max_yes, yes[i]);\n  }\n  for (int i = 0; i < (int) no.size(); i++) {\n    all_no += no[i];\n  }\n  long long ans = 0;\n  for (int i = 0; i < (int) yes.size(); i++) {\n    if (yes[i] == max_yes) {\n      yes[i] += all_no;\n      max_yes = -1;\n    }\n    ans += yes[i] * 1LL * (yes[i] - 1) / 2;\n  }\n  cout << (ans - m) << endl;\n  return 0;\n}\n']",,,"['dfs and similar', 'graphs']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Hongcow Builds A Nation.json,https://codeforces.com//blog/entry/49126,First let s make all connected components cliques This graph is still stable Now there are some components without special nodes Where should we connect them If there is a component with size A and a component with size B we can add A B edges if we connect these two components So it makes sense to choose the largest component code 
https://codeforces.com//contest/1826/problem/C,1909267,C,1826C,1826,C. Dreaming of Freedom,Madeleine L EngleThere are n programmers choosing their favorite algorithm amongst m different choice options Before the first round all m options are available In each round every programmer makes a vote for one of the remaining algorithms After the round only the algorithms with the maximum number of votes remain The voting process ends when there is only one option left Determine whether the voting process can continue indefinitely or no matter how people vote they will eventually choose a single option after some finite amount of rounds ,"['#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nvector<int> dd(int x){\n    vector<int> res;\n    for(int i=1;i*i<=x;i++){\n        if(x % i == 0){\n            res.pb(i);\n            res.pb(x / i);\n        }\n    }\n    return res;\n}\n\nvoid solve(){\n    int n, m; cin >> n >> m;\n    auto y = dd(n);\n    for(int x : y){\n        if(x <= m && x > 1){\n            cout << ""NO"" << ""\\n"";\n            return;\n        }\n    }\n    cout << ""YES"" << ""\\n"";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n']",,,"['greedy', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Dreaming of Freedom.json,https://codeforces.com//blog/entry/115892,First we need to notice that in order to keep some amount of options indefinetely this number has to be at least and divide Let s find the smallest such number Now if let s always vote for the first options evenly In the other case each round would force us to to decrease the number of remaining options so eventually it will become one So the answer is if and only if Now on how to find the number fast Since is a divisor of we can say that is the smallest divisor of not equal to We can find the number using different approaches A more straightforward one is checking all the numbers from up to If no divisors found then is prime and This results in a solution The solution presented before is good but not fast enough in some languages like Python We ve decided not to cut it off to not make the problem heavy in IO We can optimize it via finding the smallest divisor using the sieve of Eratosthenes This would result in or even faster precomputation and to answer a test case so the total time complexity is 
https://codeforces.com//contest/1553/problem/E,1054397,E,1553E,1553,E. Permutation Shift,An identity permutation of length n is an array 1 2 3 dots n We performed the following operations to an identity permutation of length n firstly we cyclically shifted it to the right by k positions where k is unknown to you the only thing you know is that 0 le k le n 1 When an array is cyclically shifted to the right by k positions the resulting array is formed by taking k last elements of the original array without changing their relative order and then appending n k first elements to the right of them without changing relative order of the first n k elements as well For example if we cyclically shift the identity permutation of length 6 by 2 positions we get the array 5 6 1 2 3 4 secondly we performed the following operation m times pick any two elements of the array and swap them You are given the values of n and m and the resulting array Your task is to find all possible values of k in the cyclic shift operation ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: Disjoint Set Union with path compression\n \t* and union by size. Add edges and test connectivity. \n \t* Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e; void init(int N) { e = vi(N,-1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } \n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tbool unite(int x, int y) { // union by size\n\t\tx = get(x), y = get(y); if (x == y) return 0;\n\t\tif (e[x] > e[y]) swap(x,y);\n\t\te[x] += e[y]; e[y] = x; return 1;\n\t}\n};\n\n/**template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {\n\tsort(all(ed));\n\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST\n\teach(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; \n\treturn ans;\n}*/\n\nint N,M;\n\nvoid solve(int tc) {\n\tre(N,M);\n\tvi P(N); re(P); each(t,P) --t;\n\tmap<int,vi> eq;\n\tF0R(i,N) {\n\t\t// (N-K+i)%N equiv P[i]\n\t\teq[(i-P[i]+N)%N].pb(i);\n\t}\n\tvi ans;\n\teach(t,eq) if (sz(t.s) >= N-2*M) {\n\t\tint K = t.f;\n\n\t\t// (N-K+i)%N\n\t\tDSU D; D.init(N);\n\t\tvi nex(N);\n\t\tF0R(i,N) D.unite(P[i],(N-K+i)%N);\n\t\tint comps = 0;\n\t\tF0R(i,N) comps += D.get(i) == i;\n\t\tint moves = N-comps;\n\t\tif (moves <= M) ans.pb(K);\n\t}\n\tpr(sz(ans));\n\teach(t,ans) pr(\' \',t);\n\tps();\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']",,,"['brute force', 'combinatorics', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Permutation Shift.json,https://codeforces.com//blog/entry/93105,Let s decrease all numbers by and start the numeration from because cyclic shifts are very easy to describe this way Let s observe for So So Continuing this process we verify that indeed Very simple Now suppose we have some value and we want to check if it is possible to obtain from th cyclic shift by doing at most swaps For this we can calculate the minimum number of swaps and check it is not more than So how to calculate the minimum number of swaps needed to transform a permutation to another permutation This is actually a well known problem The idea is we build a graph with undirected edges The minimum number of swaps will be equal to where is equal to the number of connected components in the resulting graph Nice now we can check if some is good in time But we can t check all of them right Here comes the crucial observation Suppose you get a permutation after a cyclic shift Then you make at most swaps and obtain This means at most numbers will be out of order That is there will be at least indices such that So can we calculate the number the count of integers in position for each cyclic shift Yes we can For an arbitrary there is exactly one such that But wait it means there are in total only good positions because And we check only those for which it is true that Remember that weird constraint Well turns out there are at most different to consider So we know we check at most different values and we know how to check in time That concludes the solution The time and space complexities are 
https://codeforces.com//contest/1042/problem/C,220707,C,1042C,1042,C. Array Product,You are given an array a consisting of n integers You can perform the following operations with it Choose some positions i and j 1 le i j le n i ne j write the value of a i cdot a j into the j th cell and from the i th cell Choose some position i and from the i th cell this operation can be performed The number of elements decreases by one after each operation However the indexing of positions stays the same Deleted numbers can t be used in the later operations Your task is to perform exactly n 1 operations with the array in such a way that the only number that remains in the array is maximum possible This number can be rather large so instead of printing it you need to print sequence of operations which leads to this maximum number Read the output format to understand what exactly you need to print ,"['#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \t\n// Who’s Kobe? \n// Fisherman can’t stop us\n// Average ABCDE on a good day\nusing namespace std;\n\nint n;\nconst int MAXN = 200005;\nlong long a[MAXN];\nvector<int> curr, z;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n;\n\n\tlong long neg = 0, idxn = 0, smallneg = 1e9 + 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> a[i];\n\t\tif(a[i] < 0)\n\t\t{\n\t\t\tneg++;\n\t\t\tif(abs(a[i]) < smallneg)\n\t\t\t{\n\t\t\t\tsmallneg = abs(a[i]);\n\t\t\t\tidxn = i;\n\t\t\t}\n\t\t}\n\t\tif(a[i] == 0)\n\t\t\tz.push_back(i);\n\t}\n\n\tint counter = 0;\n\tfor(int i = 0; i < (int)z.size() - 1; i++)\n\t{\n\t\tcout << 1 << "" "" << z[i] << "" "" << z[i + 1] << ""\\n"";\n\t\tcounter++;\n\t}\n\n\tint pos = -1;\n\tif (!z.empty())\n\t\tpos = z.back();\n\tif(neg % 2 == 1)\n\t{\n\t\tpos = idxn;\n\t\tif(!z.empty())\n\t\t{\n\t\t\tcout << 1 << "" "" << z.back() << "" "" << idxn << ""\\n"";\n\t\t\tcounter++;\n\t\t}\n\t}\n\tif(counter == n - 1)\n\t\treturn 0;\n\telse if (pos != -1)\n\t\tcout << 2 << "" "" << pos << ""\\n"";\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] != 0 && (neg % 2 == 0 || i != idxn))\n\t\t\tcurr.push_back(i);\n\n\tfor(int i = 0; i < curr.size() - 1; i++)\n\t\tcout << 1 << "" "" << curr[i] << "" "" << curr[i + 1] << ""\\n"";\n\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Array Product.json,https://codeforces.com/blog/entry/61891,There are several cases in the problem Let the number of zeroes in the array be and the number of negative elements be Also let be the position of the maximum negative element in the array or if there are no negative elements in the array Let the answer part be the product of all the numbers which will be in the answer and the removed part be the product of all the numbers which will be removed by the second type operation The first case is the following and Then the answer part is the product of all the numbers in the array The removed part is empty The second case is the following is odd Then the answer part is the product of all the numbers in the array except all zeroes and The removed part is the product of all zeroes and And the third case is the following is even Then the answer part is the product of all the numbers in the array except all zeroes The removed part is the product of all zeroes in the array be careful in case and Be careful with printing the answer because my first solution printed operations instead of operations in case or and And the funniest part of this problem is the checker The first thing I thought was Well I want to write a fair checker on this problem I did exactly that What do we need Split all the numbers in the array into two parts Okay let s write DSU to do that What s next Multiply numbers from to Okay let s use FFT and Divide and Conquer And the last part is the comparing two numbers of length about So writing this checker was pretty easy problem But the coordinator didn t like that and I replaced it with very easy checker which uses some ideas from the solution 
https://codeforces.com//contest/1656/problem/G,1341210,G,1656G,1656,G. Cycle Palindrome,We say that a sequence of n integers a 1 a 2 ldots a n is a palindrome if for all 1 leq i leq n a i a n i 1 You are given a sequence of n integers a 1 a 2 ldots a n and you have to find if it exists a sigma so that the sequence a sigma 1 a sigma 2 ldots a sigma n is a palindrome A permutation of 1 2 ldots n is a bijective function from 1 2 ldots n to 1 2 ldots n We say that a permutation sigma is a cycle permutation if 1 sigma 1 sigma 2 1 ldots sigma n 1 1 are pairwise different numbers Here sigma m 1 denotes underbrace sigma sigma ldots sigma m text times 1 ldots ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    std::vector<int> cnt(n);\n    std::vector<std::vector<int>> pos(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        cnt[a[i]]++;\n        pos[a[i]].push_back(i);\n    }\n    \n    int odd = 0;\n    for (int i = 0; i < n; i++) {\n        odd += cnt[i] % 2;\n    }\n    if (odd > 1) {\n        std::cout << ""NO\\n"";\n        return;\n    }\n    if (n % 2 == 1 && cnt[a[(n - 1) / 2]] == 1) {\n        std::cout << ""NO\\n"";\n        return;\n    }\n    std::cout << ""YES\\n"";\n    \n    std::vector<int> p(n), q(n);\n    \n    DSU g(n);\n    for (int x = 0, L = 0, R = n; x < 2; x++) {\n        for (int i = 0; i < n; i++) {\n            if (int(pos[i].size()) % 2 == x) {\n                for (auto j : pos[i]) {\n                    if (L < n - R) {\n                        p[L++] = j;\n                    } else {\n                        p[--R] = j;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        q[p[i]] = i;\n        g.merge(i, p[i]);\n    }\n    \n    auto swap = [&](int x, int y) {\n        std::swap(q[p[x]], q[p[y]]);\n        std::swap(p[x], p[y]);\n    };\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j < int(pos[i].size()); j++) {\n            int x = pos[i][j];\n            int y = pos[i][j - 1];\n            if (g.leader(x) != g.leader(y)) {\n                swap(q[x], q[y]);\n                g.merge(x, y);\n            }\n        }\n    }\n    \n    int lst = -1;\n    for (int i = 0; i < n; i++) {\n        if (int(pos[i].size()) <= 1) {\n            continue;\n        }\n        if (lst != -1 && !g.same(pos[i][0], pos[lst][0])) {\n            int x = pos[lst][0];\n            if (q[x] * 2 + 1 == n) {\n                x = pos[lst][1];\n            }\n            int u = q[x];\n            int v = n - 1 - q[x];\n            swap(u, v);\n            int y = pos[i][0];\n            if (q[y] * 2 + 1 == n) {\n                y = pos[i][1];\n            }\n            int a = q[y];\n            int b = n - 1 - q[y];\n            swap(u, a);\n            swap(v, b);\n            g.merge(pos[i][0], pos[lst][0]);\n        }\n        lst = i;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << p[i] + 1 << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['constructive algorithms', 'graphs', 'math']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Cycle Palindrome.json,https://codeforces.com//blog/entry/101211,We clearly see that the following two conditions are necessary Each number must be repeated an even number of time except possibly one of the numbers This is necessary to find any permutation that results in a palindrome not just a cycle If is odd it can not be that the number appears only one time Otherwise the permutation would need to have one fixed point We will see that those two conditions are sufficient First let s focus on the even case Find any permutation so that applying it results in a palindrome This permutation will have a cycle decomposition We are going to merge all those cycles in one big cycle To do so we will first merge the cycles so that indices and are in the same cycle for all Note that since we can define a new permutation with and and the permutation will still generate a palindrome and and will be in the same cycle We iterate over all the s and merge all such cycles Note that we need to keep track efficiently of which indices are in the same cycle so we should use union find data structure Now we have disjoint cycles which are symmetric that is and are in the same cycle If we ve won Otherwise let be indices belonging to each of the cycles and let be our current permutation Note that if we define and for and we have another permutation which results in a palindrome and consists of only one cycle so we re done There are different ways of handling the case when is odd the one that requires least casework for this solution is noticing that in the odd case we can still merge symmetric cycles with no issues and that the only thing that could make the last step fail would be to choose some index so that So we have to be careful not to choose and in particular this means that the cycle that contains the middle element can not be a fixed point If the second condition is satisfied this can be achieved easily in the initial permutation we choose Alternative solution Notice that the above solution has complexity because of union find Actually a complexity can be achieved we describe briefly an alternative solution with that complexity We focus on the case when is even The idea is to start with a permutation whose cycles are already symmetric In order to do so we construct a graph whose vertices are the numbers that appear in the sequence and for each we add an edge between and Now note that for each of the connected components of the graph we can obtain a symmetric cycle resulting in a palindrome from an Eulerian tour of the graph 
https://codeforces.com//contest/1359/problem/A,634672,A,1359A,1359,A. Berland Poker,The game of Berland poker is played with a deck of n cards m of which are jokers k players play this game n is divisible by k At the beginning of the game each player takes frac n k cards from the deck so each card is taken by exactly one player The player who has the maximum number of jokers is the winner and he gets the number of points equal to x y where x is the number of jokers in the winner s hand and y is the maximum number of jokers among all other players If there are two or more players with maximum number of jokers all of them are winners and they get 0 points Here are some examples n 8 m 3 k 2 If one player gets 3 jokers and 1 plain card and another player gets 0 jokers and 4 plain cards then the first player is the winner and gets 3 0 3 points n 4 m 2 k 4 Two players get plain cards and the other two players get jokers so both of them are winners and get 0 points n 9 m 6 k 3 If the first player gets 3 jokers the second player gets 1 joker and 2 plain cards and the third player gets 2 jokers and 1 plain card then the first player is the winner and he gets 3 2 1 point n 42 m 0 k 7 Since there are no jokers everyone gets 0 jokers everyone is a winner and everyone gets 0 points Given n m and k calculate the maximum number of points a player can get for winning the game ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        int our = min(n / k, m);\n        int theirs = (m - our + k - 2) / (k - 1);\n        cout << our - theirs << \'\\n\';\n    }\n    return 0;\n}']",,,"['brute force', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Berland Poker.json,https://codeforces.com//blog/entry/78116,There are many different ways to solve this problem The easiest one in my opinion is to iterate on the number of jokers the winner has let it be and the number of jokers the runner up has let it be Then the following conditions should be met the winner doesn t have less jokers than the runner up the number of jokers in the winner s hand does not exceed the number of cards in his hand the number of jokers for these two players does not exceed the total number of jokers it is possible to redistribute remaining jokers among other players so that they have at most jokers Iterating on and then checking these constraints gives us a solution It is possible to get a constant time solution using some greedy assumptions and math the first player should get as many jokers as possible while the remaining jokers should be evenly distributed among other players 
https://codeforces.com//contest/1693/problem/E,1430892,E,1693E,1693,E. Outermost Maximums,Yeri has an array of n 2 non negative integers a 0 a 1 a n a n 1 We know that a 0 a n 1 0 She wants to make all the elements of a equal to zero in the minimum number of operations In one operation she can do one of the following Choose the leftmost maximum element and change it to the maximum of the elements on its left Choose the rightmost maximum element and change it to the maximum of the elements on its right Help her find the minimum number of operations needed to make all elements of a equal to zero ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int n1=(1<<18);\n\nint n;\nint tab[nax];\n\nstruct info\n{\n\tvector<pii> wyj;//first to stan, second to dodanie\n};\n\ninfo operator +(const info &a, const info &b)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tint x=a.wyj[i].first;\n\t\tret.wyj[i]={b.wyj[x].first, b.wyj[x].second+a.wyj[i].second};\n\t}\n\treturn ret;\n}\n\ninfo drz[nax];\n\n//0 to JEDYNKI\nint polew[nax];\nint popra[nax];\n\nll wyn;\n\ninfo daj(int l, int p)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tif (l && p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={0, 1};\n\t\treturn ret;\n\t}\n\tif (!l && !p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={i, 0};\n\t\treturn ret;\n\t}\n\tif (l)\n\t{\n\t\tret.wyj[0]={1, 0};\n\t\tret.wyj[1]={1, 0};\n\t\tret.wyj[2]={0, 1};\n\t\treturn ret;\n\t}\n\tif (p)\n\t{\n\t\tret.wyj[0]={2, 0};\n\t\tret.wyj[1]={0, 1};\n\t\tret.wyj[2]={2, 0};\n\t\treturn ret;\n\t}\n\tassert(0);\n}\n\nvoid upd(int v)\n{\n\tif (!v)\n\t\treturn;\n\tdrz[n1-1+v]=daj(polew[v], popra[v]);\n\tv+=n1-1;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=(drz[2*v+1]+drz[2*v]);\n\t\tv>>=1;\n\t}\n}\n\ninfo glo;\n\nvoid czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tglo=(glo+drz[v]);\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab);\n\tczyt((v<<1), a, (a+b)>>1, graa, grab);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tpopra[tab[i]]++;\n\tfor (int i=1; i<2*n1; i++)\n\t\tdrz[i]=daj(0, 0);\n\tfor (int i=1; i<=n; i++)\n\t\tdrz[n1-1+i]=daj(0, popra[i]);\n\tfor (int i=n1-1; i; i--)\n\t\tdrz[i]=(drz[2*i+1]+drz[2*i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpopra[tab[i]]--;\n\t\tupd(tab[i]);\n\t\tif (tab[i])\n\t\t{\n\t\t\tglo=daj(0, 0);\n\t\t\tczyt(1, 1, n1, 1, tab[i]-1);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)/2].wyj);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)].wyj);\n\t\t\t//~ debug() << imie(drz[(2+n1-1)].wyj);\n\t\t\t//~ debug() << i << "" "" << glo.wyj;\n\t\t\twyn+=glo.wyj[0].second+1;\n\t\t}\n\t\tpolew[tab[i]]++;\n\t\tupd(tab[i]);\n\t}\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['data structures', 'greedy']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Outermost Maximums.json,https://codeforces.com//blog/entry/103952,Let s calculate for each element of the array the minimum number of times it needs to change throughout the process Let s take a look at the first time the th element is changing We know that is the maximum number and the elements smaller than haven t changed yet Denote the maximum element on its left as and the maximum element on its right as So is equal to the largest number among that is smaller than Likewise for We can change to either or It s better to change it to the smaller one We ll get into the details of why this is correct later Let be the minimum number of times the th element needs to change The following greedy algorithm works in operations Let be the number the leftmost maximum becomes if we do the first operation and be the number the rightmost maximum becomes if we do the second operation Do the first operation if and do the second operation otherwise If then for the leftmost maximum the maximum element on its left is smaller than the maximum element on its right That means we are making the right choice for this element Let s assume the array is a permutation of numbers from through for simplicity For some element make string of length such that O for any L for any R Imagine Yeri is initially standing on the th character of S which is O and she is facing the beginning of the string In each step she either jumps to the nearest L or jumps to the nearest R And her goal is to jump out of the string in minimum number of jumps We know it s always better to jump to the further one but we won t need this fact We will use a segment tree For each node maintain 4 values What is the minimum possible number of jumps made in this interval in case we enter it looking for an L and leave it looking for an L we enter it looking for an L and leave it looking for an R we enter it looking for an R and leave it looking for an L we enter it looking for an R and leave it looking for an R It s easy to update this Just fix which character you are looking for when moving from the node s one child to the other And you can find these values for intervals of length Now if you iterate over from to At each step at most 2 characters of the string are changing hence you can keep your segment tree updated But there are still some details we need to sort out The array is not necessarily a permutation To fix this first get rid of the O Then for each number see if it appears on the left side and see if it appears on the right side Now there are 4 different states for each number but the same segment tree can handle this too We just need to find the 4 values for each of the 4 states of a single number Time complexity 
https://codeforces.com//contest/1603/problem/F,1163974,F,1603F,1603,"F. October 18, 2017",You are given three integers n k and x Find the number modulo 998 244 353 of integer sequences a 1 a 2 ldots a n such that the following conditions are satisfied 0 le a i lt 2 k for each integer i from 1 to n There is no non empty subsequence in a such that the bitwise XOR of the elements of the subsequence is x A sequence b is a subsequence of a sequence c if b can be obtained from c by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAXB = 10000000, INV2 = (MOD + 1) / 2;\n\nint ppw[10000005], prp[10000005], pinv[10000005];\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1ULL * ret * x % MOD;\n\t\tx = 1ULL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, k, x;\nvoid solve()\n{\n\tscanf(""%d%d%d"", &n, &k, &x);\n\tif(x == 0) {\n\t\tif(n > k) {\n\t\t\tprintf(""0\\n""); return;\n\t\t}\n\t\tint ret = 1ULL * prp[k] * pinv[k - n] % MOD;\n\t\trep(i, n) ret = 1ULL * ret * ppw[i] % MOD;\n\t\tprintf(""%d\\n"", ret);\n\t} else {\n\t\tint ret = 0, ccf = 1, tmp = power(2, n);\n\t\tfor(int i = 0; i <= k; i ++) {\n\t\t\tint prob = i == 0 ? 1 : (1 + 1ULL * pinv[k] * prp[k - 1] % MOD * (MOD - ppw[i] + 1)) % MOD;\n\t\t\tret = (ret + 1ULL * ccf * pinv[i] % MOD * prob) % MOD;\n\t\t\tccf = 1ULL * ccf * (tmp - 1) % MOD * (ppw[k - i] - 1) % MOD;\n\t\t\ttmp = 1ULL * tmp * INV2 % MOD;\n\t\t\tccf = 1ULL * ccf * ppw[i] % MOD;\n\t\t}\n\t\tprintf(""%d\\n"", ret);\n\t}\n}\n\nint main()\n{\n\tppw[0] = 1;\n\trep1(i, MAXB) ppw[i] = 2 * ppw[i - 1] % MOD;\n\tprp[0] = 1;\n\trep1(i, MAXB) prp[i] = 1ULL * prp[i - 1] * (ppw[i] - 1) % MOD;\n\tpinv[MAXB] = power(prp[MAXB], MOD - 2);\n\tfor(int i = MAXB; i >= 1; i --) pinv[i - 1] = 1ULL * pinv[i] * (ppw[i] - 1) % MOD;\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']",,,"['combinatorics', 'dp', 'implementation', 'math']",2700,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. October 18, 2017.json",https://codeforces.com//blog/entry/96460,When we need to count the number of sequences such that the s are linearly independent Clearly for there are no such sequences and for the answer is as can be any element not generated by the elements and they generate exactly elements Now let s deal with the case It s easy to see that the exact value of doesn t matter here it s easy to construct a bijection between such sequences for this problem and such sequences for the case by change of basis from the one which has as the first element to one which has as the first element So from now on We will show that the answer for given is More generally it s This is easy to calculate in by calculating prefix products in and finding in and its powers in Now let s prove the formula It s possible to prove the formula by some inclusion exclusion arguments but here we will present a bit more combinatorial approach Let s just look at and find some combinatorial interpretation for it Let s consider a linear space of dimension with elements containing Consider all its subspaces of dimension Firstly how many of them are there Exactly each corresponding to the only nonzero element of the orthogonal complement of the subspace It s easy to see that exactly of them will contain and other won t Then there is a natural representation of the number it s the number of sequences of spaces where is the whole space of our problem of dimension For from to is a subspace of of dimension containing is a subspace of of dimension containing Then is the number of sequences where sets are described as above and all elements of lie in as there are ways to choose each of them This starts to resemble what we need As in such structure space generated by won t be able to contain and it s exactly the kind of arrays we are interested in So we want to show that the actual number of arrays from the statement is equal to the number of tuples where the tuple is counted with a plus sign for even and with a minus sign for odd It s enough to prove that each array will be counted exactly once this way meaning that it will be in tuples taken with plus one more time than in tuples taken with a minus Fine let s consider an array such that subspace spanned by it doesn t contain and look at the sequences of sets such that is contained in If the subspace generated by is we just need all spaces to contain If size of is there is a bijection between such sequences and sequences where is the space orthogonal to subspace of dimension For from to is a subspace of of dimension containing is a subspace of of dimension containing But the number of such sequences for a fixed is precisely So we need to show that the sum of this with correspondent signs over from to is Let s replace by we need to show that This is easy to prove by induction as after moving to the right side it s equivalent to and we can cancel from both sides and get the same equation but now for 
https://codeforces.com//contest/891/problem/B,134541,B,891B,891,B. Gluttony,You are given an array with distinct integers Construct an array by permuting such that for every non empty subset of indices the sums of elements on that positions in and are different i e ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=30;\nint n,a[N],b[N];\nPII p[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d"",a+i),p[i]=mp(a[i],i);\n\tsort(p,p+n);\n\trep(i,0,n) b[p[(i+1)%n].se]=p[i].fi;\n\trep(i,0,n) {\n\t\tprintf(""%d "",b[i]);\n\t}\n\tputs("""");\n}\n']",,,"['constructive algorithms', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Gluttony.json,https://codeforces.com//blog/entry/55841,Sort the array and shift it by one This array will be an answer Proof When we shift the sorted array all of the elements become greater except the first one consider and if 1 wasn t in t we would have otherwise consider then 1 can t be in and we have so and we are done 
https://codeforces.com//contest/1163/problem/B1,342104,B1,1163B1,1163,B1. Cat Party  Easy Edition ,Shiro s just moved to the new house She wants to invite all friends of her to the house so they can play monopoly However her house is too small so she can only invite one friend at a time For each of the n days since the day Shiro moved to the new house there will be exactly one cat coming to the Shiro s house The cat coming in the i th day has a ribbon with color u i Shiro wants to know the largest number x such that if we consider the streak of the first x days it is possible to remove day from this streak so that every ribbon color among the remaining x 1 will have the same number of occurrences For example consider the following sequence of u i 2 2 1 1 5 4 4 5 Then x 7 makes a streak since if we remove the leftmost u i 5 each ribbon color will appear exactly twice in the prefix of x 1 days Note that x 8 doesn t form a streak since you must remove exactly one day Since Shiro is just a cat she is not very good at counting and needs your help finding the longest streak ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 6;\nint n, a[N], c[N], d[N], mx, cnt;\nset<int> s;\n\ninline bool pd(int o) {\n\tif (s.size() == 1u && *s.begin() == 1) return 1;\n\tif (s.size() == 1u && *s.begin() == o) return 1;\n\tif (s.size() != 2u) return 0;\n\tint k = *s.begin(), t = *(++s.begin());\n\tif (k == 1 && (cnt - 1) * t == o - 1) return 1;\n\tif (cnt * k == o - 1 && k + 1 == t) return 1;\n\treturn 0;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tc[a[i]]++;\n\t\tmx = max(mx, a[i]);\n\t}\n\tfor (int i = 1; i <= mx; i++)\n\t\tif (c[i] && ++cnt && !d[c[i]]++)\n\t\t\ts.insert(c[i]);\n\tfor (int i = n; i; i--) {\n\t\tif (pd(i)) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!--d[c[a[i]]]) s.erase(c[a[i]]);\n\t\tif (!--c[a[i]]) --cnt;\n\t\tif (c[a[i]] && !d[c[a[i]]]++) s.insert(c[a[i]]);\n\t}\n\treturn 0;\n} ']",,,"['data structures', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B1. Cat Party  Easy Edition .json,https://codeforces.com/blog/entry/66943,We can iterate over all streaks and check for each streak if we can remove one day so that each color has the same number of cats There are 4 cases where we can remove a day from the streak to satisfy the condition There is only one color in this streak All appeared colors in this streak have the occurrence of 1 i e every color has exactly 1 cat with that color Every color has the same occurrence of cats except for exactly one color which has the occurrence of 1 Every color has the same occurrence of cats except for exactly one color which has the occurrence exactly 1 more than any other color All of these four conditions can be checked using counting techniques Complexity O n 
https://codeforces.com//contest/1000/problem/F,193659,F,1000F,1000,F. One Occurrence,You are given an array a consisting of n integers and q queries to it i th query is denoted by two integers l i and r i For each query you have to find integer that occurs in the subarray of a from index l i to index r i a subarray is a contiguous subsegment of an array For example if a 1 1 2 3 2 4 then for query l i 2 r i 6 the subarray we are interested in is 1 2 3 2 4 and possible answers are 1 3 and 4 for query l i 1 r i 2 the subarray we are interested in is 1 1 and there is no such element that occurs exactly once Can you answer all of the queries ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 500500;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint a[N];\nint l[N];\nint r[N];\nint ans[N];\nint used[N];\npair < int, int > t[4 * N];\n\nvoid upd(int x, int l, int r, int g, int y)\n{\n        if(l == r){\n                t[x] = {y, a[l]};\n                return;\n        }\n        int m = (l + r) / 2;\n        if(g <= m){\n                upd(x * 2, l, m, g, y);\n        }\n        else{\n                upd(x * 2 + 1, m + 1, r, g, y);\n        }\n        t[x] = max(t[x * 2], t[x * 2 + 1]);\n}\n\npair < int, int > get(int x, int l, int r, int tl, int tr)\n{\n        if(tl > tr){\n                return {0, 0};\n        }\n        if(l == tl && r == tr){\n                return t[x];\n        }\n        int m = (l + r) / 2;\n        return max(get(x * 2, l, m, tl, min(m, tr)), get(x * 2 + 1, m + 1, r, max(m + 1, tl), tr));\n}\n\nvoid solve()\n{\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n                l[i] = used[a[i]];\n                used[a[i]] = i;\n        }\n        for(int i = 1; i < N; i++){\n                used[i] = n + 1;\n        }\n        vector < pair < int, pair < int, int > > > v;\n        for(int i = n; i >= 1; i--){\n                r[i] = used[a[i]];\n                used[a[i]] = i;\n                v.push_back({l[i], {r[i], i}});\n        }\n        sort(v.begin(), v.end());\n        int q;\n        cin >> q;\n        vector < pair < int, pair < int, int > > > qu;\n        for(int i = 1; i <= q; i++){\n                int l, r;\n                cin >> l >> r;\n                qu.push_back({l, {r, i}});\n        }\n        sort(qu.begin(), qu.end());\n        int h = 0;\n        for(auto p: qu){\n                while(h < v.size() && v[h].fi < p.fi){\n                        upd(1, 1, n, v[h].se.se, v[h].se.fi);\n                        h++;\n                }\n                auto g = get(1, 1, n, p.fi, p.se.fi);\n                if(g.fi > p.se.fi){\n                        ans[p.se.se] = g.se;\n                }\n        }\n        for(int i = 1; i <= q; i++){\n                cout << ans[i] << ""\\n"";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']",,,"['data structures', 'divide and conquer']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. One Occurrence.json,https://codeforces.com/blog/entry/60288,Suppose all queries have the same right border Then the answer for the query can be some integer such that the last occurence of on the prefix of the array is inside the segment but the second to last occurence is outside the segment or even does not exist More formally let be the maximum index such that and or if there is no such the answer to the query is some number such that and and is the rightmost occurence of in the segment For a fixed right border we can build a segment tree which for every index such that is the rightmost occurence of on stores the value of and if we query minimum on the segment in such tree we can try to find the answer Let the position of minimum be If then can be the answer otherwise there is no answer But this is too slow since we can t afford to build a segment tree for every possible value of There are two methods how to deal with this problem you may sort all queries by their right borders and maintain the segment tree while shifting the right border when going from to we have to update the values in the positions and or we may use a persistent segment tree and get an online solution We tried to eliminate solutions using Mo s algorithm but in fact it s possible to squeeze some implementations of it into TL There are two optimizations that might help there When dividing the elements into blocks we may sort the first block in the ascending order of right borders the second in descending the third in ascending order again and so on And also it s possible to obtain a Mo based solution with worst case complexity of if we maintain the set of possible answers using sqrt decomposition on it 
https://codeforces.com//contest/1451/problem/C,804299,C,1451C,1451,C. String Equality,Ashish has two strings a and b each of length n and an integer k The strings only contain lowercase English letters He wants to convert string a into string b by performing some possibly zero operations on a In one move he can either choose an index i 1 leq i leq n 1 and swap a i and a i 1 or choose an index i 1 leq i leq n k 1 and if a i a i 1 ldots a i k 1 are to some character c c neq replace each one with the next character c 1 that is is replaced by is replaced by and so on Note that he can perform any number of operations and the operations can only be performed on string a Help Ashish determine if it is possible to convert string a into b after performing some possibly zero operations on it ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nint ca[30];\nint cb[30];\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tint n,k; cin>>n>>k;\n\t\tmemset(ca,0,sizeof(ca));\n\t\tmemset(cb,0,sizeof(cb));\n\t\tstring a,b; cin>>a>>b;\n\t\tfor(char c:a)\n\t\t{\n\t\t\tca[c-\'a\']++;\n\t\t}\n\t\tfor(char c:b)\n\t\t{\n\t\t\tca[c-\'a\']--;\n\t\t}\n\t\tbool pos=1;\n\t\tfor(int i=0;i<25;i++)\n\t\t{\n\t\t\twhile(ca[i]>=k)\n\t\t\t{\n\t\t\t\tca[i]-=k; ca[i+1]+=k;\n\t\t\t}\n\t\t\tif(ca[i]<0){pos=0; break;}\n\t\t}\n\t\tif(ca[25]<0) pos=0;\n\t\tif(pos) cout<<""Yes\\n"";\n\t\telse cout<<""No\\n"";\n\t}\n}\n']",,,"['dp', 'greedy', 'hashing', 'implementation', 'strings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. String Equality.json,https://codeforces.com//blog/entry/84885,For the answer to be YES the frequencies of each character of the alphabet must match after performing some sequence of operations Let and be the frequencies of the th character of the alphabet in strings and respectively For each starting from we keep exactly of the occurrences and try to to convert the rest into the next character If at any step this is not possible the answer is NO Consider operations of the first type It can be shown that after some finite sequence of swaps we can reorder the string in any way we like This is helpful because we do not have to worry about the characters being adjacent when we perform an operation of the second type we can always reorder the string to allow it In other words only frequency of the characters matter To convert string into string we first make the frequencies of each character of the alphabet equal then reorder the string using operations of the first type The former can be done as described above If for any there are an insufficient number of occurrences or the remaining occurrences cannot all be converted into the next character i e is not a multiple of the answer is NO Otherwise the answer is YES Time complexity 
https://codeforces.com//contest/1741/problem/E,1580861,E,1741E,1741,E. Sending a Sequence Over the Network,The sequence a is sent over the network as follows sequence a is split into segments each element of the sequence belongs to exactly one segment each segment is a group of consecutive elements of sequence for each segment its length is written next to it either to the left of it or to the right of it the resulting sequence b is sent over the network For example we needed to send the sequence a 1 2 3 1 2 3 Suppose it was split into segments as follows color red 1 color blue 2 3 1 color green 2 3 Then we could have the following sequences b 1 color red 1 3 color blue 2 3 1 color green 2 3 2 b color red 1 1 3 color blue 2 3 1 2 color green 2 3 b color red 1 1 color blue 2 3 1 3 2 color green 2 3 b color red 1 1 color blue 2 3 1 3 color green 2 3 2 If a different segmentation had been used the sent sequence might have been different The sequence b is given Could the sequence b be sent over the network In other words is there such a sequence a that converting a to send it over the network could result in a sequence b ,"['#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nvoid solve() {\n  int n; cin >> n;\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) cin >> b[i];\n\n  vector<int> dp(n+1, 0);\n  dp[n] = 1;\n\n  for (int i = n-1; i >= 0; i--) {\n    if (i+1+b[i] <= n) {\n      dp[i] |= dp[i+1+b[i]];\n    }\n    if (i - b[i] >= 0) {\n      dp[i - b[i]] |= dp[i+1];\n    }\n  }\n\n  printf(""%s\\n"", dp[0] ? ""YES"" : ""NO"");\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n']",,,['dp'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Sending a Sequence Over the Network.json,https://codeforces.com//blog/entry/107908,Let s introduce the dynamics if on the prefix the answer is Then in this sequence the numbers corresponding to the sizes of the segments from the partition into subsegments will be called A number at position in the sequence if it is is either to the right or to the left of the segment If it is to the left of the segment it can only be interesting if Then If it is on the right side of the segment then if then The answer for the whole sequence is if 
https://codeforces.com//contest/1712/problem/C,1501805,C,1712C,1712,C. Sort Zero,A Young BoyYou are given an array of n integers a 1 a 2 ldots a n In one operation you do the following Choose integer x For all i such that a i x do a i 0 assign 0 to a i Find the minimum number of operations required to sort the array in non decreasing order ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define int long long\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n\nint T,n,ans,i,j,k,a[N],c[N],pos[N],gg,tot; \nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tc[i]=0;pos[i]=0;\n\t\t}\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i],pos[a[i]]=max(i,pos[a[i]]);\n\t\t}\n\t\ta[0]=1e9;\n\t\tfor(i=n;~i;--i)if(a[i]<a[i-1]){gg=i-1;break;}\n\t\tif(gg==0){\n\t\t\tcout<<0<<""\\n"";\n\t\t}\n\t\telse{\n\t\t\ttot=0;\n\t\t\tfor(i=1;i<=n;++i){\n\t\t\t\tif(!c[a[i]])++tot,c[a[i]]=1,gg=max(gg,pos[a[i]]);\n\t\t\t\tif(i>=gg){cout<<tot<<""\\n"";break;}\n\t\t\t}\n\t\t}\n\t}\n}']",,,"['greedy', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Sort Zero.json,https://codeforces.com//blog/entry/105919,An array is sorted in non decreasing order if and only if there is no index such that This leads to a strategy while there is at least one such index apply one operation with Why is this optimal Since our operation can only decrease values and we must decrease so that is no longer true this leaves us no choice but to use the operation with You can simulate this strategy by maintaining a set of bad indices since if an index becomes bad after you apply an operation with it can never become bad again So in total there are at most operations with the set Complexity or depending on which set you use Note you can solve the problem in by noticing that if an index is bad we need to apply the operation for all unique non zero values in This is also quite a bit shorter to code 
https://codeforces.com//contest/1775/problem/C,1730875,C,1775C,1775,C. Interesting Sequence,Petya and his friend robot Petya like to solve exciting math problems One day Petya came up with the numbers n and x and wrote the following equality on the board n n 1 dots m x where denotes the bitwise AND operation Then he suggested his friend Petya find such a minimal m m ge n that the equality on the board holds Unfortunately Petya couldn t solve this problem in his head and decided to ask for computer help He quickly wrote a program and found the answer Can you solve this difficult problem ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tint n,x;\n\t\tcin>>n>>x;\n\t\t\n\t\tint res=n^x;\n\t\t\n\t\tif (n==x) cout<<n<<endl;\n\t\telse if (x==0) cout<<(2LL<<__lg(n))<<endl;\n\t\telse if ((n&x)==x && __builtin_ctzll(n^res)>__lg(res)+1){\n\t\t\tint temp=2LL<<__lg(res);\n\t\t\tn-=n&(temp-1);\n\t\t\tn|=temp;\n\t\t\tcout<<n<<endl;\n\t\t}\n\t\telse cout<<""-1""<<endl;\n\t}\n}\n']",,,"['bitmasks', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Interesting Sequence.json,https://codeforces.com//blog/entry/111286,Note that the answer will be when AND This holds if there is a bit with number which exists in number but it does not exist in number What is clear now is that some bits in must be zeroed Since we have bitwise AND going sequentially with numbers larger than we change the bits from the lowest to the highest Thus in number some bit prefix is zeroed out so if number is not number with a zeroed prefix possibly empty of bits then there is no answer Now we can calculate for each bit the minimal number such that AND AND AND has in the th bit Now calculate as the maximum on all bits to be zeroed and as the minimum on all bits to be left untouched Then if we will take as the answer otherwise there is no answer The problem can also be solved by binary search we will use it to find and check the answer by the formula for each bit find the nearest at which it will be zeroed We can do this using the following fact for th bit the first numbers starting from zero will not contain it then will then again will not and so on Such a solution works for 
https://codeforces.com//contest/356/problem/B,3677,B,356B,356,B. Xenia and Hamming,Xenia is an amateur programmer Today on the IT lesson she learned about the Hamming distance The Hamming distance between two strings and of equal length is value Record is the Iverson notation and represents the following if it is one otherwise zero Now Xenia wants to calculate the Hamming distance between two long strings and The first string is the concatenation of copies of string that is The second string is the concatenation of copies of string Help Xenia calculate the required Hamming distance given ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint ca[N][26], cb[N][26];\nchar x[N], y[N];\n\nint gcd(int a, int b) {\n  while (a > 0 && b > 0)\n    if (a > b) a %= b;\n    else b %= a;\n  return a + b;\n}\n\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  scanf(""%s"", x);\n  scanf(""%s"", y);\n  int a = strlen(x);\n  int b = strlen(y);\n  int g = gcd(a, b);\n  for (int i = 0; i < g; i++)\n    for (int j = 0; j < 26; j++) ca[i][j] = cb[i][j] = 0;\n  for (int i = 0; i < a; i++) ca[i % g][x[i] - \'a\']++;\n  for (int i = 0; i < b; i++) cb[i % g][y[i] - \'a\']++;\n  long long matches = 0;\n  for (int i = 0; i < g; i++)\n    for (int j = 0; j < 26; j++) matches += (long long)ca[i][j] * cb[i][j];\n  long long total = n * a;\n  matches *= (n / (b / g));\n  cout << (total - matches) << endl;\n  return 0;\n}\n']",,,"['implementation', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Xenia and Hamming.json,https://codeforces.com/blog/entry/9210,Let s denote the length of the first string as the length of the second string as Let It s obvious that is a period of the long strings and so we can find the distance of its prefixes of length and multiply the answer by Let s fix the position in the string and think about all characters from the second string it will be compared with It it easy to conclude that it will be compared with such that where For each possible remainder of division by and for each character we can calculate the number of characters that appear in in such positions that When calculating the Hamming distance the character will be compared with exactly characters from that are equal to it all other comparisons will add one to the distance 
https://codeforces.com//contest/776/problem/D,95208,D,776D,776,D. The Door Problem,Moriarty has trapped people in distinct rooms in a hotel Some rooms are locked others are unlocked But there is a condition that the people in the hotel can only escape when all the doors are unlocked at the same time There are switches Each switch control doors of some rooms but each door is controlled by switches You are given the initial configuration of the doors Toggling any switch that is turning it ON when it is OFF or turning it OFF when it is ON toggles the condition of the doors that this switch controls Say we toggled switch which was connected to room and which were respectively locked unlocked and unlocked Then after toggling the switch they become unlocked locked and locked You need to tell Sherlock if there exists a way to unlock all doors at the same time ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, w[101000], P[101000][2], PC[101000];\nvector<int>E[201000];\nbool v[201000];\nint SCC[201000], cnt, ord[201000];\nvoid DFS(int a){\n    v[a]=true;\n    int i;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n    ord[++cnt] = a;\n}\nvoid DFS2(int a){\n    SCC[a] = cnt;\n    int i;\n    for(i=0;i<E[a].size();i++){\n        if(!SCC[E[a][i]])DFS2(E[a][i]);\n    }\n}\nint main(){\n    int i;\n    scanf(""%d%d"",&n,&m);\n    for(i=1;i<=n;i++){\n        scanf(""%d"",&w[i]);\n    }\n    for(i=1;i<=m;i++){\n        int c, a;\n        scanf(""%d"",&c);\n        while(c--){\n            scanf(""%d"",&a);\n            P[a][PC[a]++] = i;\n        }\n    }\n    for(i=1;i<=n;i++){\n        if(w[i] == 0){\n            E[P[i][0]].push_back(P[i][1] + m);\n            E[P[i][1]].push_back(P[i][0] + m);\n            E[P[i][0] + m].push_back(P[i][1]);\n            E[P[i][1] + m].push_back(P[i][0]);\n        }\n        else{\n            E[P[i][0]].push_back(P[i][1]);\n            E[P[i][1]].push_back(P[i][0]);\n            E[P[i][0] + m].push_back(P[i][1] + m);\n            E[P[i][1] + m].push_back(P[i][0] + m);\n        }\n    }\n    for(i=1;i<=m+m;i++){\n        if(!v[i])DFS(i);\n    }\n    cnt = 0;\n    for(i=m+m;i>=1;i--){\n        if(!SCC[ord[i]]){\n            cnt++;\n            DFS2(ord[i]);\n        }\n    }\n    for(i=1;i<=m;i++){\n        if(SCC[i]==SCC[i+m]){\n            printf(""NO\\n"");\n            return 0;\n        }\n    }\n    printf(""YES\\n"");\n}']",,,"['2-sat', 'dfs and similar', 'dsu', 'graphs']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. The Door Problem.json,https://codeforces.com//blog/entry/50622,Hint Try to model the situation as a graph with rooms as edges and switches as nodes Editorial All rooms are represented as edges Mark the edges as if the room is open else mark the edge as closed The answer will be YES if you can color the graph in such a manner that the edges having value have both nodes under different color if the door is locked then one of the switches should be selected and the edges having have both nodes under same color if the door is unlocked you should either select both switches or neither of them For checking the same start a bfs from switch and toggle it and proceed if you are able to color all of the switches then the answer is YES else it is not possible See the setter s solution for implementation details 
https://codeforces.com//contest/58/problem/C,304,C,58C,58,C. Trees,On Bertown s main street trees are growing the tree number has the height of meters By the arrival of the President of Berland these trees were decided to be changed so that their heights formed a sequence This means that the heights of trees on ends the st one and the th one should be equal to each other the heights of the nd and the th tree must also be equal to each other at that the height of the nd tree should be larger than the height of the first tree by and so on In other words the heights of the trees standing at equal distance from the edge of one end of the sequence must be equal to each other and with the increasing of the distance from the edge by the tree height must also increase by For example the sequences and are beautiful and and are not Changing the height of a tree is a very expensive operation using advanced technologies invented by Berland scientists In one operation you can choose any tree and change its height to any number either increase or decrease Note that even after the change the height should remain a positive integer i e it can t be less than or equal to zero Identify the smallest number of changes of the trees height needed for the sequence of their heights to become beautiful ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define MM(a , x) memset(a , x , sizeof(a))\n#define sqr(x) ((x) * (x))\n#define abs(x) ((x > 0) ? (x) : -(x))\n#define REP(i , n) for ((i) = 0; (i) < (n); ++(i))\n#define FOR(i , a , b) for ((i) = (a); (i) <= (b); ++(i))\n#define FORD(i , a , b) for ((i) = (a); (i) >= (b); --(i))\ntypedef long long LL;\n\nconst int maxn = 100008;\n\nint n , m , tot , ans;\nint a[maxn] , cnt[maxn * 2];\n\nvoid init()\n{\n\tscanf(""%d"" , &n);\n\tint i , j;\n\tFOR (i , 1 , n) scanf(""%d"" , &a[i]);\n\tMM(cnt , 0);\n\tj = 1;\n\tFOR (i , 1 , n / 2) cnt[maxn + a[i] - j]++ , j++;\n\tif (n % 2 == 0) j--;\n\tFOR (i , n / 2 + 1 , n) cnt[maxn + a[i] - j]++ , j--;\n}\n\nvoid work()\n{\n\tans = n;\n\tint i , j , k;\n\tFOR (i , maxn + 0 , maxn + 99999) ans = min(ans , n - cnt[i]);\n\tprintf(""%d\\n"" , ans);\n}\n\nint main()\n{\n\tinit();\n\twork();\n\treturn 0;\n}\n\n']",,,['brute force'],1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Trees.json,https://codeforces.com//blog/entry/1771,Case 101 1 1 2 3 3 2 1 1 1 Answer should be 8 correct sequence 1 2 3 4 5 5 4 3 2 1 Wrong answer is 4 Assumes the correct sequence is 1 0 1 2 3 3 2 1 0 1 Wrong submission 51244937Correct submission 51245002 
https://codeforces.com//contest/1614/problem/A,1203038,A,1614A,1614,A. Divan and a Store,Businessman loves chocolate Today he came to a store to buy some chocolate Like all businessmen knows the value of money so he will not buy too expensive chocolate At the same time too cheap chocolate tastes bad so he will not buy it as well The store he came to has n different chocolate bars and the price of the i th chocolate bar is a i dollars considers a chocolate bar too expensive if it costs strictly more than r dollars Similarly he considers a bar of chocolate to be too cheap if it costs strictly less than l dollars Divan will not buy too cheap or too expensive bars is not going to spend all his money on chocolate bars so he will spend at most k dollars on chocolates Please determine the maximum number of chocolate bars can buy ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tint T;\n\tfor(cin >> T ; T ; --T){\n\t\tint N , L , R , K; vector < int > A; cin >> N >> L >> R >> K;\n\t\tfor(int i = 1 ; i <= N ; ++i){int x; cin >> x; if(x >= L && x <= R) A.push_back(x);}\n\t\tsort(A.begin() , A.end() , [&](int p , int q){return p > q;}); int cnt = 0; while(A.size() && A.back() <= K){K -= A.back(); A.pop_back(); ++cnt;}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Divan and a Store.json,https://codeforces.com//blog/entry/97283,Solution To solve this problem let s use the following greedy algorithm Let s sort the prices of chocolate bars in increasing order after which we will go from left to right and take chocolates that have a price not less than but not more than until we run out of money The number of chocolate bars that we took will be the answer to the problem The resulting asymptotics in time 
https://codeforces.com//contest/954/problem/I,167346,I,954I,954,I. Yet Another String Matching Problem,Suppose you have two strings and and their length is equal You may perform the following operation any number of times choose two different characters and and replace every occurence of in both strings with Let s denote the between strings and as the minimum number of operations required to make these strings equal For example if is and is the between them is we may replace every occurence of with so becomes and then we may replace every occurence of with so both strings become You are given two strings and For every substring of consisting of characters you have to determine the between this substring and ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\n#define MN 262144\nconst double pi=acos(-1);\nstruct cp\n{\n\tdouble r,i;\n\tcp(double r=0,double i=0):r(r),i(i){}\n\tcp operator+(cp b){return cp(r+b.r,i+b.i);}\n\tcp operator-(cp b){return cp(r-b.r,i-b.i);}\n\tcp operator*(cp b){return cp(r*b.r-i*b.i,r*b.i+i*b.r);}\n}w[2][MN+5],x[MN+5],y[MN+5];\nint N,R[MN+5],u[MN+5][6][6],f[6];\nchar a[MN+5],b[MN+5];\nint gf(int k){return f[k]<0?k:f[k]=gf(f[k]);}\nvoid init(int n)\n{\n\tfor(N=1;N<=n;N<<=1);\n\tcp g(cos(2*pi/N),sin(2*pi/N));int i,j,k;\n\tfor(i=w[0][0].r=1;i<N;++i)w[0][i]=w[0][i-1]*g;\n\tfor(i=w[1][0].r=1;i<N;++i)w[1][i]=w[0][N-i];\n\tfor(i=j=0;i<N;R[++i]=j)for(k=N>>1;(j^=k)<k;k>>=1);\n}\nvoid fft(cp*x,int v)\n{\n\tint i,j,k;\n\tfor(i=0;i<N;++i)if(i<R[i])swap(x[i],x[R[i]]);\n\tfor(i=1;i<N;i<<=1)for(j=0;j<N;j+=i<<1)for(k=0;k<i;++k)\n\t{\n\t\tcp p=x[i+j+k]*w[v][N/(i<<1)*k];\n\t\tx[i+j+k]=x[j+k]-p;x[j+k]=x[j+k]+p;\n\t}\n\tif(v)for(i=0;i<N;++i)x[i].r/=N,x[i].i/=N;\n}\nint main()\n{\n\tint n,m,i,j,k,ans=0;\n\tscanf(""%s%s"",a+1,b+1);\n\tn=strlen(a+1);m=strlen(b+1);init(n+n);\n\tfor(i=0;i<6;++i)for(j=0;j<6;++j)if(i!=j)\n\t{\n\t\tmemset(x,0,sizeof(x));memset(y,0,sizeof(y));\n\t\tfor(k=1;k<=n;++k)x[k]=a[k]==i+\'a\';\n\t\tfor(k=1;k<=m;++k)y[n-k]=b[k]==j+\'a\';\n\t\tfft(x,0);fft(y,0);\n\t\tfor(k=0;k<N;++k)x[k]=x[k]*y[k];\n\t\tfft(x,1);\n\t\tfor(k=0;k<=n-m;++k)u[k][i][j]=x[n+k].r>0.5;\n\t}\n\tfor(k=0;k<=n-m;++k)\n\t{\n\t\tmemset(f,-1,sizeof(f));ans=0;\n\t\tfor(i=0;i<6;++i)for(j=0;j<6;++j)if(u[k][i][j]&&gf(i)!=gf(j))f[gf(i)]=gf(j),++ans;\n\t\tprintf(""%d "",ans);\n\t}\n\treturn 0;\n}']",,,"['fft', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\I. Yet Another String Matching Problem.json,https://codeforces.com//blog/entry/58519,Unfortunately it seems we failed to eliminate bitset solutions The approach in our model solution is the following Firstly let s try to find some naive solution for calculating the distance between two strings We may build an undirected graph where vertices represent letters and edges represent that one letter must be transformed into another Then all letters in the same component should become one letter so the answer is the number of distinct letters minus the number of components Then let s get back to original problem For every substring of we have to find which letters have to be merged to make it equal with This can be done with the help of FFT to find all positions in substrings of with character that coincide with occurences of in we may compute a convolution of two following arrays set to every position in where occurs and to every position in where occurs all other elements should be After trying these convolutions for every pair of different characters we compute the answer for every substring using DFS or any other method 
https://codeforces.com//contest/616/problem/A,45344,A,616A,616,A. Comparing Two Long Integers,You are given two very long integers leading zeroes are allowed You should check what number or is greater or determine that they are equal The input size is very large so don t use the reading of symbols one by one Instead of that use the reading of a whole line or token As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in Don t use the function in instead of it use the function ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\nchar a[2000000];\nchar b[2000000];\n\n\nint main() {\n\tscanf("" %s"", a);\n\tscanf("" %s"", b);\n\tint na = strlen(a);\n\tint nb = strlen(b);\n\tchar *a1 = a;\n\tchar *b1 = b;\n\twhile (na > 1 && a1[0] == \'0\') {\n\t\t++a1;\n\t\t--na;\n\t}\n\twhile (nb > 1 && b1[0] == \'0\') {\n\t\t++b1;\n\t\t--nb;\n\t}\n\tif (na != nb) {\n\t\tif (na > nb)\n\t\t\tcout << "">"";\n\t\telse\n\t\t\tcout << ""<"";\n\t}\n\telse {\n\t\tint x = strcmp(a1, b1);\n\t\tif (x == 0)\n\t\t\tcout << ""="";\n\t\telse if (x < 0)\n\t\t\tcout << ""<"";\n\t\telse\n\t\t\tcout << "">"";\n\t}\n\treturn 0;\n}\n\n\n']",,,"['implementation', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Comparing Two Long Integers.json,https://codeforces.com//blog/entry/22712,Note that solutions in Java with BigInteger class or input function in Python2 will fail in this problem The reason is the next standard objects stores numbers not in decimal system and need a lot of time to convert numbers from decimal system Actually they are working in where is the legth of the number To solve this problem you should simply read the numbers to strings and add leading zeroes to the shorter one until the numbers will be of the same length After that you should simply compare them alphabetically solution Python solution Complexity 
https://codeforces.com//contest/1398/problem/D,699504,D,1398D,1398,D. Colored Rectangles,You are given three multisets of pairs of colored sticks R pairs of red sticks the first pair has length r 1 the second pair has length r 2 dots the R th pair has length r R G pairs of green sticks the first pair has length g 1 the second pair has length g 2 dots the G th pair has length g G B pairs of blue sticks the first pair has length b 1 the second pair has length b 2 dots the B th pair has length b B You are constructing rectangles from these pairs of sticks with the following process take a pair of sticks of one color take a pair of sticks of another color different from the first one add the area of the resulting rectangle to the total area Thus you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color Each pair of sticks can be used at most once some pairs can be left unused You are not allowed to split a pair into independent sticks What is the maximum area you can achieve ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 202;\nint a[N], b[N], c[N];\nint dp[N][N][N];\nint n, m, k;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(""%d"", &b[i]);\n\tsort(b, b + m);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(""%d"", &c[i]);\n\tsort(c, c + k);\n\n\tfor (int i = n; i >= 0; i--)\n\t\tfor (int j = m; j >= 0; j--)\n\t\t\tfor (int h = k; h >= 0; h--) {\n\t\t\t\tif (i > 0 && j > 0)\n\t\t\t\t\tdp[i - 1][j - 1][h] = max(dp[i - 1][j - 1][h], dp[i][j][h] + a[i - 1] * b[j - 1]);\n\t\t\t\tif (i > 0 && h > 0)\n\t\t\t\t\tdp[i - 1][j][h - 1] = max(dp[i - 1][j][h - 1], dp[i][j][h] + a[i - 1] * c[h - 1]);\n\t\t\t\tif (j > 0 && h > 0)\n\t\t\t\t\tdp[i][j - 1][h - 1] = max(dp[i][j - 1][h - 1], dp[i][j][h] + b[j - 1] * c[h - 1]);\n\t\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= m; j++)\n\t\t\tfor (int h = 0; h <= k; h++)\n\t\t\t\tans = max(ans, dp[i][j][h]);\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']",,,"['dp', 'greedy', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Colored Rectangles.json,https://codeforces.com//blog/entry/81506,Let s build some rectangles and take a look at the resulting pairings For example consider only red green rectangles Let the rectangles be Sort them in a non decreasing order of I claim that in the most optimal set are also sorted in a non decreasing order It s easy to prove with some induction Moreover if there are some green or red sticks that are not taken and that are longer than the smallest taken corresponding sticks then it s always optimal to take those instead These facts helps us to conclude that from each set only some suffix of the largest sticks are taken And they also give us the idea of the solution sort the sticks in each set and pick the largest from any of the two sets into a pair until no pairs can be taken However the greedy approach of take from any two of the three sets is incorrect We need to choose these two sets smartly Let store the maximum total area that can be obtained by taking largest red sticks largest green sticks and largest blue sticks Each transition chooses a pair of colors and takes the next pairs in both of them The answer is the maximum value in all the Overall complexity 
https://codeforces.com//contest/653/problem/D,52182,D,653D,653,D. Delivery Bears,Niwel is a little golden bear As everyone knows bears live in forests but Niwel got tired of seeing all the trees so he decided to move to the city In the city Niwel took on a job managing bears to deliver goods The city that he lives in can be represented as a directed graph with nodes and edges Each edge has a weight capacity A delivery consists of a bear carrying weights with their bear hands on a simple path from node to node The total weight that travels across a particular edge must not exceed the weight capacity of that edge Niwel has bears In the interest of fairness no bear can rest and the weight that each bear carries must be exactly the same However each bear may take different paths if they like Niwel would like to determine what is the maximum amount of weight he can deliver it s the sum of weights carried by bears Find the maximum weight ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=0x20202020;\ntypedef int flowt;\nnamespace flow {\n\tconst int M=100000,N=1000;\n\tint y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\n\tflowt f[M];\n\tint S,T,tot,Tn;\n\tvoid init(int s,int t,int tn) {\n\t\ttot=1; assert(tn<N);\n\t\trep(i,0,tn) fst[i]=0;\n\t\tS=s;T=t;Tn=tn;\n\t}\n\tvoid add(int u,int v,flowt c1,flowt c2=0) {\n\t\ttot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\n\t\ttot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\n\t}\n\tflowt sap() {\n\t\tint u=S,t=1;flowt flow=0;\n\t\trep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\n\t\tq[0]=T;dis[T]=0;pre[S]=0;\n\t\trep(i,0,t) {\n\t\t\tint u=q[i];\n\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (dis[y[j]]>dis[u]+1&&f[j^1]) \n\t\t\t\tq[t++]=y[j],dis[y[j]]=dis[u]+1;\n\t\t}\n\t\trep(i,0,Tn) gap[dis[i]]++;\n\t\twhile (dis[S]<=Tn) {\n\t\t\twhile (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\n\t\t\tif (c[u]) {\n\t\t\t\tpre[y[c[u]]]=c[u]^1;\n\t\t\t\tu=y[c[u]];\n\t\t\t\tif (u==T) {\n\t\t\t\t\tflowt minf=inf;\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\n\t\t\t\t\tflow=min(flow+minf,inf);u=S;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(--gap[dis[u]])) break;\n\t\t\t\tint mind=Tn;\n\t\t\t\tc[u]=fst[u];\n\t\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind) \n\t\t\t\t\tmind=dis[y[j]],c[u]=j;\n\t\t\t\tdis[u]=mind+1;\n\t\t\t\tgap[dis[u]]++;\n\t\t\t\tif (u!=S) u=y[pre[u]];\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nconst int M=1010;\nint n,m,k,u[M],v[M],w[M];\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&k);\n\trep(i,0,m) {\n\t\tscanf(""%d%d%d"",u+i,v+i,w+i); --u[i],--v[i];\n\t}\n\tdouble l=1./k,r=1e6;\n\trep(rd,0,60) {\n\t\tdouble md=(l+r)*0.5;\n\t\tflow::init(0,n-1,n);\n\t\trep(i,0,m) {\n\t\t\tflow::add(u[i],v[i],(int)min(w[i]/md,(double)k+1e-10));\n\t\t}\n\t\tif (flow::sap()>=k) l=md; else r=md;\n\t}\n\tprintf(""%.10f\\n"",r*k);\n}\n']",,,"['binary search', 'flows', 'graphs']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Delivery Bears.json,https://codeforces.com//blog/entry/43886,Let s transform this into a flow problem Here we transform weight into flow and each bear becomes a path Suppose we just want to find the answer for a single We can do this binary search on the flow for each path To check if a particular flow of is possible reduce the capacity of each edge from to Then check if the max flow in this graph is at least The final answer is then multiplied by the flow value that we found MUCH HARDER VERSION you are also given an integer and your task is to find the answer for paths for paths and for paths There should be real values on the output The solution of the harder version However this is not fast enough when we have up to 10 4 values of x to check Instead we look at a fast way of getting the flow value for x 1 paths given a flow with x paths in only O m log m time Suppose we ve found the paths for x bears and we know that the number of bears who use edge number i is w i Also let f x be the weight that each bear carries given that there are x bears Then we can create a residual graph as follows For each edge u i v i with capacity c i create an edge in th residual graph from u i to v i with capacity c i 1 w i and if w i 0 a backward edge with capacity f x Then we can find the fattest path in this graph with a dijsktra s in O m log m giving us f x 1 This also allows us to update our paths In particular if we use a backwards edge we subtract the number of times the edge is used by 1 otherwise we increase it by 1 This allows us to construct a new residual graph It can be shown that this only results in at most one new path We can prove that this is correct by induction Suppose the answer is correct for x bears Now one observation is that f x 1 must be less than or equal to f x as any plan that x 1 bears follow will also be able to be executed with x bears Suppose the optimal solution for x 1 bears is actually g x 1 We just need to argue that f x 1 g x 1 and we are done In the optimal solution consider replacing each edge with capacity c i to floor c i g x 1 Now consider the optimal paths for x bears in this reduced capacity graph which we found through induction Since there are only x bears but we know we can support x 1 bears there exists a path in the residual graph from the source to the sink Let s look at the capacity of this path If we travel along any backward edge the capacity of that edge is f x which is at least g x 1 If we travel on a forward edge we have c i 1 w i g x 1 c i 1 w i g x 1 The second inequality follows from reversing the divide by g x 1 step Thus the overall running time is O mn 2 log m x k m log m where the first part comes from the initial binary search and the second part comes from doing k fattest path computations 
https://codeforces.com//contest/1882/problem/A,2227514,A,1882A,1882,A. Increasing Sequence,You are given a sequence a 1 a 2 ldots a n A sequence b 1 b 2 ldots b n is called if it satisfies all of the following conditions b i is a positive integer for i 1 2 ldots n b i neq a i for i 1 2 ldots n b 1 b 2 ldots b n Find the minimum value of b n among all good sequences b 1 b 2 ldots b n ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T,ans,flg;\nint a[maxn];\nstring s;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\tint s=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&a[i]);\n\t\t\ts++;\n\t\t\twhile(s==a[i])\n\t\t\t\ts++;\n\t\t}\n\t\tprintf(""%d\\n"",s);\n\t}\n\treturn 0;\n}\n']",,,['greedy'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Increasing Sequence.json,https://codeforces.com//blog/entry/120792,TutorialGreedy solution Continue constructing as small as possible If Else For if Else calculated by this process is the answer Time complexity is per test case 
https://codeforces.com//contest/2025/problem/F,2948776,F,2025F,2025,F. Choose Your Queries,You are given an array a consisting of n integers numbered from 1 to n Initially they are all zeroes You have to process q queries The i th query consists of two different integers x i and y i During the i th query you have to choose an integer p which is either x i or y i and an integer d which is either 1 or 1 and assign a p a p d After each query every element of a should be a non negative integer Process all queries in such a way that the sum of all elements of a after the last query is the minimum possible ,"['#include <bits/stdc++.h>\xa0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, q;    std::cin >> n >> q;        std::vector<int> x(q), y(q);    std::vector<std::vector<std::array<int, 2>>> adj(n);    for (int i = 0; i < q; i++) {        std::cin >> x[i] >> y[i];        x[i]--;        y[i]--;        adj[x[i]].push_back({y[i], 2 * i});        adj[y[i]].push_back({x[i], 2 * i + 1});    }        std::vector<bool> vis(n);    std::vector<int> dep(n);        std::vector<std::string> ans(q, ""x+"");         auto match = [&](int i, int j, int x) {        ans[i / 2][1] = (i < j ? \'+\' : \'-\');        ans[j / 2][1] = (i < j ? \'-\' : \'+\');        ans[i / 2][0] = ""xy""[i % 2];        ans[j / 2][0] = ""xy""[j % 2];    };        for (int s = 0; s < n; s++) {        if (vis[s]) {            continue;        }        auto dfs = [&](auto &self, int x, int p) -> int {            vis[x] = true;            int c = -1;            for (auto [y, i] : adj[x]) {                if (vis[y]) {                    if (dep[y] > dep[x]) {                        if (c != -1) {                            match(c, i, x);                            c = -1;                        } else {                            c = i;                        }                    }                } else {                    dep[y] = dep[x] + 1;                    int d = self(self, y, i);                    if (d != -1) {                        match(i ^ 1, d, y);                    } else {                        if (c != -1) {                            match(c, i, x);                            c = -1;                        } else {                            c = i;                        }                    }                }            }            return c;        };        dfs(dfs, s, -1);    }        for (int i = 0; i < q; i++) {        std::cout << ans[i] << ""\\n"";    }        return 0;}']",,,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Choose Your Queries.json,https://codeforces.com//blog/entry/135173,We will use the classical method for solving maximization minimization problems we will come up with an estimate for the answer and try to achieve it constructively The first idea Since we have objects connected by binary relations we can model the problem as a graph Let the elements of the array be the vertices and the queries be the edges For each query we would like to choose the direction of the edge let the edge be directed towards the vertex to which the operation is applied and the sign of the operation It would be great if in each connected component we could choose an equal number of pluses and minuses so that the sum equals zero Or if the number of edges in the component is odd to make the sum equal to one Obviously it is not possible to do less than this It turns out that this is always possible There is a well known graph problem to split the edges of an undirected connected graph into pairs with at least one common endpoint We will reduce our problem to this one If we split the graph into pairs we will construct the answer from them as follows we will direct the edges of each pair towards any common vertex write on the edge with the smaller number query index and write on the edge with the larger number This construction guarantees that each pair will not add anything to the sum and each element will be non negative after each query The problem of splitting into pair can be solved using the following algorithm We will perform a DFS from any vertex and construct a DFS tree Now we will divide the edges into pairs in the order from the leaves to the root Let us stand at some vertex First run the algorithm recursively for the children of When we finish processing the children we will consider the following edges from the current vertex tree edges to the children the edge to the parent and back edges with the lower endpoint at Now we form as many pairs as possible from the edges to the children and the back edges We will remove all such edges from the graph If their total number was odd then one edge remains unpaired Form a pair from it and the edge to the parent and again remove them from the graph It turns out that when we exit the recursive call either there will be no edges left in the subtree at all or there will be one tree edge that will be processed by the parent later If the number of edges in the component is odd then at the end one edge without a pair will remain at the root I would also like to mention the following implementation details In the adjacency list it is better to store the indices of the queries rather than the vertices and then derive the vertex numbers from them This will allow for careful handling of multiple edges Removing edges from the graph directly is also not very convenient The most convenient way to work around this in my opinion is to maintain an array that marks that the edge with such a query number is now removed Alternatively for back edges we can check whether is the upper or lower endpoint as well as return a flag from the depth first search indicating is the edge to the child removed Overall complexity 
https://codeforces.com//contest/1065/problem/C,235280,C,1065C,1065,C. Make It Equal,There is a toy building consisting of n towers Each tower consists of several cubes standing on each other The i th tower consists of h i cubes so it has height h i Let s define operation on some height H as following for each tower i if its height is greater than H then remove some top cubes to make tower s height equal to H Cost of one slice equals to the total number of removed cubes from all towers Let s name slice as one if its cost is lower or equal to k k ge n Calculate the minimum number of good slices you have to do to make all towers have the same height Of course it is always possible to make it so ,"['/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << "" is "" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(""%d"", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return (\'a\' <= x && x <= \'z\'); }\ninline bool is_upper(char x) { return (\'A\' <= x && x <= \'Z\'); }\ninline bool is_digit(char x) { return (\'0\' <= x && x <= \'9\'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 1e4 + 239;\n\nint n;\nll k, kol[M];\n\nint main()\n{\n    #ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> k;\n    for (int i = 0; i < n; i++)\n    {\n        int h;\n        cin >> h;\n        kol[0]++;\n        kol[h]--;\n    }\n    for (int i = 1; i < M; i++)\n        kol[i] += kol[i - 1];\n    int ans = 0;\n    ll sum = 0;\n    for (int i = M - 1; i >= 0; i--)\n    {\n        if (kol[i] == n)\n        {\n            ans += (sum > 0);\n            break;\n        }\n        if (sum + kol[i] > k)\n        {\n            ans++;\n            sum = kol[i];\n            continue;\n        }\n        sum += kol[i];\n    }\n    cout << ans;\n    return 0;\n}\n']",,,['greedy'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Make It Equal.json,https://codeforces.com//blog/entry/62411,Let s iterate over height of slice in decreasing order All we need to know is a number of towers with height more than name it and sum of its heights Current slice on height is good if Let s greedily decrease value while slice on is good keeping correct values and When we found minimal good slice we can perform it increasing answer by one and changing tower heights just by setting new value to equal to Finish algorithm when becomes equal to minimal height of towers and make final slice 
https://codeforces.com//contest/1261/problem/F,479751,F,1261F,1261,F. Xor-Set,You are given two sets of integers A and B You need to output the sum of elements in the set C x x a oplus b a in A b in B modulo 998244353 where oplus denotes the bitwise XOR operation Each number should be counted only once For example if A 2 3 and B 2 3 you should count integer 1 only once despite the fact that you can get it as 3 oplus 2 and as 2 oplus 3 So the answer for this case is equal to 1 0 1 Let s call a segment l r a set of integers l l 1 dots r The set A is given as a union of n A segments the set B is given as a union of n B segments ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nint inverse(int a, int m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  int b = m, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nconst int LOG = 60;\n\nusing num = modnum<998244353>;\nusing num2 = modnum<1004535809>;\nusing ll = long long;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<num2> bin(LOG + 1);\n  bin[0] = 1;\n  for (int i = 0; i < LOG; ++i) {\n    bin[i + 1] = bin[i] * 2;\n  }\n  int na;\n  cin >> na;\n  vector<pair<ll, num2>> a(na * 2);\n  for (int i = 0; i < na; ++i) {\n    cin >> a[i * 2].first;\n    a[i * 2].second = -1;\n    cin >> a[i * 2 + 1].first;\n    a[i * 2 + 1].first++;\n    a[i * 2 + 1].second = 1;\n  }\n  na *= 2;\n  int nb;\n  cin >> nb;\n  vector<pair<ll, num2>> b(nb * 2);\n  for (int i = 0; i < nb; ++i) {\n    cin >> b[i * 2].first;\n    b[i * 2].second = -1;\n    cin >> b[i * 2 + 1].first;\n    b[i * 2 + 1].first++;\n    b[i * 2 + 1].second = 1;\n  }\n  map<ll, num2> sum;\n  auto solve = [&](ll x, ll y, num2 z) {\n    for (int rot = 0; rot < 2; ++rot) {\n      for (int i = LOG - 1; ~i; --i) {\n        if (x >> i & 1) {\n          ll fix = (((x >> i) ^ 1) << i) ^ (y >> i << i);\n          num2 add = 0;\n          for (int j = i - 1; ~j; --j) {\n            if (y >> j & 1) {\n              add += bin[j];\n            }\n          }\n          sum[fix] += z * add;\n          sum[fix + (1ll << i)] -= z * add;\n        }\n      }\n      swap(x, y);\n    }\n    for (int i = LOG - 1; ~i; --i) {\n      if ((x >> i & 1) && (y >> i & 1)) {\n        ll fix = (((x >> i) ^ 1) << i) ^ (((y >> i) ^ 1) << i);\n        sum[fix] += z * bin[i];\n        sum[fix + (1ll << i)] -= z * bin[i];\n      }\n    }\n  };\n  for (auto aa : a) {\n    for (auto bb : b) {\n      solve(aa.first, bb.first, aa.second * bb.second);\n    }\n  }\n  num ans = 0;\n  num2 cur = 0;\n  auto get = [&](ll l, ll r) {\n    return (num) (l + r - 1) * (r - l) / 2;\n  };\n  for (auto it = sum.begin(); it != --sum.end(); ++it) {\n    cur += it->second;\n    if (cur != 0) {\n      ans += get(it->first, next(it)->first);\n    }\n  }\n  cout << ans << ""\\n"";\n  return 0;\n}\n']",,,"['bitmasks', 'divide and conquer', 'math']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Xor-Set.json,https://codeforces.com/blog/entry/71740,Consider a segment tree over the interval a node representing a segment of length would represent all numbers with the first bits same with all possible last n bits In other words the binary representation of any number in the segment would be where all and is either 0 or 1 to would be fixed and all s can be arbitrarily chosen We can observe that if we have two segments and in the tree all possible numbers that equals the xor sum of a number in and a number in also forms a segment in the tree with the length of and the unchanging bits is equal to the xor sum of the two segment s unchanging bits Using this observation we would get an or algorithm depending on the sorting method First we get all segments that compose the intervals in and we can get resulting segments Then we are left with evaluating the sum in the combination of segments We can sort these segments to get the answer This algorithm will get an MLE in practice since the number of resulting segments could easily exceed To improve this algorithm we can make another observation that when segments of different sizes are combined as described above the smaller segment is equivalent to the ancestor of the same size as the bigger segment Let s call all the segments in the decomposition of the input the real segments and all segments with a real segment in the subtree as auxiliary segments Then we could iterate over 60 possible values of the size of the segment and for each value we could iterate over the real segments of set and auxiliary segments of set and add the results to the set We can prove that the number of both real and auxiliary segments of any size is not greater than Thus the solution runs at or algorithm depending on the sorting method 
https://codeforces.com//contest/1479/problem/B1,889626,B1,1479B1,1479,B1. Painting the Array I,Homer likes arrays a lot Today he is painting an array a 1 a 2 dots a n with two kinds of colors and A painting assignment for a 1 a 2 dots a n is described by an array b 1 b 2 dots b n that b i indicates the color of a i 0 for white and 1 for black According to a painting assignment b 1 b 2 dots b n the array a is split into two new arrays a 0 and a 1 where a 0 is the sub sequence of all white elements in a and a 1 is the sub sequence of all black elements in a For example if a 1 2 3 4 5 6 and b 0 1 0 1 0 0 then a 0 1 3 5 6 and a 1 2 4 The number of segments in an array c 1 c 2 dots c k denoted mathit seg c is the number of elements if we merge all adjacent elements with the same value in c For example the number of segments in 1 1 2 2 3 3 3 2 is 4 because the array will become 1 2 3 2 after merging adjacent elements with the same value Especially the number of segments in an empty array is 0 Homer wants to find a painting assignment b according to which the number of segments in both a 0 and a 1 i e mathit seg a 0 mathit seg a 1 is as as possible Find this number ,"['/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass B1PaintingTheArrayI {\n public:\n  void solveOne() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) {\n      cin >> x;\n      --x;\n    }\n    vector<vector<int>> occs(n);\n    for (int i = 0; i < n; ++i) {\n      occs[a[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i) occs[i].push_back(n);\n    int x = -1;\n    int y = -1;\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n      int z = a[i];\n      if (z == x) {\n        if (z == y) {\n\n        } else {\n          y = z;\n          ++res;\n        }\n      } else if (z == y) {\n        x = z;\n        ++res;\n      } else {\n        int px = x < 0 ? n : *lower_bound(all(occs[x]), i);\n        int py = y < 0 ? n : *lower_bound(all(occs[y]), i);\n        if (px < py) {\n          x = z;\n        } else {\n          y = z;\n        }\n        ++res;\n      }\n    }\n    cout << res << ""\\n"";\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    B1PaintingTheArrayI solver;\n\n\n    solver.solve();\n    return 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'dp', 'greedy', 'implementation']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B1. Painting the Array I.json,https://codeforces.com//blog/entry/87598,Formally for every sequence and we assume that are positive integers the number of segments in is defined to be where and if the Boolean expression is true and otherwise Let s restate the problem as Given a sequence divide it into two disjoint subsequences and such that is as large as possible We will construct two disjoint subsequences by scanning through the sequence Initial setting and are two empty sequences and remains not scanned Move on Suppose the last elements of and are and respectively and resp if resp is empty Let be the current element scanning through Our greedy strategy is described in two cases Greedy Strategy I If equals to one of and then assign to the opposite subsequence That is if then append after and if then append after In particular if equals to both and the assignment could be arbitrary Greedy Strategy II If differs from both and then append after the one with the nearest next same value That is let denote the next position where appears in after then append after if and after otherwise The greedy strategy is intuitive and with this strategy an algorithm is immediately obtained However its proof turns out to be complicated We append its proof for completeness Consider any optimal assignment we will show that our strategy is not worse than it Let be the subarray of Now suppose we are at some position where the optimal assignment conflicts with our strategy We assume that ends with and ends with and Greedy Strategy I If conflicts with Greedy Strategy I then we must have and without loss of generality we assume that Greedy Strategy I suggests we append after but suggests we append after Suppose results in the two subarrays while there is indeed another optimal assignment that agrees with our strategy and results in Greedy Strategy II If conflicts with Greedy Strategy II then we must have and are distinct and without loss of generality we assume that the next occurrence of goes in front of that of Greedy Strategy II suggests we append after but suggests we append after Suppose results in the two subarrays Consider two cases If does not start with then there is another optimal assignment that agrees with our strategy and results in If starts with i e then since the first occurrence of is in front of that of we have that must be in and assume that The result of is restated as We find that there is another optimal assignment that agrees with our strategy and results in Note that does not contain any or in it The number of alternations in a sequence starting with is defined to be where We note that Let denote the maximal possible sum of numbers of alternations in the two disjoint subsequences and of i e where and ranges over all possible pairs of disjoint subsequences of It is obvious that the order of and does not matter i e We note that our goal is to compute Let denote the least index such that i e In case no such index exists is defined to be In fact our problem can be solved by DP regardless of the time complexity Dynamic Programming For and every In particular for empty sequence we have We can obtain some immediate properties of by the above DP recurrence For every Moreover if then After some observations we have For every and sequence By induction on the length of sequence It is trivial for the case since the left hand side is always and the right hand side is always Suppose true for the case i e holds for every sequence of length Now consider a sequence of length It is trivial that We should prove that By Proposition 1 we need to prove that The second inequality is obvious The first inequality becomes which holds by induction We should prove that By Proposition 1 we only need to prove that which is obvious and By Proposition 1 is equivalent to The left hand side becomes by induction that The right hand side becomes by induction that The inequality holds immediately The left hand side becomes by induction that The right hand side becomes By induction that and the inequality holds The left hand side becomes The right hand side becomes by induction that The inequality immediately holds as appears in both sides and can be eliminated together The left hand side becomes The right hand side becomes By induction that the inequality holds The inequality holds for all cases Therefore the inequality holds for The inequality holds for every Suppose is a sequence For every distinct i e and if then By induction on the length of sequence It is trivial for the case since the both hand sides are Suppose true for the case i e holds for every sequence of length Now consider a sequence of length By Proposition 1 and 3 the left hand side becomes and the right hand side becomes The inequality holds immediately By Proposition 1 the left hand side becomes and the right hand side becomes By Proposition 2 we have and therefore the inequality holds This is impossible because i e there is an element of value in front of the first element of value The left hand side becomes The right hand side becomes If then by induction we have and because The inequality holds If then by induction we have and because The inequality holds The inequality holds for all cases Therefore the inequality holds for The inequality holds for every Greedy Strategy I Suppose is a sequence For every if then By Proposition 1 we have By Proposition 3 we have Combining with the both above yields the proof Greedy Strategy II Suppose is a sequence For every with if then If by Proposition 4 we have Therefore by Proposition 1 we have The same statement holds for 
https://codeforces.com//contest/1370/problem/A,652383,A,1370A,1370,A. Maximum GCD,Let s consider all integers in the range from 1 to n inclusive Among all pairs of integers in this range find the maximum possible greatest common divisor of integers in pair Formally find the maximum value of mathrm gcd a b where 1 leq a b leq n The greatest common divisor mathrm gcd a b of two positive integers a and b is the biggest integer that is a divisor of both a and b ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\nmain() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n;\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        cout << n / 2 << '\\n';\n    }\n    return 0;\n}\n""]",,,"['greedy', 'implementation', 'math', 'number theory']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Maximum GCD.json,https://codeforces.com//blog/entry/79107, Answer for any is equal to Let the maximum gcd be equal to Since the two numbers in a pair are distinct one of them must be and both of them must be divisible by The smallest multiple of greater than is Since each number in the pair must be we must have or We can achieve by choosing and Time Complexity 
https://codeforces.com//contest/821/problem/E,111653,E,821E,821,E. Okabe and El Psy Kongroo,Okabe likes to take walks but knows that spies from the Organization could be anywhere that s why he wants to know how many different walks he can take in his city safely Okabe s city can be represented as all points such that and are non negative Okabe starts at the origin point and needs to reach the point If Okabe is currently at the point in one step he can go to or Additionally there are horizontal line segments the th of which goes from to inclusive and is at It is guaranteed that and for The th line segment forces Okabe to walk with value in the range when his value satisfies or else he might be spied on This also means he is required to be under two line segments when one segment ends and another begins Okabe now wants to know how many walks there are from the origin to the point satisfying these conditions modulo ,"['#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 110\n#define maxm 16\n#define mo 1000000007\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; bool f = 0; char ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') {\n\t\tif (ch == \'-\') f = 1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= \'0\' && ch <= \'9\')\n\t\tx = x * 10 + ch - \'0\', ch = getchar();\n\tif (f) x = -x;\n}\nvoid add(int &a, int b) {\n\ta += b; a %= mo;\n}\nll k, a[maxn], b[maxn];\nint n, c[maxn], m;\nint f[maxn][maxn];\nstruct mat{\n\tint x[maxm][maxm];\n\tvoid init() {\n\t\tcl(x);\n\t}\n}A, B, C;\nmat operator * (const mat &a, const mat &b) {\n\tmat c; c.init();\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tfor (int k = 0; k <= m; ++k)\n\t\t\t\tadd(c.x[i][j], 1ll * a.x[i][k] * b.x[k][j] % mo);\n\treturn c;\n}\nmat operator ^ (mat a, ll b) {\n\tmat c; c.init(); for (int i = 0; i <= m; ++i) c.x[i][i] = 1;\n\tfor (; b; b >>= 1ll, a = a * a)\n\t\tif (b & 1ll) c = c * a;\n\treturn c;\n}\nint main() {\n\tscanf(""%d%I64d"", &n, &k);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(""%I64d%I64d%d"", &a[i], &b[i], &c[i]);\n\tf[0][0] = 1;\n\tb[n] = min(b[n], k);\n\tfor (int k = 1; k <= n; ++k) {\n\t\tA.init(); \n\t\tm = c[k];\n\t\tfor (int i = 0; i <= c[k]; ++i) {\n\t\t\tif (i) A.x[i][i - 1] = 1;\n\t\t\tA.x[i][i] = 1;\n\t\t\tif (i < c[k]) A.x[i][i + 1] = 1;\n\t\t}\n\t\tB = A ^ (b[k] - a[k]);\n\t\tfor (int i = 0; i <= c[k]; ++i) {\n\t\t\tfor (int j = 0; j <= c[k]; ++j)\n\t\t\t\tadd(f[k][i], 1ll * f[k - 1][j] * B.x[j][i] % mo);\n\t\t}\n\t}\n\tprintf(""%d\\n"", f[n][0]);\n\treturn 0;\n}\n\n\n\n\n\n']",,,"['dp', 'matrices']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Okabe and El Psy Kongroo.json,https://codeforces.com/blog/entry/52895,You can get a naive DP solution by computing f x y the number of ways to reach the point x y It s just f x 1 y 1 f x 1 y f x 1 y 1 being careful about staying above x axis and under or on any segments To speed it up note that the transitions are independent of x This is screaming matrix multiplication First if you don t know the matrix exponentiation technique for speeding up DP you should learn it from here Now let s think of the matrix representation Since the x dimension is the long one and the y dimension is small lets store a vector of values dp where dpi is the number of ways to get to a y value of i at the current x value This will be the initial vector for matrix multiplication Now what about the transition matrix Since our initial vector has length y and we need a matrix to multiply it with to map it to another vector with length y we need a y by y matrix Now if you think about how matrix multiplication works you come up with an idea like this put a 1 in the entry i j if from a y value of i we can reach a y value of j i e i j 1 Don t believe me multiply some vector times a matrix of this form to see how and why the transition works You can then build this matrix quickly and then matrix exponentiate for under every segment and multiply by the initial vector then make the result as the new initial vector for the next segment You should make sure to remove values from the vector if the next segment is lower or add values to the vector if the next segment is higher This gives complexity O nh3 log w where h 16 and w k 
https://codeforces.com//contest/1900/problem/B,2348159,B,1900B,1900,B. Laura and Operations,Nemanja wrote some digits on the board All of them are either 1 2 or 3 The number of digits 1 is a The number of digits 2 is b and the number of digits 3 is c He told Laura that in one operation she can do the following Select two different digits and erase them from the board After that write the digit 1 2 or 3 different from both erased digits For example let the digits be 1 1 1 2 3 3 She can choose digits 1 and 3 and erase them Then the board will look like this 1 1 2 3 After that she has to write another digit 2 so at the end of the operation the board will look like 1 1 2 3 2 Nemanja asked her whether it was possible for only digits of one type to remain written on the board after some operations If so which digits can they be Laura was unable to solve this problem and asked you for help As an award for helping her she will convince Nemanja to give you some points ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint a, b, c;\nvoid solve(){\n\tscanf(""%d%d%d"", &a, &b, &c);\n\tprintf(""%d %d %d\\n"", 1 - (b + c) % 2, 1 - (a + c) % 2, 1 - (a + b) % 2);\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']",,,"['dp', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Laura and Operations.json,https://codeforces.com//blog/entry/122677,SolutionRead the hints If the parity of and is not the same then it is impossible for only digits to remain on the board as it would require Otherwise the following construction will leave only digits on the board First remove digits and and write digit while and If then we are done Otherwise without loss of generality assume That means that after the operations and is even Because and are the same parity Now we perform the following operations times to get only digits left Remove digits and and add digit After that remove digits and and add digit An effective change of these operations is the reduction of by Time and memory complexities are 
https://codeforces.com//contest/1203/problem/B,388103,B,1203B,1203,B. Equal Rectangles,You are given 4n sticks the length of the i th stick is a i You have to create n rectangles each rectangle will consist of exactly 4 sticks from the given set The rectangle consists of four sides opposite sides should have equal length and all angles in it should be right Note that each stick can be used in only one rectangle Each stick should be used as a side you cannot break the stick or use it not to the full length You want to all rectangles to have equal area The area of the rectangle with sides a and b is a cdot b Your task is to say if it is possible to create exactly n rectangles of equal area or not You have to answer q independent queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tint n; cin >> n;\n\t\tvector<int> a(n * 4);\n\t\tfor (int i = 0; i < n * 4; ++i) cin >> a[i];\n\t\tsort(begin(a), end(a));\n\t\tbool ok = true;\n\t\tfor (int i = 0, l = 0, r = n * 4 - 1; i < n; ++i, l += 2, r -= 2) {\n\t\t\tif ((a[l] - a[l + 1]) || (a[r] - a[r - 1]) || (a[l] * a[r] - a[0] * a[n * 4 - 1])) {\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? ""YES"" : ""NO"") << endl;\n\t}\n}']",,,"['greedy', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Equal Rectangles.json,https://codeforces.com//blog/entry/69108,After sorting we can observe that if the answer is then the area of each rectangle is Then we just need to check for each from to that and and If all conditions are satisfied for all then the answer is Otherwise the answer is 
https://codeforces.com//contest/1944/problem/B,2535050,B,1944B,1944,B. Equal XOR,You are given an array a of length 2n consisting of each integer from 1 to n exactly You are also given an integer k 1 leq k leq lfloor frac n 2 rfloor You need to find two arrays l and r each of length mathbf 2k such that l is a subset dagger of a 1 a 2 ldots a n r is a subset of a n 1 a n 2 ldots a 2n bitwise XOR of elements of l is equal to the bitwise XOR of elements of r in other words l 1 oplus l 2 oplus ldots oplus l 2k r 1 oplus r 2 oplus ldots oplus r 2k It can be proved that at least one pair of l and r always exists If there are multiple solutions you may output any one of them dagger A sequence x is a subset of a sequence y if x can be obtained by deleting several possibly none or all elements of y and rearranging the elements in any order For example 3 1 2 1 1 2 3 1 1 and 3 2 are subsets of 1 1 2 3 but 4 and 2 2 are not subsets of 1 1 2 3 ,"['#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl \'\\n\'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nconst int N=1e5+10;\nint n,k,a[N];\nvector<int> p[N];\nvoid work() {\n\tcin>>n>>k; k<<=1;\n\tFor(i,1,n) p[i].clear();\n\tFor(i,1,n*2) cin>>a[i],p[a[i]].push_back(i);\n\tvector<int> f[2];\n\tFor(i,1,n) if((p[i][0]<=n)==(p[i][1]<=n)) {\n\t\tif(f[0].size()+(p[i][0]<=n)+(p[i][1]<=n)<=k)\n\t\t\tif(f[1].size()+(p[i][0]>n)+(p[i][1]>n)<=k) {\n\t\t\t\tf[p[i][0]>n].push_back(p[i][0]);\n\t\t\t\tf[p[i][1]>n].push_back(p[i][1]);\n\t\t\t}\n\t}\n\tFor(i,1,n) if((p[i][0]<=n)!=(p[i][1]<=n)) {\n\t\tif(f[0].size()+(p[i][0]<=n)+(p[i][1]<=n)<=k)\n\t\t\tif(f[1].size()+(p[i][0]>n)+(p[i][1]>n)<=k) {\n\t\t\t\tf[p[i][0]>n].push_back(p[i][0]);\n\t\t\t\tf[p[i][1]>n].push_back(p[i][1]);\n\t\t\t}\n\t}\n\tFor(i,0,1) {\n\t\tfor(auto x:f[i]) cout<<a[x]<<"" ""; cout<<endl;\n\t}\n}\nint main() {\n#ifdef LOCAL\n\tfreopen("".in"",""r"",stdin);\n\t// freopen("".out"",""w"",stdout);\n\t// freopen("".debug"",""w"",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}']",,,"['bitmasks', 'constructive algorithms']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Equal XOR.json,https://codeforces.com//blog/entry/127195,We can append any 2 occurrence numbers to our sequence l and any 0 occurrence numbers to our sequence r without any issue because the xor value will cancel out We do this while our sequence sizes are less than 2 k At the end of this process l and r will have the same size due to Hint 2 Now we use as many 1 occurrence numbers appending to both l and r as needed Since we append to both sequences the xor value of the 2 sequences will be the same If we had to solve for odd sequence sizes we could take a 1 occurrence number at the very start to make it even and then run the same process but if there are no 1 occurrence numbers at all we fail with this method 
https://codeforces.com//contest/1059/problem/A,231520,A,1059A,1059,A. Cashier,Vasya has recently got a job as a cashier at a local store His day at work is L minutes long Vasya has already memorized n regular customers the i th of which comes after t i minutes after the beginning of the day and his service consumes l i minutes It is guaranteed that no customer will arrive while Vasya is servicing another customer Vasya is a bit lazy so he likes taking smoke breaks for a minutes each Those breaks may go one after another but Vasya must be present at work during all the time periods he must serve regular customers otherwise one of them may alert his boss What is the maximum number of breaks Vasya can take during the day ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    ll n,l,a;\n    void main(){\n        in(n,l,a);\n        ll cur = 0;\n        ll ans = 0;\n        REP(i,0,n){\n            ll t,len;in(t,len);\n            ans += (t-cur)/a;\n            cur = t+len;\n        }\n        ans += (l-cur)/a;\n        cout<<ans;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    SOLVE::main();\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Cashier.json,https://codeforces.com//blog/entry/62238,There are only possible segments of time when Vasya can take breaks between the consecutive clients before the first client and after the last client If the length of the th such segment is Vasya may take at most breaks so we just sum those values over the possible segments Time complexity is 
https://codeforces.com//contest/1144/problem/B,322483,B,1144B,1144,B. Parity Alternated Deletions,Polycarp has an array a consisting of n integers He wants to play a game with this array The game consists of several moves On the first move he chooses any element and deletes it after the first move the array contains n 1 elements For each of the next moves he chooses any element with the only restriction its parity should differ from the parity of the element deleted on the previous move In other words he alternates parities even odd even odd or odd even odd even of the removed elements Polycarp stops if he can t make a move Formally If it is the first move he chooses any element and deletes it If it is the second or any next move if the last deleted element was Polycarp chooses any element and deletes it if the last deleted element was Polycarp chooses any element and deletes it If after some move Polycarp cannot make a move the game ends Polycarp s goal is to the sum of elements of the array after end of the game If Polycarp can delete the whole array then the sum of elements is zero Help Polycarp find this value ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\npriority_queue<int,vector<int> ,greater<int> >q,p;\nint main(){\n\tint odd = 0,even = 0,k;\n\tscanf(""%d"",&n);\n\tfor (int i = 0; i < n; ++i){\n\t\tscanf(""%d"",&k);\n\t\tif (k & 1) q.push(k),odd++; else\n\t\tp.push(k),even++;\n\t}\n\tlong long ans = 0;\n\tif (odd < even){\n\t\teven -= odd;\n\t\tif (even) even--;\n\t\twhile(even){\n\t\t\tans += p.top(); \n\t\t\tp.pop(); \n\t\t\teven--;\n\t\t}\n\t} else{\n\t\todd -= even;\n\t\tif (odd) odd--;\n\t\twhile(odd){\n\t\t\tans += q.top();\n\t\t\tq.pop(); \n\t\t\todd--;\n\t\t}\n\t}\n\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Parity Alternated Deletions.json,https://codeforces.com/blog/entry/66307,Let s calculate the sum of the whole array and then divide all its elements into two arrays and by their parity for odd for even Sort both of them in non increasing order Then what can we see We always can delete first elements from both arrays where is the size of So let s decrease by the sum of first elements of the array and the same for the array If one the arrays has more than elements both arrays cannot have more than elements because if it is so then should be greater then let s decrease by the th element of this array because this is the maximum possible element we can remove Now is the answer for the problem 
https://codeforces.com//contest/1470/problem/A,855302,A,1470A,1470,A. Strange Birthday Party,Petya organized a strange birthday party He invited n friends and assigned an integer k i to the i th of them Now Petya would like to give a present to each of them In the nearby shop there are m unique presents available the j th present costs c j dollars 1 le c 1 le c 2 le ldots le c m It s allowed to buy a single present more than once For the i th friend Petya can either buy them a present j le k i which costs c j dollars or just give them c k i dollars directly Help Petya determine the minimum total cost of hosting his party ,"[""/**\n *    author:  tourist\n *    created: 05.01.2021 17:34:59       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n      cin >> k[i];\n    }\n    sort(k.begin(), k.end());\n    vector<int> c(m);\n    for (int i = 0; i < m; i++) {\n      cin >> c[i];\n    }\n    int low = 0, high = min(n, m);\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      bool ok = true;\n      for (int i = 0; i < mid; i++) {\n        if (k[n - mid + i] <= i) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n      ans += c[k[i] - 1];\n    }\n    long long best = ans;\n    for (int i = 1; i <= low; i++) {\n      ans -= c[k[n - i] - 1];\n      ans += c[i - 1];\n      best = min(best, ans);\n    }\n    cout << best << '\\n';\n  }\n  return 0;\n}\n""]",,,"['binary search', 'dp', 'greedy', 'sortings', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Strange Birthday Party.json,https://codeforces.com//blog/entry/86464,Let s note that it is beneficial to give cheaper gifts to people with a larger value Suppose that in the optimal answer a pair of people and such that get gifts with values Then we can give a gift to a person and to a person give a gift or dollars If than we spend the same amount of money Otherwise it s a better answer So the problem can be solved using greedy algorithm Let s sort guest in order of descending value Than give each person a cheapest gift or dollars if it better To determinate a cheapest gift let s store the index of the last purchased gift Thus the final asymptotics is 
https://codeforces.com//contest/2040/problem/B,3075496,B,2040B,2040,B. Paint a Strip,You have an array of a 1 a 2 ldots a n of length n You can perform two types of operations on it Choose an index i such that 1 le i le n and a i 0 and assign 1 to a i Choose a pair of indices l and r such that 1 le l le r le n a l 1 a r 1 a l ldots a r ge lceil frac r l 1 2 rceil and assign 1 to a i for all l le i le r What is the minimum number of operations of the needed to make all elements of the array equal to one ,"['#include <bits/stdc++.h>using namespace std;\xa0using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>;\xa0constexpr int MOD = 1e9 + 7;constexpr int INF = 1e9;constexpr ll LINF = 1e18;constexpr ld EPS = 1e-9;\xa0#define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define pb push_back#define eb emplace_back#define fi first#define se second#define sz(x) ((int)(x).size())#define dbg(x) cerr << #x << "" = "" << (x) << \'\\n\'\xa0void solve() {    ll n;    cin >> n;    if(n==1){        cout << 1 << ""\\n"";        return;    }    ll k = 1;    while(true){        ll res = 3LL*((ll)1 << (k-1)) - 2;        if(res>=n) {cout << k << ""\\n""; break;}        k++;    }\xa0}\xa0int main() {    fast_io();    int t = 1;    cin >> t;    while (t--) solve();    return 0;}']",,,"['constructive algorithms', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Paint a Strip.json,https://codeforces.com//blog/entry/137074,At each moment of time the array contains a number of non intersecting segments consisting only of ones Using an operation of the first type can increase the number of these segments by Using an operation of the second type decreases the number of these segments by where is the number of segments that this operation covers Therefore the number of operations of the second type is no more than the number of operations of the first type minus The optimal strategy is to perform one operation of the first type and then alternate operations of the first and second types increasing the number of ones from to on each such pair of operations There is no point in doing more operations of the first type on the prefix of operations since we still must cover no more than two segments of ones with operations of the second type otherwise we will reduce the possible number of operations of the second type 
https://codeforces.com//contest/222/problem/C,1638,C,222C,222,C. Reducing Fractions,To confuse the opponents the Galactic Empire represents fractions in an unusual format The fractions are represented as two sets of integers The product of numbers from the first set gives the fraction numerator the product of numbers from the second set gives the fraction denominator However it turned out that the programs that work with fractions in this representations aren t complete they lack supporting the operation of reducing fractions Implement this operation and the Empire won t forget you ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#define min(a,b) (((a)<(b))?(a):(b))\nusing namespace std;\n\nbool visit[ 3164 ];\nint prime[ 1000 ], pcnt;\nint faca[ 100001 ][ 10 ][ 2 ], facb[ 100001 ][ 10 ][ 2 ], c1[ 100001 ], c2[ 100001 ], f1[ 10000001 ], f2[ 10000001 ];\n\nvoid init( )\n{\n\tint i, j;\n\tfor ( i = 2; i <= 3163; i++ )\n\t\tif ( !visit[ i ] )\n\t\t{\n\t\t\tprime[ pcnt++ ] = i;\n\t\t\tfor ( j = i * 2; j <= 3163; j += i )\n\t\t\t\tvisit[ j ] = 1;\n\t\t}\n}\n\nint main( )\n{\n\tint n, m, i, j, k, t, p;\n\tscanf(""%d%d"", &n, &m);\n\tinit( );\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tscanf(""%d"", &t);\n\t\tif ( t == 1 )\n\t\t{\n\t\t\tc1[ i ] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( j = 0; prime[ j ] * prime[ j ] <= t; j++ )\n\t\t\tif ( t % prime[ j ] == 0 )\n\t\t\t{\n\t\t\t\tfaca[ i ][ c1[ i ] ][ 0 ] = prime[ j ];\n\t\t\t\twhile ( t % prime[ j ] == 0 )\n\t\t\t\t{\n\t\t\t\t\tt /= prime[ j ];\n\t\t\t\t\tf1[ prime[ j ] ]++;\n\t\t\t\t\tfaca[ i ][ c1[ i ] ][ 1 ]++;\n\t\t\t\t}\n\t\t\t\tc1[ i ]++;\n\t\t\t}\n\t\tif ( t != 1 )\n\t\t{\n\t\t\tfaca[ i ][ c1[ i ] ][ 0 ] = t;\n\t\t\tfaca[ i ][ c1[ i ]++ ][ 1 ] = 1;\n\t\t\tf1[ t ]++;\n\t\t}\n\t}\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tscanf(""%d"", &t);\n\t\tif ( t == 1 )\n\t\t{\n\t\t\tc2[ i ] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( j = 0; prime[ j ] * prime[ j ] <= t; j++ )\n\t\t\tif ( t % prime[ j ] == 0 )\n\t\t\t{\n\t\t\t\tfacb[ i ][ c2[ i ] ][ 0 ] = prime[ j ];\n\t\t\t\twhile ( t % prime[ j ] == 0 )\n\t\t\t\t{\n\t\t\t\t\tt /= prime[ j ];\n\t\t\t\t\tf2[ prime[ j ] ]++;\n\t\t\t\t\tfacb[ i ][ c2[ i ] ][ 1 ]++;\n\t\t\t\t}\n\t\t\t\tc2[ i ]++;\n\t\t\t}\n\t\tif ( t != 1 )\n\t\t{\n\t\t\tfacb[ i ][ c2[ i ] ][ 0 ] = t;\n\t\t\tfacb[ i ][ c2[ i ]++ ][ 1 ] = 1;\n\t\t\tf2[ t ]++;\n\t\t}\n\t}\n\tfor ( i = 2; i <= 10000000; i++ )\n\t{\n\t\tt = min( f1[ i ], f2[ i ] );\n\t\tf1[ i ] -= t;\n\t\tf2[ i ] -= t;\n\t}\n\tprintf(""%d %d\\n"", n, m);\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tt = 1;\n\t\tfor ( j = 0; j < c1[ i ]; j++ )\n\t\t\tfor ( k = 0; k < faca[ i ][ j ][ 1 ] && f1[ faca[ i ][ j ][ 0 ] ]; k++ )\n\t\t\t{\n\t\t\t\tf1[ faca[ i ][ j ][ 0 ] ]--;\n\t\t\t\tt *= faca[ i ][ j ][ 0 ];\n\t\t\t}\n\t\tif ( i != 0 ) printf("" "");\n\t\tprintf(""%d"", t);\n\t}\n\tputs("""");\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tt = 1;\n\t\tfor ( j = 0; j < c2[ i ]; j++ )\n\t\t\tfor ( k = 0; k < facb[ i ][ j ][ 1 ] && f2[ facb[ i ][ j ][ 0 ] ]; k++ )\n\t\t\t{\n\t\t\t\tf2[ facb[ i ][ j ][ 0 ] ]--;\n\t\t\t\tt *= facb[ i ][ j ][ 0 ];\n\t\t\t}\n\t\tif ( i != 0 ) printf("" "");\n\t\tprintf(""%d"", t);\n\t}\n\tputs("""");\n\treturn 0;\n}\n']",,,"['implementation', 'math', 'number theory', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Reducing Fractions.json,https://codeforces.com//blog/entry/5251,Let s factorize the numerator and denominator Now for each prime integer x we know the extent of x in the factorization of the numerator a x and the denominator b x For each prime number x we can calculate the extent of x in the factorization of the numerator and the denominator after reduction newa x a x min a x b x newb x b x min a x b x We have the numerator and the denominator of the answer in factorized form Now we have to bring them into the form which is required in the condition One of the ways to do it is to note that the fraction from the statement satisfies the conditions We can factorize it again and in the answer we will have the same fraction for which there will not be such a prime x so that the degree of x in answer would be greater than newa x or newb x This operation can be called reduction The result will satisfy the condition and the fraction will be equal to the required number If you try to build answer greedily put factors in the answer till their product 10 7 the count of numbers in the answer n out or m out will be bigger than 10 5 Factorization by O sqrt max received TL You should have found a faster way For example you could have used linear sieve of Eratosthenes Complexity O max n log max log max is size of factorization 
https://codeforces.com//contest/1833/problem/B,1929815,B,1833B,1833,B. Restore the Weather,You are given an array a containing the weather forecast for Berlandia for the last n days That is a i is the estimated air temperature on day i 1 le i le n You are also given an array b the air temperature that was actually present on each of the days However all the values in array b are mixed up Determine which day was which temperature if you know that the weather never differs from the forecast by more than k degrees In other words if on day i the real air temperature was c then the equality a i c le k is always true For example let an array a 1 3 5 3 9 of length n 5 and k 2 be given and an array b 2 5 11 2 4 Then so that the value of b i corresponds to the air temperature on day i we can rearrange the elements of the array b so 2 2 5 4 11 Indeed On the 1st day a 1 b 1 1 2 1 1 le 2 k is satisfied On the 2nd day a 2 b 2 3 2 1 1 le 2 k is satisfied On the 3rd day a 3 b 3 5 5 0 0 le 2 k is satisfied On the 4th day a 4 b 4 3 4 1 1 le 2 k is satisfied On the 5th day a 5 b 5 9 11 2 2 le 2 k is satisfied ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    std::vector<std::pair<int, int>> p(n);\n    for (int i = 0; i < n; i++) {\n        p[i] = {a[i], i};\n    }\n    std::sort(p.begin(), p.end());\n    std::sort(b.begin(), b.end());\n    std::vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n        res[p[i].second] = b[i];\n    }\n    for (auto x : res) {\n        std::cout << x << "" "";\n    }\n    std::cout << ""\\n"";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}']",,,"['greedy', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Restore the Weather.json,https://codeforces.com//blog/entry/116636,Let s solve the problem using a greedy algorithm Based on the array form an array of pairs temperature day number and sort it in ascending order of temperature Also sort the array in ascending order Now the values and are the predicted and real temperature on day Indeed consider the minimum temperatures and The difference between them is If we consider the value or at there will be at least since and Since it is guaranteed that it is possible to rearrange the elements in the array and the elements and have the smallest difference it is definitely not greater than 
https://codeforces.com//contest/610/problem/D,44289,D,610D,610,D. Vika and Segments,Vika has an infinite sheet of squared paper Initially all squares are white She introduced a two dimensional coordinate system on this sheet and drew black horizontal and vertical segments parallel to the coordinate axes All segments have width equal to square that means every segment occupy some set of neighbouring squares situated in one row or one column Your task is to calculate the number of painted cells If a cell was painted more than once it should be calculated exactly once ,"[""#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\nint n;\nstruct seg{\n    int x1,y1,x2,y2;\n}s[111111];\nseg v[111111],h[111111];\nseg vn[111111];int ntot=0;\nint vtot=0,htot=0;\nint cmpx(const seg&a,const seg&b){\n    if(a.x1==b.x1)return a.y1<b.y1;\n    return a.x1<b.x1;\n}\nint cmpy(const seg&a,const seg&b){\n    if(a.y1==b.y1)return a.x1<b.x1;\n    return a.y1<b.y1;\n}\n\nstruct node{\n    int x,y,sg;\n}tt[222222];int ttot=0;\n\n\n\nint cmpnode(const node&a,const node&b){\n    return a.x<b.x;\n}\nstruct nnode{int ch[2],sz,v,fix;}t[1000005];int ndtot=0;\nint root=0;\nvoid rot(int &x,int f){\n    int y=t[x].ch[!f];\n    t[x].ch[!f]=t[y].ch[f];\n    t[y].ch[f]=x;\n    t[y].sz=t[x].sz;\n    t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz+1;\n    x=y;\n}\nvoid ins(int &x,int v){\n    if(x==0){\n        x=++ndtot;\n        t[x].ch[0]=t[x].ch[1]=0;\n        t[x].sz=1;\n        t[x].fix=rand();\n        t[x].v=v;\n    }else{\n        int f=v>=t[x].v;\n        ins(t[x].ch[f],v);\n        t[x].sz++;\n        if(t[t[x].ch[f]].fix<t[x].fix)rot(x,!f);\n    }\n}\nvoid del(int &x){\n    if(!t[x].ch[0] && !t[x].ch[1])x=0;\n    else{\n        int f=!t[x].ch[0] || t[x].ch[1]&&t[t[x].ch[1]].fix<t[t[x].ch[0]].fix;\n        rot(x,!f);\n        t[x].sz--;\n        del(t[x].ch[!f]);\n    }\n}\nvoid del_num(int &x,int v){\n    if(t[x].v==v)del(x);\n    else{\n        int f=v>=t[x].v;\n        t[x].sz--;\n        del_num(t[x].ch[f],v);\n    }\n}\nint rk(int v){\n    int x=root;int ans=0;\n    while(x){\n        if(t[x].v>=v)x=t[x].ch[0];\n        else{\n            ans+=t[t[x].ch[0]].sz+1;\n            x=t[x].ch[1];\n        }\n    }\n    return ans+1;\n}\nint main()\n{\n    gn(n);\n    for (int i=1;i<=n;i++){\n        gn(s[i].x1);\n        gn(s[i].y1);\n        gn(s[i].x2);\n        gn(s[i].y2);\n        if(s[i].x1>s[i].x2)swap(s[i].x1,s[i].x2);\n        if(s[i].y1>s[i].y2)swap(s[i].y1,s[i].y2);\n        if(s[i].x1==s[i].x2){\n            v[++vtot]=s[i];\n        }else h[++htot]=s[i];\n    }\n    sort(h+1,h+1+htot,cmpy);\n\n    ll sum=0;\n    for (int i=1,j;i<=htot;i=j){\n        for (j=i;j<=htot && h[j].y1==h[i].y1;j++);\n\n        int far=-inf;\n        for (int k=i;k<j;k++){\n            if(h[k].x1>far){\n                if(far!=-inf)tt[++ttot]=(node){far+1,h[i].y1,-1};\n                tt[++ttot]=(node){h[k].x1,h[i].y1,+1};\n                far=max(far,h[k].x2);\n            }else{\n                far=max(far,h[k].x2);\n            }\n        }\n        tt[++ttot]=(node){far+1,h[i].y1,-1};\n    }\n    for (int i=1;i<=ttot;i++)sum-=tt[i].x*tt[i].sg;\n\n    sort(tt+1,tt+1+ttot,cmpnode);\n\n    sort(v+1,v+1+vtot,cmpx);\n\n    for (int i=1,j;i<=vtot;i=j){\n        for (j=i;j<=vtot && v[j].x1==v[i].x1;j++);\n\n        int far=-inf,st=-inf;\n        for (int k=i;k<j;k++){\n            if(v[k].y1>far){\n                if(far!=-inf)vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n                st=v[k].y1;\n                far=max(far,v[k].y2);\n            }else{\n                far=max(far,v[k].y2);\n            }\n        }\n        vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n    }\n\n    sort(vn+1,vn+1+ntot,cmpx);\n\n    int cur=1;\n    for (int i=1;i<=ntot;i++){\n        while(cur<=ttot && tt[cur].x<=vn[i].x1){\n            if(tt[cur].sg==1){\n                ins(root,tt[cur].y);\n            }else{\n                del_num(root,tt[cur].y);\n            }\n            cur++;\n        }\n        int coin = rk(vn[i].y2+1)-rk(vn[i].y1);\n        sum+=vn[i].y2-vn[i].y1+1 - coin;\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n""]",,,"['constructive algorithms', 'data structures', 'geometry', 'two pointers']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Vika and Segments.json,https://codeforces.com//blog/entry/22341,At first let s unite all segments which are in same verticals or horizontals Now the answer to the problem is the sum of lengths of all segments subtract the number of intersections Let s count the number of intersections For this let s use the horizontal scan line from the top to the bottom is can be done with help of events vertical segment is open vertical segment is close and hadle horizontal segment and in some data structure store the set of x coordinates of the open segments For example we can use Fenwick tree with precompression of the coordinates Now for current horizontal segment we need to take the number of the opened vertical segmetns with value x in the range x1 x2 where x vertical where the vertical segment are locating and x1 x2 the x coordinates of the current horizontal segment 
https://codeforces.com//contest/107/problem/C,564,C,107C,107,C. Arrangement,In the year 2500 the annual graduation ceremony in the German University in Cairo GUC has run smoothly for almost 500 years so far The most important part of the ceremony is related to the arrangement of the professors in the ceremonial hall Traditionally GUC has professors Each professor has his seniority level All seniorities are different Let s enumerate the professors from to with being the most senior professor and being the most junior professor The ceremonial hall has seats one seat for each professor Some places in this hall are meant for more senior professors than the others More specifically pairs of seats are in senior junior relation and the tradition requires that for all pairs of seats the professor seated in senior position should be more senior than the professor seated in junior position GUC is very strict about its traditions which have been carefully observed starting from year 2001 The tradition requires that The seating of the professors changes every year Year 2001 ceremony was using lexicographically first arrangement of professors in the ceremonial hall Each consecutive year lexicographically next arrangement of the professors is used The arrangement of the professors is the list of integers where the first integer is the seniority of the professor seated in position number one the second integer is the seniority of the professor seated in position number two etc Given the number of professors the current year and pairs of restrictions output the arrangement of the professors for this year ,"['/*\n * c.cpp\n *\n *  Created on: 2011-8-23\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\ntypedef long long int64;\nint n, m;\nint64 kth;\n\nint w[20];\nint before[20] = { };\nconst int MAX_N = 16;\nconst int MAX_S = 1 << MAX_N;\n\nint64 eval(int p) {\n\tstatic int64 dp[20][MAX_S];\n\tmemset(dp, 0, sizeof dp);\n\tint at[MAX_N] = { };\n\tmemset(at, -1, sizeof at);\n\tfor (int i = 0; i < p; ++i) {\n\t\tat[w[i]] = i;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < (1 << n); ++j) {\n\t\t\tif (dp[i][j] != 0) {\n\t\t\t\tint64 c = dp[i][j];\n\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\tif (~j >> k & 1) {\n\t\t\t\t\t\tif (at[i] != -1 && at[i] != k)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif ((j & before[k]) == before[k]) {\n\t\t\t\t\t\t\tdp[i + 1][j ^ (1 << k)] += c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][(1 << n) - 1];\n}\nint main() {\n\tcin >> n >> kth >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b, --a, --b;\n\t\tbefore[b] |= 1 << a;\n\t}\n\tkth -= 2001;\n\tif (eval(0) <= kth) {\n\t\tcout << ""The times have changed"" << endl;\n\t\treturn 0;\n\t}\n\tint used = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (used >> j & 1)\n\t\t\t\tcontinue;\n\t\t\tw[i] = j;\n\t\t\tint64 tmp = eval(i + 1);\n\t\t\tif (tmp <= kth) {\n\t\t\t\tkth -= tmp;\n\t\t\t} else {\n\t\t\t\tused |= 1 << j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << w[i] + 1 << "" "";\n\t}\n\tcout << endl;\n\treturn 0;\n}\n']",,,"['bitmasks', 'dp']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Arrangement.json,https://codeforces.com/blog/entry/2514,The problem asks for finding the lexicographically n th permutation satisfying the input constraints The trick which confused many contestants as well as a few authors and testers is that instead of having the restrictions formulated in a way position a i position b i the restrictions were element at position a i element at position b i As in most problems where one has to output lexicographically n th answer the idea which can result in the solution which is passing the systests is to learn how to compute the number of solutions satisfying certain constraints We will speak about how to compute the number of solutions in a bit but first let s understand how having such function would lead to a solution The very first observation is if the total number of possible solutions is less than y 2000 then the answer is The times have changed Once we have ensured that the solution exists it can be found using some of search A simple approach would be the following fix the first element of the resulting permutation to be 1 and count the number of possible solutions If we do have enough to reach year y then the first element must be 1 because there exists enough permutations with the first element being 1 to cover the years up to y and any permutation where the first element is not 1 comes after any permutation where the first element is 1 in lexicographical order And if fixing the first element to be 1 is not giving enough permutations then we should decrease the desired year by the number of solutions with 1 being fixed as the first element and start looking for the solutions with 2 as the first element The intuition is that there are not enough solutions with 1 being the first element but once we acknowledge that and start looking for the other solutions with 2 as the first element we are speaking not about arrangements for years 2001 and onwards but about the years 2001 number of solutions with first element being one and onwards Therefore instead of looking for the permutation with index y 2001 with the first element being 1 we are looking for the permutation with the lower index y 2001 number of solutions with first element being one with the first element being 2 or higher This process should be continued until all the elements are identified Once the first index is fixed the known prefix would become a two numbers prefix and it will grow until all the permutation is constructed Now to complete the solution we need to be able to compute the number of permutations which satisfy two restrictions the input constraints and the added permutation has prefix P constraint This problem can be solved using DP For a given prefix P of length m n m other elements should be placed Assume first that we are going to be iterating over all possible permutations with the given prefix using the brute force but instead of trying each possible value for the element at the next empty position i we would be trying each possible position for the next not yet placed element i This approach would work but in O n m time which is obviously unfeasible We need to find some way to reduce the state space and make it run faster The key observation is the following the state of the partially solved problem can be completely described by the bitmask of the currently occupied positions This statement is nontrivial as from the first glance it seems that apart from the unused positions mask the information about the order in which the already placed elements are placed is important However it s not Recall that all the constraints have the form of element at position ai is less than the element at position bi Provided the elements are placed in increasing order in order to satisfy each constraint it s enough to confirm that if the element to be placed is being put into position i there is no such constraint in the input that the element at position i should be less than the element at position j while the element at position j has already been placed This approach results in the DP with 2n m states Note that the next element to be placed can always be determined by the number of bits set in the mask and the prefix elements The implementation of the above algorithm requires nontrivial coding as the elements belonging to the prefix have to be treated differently compared to the elements which were placed by the DP This is because the DP is enforcing that the elements are always added in the increasing order which does not have to be the case for the elements conducting the prefix 
https://codeforces.com//contest/1349/problem/B,619060,B,1349B,1349,B. Orac and Medians,Slime has a sequence of positive integers a 1 a 2 ldots a n In one operation Orac can choose an arbitrary subsegment l ldots r of this sequence and replace all values a l a l 1 ldots a r to the value of median of a l a l 1 ldots a r In this problem for the integer multiset s the median of s is equal to the lfloor frac s 1 2 rfloor th smallest number in it For example the median of 1 4 4 6 5 is 4 and the median of 1 7 5 8 is 5 Slime wants Orac to make a 1 a 2 ldots a n k using these operations Orac thinks that it is impossible and he does not want to waste his time so he decided to ask you if it is possible to satisfy the Slime s requirement he may ask you these questions several times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 100100;\nint n, k;\nint a[N];\n\nint sgn(int x) {\n\tif (x > 0) return 1;\n\tif (x == 0) return 0;\n\treturn -1;\n}\n\nbool solve() {\n\tscanf(""%d%d"", &n, &k);\n\tbool hv = false;\n\tbool bad = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx -= k;\n\t\thv |= (x == 0);\n\t\tx = sgn(x);\n\t\tbad |= x == -1;\n\t\tif (x == 0) x = 1;\n\t\ta[i + 1] = x;\n\t}\n\tif (!hv) return false;\n\tif (!bad) return true;\n\ta[0] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i + 1] += a[i];\n\tint minBal = n + 3;\n\tfor (int i = 3; i <= n; i++) {\n\t\tminBal = min(minBal, a[i - 3]);\n\t\tif (a[i] > minBal)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\tif (solve())\n\t\t\tprintf(""yes\\n"");\n\t\telse\n\t\t\tprintf(""no\\n"");\n\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Orac and Medians.json,https://codeforces.com//blog/entry/77284,Let then just consider whether it can be done to make all elements in become in a finite number of operations It can be proved that a solution exists if and only if and The necessity is obvious if no elements in can be transformed into If there are at least two zeros between any two positive numbers then the median of each interval equals to no solution exists Consider the sufficiency If there are two adjacent elements in both equals to just select an interval which contains at least three elements and exact one element unequal to and operate once on this interval After this operation there are still two adjacent elements in both equals to so we keep doing this until all elements are transformed into Therefore if there is a interval which satisfies and the median of equals to just perform an operation on then use the above strategy It can be shown that such an interval can always be created in several operations with the condition If an interval satisfies or or or just perform an operation on If satisfies then or Perform an operation on or If any interval with three elements doesn t satisfy the above conditions because there is an interval which satisfies or Take such an interval perform an operation on first then select an interval which contains at least three elements and exact one element unequal to until two adjacent numbers equals to and respectively Perform one operation on these two adjacent elements Therefore the sufficiency is proved So just check whether there is an element in equals to and whether there is a pair of two positive integers which satisfies The complexity is 
https://codeforces.com//contest/965/problem/C,178361,C,965C,965,C. Greedy Arkady,k people want to split n candies between them Each candy should be given to exactly one of them or be thrown away The people are numbered from 1 to k and Arkady is the first of them To split the candies Arkady will choose an integer x and then give the first x candies to himself the next x candies to the second person the next x candies to the third person and so on in a cycle The leftover the remainder that is not divisible by x will be thrown away Arkady can t choose x greater than M as it is considered greedy Also he can t choose such a small x that some person will receive candies more than D times as it is considered a slow splitting Please find what is the maximum number of candies Arkady can receive by choosing some valid x ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N = 1e2 + 10;\n\nll n, k, m, d;\n\nll mx;\n\nint main() {\n cin >> n >> k >> m >> d;\n\n mx = max(mx, (n / m + k - 1) / k * m);\n for (int i = 1; i <= d; i++) {\n  ll cnt = k * i - k + 1;\n  if (cnt > n) break;\n  if (n / cnt > m) continue;\n  mx = max(mx, n / cnt * i);\n }\n cout << mx;\n return 0;\n}\n\n']",,,['math'],2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Greedy Arkady.json,https://codeforces.com//blog/entry/59105,As the limits on are small let s try all possible values of the number of times Arkady will receive candies For a given it s easy to compute and the maximum and minimum values of that suit these and Then with a fixed it s easy to write the formula of how many candies Arkady gets it s candies So it s obvious that we should choose for the given and update the answer can you solve the task when the leftover is not thrown away but is given to the next person can you solve the task from bonus 1 but without the condition just 
https://codeforces.com//contest/1353/problem/C,620789,C,1353C,1353,C. Board Moves,You are given a board of size n times n where n is not divisible by 2 Initially each cell of the board contains one figure In one move you can select presented in some cell and move it to one of the cells i e from the cell i j you can move the figure to cells i 1 j 1 i 1 j i 1 j 1 i j 1 i j 1 i 1 j 1 i 1 j i 1 j 1 Of course you move figures to cells out of the board It is allowed that after a move there will be several figures in one cell Your task is to find the minimum number of moves needed to get into cell i e n 2 1 cells should contain 0 figures and one cell should contain n 2 figures You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a;\n           cin>>a;\n           int ans=0;\n           for (int i=1;i<=a/2;i++) {\n               int qq=2*i+1; \n               qq=qq*qq; \n               qq-=(2*i-1)*(2*i-1); ans+=i*qq; \n           } \n           cout<<ans<<""\\n""; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']",,,['math'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Board Moves.json,https://codeforces.com//blog/entry/77373,It is intuitive and provable that the best strategy is to move each figure to the center cell Now with some paperwork or easy observations we can notice that we have exactly cells with the shortest distance cells with the shortest distance cells with the shortest distance and so on So we have cells with the shortest distance So the answer is It can be rewritten as so we can just calculate the sum of squares of all integers from to using loop or formula and multiply the answer by Time complexity or 
https://codeforces.com//contest/1934/problem/B,2505360,B,1934B,1934,B. Yet Another Coin Problem,You have 5 different types of coins each with a value equal to one of the first 5 triangular numbers 1 3 6 10 and 15 These coin types are available in abundance Your goal is to find the minimum number of these coins required such that their total value sums up to exactly n We can show that the answer always exists ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    IOS;\n\n    vi dp(100000 + 10, 1e18); dp[0] = 0;\n    for(int i = 1; i <= 100000; i++){\n        for(int j : {1, 3, 6, 10, 15}){\n            if(i < j) continue;\n            dp[i] = min(dp[i], dp[i - j] + 1);\n        }\n    }\n\n    int T; cin >> T;\n    while(T--){\n        int N; cin >> N;\n        int ans = 0;\n        if(N >= 1e5){\n            int chk = (N - (int)1e5) / 15 + 10;\n            ans = dp[N - chk * 15] + chk;\n        }\n        else ans = dp[N];\n        cout << ans << endl;\n    }\n\n}""]",,,"['brute force', 'dp', 'greedy', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Yet Another Coin Problem.json,https://codeforces.com//blog/entry/126423,SolutionFact You will never need more than ones threes sixes and tens Reason For Suppose if you used ones then you could have used one and ones For Suppose if you used threes then you could have used one and threes For Suppose if you used sixes then you could have used two s and sixes For Suppose if you used tens then you could have used two s and tens now since bound on their count is less we can bruteforce on these count 
https://codeforces.com//contest/2030/problem/D,2962991,D,2030D,2030,D. QED s Favorite Permutation,QED is given a permutation text p of length n He also has a string s of length n containing only characters texttt L and texttt R QED only likes permutations that are sorted in non decreasing order To sort p he can select any of the following operations and perform them any number of times Choose an index i such that s i texttt L Then swap p i and p i 1 It is guaranteed that s 1 neq texttt L Choose an index i such that s i texttt R Then swap p i and p i 1 It is guaranteed that s n neq texttt R He is also given q queries In each query he selects an index i and changes s i from texttt L to texttt R or from texttt R to texttt L Note that the changes are After each query he asks you if it is possible to sort p in non decreasing order by performing the aforementioned operations any number of times Note that before answering each query the permutation p is reset to its original form text A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include ""bits/stdc++.h""using namespace std;using ll = long long;using vi = vector<int>;\xa0#define endl \'\\n\'#define pb emplace_back#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()#define make_unique(x) sort(all(x)), x.resize(unique(all(x)) - begin(x))#define debug(x) cerr << ""["" << __LINE__ << ""] ""#x"" = "" << (x) << endl\xa0const int MN = 2e5 + 105;int cnt = 0;\xa0void solve() {\tint n, q;\tcin >> n >> q;\t\tvector <vector <int>> st(n), en(n);\tvector <bool> flg(n, false);\tvector <int> vec(n, 0);\tvector <int> p(n);\tset <int> miss;\tstring str, str_;\t//\tauto proc = [&](int pos) -> void {//\t\tif (str[pos] == \'R\') {//\t\t\tvec[pos] --, vec[pos - 1] ++;//\t\t\tstr[pos] = \'L\';//\t\t} else {//\t\t\tvec[pos - 1] --, vec[pos] ++;//\t\t\tstr[pos] = \'R\';//\t\t}//\t};\t\tfor (int i = 0; i < n; i ++) {\t\tcin >> p[i];\t\tp[i] --;\t\tif (i == p[i]) continue;\t\tst[min(i, p[i])].pb(i);\t\ten[max(i, p[i]) - 1].pb(i);\t}\t\tint cur = 0;\t\t\tfor (int i = 0 ; i < n; i ++ ) {\t\tcur += st[i].size();\t\tif (cur > 0) {\t\t\tflg[i] = true;\t\t}\t\tcur -= en[i].size();\t}\t\t\tcin >> str;\tstr_ = str;\tfor (int i = 0; i < n; i ++) {\t\tif (str[i] == \'R\') {\t\t\tvec[i] ++;\t\t\t\t} else {\t\t\tvec[i - 1] ++;\t\t}\t}\t\tfor (int i = 0; i < n - 1; i ++) {\t\tif (flg[i] && !vec[i] ) {\t\t\tmiss.insert(i);\t\t\t\t\t}\t}\t\xa0\t\twhile (q --) {\t\tint x;\t\tcin >> x;  \t\tx --;\t\t\t\tif (str[x] == \'R\') {\t\t\tif (vec[x] <= 1 && flg[x]) miss.insert(x);\t\t\tif (vec[x - 1] == 0 && flg[x - 1]) miss.erase(x - 1);\t\t\tcerr << \'x\' << x << endl;\t\t\tvec[x] --, vec[x - 1] ++;\t\t\tstr[x] = \'L\';\t\t} else {\t\t\tif (vec[x - 1] <= 1 && flg[x - 1]) miss.insert(x - 1);\t\t\tif (vec[x] == 0 && flg[x]) miss.erase(x);\t\t\tvec[x - 1] -- , vec[x] ++;\t\t\tstr[x] = \'R\';\t\t}\t\t\t\tif (miss.empty()) {\t\t\tcout << ""YES"" << endl;\t\t} else {\t\t\tcout << ""NO"" << endl;\t\t}\t}}\xa0\xa0\xa0int main() {#ifndef ONLINE_JUDGE\tfreopen(""in.txt"", ""r"", stdin);//\tfreopen(""out.txt"", ""w"", stdout);#endif\xa0\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\xa0\tint tc = 1;\tcin >> tc;\twhile (tc --) solve();\xa0\treturn 0;}']",,,"['data structures', 'implementation', 'sortings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. QED s Favorite Permutation.json,https://codeforces.com//blog/entry/135218,Through a series of swaps we can swap an element from position to position WLOG assume if there is no such such that such that and Let s mark all indices such that and as bad If represents the position of in then we must make sure it is possible to swap from to As you can see we can model these conditions as intervals We must make sure there are no bad indices included in any intervals We need to gather indices such that is included in at least one interval This can be done with difference array Let denote the number of intervals that include If then we need to make sure is not a bad index We can keep all bad indices in a set Notice that when we update we can only potentially toggle indices and from good to bad or vice versa For example if and index is not in the bad set then we will insert it After each query if the bad set is empty then the answer is YES 
https://codeforces.com//contest/806/problem/C,105597,C,806C,806,C. Prairie Partition,It can be shown that any positive integer can be uniquely represented as where and are integers Let s call that representation of For example the prairie partitions of and are Alice took a sequence of positive integers possibly with repeating elements replaced every element with the sequence of summands in its prairie partition arranged the resulting numbers in non decreasing order and gave them to Borys Now Borys wonders how many elements Alice s original sequence could contain Find all possible options ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nconst int MB = 50;\n\nint base[MB];\nint st[MB];\n\nbool check(int c) {\n    int c0 = 0, c1 = c;\n    for (int i = 0; i < MB-1; i++) {\n        c0 += st[i];\n        if (c0+c1 <= base[i]) {\n            //inc\n            int u = base[i] - (c0+c1);\n            if (c1 < u) return false;\n            c1 -= u;\n            c0 += u;\n        } else {\n            //dec\n            if (i == 0) return false;\n            int dec = (c0+c1) - base[i];\n            int dec0 = min(c0, dec);\n            c0 -= dec0;\n            dec -= dec0;\n            int dec1 = min(c1, dec);\n            c1 -= dec1;\n            dec -= dec1;\n            if (dec) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n;\n    cin >> n;\n    int offset = 0;\n    for (int i = 0; i < n; i++) {\n        ll x;\n        cin >> x;\n        int u = bsr(ull(x));\n        if (x == (1LL<<u)) {\n            // pow 2\n            base[u]++;\n        } else {\n            for (int i = 0; i <= u; i++) {\n                base[i]--;\n            }\n            offset++;\n            st[u+1]++;\n        }\n    }\n\n/*    for (int i = 0; i < MB; i++) {\n        cout << base[i] << "" "";\n    }\n    cout << endl;\n\n    for (int i = 0; i < MB; i++) {\n        cout << st[i] << "" "";\n    }\n    cout << endl;*/\n\n    V<int> ok;\n    for (int i = 0; i <= n; i++) {\n        if (check(i)) ok.push_back(i+offset);\n    }\n\n    if (ok.size() == 0) {\n        cout << -1 << endl;\n    } else {\n        for (int d: ok) {\n            cout << d << "" "";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n']",,,"['binary search', 'greedy']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Prairie Partition.json,https://codeforces.com//blog/entry/51883,This kind of partition sometimes shows up in solutions to knapsack problems with multiple items of the same type Let s say we want to check if the answer can be That means we have to construct chains of powers of 2 like possibly with different values of and then assign at most one of the remaining elements to each chain so that the element doesn t exceed double the largest power of 2 in its assigned chain If we can assign all the elements successfully is one possible answer It can be proved that the chains can be constructed greedily one by one with each chain as long as possible Let s denote the number of occurrences of integer in the input by Then the number of chains where integer can be used is restricted by If we construct the chains greedily then it s easy to see that the first chains will use And if we use as many occurrences of powers of 2 as possible that s better both because we are left with less elements to be assigned to the chains and because the largest powers of 2 in the chains are higher thus more elements can be assigned to the chains Having chains constructed how do we quickly check if we can assign the remaining elements to these chains This can also be done greedily If we can t assign the largest of the remaining elements to the longest chain then we can t assign this element to any chain so there s no possible assignment Otherwise remove the largest element and the longest chain from consideration and repeat the process until we either assign all the elements or run into a failure situation described above Why is greedy correct Consider a valid assignment where the largest element is assigned to some chain and some element is assigned to the longest chain If and it can be seen that we can as well reassign to and to to get another valid assignment Thus if there exists a valid assignment there also exists one with assigned to Implemented straightforwardly this solution works in In fact both factors of can be optimized First it can be seen that if is one possible answer but there is at least element equal to 1 not yet involved in any chains then is another possible answer since when we construct the th chain we only make the situation better we won t have to assigned the elements of this chain to other chains and we ll have another chain which can be used for assignment too Therefore we can perform a binary search on the smallest possible value of thus having to do assignments instead of Second let be the largest of the input integers All elements of the input sequence can be distributed into groups powers of 2 and integers between consecutive powers of 2 The integers in the groups are effectively indistinguishable from our point of view which allows us to do the assignment part in Applying any of these two optimizations was enough to solve the problem 
https://codeforces.com//contest/141/problem/D,748,D,141D,141,D. Take-off Ramps,Vasya participates in a ski race along the axis The start is at point and the finish is at that is at a distance meters from the start in the positive direction of the axis Vasya has been training so hard that he can run one meter in exactly one second Besides there are take off ramps on the track each ramp is characterized by four numbers represents the ramp s coordinate represents from how many meters Vasya will land if he goes down this ramp represents the flight time in seconds is the number indicating for how many meters Vasya should gather speed to get ready and fly off the ramp As Vasya gathers speed he should ski on the snow that is he should not be flying but his speed still equals one meter per second Vasya is allowed to move in on the axis but he is prohibited to cross the start line that is go to the negative semiaxis Vasya himself chooses which take off ramps he will use and in what order that is he is not obliged to take off from all the ramps he encounters Specifically Vasya can skip the ramp It is guaranteed that that is Vasya cannot cross the finish line in flight Your task is to find the minimum time that Vasya will spend to cover the distance ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\ntypedef pair< int, int > PRII;\ntypedef pair< double, double > PRDD;\n\n#define p_b push_back\n#define m_p make_pair\n#define x first\n#define y second\n\n#define Size(a) ((int)a.size())\n#define sqr(x) ((x)*(x))\n\n#define oo 1000000001\n#define eps 1e-9\nconst double pi = acos(-1.0);\n\n#define maxn 200000 + 10\n#define maxm 500000 + 10\n\nint n,m = 0;\nmap< int, int > s;\nmap< int, int >::iterator itr1,itr2;\n\nint totm = 0,e[maxm],last[maxm],f[maxm],g[maxm],now[maxn];\nint dist[maxn],pre[maxn],ramp[maxn],ans[maxn];\npriority_queue< PRII > que;\n\ninline void build( int u, int v, int d, int k )\n{\n    ++totm;\n    e[totm] = v;\n    last[totm] = now[u];\n    f[totm] = d;\n    g[totm] = k;\n    now[u] = totm;\n}\n\nint main()\n{\n    int i,L,x,d,t,p;\n    \n    scanf(""%d%d"",&n,&L);\n    s[0] = ++m;\n    s[L] = ++m;\n    for( i = 1 ; i <= n ; ++i )\n        {\n            scanf(""%d%d%d%d"",&x,&d,&t,&p);\n            if( x-p < 0 )\n                continue;\n            if( s.find(x-p) == s.end() )\n                s[x-p] = ++m;\n            if( s.find(x+d) == s.end() )\n                s[x+d] = ++m;\n            build(s[x-p],s[x+d],p+t,i);\n        }\n    for( itr1 = s.begin() ; ; ++itr1 )\n        {\n            itr2 = itr1, ++itr2;\n            if( itr2 == s.end() )\n                break;\n            build(itr1->y,itr2->y,itr2->x-itr1->x,0);\n            build(itr2->y,itr1->y,itr2->x-itr1->x,0);\n        }\n    \n    for( i = 1 ; i <= m ; ++i )\n        dist[i] = oo;\n    dist[1] = 0;\n    que.push(m_p(0,1));\n    while( Size(que) )\n        {\n            PRII tmp = que.top();\n            que.pop();\n            for( i = now[tmp.y] ; i ; i = last[i] )\n                if( dist[e[i]] > -tmp.x+f[i] )\n                    {\n                        dist[e[i]] = -tmp.x+f[i];\n                        que.push(m_p(-dist[e[i]],e[i]));\n                        pre[e[i]] = tmp.y;\n                        ramp[e[i]] = g[i];\n                    }\n        }\n        \n    printf(""%d\\n"",dist[2]);\n    for( i = 2 ; i != 1 ; i = pre[i] )\n        if( ramp[i] )\n            ans[++ans[0]] = ramp[i];\n    printf(""%d\\n"",ans[0]);\n    for( i = ans[0] ; i >= 1 ; --i )\n        printf(""%d%c"",ans[i],i>1?\' \':\'\\n\');    \n        \n    return 0;\n}\n']",,,"['graphs', 'shortest paths']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Take-off Ramps.json,https://codeforces.com//blog/entry/3571,Let s generate the weighted directed graph of all ramps The graphs vertexes are the important points on the line Ox there are points 0 L xi pi xi di The graphs edges are the possible ramp jumps transfer from point xi pi to point xi di or transfer from vertex in neighboring vertexes neighboring means that we get the next and previous important points on the line The weights of these edges are correspondingly pi ti and xv 1 xv xv xv 1 We must note that in the transfers we can t get in the negative part of Ox and we must delete this transfers Then we must find and output the shortest path in this graph from vertex 0 to L This can be done for example with Dijkstra s algorithm for the sparse graphs 
https://codeforces.com//contest/342/problem/E,3442,E,342E,342,E. Xenia and Tree,Xenia the programmer has a tree consisting of nodes We will consider the tree nodes indexed from 1 to We will also consider the first node to be initially painted red and the other nodes to be painted blue The between two tree nodes and is the number of edges in the shortest path between and Xenia needs to learn how to quickly execute queries of two types paint a specified blue node in red calculate which red node is the closest to the given one and print the shortest distance to the closest red node Your task is to write a program which will execute the described queries ,"['#define LOCAL\n\n/** ` Micro Mezzo Macro Flation -- Overheated Economy ., **/\n\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (n____=int(n),i=0;i<n____;++i)\n#define FOR_C_N(i, a, b) for (b____=int(b),i=a;i<b____;++i)\n#define DWN_C_N(i, b, a) for (a____=int(a),i=b-1;i>=a____;--i)\n#define REP_1_C_N(i, n) for (n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (a____=int(a),i=b;i>=a____;--i)\n\n#define ECH(it, A) for (typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define DO(n) while(n--)\n#define DO_C(n) int n____ = n; while(n____--)\n#define TO(i, a, b) int s_=a<b?1:-1,b_=b+s_;for(int i=a;i!=b_;i+=s_)\n#define TO_1(i, a, b) int s_=a<b?1:-1,b_=b;for(int i=a;i!=b_;i+=s_)\n#define SQZ(i, j, a, b) for (int i=int(a),j=int(b)-1;i<j;++i,--j)\n#define SQZ_1(i, j, a, b) for (int i=int(a),j=int(b);i<=j;++i,--j)\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, X) fP(ALL(A), X) // != A.end()\n#define CTN(T, x) (T.fP(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n\n#define Rush int T____; RD(T____); DO(T____)\n#pragma comment(linker, ""/STACK:36777216"")\n//#pragma GCC optimize (""O2"")\n#define Ruby system(""ruby main.rb"")\n#define Haskell system(""runghc main.hs"")\n#define Pascal system(""fpc main.pas"")\n\ntypedef long long LL;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VD;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef set<LL> SL;\ntypedef set<DB> SD;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef map<LL, int> MLI;\ntypedef map<DB, int> MDI;\ntypedef map<int, bool> MIB;\ntypedef map<string, bool> MSB;\ntypedef map<LL, bool> MLB;\ntypedef map<DB, bool> MDB;\ntypedef pair<int, int> PII;\ntypedef pair<int, bool> PIB;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\ntypedef set<PII> SII;\ntypedef map<PII, int> MPIII;\ntypedef map<PII, bool> MPIIB;\n\n/** I/O Accelerator **/\n\n/* ... :"" We are I/O Accelerator ... Use us at your own risk ;) ... "" .. */\n\ntemplate<class T> inline void RD(T &);\ntemplate<class T> inline void OT(const T &);\n\ninline int RD(){ int x; RD(x); return x;}\ntemplate<class T> inline T& _RD(T &x){ RD(x); return x;}\ninline void RC(char &c){scanf("" %c"", &c);}\ninline char RC(){ char x; RC(x); return x;}\ninline void RS(char *s){scanf(""%s"", s);}\n\ntemplate<class T0, class T1> inline void RD(T0 &x0, T1 &x1){RD(x0), RD(x1);}\ntemplate<class T0, class T1, class T2> inline void RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);}\ntemplate<class T0, class T1> inline void OT(T0 &x0, T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(T0 &x0, T1 &x1, T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\n\n\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){\n    while (!Q.empty()) Q.pop();\n}\n\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){\n    while (!Q.empty()) Q.pop();\n}\n\ntemplate<class T> inline void CLR(T &A){A.clear();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2){FLC(A0), FLC(A1), FLC(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3){FLC(A0), FLC(A1), FLC(A2), FLC(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4), FLC(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4), FLC(A5), FLC(A6);}\n\ntemplate<class T> inline void SRT(T &A){sort(ALL(A));}\ntemplate<class T, class C> inline void SRT(T &A, C B){sort(ALL(A), B);}\n\n/** Add - On **/\n\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = 3.14159265358979323846264; //M_PI;\n\n// <<= ` 0. Daily Use .,\n\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (b>a) a=b;}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(min(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\nint Ceil(int x, int y){return (x - 1) / y + 1;}\n\n// <<= ` 1. Bitwise Operation .,\ninline bool _1(int x, int i){return x & 1<<i;}\ninline bool _1(LL x, int i){return x & 1LL<<i;}\ninline LL _1(int i){return 1LL<<i;}\n//inline int _1(int i){return 1<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n//inline int _U(int i){return _1(i) - 1;};\n\n\ntemplate<class T> inline T low_bit(T x) {\n    return x & -x;\n}\n\ntemplate<class T> inline T high_bit(T x) {\n    T p = low_bit(x);\n    while (p != x) x -= p, p = low_bit(x);\n    return p;\n}\n\ninline int count_bits(int x){\n    x = (x & 0x55555555) + ((x & 0xaaaaaaaa) >> 1);\n    x = (x & 0x33333333) + ((x & 0xcccccccc) >> 2);\n    x = (x & 0x0f0f0f0f) + ((x & 0xf0f0f0f0) >> 4);\n    x = (x & 0x00ff00ff) + ((x & 0xff00ff00) >> 8);\n    x = (x & 0x0000ffff) + ((x & 0xffff0000) >> 16);\n    return x;\n}\n\ninline int count_bits(LL x){\n    x = (x & 0x5555555555555555LL) + ((x & 0xaaaaaaaaaaaaaaaaLL) >> 1);\n    x = (x & 0x3333333333333333LL) + ((x & 0xccccccccccccccccLL) >> 2);\n    x = (x & 0x0f0f0f0f0f0f0f0fLL) + ((x & 0xf0f0f0f0f0f0f0f0LL) >> 4);\n    x = (x & 0x00ff00ff00ff00ffLL) + ((x & 0xff00ff00ff00ff00LL) >> 8);\n    x = (x & 0x0000ffff0000ffffLL) + ((x & 0xffff0000ffff0000LL) >> 16);\n    x = (x & 0x00000000ffffffffLL) + ((x & 0xffffffff00000000LL) >> 32);\n    return x;\n}\n\nint reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\nLL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\n// <<= ` 2. Modular Arithmetic Basic .,\n\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int pow(int a, int b){\n    int c = 1;\n    while (b) {\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T>\ninline int pow(T a, int b){\n    T c(1);\n    while (b) {\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIA(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int sum(int a, int b, int MOD){\n    a += b; if (a >= MOD) a -= MOD;\n    return a;\n}\n\ninline int phi(int n){\n    int res = n;\n    for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n// <<= \'9. Comutational Geometry .,\n\nstruct Po; struct Line; struct Seg;\n\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\nstruct Po{\n    DB x, y;\n    Po(DB _x = 0, DB _y = 0):x(_x), y(_y){}\n\n    friend istream& operator >>(istream& in, Po &p){return in >> p.x >> p.y;}\n    friend ostream& operator <<(ostream& out, Po p){return out << ""("" << p.x << "", "" << p.y << "")"";}\n\n    friend bool operator ==(Po, Po);\n    friend bool operator !=(Po, Po);\n    friend Po operator +(Po, Po);\n    friend Po operator -(Po, Po);\n    friend Po operator *(Po, DB);\n    friend Po operator /(Po, DB);\n\n    bool operator < (const Po &rhs) const{return sgn(x, rhs.x) < 0 || sgn(x, rhs.x) == 0 && sgn(y, rhs.y) < 0;}\n    Po operator-() const{return Po(-x, -y);}\n    Po& operator +=(Po rhs){x += rhs.x, y += rhs.y; return *this;}\n    Po& operator -=(Po rhs){x -= rhs.x, y -= rhs.y; return *this;}\n    Po& operator *=(DB k){x *= k, y *= k; return *this;}\n    Po& operator /=(DB k){x /= k, y /= k; return *this;}\n\n    DB length_sqr(){return sqr(x) + sqr(y);}\n    DB length(){return sqrt(length_sqr());}\n\n    DB atan(){\n        return atan2(y, x);\n    }\n\n    void input(){\n        scanf(""%lf %lf"", &x, &y);\n    }\n};\n\nbool operator ==(Po a, Po b){return sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0;}\nbool operator !=(Po a, Po b){return sgn(a.x - b.x) != 0 || sgn(a.y - b.y) != 0;}\nPo operator +(Po a, Po b){return Po(a.x + b.x, a.y + b.y);}\nPo operator -(Po a, Po b){return Po(a.x - b.x, a.y - b.y);}\nPo operator *(Po a, DB k){return Po(a.x * k, a.y * k);}\nPo operator *(DB k, Po a){return a * k;}\nPo operator /(Po a, DB k){return Po(a.x / k, a.y / k);}\n\nstruct Line{\n    Po a, b;\n    Line(Po _a = Po(), Po _b = Po()):a(_a), b(_b){}\n    Line(DB x0, DB y0, DB x1, DB y1):a(Po(x0, y0)), b(Po(x1, y1)){}\n    Line(Seg);\n\n    friend ostream& operator <<(ostream& out, Line p){return out << p.a << ""-"" << p.b;}\n};\n\nstruct Seg{\n    Po a, b;\n    Seg(Po _a = Po(), Po _b = Po()):a(_a), b(_b){}\n    Seg(DB x0, DB y0, DB x1, DB y1):a(Po(x0, y0)), b(Po(x1, y1)){}\n    Seg(Line l);\n\n    friend ostream& operator <<(ostream& out, Seg p){return out << p.a << ""-"" << p.b;}\n    DB length(){return (b - a).length();}\n};\n\nLine::Line(Seg l):a(l.a), b(l.b){}\nSeg::Seg(Line l):a(l.a), b(l.b){}\n\n#define innerProduct dot\n#define scalarProduct dot\n#define dotProduct dot\n#define outerProduct det\n#define crossProduct det\n\ninline DB dot(DB x1, DB y1, DB x2, DB y2){return x1 * x2 + y1 * y2;}\ninline DB dot(Po a, Po b){return dot(a.x, a.y, b.x, b.y);}\ninline DB dot(Po p0, Po p1, Po p2){return dot(p1 - p0, p2 - p0);}\ninline DB dot(Line l1, Line l2){return dot(l1.b - l1.a, l2.b - l2.a);}\ninline DB det(DB x1, DB y1, DB x2, DB y2){return x1 * y2 - x2 * y1;}\ninline DB det(Po a, Po b){return det(a.x, a.y, b.x, b.y);}\ninline DB det(Po p0, Po p1, Po p2){return det(p1 - p0, p2 - p0);}\ninline DB det(Line l1, Line l2){return det(l1.b - l1.a, l2.b - l2.a);}\n\ntemplate<class T1, class T2> inline DB dist(T1 x, T2 y){return sqrt(dist_sqr(x, y));}\n\ninline DB dist_sqr(Po a, Po b){return sqr(a.x - b.x) + sqr(a.y - b.y);}\ninline DB dist_sqr(Po p, Line l){Po v0 = l.b - l.a, v1 = p - l.a; return sqr(fabs(det(v0, v1))) / v0.length_sqr();}\ninline DB dist_sqr(Po p, Seg l){\n    Po v0 = l.b - l.a, v1 = p - l.a, v2 = p - l.b;\n    if (sgn(dot(v0, v1)) * sgn(dot(v0, v2)) <= 0) return dist_sqr(p, Line(l));\n    else return min(v1.length_sqr(), v2.length_sqr());\n}\n\ninline DB dist_sqr(Line l, Po p){return dist_sqr(p, l);}\ninline DB dist_sqr(Seg l, Po p){return dist_sqr(p, l);}\n\ninline DB dist_sqr(Line l1, Line l2){\n    if (sgn(det(l1, l2)) != 0) return 0;\n    return dist_sqr(l1.a, l2);\n}\ninline DB dist_sqr(Line l1, Seg l2){\n    Po v0 = l1.b - l1.a, v1 = l2.a - l1.a, v2 = l2.b - l1.a; DB c1 = det(v0, v1), c2 = det(v0, v2);\n    return sgn(c1) != sgn(c2) ? 0 : sqr(min(fabs(c1), fabs(c2))) / v0.length_sqr();\n}\n\nbool isIntersect(Seg l1, Seg l2){\n\n    //if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b) return true;\n\n    return\n        min(l1.a.x, l1.b.x) <= max(l2.a.x, l2.b.x) &&\n        min(l2.a.x, l2.b.x) <= max(l1.a.x, l1.b.x) &&\n        min(l1.a.y, l1.b.y) <= max(l2.a.y, l2.b.y) &&\n        min(l2.a.y, l2.b.y) <= max(l1.a.y, l1.b.y) &&\n    sgn( det(l1.a, l2.a, l2.b) ) * sgn( det(l1.b, l2.a, l2.b) ) <= 0 &&\n    sgn( det(l2.a, l1.a, l1.b) ) * sgn( det(l2.b, l1.a, l1.b) ) <= 0;\n\n}\n\ninline DB dist_sqr(Seg l1, Seg l2){\n    if (isIntersect(l1, l2)) return 0;\n    else return min(dist_sqr(l1.a, l2), dist_sqr(l1.b, l2), dist_sqr(l2.a, l1), dist_sqr(l2.b, l1));\n}\n\ninline bool isOnExtremePoint(const Po &p, const Seg &l){\n    return p == l.a || p == l.b;\n}\n\ninline bool isOnseg(const Po &p, const Seg &l){\n\n    //if (p == l.a || p == l.b) return false;\n\n    return sgn(det(p, l.a, l.b)) == 0 &&\n        sgn(l.a.x, p.x) * sgn(l.b.x, p.x) <= 0 && sgn(l.a.y, p.y) * sgn(l.b.y, p.y) <= 0;\n}\n\ninline Po intersect(const Line &l1, const Line &l2){\n    return l1.a + (l1.b - l1.a) * (det(l2.a, l1.a, l2.b) / det(l2, l1));\n}\n\n// perpendicular foot\ninline Po intersect(const Po & p, const Line &l){\n    return intersect(Line(p, p + Po(l.a.y - l.b.y, l.b.x - l.a.x)), l);\n}\n\ninline Po rotate(Po p, DB alpha, Po o = Po()){\n    p.x -= o.x, p.y -= o .y;\n    return Po(p.x * cos(alpha) - p.y * sin(alpha), p.y * cos(alpha) + p.x * sin(alpha)) + o;\n}\n\n// <<= \' A. Random Event ..\n\ninline int rand32(){return (bool(rand() & 1) << 30) | (rand() << 15) + rand();}\ninline int random32(int l, int r){return rand32() % (r - l + 1) + l;}\ninline int random(int l, int r){return rand() % (r - l + 1) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return rand() % 2;}\n\n// <<= \' 0. I/O Accelerator interface .,\n\ntemplate<class T> inline void RD(T &x){\n    //cin >> x;\n    //scanf(""%d"", &x);\n    char c; for (c = getchar(); c < \'0\'; c = getchar()); x = c - \'0\'; for (c = getchar(); c >= \'0\'; c = getchar()) x = x * 10 + c - \'0\';\n    //char c; c = getchar(); x = c - \'0\'; for (c = getchar(); c >= \'0\'; c = getchar()) x = x * 10 + c - \'0\';\n}\n\ntemplate<class T> inline void OT(const T &x){\n    printf(""%d\\n"", x);\n}\n\n/* .................................................................................................................................. */\n\nconst int N = 100009, M = N * 2;\n\nint hd[N], prd[M], suc[M], to[M];\n// Adjcent List .. .\nint size[N], head[N], F[N], D[N], Hid[N];\n// Vertex .. .\nint n, nn;\n\n#define black(x) H[x].B[1]\n\n#define lx (x<<1)\n#define rx (lx|1)\n#define y (x>>1)\n\nstruct Heap{\n\n    VI B; int *H, *P;\n    int n;\n\nprivate:\n\n    inline int A(int x){return B[H[x]];}\n\n    void Swap(int a, int b){\n        swap(H[a], H[b]);\n        P[H[a]] = a, P[H[b]] = b;\n    }\n\n    inline void Up(int x){\n        while (A(y) > A(x)){\n            Swap(x, y), x = y;\n        }\n    }\n\n    inline void Down(int x){\n        int h = x; while (true){\n            if (lx <= n && A(lx) < A(h)) h = lx;\n            if (rx <= n && A(rx) < A(h)) h = rx;\n            if (h == x) break;\n            Swap(h, x), x = h;\n        }\n    }\n\npublic:\n\n    void Build(){\n        n = SZ(B); H = new int[n], P = new int[n]; --n;\n        FOR_1(i, 0, n) H[i] = P[i] = i; DWN_1(i, n>>1, 1) Down(i);\n    }\n\n    void Update(int x, int v){\n        if (B[x] > v) B[x] = v, Up(P[x]);\n        else B[x] = v, Down(P[x]);\n    }\n\n    int top(){\n        return A(1);\n    }\n\n} H[N];\n\n#undef y\n\n#define root 1, 0, n-1\n#define m ((l+r)>>1)\n#define lc lx, l, m\n#define rc rx, m+1, r\n\n#define Update(x) ml[x] = min(ml[lx], d(l, m+1) + ml[rx]), mr[x] = min(mr[rx], d(m, r) + mr[lx])\n#define Upleaf(x) ml[x] = mr[x] = h.top()\n\nstruct Interval_Tree{\n\n    VI id; int *ml, *mr;\n    int n, _x, offset;\n\nprivate:\n\n    int d(int l, int r){\n        return r - l;\n    }\n\n#define h H[id[l]]\n    void _B(int x, int l, int r){\n        if (l == r) ml[x] = mr[x] = INF;\n        else _B(lc), _B(rc), ml[x] = mr[x] = INF;\n    }\n\n    void _M(int x, int l, int r){\n        if (l == r) Upleaf(x);\n        else {if (_x <= m) _M(lc); if (m < _x) _M(rc); Update(x);}\n    }\n\n    int _MinL(int x, int l, int r){\n        if (l == r) return ml[x];\n        else return _x <= m ? _MinL(lc) : min(_MinL(rc), mr[lx] + d(m, _x));\n    }\n\n    int _MinR(int x, int l, int r){\n        if (l == r) return mr[x];\n        else return _x <= m ? min(_MinR(lc), d(_x, m+1) + ml[rx]) : _MinR(rc);\n    }\n\n#undef h\n\npublic:\n\n    int d(int x){\n        return d(0, D[x] - offset);\n    }\n\n    void Build(){\n        n = SZ(id); offset = D[id[0]]; int t=1; while(t<n) t<<=1; t<<=1;\n        ml = new int[t], mr = new int[t],  _B(root);\n    }\n\n    void Modify(int x){\n        _x = D[x] - offset, _M(root);\n    }\n\n    int MinR(int x){\n        _x = D[x] - offset; return _MinR(root);\n    }\n\n    int MinL(int x){\n        _x = D[x] - offset; return _MinL(root);\n    }\n\n    int MinL(){return ml[1];}\n\n} T[N];\n\n#undef Update\n\ninline void del(int x){\n    if (x == hd[to[x^1]]) prd[hd[to[x^1]] = suc[x]] = 0;\n    else suc[prd[suc[x]] = prd[x]] = suc[x];\n}\n\n#define TRA(i, x) for(int i=hd[x];i;i=suc[i])\n#define u q[i]\n#define v to[ii]\n\nint q[N]; void bfs(){\n    n = 0, q[n++] = 1; REP(i, n) TRA(ii, u) if(!F[v])\n        q[n++] = v, F[v] = u, D[v] = D[u] + 1, del(ii^1);\n\n    DWN(i, n, 0){\n        size[u] = 1; TRA(ii, u)\n            size[u] += size[v];\n    }\n}\n\nvoid hld(){\n    REP(i, n) if (!head[u]){\n        int x = u, y; while (true){\n            T[u].id.PB(x); y = 0; head[x] = u; TRA(ii, x){\n                if(!y || size[v] > size[y]) y = v;\n            }\n            if (!y) break;\n            x = y;\n        }\n    }\n}\n\nvoid init(){\n\n    DWN(i, n, 0){\n\n        int cnt = 1; H[u].B.PB(INF);\n\n        TRA(ii, u) if(head[v] != head[u])\n            Hid[v]=++cnt, H[u].B.PB(INF);\n\n        H[u].Build(); if (head[u] == u)  // is path head ? ..\n            T[u].Build();\n    }\n}\n\n#undef u\n#undef v\n\nvoid Up(int& x){\n    T[head[x]].Modify(x), x = head[x];\n}\n\nvoid Modify(int u){\n\n    if (black(u)) H[u].Update(1, 0);\n    else H[u].Update(1, INF);\n\n    Up(u); int v = F[u]; while (v){\n        H[v].Update(Hid[u], T[u].MinL() + 1);\n        Up(v), v = F[u = v];\n    }\n}\n\nint Query(int u){\n\n    if (!black(u)) return 0;\n\n    int res = INF, path = 0, t; while (u){\n        t = min(T[head[u]].MinL(u), T[head[u]].MinR(u));\n        checkMin(res, t + path); if (!t) break; // Cut .. -2s..\n        path += T[head[u]].d(u) + 1;\n        u = F[head[u]];\n    }\n    return res == INF ? -1 : res;\n}\n\nint vvv[N];\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""r"", stdin);\n#endif\n    int Q; RD(n, Q);\n    FOR_C(i, 2, n << 1){\n        RD(to[i], to[i|1]);\n        prd[hd[to[i^1]]] = i, suc[i] = hd[to[i^1]], hd[to[i^1]] = i, ++i;\n        prd[hd[to[i^1]]] = i, suc[i] = hd[to[i^1]], hd[to[i^1]] = i;\n    }\n\n\n\n    REP_1(i, n) H[i].B.PB(-INF); // offset .. .\n\n\n\n    bfs(); hld(); init(); // heavy light decomposition .. .\n\n\n        Modify(1);\nvvv[1] = 1;\n    DO(Q){\n        if (RD()==2) {\n                OT(Query(RD()));\n        }\n        else {\n            int ttt  = RD ();\n            if (vvv[ttt] == 0)\n                Modify(ttt);\n            vvv[ttt] = 1;\n        }\n    }\n}\n']",,,"['data structures', 'divide and conquer', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Xenia and Tree.json,https://codeforces.com/blog/entry/8800,The problem can be solved in different ways The most easy idea is sqrt optimization Split all queries into blocks Each block we will process separately Before processing each block we should calculate minimum distances from every node to the closest red node using bfs To answer the query we should update this value by shortest distances to red nodes in current block The solution becomes simple Every queries we make simple bfs and for every node WE calculate value the shortest distance to some red node from node Then to answer the query of type 2 you should calculate where every red node which becomes red in current block of length Distance between two nodes can be got using preprocessing for lca 
https://codeforces.com//contest/835/problem/A,116346,A,835A,835,A. Key races,Two boys decided to compete in text typing on the site Key races During the competition they have to type a text consisting of characters The first participant types one character in milliseconds and has ping milliseconds The second participant types one character in milliseconds and has ping milliseconds If connection ping delay is milliseconds the competition passes for a participant as follows Exactly after milliseconds after the start of the competition the participant receives the text to be entered Right after that he starts to type it Exactly milliseconds after he ends typing all the text the site receives information about it The winner is the participant whose information on the success comes earlier If the information comes from both participants at the same time it is considered that there is a draw Given the length of the text and the information about participants determine the result of the game ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint main()\n{\n\tint s,v1,v2,t1,t2;\n\tint s1,s2;\n\tscanf(""%d%d%d%d%d"",&s,&v1,&v2,&t1,&t2);\n\ts1=2*t1+s*v1;\n\ts2=2*t2+s*v2;\n\tif(s1<s2)\n\t\tprintf(""First\\n"");\n\telse if(s2<s1)\n\t\tprintf(""Second\\n"");\n\telse\n\t\tprintf(""Friendship\\n"");\n\treturn 0;\n}']",,,['math'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Key races.json,https://codeforces.com//blog/entry/53588,Information on the success of the first participant will come in milliseconds of the second participant in milliseconds We need to compare these numbers and print the answer depending on the comparison result 
https://codeforces.com//contest/1316/problem/D,552823,D,1316D,1316,D. Nash Matrix,Nash designed an interesting yet simple board game where a player is simply required to follow instructions written on the cell where the player currently stands This board game is played on the n times n board Rows and columns of this board are numbered from 1 to n The cell on the intersection of the r th row and c th column is denoted by r c Some cells on the board are called On each cell of the board there is written one of the following 5 characters U D L R or X instructions for the player Suppose that the current cell is r c If the character is R the player should move to the right cell r c 1 for L the player should move to the left cell r c 1 for U the player should move to the top cell r 1 c for D the player should move to the bottom cell r 1 c Finally if the character in the cell is X then this cell is the The player should remain in this cell the game for him isn t very interesting from now on It is guaranteed that the characters are written in a way that the player will never have to step outside of the board no matter at which cell he starts As a player starts from a cell he moves according to the character in the current cell The player keeps moving until he lands in a blocked zone It is also possible that the player will keep moving infinitely long For every of the n 2 cells of the board Alice your friend wants to know how will the game go if the player starts in this cell For each starting cell of the board she writes down the cell that the player stops at or that the player never stops at all She gives you the information she has written for each cell r c she wrote a pair x y meaning if a player had started at r c he would end up at cell x y or a pair 1 1 meaning if a player had started at r c he would keep moving infinitely long and would never enter the blocked zone It might be possible that Alice is trying to fool you and there s no possible grid that satisfies all the constraints Alice gave you For the given information Alice provided you you are required to decipher a possible board or to determine that such a board doesn t exist If there exist several different boards that satisfy the provided information you can find any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\npair<int, int> a[1005][1005];\nchar mp[1005][1005];\npair<int, int> stk[2000005];\nbool mark[1005][1005];\nint n, top;\nchar getch(int x) {\n\tif (x == 0) return \'L\';\n\tif (x == 1) return \'R\';\n\tif (x == 2) return \'U\';\n\treturn \'D\';\n}\n\nvoid dfs(int x, int y) {\n\tmark[x][y] = true;\n\tfor (int i = 0; i < 4; ++ i) {\n\t\tint nx = x + d[i][0];\n\t\tint ny = y + d[i][1];\n\t\tif (nx < 1 || nx > n || ny < 1 || ny > n) continue;\n\t\tif (a[x][y] != a[nx][ny]) continue;\n\t\tif (mark[nx][ny]) continue;\n\t\tmp[nx][ny] = getch(i);\n\t\tdfs(nx, ny);\n\t}\n}\n\nint main( ) {\n\tbool ok = false;\n\tint x, y;\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tscanf(""%d %d"", &x, &y);\n\t\t\tif (make_pair(x, y) == make_pair(i, j)) {\n\t\t\t\tstk[++ top] = make_pair(i, j);\n\t\t\t}\n\t\t\ta[i][j] = make_pair(x, y);\n\t\t}\n\tfor (int i = 1; i <= top; i ++) {\n\t\tdfs(stk[i].first, stk[i].second);\n\t\tmp[stk[i].first][stk[i].second] = \'X\';\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (a[i][j] != make_pair(-1, -1)) continue;\n\t\t\tint idx = -1, idy = -1;\n\t\t\tif (a[i + 1][j] == make_pair(-1, -1)) {\n\t\t\t\tidx = i + 1;\n\t\t\t\tidy = j;\n\t\t\t\tmp[i][j] = \'D\';\n\t\t\t\tmp[i + 1][j] = \'U\';\n\t\t\t}\n\t\t\tif (a[i - 1][j] == make_pair(-1, -1)) {\n\t\t\t\tidx = i - 1;\n\t\t\t\tidy = j;\n\t\t\t\tmp[i][j] = \'U\';\n\t\t\t\tmp[i - 1][j] = \'D\';\n\t\t\t}\n\t\t\tif (a[i][j - 1] == make_pair(-1, -1)) {\n\t\t\t\tidx = i;\n\t\t\t\tidy = j - 1;\n\t\t\t\tmp[i][j] = \'L\';\n\t\t\t\tmp[i][j - 1] = \'R\';\n\t\t\t}\n\t\t\tif (a[i][j + 1] == make_pair(-1, -1)) {\n\t\t\t\tidx = i;\n\t\t\t\tidy = j + 1;\n\t\t\t\tmp[i][j] = \'R\';\n\t\t\t\tmp[i][j + 1] = \'L\';\n\t\t\t}\n\t\t\tif (idx == -1 && idy == -1) continue;\n\t\t\tdfs(i, j);\n\t\t\tdfs(idx, idy);\n\t\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (!mark[i][j]) ok = true;\n\tif (ok) printf(""INVALID\\n"");\n\telse {\n\t\tprintf(""VALID\\n"");\n\t\tfor (int i = 1; i <= n; puts(""""), i ++)\n\t\t\tfor (int j = 1; j <= n; j ++)\n\t\t\t\tprintf(""%c"", mp[i][j]);\n\t}\t\n\treturn 0;\n}\n\n']",,,"['constructive algorithms', 'dfs and similar', 'graphs', 'implementation']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Nash Matrix.json,https://codeforces.com//blog/entry/74493,If there exists a valid board satisfying the input matrix one can notice two types of clusters in the input matrix first a cluster of connected cells having the same stopping point and second a cluster of connected cells which do not have any stopping point i e all having pair Among the cells having a stopping point we can start a dfs bfs from all the cells having stopping point as the cell itself i e cells has stopping cell as While performing the traversal we move into any neighbouring cell from current cell if it has the same stopping cell as the current cell This way all the cells in clusters of first kind will have an instruction associated or For the cells having no stopping cell we need to put instructions on them such that starting on them a player keeps moving in a cycle So these cells are either a part of cycle or have paths starting from them leading into a cycle The simplest way to do so is to try to put such cells into disjoint pairs cycles of length 2 of neighbouring cells each cell in pair pointing towards the other Note that after trying to pair up these cells having no stopping point there are no more two adjacent such cells both unpaired Now for any such cell which could not be paired up if it has no adjacent paired up cell then it is a case of INVALID else just put a direction on the cell so that player moves into the adjacent paired up cell Now if any cell remains without having any instruction alloted it is a case of INVALID The complexity of the above solution 
https://codeforces.com//contest/461/problem/E,13284,E,461E,461,E. Appleman and a Game,Appleman and Toastman like games Today they play a game with strings with the following rules Firstly Toastman tells Appleman two strings and both consisting only of letters Then Appleman must build string as quickly as possible Initially he has empty string and in one second he can append to end of the current string any contiguous substring of Now Toastman and Appleman are beginning to play the game Toastman has already told string to Appleman but he hasn t come up with string yet Toastman only thinks that he should choose string consisting of characters Of course he wants to find the worst string for Appleman such string that Appleman will spend as much time as possible during the game Tell Toastman how much time will Appleman spend during the game if Toastman finds the worst string for him You can assume that Appleman plays optimally therefore he builds any string in minimal possible time ,"['/*\n * cheat.cpp\n *\n *  Created on: 2012-5-25\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <string>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_LEN = int(1e5) + 10;\n\nstruct State {\n\tState*suf, *go[4];\n\tint val;\n\tState() :\n\t\t\tsuf(0), val(0) {\n\t\tmemset(go, 0, sizeof go);\n\t}\n}*root, *last;\nState statePool[MAX_LEN * 2], *cur = statePool;\n\nvoid init() {\n\troot = last = cur++;\n}\n\nvoid extend(int w) {\n\tState*p = last, *np = cur++;\n\tnp->val = p->val + 1;\n\twhile (p && !p->go[w])\n\t\tp->go[w] = np, p = p->suf;\n\tif (!p)\n\t\tnp->suf = root;\n\telse {\n\t\tState*q = p->go[w];\n\t\tif (p->val + 1 == q->val)\n\t\t\tnp->suf = q;\n\t\telse {\n\t\t\tState*nq = cur++;\n\t\t\tmemcpy(nq->go, q->go, sizeof q->go);\n\t\t\tnq->val = p->val + 1;\n\t\t\tnq->suf = q->suf;\n\t\t\tq->suf = nq;\n\t\t\tnp->suf = nq;\n\t\t\twhile (p && p->go[w] == q)\n\t\t\t\tp->go[w] = nq, p = p->suf;\n\t\t}\n\t}\n\tlast = np;\n}\n\nint buf[MAX_LEN];\n//int n, m;\ntypedef long long int64;\ntypedef vector<vector<int64> > mat;\n\nconst int64 INF = 1LL << 61;\n\nmat zero(int n) {\n\tmat a(n, vector<int64>(n, 0));\n\treturn a;\n}\n\nmat unit(int n) {\n\tmat c = zero(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tc[i][j] = (i == j) ? 0 : INF;\n\t\t}\n\t}\n\treturn c;\n}\n\nmat mul(mat a, mat b) {\n\tint n = a.size();\n\tmat c = zero(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tc[i][j] = INF;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tc[i][j] = min(c[i][j], a[i][k] + b[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nlong long N;\nint n;\n\nint64 COST[4][4];\nint main() {\n\tinit();\n\tcin >> N;\n\tstring t;\n\tcin >> t;\n\tn = t.size();\n\tstring ABCD = ""ABCD"";\n\tfor (int i = 0; i < t.size(); ++i) {\n\t\tint me = ABCD.find(t[i]);\n\t\tbuf[i] = me;\n\t\textend(me);\n\t}\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tCOST[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (int forbid = 0; forbid < 4; ++forbid) {\n\t\tState*cur = root;\n\t\tint l = 0;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\twhile (i + l < n && cur->go[forbid])\n\t\t\t\tcur = cur->go[buf[i + l]], l++;\n\t\t\tif (!cur->go[forbid]) {\n//\t\t\t\tCOST[buf[i]][forbid] = l;\n\t\t\t\tCOST[buf[i]][forbid] = min(COST[buf[i]][forbid], 1LL * l);\n\t\t\t}\n\t\t\tif (l > 0) {\n\t\t\t\t--l;\n\t\t\t\tif (l <= cur->suf->val)\n\t\t\t\t\tcur = cur->suf;\n\t\t\t}\n\t\t}\n\t}\n\n//\tfor (int i = 0; i < 4; ++i) {\n//\t\tfor (int j = 0; j < 4; ++j) {\n//\t\t\tcout << COST[i][j] << "" "";\n//\t\t}\n//\t\tcout << endl;\n//\t}\n\n\tmat one = zero(4);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tone[i][j] = COST[i][j];\n\t\t}\n\t}\n\n\tvector<mat> pw(70);\n\tpw[0] = one;\n\tfor (int i = 1; i < 70; ++i) {\n\t\tpw[i] = mul(pw[i - 1], pw[i - 1]);\n\t}\n\tmat cur = unit(4);\n\tlong long ans = 0;\n\tfor (int i = 70 - 1; i >= 0; --i) {\n\t\tmat ncur = mul(cur, pw[i]);\n\t\tint64 best = INF;\n\t\tfor (int a = 0; a < 4; ++a) {\n\t\t\tfor (int b = 0; b < 4; ++b) {\n\t\t\t\tbest = min(best, ncur[a][b]);\n\t\t\t}\n\t\t}\n\t\tif (best <= N) {\n\t\t\tcur = ncur;\n\t\t\tans += 1LL << i;\n\t\t}\n\t}\n\tint64 best = INF;\n\tfor (int a = 0; a < 4; ++a) {\n\t\tfor (int b = 0; b < 4; ++b) {\n\t\t\tbest = min(best, cur[a][b]);\n\t\t}\n\t}\n\tif (best < N)\n\t\t++ans;\n\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['binary search', 'shortest paths', 'strings']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Appleman and a Game.json,https://codeforces.com/blog/entry/13568,Let C be the number of characters here C 4 Given string S the way to achieve minimum steps is as follows Append one of the longest substring of T that fits current position of string S Appending a not longest substring can be replaced by appending longest substring and shortening the next substring appended Let dp K c1 c2 be defined as the minimum length of string that can be obtained by appending a string K times and that starts by character c1 and whose next character is c2 Note that next character is not counted in the length dp 1 can be calculated as follows For every string of length L expressed by C characters if the string is not included in T update the dp table as dp 1 the string s first character its last character min dp 1 its first character its last character L 1 For any c1 c2 dp 1 c1 c2 is smaller than or equal to log C T 1 2 since the kind of strings of length log C T 1 2 that start by c1 and end by c2 is equals to T 1 Therefore for L 1 log T 1 2 try all the strings as described above Also we can use trie that contains all substrings of T of length log C T 1 2 and find what can t be described as a substring of T by one step Since dp k 1 c1 c2 min dp k c1 c3 dp 1 c3 c2 c3 1 C we can use matrix multiplication to get dp K For a integer K if there is c1 c2 such that dp K c1 c2 S the answer is greater than K Otherwise the answer is smaller than or equal to K Since answer is bigger or equal to 1 and smaller or equal to S we can use binary search to find the ansewr O T log T 2 C 2 C 3 log S 2 BONUS Is there any algorithm that solves in O 1 or O C foo that is not depended on S for each S with pre calc Some hints Maximal value of dp 1 Minimal value of dp 1 2 let s call the maximal value dp 1 i j L Here any C L 2 strings are contained in T as substring so for any c1 c2 dp 1 c1 c2 L 2 Maximal value of dp 1 k minimal value of dp 1 k 1 k 1 C Maximal value of dp 1 k minimal value of dp 1 k 1 k 1 C Even if we use these hints and make C 3 the implementation would be not easy If you come up with smart way please comment here 
https://codeforces.com//contest/222/problem/D,1639,D,222D,222,D. Olympiad,A boy named Vasya has taken part in an Olympiad His teacher knows that in total Vasya got at least points for both tours of the Olympiad The teacher has the results of the first and the second tour of the Olympiad but the problem is the results have only points no names The teacher has to know Vasya s chances Help Vasya s teacher find two numbers the best and the worst place Vasya could have won Note that the total results table sorts the participants by the sum of points for both tours the first place has the participant who has got the most points If two or more participants have got the same number of points it s up to the jury to assign places to them according to their choice It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nmultiset<int> s;\nint a[ 100001 ], b[ 100001 ];\n\nint main( )\n{\n\tint n, p, i, t1, t2, q = 1000000000, ans = 1;\n\tmultiset<int>::iterator ii;\n\tscanf(""%d%d"", &n, &p);\n\tfor ( i = 0; i < n; i++ ) scanf(""%d"", &a[ i ]);\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tscanf(""%d"", &b[ i ]);\n\t\ts.insert( b[ i ] );\n\t}\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tii = s.lower_bound( p - a[ i ] );\n\t\tif ( ii != s.end( ) )\n\t\t\tif ( q > *ii + a[ i ] )\n\t\t\t{\n\t\t\t\tq = *ii + a[ i ];\n\t\t\t\tt1 = *ii;\n\t\t\t\tt2 = i;\n\t\t\t}\n\t}\n\tii = s.find( t1 );\n\ts.erase( ii );\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tif ( i == t2 ) continue;\n\t\tii = s.lower_bound( q - a[ i ] );\n\t\tif ( ii != s.end( ) )\n\t\t{\n\t\t\tans++;\n\t\t\ts.erase( ii );\n\t\t}\n\t}\n\tprintf(""1 %d\\n"", ans);\n\treturn 0;\n}\n']",,,"['binary search', 'greedy', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Olympiad.json,https://codeforces.com//blog/entry/5251,First of all note that in any case the best place which Vasya can take is the first place for he can earn maximum points Now we must find the worst place which Vasya can take We need to find maximal matching in bipartite graph where the edge between vertice i from the first part and vertice j from the second part exists if a i b j x To solve this task it is enough just to sort the vertices in both parts of the graph by their weights and use two pointers method Suppose that we have sorted all the vertices by non increasing points a1 a2 an Let s take two pointers L 1 in the first part and R N in the second part While a L b R x we must decrease R to find the first vertice such a L b R x When we found such R we must add this edge to the answer i e increase the answer increase L by 1 decrease R by 1 It is easy to show why this algo is correct and it finds the optimal solution I have discovered a truly marvelous proof of this but the margins of this analysis are too narrow to for him Complexity O N log N for sorting and O N for two pointers 
https://codeforces.com//contest/512/problem/C,21644,C,512C,512,C. Fox And Dinner,Fox Ciel is participating in a party in Prime Kingdom There are foxes there include Fox Ciel The i th fox is years old They will have dinner around some round tables You want to distribute foxes such that Each fox is sitting at some table Each table has at least 3 foxes sitting around it The sum of ages of any two adjacent foxes around each table should be a prime number If foxes are sitting around table in clockwise order then for and are adjacent and and are also adjacent If it is possible to distribute the foxes in the desired manner find out a way to do that ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct TEdge {\n    int from, to;\n    int c, w;\n\n    TEdge(int from = 0, int to = 0, int c = 0)\n        : from(from)\n        , to(to)\n        , c(c)\n        , w(0)\n    {\n    }\n};\n\nconst int MAXN = 300;\nvector<TEdge> edges;\nvi e[MAXN];\nint vis[MAXN];\n\nvoid addEdge(int from, int to, int c) {\n    e[from].pb(edges.size());\n    edges.pb(TEdge(from, to, c));\n    e[to].pb(edges.size());\n    edges.pb(TEdge(to, from, 0));\n}\n\nbool dfs(int v, int t) {\n    if (v == t) return true;\n    if (vis[v]) return false;\n    vis[v] = 1;\n    forn(i, e[v].size()) {\n        TEdge w = edges[e[v][i]];\n        if (w.w >= w.c) continue;\n        if (dfs(w.to, t)) {\n            ++edges[e[v][i]].w;\n            --edges[e[v][i] ^ 1].w;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; ++i) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nvi g[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vi a(N);\n    forn(i, N) cin >> a[i];\n    forn(i, N) {\n        if (a[i] % 2 == 0) addEdge(N, i, 2);\n        else addEdge(i, N + 1, 2);\n    }\n    forn(i, N) forn(j, i) {\n        if (!isPrime(a[i] + a[j])) continue;\n        if (a[i] % 2 == 0) addEdge(i, j, 1);\n        else addEdge(j, i, 1);\n    }\n    forn(i, N) {\n        forn(j, MAXN) vis[j] = 0;\n        if (!dfs(N, N + 1)) {\n            cout << ""Impossible\\n"";\n            return 0;\n        }\n    }\n    forn(i, edges.size()) {\n        int x = edges[i].from, y = edges[i].to;\n        if (x < N && y < N && edges[i].w > 0) {\n            g[x].pb(y);\n            g[y].pb(x);\n        }\n    }\n\n    vvi ans;\n    forn(i, N) vis[i] = 0;\n    forn(i, N) {\n        if (vis[i]) continue;\n        int j = g[i][0], p = i;\n        vi res;\n        res.pb(i);\n        vis[i] = 1;\n        while (j != i) {\n            vis[j] = 1;\n            res.pb(j);\n            int t = 0;\n            while (g[j][t] == p) ++t;\n            p = j;\n            j = g[j][t];\n        }\n        ans.pb(res);\n    }\n    cout << ans.size() << \'\\n\';\n    forn(i, ans.size()) {\n        cout << ans[i].size();\n        for (int x: ans[i]) cout << \' \' << x + 1;\n        cout << \'\\n\';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",,,"['flows', 'graph matchings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Fox And Dinner.json,https://codeforces.com/blog/entry/16173,First finding is if is a prime then one of them is an odd number another is an even number that s why we set Then we could find every odd number have exactly 2 even number as neighborhood and every even number have exactly 2 odd number as neighborhood And that means we need to have a solution So it looks like bipartite graph matching but every element matched 2 elements And in fact it can be handled by maxflow For each odd number we add a node on the left side and link it from source with capacity equals to 2 and for each even number we add a node on the right side and link it to sink with capacity equals to 2 And if sum of two numbers is a prime number we link them with capacity equals to 1 Then we solve the max flow it have solution if and only if We can construct the answer cycles from the matches Note Actually this task is still solvable if we allow But you need some clever way to deal with it We think it is too hard so we removed this case What do you think about this decision 
https://codeforces.com//contest/1400/problem/F,709188,F,1400F,1400,F. x-prime Substrings,You are given an integer value x and a string s consisting of digits from 1 to 9 inclusive A substring of a string is a contiguous subsequence of that string Let f l r be the sum of digits of a substring s l r Let s call substring s l 1 r 1 if f l 1 r 1 x there are no values l 2 r 2 such that l 1 le l 2 le r 2 le r 1 f l 2 r 2 neq x x is divisible by f l 2 r 2 You are allowed to erase some characters from the string If you erase a character the two resulting parts of the string are concatenated without changing their order What is the minimum number of characters you should erase from the string so that there are no substrings in it If there are no substrings in the given string s then print 0 ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << \'{\'; string sep; for (const auto &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << \'{\'; string sep; for (const auto &x : arr) os << sep << x, sep = "", ""; return os << \'}\'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n// This version of aho_corasick uses more memory and depends on a small alphabet, but it provides O(1) suffix links.\ntemplate<char MIN_CHAR = \'a\', int ALPHABET = 26>\nstruct aho_corasick {\n    struct node {\n        // suff = the index of the node of the longest strict suffix of the current node that\'s also in the tree.\n        //   Also see ""blue arcs"" on Wikipedia: https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\n        // dict = the index of the node of the longest strict suffix of the current node that\'s in the word list.\n        //   Also see ""green arcs"" on Wikipedia.\n        // depth = normal trie depth (root is 0). Can be removed to save memory.\n        // word_index = the index of the *first* word ending at this node. -1 if none.\n        // word_count = the total number of words ending at this node. Used in count_total_matches().\n        // link = the trie connections and/or suffix connections from this node.\n        int suff = -1, dict = -1, depth = 0;\n        int word_index = -1, word_count = 0;\n        int link[ALPHABET];\n\n        node() {\n            fill(link, link + ALPHABET, -1);\n        }\n\n        int& operator[](char c) {\n            return link[c - MIN_CHAR];\n        }\n    };\n\n    vector<node> nodes;\n    int W;\n    vector<int> word_location;\n    vector<int> word_indices_by_depth;\n    vector<int> defer;\n\n    aho_corasick(const vector<string> &words = {}) {\n        if (!words.empty())\n            build(words);\n    }\n\n    // Builds the adj list based on suffix parents. Often we want to perform DP and/or queries on this tree.\n    vector<vector<int>> build_suffix_adj() const {\n        vector<vector<int>> adj(nodes.size());\n\n        for (int i = 1; i < int(nodes.size()); i++)\n            adj[nodes[i].suff].push_back(i);\n\n        return adj;\n    }\n\n    int get_or_add_child(int current, char c) {\n        if (nodes[current][c] >= 0)\n            return nodes[current][c];\n\n        int index = int(nodes.size());\n        nodes[current][c] = index;\n        nodes.emplace_back();\n        nodes.back().depth = nodes[current].depth + 1;\n        return index;\n    }\n\n    int add_word(const string &word, int word_index) {\n        assert(!nodes.empty());\n        int current = 0;\n\n        for (char c : word)\n            current = get_or_add_child(current, c);\n\n        if (nodes[current].word_index < 0)\n            nodes[current].word_index = word_index;\n\n        nodes[current].word_count++;\n        return current;\n    }\n\n    // Returns where in the trie we should end up after starting at `location` and adding char `c`. Runs in O(1).\n    int get_suffix_link(int location, char c) const {\n        if (location >= 0)\n            location = nodes[location].link[c - MIN_CHAR];\n\n        return max(location, 0);\n    }\n\n    void build(const vector<string> &words) {\n        nodes = {node()};\n        W = int(words.size());\n        word_location.resize(W);\n        defer.resize(W);\n        int max_depth = 0;\n\n        for (int i = 0; i < W; i++) {\n            word_location[i] = add_word(words[i], i);\n            max_depth = max(max_depth, int(words[i].size()));\n            defer[i] = nodes[word_location[i]].word_index;\n        }\n\n        // Create a list of word indices in decreasing order of depth, in linear time via counting sort.\n        word_indices_by_depth.resize(W);\n        vector<int> depth_freq(max_depth + 1, 0);\n\n        for (int i = 0; i < W; i++)\n            depth_freq[words[i].size()]++;\n\n        for (int i = max_depth - 1; i >= 0; i--)\n            depth_freq[i] += depth_freq[i + 1];\n\n        for (int i = 0; i < W; i++)\n            word_indices_by_depth[--depth_freq[words[i].size()]] = i;\n\n        // Solve suffix parents by traversing in order of depth (BFS order).\n        vector<int> q = {0};\n\n        for (int i = 0; i < int(q.size()); i++) {\n            int current = q[i];\n\n            for (char c = MIN_CHAR; c < MIN_CHAR + ALPHABET; c++) {\n                int &index = nodes[current][c];\n\n                if (index >= 0) {\n                    // Find index\'s suffix parent by traversing suffix parents of current until one of them has a child c.\n                    int suffix_parent = get_suffix_link(nodes[current].suff, c);\n                    nodes[index].suff = suffix_parent;\n                    nodes[index].word_count += nodes[suffix_parent].word_count;\n                    nodes[index].dict = nodes[suffix_parent].word_index < 0 ? nodes[suffix_parent].dict : suffix_parent;\n                    q.push_back(index);\n                } else {\n                    index = get_suffix_link(nodes[current].suff, c);\n                }\n            }\n        }\n    }\n\n    // Counts the number of matches of each word in O(text length + num words).\n    vector<int> count_matches(const string &text) const {\n        vector<int> matches(W, 0);\n        int current = 0;\n\n        for (char c : text) {\n            current = get_suffix_link(current, c);\n            int dict_node = nodes[current].word_index < 0 ? nodes[current].dict : current;\n\n            if (dict_node >= 0)\n                matches[nodes[dict_node].word_index]++;\n        }\n\n        // Iterate in decreasing order of depth.\n        for (int word_index : word_indices_by_depth) {\n            int location = word_location[word_index];\n            int dict_node = nodes[location].dict;\n\n            if (dict_node >= 0)\n                matches[nodes[dict_node].word_index] += matches[word_index];\n        }\n\n        for (int i = 0; i < W; i++)\n            matches[i] = matches[defer[i]];\n\n        return matches;\n    }\n\n    // Counts the number of matches over all words at each ending position in `text` in O(text length).\n    vector<int> count_matches_by_position(const string &text) const {\n        vector<int> matches(text.size());\n        int current = 0;\n\n        for (int i = 0; i < int(text.size()); i++) {\n            current = get_suffix_link(current, text[i]);\n            matches[i] = nodes[current].word_count;\n        }\n\n        return matches;\n    }\n\n    // Counts the total number of matches of all words within `text` in O(text length).\n    int64_t count_total_matches(const string &text) const {\n        int64_t matches = 0;\n        int current = 0;\n\n        for (char c : text) {\n            current = get_suffix_link(current, c);\n            matches += nodes[current].word_count;\n        }\n\n        return matches;\n    }\n};\n\n\nconst int INF = 1e9 + 5;\n\nint N, X;\nstring S;\nvector<string> prime;\naho_corasick<\'1\', 9> AC;\n\nbool check(string str) {\n    int n = int(str.size());\n\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n\n        for (int j = i; j < n; j++) {\n            sum += str[j] - \'0\';\n\n            if (sum < X && X % sum == 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nvoid generate(string str, int sum) {\n    if (sum > X)\n        return;\n\n    if (sum == X) {\n        if (check(str))\n            prime.push_back(str);\n\n        return;\n    }\n\n    for (int d = 1; d <= 9 && sum + d <= X; d++)\n        generate(str + char(d + \'0\'), sum + d);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> S >> X;\n    N = int(S.size());\n    generate("""", 0);\n    dbg(prime);\n    AC.build(prime);\n    int ST = int(AC.nodes.size());\n    vector<int> dp(ST, INF);\n    dp[0] = 0;\n\n    for (auto &ch : S) {\n        vector<int> next_dp(ST, INF);\n\n        for (int state = 0; state < ST; state++)\n            if (dp[state] < INF) {\n                next_dp[state] = min(next_dp[state], dp[state] + 1);\n                int transition = AC.get_suffix_link(state, ch);\n\n                if (AC.nodes[transition].word_index < 0)\n                    next_dp[transition] = min(next_dp[transition], dp[state]);\n            }\n\n        swap(dp, next_dp);\n    }\n\n    cout << *min_element(dp.begin(), dp.end()) << \'\\n\';\n}\n']",,,"['brute force', 'dfs and similar', 'dp', 'string suffix structures', 'strings']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. x-prime Substrings.json,https://codeforces.com//blog/entry/81916,The key observation is that since is only up to 20 there can t be that many different prime strings total turns out there are only about 2400 for the worst case of So we can generate all of them and perform a DP where our state is represented by the longest prefix of any of the strings we currently match We can do this by building a trie of all of the prime strings We then need to be able to transition around in this trie it turns out this is exactly what Aho Corasick does for us In particular knowing which node of the Aho Corasick tree we are currently at gives us the full information we need to determine whether or not we will match one of the strings after adding more characters later This leads to a fairly simple DP 90977148 
https://codeforces.com//contest/1933/problem/D,2499500,D,1933D,1933,D. Turtle Tenacity  Continual Mods,Given an array a 1 a 2 ldots a n determine whether it is possible to into b 1 b 2 ldots b n such that b 1 bmod b 2 bmod ldots bmod b n neq 0 Here x bmod y denotes the remainder from dividing x by y Also the modulo operations are calculated from left to right That is x bmod y bmod z x bmod y bmod z For example 2024 bmod 1000 bmod 8 2024 bmod 1000 bmod 8 24 bmod 8 0 ,"['/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e5+10;\nint n,a[N];\nvoid leeminhduc2()\n{\n    cin >> n;\n    for (int i=1;i<=n;i++)\n    {\n        cin >> a[i];\n    }\n    int d=0;\n    for (int i=1;i<=n;i++) d+=(a[i]==1);\n    if (d>1) cout << ""NO\\n"";\n    else if (d==1) cout << ""YES\\n"";\n    else\n    {\n        int x=*min_element(a+1,a+n+1);\n        d=0;\n        for (int i=1;i<=n;i++) d+=(a[i]==x);\n        if (d==1) cout << ""YES\\n"";\n        else\n        {\n            bool ok=0;\n            for (int i=1;i<=n;i++) if (a[i]%x) ok=1;\n            if (ok) cout << ""YES\\n"";\n            else cout << ""NO\\n"";\n        }\n    }\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n']",,,"['constructive algorithms', 'greedy', 'math', 'number theory', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Turtle Tenacity  Continual Mods.json,https://codeforces.com//blog/entry/126560,Sort the array in non decreasing order Now assume If the minimum is unique Therefore place at the front and the result after all modulo operations is just Hence the answer is yes for this case If and there exists some element such that then a possible solution is rearranging the array to Since is the minimum among the other elements and the result after all modulo operations equals Hence the answer is yes for this case Otherwise if all elements are multiples of the minimum the answer is no because any element modulo the minimum equals and at least one of the minimums must not be the first element So after passing through two minimums we are guaranteed to get a 
https://codeforces.com//contest/1398/problem/G,699507,G,1398G,1398,G. Running Competition,A running competition is going to be held soon The stadium where the competition will be held can be represented by several segments on the coordinate plane two horizontal segments one connecting the points 0 0 and x 0 the other connecting the points 0 y and x y n 1 vertical segments numbered from 0 to n The i th segment connects the points a i 0 and a i y 0 a 0 a 1 a 2 dots a n 1 a n x For example here is a picture of the stadium with x 10 y 5 n 3 and a 0 3 5 10 A is a route that goes along the segments starts and finishes at the same point and never intersects itself the only two points of a lap that coincide are its starting point and ending point The length of a lap is a total distance travelled around it For example the red route in the picture representing the stadium is a lap of length 24 The competition will be held in q stages The i th stage has length l i and the organizers want to choose a lap for each stage such that the length of the lap is a The organizers don t want to choose short laps for the stages so for each stage they want to find the maximum possible length of a suitable lap Help the organizers to calculate the maximum possible lengths of the laps for the stages In other words for every l i find the maximum possible integer L such that l i bmod L 0 and there exists a lap of length L If it is impossible to choose such a lap then print 1 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=(\'0\'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntemplate<unsigned mod=998244353>struct mint {\n   unsigned val;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=val,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0)x+=mod; return x;\n   }\n   mint():val(0){}\n   mint(ll x):val(x>=0?x%mod:mod+(x%mod)){}\n   mint pow(ll t){mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n   mint& operator+=(const mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n   mint& operator-=(const mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n   mint& operator*=(const mint& x){val=ll(val)*x.val%mod; return *this;}\n   mint& operator/=(const mint& x){val=ll(val)*x.inv()%mod; return *this;}\n   mint operator+(const mint& x)const{return mint(*this)+=x;}\n   mint operator-(const mint& x)const{return mint(*this)-=x;}\n   mint operator*(const mint& x)const{return mint(*this)*=x;}\n   mint operator/(const mint& x)const{return mint(*this)/=x;}\n   bool operator==(const mint& x)const{return val==x.val;}\n   bool operator!=(const mint& x)const{return val!=x.val;}\n};\ntemplate<unsigned mod=998244353>struct factorial {\n   using Mint=mint<mod>;\n   vector<Mint> Fact, Finv;\npublic:\n   factorial(int maxx){\n      Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);\n      Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;\n   }\n   Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n   Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n   Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\nusing Mint=mint<>;\n\nvector<int> rt,irt;\ntemplate<unsigned mod=998244353>void init(int lg=21){\n   using Mint=mint<mod>; Mint prt=2;\n   while(prt.pow(mod>>1).val==1)prt+=1;\n   rt.resize(1<<lg,1); irt.resize(1<<lg,1);\n   rep(w,0,lg){\n      int mask=(1<<w)-1,t=Mint(-1).val>>w;\n      Mint g=prt.pow(t),ig=prt.pow(mod-1-t);\n      rep(i,0,mask){\n         rt[mask+i+1]=(g*rt[mask+i]).val;\n         irt[mask+i+1]=(ig*irt[mask+i]).val;\n      }\n   }\n}\n\ntemplate<unsigned mod=998244353>struct FPS{\n   using Mint=mint<mod>; vector<Mint> f;\n   FPS():f({1}){}\n   FPS(int _n):f(_n){}\n   FPS(vector<Mint> _f):f(_f){}\n   Mint& operator[](const int i){return f[i];}\n   Mint eval(Mint x){\n      Mint res,w=1;\n      for(Mint v:f)res+=w*v,w*=x; return res;\n   }\n   FPS inv()const{\n      assert(f[0]!=0); int n=f.size();\n      FPS res(n); res.f[0]=f[0].inv();\n      for(int k=1;k<n;k<<=1){\n         FPS g(k*2),h(k*2);\n         rep(i,0,min(k*2,n))g[i]=f[i]; rep(i,0,k)h[i]=res[i];\n         g.ntt(); h.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,0,k)g[i]=0,g[i+k]*=-1;\n         g.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,k,min(k*2,n))res[i]=g[i];\n      } return res;\n   }\n   void ntt(bool inv=0){\n        int n=f.size(); if(n==1)return;\n        if(inv){\n            for(int i=1;i<n;i<<=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        f[i+j+k]*=irt[i*2-1+k];\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp;\n                    }\n                }\n            }\n            Mint mul=Mint(n).inv(); rep(i,0,n)f[i]*=mul;\n        }else{\n            for(int i=n>>1;i;i>>=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp*rt[i*2-1+k];\n                    }\n                }\n            }\n        }\n   }\n   FPS operator+(const FPS& g)const{return FPS(*this)+=g;}\n   FPS operator-(const FPS& g)const{return FPS(*this)-=g;}\n   FPS operator*(const FPS& g)const{return FPS(*this)*=g;}\n   template<class T>FPS operator*(T t)const{return FPS(*this)*=t;}\n   FPS operator/(const FPS& g)const{return FPS(*this)/=g;}\n   template<class T>FPS operator/(T t)const{return FPS(*this)/=t;}\n   FPS operator%(const FPS& g)const{return FPS(*this)%=g;}\n   FPS& operator+=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]+=g[i]; return *this;\n   }\n   FPS& operator-=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]-=g[i]; return *this;\n   }\n   FPS& operator*=(FPS g){\n      int m=f.size()+g.f.size()-1,n=1; while(n<m)n<<=1;\n      f.resize(n); g.f.resize(n);\n      ntt(); g.ntt(); rep(i,0,n)f[i]*=g[i]; \n      ntt(1); f.resize(m); return *this;\n   }\n   template<class T>FPS& operator*=(T t){for(Mint x:f)x*=t; return *this;}\n   FPS& operator/=(FPS g){\n      if(g.f.size()>f.size())return *this=FPS({0});\n      reverse(ALL(f)); reverse(ALL(g.f));\n      int n=f.size()-g.f.size()+1;\n      f.resize(n); g.f.resize(n); FPS mul=g.inv();\n      *this*=mul; f.resize(n); reverse(ALL(f)); return *this;\n   }\n   template<class T>FPS& operator/=(T t){for(Mint x:f)x/=t; return *this;}\n   FPS& operator%=(FPS g){\n      *this-=*this/g*g;\n      while(!f.empty()&&f.back()==0)f.pop_back();\n      return *this;\n   }\n   FPS sqrt(){\n      int n=f.size(); FPS res(1); res[0]=1;\n      for(int k=1;k<n;k<<=1){\n         FPS ff=*this; res.f.resize(k*2);\n         res+=ff/res; res/=2;\n      } res.f.resize(n); return res;\n   }\n   FPS diff(){\n      FPS res=*this; rep(i,0,res.f.size()-1)res[i]=res[i+1]*(i+1);\n      res.f.pop_back(); return res;\n   }\n   FPS inte(){\n      FPS res=*this; res.f.push_back(0);\n      rrep(i,res.f.size()-1,0)res[i]=res[i-1]/i;\n      res[0]=0; return res;\n   }\n   FPS log(){\n      assert(f[0]==1); FPS res=diff()*inv(); \n      res.f.resize(f.size()-1); res=res.inte(); return res;\n   }\n   FPS exp(){\n      assert(f[0]==0); int m=f.size(),n=1; while(n<m)n<<=1;\n      f.resize(n); FPS d=diff(),res(n); vector<FPS> pre;\n      for(int k=n;k;k>>=1){\n         FPS g=d; g.f.resize(k);\n         g.ntt(); pre.push_back(g);\n      }\n      auto dfs=[&](auto dfs,int l,int r,int dep)->void{\n         if(r-l==1){if(l>0)res[l]/=l; return;}\n         int m=(l+r)>>1; dfs(dfs,l,m,dep+1);\n         FPS g(r-l); rep(i,0,m-l)g[i]=res[l+i];\n         g.ntt(); rep(i,0,r-l)g[i]*=pre[dep][i]; g.ntt(1);\n         rep(i,m,r)res[i]+=g[i-l-1]; dfs(dfs,m,r,dep+1);\n      }; res[0]=1; dfs(dfs,0,n,0); res.f.resize(m); return res;\n   }\n};//need to initialize\n\nint n,t; int a[1010000];\nint cnt[501000]={};\nfactorial<> fact(501000);\nMint inv[501000];\n\nFPS<> substituteXplus(FPS<> A, Mint w) {\n   int n = (int)A.f.size();\n   for (int i = 0; i < n; i++)\n      A[i] *= fact.fact(i, 0);\n   vector<Mint> B(n);\n   Mint pw = 1;\n   for (int i = 0; i < n; i++) {\n      B[i] = pw * fact.fact(i, 1);\n      pw *= w;\n   }\n   reverse(all(B));\n   FPS<> C = A * FPS<>(B);\n   B = C.f;\n   rotate(B.begin(), B.begin() + n - 1, B.end());\n   B.resize(n);\n   for (int i = 0; i < n; i++)\n      B[i] *= fact.fact(i, 1);\n   return FPS<>(B);\n}\n/*\n   CALL INIT !!!\n*/\n\nconst int N = 500500;\nbool good[N];\nint ans[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tinit();\n\n\tint n, x, y;\n\tscanf(""%d%d%d"", &n, &x, &y);\n\tvector<Mint> a(x + 1);\n\tn++;\n\tfor (int i = 0; i <= x; i++)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint z;\n\t\tscanf(""%d"", &z);\n\t\ta[z] = 1;\n\t}\n\tvector<Mint> b = a;\n\treverse(all(b));\n\tFPS<> c = FPS<>(a) * FPS<>(b);\n\n\tfor (int i = 1; i <= x; i++)\n\t\tif (c[x + i].val != 0)\n\t\t\tgood[y + i] = 1;\n\n\tfor (int i = 0; i < N; i++)\n\t\tans[i] = -1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (!good[i]) continue;\n\t\tfor (int j = i; j < N; j += i)\n\t\t\tans[j] = 2 * i;\n\t}\n\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint z;\n\t\tscanf(""%d"", &z);\n\t\tz /= 2;\n\t\tprintf(""%d "", ans[z]);\n\t}\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']",,,"['bitmasks', 'fft', 'math', 'number theory']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Running Competition.json,https://codeforces.com//blog/entry/81506,First of all let s find all possible lengths of the laps after doing that we can just check every divisor of to find the maximum possible length of a lap for a given query A lap is always a rectangle you can t construct a lap without using any vertical segments or using an odd number of vertical segments and if you try to use or more vertical segments you can t go back to the point where you started because both horizontal segments are already partially visited So a lap is a rectangle bounded by two vertical segments and if we use vertical segments and the perimeter of this rectangle is Let s find all values that can be represented as A naive approach will be too slow we have to speed it up somehow Let s build an array of numbers where is some integer greater than Each number that can be represented as can also be represented as so we have to find all possible sums of two elements belonging to different arrays The key observation here is that if and are small we can treat each array as a polynomial let and similarly Let s look at the product of that polynomials The coefficient for is non zero if and only if there exist and such that so finding all possible sums and all possible differences can be reduced to multiplying two polynomials which can be done faster than using Karatsuba s algorithm or FFT 
https://codeforces.com//contest/713/problem/C,71347,C,713C,713,C. Sonya and Problem Wihtout a Legend,Sonya was unable to think of a story for this problem so here comes the formal description You are given the array containing positive integers At one turn you can pick any element and increase or decrease it by The goal is the make the array strictly increasing by making the minimum possible number of operations You are allowed to change elements in any way they can become negative or equal to ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nlong long ans;\nmultiset < int > S;\n\nint main ()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nscanf (""%d"", &N);\nfor (int i=1; i<=N; i++)\n{\n    int ai;\n    scanf (""%d"", &ai), ai -= i;\n//    printf (""%d%c"", ai, "" \\n""[i==N]);\n    if (S.empty () || (*S.rbegin ()) <= ai) S.insert (ai);\n    else\n    {\n        auto it = S.end (); it --;\n        ans += (*it) - ai, S.erase (it), S.insert (ai), S.insert (ai);\n    }\n}\nprintf (""%I64d\\n"", ans);\n\nreturn 0;\n}\n']",,,"['dp', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Sonya and Problem Wihtout a Legend.json,https://codeforces.com//blog/entry/47094,Lets first solve easier problem Given an array of number what it is minimal amount of operations to element to element to make all numbers in array equal We need to solve this problem for each prefix Optimal solution would be making all numbers equal to median value of the prefix middle element in sorted list For this problem we can simply use two heaps and insert element in right one removing elements from inserted if need to keep heaps equal and fit the constraint max value Heap1 min value Heap2 Now lets solve harder problem What is minimal amount of operations to element to element to make array be arithmetics progression with step We can just reduce number in array by value and will receive previous problem Finally we have original problem answer for prefix ending in i e number of operations to make prefix of first elements in increasing order Also for each will remember minimal last number in resulting sequence For each will bruteforce value and calculate answer for if if arithmetics progression with step Also we need to assume if median value in is lower than minimal value at i than we cannot update answer for by answer for 
https://codeforces.com//contest/2060/problem/F,3147475,F,2060F,2060,F. Multiplicative Arrays,You re given integers k and n For each integer x from 1 to k count the number of integer arrays a such that all of the following are satisfied 1 leq a leq n where a represents the length of a 1 leq a i leq k for all 1 leq i leq a a 1 times a 2 times dots times a a x i e the product of all elements is x Note that two arrays b and c are different if either their lengths are different or if there exists an index 1 leq i leq b such that b i neq c i Output the answer modulo 998 244 353 ,"[""#include <bits/stdc++.h>using namespace std;\xa0static const int MOD = 998244353;static const int MAXK = 100000;\xa0inline long long modAdd(long long a, long long b) {\tlong long r = a + b;\tif (r >= MOD) r -= MOD;\treturn r;}inline long long modSub(long long a, long long b) {\tlong long r = a - b;\tif (r < 0) r += MOD;\treturn r;}inline long long modMul(long long a, long long b) {\treturn (a % MOD) * (b % MOD) % MOD;}long long modExp(long long base, long long exp) {\tlong long result = 1 % MOD;\tbase %= MOD;\twhile (exp > 0) {\t\tif (exp & 1) result = (result * base) % MOD;\t\tbase = (base * base) % MOD;\t\texp >>= 1;\t}\treturn result;}inline long long modInv(long long x) {\treturn modExp(x, MOD-2);}\xa0static int spf[MAXK+1];  void build_spf() {\tfor (int i = 2; i <= MAXK; i++) {\t\tif (!spf[i]) { \t\t\t// i is prime\t\t\tfor (long long j = (long long)i; j <= MAXK; j += i) {\t\t\t\tif (!spf[j]) spf[j] = i;\t\t\t}\t\t}\t}}\xa0vector<pair<int,int>> factor_small(int x) {\tvector<pair<int,int>> f;\twhile (x > 1) {\t\tint p = spf[x];\t\tint cnt = 0;\t\twhile (spf[x] == p) {\t\t\tx /= p;\t\t\tcnt++;\t\t}\t\tf.push_back({p,cnt});\t}\treturn f;}\xa0typedef long long ll;typedef vector<ll> Poly;Poly polyMul(const Poly &A, const Poly &B) {\tPoly C(A.size()+B.size()-1, 0LL);\tfor (size_t i=0; i<A.size(); i++){\t\tfor (size_t j=0; j<B.size(); j++){\t\t\tC[i+j] = modAdd(C[i+j], modMul(A[i], B[j]));\t\t}\t}\treturn C;}\xa0// P(m) = ( (m + 0)*(m + 1)*...*(m + a-1) ) / a!Poly bino(int a) {\tif (a == 0) {\t\treturn Poly(1, 1LL);\t}\tPoly res(1, 1LL); // constant 1\tfor(int j=0; j<a; j++){\t\tPoly tmp(res.size()+1, 0LL);\t\tfor (size_t i=0; i<res.size(); i++){\t\t\tll coeff = res[i];\t\t\t// (m + j) => \t\t\t//    newPoly[i+1] += coeff (coefficient for m^(i+1))\t\t\t//    newPoly[i]   += j*coeff\t\t\ttmp[i+1] = modAdd(tmp[i+1], coeff);\t\t\ttmp[i]   = modAdd(tmp[i], modMul(coeff, j));\t\t}\t\tres.swap(tmp);\t}\xa0\t// divide by a! mod\tstatic bool factInit = false;\tstatic ll fact[40], invfact[40];\tif (!factInit) {\t\tfactInit = true;\t\tfact[0]=1; for(int i=1;i<40;i++) fact[i]=modMul(fact[i-1], i);\t\tinvfact[39] = modInv(fact[39]);\t\tfor(int i=38;i>=0;i--){\t\t\tinvfact[i] = modMul(invfact[i+1], i+1);\t\t}\t}\tll invA = invfact[a]; // 1/(a!) mod\tfor (auto &c : res) {\t\tc = modMul(c, invA);\t}\treturn res;}static const int MAXP = 16; \xa0static vector<ll> sumPoly[MAXP+1];long long evalPoly(const Poly &poly, long long x) {\tlong long ans = 0;\tfor (int i=(int)poly.size()-1; i>=0; i--){\t\tans = modMul(ans, x);\t\tans = modAdd(ans, poly[i]);\t}\treturn ans;}long long sumpow(long long n, int p) {\tif (n < 0) return 0; // safety\treturn evalPoly(sumPoly[p], n);}void bsp() {\tfor(int p=0; p<=MAXP; p++){\t\tvector<long long> X(p+2), Y(p+2);\t\tX[0] = 0; Y[0] = 0;\t\tfor(int i=1; i<=p+1; i++){\t\t\tX[i] = i;\t\t\t// i^p mod\t\t\tlong long ipow = 1;\t\t\tfor(int r=0;r<p;r++){\t\t\t\tipow = modMul(ipow, i);\t\t\t}\t\t\tY[i] = modAdd(Y[i-1], ipow); \t\t}\t\tint L = p+2; // number of points\t\tvector<vector<long long>> F(L, vector<long long>(L,0LL));\t\tfor(int i=0;i<L;i++){\t\t\tF[i][0] = Y[i] % MOD;\t\t}\t\tfor(int j=1;j<L;j++){\t\t\tfor(int i=0; i<L-j;i++){\t\t\t\tlong long num = modSub(F[i+1][j-1], F[i][j-1]);\t\t\t\tlong long den = modSub(X[i+j], X[i]); // X[i+j] - X[i]\t\t\t\tlong long invDen = modInv((den+MOD)%MOD);\t\t\t\tF[i][j] = modMul(num, invDen);\t\t\t}\t\t}\t\tPoly res(1, 0LL);\t\tPoly curTerm(1, 1LL);\t\tfor(int j=0;j<L;j++){\t\t\tlong long coeff = F[0][j];\t\t\tPoly polyTerm(curTerm.size());\t\t\tfor(size_t u=0; u<curTerm.size(); u++){\t\t\t\tpolyTerm[u] = modMul(curTerm[u], coeff);\t\t\t}\t\t\tif (polyTerm.size() > res.size())\t\t\t\tres.resize(polyTerm.size(), 0);\t\t\tfor(size_t u=0; u<polyTerm.size(); u++){\t\t\t\tres[u] = modAdd(res[u], polyTerm[u]);\t\t\t}\t\t\tif (j+1 < L) {\t\t\t\tPoly newCur(curTerm.size()+1, 0LL);\t\t\t\tfor(size_t i=0; i<curTerm.size(); i++){\t\t\t\t\tnewCur[i+1] = modAdd(newCur[i+1], curTerm[i]);\t\t\t\t\tlong long tmp = modMul(curTerm[i], (MOD - (X[j] % MOD)));\t\t\t\t\tnewCur[i] = modAdd(newCur[i], tmp);\t\t\t\t}\t\t\t\tcurTerm.swap(newCur);\t\t\t}\t\t}\t\tsumPoly[p] = res;  // store\t}}\xa0int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr);\xa0\tbuild_spf();\tbsp();\tint t;\tcin >> t;\twhile(t--){\t\tlong long n;\t\tint k;\t\tcin >> k >> n;\xa0\t\tvector<long long> ans(k+1, 0);\xa0\t\tfor(int x=1; x<=k; x++){\t\t\tauto factx = factor_small(x);\t\t\tPoly polyRes(1, 1LL);\t\t\tfor (auto &pe : factx) {\t\t\t\tint expnt = pe.second;\t\t\t\tPoly pf = bino(expnt); \t\t\t\tpolyRes = polyMul(polyRes, pf);\t\t\t}\t\t\tlong long total = 0;\t\t\tfor (int i=0; i<(int)polyRes.size(); i++){\t\t\t\tif (polyRes[i] != 0) {\t\t\t\t\tlong long c = polyRes[i];\t\t\t\t\tlong long sp = sumpow(n, i);\t\t\t\t\ttotal = modAdd(total, modMul(c, sp));\t\t\t\t}\t\t\t}\t\t\tans[x] = total;\t\t}\t\tfor(int x=1; x<=k; x++){\t\t\tcout << ans[x];\t\t\tif (x<k) cout << ' ';\t\t}\t\tcout << '\\n';\t}\treturn 0;}""]",,,"['combinatorics', 'dp', 'number theory']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Multiplicative Arrays.json,https://codeforces.com/blog/entry/138342,The naive solution is to define fk n as the number of arrays containing n elements with a product of k We could then try to compute this by considering the last element of the array among the divisors of k giving us fk n j kfj n 1 with fk 1 1 The answers would then be ni 1f1 i ni 1f2 i ni 1fk i However this leads to an O nklogk solution which exceeds our time constraints We need to optimize this approach We can prove that there are at most 16 non 1 elements in our arrays This is because The prime factorization of k p1p2 pt divides k into the most non 1 elements With 17 non 1 elements the smallest possible value would be k 217 131072 105 Based on this observation we can define our dynamic programming state as Let dp i j represent the number of arrays with product i containing only j non 1 elements The recurrence relation becomes dp i j p i p 1dp ip j 1 Base case dp i 1 1 for i 1 This computation has a time complexity of O klog2k as we perform kj 1d j O klogk additions for each i To calculate fk n we Enumerate the number of non 1 elements from 1 to 16 For j non 1 elements in the array We have n j elements that are 1 We need to choose j positions for non 1 elements Fill these positions with dp k j possible sequences This gives us fk n 16j 1 nj dp k j Therefore i 1nfk n i 1n j 116 ij dp k j j 116 dp k j i 1n ij j 116 n 1j 1 dp k j Note that ni 1 ij n 1j 1 is given by the Hockey Stick Identity Each answer can be calculated in O log2k time giving an overall time complexity of O klog2k 
https://codeforces.com//contest/1190/problem/D,371226,D,1190D,1190,D. Tokitsukaze and Strange Rectangle,There are n points on the plane the i th of which is at x i y i Tokitsukaze wants to draw a strange rectangular area and pick all the points in the area The strange area is enclosed by three lines x l y a and x r as its left side its bottom side and its right side respectively where l r and a can be any real numbers satisfying that l r The upper side of the area is boundless which you can regard as a line parallel to the x axis at infinity The following figure shows a strange rectangular area A point x i y i is in the strange rectangular area if and only if l x i r and y i a For example in the above figure p 1 is in the area while p 2 is not Tokitsukaze wants to know how many different non empty sets she can obtain by picking all the points in a strange rectangular area where we think two sets are different if there exists at least one point in one set of them but not in the other ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\npii a[N];\nint xs[N];\nint xsSz;\nint n;\nint fenv[N];\nbool used[N];\n\nvoid addFenv(int p, int x) {\n\tfor(; p < N; p |= p + 1)\n\t\tfenv[p] += x;\n}\nint getFenv(int r) {\n\tint res = 0;\n\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\tres += fenv[r];\n\treturn res;\n}\nint getSum(int l, int r) {\n\treturn getFenv(r - 1) - getFenv(l - 1);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d%d"", &a[i].second, &a[i].first);\n\tsort(a, a + n);\n\tn = unique(a, a + n) - a;\n\tfor (int i = 0; i < n; i++) {\n\t\txs[xsSz++] = a[i].second;\n\t}\n\tsort(xs, xs + xsSz);\n\txsSz = unique(xs, xs + xsSz) - xs;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i].second = lower_bound(xs, xs + xsSz, a[i].second) - xs;\n\tll ans = 0;\n\tint l = 0;\n\treverse(a, a + n);\n\tll m = 0;\n\twhile(l < n) {\n\t\tint r = l;\n\t\twhile(r < n && a[l].first == a[r].first) r++;\n\t\tvector<int> z;\n\t\tfor (int i = l; i < r; i++)\n\t\t\tz.push_back(a[i].second);\n\t\tz.push_back(-1);\n\t\tz.push_back(xsSz);\n\t\tsort(z.begin(), z.end());\n\t\tz.resize(unique(z.begin(), z.end()) - z.begin());\n\t\tfor (int i = 0; i < (int)z.size() - 1; i++) {\n\t\t\tint L = z[i] + 1, R = z[i + 1];\n\t\t\tll w = getSum(L, R);\n\t\t\tans -= w * (w + 1) / 2;\n\t\t}\n\t\twhile(l < r) {\n\t\t\tif (!used[a[l].second]) {\n\t\t\t\tm++;\n\t\t\t\tused[a[l].second] = 1;\n\t\t\t\taddFenv(a[l].second, 1);\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tans += m * (m + 1) / 2;\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']",,,"['data structures', 'divide and conquer', 'sortings', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Tokitsukaze and Strange Rectangle.json,https://codeforces.com/blog/entry/68314,Tutorial For each strange rectangular area and its corresponding set of points we only need to focus on the lowest coordinate the leftmost coordinate and the rightmost coordinate of points in this set Different sets must have different so we can count them by enumerating these values Let s enumerate first Then we need to list all the possible coordinates of points satisfying that and mark every possible satisfying there is a point By doing so we can make sure when enumerating and the requirement for is met as well However enumerating forcibly which is in time complexity is too slow to pass so let s optimize the enumeration step by step Let s pick and sort the points from left to right Assuming that and Unable to parse markup type CF MATHJAX is the leftmost point of them that is in the chosen set we can count the number of aforementioned different coordinates in ranges and and then count the number of possible pairs immediately More specifically let be the number of different coordinates of points in the area and we know the number of possible pairs is After precalculating for each we can reduce the time complexity into The very last step is using the trick of sweeping lines We can enumerate from highest to lowest and during that process use data structures to maintain possible coordinates What we need to implement is to maintain a container check if a coordinate is already in the container add a coordinate to the container and query the number of coordinates in a range These requirements can be easily achieved by Fenwick tree segment tree or others With the last optimization we can solve in time complexity By the way there also exist solutions using other approaches such as divide and conquer 
https://codeforces.com//contest/1498/problem/F,939727,F,1498F,1498,F. Christmas Game,Alice and Bob are going to celebrate Christmas by playing a game with a tree of presents The tree has n nodes numbered 1 to n with some node r as its root There are a i presents are hanging from the i th node Before beginning the game a special integer k is chosen The game proceeds as follows Alice begins the game with moves alternating each turn in any move the current player may choose some node for example i which has depth at least k Then the player picks some positive number of presents hanging from that node let s call it m 1 le m le a i the player then places these m presents on the k th ancestor let s call it j of the i th node the k th ancestor of vertex i is a vertex j such that i is a descendant of j and the difference between the depth of j and the depth of i is exactly k Now the number of presents of the i th node a i is decreased by m and correspondingly a j is increased by m Alice and Bob both play optimally The player unable to make a move loses the game of the tree find who among Alice or Bob wins the game Note The depth of a node i in a tree with root r is defined as the number of edges on the simple path from node r to node i The depth of root r itself is zero ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002],k,f[100002][42],g[100002][42];\ninline void add(re int x,re int y){e[++cnt]=(edge){y,head[x]},head[x]=cnt;}\ninline void dfs(re int x,re int y,re int d){\n\tif((d/k)&1)ans^=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to^y)dfs(e[i].to,x,d+1);\n}\ninline void dfs1(re int x,re int y){\n\tf[x][0]=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to^y){\n\t\t\tdfs1(e[i].to,x);\n\t\t\tfor(re int j=0;j<k*2;++j)f[x][j+1]^=f[e[i].to][j];\n\t\t\tf[x][0]^=f[x][k*2],f[x][k*2]=0;\n\t\t}\n}\ninline void dfs2(re int x,re int y){\n\tif(y){\n\tfor(re int j=0;j<k*2;++j)g[x][j+1]^=g[y][j];\n\tg[x][0]^=g[x][k*2],g[x][k*2]=0;\n\tg[x][1]^=a[y];\n\tfor(re int j=0;j<k*2;++j)f[y][j+1]^=f[x][j];\n\tf[y][0]^=f[y][k*2],f[y][k*2]=0;\n\tfor(re int j=0;j<k*2;++j)g[x][j+1]^=f[y][j];\n\tg[x][0]^=g[x][k*2],g[x][k*2]=0;\n\tfor(re int j=0;j<k*2;++j)f[y][j+1]^=f[x][j];\n\tf[y][0]^=f[y][k*2],f[y][k*2]=0;\n\t}\n\tg[x][0]^=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)if(e[i].to^y)dfs2(e[i].to,x);\n}\nsigned main(){\n\tn=read(),k=read();\n\tfor(re int i=1,x,y;i<n;++i)x=read(),y=read(),add(x,y),add(y,x);\n\tfor(re int i=1;i<=n;++i)a[i]=read();\n\tdfs1(1,1),dfs2(1,0);\n\tfor(re int i=1;i<=n;++i){\n\t\tans=0;\n\t\tfor(re int j=k;j<k*2;++j)ans^=f[i][j]^g[i][j];\n\t\tif(ans)printf(""1 "");\n\t\telse printf(""0 ""); \n\t}\n}\n']",,,"['bitmasks', 'data structures', 'dfs and similar', 'dp', 'games', 'math', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Christmas Game.json,https://codeforces.com//blog/entry/89137,How do we solve a standard Nim game on arrays By the Sprague Grundy theorem we know that the current player has a winning strategy if xorsum of sizes of the existing piles is non zero For a proof read details on CP algorithms 
https://codeforces.com//contest/1196/problem/A,377790,A,1196A,1196,A. Three Piles of Candies,Alice and Bob have received three big piles of candies as a gift Now they want to divide these candies as fair as possible To do this Alice takes one pile of candies then Bob takes one of the other two piles The last pile is split between Alice and Bob as they want for example it is possible that Alice takes the whole pile and Bob gets nothing from it After taking the candies from the piles if Alice has more candies than Bob she discards some candies so that the number of candies she has is equal to the number of candies Bob has Of course Bob does the same if he has more candies Alice and Bob want to have as many candies as possible and they plan the process of dividing candies accordingly Please calculate the maximum number of candies Alice can have after this division process of course Bob will have the same number of candies You have to answer q independent queries Let s see the following example 1 3 4 Then Alice can choose the third pile Bob can take the second pile and then the only candy from the first pile goes to Bob then Alice has 4 candies and Bob has 4 candies Another example is 1 10 100 Then Alice can choose the second pile Bob can choose the first pile and candies from the third pile can be divided in such a way that Bob takes 54 candies and Alice takes 46 candies Now Bob has 55 candies and Alice has 56 candies so she has to discard one candy and after that she has 55 candies too ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int q;\n    scanf(""%d"", &q);\n    while (q--) {\n        long long a, b, c;\n        scanf(""%lld%lld%lld"", &a, &b, &c);\n        printf(""%lld\\n"", 1LL * (a + b + c) / 2);\n    }\n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Three Piles of Candies.json,https://codeforces.com//blog/entry/68655,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd 
https://codeforces.com//contest/999/problem/D,192343,D,999D,999,D. Equalize the Remainders,You are given an array consisting of n integers a 1 a 2 dots a n and a positive integer m It is guaranteed that m is a divisor of n In a single move you can choose any position i between 1 and n and increase a i by 1 Let s calculate c r 0 le r le m 1 the number of elements having remainder r when divided by m In other words for each remainder let s find the number of corresponding elements in a with that remainder Your task is to change the array in such a way that c 0 c 1 dots c m 1 frac n m Find the minimum number of moves to satisfy the above requirement ,"['#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl \'\\n\'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, m;\nint a[MAXN];\nvector<int> kok[MAXN];\n\nbool read() {\n    if (!(cin >> n >> m))\n        return false;\n\n    forn (i, n)\n        cin >> a[i];\n\n    return true;\n}\n\nvoid solve() {\n    forn (i, n)\n        kok[a[i] % m].push_back(i);\n\n    set< pair<int, int> > cock;\n    ll ans = 0;\n\n    forn (i, 2 * m)\n        if (sz(kok[i % m]) < n / m) {\n            for (; !cock.empty() && sz(kok[i % m]) < n / m; cock.erase(cock.begin())) {\n                auto j = cock.begin()->second;\n                auto t = (m + i % m - cock.begin()->first) % m;\n                ans += t;\n                a[j] += t;\n                kok[i % m].push_back(j);\n            }\n        } else if (sz(kok[i % m]) > n / m) {\n            for (; sz(kok[i % m]) > n / m; kok[i % m].pop_back())\n                cock.insert(make_pair(i % m, kok[i % m].back()));\n        }\n\n    cout << ans << endl;\n\n    forn (i, n)\n        cout << a[i] << \' \';\n\n    cout << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand(\'S\' + \'E\' + \'R\' + \'E\' + \'Z\' + \'H\' + \'K\' + \'A\');\n\n#ifdef SEREZHKA\n    freopen(""file.in"", ""r"", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n']",,,"['data structures', 'greedy', 'implementation']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Equalize the Remainders.json,https://codeforces.com/blog/entry/60138,For each from to find all elements of the array that are congruent to modulo and store their indices in a list Also create a vector called and let be We have to cycle from to twice For each from to if there are in list too many i e elements congruent to modulo remove the extra elements from this list and add them to If instead there are too few i e elements congruent to modulo remove the last few elements from the vector For every removed index increase by After doing so after two passes we print the total increase and the updated array It is obvious that after the first iterations every list will have size at most and after more iterations all lists will have the same sizes It can be easily proved that this algorithm produces an optimal answer The time complexity is 
https://codeforces.com//contest/1687/problem/D,1419368,D,1687D,1687,D. Cute number,Ran is especially skilled in computation and mathematics It is said that she can do unimaginable calculation work in an instant Ran Yakumo is a cute girl who loves creating cute Maths problems Let f x be the minimal square number greater than x and g x be the maximal square number less than or equal to x For example f 1 f 2 g 4 g 8 4 A positive integer x is if x g x f x x For example 1 5 11 are cute integers while 3 8 15 are not Ran gives you an array a of length n She wants you to find the smallest non negative integer k such that a i k is a cute number for any element of a ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint a[N];\nint n;\nint jmp[N];\n\nint myJump(int v, int x) {\n\tif (jmp[v] != v) return jmp[v] = myJump(jmp[v], x);\n\tif (v == n - 1 || a[v + 1] - a[v] > x) return v;\n\treturn jmp[v] = myJump(v + 1, x);\n}\n\nll mySqrt(ll x) {\n\tll y = (ll)sqrt(x);\n\twhile(y * y < x) y++;\n\twhile(y * y > x) y--;\n\treturn y;\n}\nvoid solve(ll x, ll y, ll &L, ll &R) {\n\tll z = x + L;\n\tll k = mySqrt(z);\n\tif (k * k + k < z) k++;\n\tL = max(L, k * k - x);\n\tR = min(R, k * k + k - y);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tjmp[i] = i;\n\t}\n\tfor (ll k = 1;; k++) {\n\t\tll L = k * k - a[0], R = k * k + k - a[0];\n\t\tif (R < 0) continue;\n\t\tif (L < 0) L = 0;\n\t\tint v = 0;\n\t\twhile(L <= R && v < n) {\n\t\t\tint u = myJump(v, k);\n\t\t\tsolve(a[v], a[u], L, R);\n\t\t\tv = u + 1;\n\t\t}\n\t\tif (L <= R) {\n\t\t\tprintf(""%lld\\n"", L);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n']",,,"['binary search', 'brute force', 'data structures', 'dsu', 'implementation', 'math']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Cute number.json,https://codeforces.com//blog/entry/103493,Solution For any integer iff we can find satisfying we have which means is beautiful Define It is easy to find that and there are only useful because Enumerate and calculate the range of in order It can be shown that the range is an interval for all So we can solve this problem in We call a jump if Assuming there is no more than jumps We only need to enumerate jumps to calculate the ranges We can use linked list or set in C to maintain it The time complexity is 
https://codeforces.com//contest/1362/problem/A,640962,A,1362A,1362,A. Johnny and Ancient Computer,Johnny has recently found an ancient broken computer The machine has only one register which allows one to put in there one variable Then in one operation you can shift its bits left or right by at most three positions The right shift is forbidden if it So in fact in one operation you can multiply or divide your number by 2 4 or 8 and division is only allowed if the number is divisible by the chosen divisor Formally if the register contains a positive integer x in one operation it can be replaced by one of the following x cdot 2 x cdot 4 x cdot 8 x 2 if x is divisible by 2 x 4 if x is divisible by 4 x 8 if x is divisible by 8 For example if x 6 in one operation it can be replaced by 12 24 48 or 3 Value 6 isn t divisible by 4 or 8 so there re only four variants of replacement Now Johnny wonders how many operations he needs to perform if he puts a in the register and wants to get b at the end ,"[""#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint t; cin >> t;\n\n\twhile (t--) {\n\t\tll a, b; cin >> a >> b;\n\t\tint op = 0;\n\t\tif (a > b) {\n\t\t\twhile (a > b) { \n\t\t\t\tif (a % 8 == 0 && a / 8 >= b) { a /= 8; op++; }\n\t\t\t\telse if (a % 4 == 0 && a / 4 >= b) { a /= 4; op++; }\n\t\t\t\telse if (a % 2 == 0 && a / 2 >= b) { a /= 2; op++; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (a < b) {\n\t\t\t\tif (a * 8 <= b) { a *= 8; op++; }\n\t\t\t\telse if (a * 4 <= b) { a *= 4; op++; }\n\t\t\t\telse if (a * 2 <= b) { a *= 2; op++; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t}\n\n\t\tcout << (a == b ? op : -1) << '\\n';\n\t}\n}""]",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Johnny and Ancient Computer.json,https://codeforces.com//blog/entry/78355,Let us write as and as where and are odd The only operation we have changes by so must be equal to otherwise the answer is It is easy to notice that we can greedily move toward so the answer is equal to 
https://codeforces.com//contest/835/problem/E,116350,E,835E,835,E. The penguin s game,Penguin Xoriy came up with a new game recently He has icicles numbered from to Each icicle has a temperature an integer from to of these icicles are special their temperature is while a temperature of all the others is You have to find those special icicles You can choose a subset of icicles and ask the penguin what is the bitwise exclusive OR of the temperatures of the icicles in this subset Note that you can t ask more than questions You are to find the special icicles ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint a[1010];\nint cnt;\nint n,x,y;\nint ask()\n{\n\tint i;\n\tprintf(""? %d "",cnt);\n\tfor(i=1;i<=cnt;i++)\n\t\tprintf(""%d "",a[i]);\n\tprintf(""\\n"");\n\tfflush(stdout);\n\tint s;\n\tscanf(""%d"",&s);\n\treturn s;\n}\nint main()\n{\n\tscanf(""%d%d%d"",&n,&x,&y);\n\tint m=0;\n\tint s,p;\n\tint i,j;\n\tint num;\n\tint ans1=0,ans2=0;\n\tfor(i=1;i<=15;i++)\n\t\tif(n&(1<<(i-1)))\n\t\t\tm=i;\n\tfor(i=m;i>=1;i--)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(i-1)))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t{\n\t\t\t\tp=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tans2|=1<<(p-1);\n\tfor(i=p-1;i>=1;i--)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(i-1))&&j&(1<<(p-1)))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t\tans2|=1<<(i-1);\n\t\t}\n\t}\n\tfor(i=p-1;i>=1;i--)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(i-1))&&!(j&(1<<(p-1))))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t\tans1|=1<<(i-1);\n\t\t}\n\t}\n\tfor(i=p+1;i<=m;i++)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(p-1))&&j&(1<<(i-1)))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t{\n\t\t\t\tans1|=1<<(i-1);\n\t\t\t\tans2|=1<<(i-1);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans1>ans2)\n\t\tswap(ans1,ans2);\n\tprintf(""! %d %d\\n"",ans1,ans2); \n\treturn 0;\n}']",,,"['binary search', 'constructive algorithms', 'interactive']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The penguin s game.json,https://codeforces.com//blog/entry/53588,The solution can be separated into several parts Consider the following cases Subset s size is even the number of special icicles in it is even Then the answer to such question is Subset s size is even the number of special icicles in it is odd Then the answer to such question is Subset s size is odd the number of special icicles in it is even Then the answer to such question is Subset s size is odd the number of special icicles in it is odd Then the answer to such question is and so the numbers are pairwise distinct Therefore we can find the parity of the number of special icicles on the given subset using 1 question Suppose we have icicles and one of them is special Then you can find it using questions The algorithm is to use binary search over the minimum prefix that contains the special icicle Each integer can be written using no more than bits Iterate over the bits from to Ask a question about the icicles that have in their numbers in the fixed bit After that we can determine if the numbers of the special icicles differ in this bit Really the bits differ if this subset s size is odd and don t differ otherwise Obviously we will find at least one bit where their numbers differ Let is the subset of the icicles that have in this bit and is the complement set Let is the size of the smallest from these subsets Then Let s solve the problem for the only one special icicle for the smallest of these subsets Then it s easy to get the number of the other icicle we know the number of the first icicle and we know in which bits the numbers differ and in which don t This solution uses 19 question It can be proven that in the given constraints you can t solve this problem in less than 19 questions 
https://codeforces.com//contest/691/problem/B,65087,B,691B,691,B. s-palindrome,Let s call a string if it is symmetric about the middle of the string For example the string is but the string is not The string is not because the second half of it is not a mirror reflection of the first half You are given a string Check if the string is ,"['/*\nI\'ve used hammers made out of wood\nI have played games with pieces and rules\nI undeciphered tricks at the bar\nBut now you\'re gone, I haven\'t figured out why\nI\'ve come up with riddles and jokes about war\nI\'ve figured out numbers and what they\'re for\nI\'ve understood feelings and I\'ve understood words\nBut how could you be taken away?\n\nAnd wherever you\'ve gone\nAnd wherever we might go\nIt don\'t seem fair...\nToday just disappeared.\nYour light\'s reflected now, reflected from afar\nWe were but stones, your light made us stars.\n\nWith heavy breath, awakened regrets\nBack pages and days alone that could have been spent, together...\nBut we were miles apart.\nEvery inch between us becomes light years now\nNo time to be void or save up on life\nYou got to spend it all...\n\nAnd wherever you\'ve gone\nAnd wherever we might go\nIt don\'t seem fair...\nYou seem to like it here\nYour light\'s reflected now, reflected from afar\nWe were but stones, your light made us stars.\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 1000031;\n\nchar w[1000];\nstring st;\n\nint main(){\n\t//freopen(""fabro.in"",""r"",stdin);\n\t//freopen(""fabro.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"", ""r"", stdin);\n\t//freopen(""F:/output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tfor (int i = 0; i <= 500; i++)\n\t\tw[i] = \'.\';\n\n\tw[\'A\'] = \'A\';\n\tw[\'H\'] = \'H\';\n\tw[\'I\'] = \'I\';\n\tw[\'M\'] = \'M\';\n\tw[\'O\'] = \'O\';\n\tw[\'o\'] = \'o\';\n\tw[\'T\'] = \'T\';\n\tw[\'U\'] = \'U\';\n\tw[\'V\'] = \'V\';\n\tw[\'v\'] = \'v\';\n\tw[\'W\'] = \'W\';\n\tw[\'w\'] = \'w\';\n\tw[\'X\'] = \'X\';\n\tw[\'x\'] = \'x\';\n\tw[\'Y\'] = \'Y\';\n\t\n\tw[\'b\'] = \'d\';\n\tw[\'d\'] = \'b\';\n\n\tw[\'p\'] = \'q\';\n\tw[\'q\'] = \'p\';\n\n\tcin >> st;\n\tstring memo = st;\n\tfor (int i = 0; i < st.size(); i++)\n\t{\n\t\tst[i] = w[st[i]];\n\t}\n\t\n\treverse(st.begin(), st.end());\n\tif (st == memo)\n\t\tcout << ""TAK"";\n\telse\n\t\tcout << ""NIE"";\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']",,,"['implementation', 'strings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. s-palindrome.json,https://codeforces.com//blog/entry/46075,The problem was suggested by Nikita Melnikov nickmeller In this problem you should simply find the symmetric letters by picture and also observe that the pairs and is the symmteric reflections C solution 
https://codeforces.com//contest/1236/problem/A,442393,A,1236A,1236,A. Stones,Alice is playing with some stones Now there are three numbered heaps of stones The first of them contains a stones the second of them contains b stones and the third of them contains c stones Each time she can do one of two operations take one stone from the first heap and two stones from the second heap this operation can be done only if the first heap contains at least one stone and the second heap contains at least two stones take one stone from the second heap and two stones from the third heap this operation can be done only if the second heap contains at least one stone and the third heap contains at least two stones She wants to get the maximum number of stones but she doesn t know what to do Initially she has 0 stones Can you help her ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\ntypedef long long ll;\nint i;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int a,b,c;\n        cin >> a >> b >> c;\n        int res = 0;\n        for(int i = 0; i <= a && 2*i <= b; ++i) {\n            int newB = b-i-i;\n            int curr = 3*i;\n            curr +=3*min(newB, c/2);\n            res = max(res, curr);\n        }\n        cout << res << endl;\n    }\n}\n""]",,,"['brute force', 'greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Stones.json,https://codeforces.com/blog/entry/70654,We can use many ways to solve the problem If you just enumerate how many operations of the first and the second type it will also pass Of course there is a greedy solution We make the second operation as much as possible and then use the first operation It takes time 
https://codeforces.com//contest/1167/problem/D,344633,D,1167D,1167,D. Bicolored RBS,A string is called if it does not contain any characters other than and A bracket sequence is called shortly RBS if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are RBS and and are not We can see that each opening bracket in RBS is paired with some closing bracket and using this fact we can define of the RBS as maximum number of bracket pairs such that the 2 nd pair lies inside the 1 st one the 3 rd one inside the 2 nd one and so on For example nesting depth of is 0 is 1 and is 3 Now you are given RBS s of even length n You should color each bracket of s into one of two colors red or blue Bracket sequence r consisting only of red brackets should be RBS and bracket sequence consisting only of blue brackets b should be RBS Any of them can be empty You are not allowed to reorder characters in s r or b No brackets can be left uncolored Among all possible variants you should choose one that of r s and b s nesting depth If there are multiple solutions you can print any of them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nchar wcz[nax];\n\nint b;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (wcz[i]==\'(\')\n\t\t{\n\t\t\tb++;\n\t\t\tprintf(""%d"", (b&1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(""%d"", (b&1));\n\t\t\tb--;\n\t\t}\n\t}\n\tprintf(""\\n"");\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Bicolored RBS.json,https://codeforces.com/blog/entry/67058,Let be nested depth of RBS There is an interesting fact that From the other side we can always reach equation using some approaches Let s look at prefix of length of string Let be number of opening bracket in the prefix number of closing brackets Then we can define balance of the th prefix of as The author s approach is next Let s define of pair of brackets matched in natural way as where is position of opening bracket of this pair Then we will color in red all pairs with even level and in blue with odd level Proof of It can be shown that and exists such that After any coloring of we can define number of opening closing red blue brackets of th prefix of as and respectively Since and then Finally 
https://codeforces.com//contest/1689/problem/E,1426172,E,1689E,1689,E. ANDfinity,After graduating from computer sciences Vlad has been awarded an array a 1 a 2 ldots a n of n non negative integers As it is natural he wanted to construct a graph consisting of n vertices numbered 1 2 ldots n He decided to add an edge between i and j if and only if a i a j 0 where denotes the bitwise AND operation Vlad also wants the graph to be connected which might not be the case initially In order to satisfy that he can do the following two types of operations on the array Choose some element a i and increment it by 1 Choose some element a i and decrement it by 1 possible only if a i 0 It can be proven that there exists a finite sequence of operations such that the graph will be connected So can you please help Vlad find the minimum possible number of operations to do that and also provide the way how to do that ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (a[i] == 0) a[i] = 1, ++ans;\n        }\n        auto check = [&](vector<int> a) {\n            vector<int> vis(31), f(31);\n            function<int(int)> find = [&](int x) {\n                if (f[x] == x) return f[x];\n                return f[x] = find(f[x]);\n            };\n            for (int i = 0; i <= 30; i++) f[i] = i;\n            for (auto i : a) {\n                int r = -1;\n                for (int b = 0; b <= 30; b++) {\n                    if ((i >> b) & 1) {\n                        vis[b] = 1;\n                        if (r == -1) r = b;\n                        f[find(b)] = find(r);\n                    }\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < 30; i++) {\n                if (vis[i] && find(i) == i) {\n                    ++cnt;\n                }\n            }\n            return cnt == 1;\n        };\n        if (check(a)) {\n            cout << ans << endl;\n            for (auto i : a) cout << i << "" "";\n            cout << endl;\n            continue;\n        }\n        int ok = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 1) {\n                --a[i];\n                if (check(a)) {\n                    cout << ans + 1 << endl;\n                    for (auto i : a) cout << i << "" "";\n                    cout << endl;\n                    ok = 1;\n                    break;\n                }\n                ++a[i];\n            }\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 1 << endl;\n                for (auto i : a) cout << i << "" "";\n                cout << endl;\n                ok = 1;\n                break;\n            }\n            --a[i];\n        }\n        if (ok) continue;\n        vector<int> vis(30), f(30);\n        for (int i = 0; i < 30; i++) f[i] = i;\n        function<int(int)> find = [&](int x) {\n            if (f[x] == x) return f[x];\n            return f[x] = find(f[x]);\n        };\n        for (auto i : a) {\n            int r = -1;\n            for (int b = 0; b <= 29; b++) {\n                if ((i >> b) & 1) {\n                    vis[b] = 1;\n                    if (r == -1) r = b;\n                    int x = find(b), y = find(r);\n                    if (x > y) f[x] = y;\n                    else f[y] = x;\n                }\n            }\n        }\n        for (int i = 29; i >= 0; i--) {\n            if (vis[i] && find(i) == i) {\n                for (int j = 0; j < n; j++) {\n                    if ((a[j] >> i) & 1) {\n                        --a[j];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 2 << endl;\n                for (auto i : a) cout << i << "" "";\n                cout << endl;\n                break;\n            }\n            --a[i];\n        }\n    }\n    return 0;\n}']",,,"['bitmasks', 'brute force', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. ANDfinity.json,https://codeforces.com//blog/entry/103471,SolutionFirslty let s understand how to check whether the graph induced by some array is connected in We create a graph over bits Let s take all elements and add an edge between their adjacent bits all bits of a single will be connected To quickly access the lowest bit we will use in code Now we just check whether the graph over bits is connected We check whether the graph for initial array is connected If it is the answer is 0 Then we wonder if the answer is Check if at least one of the graphs for arrays for every is connected Do the same for arrays If none of the graphs is connected the answer is and otherwise Now let s see how the answer will be at most Let be the sequence of indices denoting that has the highest lowest bit the highest value of if then we can just decrease by and connect everything If and we do the same we might disconnect that number from other numbers having the highest lowest bit thus an additional operation of adding to is needed to keep everything connected The answer is in this case Complexity of this solution is 
https://codeforces.com//contest/1837/problem/D,1937912,D,1837D,1837,D. Bracket Coloring,A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example the bracket sequences and are regular the resulting expressions are and the bracket sequences and are not A bracket sequence is called if one of the following conditions is satisfied it is a regular bracket sequence if the order of the characters in this sequence is reversed it becomes a regular bracket sequence For example the bracket sequences are beautiful You are given a bracket sequence s You have to color it in such a way that every bracket is colored into one color for every color there is at least one bracket colored into that color for every color if you write down the sequence of brackets having that color in the order they appear you will get a beautiful bracket sequence Color the given bracket sequence s into the number of colors according to these constraints or report that it is impossible ,"[""#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> S(n + 1, 0);\n    S[0] = 0;\n    for (int j = 0; j < n; j++){\n      if (s[j] == '('){\n        S[j + 1] = S[j] + 1;\n      }\n      if (s[j] == ')'){\n        S[j + 1] = S[j] - 1;\n      }\n    }\n    if (S[n] != 0){\n      cout << -1 << endl;\n    } else {\n      bool pos = false, neg = false;\n      for (int j = 0; j < n; j++){\n        if (S[j] > 0){\n          pos = true;\n        }\n        if (S[j] < 0){\n          neg = true;\n        }\n      }\n      if (!pos || !neg){\n        cout << 1 << endl;\n        for (int j = 0; j < n; j++){\n          cout << 1;\n          if (j < n - 1){\n            cout << ' ';\n          }\n        }\n        cout << endl;\n      } else {\n        vector<int> c(n);\n        for (int j = 0; j < n; j++){\n          if (S[j] + S[j + 1] > 0){\n            c[j] = 1;\n          } else {\n            c[j] = 2;\n          }\n        }\n        cout << 2 << endl;\n        for (int j = 0; j < n; j++){\n          cout << c[j];\n          if (j < n - 1){\n            cout << ' ';\n          }\n        }\n        cout << endl;\n      }\n    }\n  }\n}""]",,,"['constructive algorithms', 'greedy']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Bracket Coloring.json,https://codeforces.com//blog/entry/116752,What properties do beautiful bracket sequences have Well each beautiful sequence is either an RBS regular bracket sequence or a reversed RBS For RBS the the difference between the number of opening and closing brackets is non negative for every its prefix and equal to zero at the end of the string For a reversed RBS the balance is non positive for every prefix and zero at the end of the string So every beautiful string has balance equal to and if the string has non zero balance it is impossible to color it Let s consider the case when the balance of is Suppose we calculated the balance on every prefix of and split it into parts by cutting it along the positions where the balance is For example the string will be split into and For every part of the string we obtain the balance in the end is equal to and the balance in the middle of the part is never equal to since positions with balance equal to were the positions where we split the string So the balance is either positive in all positions of the part or negative in all positions of the part and every string we obtain from cutting into parts will be beautiful A concatenation of two RBS es is always an RBS The same can be said about the strings which become RBS after reversing So for every part we obtain after cutting into parts we can determine whether it is an RBS or a reversed RBS concatenate all RBS es into one big RBS by coloring them into color and concatenate all reversed RBS es into one string by coloring them into color This construction shows that the maximum number of colors is and allows to obtain the coloring into two colors so all that s left to solve the problem is to check whether it s possible to use just one color it is the case if and only if the given string is beautiful 
https://codeforces.com//contest/1712/problem/F,1501809,F,1712F,1712,F. Triameter,You and Your SubmissionA tree is a connected undirected graph without cycles A weighted tree has a weight assigned to each edge The degree of a vertex is the number of edges connected to this vertex You are given a weighted tree with n vertices each edge has a weight of 1 Let L be the set of vertices with degree equal to 1 You have to answer q queries In the i th query You are given a positive integer x i For all u v in L such that u v add edge u v with weight x i to the graph initially the given tree Find the diameter of the resulting graph The diameter of a graph is equal to max limits 1 le u v le n operatorname d u v where operatorname d u v is the length of the shortest path between vertex u and vertex v ,"['#pragma GCC optimize(""Ofast"")\n#include<bits/stdc++.h>\nusing namespace std;\n#define end ed\n#define N 1000005\nint fa[N],f1[N],qwq,f2[N],f3[N],fir[N],end[N],dep[N],tot,rmq[N<<1],D[N<<1][21],lg[N<<1],LG;\nvector<int>son[N];\nstruct node{\n\tint x,y;\n}f[N];\nint Dis(int x,int y){\n\tLG=lg[y-x+1];\n\treturn min(D[x][LG],D[y-(1<<LG)+1][LG]);\n}\nint dis(int x,int y){\n\tif(fir[x]<=end[y]){\n\t\treturn dep[x]+dep[y]-(Dis(fir[x],end[y])<<1);\n\t}\n\treturn dep[x]+dep[y]-(Dis(fir[y],end[x])<<1);\n}\ninline bool cmp(node aa,node bb){\n\treturn aa.y<bb.y;\n}\nvoid dfs(int now){\n\tif(son[now].size()==0)f1[now]=0;\n\telse f1[now]=1e9;\n\tf2[now]=1e9;\n\trmq[++tot]=now;fir[now]=end[now]=tot;\n\tfor(int T,i=0;i<son[now].size();++i){\n\t\tdfs(T=son[now][i]);\n\t\tif(f1[T]+1<f1[now])f2[now]=f1[now],f1[now]=f1[T]+1;\n\t\telse f2[now]=min(f2[now],f1[T]+1);\n\t\trmq[++tot]=now;\n\t\tend[now]=tot;\n\t}\n}\nnamespace IO{\n\tchar ibuf[1<<20],*ip1=0,*ip2=0;\n\tchar gc(){if(ip1==ip2)ip1=ibuf,ip2=ibuf+fread(ibuf,1,1<<20,stdin);return ip1==ip2?EOF:*ip1++;}\n\tchar obuf[1<<20],*op1=obuf,*op2=obuf+(1<<20);\n\tvoid flush(){fwrite(obuf,1,op1-obuf,stdout);}\n\tvoid pc(char c){*op1++=c;if(op1==op2)flush(),op1=obuf;}\n\tstruct ioo{ioo(){}~ioo(){flush();}}ioo;\n};\nusing namespace IO;\nint read(){\n\tint ret=0,t=1;char c=gc();\n\twhile((c<\'0\'||c>\'9\')&&c!=\'-\')c=gc();if(c==\'-\')t=-1,c=gc();\n\twhile(c>=\'0\'&&c<=\'9\')ret=ret*10+c-\'0\',c=gc();return ret*t;\n}\nvoid dfs_(int now){\n\tfor(int T,i=0;i<son[now].size();++i){\n\t\tT=son[now][i];dep[T]=dep[now]+1;\n\t\tif(f1[now]==f1[T]+1)f3[T]=f2[now]+1;\n\t\telse f3[T]=f1[now]+1;\n\t\tf3[T]=min(f3[T],f3[now]+1);\n\t\tdfs_(T);\n\t}\n}\nint n,i,j,g[N][2],diss[N],l,r,mid,q,x,len;\nint check(int ans){\n\tj=n;\n\tif(qwq>=(n>>2)&&n==1000000){\n\t\tfor(i=1;diss[i]>=ans;++i){\n\t\t\twhile(j&&f[i].y+f[j].y+x>=ans)--j;\n\t\t\tif(j!=n){\n\t\t\t\tif(dis(f[i].x,g[j+1][0])>=ans){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif(dis(f[i].x,g[j+1][1])>=ans){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=n;++i){\n\t\twhile(j&&f[i].y+f[j].y+x>=ans)--j;\n\t\tif(j>=i&&diss[i]<ans)continue;\n\t\tif(j!=n){\n\t\t\tif(dis(f[i].x,g[j+1][0])>=ans){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(dis(f[i].x,g[j+1][1])>=ans){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tn=read();\n\tfor(i=2;i<=n;++i)fa[i]=read(),son[fa[i]].push_back(i),qwq+=fa[i]==i-1;\n\tdfs(1);\n\tif(son[1].size()==1)f3[1]=0;\n\telse f3[1]=1e9;\n\tdfs_(1);\n\tlg[1]=0;\n\tfor(i=2;i<(n<<1);++i){\n\t\tlg[i]=lg[i-1]+((i&-i)==i);\n\t}\n\tfor(i=1;i<=n;++i)f1[i]=min(f1[i],f3[i]),f[i].x=i,f[i].y=f1[i];\n\tsort(f+1,f+n+1,cmp);\n\tfor(i=1;i<=tot;++i){\n\t\tD[i][0]=dep[rmq[i]];\n\t}\n\tfor(i=0;(1<<i+1)<tot;++i){\n\t\tfor(j=1;j<=tot-(1<<i);++j){\n\t\t\tif(D[j][i]<=D[j+(1<<i)][i])D[j][i+1]=D[j][i];\n\t\t\telse D[j][i+1]=D[j+(1<<i)][i];\n\t\t}\n\t\tfor(;j<=tot;++j)D[j][i+1]=D[j][i];\n\t}\n\tg[n][0]=f[n].x;\n\tg[n][1]=f[n].x;\n\tdiss[n]=0;\n\tg[n-1][0]=f[n-1].x;\n\tg[n-1][1]=f[n-1].x;\n\tdiss[n-1]=dis(f[n].x,f[n-1].x);\n\tfor(i=n-2;i;--i){\n\t\tint d1=dis(f[i].x,g[i+1][0]),d2=dis(f[i].x,g[i+1][1]);\n\t\tg[i][0]=g[i+1][0];\n\t\tg[i][1]=g[i+1][1];\n\t\tdiss[i]=diss[i+1];\n\t\tif(d1>=d2&&d1>diss[i+1]){\n\t\t\tdiss[i]=d1;\n\t\t\tg[i][1]=f[i].x;\n\t\t}\n\t\tif(d2>d1&&d2>diss[i+1]){\n\t\t\tdiss[i]=d2;\n\t\t\tg[i][0]=f[i].x;\n\t\t}\n\t}\n\tq=read();\n\twhile(q--){\n\t\tx=read();\n\t\tl=0;\n\t\tfor(i=1;i<=n;++i)l=max(l,min(diss[i],f1[g[i][0]]+f1[g[i][1]]+x));\n\t\tr=min(diss[1],f[n].y+f[n-1].y+x);\n\t\twhile(l<r){\n\t\t\tmid=r-(r-l>>1);\n\t\t\tif(check(mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tcout<<l<<\'\\n\';\n\t}\n} ']",,,"['binary search', 'data structures', 'dfs and similar', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Triameter.json,https://codeforces.com//blog/entry/105919,We will solve the problem independently times Let be the distance to the closest leaf from vertex can be found using a simple bfs with multiple start sources Let be the distance in the resulting graph Then A short proof we ll either go through an edge between two leaves or we won t In the second case the answer is clearly In the first case our objective is to get to a leaf as fast as possible use an edge with weight and then move to the destination vertex We want to find the maximum possible value of As is pretty standard in tree problems we can do small to large merging Let s maintain the max value of over all in the subtree of with We have a variable initially For some we will first merge all the subtrees and then add to the merged We will also update during this The final answer will be Merging two subtrees Suppose we are merging subtree into subtree with some current First of all iterate from to For every do this cycle if and then do and continue else break and continue to the next Why does this work Because all arrays are sorted in decreasing order Why Because for some vertex with there is always a vertex in it s subtree with After we are done with that update for every Adding to the merged When we are adding to we update the answer in almost the same way only we set to and to After that we either do or if just append to the back of Complexity This particular variant of small to large merging works in since when merging two structures of size and the new size is You can find the proof here Since we increase at most times and we can calculate for all vertices in the complexity is per query so for all queries Note that doing small to large merging once and updating answers simultaneously is much faster that doing small to large merging times In the first case you can even get away with using binary search to update the answer in the second case you cannot 
https://codeforces.com//contest/1348/problem/B,609089,B,1348B,1348,B. Phoenix and Beauty,Phoenix loves beautiful arrays An array is beautiful if all its subarrays of length k have the same sum A subarray of an array is any sequence of consecutive elements Phoenix currently has an array a of length n He wants to insert some number of integers possibly zero into his array such that it becomes beautiful The inserted integers must be between 1 and n inclusive Integers may be inserted anywhere even before the first or after the last element and he is to minimize the number of inserted integers ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=10010;\nint t,k,n,a[MAXN],b[MAXN],mp[MAXN],rev[MAXN],tmp,cnt;\nint main () {\n\tscanf(""%d"",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(""%d%d"",&n,&k);\n\t\ttmp=cnt=0;\n\t\tfor (int i=1;i<=n;i++) {mp[i]=0;}\n\t\tfor (int i=1;i<=n;i++) {\n\t\t\tscanf(""%d"",&a[i]);\n\t\t\tif (++mp[a[i]]==1) {tmp++;}\n\t\t}\n\t\tif (tmp>k) {printf(""-1\\n"");continue;}\n\t\tint dis=0;\n\t\tfor (int i=1;i<=n;i++) {\n\t\t\tif (n-i+1+dis<=k||mp[i]) {rev[++dis]=i;}\n\t\t}\n\t\tfor (int i=1;i<=n;i++) {\n\t\t\tfor (int j=1;j<=dis;j++) {\n\t\t\t\tb[++cnt]=rev[j];\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",cnt);\n\t\tfor (int i=1;i<=cnt;i++) {printf(""%d "",b[i]);}\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Phoenix and Beauty.json,https://codeforces.com//blog/entry/76555,For an array to be beautiful for some the array must be periodic with period If there exists more than distinct numbers in the array there is no answer and we print because the array cannot be periodic with period Otherwise we propose the following construction Consider a list of all the distinct numbers in array If there are less than of them we will append some s or any other number until the list has size We can just print this list times The length of our array is which never exceeds Array can always be constructed by inserting some numbers into array because every number in corresponds to one list Time complexity for each test case 
https://codeforces.com//contest/666/problem/C,57415,C,666C,666,C. Codeword,The famous sculptor Cicasso is a Reberlandian spy These is breaking news in Berlandian papers today And now the sculptor is hiding This time you give the shelter to the maestro You have a protected bunker and you provide it to your friend You set the security system in such way that only you can open the bunker To open it one should solve the problem which is hard for others but is simple for you Every day the bunker generates a codeword Every time someone wants to enter the bunker integer appears on the screen As the answer one should enter another integer the residue modulo of the number of strings of length that consist only of lowercase English letters and contain the string as the The subsequence of string is a string that can be derived from the string by removing some symbols from it maybe none or all of them In particular any string is the subsequence of itself For example the string is the subsequence of the string You haven t implemented the algorithm that calculates the correct answers yet and you should do that ASAP ,"['#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\n#define MOD 1000000007ll\n\nusing namespace std;\n\ntypedef long long ll;\nll f[100005];\nll vf[100005];\n\nll pw(ll a, ll b) {\n    ll r = 1;\n    while (b) {\n        if (b&1) r = (r*a)%MOD;\n        a = (a*a)%MOD;\n        b /= 2;\n    }\n    return r;\n}\n\nchar buf[100005];\nint m, l;\nvector<tuple<int,int,int> > qu;\nll s[100005];\nll p25[100005];\n\nll c(int n, int k) {\n    return f[n] * vf[k] % MOD * vf[n-k] % MOD;\n}\n\nvoid pc(int nl) {\n    l = nl;\n    FO(i,0,l) s[i] = 0;\n    FO(i,l,100005) {\n        s[i] = s[i-1]*26 + c(i-1,l-1) * p25[i-l];\n        s[i] %= MOD;\n        //printf(""%d:s[%d]=%lld\\n"", l, i, s[i]);\n    }\n}\n\nint main() {\n    f[0] = 1;\n    FO(i,1,100005) f[i] = i*f[i-1]%MOD;\n    vf[100004] = pw(f[100004], MOD-2);\n    for (int i = 100003; i >= 0; i--) vf[i] = vf[i+1]*(i+1)%MOD;\n    p25[0] = 1;\n    FO(i,1,100005) p25[i] = p25[i-1]*25%MOD;\n\n    scanf(""%d"", &m);\n    scanf("" %s"", buf); l = strlen(buf);\n    FO(z,0,m) {\n        int t; scanf(""%d"", &t);\n        if (t == 1) {\n            scanf("" %s"", buf);\n            l = strlen(buf);\n        } else {\n            int n; scanf(""%d"", &n);\n            qu.emplace_back(l, n, z);\n        }\n    }\n\n    sort(qu.begin(),qu.end());\n    l = -1;\n    vector<pair<int,ll> > ans;\n    for (auto q : qu) {\n        int nl, n, z; tie(nl,n,z) = q;\n        if (nl != l) {\n            pc(nl);\n        }\n        ans.emplace_back(z,s[n]);\n    }\n    sort(ans.begin(),ans.end());\n    for (auto a : ans) printf(""%lld\\n"", a.second);\n}\n\n']",,,"['combinatorics', 'strings']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Codeword.json,https://codeforces.com//blog/entry/44622,The first thing to notice string itself does not matter only its length does In each sequence of length containing a fixed subsequence we can select s lexicographically minimal occurance let it be No character may occur between and because otherwise the occurence is not lex min On the other hand if there is an occurence which satsfies this criterion than it is lex min Given this definition we can count number of strings containing given string as a subsequence At first select positions of the lex min occurance there are ways to do it Next you can use any of characters at first intervals between and any of at the end of the string Here denotes alphabet size Looping through the position of last character in in the lex min occurence we can count that there are exactly strings containing as a subsequence So having fixed answer for each could be computed in linear time A final detail input strings can have at most different lengths Thus simply applying the overmentioned formula we get a solution which was the expected one 
https://codeforces.com//contest/1371/problem/E1,658032,E1,1371E1,1371,E1. Asterism  Easy Version ,First Aoi came up with the following idea for the competitive programming problem Yuzu is a girl who collecting candies Originally she has x candies There are also n enemies numbered with integers from 1 to n Enemy i has a i candies Yuzu is going to determine a permutation P A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation because n 3 but there is the number 4 in the array After that she will do n duels with the enemies with the following rules If Yuzu has number of candies than enemy P i she wins the duel and Otherwise she loses the duel and gets nothing The candy which Yuzu gets will be used in the next duels Yuzu wants to How many valid permutations P exist This problem was easy and wasn t interesting for Akari who is a friend of Aoi And Akari made the following problem from the above idea Let s define f x as the number of valid permutations for the integer x You are given n a and p le n Let s call a positive integer x if the value f x is divisible by p Find good integers x Your task is to solve this problem made by Akari ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 2005;\nint n, p, cnt, maxi, a[Maxn], Ans[Maxn];\nint main()\n{\n\tscanf(""%d%d"", &n, &p);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]), maxi = max(maxi, a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = 1; i <= maxi; i++)\n\t{\n\t\tint pnt = 1;\n\t\tlong long ans = 1;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\twhile (pnt <= n && a[pnt] - j + 1 <= i) pnt++;\n\t\t\t(ans *= pnt - j) %= p;\n\t\t}\n\t\tif (ans) Ans[++cnt] = i;\n\t}\n\tprintf(""%d\\n"", cnt);\n\tfor (int i = 1; i <= cnt; i++)\n\t\tprintf(""%d "", Ans[i]);\n\treturn 0;\n}']",,,"['binary search', 'brute force', 'combinatorics', 'math', 'number theory', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Asterism  Easy Version .json,https://codeforces.com//blog/entry/79624,Let s define Yuzu should have at least candies initially to win all duels then for This is divisible by And if Yuzu have equal or more than candies initially any permutation will be valid then for This is divisible by too because Then in this subtask you should find whether each are divisible by for in You can find the value of by following simulation First let the number of enemies they have strictly less than candies Then do the following steps for the number of enemies they have exactly candies Now is a prime Then Whether is divisible by is Whether was multiplied to as at least once This can be simulated in time for each Total complexity 
https://codeforces.com//contest/341/problem/A,3422,A,341A,341,A. Tourist Problem,Iahub is a big fan of tourists He wants to become a tourist himself so he planned a trip There are destinations on a straight road that Iahub wants to visit Iahub starts the excursion from kilometer 0 The destinations are described by a non negative integers sequence The number represents that the th destination is at distance kilometers from the starting point No two destinations are located in the same place Iahub wants to visit each destination only once Note that crossing through a destination is not considered visiting unless Iahub explicitly wants to visit it at that point Also after Iahub visits his last destination he doesn t come back to kilometer 0 as he stops his trip at the last destination The distance between destination located at kilometer and next destination located at kilometer is kilometers We call a route an order of visiting the destinations Iahub can visit destinations in any order he wants as long as he visits all destinations and he doesn t visit a destination more than once Iahub starts writing out on a paper all possible routes and for each of them he notes the total distance he would walk He s interested in the average number of kilometers he would walk by choosing a route As he got bored of writing out all the routes he asks you to help him ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n;\n  while (scanf(""%d"", &n) >= 1) {\n    vi as(n);\n    for (int i = 0; i < n; i++)\n      scanf(""%d"", &as[i]);\n    sort(as.begin(), as.end());\n\n    ll suml = 0, sumr = 0;\n    for (int i = 0; i < n; i++) sumr += as[i];\n\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n      sumr -= as[i];\n\n      ll sumLen = 0;\n      sumLen += sumr - ll(n - i - 1) * as[i];\n      sumLen += ll(i) * as[i] - suml;\n//      eprintf(""%I64d (%I64d %I64d)\\n"", sumLen, suml, sumr);\n      ans += sumLen;\n\n      suml += as[i];\n    }\n//    eprintf(""%I64d %I64d\\n"", ans, ansb);\n    for (int i = 0; i < n; i++)\n      ans += as[i];\n    ll ansb = n;\n    ll x = gcd(ans, ansb);\n    ans /= x;\n    ansb /= x;\n    printf(""%I64d %I64d\\n"", ans, ansb);\n  }\n  return 0;\n}\n']",,,['math'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Tourist Problem.json,https://codeforces.com/blog/entry/8755,Despite this is a math task the only math formula we ll use is that number of permutations with n elements is n From this one we can deduce the whole task The average formula is sum of all routes number of routes As each route is a permutation with n elements number of routes is n Next suppose you have a permutation of a p1 p2 pn The sum for it will be p1 p2 p1 pn pn 1 The sum of routes will be the sum for each possible permutation We can calculate sum of all routes in two steps first time we calculate sums like p1 and then we calculate sums like p2 p1 pn pn 1 for every existing permutation First step Each element of a1 a2 an can appear on the first position on the routes and needs to be added as much as it appears Suppose I fixed an element X for the first position I can fill positions 2 3 n 1 in n 1 ways Why It is equivalent to permuting n 1 elements all elements except X So sum of all a1 n 1 a2 n 1 an n 1 n 1 a1 a2 an Second step For each permutation for each position j between 1 and n 1 we need to compute pj p j 1 Similarly to first step we observe that only elements from a can appear on consecutive positions We fix 2 indices i and j We re interested in how many permutations do ai appear before aj We fix k such as on a permutation p ai appears on position k and aj appears on a position k 1 In how many ways can we fix this n 1 ways 1 2 n 1 What s left A sequence of n 2 elements which can be permuted independently So the sum of second step is ai aj n 1 n 2 for each i j If I note a1 a2 an by S1 and ai aj for each i j by S2 the answer is N 1 S1 N 1 S2 N By a simplification the answer is S1 S2 N The only problem remained is how to calculate S2 Simple iteration won t enter in time limit Let s think different For each element I need to make sum of differences between it and all smaller elements in the array a As well I need to make sum of all different between bigger elements than it and it I ll focus on the first part I sort increasing array a Suppose I m at position i I know that i 1 elements are smaller than ai The difference is simply i 1 ai sum of elements before position i Sum of elements before position i can be computed when iterating i Let s call the obtained sum Sleft I need to calculate now sum of all differences between an element and bigger elements than it This sum is equal to Sleft As a proof for an element ai calculating the difference aj ai when aj ai is equivalent to calculating differences between aj and a smaller element of it in this case ai That s why Sleft Sright As a conclusion the answer is S1 2 Sleft N For make fraction irreducible you can use Euclid s algorithm The complexity of the presented algorithm is O N logN necessary due of sorting Sorting can be implemented by count sort as well having a complexity of O maximalValue but this is not necessary 
https://codeforces.com//contest/1256/problem/B,459825,B,1256B,1256,B. Minimize the Permutation,You are given a permutation of length n Recall that the permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array You can perform at most n 1 operations with the given permutation it is possible that you don t perform any operations at all The i th operation allows you to swap elements of the given permutation on positions i and i 1 The operations can be performed in arbitrary order Your task is to find the lexicographically minimum possible permutation obtained by performing some of the given operations in some order You can see the definition of the lexicographical order in the notes section You have to answer q independent test cases For example let s consider the permutation 5 4 1 3 2 The minimum possible permutation we can obtain is 1 5 2 4 3 and we can do it in the following way perform the second operation swap the second and the third elements and obtain the permutation 5 1 4 3 2 perform the fourth operation swap the fourth and the fifth elements and obtain the permutation 5 1 4 2 3 perform the third operation swap the third and the fourth elements and obtain the permutation 5 1 2 4 3 perform the first operation swap the first and the second elements and obtain the permutation 1 5 2 4 3 Another example is 1 2 4 3 The minimum possible permutation we can obtain is 1 2 3 4 by performing the third operation swap the third and the fourth elements ,"['//ZJ_MRZ\'s Code\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<vector>\n#define re register\n#define N 110\nusing namespace std;\ninline int read();\ninline long long readl();\ninline void write(int x,int ch);\ninline void writel(int x,int ch);\nint a[N],n;\ninline void sol() {\n\tn=read();\n\tint minv,minn,minr;\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i]=read();\n\t\tif(a[i]==1) {\n\t\t\tminn=i;\n\t\t\tminr=i;\n\t\t}\n\t}\n\tfor(int i=minn-1;i>=1;i--)\n\t\tswap(a[i],a[i+1]);\n\twhile(minr<n) {\n\t\tminv=200;\n\t\tfor(int i=minr;i<=n;i++) {\n\t\t\tif(a[i]<minv) {\n\t\t\t\tminv=a[i];\n\t\t\t\tminn=i;\n\t\t\t}\n\t\t}\n\t\tif(minn==minr) {\n\t\t\tminr++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=minn-1;i>=minr;i--)\n\t\t\tswap(a[i],a[i+1]);\n\t\tminr=minn;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tcout<<a[i]<<"" "";\n\t}\n\tcout<<endl;\n\treturn;\n}\nsigned main() {\n\tint T;\n\tT=read();\n\twhile(T--) {\n\t\tsol();\n\t}\n\treturn 0;\n}\ninline void writel(long long x,int ch) {\n\tif(x<0) {\n\t\tputchar(\'-\');\n\t\tx=-x;\n\t}\n\tif(x>9) {\n\t\twrite(x/10,0);\n\t}\n\tputchar(x%10+\'0\');\n\tif(ch)\n\t\tprintf(""\\n"");\n\treturn;\n}\ninline void write(int x,int ch) {\n\tif(x<0) {\n\t\tputchar(\'-\');\n\t\tx=-x;\n\t}\n\tif(x>9) {\n\t\twrite(x/10,0);\n\t}\n\tputchar(x%10+\'0\');\n\tif(ch)\n\t\tprintf(""\\n"");\n\treturn;\n}\ninline long long readl() {\n    long long x=0,f=1;\n    char ch=getchar();\n    while(ch>\'9\'||ch<\'0\') {\n        if(ch==\'-\')\n            f=-1;\n        ch=getchar();\n    }\n    while(ch>=\'0\'&&ch<=\'9\') {\n        x=x*10+ch-\'0\';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int read() {\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>\'9\'||ch<\'0\') {\n        if(ch==\'-\')\n            f=-1;\n        ch=getchar();\n    }\n    while(ch>=\'0\'&&ch<=\'9\') {\n        x=x*10+ch-\'0\';\n        ch=getchar();\n    }\n    return x*f;\n}']",,,['greedy'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Minimize the Permutation.json,https://codeforces.com//blog/entry/71184,The following greedy solution works let s take the minimum element and move it to the leftmost position we can With this algorithm all forbidden operations are form the prefix of operations and so on So we can carry the position of the leftmost operation we can perform Initially it is We repeat the algorithm until Let s find the position of the minimum element among elements Let this position be If then let s increase and continue the algorithm Otherwise we need to move the element from the position to the position and then set Time complexity 
https://codeforces.com//contest/1743/problem/D,1590319,D,1743D,1743,D. Problem with Random Tests,You are given a string s consisting of n characters Each character of s is either or A substring of s is a contiguous subsequence of its characters You have to choose two substrings of s possibly intersecting possibly the same possibly non intersecting just any two substrings After choosing them you calculate the value of the chosen pair of substrings as follows let s 1 be the first substring s 2 be the second chosen substring and f s i be the integer such that s i is its binary representation for example if s i is f s i 26 the value is the of f s 1 and f s 2 Calculate the maximum possible value you can get and print it ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::string s;\n    std::cin >> s;\n    \n    if (s.find(\'1\') == std::string::npos) {\n        std::cout << 0 << ""\\n"";\n        return 0;\n    }\n    \n    int a = s.find(\'1\');\n    \n    if (s.substr(a).find(\'0\') == std::string::npos) {\n        std::cout << s.substr(a) << ""\\n"";\n        return 0;\n    }\n    \n    int b = a + s.substr(a).find(\'0\');\n    \n    auto ans = s;\n    \n    for (int i = 0; i <= b - a; i++) {\n        auto res = s;\n        for (int j = 0; j + i < n; j++) {\n            res[j + i] |= s[j];\n        }\n        ans = std::max(ans, res);\n    }\n    ans = ans.substr(ans.find(\'1\'));\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']",,,"['brute force', 'dp', 'greedy', 'probabilities']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Problem with Random Tests.json,https://codeforces.com//blog/entry/108153,The first observation we need is that we can choose two prefixes of as the substrings used in forming the results This can be proved easily suppose we chose a substring which does not contain the leftmost character of if we expand it to the left the answer won t become worse So it is optimal to choose two prefixes of as the substrings Furthermore one of these prefixes must be itself if the leftmost index of is the length of the answer won t exceed but the only way to have a in the th bit of the answer is to choose a prefix of where the th character from the right is and there is only one such prefix of which is itself So now we can solve the problem in try to combine all prefixes of with itself and choose the one that yields the best answer To speed this up we need to somehow cut down on the number of prefixes of we check Let s look at the first block of s in The next character after this block is since we take as one of the substring in order to get instead of in the corresponding position of the answer we need to choose a prefix which has in that position This represents one of the s from the first block of s since only one of them can shift to that position So we need to check only the prefixes such that by using them we shift some character from the first block to the position of the first after this block Since the tests are random the expected length of the first block of s is furthermore even the probabiliy that its length is or bigger is about so the expected number of prefixes we need to check is also Thus the expected runtime of our solution is 
https://codeforces.com//contest/808/problem/G,106403,G,808G,808,G. Anthem of Berland,Berland has a long and glorious history To increase awareness about it among younger citizens King of Berland decided to compose an anthem Though there are lots and lots of victories in history of Berland there is the one that stand out the most King wants to mention it in the anthem as many times as possible He has already composed major part of the anthem and now just needs to fill in some letters King asked you to help him with this work The anthem is the string of no more than small Latin letters and question marks The most glorious victory is the string of no more than small Latin letters You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string in string is maximal Note that the occurrences of string in can overlap Check the third example for clarification ,"['#include<cstdio>\n#include<cstring>\nchar s1[100007],s2[100007];\nint fa[100007],f[100007],g[100007];\nbool is[100007];\nvoid maxs(int&a,int b){if(a<b)a=b;}\nint main(){\n\tscanf(""%s%s"",s1+1,s2+1);\n\tint l1=strlen(s1+1),l2=strlen(s2+1);\n\tfor(int i=2,j=0;i<=l2;++i){\n\t\twhile(j&&s2[i]!=s2[j+1])j=fa[j];\n\t\tif(s2[i]==s2[j+1])++j;\n\t\tfa[i]=j;\n\t}\n\tfor(int i=l2;i<=l1;++i){\n\t\tis[i]=1;\n\t\tfor(int a=0;a<l2;++a)if(s1[i-a]!=\'?\'&&s1[i-a]!=s2[l2-a]){\n\t\t\tis[i]=0;\n\t\t\tbreak;\n\t\t}\n\t\tg[i]=g[i-1];\n\t\tif(is[i]){\n\t\t\tf[i]=g[i-l2];\n\t\t\tfor(int j=fa[l2];j;j=fa[j]){\n\t\t\t\tmaxs(f[i],f[i-(l2-j)]);\n\t\t\t}\n\t\t\t++f[i];\n\t\t\tmaxs(g[i],f[i]);\n\t\t}\n\t}\n\tprintf(""%d"",g[l1]);\n\treturn 0;\n}']",,,"['dp', 'strings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Anthem of Berland.json,https://codeforces.com//blog/entry/52010,Let s denote the string obtained by concatenation where is some dividing character that isn t a part of the alphabet as Recall that KMP algorithm builds the prefix function for this string We can calculate on this string where is the position in this string and is the value of prefix function in this position The value of is the maximum number of occurences of found so far or if this situation is impossible If th character is a Latin letter then we just recalculate prefix function for this position the fact that in KMP the value of prefix function won t exceed allows us to do so If th character is a question mark then we check all possible characters and recalculate prefix function for all of these characters and update the corresponding values The size of and is pretty big so we need to recalculate these values in time this can be done by precalculating the values of is the value of prefix function is a new character and is the value of prefix function after adding this character 
https://codeforces.com//contest/367/problem/B,4097,B,367B,367,B. Sereja ans Anagrams,Sereja has two sequences and and number Sequence consists of integers Similarly sequence consists of integers As usual Sereja studies the sequences he has Today he wants to find the number of positions such that sequence can be obtained from sequence by rearranging elements Sereja needs to rush to the gym so he asked to find all the described positions of ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nmap <int, int> mp;\n\nint bad;\nint a[200010],b[200010],c[200010];\nbool ans[200010];\n\nvoid add(int x){\n    mp[x]++;\n    int tmp = mp[x];\n    if(tmp == 1) bad++;\n    if(tmp == 0) bad--;\n}\n\nvoid erase(int x){\n    mp[x]--;\n    int tmp = mp[x];\n    if(tmp == -1) bad++;\n    if(tmp == 0) bad--;\n}\n\nvoid func(int n, int m, int offset, int step){ // b: m, c: n, find b from c\n    int i;\n    \n    if(n < m) return;\n    \n    REP(i,m) add(c[i]);\n    if(bad == 0) ans[offset] = true;\n    // cout << offset << \' \' << bad << endl;\n    \n    for(i=m;i<n;i++){\n        add(c[i]);\n        erase(c[i-m]);\n        if(bad == 0) ans[offset + step * (i-m+1)] = true;\n        // cout << offset + step * (i-m+1) << \' \' << bad << endl;\n    }\n    \n    for(i=n-m;i<n;i++) erase(c[i]);\n}\n\nint main(void){\n    int n,m,p,i,j;\n    \n    cin >> n >> m >> p;\n    REP(i,n) scanf(""%d"", &a[i]);\n    REP(i,m) scanf(""%d"", &b[i]);\n    \n    REP(i,m) erase(b[i]);\n    \n    REP(i,p){\n        int n2 = 0;\n        for(j=i;j<n;j+=p){\n            c[n2] = a[j];\n            n2++;\n        }\n        func(n2, m, i, p);\n    }\n    \n    int cnt = 0;\n    REP(i,n) if(ans[i]) cnt++;\n    cout << cnt << endl;\n    bool first = true;\n    REP(i,n) if(ans[i]){\n        if(!first) printf("" "");\n        first = false;\n        printf(""%d"", i+1);\n    }\n    \n    cout << endl;\n    \n    return 0;\n}\n']",,,"['binary search', 'data structures']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Sereja ans Anagrams.json,https://codeforces.com//blog/entry/9726,We will divide the sequence on sequences st th th element will go to the first sequence nd th th will go to the second sequence and so on Now you need to find an answer for each of them considering that This can be solved by a simple method You can go along the sequence from left to right and count the number of occurrences of each number If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence then everything is OK 
https://codeforces.com//contest/1923/problem/A,2492664,A,1923A,1923,A. Moving Chips,There is a ribbon divided into n cells numbered from 1 to n from left to right Each cell either contains a chip or is free You can perform the following operation any number of times possibly zero choose a chip and move it to the You can choose any chip that you want provided that there is at least one free cell to the left of it When you move the chip the cell where it was before the operation becomes free Your goal is to move the chips in such a way that What is the minimum number of operations you have to perform ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int l = 0, r = n - 1;\n    while (a[l] == 0) {\n        l++;\n    }\n    while (a[r] == 0) {\n        r--;\n    }\n    int ans = std::count(a.begin() + l, a.begin() + r, 0);\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Moving Chips.json,https://codeforces.com//blog/entry/126339,Denote the position of the leftmost chip as the position of the rightmost chip as and the number of chips as Having all chips in one block without free spaces means that we need to reach the situation when Since is always met the situation when is when the chips are packed as close as possible we need to decrease the value of as fast as possible There are two approaches to do it One is to try decreasing every time i e let s code a greedy solution that always applies an operation to the current rightmost chip This is actually one of the correct solutions to the problem But if we prove it we can design an easier solution Whenever we apply an operation on any chip other than the rightmost chip the value of does not decrease we either don t change and at all or decrease But whenever we apply an operation on the rightmost chip decreases by exactly the new rightmost chip will be in position either it is present there before the operation or it will be moved there from So only applying the operations to the rightmost chip decreases and it always decreases by exactly no matter what So the answer to the problem is actually 
https://codeforces.com//contest/1234/problem/D,426514,D,1234D,1234,D. Distinct Characters Queries,You are given a string s consisting of lowercase Latin letters and q queries for this string Recall that the substring s l r of the string s is the string s l s l 1 dots s r For example the substrings of are but not and There are two types of queries 1 pos c 1 le pos le s c is lowercase Latin letter replace s pos with c set s pos c 2 l r 1 le l le r le s calculate the number of distinct characters in the substring s l r ,"['#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << ""="" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int MAX_N = (int)1e5 + 777;\nconst int A     = 26;\n\nint tree[2 * MAX_N], n;\n\nvoid solve() {\n\tstring str;\n\tcin >> str;\n\n\tn = len(str);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint code = str[i] - \'a\';\n\t\ttree[i + n] = 1 << code;\n\t}\n\n\tfor(int i = n - 1; i > 0; --i) {\n\t\ttree[i] = tree[2 * i] | tree[2 * i + 1];\n\t}\n\n\tint q;\n\tcin >> q;\n\n\twhile(q--) {\n\t\tint type;\n\t\tcin >> type;\n\n\t\tif(type == 1) {\n\t\t\tint pos;\n\t\t\tchar chr;\n\t\t\tcin >> pos >> chr;\n\t\t\t--pos;\n\t\t\tpos += n;\n\n\t\t\tint code = chr - \'a\';\n\t\t\ttree[pos] = 1 << code;\n\n\t\t\tfor(; pos > 0; pos /= 2)\n\t\t\t\ttree[pos / 2] = tree[pos] | tree[pos ^ 1];\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l, --r;\n\t\t\tl += n, r += n;\n\t\t\t++r;\n\n\t\t\tint msk = 0;\n\n\t\t\twhile(l < r) {\n\t\t\t\tif(l & 1)\n\t\t\t\t\tmsk |= tree[l++];\n\n\t\t\t\tif(r & 1)\n\t\t\t\t\tmsk |= tree[--r];\n\n\t\t\t\tl /= 2;\n\t\t\t\tr /= 2;\n\t\t\t}\n\n\t\t\tint answ = 0;\n\n\t\t\tfor(int j = 0; j < A; ++j) {\n\t\t\t\tansw += (msk >> j) & 1;\n\t\t\t}\n\n\t\t\tcout << answ << \'\\n\';\n\t\t}\n\t}\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n']",,,['data structures'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Distinct Characters Queries.json,https://codeforces.com//blog/entry/70233,Let s store for each letter all positions in which it appears in some data structure We need such a data structure that can add remove and find the next element greater than or equal to our element fast enough Suddenly this data structure is again in C When we meet the first type query let s just modify two elements of corresponding sets one remove one add When we meet the second type query let s iterate over all letters If the current letter is in the segment then the first element greater than or equal to in the corresponding set should exist and be less than or equal to If it is so let s increase the answer by one After iterating over all letters just print the answer Time complexity when is the size of the alphabet 
https://codeforces.com//contest/1154/problem/E,331481,E,1154E,1154,E. Two Teams,There are n students standing in a row Two coaches are forming two teams the first coach chooses the first team and the second coach chooses the second team The i th student has integer programming skill a i All programming skills are and between 1 and n inclusive Firstly the first coach will choose the student with maximum programming skill among all students not taken into any team k closest students to the left of him and k closest students to the right of him if there are less than k students to the left or to the right all of them will be chosen All students that are chosen leave the row and join the first team Secondly the second coach will make the same move but all students chosen by him join the second team Then again the first coach will make such move and so on This repeats until the row becomes empty i e the process ends when each student becomes to some team Your problem is to determine which students will be taken into the first team and which students will be taken into the second team ,"['// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n    assert(~c);\n  }\n  if (c == \'-\') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  set<pair<int, int> > s;\n  set<int> pos;\n  int n = read(), k = read();\n  vector<int> arr(n), ans(n);\n  for (int i = 0; i < n; ++i) {\n    s.emplace(arr[i] = read(), i);\n    pos.emplace(i);\n  }\n  while (!s.empty()) {\n    static int cur = 2;\n    if (cur & 1) ++cur; else --cur;\n    int id = s.rbegin()->second;\n    auto it = pos.find(id);\n    /* get left */ {\n      if (it != pos.begin()) {\n        auto jt = it; --jt;\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          if (jt == pos.begin()) {\n            pos.erase(jt); break;\n          }\n          auto kt = jt; --jt;\n          pos.erase(kt);\n        }\n      }\n    } /* get right */ {\n      auto jt = it; ++jt;\n      if (jt != pos.end()) {\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          auto kt = jt; ++jt; pos.erase(kt);\n          if (jt == pos.end()) break;\n        }\n      }\n    }\n    ans[*it] = cur;\n    s.erase({arr[*it], *it});\n    pos.erase(it);\n  }\n  for (int i = 0; i < n; ++i) {\n    printf(""%d"", ans[i]);\n  }\n  return 0;\n}\n']",,,"['data structures', 'implementation', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Two Teams.json,https://codeforces.com//blog/entry/66586,Let s maintain two data structures a queue with positions of students in order of decreasing their programming skill and a set note that we need exactly set with positions of students not taken in any team To construct the first data structure we need to sort pairs in decreasing order of the first element and after that push second elements in order from left to right The second data structure can be constructed even easier we just need to insert all values from into it Also let s maintain an array where if the th student belongs to the first team and otherwise and the variable to determine whose turn is now initially it is While our set is not empty let s repeat the following algorithm firstly while the head the first element of the queue is not in the set pop it out This is how we determine which student will be taken now Let his position be And don t forget to pop him out too Create the additional dynamic array which will contain all students we will add to the team during this turn Let s find the iterator to the student with the position Then make the following sequence of moves times add the element the current iterator is pointing at to the array then if the current iterator is pointing at the first element break the cycle otherwise go to the iterator pointing at the previous element Then let s find the iterator to the student next to the student with position And then let s make almost the same sequence of moves times if the current iterator is pointing to the end of the set break the cycle otherwise add the element the current iterator is pointing at to the array and advance to the iterator pointing at the next element Then let s remove all values from the array from the set and for each student we delete let s set And change the variable to if it is now and to otherwise Time complexity 
https://codeforces.com//contest/1485/problem/D,893887,D,1485D,1485,D. Multiples and Power Differences,You are given a matrix a consisting of positive integers It has n rows and m columns Construct a matrix b consisting of positive integers It should have the same size as a and the following conditions should be met 1 le b i j le 10 6 b i j is a multiple of a i j the absolute value of the difference between numbers in any adjacent pair of cells two cells that share the same side in b is equal to k 4 for some integer k ge 1 k is not necessarily the same for all pairs it is own for each pair We can show that the answer always exists ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,m,a[505][505];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tif((i+j)&1)a[i][j]=720720;\n\t\t\telse a[i][j]=720720-x*x*x*x;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<m;++j)printf(""%d "",a[i][j]);\n\t\tprintf(""%d\\n"",a[i][m]);\n\t}\n    return 0;\n}\n']",,,"['constructive algorithms', 'graphs', 'math', 'number theory']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Multiples and Power Differences.json,https://codeforces.com//blog/entry/87470,SolutionBuild a matrix with a checkerboard pattern let if is even and otherwise The difference between two adjacent cells is obviously a fourth power of an integer We choose because it is This ensures that is a multiple of because it is either itself or the sum of two multiples of Complexity 
https://codeforces.com//contest/1082/problem/E,64167,E,1082E,1082,E. Increasing Frequency,You are given array a of length n You can choose one segment l r 1 le l le r le n and integer value k positive negative or even zero and change a l a l 1 dots a r by k each i e a i a i k for each l le i le r What is the maximum possible number of elements with value c that can be obtained after one such operation ,"['/*\nFeel so good I feel so fine\nLove that little lady always on my mind\nGives me lovin\' every night and day\nNever gonna leave her, never goin\' away\n\nSomeone to love me\nYou know she makes me feel alright\nSomeone who needs me\nLove me every single night\n\nFeel so happy since I met that girl\nWhen we\'re making love it\'s something out of this world\n\nFeels so good to know that she\'s all mine\nGoing to love that woman \'til the end of time\n\nSomeone to live for\nLove me \'til the end of time\nMakes me feel happy\nGood to know that she\'s all mine\n\nLovely lady make love all night long\nLovely lady never do me wrong\nI don\'t wanna leave ya\nI never wanna leave ya,\nanymore no more\nLovely lady, mystifying eyes\nLovely lady, she don\'t tell me no lies\nI know I\'ll never leave ya\nI\'m never gonna leave ya anymore no more\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n,C,ar[N],pref[N],suf[N];\nint last_entry[N],best_pref[N];\nint ans;\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>C;\n\n\tfor (int i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tpref[i]=pref[i-1];\n\t\tif (ar[i]==C)\n\t\t\tpref[i]++;\n\t}\n\n\tfor (int i=n;i>=1;--i){\n\t\tsuf[i]=suf[i+1];\n\t\tif (ar[i]==C)\n\t\t\tsuf[i]++;\n\t}\n\n\tfor (int i=1;i<=n;i++){\n\t\tbest_pref[i]=pref[i-1]+1;\n\t\tint le=last_entry[ar[i]];\n\t\tif (le>0)\n\t\t\tbest_pref[i]=max(best_pref[i],best_pref[le]+1);\n\t\tlast_entry[ar[i]]=i;\n\t}\n\n\tfor (int i=1;i<=n;i++){\n\t\tans=max(ans,best_pref[i]+suf[i+1]);\n\t}\n\tcout<<ans<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']",,,"['binary search', 'dp', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Increasing Frequency.json,https://codeforces.com/blog/entry/63544,Let be a number of occurrences of number in subsegment The given task is equivalent to choosing and value such that is maximum possible But with some transformations so we need to maximize Key observation is the next if we fix some value then we can shrink each segment between consecutive occurrences of in one element with weight equal to Then we need just to find subsegment with maximal sum the standard task which can be solved in Finally total complexity is 
https://codeforces.com//contest/1009/problem/C,197474,C,1009C,1009,C. Annoying Present,Alice got an array of length n as a birthday present once again This is the third year in a row And what is more disappointing it is overwhelmengly boring filled entirely with zeros Bob decided to apply some changes to the array to cheer up Alice Bob has chosen m changes of the following form For some integer numbers x and d he chooses an arbitrary position i 1 le i le n and for every j in 1 n adds x d cdot dist i j to the value of the j th cell dist i j is the distance between positions i and j i e dist i j i j where x is an absolute value of x For example if Alice currently has an array 2 1 2 2 and Bob chooses position 3 for x 1 and d 2 then the array will become 2 1 2 cdot 2 1 1 2 cdot 1 2 1 2 cdot 0 2 1 2 cdot 1 5 2 1 3 Note that Bob can t choose position i outside of the array that is smaller than 1 or greater than n Alice will be the happiest when the elements of the array are as big as possible Bob claimed that the arithmetic mean value of the elements will work fine as a metric What is the maximum arithmetic mean value Bob can achieve ,"['//nie, 3 cze 2018, 13:38:19 CEST\n//Konrad Paluszek, University of Warsaw (former XIV LO Staszic)\n# include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst bool local = \n#ifdef LOCAL\ntrue;\n#else\nfalse;\n#endif\n#define f first\n#define s second\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define bvt(s, f) int s(int x){return f(x);}int s(UI x){return f(x);}int s(LL x){return f##ll(x);}int s(ULL x){return f##ll(x);}\n#define FORBITS(i,m)  for(decltype(m)lP6N4Slr=(m),i=lP6N4Slr?ctz(lP6N4Slr):0;lP6N4Slr;lP6N4Slr^=((decltype(m))1<<i),i=ctz(lP6N4Slr))\n#define FORDBITS(i,m) for(decltype(m)_6Im=(m),i=_6Im?8*sizeof(m)-clz(_6Im)-1:0;_6Im;_6Im^=((decltype(m))1<<i),i=8*sizeof(m)-clz(_6Im)-1)\n#define SUBS(i, mask) for(decltype(mask)i = (mask),NFR9xNQCJZTrYQ=1;NFR9xNQCJZTrYQ;NFR9xNQCJZTrYQ=i,i=(i-1)&(mask))\n#define PB push_back\n#define MP make_pair\n#define MT(a, b, c) MP(MP(a, b), c)\n#define MQ(a, b, c, d) MP(MP(a, b), MP(c, d))\n#define tri(a, b, c) pair <pair <a, b>, c>\n#define quadr(a, b, c, d) pair <pair <a, b>, pair <c, d> >\n#define EB emplace_back\n# define jvx(...)\n# define fkz(...) __VA_ARGS__ jvx()\n# define cxo(...) __VA_ARGS__\n#define uuu_id() uuu\nusing LL=long long;using PII=pair<int,int>;using VI=vector<int>;using SI=set<int>;\nusing MII=map<int,int>;using UMII=unordered_map<int, int>;using LD=long double;using TII=\npair<PII,int>;using QII=pair<PII,PII>;using UI=unsigned int;using ULL=unsigned long long;\n#define uuu(prev, t) using S##t=set<t>; using V##t=vector<t>; using M##t=map<t,t>;\\\n\tusing MI##t=map<int,t>;using US##t=unordered_set<t>; prev(S##t) prev(V##t)\n#define uuu_() uuu\n#define ymd(t) \n#define ymd2(t) fkz(uuu_)()(ymd, t)\n#define ymd3(t) cxo(cxo(cxo(fkz(uuu_)()(ymd2, t))))\n#define ymd4(t) using P##t = pair<t,t>; using T##t=tri(t,t,t); using Q##t=quadr(t,t,t,t); \\\n\tymd3(P##t) ymd3(T##t) ymd3(Q##t) ymd3(t)\nymd4(LL) ymd4(LD) ymd3(PII) ymd3(TII) ymd3(QII) ymd4(VI) ymd4(SI) ymd4(UI) ymd4(ULL)\nbvt(popc,__builtin_popcount)bvt(ctz,__builtin_ctz)bvt(clz,__builtin_clz)bvt(bit_parity,__builtin_parity)\n#define siz(r) ((int)r.size())\n#define ALL(r) r.begin(), r.end()\n#define sim template <class T\n#define ros return o\nsim,class N>bool mini(T&o,N h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(T&o,N h){if(o<h)ros=h,1;return 0;}\n#define oor >ostream &operator<<(ostream &o,\n#define urs(r) typename pta<typename remove_reference<decltype(r)>::type>::t\n#define bnt ;}sim> struct\nsim,class N oor pair<T,N>u){ros<<""<""<<u.f<<"", ""<<u.s<<"">"" bnt pta{using t=T;};sim,int N>struct pta<T[N]>{using t=T*;};\nsim,typename=typename enable_if<!is_same<T,string>::value,urs(T().end())>::type oor\nT u){int c=0;o<<""{"";for(auto e:u)o<<"", ""+2*!c++<<e;ros<<""}"";}\nint mpow(int b, int e) {int o = 1; while (e) {if (e & 1)o = o * 1ll * b % MOD;b = b * 1ll * b % MOD;e /= 2;}ros;}\nvoid dor(){cerr<<dec<<""\\033[0m""<<endl;}sim,class...N>void dor(T x,N...y){cerr<<boolalpha<<x<<""; "";dor(y...);} const bool deb =\n#define acv(N,O) sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(N o, T x) {ros O N(x);} \\\n  sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(T o, N x) {return N(o) O x;} \\\n  sim> typename enable_if<is_arithmetic<T>::value || is_same<T,N>::value, N&>::type operator O##=(N &o, T x) {ros = o O N(x);}\n#ifdef DEB\ntrue;\n#define debug(c...)cerr<<""\\033[1;""<<30+__LINE__%8<<""m[""<<__FUNCTION__<<""#""<<__LINE__<<""] \\033[""<<30+(__LINE__/8+__LINE__*3)%8<<""m"",::dor(c)\n#define rcu m);}g(+) g(-) g(*) g(/) g(%) g(<<) g(>>) g(^) g(|) g(&) g(>=) g(<=) g(>) g(<) g(!=) g(==)\n#define zub(h,t,n...) class N> auto operator h(n u)->nep<urs(t)> {return ngy(t,\nsim>string bte(T u){stringstream o;o<<u;ros.str()bnt nep;sim>T yyo(nep<T>);sim>nep<T>ngy(T v,string c,int m=0);sim>T yyo(T o){ros bnt\nnep{T v;string c;int m; nep<T>mask(){return ngy(v,c,1);}\n#define g(o) template<zub(o, v o u, N) ""("" + bte(*this) + "") "" #o "" ("" + bte(u) + "")"", m);}\ntemplate<zub([],v[yyo(u)],N)c+""[""+bte(u)+""]"",rcu};sim>nep<T>ngy(T v,string c,int m){return nep<T>{v,c,m};}\nsim>T yyo(nep<T> o){ros.v;}sim>int uhn(T){return 0;}sim>int uhn(nep<T>o){ros.m;}\n#define ccy(c, y) sim> class enable_if<c is_arithmetic<T>::value,string>::type ema(T u){return bte(y);}\nccy(,bitset<8*sizeof(T)>(u))ccy(!,u)sim,class N> string ema(pair<T,N> o) {return ""<"" + ema(o.f) + "", "" + ema(o.s) + "">"";}\n#define g(o) sim, zub(o, yyo(p) o u.v, T p, nep<N>) ""("" + bte(p) + "") "" #o "" ("" + bte(u) + "")"", uhn(p) + u.m);}\nsim>string bte(nep<T>o){ros.c+"" = ""+(o.m?ema(o.v):bte(o.v));}sim oor nep<T>m){ros<<bte(rcu sim>nep<T>ngy(nep<T>o,string c="""",int m=0){ros;}\n#undef g\n#define imie(a...) ngy(a, #a)\n#define imask(a...) ngy(a, #a, 1)\n#define range(u, g, c) ngy(list<urs(u[0])>(&u[yyo(g)], &u[yyo(c)] + 1), #u ""["" + bte(g) + ""..."" + bte(c) + ""]"")\n#define arr(a, i) imie(a)[imie(i)]\n#define arr2(a, i, j) imie(a)[imie(i)][imie(j)]\n#define arr3(a, i, j, k) imie(a)[imie(i)][imie(j)][imie(k)]\n#define arr4(a, i, j, k, q) imie(a)[imie(i)][imie(j)][imie(k)][imie(q)]\nvector <stringstream> lif;struct prux {prux() {lif.EB();}~prux() {lif.pop_back();}};\n#define mark_stack(c...) udz(__LINE__,c)\n#define udz(a,b...) erf(a, b)\n#define erf(l,c...) prux _4IJ1MYUxZy2p_Q##l;lif.back()<<""\\033[1;""<<30+l%8<<""m[""<<__FUNCTION__<<\\\n  ""#""<<l<<""] \\033[""<<30+(l/8+l*3)%8<<""m"";siw(c)\nvoid siw(){};sim, class...N> void siw(T x, N...y) {lif.back() << x << ""; "";siw(y...);}\n#define print_stack() cerr << ""STACK_TRACE_FROM:"" << __FUNCTION__ << ""#"" << __LINE__<<endl,nfl()\n#define ckx(o) template<zub(o, o yyo(u), nep<N>) #o ""("" + bte(u) + "")"", u.m);}\nsim> struct tqaz{T a;int u,d,l,r;};sim> tqaz<T> zaqt(T a,int u,int d,int l,int r){return tqaz<T>{a,u,d,l,r};}\n#define matr(a,u,d,l,r) ngy(zaqt(a,yyo(u),yyo(d),yyo(l),yyo(r)), #a""[""+bte(u)+""...""+bte(d)+""][""+bte(l)+""...""+bte(r)+""]"")\n#define avc(f) sim>string f(tqaz<T> x){vector<vector<string>> t;FOR(i,x.u,x.d){t.EB();FOR(j,x.l,x.r)t.back().PB(f(x.a[i][j]));}\\\nstringstream o;VI M;FOR(j,x.l,x.r){int m=0;FOR(i,x.u,x.d)maxi(m, siz(t[i-x.u][j-x.l]));M.PB(m);}FOR(i,x.u,x.d){o<<""\\n\\t[""<<i<<""] "";\\\nFOR(j,x.l,x.r){REP(_, M[j-x.l]-siz(t[i-x.u][j-x.l]))o<<"" "";o<<t[i-x.u][j-x.l]<<((j+1)%5?"", "":""; "");}}ros.str() + ""\\n"";}\nvoid nfl() {for (auto &s : lif)cerr << ""  "" << s.str() << ""\\033[m"" << endl;} ckx(+) ckx(-) ckx(!) ckx(~) avc(bte) avc(ema)\nstruct zet_p {int o;LD v;zet_p(LL x=0):o(x%MOD),v(x){} zet_p(LL x, LD y):o(x%MOD),v(y){} int get(){ros>=0?o:o+MOD;}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o,v+a.v);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o,v-a.v);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o,v*a.v);}\n  zet_p operator/(zet_p a) {assert(a.o != 0); return zet_p(o*1ll*mpow(a.o, MOD-2),v/a.v);}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nostream&operator<<(ostream &o, zet_p u) {ros<<""[""<<u.o<<"" @ ""<<u.v<<""]"";}using frac_mod = zet_p;\n#else\nfalse;\nstruct zet_p {int o;int get(){ros>=0?o:o+MOD;}zet_p(LL x=0):o(x%MOD){}zet_p(int x):o(x%MOD){}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o);}\n  zet_p operator/(zet_p a) {return zet_p(o*1ll*mpow(a.o, MOD - 2));}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nstruct frac_mod {int o,m;int get(){return (o*1ll*mpow(m,MOD-2)%MOD+MOD)%MOD;}frac_mod(int x=0):o(x%MOD),m(1){}frac_mod(LL x):o(x%MOD),m(1){}\n  frac_mod(LL a,LL b):o(a),m(b){}\n  frac_mod operator+(frac_mod a){return frac_mod(o*1ll*a.m+m*1ll*a.o,m*a.m);}\n  frac_mod operator-(frac_mod a){return frac_mod(o*1ll*a.m-m*1ll*a.o,m*a.m);}\n  frac_mod operator*(frac_mod a){return frac_mod(o*1ll*a.o,m*1ll*a.m);}\n  frac_mod operator/(frac_mod a){return frac_mod(o*1ll*a.m,m*1ll*a.o);}\n  bool operator==(frac_mod a) {return (o * 1ll * a.m - m * 1ll * a.o) % MOD == 0;}};\nacv(frac_mod, +) acv(frac_mod, -) acv(frac_mod, *) acv(frac_mod, /)\n#define debug(...)\n#define mark_stack(...)\n#define print_stack(...)\n#endif\nacv(zet_p, +) acv(zet_p, -) acv(zet_p, *) acv(zet_p, /)\n#define nok(o,c,r,l...) auto operator o(c p, r y)-> decltype(MP(l)) {return MP(l);}\n#define pcg(o) sim, class S, class N, class H> nok(o, pair<S u T>, pair<H u N>, p.f o y.f, p.s o y.s)\\\nsim,class S,class N,class=typename enable_if<!is_base_of<ios_base,typename remove_reference<T>::type>::value>::type>nok\\\n(o,T,pair<S u N>, p o y.f, p o y.s) sim, class S, class N> nok(o, pair<S u N>, T, p.f o y, p.s o y)\n#define clp(r) pcg(r) sim, class S, class N, class H> \\\n\tpair <T,S> & operator r##=(pair <T,S> &p, pair<N,H> y) {p.f r##= y.f; p.s r##= y.s; return p;}\\\n\tsim, class S, class N> pair <T,S> &operator r##=(pair<T,S> &p, N y) {p.f r##= y; p.s r##= y; return p;}\n#define u ,\n#define syd(o) sim, class N> auto operator o(pair<T,N> e) -> decltype(MP(o e.f, o e.s)) {return MP(o e.f, o e.s);}\nclp(+) clp(-) clp(*) clp(/) clp(%) clp(^) clp(|) clp(>>) clp(<<) clp(&) pcg(&&) pcg(||) syd(-) syd(+) syd(~) syd(!)\n#undef u\nsim> int dud(T &, T&);sim> char dud(T x, ...);\n#define muf(c...) {\\\n\tsim, class N> static T c get1(pair <T, N> c o){ros.f;}\\\n\tsim, class N> static N c get2(pair <T, N> c o){ros.s;}\\\n\tsim, class N, class S> static T c get1(tri(T, N, S) c o){ros.f.f;}\\\n\tsim, class N, class S> static N c get2(tri(T, N, S) c o){ros.f.s;}\\\n\tsim, class N, class S> static S c get3(tri(T, N, S) c o){ros.s;}\\\n\tsim, class N, class S, class H> static S c get3(quadr(T, N, S, H) c o){ros.s.f;}\\\n\tsim, class N, class S, class H> static H c get4(quadr(T, N, S, H) c o){ros.s.s;}\\\n};\ntemplate <class X> struct qul muf()\ntemplate <> struct qul <int> muf(&)\n#define get1(o) qul<decltype(dud(o, o))>::get1(o)\n#define get2(o) qul<decltype(dud(o, o))>::get2(o)\n#define get3(o) qul<decltype(dud(o, o))>::get3(o)\n#define get4(o) qul<decltype(dud(o, o))>::get4(o)\nsim, class N> using gyv = T;\nnamespace std {sim, class N> struct hash<pair<T,N>>{size_t operator()(const pair<T,N>&u)const {\n      return hash<T>()(u.f) * 440624741ULL ^ hash<N>()(u.s);}};\n  sim> struct hash<gyv<T, decltype(((T*)0)->end())>> {size_t operator()(const T& u) const {size_t o = 505347433;\nfor (auto e : u)o = hash<urs(e)>()(e) ^ o * 277953755ULL;ros;}};}\n\nconst int MN = 1e6 + 44;\nvoid PdAYB7V() {\n\tprint_stack();\n\tdebug(imie(MN) * 1ll * imie(MOD), ""make sure it is right!!!!"");\n\tdebug(""make sure m, n aren\'t misused"");\n\tdebug(""long longs!!!!!!!!!!!!!!!!!!!"");\n\tdebug(""run with m, n = 1"");\n\tdebug(""make sure bounds on values aren\'t misused"");\n\tdebug(""Check time/memory limit"");\n\twhile (getchar() != EOF);\n\texit(0);\n}\nint main() {\n\t#ifdef DEB\n\tatexit(PdAYB7V);\n\t#endif\n\tint n, m;\n\tscanf(""%d%d"", &n, &m);\n\tLL msum = 0, Msum = 0;\n\tREP(i, n)\n\t\tMsum += i;\n\tREP(i, n)\n\t\tmsum += abs(i - n / 2);\n\tLL ans = 0;\n\tREP(i, m) {\n\t\tint x, d;\n\t\tscanf(""%d%d"", &x, &d);\n\t\tans += x * 1ll * n + max(d * msum, d * Msum);\n\t}\n\tprintf(""%.10Lf\\n"", ans / (LD) n);\n}\n\n\n']",,,"['greedy', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Annoying Present.json,https://codeforces.com/blog/entry/60630,Judging by constraints you can guess that the greedy approach is the right one Firstly let s transition from maximizing the arithmetic mean to the sum it s the same thing generally Secondly notice that each is being added to each element regardless of the chosen position Finally take a look at a function total sum obtained by applying change with to position and notice that it is non strictly convex Its maximum or minimum values can always be found in one of these positions method of rounding doesn t matter and Thus the solution will look like this for positive you apply the change to position and for non positive to position The impact of the change can be calculated with the formula of the sum of arithmetic progression Also you should either do all of your calculations in long double 10 byte type or maintain sum in long long you can estimate it with so it fits and divide it by in the end then double will work Overall complexity 
https://codeforces.com//contest/1364/problem/B,647243,B,1364B,1364,B. Most socially-distanced subsequence,Given a permutation p of length n find its subsequence s 1 s 2 ldots s k of length at least 2 such that s 1 s 2 s 2 s 3 ldots s k 1 s k is as big as possible over all subsequences of p with length at least 2 Among all such subsequences choose the one whose length k is as small as possible If multiple subsequences satisfy these conditions you are allowed to find any of them A sequence a is a subsequence of an array b if a can be obtained from b by deleting some possibly zero or all elements A permutation of length n is an array of length n in which every element from 1 to n occurs exactly once ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto &i : a) {\n      cin >> i;\n    }\n    int i = 0;\n    vector<int> res;\n    while (true) {\n      res.emplace_back(a[i]);\n      int j = i + 1;\n      if (j == n) {\n        break;\n      } else if (a[j] > a[i]) {\n        while (a[j] > a[j - 1] && j < n) {\n          j++;\n        }\n        i = j - 1;\n      } else {\n        while (a[j] < a[j - 1] && j < n) {\n          j++;\n        }\n        i = j - 1;\n      }\n    }\n    cout << res.size() << '\\n';\n    for (const auto &j : res) {\n      cout << j << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n""]",,,"['greedy', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Most socially-distanced subsequence.json,https://codeforces.com//blog/entry/78781,TL DR the answer contains the first element last element and all the local minima and maxima where a local minimum is an element less than its 2 adjacents and a local maximum is an element greater than it 2 adjacents Let s look at the expression in the problem for 3 numbers If and or if and so it s never optimal to use and in a row because you can use just and and achieve a shorter subsequence If you keep erasing your s from the original permutation you ll end up with the first element the last element and the local minima and maxima You can see that erasing any of them would decrease the expression so this is the optimal answer Code link https pastebin com e2HHuKFY 
https://codeforces.com//contest/1173/problem/B,355016,B,1173B,1173,B. Nauuo and Chess,Nauuo is a girl who loves playing chess One day she invented a game by herself which needs n chess pieces to play on a m times m chessboard The rows and columns are numbered from 1 to m We denote a cell on the intersection of the r th row and c th column as r c The game s goal is to place n chess pieces numbered from 1 to n on the chessboard the i th piece lies on r i c i while the following rule is satisfied for all pairs of pieces i and j r i r j c i c j ge i j Here x means the absolute value of x However Nauuo discovered that sometimes she couldn t find a solution because the chessboard was too small She wants to find the chessboard on which she can put n pieces according to the rules She also wonders how to place the pieces on such a chessboard Can you help her ,"['//2019.6.7 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n #define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<\'0\'||ch>\'9\')ch=gc();\n    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=gc();}\n//    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<\'0\'||ch>\'9\')ch=gc();\n//    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=gc();}\n//    while(ch>=\'0\'&&ch<=\'9\')s=s*10+ch-\'0\',ch=gc();\n//    return s*w;\n//}\n//inline void swap(res &x,res &y) {\n//    x^=y^=x^=y;\n//}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nnamespace MAIN {\n    int n;\n    inline void MAIN(){\n        n=read();\n        res m=1;\n        if(n==1){puts(""1"");puts(""1 1"");return;}\n        for(;(m-1)*2<(n-1);m++);\n        printf(""%d\\n"",m);\n        res dx=1,dy=1;\n        for(res i=1;i<=n;i++){\n            printf(""%d %d\\n"",dx,dy);\n            if(dy==m)dx++;\n            else dy++;\n        }\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n    // freopen(""zao.in"",""r"",stdin);\n    // freopen(""std.out"",""w"",stdout);\n    MAIN::MAIN();\n    return 0;\n}']",,,"['constructive algorithms', 'greedy']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Nauuo and Chess.json,https://codeforces.com//blog/entry/67511,Tutorial Consider the chess pieces and can be If we put the th piece on satisfying it is a feasible plan because 
https://codeforces.com//contest/1811/problem/E,1864327,E,1811E,1811,E. Living Sequence,In Japan the number 4 reads like death so Bob decided to build a a contains all natural numbers that do not contain the digit 4 a 1 2 3 5 6 7 8 9 10 11 12 13 15 16 ldots For example the number 1235 is part of the sequence a but the numbers 4321 443 are not part of the sequence a Bob realized that he does not know how to quickly search for a particular number by the position k in the sequence so he asks for your help For example if Bob wants to find the number at position k 4 indexing from 1 you need to answer a k 5 ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint64_t dp[19];\nint a[19];\n\nint64_t f(int i, bool smaller, bool pos) {\n  if (i < 0) {\n    return pos;\n  }\n  if (smaller && pos && dp[i] != -1) {\n    return dp[i];\n  }\n  int64_t ans = 0;\n  int lim = smaller ? 9 : a[i];\n  for (int d = 0; d <= lim; d++) {\n    if (d != 4) ans += f(i - 1, smaller || d < lim, pos || d > 0);\n  }\n  return smaller && pos ? dp[i] = ans : ans;\n}\n\nint64_t solve(int64_t x) {\n  int n = 0;\n  do {\n    a[n++] = x % 10;\n    x /= 10;\n  } while (x > 0);\n  return f(n - 1, 0, 0);\n}\n\nvoid solve() {\n  int64_t k;\n  cin >> k;\n  int64_t lo = 1, hi = 1e18;\n  int64_t ans = -1;\n  while (lo <= hi) {\n    int64_t mid = (lo + hi) / 2;\n//    cerr << mid << endl;\n    if (solve(mid) >= k) {\n      ans = mid;\n      hi = mid - 1;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  cout << ans << ""\\n"";\n}\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n  memset(dp, -1, sizeof(dp));\n  int tt; cin >> tt;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n']",,,"['binary search', 'dp', 'math', 'number theory']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Living Sequence.json,https://codeforces.com//blog/entry/114788,Note that any number in the sequence can be made up of possible digits all digits except Then let s find the first digit of the answer notice that it is just or where where the length of the number we re looking for and the maximum Note that simply corresponds to a digit in the base numeral system Why is this so Because without the first digit we can assemble any numbers with possible digits and we can put the digits except in the first place Thus in the answer the first digit will be if and if Note that once the first digit is determined the rest can be found the same way since the prefix does not affect anything 
https://codeforces.com//contest/1217/problem/D,404646,D,1217D,1217,D. Coloring Edges,You are given a directed graph with n vertices and m directed edges without self loops or multiple edges Let s denote the k coloring of a digraph as following you color each edge in one of k colors The k coloring is if and only if there no cycle formed by edges of same color Find a good k coloring of given digraph with minimum possible k ,"['#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/05, 23:56:24\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint deg[5001];\nvector<int> redge[5001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> ans;\n    for (int i = 1; i <= m; ++i) {\n        int x, y;\n        cin >> x >> y;\n        ans.push_back((x < y) + 1);\n        ++deg[x];\n        redge[y].push_back(x);\n    }\n    vector<int> st;\n    for (int i = 1; i <= n; ++i) {\n        if (deg[i] == 0) st.push_back(i);\n    }\n    for (int i = 0; i < st.size(); ++i) {\n        int x = st[i];\n        for (int j : redge[x]) {\n            if (--deg[j] == 0) st.push_back(j);\n        }\n    }\n    if (st.size() < n) {\n        printf(""2\\n"");\n        for (int i : ans) printf(""%d "", i);\n    }\n    else {\n        printf(""1\\n"");\n        for (int i = 0; i < m; ++i) printf(""1 "");\n    }\n    return 0;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'graphs']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Coloring Edges.json,https://codeforces.com//blog/entry/69605,Let s run dfs on the graph and color all back edges is back edge if there is a path from to by edges from dfs tree in black and all other edges in white It can be proven that any cycle will have at least one white edge and at least black edge Moreover each back edge connected with at least one cycle path from to and back edge So the coloring we got is exactly the answer How to prove that any cycle have at least one edge of both colors Let s look only at edges from dfs trees We can always renumerate vertices in such way that index of parent is bigger than the index of any its child We can process and assign with minimal free number after we processed all its children Now we can note that for any white edge not only tree edge condition holds because of properties of dfs forward edges are obvious cross edge becomes cross because dfs at first processed vertex and after that so And for each back edge it s true that Since any cycle have both and situations profit 
https://codeforces.com//contest/1660/problem/C,1349757,C,1660C,1660,C. Get an Even String,A string a a 1a 2 dots a n is called if it consists of a concatenation joining of strings of length 2 consisting of the same characters In other words a string a is even if two conditions are satisfied its length n is even for all odd i 1 le i le n 1 a i a i 1 is satisfied For example the following strings are even empty string and The following strings are not even and Given a string s consisting of lowercase Latin letters Find the minimum number of characters to remove from the string s to make it even The deleted characters do not have to be consecutive ,"[""#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  string s;\n  cin >> s;\n  vector<bool> used(26, false);\n  int ln = 0;\n  for (auto c : s) {\n    if (used[c - 'a']) {\n      ln++;\n      used.assign(26, false);\n    } else {\n      used[c - 'a'] = true;\n    }\n  }\n  cout << (int) s.size() - 2 * ln << '\\n';\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}""]",,,"['dp', 'greedy', 'strings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Get an Even String.json,https://codeforces.com//blog/entry/101526,We will act greedily we will make an array consisting of elements in which we will mark if the letter is already encountered in the string and otherwise In the variable we will store the length of the even string that can be obtained from We will go through the string by executing the following algorithm if mark if then we already have a pair of repeating characters to add to an even string add to the number and clear the array Clearing is necessary because both characters that will make up the next pair must be in the string after the current character In other words if the last character in the current pair was then the first character in the new pair can be where Then we calculate the answer as 
https://codeforces.com//contest/1547/problem/C,1041927,C,1547C,1547,C. Pair Programming,Monocarp and Polycarp are learning new programming techniques Now they decided to try pair programming It s known that they have worked together on the same file for n m minutes Every minute exactly one of them made one change to the file Before they started there were already k lines written in the file Every minute exactly one of them does one of two actions adds a new line to the end of the file or changes one of its lines Monocarp worked in total for n minutes and performed the sequence of actions a 1 a 2 dots a n If a i 0 then he adds a new line to the end of the file If a i 0 then he changes the line with the number a i Monocarp performed actions strictly in this order a 1 then a 2 a n Polycarp worked in total for m minutes and performed the sequence of actions b 1 b 2 dots b m If b j 0 then he adds a new line to the end of the file If b j 0 then he changes the line with the number b j Polycarp performed actions strictly in this order b 1 then b 2 b m Restore their common sequence of actions of length n m such that all actions would be correct there should be no changes to lines that do not yet exist Keep in mind that in the common sequence Monocarp s actions should form the subsequence a 1 a 2 dots a n and Polycarp s subsequence b 1 b 2 dots b m They can replace each other at the computer any number of times Let s look at an example Suppose k 3 Monocarp first changed the line with the number 2 and then added a new line thus n 2 a 2 0 Polycarp first added a new line and then changed the line with the number 5 thus m 2 b 0 5 Since the initial length of the file was 3 in order for Polycarp to change line number 5 two new lines must be added beforehand Examples of correct sequences of changes in this case would be 0 2 0 5 and 2 0 0 5 Changes 0 0 5 2 wrong order of actions and 0 5 2 0 line 5 cannot be edited yet are not correct ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int k, n, m;\n        cin >> k >> n >> m;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        int x = 0, y = 0;\n        vector<int> ans;\n        for (int z = 0; z < n + m; z++) {\n            if (x < n && a[x] == 0) {\n                ans.push_back(0);\n                x++;\n                k++;\n            } else if (y < m && b[y] == 0) {\n                ans.push_back(0);\n                y++;\n                k++;\n            } else if (y == m || (x < n && a[x] < b[y])) {\n                if (a[x] > k) {\n                    cout << ""-1\\n"";\n                    return;\n                }\n                ans.push_back(a[x++]);\n            } else {\n                if (b[y] > k) {\n                    cout << ""-1\\n"";\n                    return;\n                }\n                ans.push_back(b[y++]);\n            }\n        }\n        for (int i : ans) {\n            cout << i << "" "";\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']",,,"['greedy', 'two pointers']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Pair Programming.json,https://codeforces.com//blog/entry/92715,The solution is that if we can do something let s do it It doesn t make sense not to act because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future Therefore we will iterate over the actions and eagerly act Monocarp or Polycarp Let s create two pointers and in arrays and index of possible action of Monocarp and Polycarp and the current length of the file Suppose that or on current iteration Then we take the appropriate zero element and increase by one We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct Suppose that and If and then there is no answer because we can potentially do only two actions and both make the answer incorrect If one number is greater than and the other is less than or equals then we take the one that less than or equals If one of the sequences or ends then only one potential action needs to be checked at each iteration 
https://codeforces.com//contest/1929/problem/E,2478907,E,1929E,1929,E. Sasha and the Happy Tree Cutting,Sasha was given a tree dagger with n vertices as a prize for winning yet another competition However upon returning home after celebrating his victory he noticed that some parts of the tree were missing Sasha remembers that he colored some of the edges of this tree He is certain that for any of the k pairs of vertices a 1 b 1 ldots a k b k he colored at least one edge on the simple path ddagger between vertices a i and b i Sasha does not remember how many edges he exactly colored so he asks you to tell him the minimum number of edges he could have colored to satisfy the above condition dagger A tree is an undirected connected graph without cycles ddagger A simple path is a path that passes through each vertex at most once ,"['#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nvector<int>v[300005];\nint sy[45],cnt;\nint bu[25],bv[25],blc[25];\nint bz[300005][20];\nint dep[300005];\nint dfn[300005],siz[300005],tmp;\nint dp[1049576];\nvoid dfs(int x,int f)\n{\n\tdfn[x]=++tmp;\n\tsiz[x]=1;\n\tdep[x]=dep[f]+1;\n\tbz[x][0]=f;\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tbz[x][i]=bz[bz[x][i-1]][i-1];\t\n\t}\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==f)continue;\n\t\tdfs(v[x][i],x);\n\t\tsiz[x]+=siz[v[x][i]];\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dep[bz[x][i]]>=dep[y])x=bz[x][i];\n\t}\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(bz[x][i]!=bz[y][i])\n\t\t{\n\t\t\tx=bz[x][i];\n\t\t\ty=bz[y][i];\n\t\t}\n\t}\n\treturn bz[x][0];\n} \nint findzx(int x,int k)\n{\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(k>=(1<<i))\n\t\t{\n\t\t\tk-=(1<<i);\n\t\t\tx=bz[x][i];\n\t\t}\n\t}\n\treturn x;\n}\nint pd(int x,int y,int z)\n{\n\tint ans=0;\n\tif(dfn[x]>=dfn[z]&&dfn[x]<=dfn[z]+siz[z]-1)ans++;\n\tif(dfn[y]>=dfn[z]&&dfn[y]<=dfn[z]+siz[z]-1)ans++;\n\tif(ans==1)return true;\n\treturn false;\n}\nsigned main()\n{\n\tint t,n,k,x,y;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t\tcnt=0;\n\t\ttmp=0;\n\t\tdfs(1,0);\n\t\tk=read();\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tbu[i]=read();\n\t\t\tbv[i]=read();\n\t\t\tblc[i]=lca(bu[i],bv[i]);\t\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tif(bu[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bu[i],dep[bu[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0;\n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bv[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bv[i],dep[bv[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0; \n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(""%d\\n"",cnt);\n\t\t//for(int i=1;i<=cnt;i++)printf(""%d "",sy[i]);\n\t//\tprintf(""\\n"");\n\t\tfor(int i=0;i<(1<<k);i++)dp[i]=1000000000;\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<k);i++)\n\t\t{\n\t\t\tif(dp[i]==1000000000)continue;\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tdp[i|sy[j]]=min(dp[i|sy[j]],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",dp[(1<<k)-1]);\n\t}\n}\n']",,,"['bitmasks', 'brute force', 'dfs and similar', 'dp', 'graphs', 'greedy', 'math', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Sasha and the Happy Tree Cutting.json,https://codeforces.com//blog/entry/125943,Let s consider each edge i and mark the set of pairs Si that it covers Then the claim is we have a total of O k different sets This is because we are only interested in the edges that are present in the compressed tree on these k pairs of vertices And as it is known the number of edges in the compressed tree is O k Then we need to find the minimum number of sets among these sets such that each pair is present in at least one of them This can be achieved by dynamic programming on sets as follows Let dp mask be the minimum number of edges that need to be removed in order for at least one edge to be removed among the pairs corresponding to the individual set bits in mask Then the update is as follows dp mask Si min dp mask Si dp mask 1 for all distinct sets S where Si is the mask corresponding to the pairs passing through the edge This update is performed because we are adding one more edge to this mask As a result we obtain a solution with a time complexity of O nk 2kk where O nk is for precomputing the set of pairs removed by each edge for each edge and O 2kk is for updating the dynamic programming 
https://codeforces.com//contest/137/problem/C,723,C,137C,137,C. History,Polycarpus likes studying at school a lot and he is always diligent about his homework Polycarpus has never had any problems with natural sciences as his great great grandfather was the great physicist Seinstein On the other hand though Polycarpus has never had an easy time with history Everybody knows that the World history encompasses exactly events the th event had continued from the year to the year inclusive Polycarpus easily learned the dates when each of events started and ended Polycarpus inherited excellent memory from his great great granddad But the teacher gave him a more complicated task Polycaprus should know when all events began and ended and he should also find out for each event whether it includes another event Polycarpus teacher thinks that an event includes an event if and Your task is simpler find the number of events that are included in some other event ,"['#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nint n;\nPII a[100000];\n\nint main(){\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++) scanf(""%d%d"",&a[i].first,&a[i].second);\n    sort(a,a+n);\n    int far=0,ans=0;\n    for(int i=0;i<n;i++){\n        if(a[i].second<=far) ans++;\n        far=max(far,a[i].second);\n    }\n    printf(""%d\\n"",ans);\n}\n']",,,['sortings'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. History.json,https://codeforces.com//blog/entry/3318,Denote a i b i ends of the i th event Let s sort pairs a i b i by a i and iterate over all pairs Denote rg the maximal b i from already processed If current b i rg than we must increment answer by one If b i rg than we must assign rg by b i The complexity is O n logn 
https://codeforces.com//contest/1684/problem/C,1404373,C,1684C,1684,C. Column Swapping,You are given a grid with n rows and m columns where each cell has a positive integer written on it Let s call a grid if in each row the sequence of numbers is sorted in a non decreasing order It means that for each 1 le i le n and 2 le j le m the following holds a i j ge a i j 1 You have to to do the following operation exactly once choose two columns with indexes i and j 1 le i j le m and swap them You are asked to determine whether it is possible to make the grid good after the swap and if it is find the columns that need to be swapped ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 18:38:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> a(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> a[i][j];\n      }\n    }\n    int x = -1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        if (a[i][j] > a[i][j + 1]) {\n          x = j;\n        }\n      }\n    }\n    if (x == -1) {\n      cout << ""1 1"" << endl;\n      continue;\n    }\n    auto Flag = [&](int i, int j) {\n      if (i >= 0 && j >= 0 && i < h && j < w - 1 && a[i][j] > a[i][j + 1]) {\n        return 1;\n      }\n      return 0;\n    };\n    vector<int> cnt(h);\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        cnt[i] += Flag(i, j);\n      }\n    }\n    int a0 = -1, a1 = -1;\n    for (int j0 = x; j0 <= x + 1; j0++) {\n      for (int j1 = 0; j1 < w; j1++) {\n        if (j0 == j1) {\n          continue;\n        }\n        bool inv = false;\n        if (j0 > j1) {\n          swap(j0, j1);\n          inv = true;\n        }\n        bool ok = true;\n        for (int i = 0; i < h; i++) {\n          int cc = cnt[i];\n          if (j0 + 1 == j1) {\n            cc -= Flag(i, j0 - 1);\n            cc -= Flag(i, j0);\n            cc -= Flag(i, j0 + 1);\n            swap(a[i][j0], a[i][j1]);\n            cc += Flag(i, j0 - 1);\n            cc += Flag(i, j0);\n            cc += Flag(i, j0 + 1);\n            swap(a[i][j0], a[i][j1]);\n          } else {\n            cc -= Flag(i, j0 - 1);\n            cc -= Flag(i, j0);\n            cc -= Flag(i, j1 - 1);\n            cc -= Flag(i, j1);\n            swap(a[i][j0], a[i][j1]);\n            cc += Flag(i, j0 - 1);\n            cc += Flag(i, j0);\n            cc += Flag(i, j1 - 1);\n            cc += Flag(i, j1);\n            swap(a[i][j0], a[i][j1]);\n          }\n          assert(cc >= 0);\n          if (cc > 0) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) {\n          a0 = j0;\n          a1 = j1;\n        }\n        if (inv) {\n          swap(j0, j1);\n        }\n      }\n    }\n    if (a0 == -1) {\n      cout << -1 << \'\\n\';\n    } else {\n      cout << a0 + 1 << "" "" << a1 + 1 << \'\\n\';\n    }\n  }\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy', 'implementation', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Column Swapping.json,https://codeforces.com//blog/entry/102995,At first let s check wether the given table is good If it is not then there is a row that has elements that should be replaced Let s say that this row is and is the sorted row Then let s find the set of positions that If there are at least such positions then the answer is because by making a swap we remove at most such bad positions If there are no more than such positions then let s swap the corresponding columns and check whether each row is sorted If the table is good we found the answer If it is not then the answer is because we can not sort and get a good table after that 
https://codeforces.com//contest/1363/problem/A,636623,A,1363A,1363,A. Odd Selection,Shubham has an array a of size n and wants to select exactly x elements from it such that their sum is odd These elements do not have to be consecutive The elements of the array are not guaranteed to be distinct Tell him whether he can do so ,"['#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << "" : "" << x << \'\\n\'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 2e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll cnt[2];\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll T;\n\tcin >> T;\n\tfor(int i = 0; i < T; i++){\n\t\tmemset(cnt, 0, sizeof cnt);\n\t\tll n, x, v;\n\t\tcin >> n >> x;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> v;\n\t\t\tcnt[v & 1] ++;\n\t\t}\n\t\tif(x == n) cout << (cnt[1] & 1 ? ""Yes"" : ""No"") << \'\\n\';\n\t\telse {\n\t\t\tif(min(cnt[0], cnt[1]) > 0) cout << ""Yes"" << \'\\n\';\n\t\t\telse if(cnt[0]) cout << ""No\\n"";\n\t\t\telse cout << (x & 1 ? ""Yes"" : ""No"") << \'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Odd Selection.json,https://codeforces.com//blog/entry/78202, The sum of numbers can only be odd if we have an odd number of numbers which are odd An odd statement indeed We first maintain two variables and representing the number of odd and even numbers in the array respectively We then iterate over the number of odd numbers we can choose which are upto and see if where is the number of odd numbers we have chosen 
https://codeforces.com//contest/1989/problem/D,2721697,D,1989D,1989,D. Smithing Skill,You are playing a famous computer game that just works where you have various skills you can level up Today you focused on the Smithing skill Your tactic is obvious forging weapons from ingots and then melting them back to return the materials partially For simplicity every time you create an item you get 1 experience point and every time you melt an item you also get 1 experience point There are n classes of weapons you can forge and m types of metal ingots You can create one weapon of the i th class spending a i ingots of metal of Melting a weapon of the i th class which you crafted earlier returns you b i ingots of the type of metal You have c j metal ingots of the j th type and you know that you can craft a weapon of any class from any metal type Each combination of a weapon class and a metal type can be used any number of times What is the maximum total amount of experience you can earn by crafting and melting weapons ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    int n,m; cin >> n >> m;    vc<pii> a(n);    rep(n) cin >> a[i].first;    rep(n) cin >> a[i].second,a[i].second=a[i].first-a[i].second;    sort(all(a));    vc<pii> b;    for(auto &[x,y]: a){        if(sz(b)&&y>=b.back().second) continue;        b.pb({x,y});    }    vi dp(1000005);    int cur=0;    rep(i,1,sz(dp)){        while(cur+1<sz(b)&&b[cur+1].first<=i) cur++;        if(b[cur].first<=i){            dp[i]=dp[i-b[cur].second]+1;        }    }    ll res=0;    rep(_,m){        ll x; cin >> x;        if(x>=sz(dp)){            ll y=(x-sz(dp)+1+b.back().second-1)/b.back().second;            res+=y;            x-=y*b.back().second;        }        if(x>=0) res+=dp[x];    }    print(res*2);}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}']",,,"['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Smithing Skill.json,https://codeforces.com/blog/entry/130988,It s quite obvious that we should melt every weapon we forge and we can do it as soon as we forge it So let s do these actions in pairs forge a weapon then instantly melt it Since you can t use two types of metal while forging one weapon we can solve our task independently for each metal type Suppose you have x ingots of the chosen metal You can act greedily you can forge only weapons of classes with ai x but among them it s optimal to chose one that makes us lose the minimum number of ingots by forging it and melting it so we need to minimize the value of ai bi However this greedy solution is too slow when implemented naively Let s define A maxai and look at two cases x A or x A If x A let s just precalculate answers ans x for all x from 0 to A To do so let s precalculate another value best x as the minimum ai bi among all classes i where ai x In other words best x will be equal to the minimum amount of ingots you ll lose if you have x ingots and you need to forge melt one weapon We can precalculate best x in two steps for each class i we can set best ai min best ai ai bi using approach similar to prefix minima or dynamic programming we can also update best x min best x best x 1 for all x from 1 to A Using the array best we can calculate ans easily with dynamic programming ans x 2 ans x best x for all x from 1 to A In case x A we can forge melt a weapon with minimum ai bi as many times as we can until x A Once x becomes less or equal to A we can take the value ans x and finish processing that metal type Knowing that the minimum ai bi is just best A we can reformulate our first step as finding minimum k such that x k best A A or k x Abest A In other words we ll make the first step exactly k x Abest A times So we can calculate the final answer as 2k ans x k best A As a result we run precalculating in O n A time and process each metal type in O 1 time The total complexity is O n m A time and space 
https://codeforces.com//contest/1038/problem/C,216023,C,1038C,1038,C. Gambling,Two players A and B have a list of n integers each They both want to maximize the subtraction between their score and their opponent s score In one turn a player can either add to his score any element from his list assuming his list is not empty the element is removed from the list afterward Or remove an element from his opponent s list assuming his opponent s list is not empty Note that in case there are equal elements in the list only one of them will be affected in the operations above For example if there are elements 1 2 2 3 in a list and you decided to choose 2 for the next turn only a single instance of 2 will be deleted and added to the score if necessary The player A starts the game and the game stops when both lists are empty Find the difference between A s score and B s score at the end of the game if both of the players are playing optimally Optimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves In this problem it means that each player each time makes a move which maximizes the final difference between his score and his opponent s score knowing that the opponent is doing the same ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(""%lld"", &x); return x;}\nvoid read(char *s){scanf(""%s"", s);}\nvoid no(){printf(""No""); exit(0);}\n\n#define maxn 120000\n#define maxm\n\nmultiset<LL, greater<int> > a, b;\n\nint main(){\n\tLL ans = 0;\n\tint n = read();\n\tfor(int i = 0; i < n; i += 1) a.insert(read());\n\tfor(int i = 0; i < n; i += 1) b.insert(read());\n\tfor(int i = 0; i < n; i += 1){\n\t\tif(a.empty()) b.erase(b.begin());\n\t\telse{\n\t\t\tif(b.empty()){\n\t\t\t\tans += *a.begin();\n\t\t\t\ta.erase(a.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(*a.begin() < *b.begin()) b.erase(b.begin());\n\t\t\t\telse{\n\t\t\t\t\tans += *a.begin();\n\t\t\t\t\ta.erase(a.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(b.empty()) a.erase(a.begin());\n\t\telse{\n\t\t\tif(a.empty()){\n\t\t\t\tans -= *b.begin();\n\t\t\t\tb.erase(b.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(*b.begin() < *a.begin()) a.erase(a.begin());\n\t\t\t\telse{\n\t\t\t\t\tans -= *b.begin();\n\t\t\t\t\tb.erase(b.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"", ans);\n}']",,,"['greedy', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Gambling.json,https://codeforces.com/blog/entry/61692,This problem was greedy First it is obvious that both the players will try to either take their own maximum value or remove the opponent s maximum value Hence the arrays should be sorted and two pointers should be maintained to keep track of how many elements from each array have been counted removed already In every move if the person has a choice to either take his own value or remove his opponent s value then he will make the choice dependent on the values of and In fact it turns out that it is optimal just to select the choice with a greater number in case of tie any will do How to prove it One can show by induction that it does the same as the dynamic programming of size However there is a more nice way Let s say that initially each player gets of all numbers in his list This way when you choose a number from your own list you add the rest of it to the score And when you remove the number from opponent s list you remove the of it from your opponent s score Clearly all moves become symmetrical to both players now So each player can make a decision just based on which of the moves is greater If then he will take his number If he will discard the opponent s number If he can make either of the above moves it will not make a difference Complexity 
https://codeforces.com//contest/2028/problem/A,3015765,A,2028A,2028,A. Alice s Adventures in  Chess ,Alice is trying to meet up with the Red Queen in the countryside Right now Alice is at position 0 0 and the Red Queen is at position a b Alice can only move in the four cardinal directions north east south west More formally if Alice is at the point x y she will do one of the following go north represented by moving to x y 1 go east represented by moving to x 1 y go south represented by moving to x y 1 or go west represented by moving to x 1 y Alice s movements are predetermined She has a string s representing a sequence of moves that she performs from left to right Once she reaches the end of the sequence she repeats the same pattern of moves forever Can you help Alice figure out if she will ever meet the Red Queen ,"['#include<bits/stdc++.h>#define ll long longusing namespace std;long long read(){    long long x=0,f=1;char ch=getchar();    while(!isdigit(ch))    {if(ch==\'-\') f=-1;ch=getchar();}    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}    return x*f;}void write(long long x){    if(x<0) putchar(\'-\'),x=-x;    if(x>9) write(x/10);    putchar(x%10+\'0\');}const int N=2e5+10;int T,n;int a,b;char s[N];int main(){    //freopen("".in"",""r"",stdin);    //freopen("".out"",""w"",stdout);    T=read();    while(T--){        n=read();        cin>>a>>b;        int x=0,y=0;        bool fl=0;        if(x==a&&y==b)fl=1;                for(int i=1;i<=n;i++){            cin>>s[i];        }        for(int i=1;i<=1000;i++){            for(int j=1;j<=n;j++){                if(s[j]==\'N\')y++;                if(s[j]==\'S\')y--;                if(s[j]==\'E\')x++;                if(s[j]==\'W\')x--;                if(x==a&&y==b)fl=1;            }        }        if(fl)puts(""YES"");        else puts(""NO"");    }    return 0;}']",,,"['brute force', 'implementation', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Alice s Adventures in  Chess .json,https://codeforces.com//blog/entry/136096,We can run the whole pattern times which gives a total runtime of be careful in that running the pattern only 10 times is not enough To prove that repeats suffices suppose that Alice s steps on the first run of the pattern are we will take for convenience Then Alice ends up at position if there exists a the number of extra repeats such that for some and Certainly if we only need one repeat so assume WLOG that Then it must be the case that However since and so and therefore repeats always suffice In fact the above proof shows that we can solve each testcase in time 
https://codeforces.com//contest/95/problem/A,497,A,95A,95,A. Hockey,Petya loves hockey very much One day as he was watching a hockey match he fell asleep Petya dreamt of being appointed to change a hockey team s name Thus Petya was given the original team name and the collection of forbidden substrings All those strings consist of uppercase and lowercase Latin letters String has the length of its characters are numbered from to First Petya should find all the occurrences of forbidden substrings in the string During the search of substrings the case of letter shouldn t be taken into consideration That is strings and are considered equal After that Petya should perform the replacement of all letters covered by the occurrences More formally a letter in the position should be replaced by any other one if for position in string there exist pair of indices such that substring is contained in the collection when using case insensitive comparison During the replacement the letter s case should remain the same Petya is not allowed to replace the letters that aren t covered by any forbidden substring Letter uppercase or lowercase is considered lucky for the hockey players That s why Petya should perform the changes so that the occurred in the resulting string as many times as possible Help Petya to find such resulting string If there are several such strings find the one that comes first lexicographically Note that the process of replacements is not repeated it occurs only once That is if after Petya s replacements the string started to contain new occurrences of bad substrings Petya pays no attention to them ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1000+10;\nchar st[maxn],c[maxn];\nchar b[maxn][maxn];\nint n;\nbool flag[maxn];\n\nbool cmp(int a,int b,char s1[],char s2[],int n)\n{\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tchar c1=s1[a+i];\n\t\tif (c1>=\'A\' && c1<=\'Z\') c1=c1-\'A\'+\'a\';\n\t\tchar c2=s2[b+i];\n\t\tif (c2>=\'A\' && c2<=\'Z\') c2=c2-\'A\'+\'a\';\n\t\tif (c1!=c2) return 0;\n\t}\n\t//if (s1[a+i]!=s2[b+i]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor (int i=0;i<n;i++) scanf(""%s"",b[i]);\n\tscanf(""%s"",st);\n\tscanf(""%s"",c);\n\n\tfor (int i=0;st[i];i++)\n\t{\n\t\tbool ok=0;\n\t\tfor (int k=0;!ok && k<n;k++)\n\t\t{\n\t\t\tint len=strlen(b[k]);\n\t\t\tfor (int j=0;!ok && j<=i;j++)\n\t\t\tif (j+len-1>=i)\n\t\t\t\tok|=cmp(j,0,st,b[k],len);\n\t\t}\n\t\tflag[i]=ok;\n\t}\n\t\n\tif (c[0]>=\'a\'&& c[0]<=\'z\')c[0]=c[0]-\'a\'+\'A\';\n\n\tfor (int i=0;st[i];i++)\n\n\t\tif (flag[i])\n\t\t{\n\t\t\tif (st[i]>=\'A\' && st[i]<=\'Z\')\n\t\t\t{\n\t\t\t\tif (st[i]==c[0])\n\t\t\t\t{\n\t\t\t\t\tif (st[i]==\'A\') st[i]=\'B\';\n\t\t\t\t\telse st[i]=\'A\';\n\t\t\t\t} else st[i]=c[0];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (st[i]==c[0]-\'A\'+\'a\')\n\t\t\t\t{\n\t\t\t\t\tif (st[i]==\'a\') st[i]=\'b\';\n\t\t\t\t\telse st[i]=\'a\';\n\t\t\t\t} else st[i]=c[0]-\'A\'+\'a\';\n\t\t\t} \n\t\t}\n\t\n\tprintf(""%s"",st);\n}\n\t\t']",,,"['implementation', 'strings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Hockey.json,https://codeforces.com//blog/entry/2257,Let B i true if character in position i is in some substring of W which is in dictionary For each B i true do next If S i letter and letter a then S i b If S i letter and letter a then S i a If S i letter then S i letter 
https://codeforces.com//contest/805/problem/B,105167,B,805B,805,B. 3-palindrome,In the beginning of the new year Keivan decided to reverse his name He doesn t like palindromes so he changed Naviek to Navick He is too selfish so for a given he wants to obtain a string of characters each of which is either or with no of length appearing in the string as a substring For example the strings and suit him while the string doesn t He also want the number of letters in his string to be as little as possible ,"[""#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <bitset>\n#define fi first\n#define se second\n#define mkp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define per(i,b,a) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,a,b) for (int i=(a);i<=(b);i++)\n#define PER(i,b,a) for (int i=(b);i>=(a);i--)\nusing namespace std;\ntypedef long long LL;\n\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 1000005; // 1e6;\nint n;\nint main()\n{\n        cin>>n;\n        rep(i,0,n)\n        {\n                if (i%4==0) cout<<'a';\n                else if (i%4==1) cout<<'a';\n                else if (i%4==2) cout<<'b';\n                else if (i%4==3) cout<<'b';\n//                else cout<<'c';\n        }\n        cout<<endl;\n}\n""]",,,['constructive algorithms'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. 3-palindrome.json,https://codeforces.com//blog/entry/51846,The answer is constructive as follows It is obvious there is no palindrome as substring and the number of characters is minimum possible equal to zero 
https://codeforces.com//contest/1694/problem/B,1430895,B,1694B,1694,B. Paranoid String,Let s call a binary string T of length m indexed from 1 to m if we can obtain a string of length 1 by performing the following two kinds of operations m 1 times in any order Select any substring of T that is equal to and then replace it with Select any substring of T that is equal to and then replace it with For example if T we can select the substring T 2T 3 and perform the first operation So we obtain T You are given a binary string S of length n indexed from 1 to n Find the number of pairs of integers l r 1 le l le r le n such that S l ldots r the substring of S from l to r is a string ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename Fun>\nstruct y_combinator {\n    const Fun fun;\n\n    explicit y_combinator(const Fun&& fun) : fun(std::forward<const Fun>(fun)) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) const {\n        return fun(std::ref(*this), std::forward<Args>(args)...);\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    long long ans = n;\n    for (int i = 1; i < n; ++i) {\n        if (s[i] != s[i - 1]) {\n            ans += i;\n        }\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n""]",,,"['constructive algorithms', 'greedy']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Paranoid String.json,https://codeforces.com//blog/entry/103952,We want to show that a binary string of length is if and only if or and In the case of We can never delete the last two characters because they will always remain equal So is not In the case of If we can reach our goal by one operation Otherwise assume that the last character is Now the last three characters are either or In the first case perform the operation on and in the second case perform the operation on Then the last two characters will be and we can continue this algorithm on the new string until we reach The number of substrings of length is equal to To count the number of longer substrings we can fix from index to if holds we should add to the answer complexity 
https://codeforces.com//contest/1455/problem/G,815720,G,1455G,1455,G. Forbidden Value,Polycarp is editing a complicated computer program First variable x is declared and assigned to 0 Then there are instructions of two types assign x a value y or spend v burles to remove that instruction thus not reassign x block execute instructions inside the block if the value of x is y and ignore the block otherwise blocks can contain instructions and other blocks inside them However when the value of x gets assigned to s the computer breaks and immediately catches fire Polycarp wants to prevent that from happening and spend as few burles as possible What is the minimum amount of burles he can spend on removing instructions to never assign x to s ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int64_t INF64 = int64_t(2e18) + 5;\n\nstruct DP_DS {\n    map<int, int64_t> dp;\n    set<pair<int64_t, int>> values;\n    int64_t offset = 0;\n\n    void add_all(int64_t delta) {\n        offset += delta;\n    }\n\n    bool contains(int x) const {\n        return dp.count(x);\n    }\n\n    int64_t get(int x) const {\n        return !contains(x) ? INF64 : dp.at(x) + offset;\n    }\n\n    int64_t pop(int x) {\n        if (!contains(x))\n            return INF64;\n\n        int64_t dp_value = dp[x];\n        dp.erase(x);\n        values.erase({dp_value, x});\n        return dp_value + offset;\n    }\n\n    void add_option(int x, int64_t cost) {\n        if (contains(x))\n            cost = min(cost, pop(x));\n\n        cost -= offset;\n        dp[x] = cost;\n        values.emplace(cost, x);\n    }\n\n    int64_t get_min() const {\n        return values.begin()->first + offset;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, BAD;\n    cin >> N >> BAD;\n    vector<DP_DS> dp_stack(1);\n    dp_stack[0].add_option(0, 0);\n\n    for (int i = 0; i < N; i++) {\n        string instruction;\n        cin >> instruction;\n\n        if (instruction == ""set"") {\n            int y, v;\n            cin >> y >> v;\n\n            if (y == BAD) {\n                dp_stack.back().add_all(v);\n            } else {\n                int64_t minimum = dp_stack.back().get_min();\n                dp_stack.back().add_all(v);\n                dp_stack.back().add_option(y, minimum);\n            }\n        } else if (instruction == ""if"") {\n            int y;\n            cin >> y;\n            int64_t cost = dp_stack.back().pop(y);\n            dp_stack.emplace_back();\n            dp_stack.back().add_option(y, cost);\n        } else if (instruction == ""end"") {\n            DP_DS &back = dp_stack.back();\n            DP_DS &second = dp_stack[dp_stack.size() - 2];\n\n            if (back.dp.size() > second.dp.size())\n                swap(back, second);\n\n            for (auto &pr : back.dp)\n                second.add_option(pr.first, back.get(pr.first));\n\n            dp_stack.pop_back();\n        } else {\n            assert(false);\n        }\n    }\n\n    assert(dp_stack.size() == 1);\n    cout << dp_stack[0].get_min() << \'\\n\';\n}\n']",,,"['data structures', 'dp']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Forbidden Value.json,https://codeforces.com//blog/entry/85186,Consider the following dynamic programming the minimum cost to make have value after the th line The transitions here are pretty easy on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value There are a lot of possible values so that dp works in First let s notice that all the values that don t appear in the input won t matter so you can keep only the existing values in the dp Next let s consider the following modification to it What happens when you enter an if block It s actually the same dp but the only starting value is not with cost as in the beginning of the whole program but some value with some cost So let s calculate this dp separately from the outer one and just merge the values together Notice that if some value doesn t appear inside the if block then its cost can not decrease exiting out of it Thus it s enough to calculate the inner dp only for values that appear inside the if block Okay the transitions for if became easier The set transitions are still slow though Examine the nature of them All the values besides the written on the set instruction increase their cost by As for the its cost becomes equal to the cost of the cheapest value before the instruction Thus let s maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements That can be done with a set and a single integer that stores the current shift that should be applied to all elements Surely you ll also need a map to retrieve the current cost of particular values The final part is fast merging of the if block dp and the outer one It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become in total So we can apply small to large and swap these dp s based on their sizes Overall complexity 
https://codeforces.com//contest/1973/problem/B,2652011,B,1973B,1973,"B. Cat, Fox and the Lonely Array",Today Cat and Fox found an array a consisting of n non negative integers Define the of a as the positive integer k 1 le k le n such that for any two positive integers i and j 1 leq i j leq n k 1 the following holds a i a i 1 ldots a i k 1 a j a j 1 ldots a j k 1 where x y denotes the bitwise OR of x and y In other words for every k consecutive elements their bitwise OR should be the same Note that the loneliness of a is well defined because for k n the condition is satisfied Cat and Fox want to know how lonely the array a is Help them calculate the loneliness of the found array ,"['#include<bits/stdc++.h>using namespace std;int n,a[101000],t[20];bool chk(int e){    memset(t,0,sizeof(t));    int oz=-1;    for(int i=1;i<=n;i++){        for(int j=0;j<20;j++)if((a[i]>>j)&1)t[j]++;        if(i>e){for(int j=0;j<20;j++)if((a[i-e]>>j)&1)t[j]--;}        if(i>=e){            int z=0;            for(int j=0;j<20;j++)if(t[j])z|=(1<<j);            if(oz!=-1&&oz!=z)return 0;            oz=z;        }    }    return 1;}int main(){    int T;scanf(""%d"",&T);while(T--){        scanf(""%d"",&n);for(int i=1;i<=n;i++)scanf(""%d"",&a[i]);        int l=1,r=n,jx=n;while(l<=r){            int mi=(l+r)>>1;            if(chk(mi))jx=mi,r=mi-1;            else l=mi+1;        }        printf(""%d\\n"",jx);    }    return 0;}']",,,"['binary search', 'bitmasks', 'data structures', 'greedy', 'math', 'two pointers']",1300,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Cat, Fox and the Lonely Array.json",https://codeforces.com//blog/entry/129556,Definition We will say that the array is lonely if is true for any two positive integers Let be the maximum value an element in array can have 
https://codeforces.com//contest/1555/problem/C,1062142,C,1555C,1555,C. Coin Rows,Alice and Bob are playing a game on a matrix consisting of 2 rows and m columns The cell in the i th row in the j th column contains a i j coins in it Initially both Alice and Bob are standing in a cell 1 1 They are going to perform a sequence of moves to reach a cell 2 m The possible moves are Move right from some cell x y to x y 1 Move down from some cell x y to x 1 y First Alice makes until she reaches 2 m She collects the coins in all cells she visit including the starting cell When Alice finishes Bob starts his journey He also performs the moves to reach 2 m and collects the coins in all cells that he visited The score of the game is the total number of coins Bob collects Alice wants to minimize the score Bob wants to maximize the score What will the score of the game be if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<int>> a(2, vector<int>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> a[j][k];\n      }\n    }\n    vector<int> S1(m + 1);\n    S1[m] = 0;\n    for (int j = m - 1; j >= 0; j--){\n      S1[j] = S1[j + 1] + a[0][j];\n    }\n    vector<int> S2(m + 1);\n    S2[0] = 0;\n    for (int j = 0; j < m; j++){\n      S2[j + 1] = S2[j] + a[1][j];\n    }\n    int ans = INF;\n    for (int j = 0; j < m; j++){\n      ans = min(ans, max(S1[j + 1], S2[j]));\n    }\n    cout << ans << endl;\n  }\n}']",,,"['brute force', 'constructive algorithms', 'dp', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Coin Rows.json,https://codeforces.com//blog/entry/93389,First observe that each of the players has only options for their path which column to go down in Let s consider a Bob s response to a strategy chosen by Alice The easiest way to approach that is to look at the picture of the Alice s path The path clearly separates the field into two independent pieces suffix of the first row and the prefix of the second row Bob can t grab the coins from both of them at once However he can grab either of them fully So the optimal path for him will be one of these two options You can precalculate some prefix sums and become able to get the Bob s score given the Alice s path Alice has possibly paths so you can iterate over them and choose the minimum answer However prefix sums are not required since you can quickly recalculate both needed sums while iterating over the Alice s column to go down in Overall complexity per testcase 
https://codeforces.com//contest/1750/problem/B,1626958,B,1750B,1750,B. Maximum Substring,A binary string is a string consisting only of the characters and You are given a binary string s For some non empty substring dagger t of string s containing x characters and y characters define its as x cdot y if x 0 and y 0 x 2 if x 0 and y 0 y 2 if x 0 and y 0 Given a binary string s of length n find the maximum cost across all its non empty substrings dagger A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tints(N);\n\tstr S;\n\tre(S);\n\tvl len;\n\tfor (int i = 0; i < sz(S);) {\n\t\tint j = i;\n\t\twhile (i < sz(S) && S.at(i) == S.at(j)) ++i;\n\t\tlen.pb(i - j);\n\t}\n\tll ans = 0;\n\teach(t, len) ckmax(ans, t * t);\n\tAR<ll, 2> tot{};\n\tF0R(i, sz(len)) { tot[i % 2] += len[i]; }\n\tckmax(ans, tot[0] * tot[1]);\n\t// F0R(i,sz(len)-1) ckmax(ans,(len[i]+len[i+2])*len[i])\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']",,,"['brute force', 'greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Maximum Substring.json,https://codeforces.com//blog/entry/108504,SolutionConsidering that if we want to find the max value of then the whole string is the best to calculate for it s and s are the max Then considering and what we need to do is to calculate the max continuous number of or compare its square to the first condition then take the bigger one as the answer 
https://codeforces.com//contest/1748/problem/C,1632965,C,1748C,1748,C. Zero-Sum Prefixes,The of an array v 1 v 2 ldots v n is defined as the number of indices i 1 le i le n such that v 1 v 2 ldots v i 0 You are given an array a 1 a 2 ldots a n of length n You can perform the following operation multiple times select an index i 1 le i le n such that a i 0 then replace a i by an arbitrary integer What is the maximum possible score of a that can be obtained by performing a sequence of such operations ,"['# include <cstdlib>\n# include <cstring>\n# include <map>\n# include <algorithm>\n# include <cstdio>\n\nnamespace khin {\n  using namespace std;\n  namespace main {\n    inline namespace source {\n      typedef unsigned long int ulong;\n      typedef unsigned short int ushort;\n      typedef unsigned int uint;\n    }\n    namespace c { void main(); }\n  }\n}\n\nint main() { khin::main::c::main(); }\n\nnamespace khin::main::c {\n  namespace test_case {\n    constexpr uint n_max(200\'000);\n    uint n; int a[n_max + 2]; long long int s[n_max + 1];\n    void main() {\n      scanf(""%u"", &n);\n      for (uint i(1); i <= n; ++i) scanf(""%d"", &a[i]);\n      uint ans(0);\n      for (uint i(0), j(0); i <= n; i = j) {\n        while (a[++j]);\n        s[i] = 0;\n        for (uint k(i + 1); k < j; ++k) s[k] = s[k - 1] + a[k];\n        if (i) {\n          map<long long int, uint> cnt; uint res(0);\n          for (uint k(i); k < j; ++k) res = max(res, ++cnt[s[k]]);\n          ans += res;\n        } else ans += count(s + 1, s + j, 0);\n      }\n      printf(""%u\\n"", ans);\n      memset(a + 1, 0x00, n * sizeof(int));\n    }\n  }\n  void main() {\n    ushort t;\n    scanf(""%hu"", &t);\n    while (test_case::main(), --t);\n  }\n}']",,,"['brute force', 'data structures', 'dp', 'greedy', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Zero-Sum Prefixes.json,https://codeforces.com//blog/entry/108319,SolutionLet s consider the prefix sum array For every index such that if we change the value of to then every element from the suffix will be increased by Therefore if we ll partition array into multiple subarrays Since none of the elements from the first subarray can be changed it will contribute with the number of occurences of in towards the final answer For each of the other subarrays let be the most frequent element in the subarray appearing times Since we can change the value of to In this case every in this subarray will become equal to and our current subarray will contribute with towards the final answer Time complexity per testcase 
https://codeforces.com//contest/555/problem/E,30423,E,555E,555,E. Case of Computer Network,Andrewid the Android is a galaxy known detective Now he is preparing a defense against a possible attack by hackers on a major computer network In this network are vertices some pairs of vertices are connected by undirected channels It is planned to transfer important messages via this network the th of which must be sent from vertex to vertex via one or more channels perhaps through some intermediate vertices To protect against attacks a special algorithm was developed Unfortunately it can be applied only to the network containing directed channels Therefore as new channels can t be created it was decided for each of the existing undirected channels to enable them to transmit data only in one of the two directions Your task is to determine whether it is possible so to choose the direction for each channel so that each of the messages could be successfully transmitted ,"['#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int MAX = 200005;\nvector<int> adj[MAX];\nint from[MAX], to[MAX], low[MAX], d[MAX], color[MAX], cc[MAX], par[20][MAX];\nbool iscut[MAX], mark[MAX], ans = true;\nvoid dfs(int p, int v)\n{\n\tmark[v] = true;\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint id = adj[v][i];\n\t\tif (id == p)\n\t\t\tcontinue;\n\t\tint u = from[id] + to[id] - v;\n\t\tif (mark[u])\n\t\t{\n\t\t\tif (d[low[v]] > d[u])\n\t\t\t\tlow[v] = u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td[u] = d[v] + 1;\n\t\t\tdfs(id, u);\n\t\t\tif (d[low[u]] > d[v])\n\t\t\t\tiscut[id] = true;\n\t\t\tif (d[low[v]] > d[low[u]])\n\t\t\t\tlow[v] = low[u];\n\t\t}\n\t}\n}\nvoid go(int v, int c)\n{\n\tcolor[v] = c;\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint id = adj[v][i];\n\t\tif (iscut[id])\n\t\t\tcontinue;\n\t\tint u = from[id] + to[id] - v;\n\t\tif (color[u] == -1)\n\t\t\tgo(u, c);\n\t}\n}\nvoid init(int p, int v, int c)\n{\n\tcc[v] = c;\n\tpar[0][v] = p;\n\tfor (int i = 1; i < 20; i++)\n\t\tpar[i][v] = par[i - 1][par[i - 1][v]];\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint u = adj[v][i];\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\td[u] = d[v] + 1;\n\t\tinit(v, u, c);\n\t}\n}\nint get_parent(int v, int k)\n{\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1 << i) & k)\n\t\t\tv = par[i][v];\n\treturn v;\n}\nint lca(int u, int v)\n{\n\tif (d[u] < d[v])\n\t\tswap(u, v);\n\tu = get_parent(u, d[u] - d[v]);\n\tif (u == v)\n\t\treturn u;\n\tfor (int i = 19; i >= 0; i--)\n\t\tif (par[i][u] != par[i][v])\n\t\t{\n\t\t\tu = par[i][u];\n\t\t\tv = par[i][v];\n\t\t}\n\treturn par[0][v];\n}\nint down[MAX], up[MAX];\nvoid fin(int p, int v)\n{\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint u = adj[v][i];\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\tfin(v, u);\n\t\tdown[v] += down[u];\n\t\tup[v] += up[u];\n\t}\n\tif (down[v] > 0 && up[v] > 0)\n\t\tans = false;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tmemset(color, -1, sizeof(color));\n\tfor (int i = 0; i < MAX; i++)\n\t\tlow[i] = i;\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> from[i] >> to[i];\n\t\tfrom[i]--;\n\t\tto[i]--;\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (!mark[i])\n\t\t\tdfs(-1, i);\n\tint c = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (color[i] == -1)\n\t\t\tgo(i, c++);\n\tfor (int i = 0; i < n; i++)\n\t\tadj[i].clear();\n\tfor (int i = 0; i < m; i++)\n\t\tif (iscut[i])\n\t\t{\n\t\t\tadj[color[from[i]]].push_back(color[to[i]]);\n\t\t\tadj[color[to[i]]].push_back(color[from[i]]);\n\t\t}\n\tmemset(cc, -1, sizeof(cc));\n\tmemset(d, 0, sizeof(d));\n\tn = c;\n\tc = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cc[i] == -1)\n\t\t\tinit(i, i, c++);\n\twhile (q--)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\tu = color[u];\n\t\tv = color[v];\n\t\tif (cc[u] != cc[v])\n\t\t\tans = false;\n\t\telse\n\t\t{\n\t\t\tint p = lca(u, v);\n\t\t\tup[u]++;\n\t\t\tup[p]--;\n\t\t\tdown[p]--;\n\t\t\tdown[v]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (par[0][i] == i)\n\t\t\tfin(i, i);\n\tif (ans)\n\t\tcout << ""Yes\\n"";\n\telse\n\t\tcout << ""No\\n"";\n\treturn 0;\n}\n']",,,"['dfs and similar', 'graphs', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Case of Computer Network.json,https://codeforces.com//blog/entry/18919,First of all let s reduce this problem to a problem on a tree In order to achieve this let s orient edges in all biconnected components according to a DFS order We ll get a strongly connected component Suppose it s false Then this component can be divided into parts and such that there s no edge from to As initially there are at least two edges between and this situation is impossible because after entering in our DFS we ll have to exit via one of these edges Contradiction We can compress all biconnected components Now we need to handle several queries orient edges on a simple path in a tree and to check if there are no conflicts For this let s hang our tree and find LCA s for queries pairs of vertices Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries paths call it that are ends of queries paths call it and that are precalculated LCAs call it Now we can orient the edge connecting the root of the subtree and its parent if is positive then it should be oriented up if is positive then it should be oriented down if both are positive there s no solution if both are zeros the direction does not matter Time where is the time of calculating LCA per query solution that uses slightly other method for the last part 
https://codeforces.com//contest/895/problem/B,136055,B,895B,895,B. XK Segments,While Vasya finished eating his piece of pizza the lesson has already started For being late for the lesson the teacher suggested Vasya to solve one interesting problem Vasya has an array and integer He should find the number of different ordered pairs of indexes such that and there are exactly integers such that and is divisible by In this problem it is meant that pair is equal to only if is equal to For example pair is not the same as ,"['#include""bits/stdc++.h""\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch==\'-\')f=-1;}while(ch<\'0\'||ch>\'9\');do x=x*10+ch-\'0\',ch=getchar();while(ch<=\'9\'&&ch>=\'0\');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,k;\n\nll A[maxn];\n\nmap<int,int> has;\n\nint main(){\n\tread(n,x,k);\n\tREP(i,1,n)read(A[i]);\n\tsort(A+1,A+n+1);\n\tll ans=0;\n\tREP(i,1,n){\n\t\tint t=(A[i]-1)/x;\n\t\tt+=k;\n\t\tll l=1ll*t*x,r=1ll*t*x+x-1;\n\t\tl=max(l,(ll)A[i]);\n\t\tans+=upper_bound(A+1,A+n+1,r)-lower_bound(A+1,A+n+1,l);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n']",,,"['binary search', 'math', 'sortings', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. XK Segments.json,https://codeforces.com//blog/entry/56028,First we need to understand how to find the number of integers in segment which are divisible by It is After that we should sort array in ascending order For each left boundary of the segment we need to find minimal and maximal index of good right boundaries All right boundaries should satisfy the following condition We already know is increasing while increases So we can do binary search on sorted array to find minimal maximal index of good right boundaries and that mean we can find the number of good right boundaries Time complexity Solution 
https://codeforces.com//contest/1732/problem/B,1601555,B,1732B,1732,B. Ugu,A binary string is a string consisting only of the characters and You are given a binary string s 1 s 2 ldots s n It is necessary to make this string non decreasing in the least number of operations In other words each character should be not less than the previous In one operation you can do the following Select an arbitrary index 1 leq i leq n in the string For all j geq i change the value in the j th position to the opposite that is if s j 1 then make s j 0 and vice versa What is the minimum number of operations needed to make the string non decreasing ,"['#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c==\'-\')f=-1;\n\t\tfor(;c<\'0\'||c>\'9\';c=gc())if(c==\'-\')f=-1;\n\t\tfor(;c>=\'0\'&&c<=\'9\';c=gc())\n\t\t\tx=x*10+(c-\'0\');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c=\'\\n\'){\n\t\tif(x<0)pc(\'-\'),x=-x;\n\t\tif(x==0) pc(\'0\'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+\'0\';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n;\nchar s[100005];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n);\n\t\tscanf(""%s"",s+1);\n\t\tint tot=0;\n\t\ts[0]=\'0\';\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]!=s[i-1])tot++;\n\t\t}\n\t\tpi(max(0,tot-1),\'\\n\');\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/']",,,"['brute force', 'dp', 'greedy', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Ugu.json,https://codeforces.com//blog/entry/108327,Let s mentally imagine the following array of length if and otherwise Note that if we apply the operation to the index then all the values of the array do not change except for Let s look at this in more detail For note that the th and th elements invert their value so does not change For note that the th and th elements do not change their value so does not change For note that the th element does not change its value but the th element does so will change its value If we look at the array for a sorted binary string we can see that this array does not contain more than one unit you either have a string consisting of only zeros or only ones or it looks like this Let be the number of ones in the original array We have now shown that the answer is In fact if the string starts with then the answer is otherwise it is Let s prove that if the string starts with then we can get the answer the case with will be similar Let s show a constructive proof using a small example Choose then Choose then Choose then 
https://codeforces.com//contest/1790/problem/D,1753649,D,1790D,1790,D. Matryoshkas,is a wooden toy in the form of a painted doll inside which you can put a similar doll of a smaller size A set of nesting dolls contains one or more nesting dolls their sizes are consecutive positive integers Thus a set of nesting dolls is described by two numbers s the size of a smallest nesting doll in a set and m the number of dolls in a set In other words the set contains sizes of s s 1 dots s m 1 for some integer s and m s m 0 You had one or more sets of nesting dolls Recently you found that someone mixed all your sets in one and recorded a sequence of doll sizes integers a 1 a 2 dots a n You do not remember how many sets you had so you want to find the number of sets that you could initially have For example if a given sequence is a 2 2 3 4 3 1 Initially there could be 2 sets the first set consisting of 4 nesting dolls with sizes 1 2 3 4 a second set consisting of 2 nesting dolls with sizes 2 3 According to a given sequence of sizes of nesting dolls a 1 a 2 dots a n determine the minimum number of nesting dolls that can make this sequence Each set is completely used so all its nesting dolls are used Each element of a given sequence must correspond to exactly one doll from some set ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint t,a[200100];\nvoid solve(){\n        int n,i,ans=0,t=-1,p=0;cin>>n;\n        map<int,int>mp;\n        for(i=0;i<n;i++)cin>>a[i],mp[a[i]]++;\n        for(auto [f,s]:mp){\n                if(t!=f-1)p=0;\n                if(s>p)ans+=s-p;\n                t=f,p=s;\n        }\n        cout<<ans<<'\\n';\n}\nsigned main(){\n        ios::sync_with_stdio(false);cin.tie(nullptr);\n        cin>>t;\n        while(t--)solve();\n        return 0;\n}""]",,,"['data structures', 'greedy', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Matryoshkas.json,https://codeforces.com//blog/entry/111948,First for each size let s count the number of dolls of this size Then let s create a set in which for each doll of size we add the numbers and This will allow you to process all the segments as well as the dimensions adjacent to them We will iterate over the set in ascending order of size Let be the number of matryoshkas of the current size of the previous one considered at the beginning If the numbers do not match then you need to close if or open if segments It is enough to add only the opening of the segments to the answer 
https://codeforces.com//contest/731/problem/A,75972,A,731A,731,A. Night at the Museum,Grigoriy like the hero of one famous comedy film found a job as a night security guard at the museum At first night he received and was to take stock of the whole exposition is a special devise that allows to print the text of a plastic tape Text is printed sequentially character by character The device consists of a wheel with a lowercase English letters written in a circle static pointer to the current letter and a button that print the chosen letter At one move it s allowed to rotate the alphabetic wheel one step clockwise or counterclockwise Initially static pointer points to letter Other letters are located as shown on the picture After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit It s not required to return the wheel to its initial position with pointer on the letter Our hero is afraid that some exhibits may become alive and start to attack him so he wants to print the names as fast as possible Help him for the given string find the minimum number of rotations of the wheel required to print it ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nint ans;\nstring s;\n\nint d(char a,char b)\n{\n\tif(a>b)swap(a,b);\n\treturn min(b-a,26-b+a);\n}\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> s;\n\tans+=d('a',s[0]);\n\tfor(int i=1;i<s.size();i++)\n\t\tans+=d(s[i],s[i-1]);\n\tcout << ans;\n\treturn 0;\n}\n""]",,,"['implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Night at the Museum.json,https://codeforces.com//blog/entry/47840,In this problem you have to implement exactly what is written in the statement i e you should find minimum number of rotations from letter a to the first letter in the input then to the second one and so on The only useful knowledge that may simplify the solution is that the distance between points and on the circle of length 26 in our case is This solution works in and of course fits in time limit 
https://codeforces.com//contest/141/problem/B,746,B,141B,141,B. Hopscotch,So nearly half of the winter is over and Maria is dreaming about summer She s fed up with skates and sleds she was dreaming about Hopscotch all night long It s a very popular children s game The game field the court looks as is shown in the figure all blocks are square and are numbered from bottom to top blocks in the same row are numbered from left to right Let us describe the hopscotch with numbers that denote the number of squares in the row staring from the lowest one 1 1 2 1 2 1 2 1 2 where then the period is repeated 1 2 The coordinate system is defined as shown in the figure Side of all the squares are equal and have length Maria is a very smart and clever girl and she is concerned with quite serious issues if she throws a stone into a point with coordinates then will she hit some square If the answer is positive you are also required to determine the number of the square It is believed that the stone has fallen into the square if it is located inside it In other words a stone that has fallen on the square border is not considered a to hit a square ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair< int, int > PRII;\ntypedef pair< double ,double > PRDD;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\n\n#define Size(a) ((int)a.size())\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\n#define x first\n#define y second\n#define p_b push_back\n#define m_p make_pair\n#define oo 1000000000\n#define eps 1e-12\nconst double pi = acos(-1.0);\n\nint main()\n{\n    int a,x,y,t;\n    \n\tscanf(""%d%d%d"",&a,&x,&y);\n\t\n\tif( !(y % a) )\n\t\tprintf(""-1\\n"");\n\telse\n\t\t{\n\t\t\tif( y < a )\n\t\t\t\t{\n\t\t\t\t\tif( 2*x > -a && 2*x < a )\n\t\t\t\t\t\tprintf(""1\\n"");\n\t\t\t\t\telse printf(""-1\\n"");\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ty -= a;\n\t\t\t\t\tt = y/(2*a)*3+1;\n\t\t\t\t\ty %= 2*a;\n\t\t\t\t\tif( y < a )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( 2*x > -a && 2*x < a )\n\t\t\t\t\t\t\t\tprintf(""%d\\n"",t+1);\n\t\t\t\t\t\t\telse printf(""-1\\n"");\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( x > -a && x < 0 )\n\t\t\t\t\t\t\t\tprintf(""%d\\n"",t+2);\n\t\t\t\t\t\t\telse if( x > 0 && x < a )\n\t\t\t\t\t\t\t\tprintf(""%d\\n"",t+3);\n\t\t\t\t\t\t\telse printf(""-1\\n"");\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t}\n\n    return 0;\n}\n']",,,"['geometry', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Hopscotch.json,https://codeforces.com//blog/entry/3571,Let s bust the level 0 i 106 in which assumedly the stone could hit Let s find the minimal number of square on this level Then we can understand how many squares there are on this level one or two Then we check with one or two ifs if on this level two squares if the stone is in corresponding square or not If the stone is inside then output the answer If we didn t find any square where the stone is output 1 
https://codeforces.com//contest/1976/problem/C,2672919,C,1976C,1976,C. Job Interview,Monocarp is opening his own IT company He wants to hire n programmers and m testers There are n m 1 candidates numbered from 1 to n m 1 in chronological order of their arriving time The i th candidate has programming skill a i and testing skill b i a person s programming skill is different from their testing skill The skill of the team is the sum of the programming skills of all candidates hired as programmers and the sum of the testing skills of all candidates hired as testers When a candidate arrives to interview Monocarp tries to assign them to the most suitable position for them if their programming skill is higher then he hires them as a programmer otherwise as a tester If all slots for that position are filled Monocarp assigns them to the other position Your task is for each candidate calculate the skill of the team if everyone except them comes to interview Note that it means that exactly n m candidates will arrive so all n m positions in the company will be filled ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n, m;    std::cin >> n >> m;        const int N = n + m + 1;    std::vector<int> a(N), b(N);    for (int i = 0; i < N; i++) {        std::cin >> a[i];    }    for (int i = 0; i < N; i++) {        std::cin >> b[i];    }        int t = 0;    int x = 0, y = 0;    i64 sum = 0;    while (x < n && y < m) {        if (a[t] > b[t]) {            sum += a[t];            x++;        } else {            sum += b[t];            y++;        }        t++;    }        std::vector<i64> ans(N);    i64 res = sum;    for (int i = t; i < N; i++) {        res += x == n ? b[i] : a[i];    }    for (int i = t; i < N; i++) {        ans[i] = res - (x == n ? b[i] : a[i]);    }    for (int i = 0; i < t; i++) {        if ((x == n) == (a[i] < b[i])) {            ans[i] = res - std::max(a[i], b[i]);        }    }        int ot = t;    int ox = x;    if (x == n) {        x--;    } else {        y--;    }    while (x < n && y < m) {        if (a[t] > b[t]) {            sum += a[t];            x++;        } else {            sum += b[t];            y++;        }        t++;    }    res = sum;    for (int i = t; i < N; i++) {        res += x == n ? b[i] : a[i];    }    for (int i = 0; i < ot; i++) {        if ((ox == n) == (a[i] > b[i])) {            ans[i] = res - std::max(a[i], b[i]);        }    }        for (int i = 0; i < N; i++) {        std::cout << ans[i] << "" \\n""[i == N - 1];    }}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']",,,"['binary search', 'dp', 'greedy', 'implementation', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Job Interview.json,https://codeforces.com//blog/entry/129992,Let s naively calculate the answer for the th candidate While calculating it let s store two values the type of job the th candidate was hired for the index of the first candidate who was hired for a suboptimal role We can show that this first candidate who was hired for a suboptimal role is the only possible candidate who can change his role if another candidate doesn t show up So for all other candidates among the first candidates their roles are fixed To prove this we can consider the following cases if the candidate who doesn t show up has an index or greater then for all candidates after them there is only one possible job when we consider that candidate all positions on one of the job are already filled if the index who doesn t show up has index less than then the candidate will take the same job as that candidate has taken and in any case all positions of the optimal job of the candidate will be filled after we take that candidate Now we can use the th candidate s answer to calculate the answer for the th candidate as follows if and we can move the th candidate to the role and the th candidate to the role this will change the answer by in case of the th candidate was hired as programmer similarly for tester otherwise we can simply move the th candidate to the role this will change the answer by in case of the th candidate was hired as programmer similarly for tester 
https://codeforces.com//contest/1702/problem/B,1456427,B,1702B,1702,B. Polycarp Writes a String from Memory,Polycarp has a poor memory Each day he can remember no more than 3 of different letters Polycarp wants to write a non empty string of s consisting of lowercase Latin letters taking number of days In how many days will he be able to do it Polycarp initially has an empty string and can only add characters to the end of that string For example if Polycarp wants to write the string he will do it in 2 days on the first day Polycarp will memorize the letters and write On the second day Polycarp will remember the letters add to the resulting line and get the line If Polycarp wants to write the string he will do it in 4 days in the first day will be written part on day two will be written part on the third day part of will be written on the fourth day part of will be written For a given string s print the minimum number of days it will take Polycarp to write it ,"['/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,k,c,a[N],d[N];\nvoid solo()\n{\n    string s;\n    cin>>s;\n    rep(i,97,138) d[i]=0;\n    k=0;\n    c=0;\n    rep(i,0,s.size()-1){\n        if (d[s[i]]==0){\n            c++;\n            if (c>3){\n                rep(j,97,138) d[j]=0;\n                k++;\n                c=1;\n            }\n            d[s[i]]++;\n        }\n    }\n    cout<<k+1;\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']",,,['greedy'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Polycarp Writes a String from Memory.json,https://codeforces.com//blog/entry/104763,Let us simulate the process We store a set consisting of letters that Polycarp memorizes on one day Gradually dial the set If the size of exceeds we add to the day counter and clear 
https://codeforces.com//contest/1373/problem/G,657376,G,1373G,1373,G. Pawns,You are given a chessboard consisting of n rows and n columns Rows are numbered from bottom to top from 1 to n Columns are numbered from left to right from 1 to n The cell at the intersection of the x th column and the y th row is denoted as x y Furthermore the k th column is a special column Initially the board is empty There are m changes to the board During the i th change one pawn is added or removed from the board The current board is good if we can move all pawns to the special column by the followings rules Pawn in the cell x y can be moved to the cell x y 1 x 1 y 1 or x 1 y 1 You can make as many such moves as you like Pawns can not be moved outside the chessboard Each cell can not contain more than one pawn The current board may not always be good To fix it you can add new rows to the board New rows are added at the top i e they will have numbers n 1 n 2 n 3 dots After each of m changes print one integer the minimum number of rows which you have to add to make the board good ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nconst ll identity = 0;\nconst ll SZ = 131072*4;\n\nll sum[2*SZ], lazy[2*SZ];\n\nll combine(ll A, ll B) {\n    return max(A, B);\n}\n\nll combineUpd(ll A, ll B) {\n    return A+B;\n}\n\nvoid push(int index, ll L, ll R) {\n    sum[index] = combineUpd(sum[index], lazy[index]);\n    if (L != R) lazy[2*index] = combineUpd(lazy[2*index], lazy[index]), lazy[2*index+1] = combineUpd(lazy[2*index+1], lazy[index]);\n    lazy[index] = identity;\n}\n\nvoid pull(int index) {\n    sum[index] = combine(sum[2*index], sum[2*index+1]);\n}\n\nll query(int lo, int hi, int index = 1, ll L = 0, ll R = SZ-1) {\n    push(index, L, R);\n    if (lo > R || L > hi) return 0;\n    if (lo <= L && R <= hi) return sum[index];\n\n    int M = (L+R) / 2;\n    return combine(query(lo, hi, 2*index, L, M), query(lo, hi, 2*index+1, M+1, R));\n}\n\nvoid update(int lo, int hi, ll increase, int index = 1, ll L = 0, ll R = SZ-1) {\n    push(index, L, R);\n    if (hi < L || R < lo) return;\n    if (lo <= L && R <= hi) {\n        lazy[index] = increase;\n        push(index, L, R);\n        return;\n    }\n\n    int M = (L+R) / 2;\n    update(lo, hi, increase, 2*index, L, M); update(lo, hi, increase, 2*index+1, M+1, R);\n    pull(index);\n}\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N, K, M; cin >> N >> K >> M;\n\n    F0R(i, 2*SZ) sum[i] = 0, lazy[i] = 0;\n\n    F0R(i, 2*SZ) {\n        update(i, i, i);\n    }\n\n    set<pi> S;\n    priority_queue<pair<int, pi> > q;\n    F0R(i, M) {\n        int A, B; cin >> A >> B;\n        int cur = B + abs(K - A);\n\n        if (S.count({A, B})) {\n            S.erase({A, B});\n            update(0, cur, -1);\n        } else {\n            S.ins({A, B});\n            update(0, cur, 1);\n            q.push({cur, {A, B}});\n        }\n\n        while (!q.empty() && !S.count(q.top().s)) {\n            q.pop();\n        }\n        if (q.empty()) {\n            cout << 0 << nl;\n        } else {\n            cout << max(query(0, q.top().f) - N-1, 0ll) << nl;\n        }\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['data structures', 'divide and conquer', 'greedy']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Pawns.json,https://codeforces.com//blog/entry/79376,For each pawn with initial position there exists a minimum index of row such that the pawn can reach the cell but cannot reach the cell It s easy to see that In the resulting configuration this pawn can occupy the cell or any other cell having Suppose the board consists of rows For each row the number of rows above it should be not less than the number of pawns that occupy the cells above it that is having greater than the index of that row because if this condition is not fulfilled we can t assign each pawn a unique cell If we denote the number of pawns that should go strictly above the th row as then for every row the condition must be met To prove that this condition is sufficient we may for example use Hall s theorem Okay now what about finding the minimum satisfying it Let s initially set to and for each row maintain the value of the minimum number of rows we have to add to our board so that the condition for the row is met we also have to maintain this value for auxiliary rows from to since some pawns cannot fit in the initial board at all Finding the minimum value we have to add to equals finding the maximum of all these values on some prefix we don t need to look at the values on some rows with large indices if there are no pawns after them so we need a maximum query on the segment where is the maximum index among all pawns and when a pawn is added or removed we should add or to all values on some suffix A segment tree with lazy propagation will do the trick solving the problem for us in 
https://codeforces.com//contest/1257/problem/F,470641,F,1257F,1257,F. Make Them Similar,Let s call two numbers if their binary representations contain the same number of digits equal to 1 For example 2 and 4 are similar binary representations are 10 and 100 1337 and 4213 are similar binary representations are 10100111001 and 1000001110101 3 and 2 are not similar binary representations are 11 and 10 42 and 13 are similar binary representations are 101010 and 1101 You are given an array of n integers a 1 a 2 a n You may choose a non negative integer x and then get another array of n integers b 1 b 2 b n where b i a i oplus x oplus denotes bitwise XOR Is it possible to obtain an array b where all numbers are similar to each other ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int BITS = 30;\nconst int HALF = BITS / 2;\n\nint N;\nvector<int> A;\n\nvoid normalize(vector<int> &counts) {\n    assert((int) counts.size() == N);\n\n    for (int i = N - 1; i >= 0; i--)\n        counts[i] -= counts[0];\n}\n\nint main() {\n    cin >> N;\n    A.resize(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    map<vector<int>, int> possible;\n\n    for (int mask = 0; mask < 1 << HALF; mask++) {\n        vector<int> counts(N, 0);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = __builtin_popcount((A[i] & ((1 << HALF) - 1)) ^ mask);\n\n        normalize(counts);\n\n        if (possible.find(counts) == possible.end())\n            possible[counts] = mask;\n    }\n\n    for (int mask = 0; mask < 1 << HALF; mask++) {\n        vector<int> counts(N, 0);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = __builtin_popcount(A[i] >> HALF ^ mask);\n\n        normalize(counts);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = -counts[i];\n\n        if (possible.find(counts) != possible.end()) {\n            int other = possible[counts];\n            cout << (mask << HALF) + other << '\\n';\n            return 0;\n        }\n    }\n\n    cout << -1 << '\\n';\n}\n""]",,,"['bitmasks', 'brute force', 'hashing', 'meet-in-the-middle']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Make Them Similar.json,https://codeforces.com//blog/entry/71434,Iterating over all possible values of and checking them may be too slow though heavily optimized brute force is difficult to eliminate in this problem so we need to speed this approach up The resulting number consists of bits Let s use the classical meet in the middle trick try all combinations of lowest bits try all combinations of highest bits and somehow merge the results When we fix a combination of lowest bits we fix lowest bits in every Suppose that there are ones among lowest bits of Analogically when we fix a combination of highest bits we fix highest bits in every Suppose that there are ones among highest bits of We want to find a combination of lowest and highest bits such that is the same for each Let s represent each combination of lowest bits with an dimensional vector with coordinates Let s also represent each combination of highest bits with an dimensional vector with coordinates We want to find a combination of lowest bits and a combination of highest bits such that their vectors are opposite We can do so for example by precalculating all vectors for all combinations of lowest bits storing them in a map or a trie iterating on a combination of highest bits and searching for the opposite vector in the map trie 
https://codeforces.com//contest/1860/problem/A,2169697,A,1860A,1860,A. Not a Substring,A bracket sequence is a string consisting of characters and or A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular they can be transformed into and respectively bracket sequences and are not regular You are given a bracket sequence s let s define its length as n Your task is to find a regular bracket sequence t of length 2n such that s occur in t as a or report that there is no such sequence ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    if (s == ""()"") {\n        std::cout << ""NO\\n"";\n        return;\n    }\n    \n    std::cout << ""YES\\n"";\n    bool alt = true;\n    for (int i = 1; i < n; i++) {\n        if (s[i] == s[i - 1]) {\n            alt = false;\n        }\n    }\n    if (alt) {\n        std::cout << std::string(n, \'(\') + std::string(n, \')\') << ""\\n"";\n    } else {\n        for (int i = 1; i <= n; i++) {\n            std::cout << ""()"";\n        }\n        std::cout << ""\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Not a Substring.json,https://codeforces.com//blog/entry/119504,Let s consider the following two cases the string contains two consecutive equal characters for example or In this case we can choose a string of the form since it does not contain a substring of two equal characters therefore is not a substring of in the string all adjacent characters are different i e it is alternating In this case we can choose a string of the form since here the length of the longest alternating substring is The only alternating substring it contains is which is a part of regular bracket sequence Thus it is sufficient to consider the answer among only two candidates and of length 
https://codeforces.com//contest/732/problem/C,76073,C,732C,732,C. Sanatorium,Vasiliy spent his vacation in a sanatorium came back and found that he completely forgot details of his vacation Every day there was a breakfast a dinner and a supper in a dining room of the sanatorium of course in this order The only thing that Vasiliy has now is a card from the dining room contaning notes how many times he had a breakfast a dinner and a supper thus the card contains three integers Vasiliy could sometimes have missed some meal for example he could have had a breakfast and a supper but a dinner or probably at some days he haven t been at the dining room at all Vasiliy doesn t remember what was the time of the day when he arrived to sanatorium before breakfast before dinner before supper or after supper and the time when he left it before breakfast before dinner before supper or after supper So he considers any of these options After Vasiliy arrived to the sanatorium he was there all the time until he left Please note that it s possible that Vasiliy left the sanatorium on the same day he arrived According to the notes in the card help Vasiliy determine the minimum number of meals in the dining room that he could have missed We shouldn t count as missed meals on the arrival day before Vasiliy s arrival and meals on the departure day after he left ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nll a[3],b[3];\n\nint main(){\n    ll Sum = 0;\n    rep(i,0,3) cin >> a[i] , Sum += a[i];\n    ll ans = 9 * 1e18;\n    rep(i,0,3) rep(j,i,3){\n        memset(b,0,sizeof(b));\n        rep(k,i,j+1) b[k] = 1;\n        bool ok = true;\n        rep(k,0,3) ok &= b[k] >= a[k];\n        if(ok) ans = min(ans , j - i + 1ll - Sum);\n    }\n    rep(i,0,4) rep(j,0,4){\n        memset(b , 0 , sizeof(b));\n        for(int k=0;k<min(3,i);++k) b[k]++;\n        for(int k=0;k<min(3,j);++k) b[2-k]++;\n        ll Max = 0;\n        rep(k,0,3) Max = max(Max , a[k] - b[k]);\n        ll tmp = 3 * Max + i + j - Sum;\n        ans = min(tmp , ans);\n    }\n    cout <<ans << endl;\n    return 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Sanatorium.json,https://codeforces.com//blog/entry/47890,Let s iterate on the time of day when Vasiliy arrived at the sanatorium breakfast dinner or supper and on the time when Vasiliy left We sum the changed values of and considering that we take all possible meals during the first and the last day into the variable find the maximum of these three variables also changed and if our current answer is more than we update it with this value After considering all possible scenarios we print the answer Time complexity 
https://codeforces.com//contest/1824/problem/E,1909042,E,1824E,1824,E. LuoTianyi and Cartridge,LuoTianyi is watching the anime She finds that making a Cartridge is interesting To describe the process of making a Cartridge more clearly she abstracts the original problem and gives you the following problem You are given a tree T consisting of n vertices Each vertex has values a i and b i and each edge has values c j and d j Now you are aim to build a T as follows First select p vertices from T p is a number chosen by yourself as the vertex set S of T Next select p 1 edges from T one by one you cannot select one edge more than once May you have chosen the j th edge connects vertices x j and y j with values c j d j then you can choose two vertices u and v in S that satisfy the edge x j y j is contained in the simple path from u to v in T and link u and v in T by the edge with values c j d j u and v shouldn t be contained in one connected component before in T Let A be the minimum of values a i in T and C be the minimum of values c i in T Let B be the sum of b i in T and D be the sum of values d i in T Let min A C cdot B D be the of T You need to find the maximum possible cost of T ,"['#include <bits/stdc++.h>\xa0using i64 = long long;struct HLD {    int n;    std::vector<int> siz, top, dep, parent, in, out, seq;    std::vector<std::vector<int>> adj;    int cur;        HLD() {}    HLD(int n) {        init(n);    }    void init(int n) {        this->n = n;        siz.resize(n);        top.resize(n);        dep.resize(n);        parent.resize(n);        in.resize(n);        out.resize(n);        seq.resize(n);        cur = 0;        adj.assign(n, {});    }    void addEdge(int u, int v) {        adj[u].push_back(v);        adj[v].push_back(u);    }    void work(int root = 0) {        top[root] = root;        dep[root] = 0;        parent[root] = -1;        dfs1(root);        dfs2(root);    }    void dfs1(int u) {        if (parent[u] != -1) {            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));        }                siz[u] = 1;        for (auto &v : adj[u]) {            parent[v] = u;            dep[v] = dep[u] + 1;            dfs1(v);            siz[u] += siz[v];            if (siz[v] > siz[adj[u][0]]) {                std::swap(v, adj[u][0]);            }        }    }    void dfs2(int u) {        in[u] = cur++;        seq[in[u]] = u;        for (auto v : adj[u]) {            top[v] = v == adj[u][0] ? top[u] : v;            dfs2(v);        }        out[u] = cur;    }    int lca(int u, int v) {        while (top[u] != top[v]) {            if (dep[top[u]] > dep[top[v]]) {                u = parent[top[u]];            } else {                v = parent[top[v]];            }        }        return dep[u] < dep[v] ? u : v;    }        int dist(int u, int v) {        return dep[u] + dep[v] - 2 * dep[lca(u, v)];    }        int jump(int u, int k) {        if (dep[u] < k) {            return -1;        }                int d = dep[u] - k;                while (dep[top[u]] > d) {            u = parent[top[u]];        }                return seq[in[u] - dep[u] + d];    }        bool isAncester(int u, int v) {        return in[u] <= in[v] && in[v] < out[u];    }        int rootedParent(int u, int v) {        std::swap(u, v);        if (u == v) {            return u;        }        if (!isAncester(u, v)) {            return parent[u];        }        auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {            return in[x] < in[y];        }) - 1;        return *it;    }        int rootedSize(int u, int v) {        if (u == v) {            return n;        }        if (!isAncester(v, u)) {            return siz[v];        }        return n - siz[rootedParent(u, v)];    }        int rootedLca(int a, int b, int c) {        return lca(a, b) ^ lca(b, c) ^ lca(c, a);    }};struct DSU {    std::vector<int> f, siz;        DSU() {}    DSU(int n) {        init(n);    }        void init(int n) {        f.resize(n);        std::iota(f.begin(), f.end(), 0);        siz.assign(n, 1);    }        int find(int x) {        while (x != f[x]) {            x = f[x] = f[f[x]];        }        return x;    }        bool same(int x, int y) {        return find(x) == find(y);    }        bool merge(int x, int y) {        x = find(x);        y = find(y);        if (x == y) {            return false;        }        siz[x] += siz[y];        f[y] = x;        return true;    }        int size(int x) {        return siz[find(x)];    }};\xa0template<class Info>struct SegmentTree {    int n;    std::vector<Info> info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template<class T>    SegmentTree(std::vector<T> init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template<class T>    void init(std::vector<T> init_) {        n = init_.size();        info.assign(4 << std::__lg(n), Info());        std::function<void(int, int, int)> build = [&](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x < m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l >= y || r <= x) {            return Info();        }        if (l >= x && r <= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template<class F>    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l >= y || r <= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template<class F>    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template<class F>    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l >= y || r <= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template<class F>    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }};\xa0constexpr int inf = 1E9;struct Min {    int x = inf;};\xa0Min operator+(Min a, Min b) {    return {std::min(a.x, b.x)};}template <typename T>struct Fenwick {    int n;    std::vector<T> a;        Fenwick(int n = 0) {        init(n);    }        void init(int n) {        this->n = n;        a.assign(n, T());    }        void add(int x, T v) {        for (int i = x + 1; i <= n; i += i & -i) {            a[i - 1] += v;        }    }        T sum(int x) {        auto ans = T();        for (int i = x; i > 0; i -= i & -i) {            ans += a[i - 1];        }        return ans;    }        T rangeSum(int l, int r) {        return sum(r) - sum(l);    }        int kth(T k) {        int x = 0;        for (int i = 1 << std::__lg(n); i; i /= 2) {            if (x + i <= n && k >= a[x + i - 1]) {                x += i;                k -= a[x - 1];            }        }        return x;    }};\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n;    std::cin >> n;        std::vector<int> a(2 * n - 1), b(2 * n - 1);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    for (int i = 0; i < n; i++) {        std::cin >> b[i];    }        HLD t(n);    std::vector<int> x(n - 1), y(n - 1);    for (int i = 0; i < n - 1; i++) {        std::cin >> x[i] >> y[i] >> a[n + i] >> b[n + i];        x[i]--, y[i]--;                t.addEdge(x[i], y[i]);    }    t.work();        auto vb = b;    std::sort(vb.begin(), vb.end(), std::greater());    for (int i = 0; i < 2 * n - 1; i++) {        b[i] = std::lower_bound(vb.begin(), vb.end(), b[i], std::greater()) - vb.begin();    }        auto cmp = [&](int x, int y) {        return t.in[x] < t.in[y];    };    std::set<int, decltype(cmp)> s(cmp);    std::vector<int> c(n), d(n);    for (int i = 0; i < n - 1; i++) {        if (t.parent[x[i]] != y[i]) {            std::swap(x[i], y[i]);        }        c[x[i]] = a[n + i];        d[x[i]] = b[n + i];    }        std::vector<int> ord(2 * n - 1);    std::iota(ord.begin(), ord.end(), 0);    std::sort(ord.begin(), ord.end(), [&](int i, int j) {        return a[i] > a[j];    });        SegmentTree<Min> seg(n);        int top = -1;        Fenwick<int> fc(2 * n - 1), fce(2 * n - 1);    Fenwick<i64> fs(2 * n - 1), fse(2 * n - 1);    i64 sumb = 0;    auto add = [&](int x, int t = 1) {        fc.add(x, t);        fs.add(x, vb[x] * t);    };        std::set<int, decltype(cmp)> sdown(cmp);    i64 sumv = 0;    auto addv = [&](int x) {        // std::cerr << ""addvertex "" << x + 1 << ""\\n"";                sumv += vb[b[x]];        add(b[x]);                auto it = sdown.upper_bound(x);        int u = -1;        if (it != sdown.begin() && t.in[x] < t.out[*std::prev(it)]) {            u = *std::prev(it);        }                if (u != -1) {            auto v = seg.rangeQuery(t.in[u], t.out[u]).x;            if (v != inf) {                add(v);                sumb -= vb[v];            }        }        seg.modify(t.in[x], {b[x]});        if (u != -1) {            auto v = seg.rangeQuery(t.in[u], t.out[u]).x;            if (v != inf) {                add(v, -1);                sumb += vb[v];            }        }    };        int L = n, R = 0;        int cnte = 0;    auto adde = [&](int x) {        // std::cerr << ""addedge ("" << x + 1 << "", "" << t.parent[x] + 1 << "")\\n"";        cnte++;        sumb += vb[d[x]];        fce.add(d[x], 1);        fse.add(d[x], vb[d[x]]);        L = std::min(L, t.in[x]);        R = std::max(R, t.out[x]);                if (top == -1 || t.dep[x] < t.dep[top]) {            top = x;        }                auto it = sdown.upper_bound(x);        if (it != sdown.begin() && t.in[x] < t.out[*std::prev(it)]) {            int u = *std::prev(it);            auto v = seg.rangeQuery(t.in[u], t.out[u]).x;            if (v != inf) {                add(v);                sumb -= vb[v];            }            sdown.erase(u);        }        it = sdown.lower_bound(x);        if (it != sdown.end() && t.in[*it] < t.out[x]) {            return;        }        sdown.insert(x);        auto v = seg.rangeQuery(t.in[x], t.out[x]).x;        if (v != inf) {            add(v, -1);            sumb += vb[v];        }    };        auto query = [&]() {        if (cnte >= s.size() - 1) {            int res = s.size() - 1;            i64 sum = sumv;            int t = fce.kth(res);            sum += fse.sum(t);            res -= fce.sum(t);            if (res) {                sum += 1LL * res * vb[t];            }            return sum;        }        int res = cnte + 1 - sdown.size();        i64 sum = sumb;        if (top != -1) {            if (t.in[top] > L || t.out[top] < R) {                top = -1;            }        }        int v = -1;        if (top != -1) {            res--;            v = (seg.rangeQuery(0, t.in[top]) + seg.rangeQuery(t.out[top], n)).x;            add(v, -1);            sum += vb[v];        }        int t = fc.kth(res);        sum += fs.sum(t);        res -= fc.sum(t);        if (res) {            sum += 1LL * res * vb[t];        }        if (v != -1) {            add(v);        }        // std::cerr << ""p : "" << cnte + 1 << ""\\n"";        // std::cerr << ""sumb : "" << sumb << ""\\n"";        // std::cerr << ""sum : "" << sum << ""\\n"";        // std::cerr << ""-----\\n"";        return sum;    };        std::vector<bool> vis(n);    i64 ans = 0;    for (int i = 0; i < n; i++) {        ans = std::max(ans, 1LL * a[i] * vb[b[i]]);    }    DSU dsu(n);    for (auto i : ord) {        i64 min = a[i];        if (i < n) {            auto it = s.insert(i).first;            int lst = it == s.begin() ? *s.rbegin() : *std::prev(it);            int nxt = std::next(it) == s.end() ? *s.begin() : *std::next(it);            for (auto x : {lst, nxt}) {                int y = i;                x = dsu.find(x);                y = dsu.find(y);                while (x != y) {                    if (t.dep[x] < t.dep[y]) {                        std::swap(x, y);                    }                    if (vis[x]) {                        adde(x);                    }                    vis[x] = true;                    dsu.merge(t.parent[x], x);                    x = dsu.find(x);                }            }            addv(i);        } else {            i -= n;            if (vis[x[i]]) {                adde(x[i]);            }            vis[x[i]] = true;        }        if (!s.empty()) {            // std::cerr << ""min : "" << min << ""\\n"";            ans = std::max(ans, min * query());        }    }        std::cout << ans << ""\\n"";        return 0;}']",,,"['data structures', 'trees']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. LuoTianyi and Cartridge.json,https://codeforces.com//blog/entry/116328,Consider finding the maximum value of B D for every min A C Denote min A C as x We call a vertex u satisfying au x or an edge satisfying ce x optional Denote as V the optional vertex set and as E0 the optional edge set Firstly if all optional vertices are on the same side of an edge this edge mustn t be chosen Delete these edges from E0 and we get the edge set E Formally an edge e is in E if and only if ce x and there exists u v so that e is on the path between them Lemma There exists an optimal Tans Vans Eans that either V Vans or E Eans Proof Assume an optimal T V E with V V E E Choose an edge e that is in E but not in E Because V V there must exist two vertices u v on different sides of edge e and u V v V Consider adding the edge e and the vertex v into our chosen tree the resulting graph is obviously a tree Note that bv de 0 so the resulting choice is no worse than T When we delete the edges in E from the original tree we get some connected components Shrink one component into a single vertex to get V and then for all edges u v E connect u s and v s component together in the new graph and get E Obviously the new graph T V E is a tree For any leaf vertex u on the new tree T there must exist a vertex u in the component u that is chosen otherwise the edge connecting to u let s say e is not chosen either Adding u and e into our answer tree achieves a better answer Assume that now we have chosen a vertex u for every leaf u denote the set of chosen vertices as Vx Consider an arbitary choice of vertex for components Vc and edge choice Ec satisfying Vx Vc V Ec E Vc 1 Ec It s easy to prove that the choice is a legal answer given the fact that every e Ec has at least one leaf component on each side and every leaf component contains a chosen vertex Reconsider the lemma and we can get a solution for a fixed x Find V E Calculate the components and get V E Find the vertex with the maximum b in every leaf component in V and get Vx Let m be min V E 1 and m be Vx Choose the vertices in V Vx with the first m m largest b and the edges in E with the first m 1 largest d and get the answer Consider the process when x gets larger the sets V E get smaller and smaller while the components merge into each other We use segment trees to maintain the b value of the vertices and the d value of the edges when merging two components we simply merge the two segment trees 
https://codeforces.com//contest/1205/problem/B,390598,B,1205B,1205,B. Shortest Cycle,You are given n integer numbers a 1 a 2 dots a n Consider graph on n nodes in which nodes i j i neq j are connected if and only if a i AND a j neq 0 where AND denotes the bitwise AND operation Find the length of the shortest cycle in this graph or determine that it doesn t have cycles at all ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ];\nint dis[555][555],aa[555][555];\nint main()\n{\n\tmemset(dis,127/4,sizeof dis);\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(""%lld"",a+i);\n\t\tif(!a[i])\n\t\t{\n\t\t\t--n; --i;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif(n>3*64)\n\t{\n\t\tputs(""3"");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif((a[i]&a[j])) dis[i][j]=dis[j][i]=1;\n\tmemcpy(aa,dis,sizeof aa);\n\tint ans=2e9;\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tfor(int i=1;i<k;++i)\n\t\t\tfor(int j=i+1;j<k;++j)\n\t\t\t\tans=min(ans,aa[i][k]+aa[k][j]+dis[i][j]);\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n\t}\n\tif(ans>1e3) ans=-1;\n\tprintf(""%d\\n"",ans);\n}\n']",,,"['bitmasks', 'brute force', 'graphs', 'shortest paths']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Shortest Cycle.json,https://codeforces.com/blog/entry/69158,The most important thing in this task is to notice that if any bit is contained at least numbers then they will form a cycle of length and the answer is Suppose now that each bit is in no more than two numbers It follows that each bit can be shared by at most one pair of numbers From here we get that in the graph there are no more than edges Then in it you can find the shortest cycle in for each edge between the vertices and we will try to remove it and find the shortest distance between the vertices in the resulting graph If each time and turned out to be in different components then there is no cycle in the graph otherwise its length is the minimal of the distances found Asymptotics 
https://codeforces.com//contest/1833/problem/C,1929816,C,1833C,1833,C. Vlad Building Beautiful Array,Vlad was given an array a of n positive integers Now he wants to build a array b of length n from it Vlad considers an array if all the numbers in it are positive and have the same parity That is all numbers in the array are than zero and are either all even or all odd To build the array b Vlad can assign each b i either the value a i or a i a j where any j from 1 to n can be chosen To avoid trying to do the impossible Vlad asks you to determine whether it is possible to build a array b of length n using his array a ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    std::sort(a.begin(), a.end());\n    a.resize(std::unique(a.begin(), a.end()) - a.begin());\n    n = (int) a.size();\n    std::vector<bool> ok(2, false);\n    std::vector t(n, std::vector<bool>(2, false));\n    for (int i = 0; i < n; i++) {\n        int x = a[i] & 1;\n        t[i][x] = true;\n        if (ok[1]) {\n            t[i][x ^ 1] = true;\n        }\n        ok[x] = true;\n    }\n    std::vector<int> cnt(2, 0);\n    for (auto x : t) {\n        cnt[0] += x[0];\n        cnt[1] += x[1];\n    }\n    if (cnt[0] == n || cnt[1] == n) {\n        std::cout << ""Yes"" << ""\\n"";\n    } else {\n        std::cout << ""No"" << ""\\n"";\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Vlad Building Beautiful Array.json,https://codeforces.com//blog/entry/116636,If all the numbers in the array already have the same parity then for each it is sufficient to assign Otherwise it is impossible to make all the numbers even by leaving them positive because the parity changes only when subtracting an odd number and we cannot make the minimum odd number an even number It remains only to make all numbers odd that is subtract odd numbers from even numbers This can be done if the minimum number in the array is odd because we can subtract it from every even number 
https://codeforces.com//contest/408/problem/B,7727,B,408B,408,B. Garland,Once little Vasya read an article in a magazine on how to make beautiful handmade garland from colored paper Vasya immediately went to the store and bought colored sheets of paper the area of each sheet is 1 square meter The garland must consist of exactly pieces of colored paper of arbitrary area each piece should be of a certain color To make the garland Vasya can arbitrarily cut his existing colored sheets into pieces Vasya is not obliged to use all the sheets to make the garland Vasya wants the garland to be as attractive as possible so he wants to maximize the total area of pieces of paper in the garland Calculate what the maximum total area of the pieces of paper in the garland Vasya can get ,"[""#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <unordered_set>\n#include <stdio.h>\n#include <string.h>\n#include <unordered_map>\nusing namespace std;\n\n#define MOD 10e9+7\n\nint c1[256];\nint c2[256];\n\nint main(){\n    string s1;\n    cin>>s1;\n    for(int i=0; i<s1.size(); i++)\n        c1[s1[i]]++;\n    string s2;\n    cin>>s2;\n    for(int i=0; i<s2.size(); i++)\n        c2[s2[i]]++;\n    int s=0;\n    for(char i='a'; i<='z'; i++){\n        if(c2[i]!=0&&c1[i]==0){\n            cout<<-1<<endl;\n            return 0;\n        }\n        s+=min(c1[i],c2[i]);\n    }\n    cout<<s<<endl;\n    return 0;\n}\n""]",,,['implementation'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Garland.json,https://codeforces.com//blog/entry/11333,In this problem it is necessary to find the garland with the maximal length which can be composed of elements that we have First if you need some color but you don t have it then the answer is 1 Otherwise answer is always exists Let s sum the answers for all the colors separately Suppose we have pieces of a garland of some color and we need pieces Then we have to add to the answer if we will use 1 meter pieces in the other case if we will use all pieces 
https://codeforces.com//contest/1133/problem/C,308946,C,1133C,1133,C. Balanced Team,You are a coach at your local university There are n students under your supervision the programming skill of the i th student is a i You have to create a team for a new programming competition As you know the more students some team has the more probable its victory is So you have to create a team with the maximum number of students But you also know that a team should be It means that the programming skill of each pair of students in a created team should differ by no more than 5 Your task is to report the maximum possible number of students in a team ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define INF 9223372036854775807\n#define M_PI 3.14159265358979323846\n\nint mod = INF;\n\nint fastPow(int b, int e){int r = 1;while(e){if(e%2 == 1){r*=b;r%=mod;}b*=b;b%=mod;e/=2;}return r;}\nint pgcd(int a, int b){ if(a%b == 0) return b; else return pgcd(b, a%b);}\nint sign(int a){if(a < 0){ return -1;}if(a == 0) {return 0;}return 1;}\nbool isPrime(int a){if(a == 1) {return false;}int f = sqrt(a);for(int i = 2; i<=f; i++){if(a%i == 0){return false;}}return true;}\nint toInt(string s){int tot = 0;for(int i = s.size()-1; i >= 0; i--){tot+=((s[i]-\'0\')%mod)*fastPow(10,i);tot%=mod;}return tot;}\nstring toString(int a){string s = """";while(a){s = (char)(\'0\'+a%10) + s;a/=10;}return s;}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for(int i = 0; i < n; i++){\n        cin >> v[i];\n    }\n    sort(v.begin(), v.end());\n    int ans = 1;\n\n    for(int i = 0; i < n; i++){\n        int l = lower_bound(v.begin(), v.end(), v[i]-5)-v.begin();\n        int r = i;\n        if(l > r) continue;\n        ans = max(ans, r-l+1);\n    }\n\n    cout << ans << endl;\n}\n']",,,"['sortings', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Balanced Team.json,https://codeforces.com//blog/entry/65807,Let s sort all values in non decreasing order Then we can use two pointers to calculate for each student the maximum number of students such that This is pretty standard approach We also can use binary search to do it or we can store for each programming skill the number of students with this skill and just iterate from some skill to and sum up all numbers of students 
https://codeforces.com//contest/529/problem/E,25014,E,529E,529,E. The Art of Dealing with ATM,ATMs of a well known bank of a small country are arranged so that they can not give any amount of money requested by the user Due to the limited size of the bill dispenser the device that is directly giving money from an ATM and some peculiarities of the ATM structure you can get at most bills from it and the bills may be of at most two distinct denominations For example if a country uses bills with denominations and burles then at such ATM can give sums burles and burles but it cannot give sums and burles Let s suppose that the country uses bills of distinct denominations and the ATM that you are using has an unlimited number of bills of each type You know that during the day you will need to withdraw a certain amount of cash times You know that when the ATM has multiple ways to give money it chooses the one which requires the minimum number of bills or displays an error message if it cannot be done Determine the result of each of the of requests for cash withdrawal ,"['#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << "" = "" << x << endl\n#define _ << "" _ "" <<\n\ntypedef long long llint;\n\nconst int MAX = 1e7 + 100;\nconst int MAXN = 5050;\n\nint a[MAXN];\nbool ima[MAX];\n\nint main(void) {\n  int n, k;\n  scanf(""%d %d"", &n, &k);\n  REP(i, n) {\n    scanf(""%d"", &a[i]);\n    ima[a[i]] = true;\n  }\n\n  int q;\n  scanf(""%d"", &q);\n  while (q--) {\n    int v;\n    scanf(""%d"",  &v);\n    \n    int ans = k+1;\n    REP(i, n) REP(x, k+1) {\n      int rem = v - x * a[i];\n      if (rem < 0) break;\n      \n      if (rem == 0) {\n        ans = min(ans, x);\n        continue;\n      }\n\n      FOR(y, 1, k+1-x)\n        if (rem % y == 0 && rem/y < MAX && ima[rem / y]) {\n          ans = min(ans, x + y);\n          break;\n        }\n    }\n\n    if (ans > k) ans = -1;\n    printf(""%d\\n"", ans);\n  }\n\n  return 0;\n}\n']",,,['brute force'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. The Art of Dealing with ATM.json,https://codeforces.com//blog/entry/17065,Intended solution has the complexity or For each possible value x that we can get write a pair x m where m is number of bills to achieve this value Sort this array in ascending order of x and leave only the best possible number of bills for each value of x Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O 1 time Check that we used no more than k bills totally and relax the answer if needed 
https://codeforces.com//contest/1628/problem/B,1270543,B,1628B,1628,B. Peculiar Movie Preferences,You are given a list s of n non empty strings of length representing the scenes of Mihai s movie A subsequence of s is called if it is non empty and the concatenation of the strings in the subsequence in order is a palindrome Can you help Mihai check if there is at least one awesome subsequence of s A palindrome is a string that reads the same backward as forward for example strings are palindromes but strings are not A sequence a is a non empty subsequence of a non empty sequence b if a can be obtained from b by deletion of several possibly zero but not all elements ,"['/**\n *    author:  tourist\n *    created: 22.01.2022 17:44:36       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n    }\n    bool ok = false;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == string(s[i].rbegin(), s[i].rend())) {\n        ok = true;\n        break;\n      }\n    }\n    if (ok) {\n      cout << ""YES"" << \'\\n\';\n      continue;\n    }\n    set<string> p;\n    for (int i = 0; i < n; i++) {\n      string x(s[i].rbegin(), s[i].rend());\n      string y(s[i].rbegin(), prev(s[i].rend()));\n      if (p.find(x) != p.end() || p.find(y) != p.end()) {\n        ok = true;\n        break;\n      }\n      p.insert(s[i]);\n    }\n    if (!ok) {\n      p.clear();\n      for (int i = n - 1; i >= 0; i--) {\n        string x(next(s[i].rbegin()), s[i].rend());\n        if (p.find(x) != p.end()) {\n          ok = true;\n          break;\n        }\n        p.insert(s[i]);\n      }\n    }\n    cout << (ok ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['greedy', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Peculiar Movie Preferences.json,https://codeforces.com//blog/entry/99276,Because of the low constraints on the lengths of the strings we can prove that it s enough to pair at most strings to form a palindrome proof only checking pairs is enough Let s assume there is a awesome subsequence of the form xyz where x and z are single strings from s and y is anything If x and z are the same length they clearly have to be reverses of each other for xyz to be a palindrome so y is not needed to make it a palindrome If they are not the same length one of them is of length 3 and the other is of length 2 Assume x is the string of length 3 and y is the string of length 2 The first two characters of x must be the reverse of z If x and z are concatenated the third character of x is in the middle so it doesn t matter So in this case too y is not needed This proves that if any awesome subsequence exists there also exists an awesome subsequence of 1 or 2 strings proof ends So we first check if there exists a palindrome already if there is we found a solution If not checking for each pair would take too long but we can do it much more efficiently We can assume that all strings are of length or since if there was a string of length it would be a palindrome and we would have found the solution earlier For each string of length it s enough to check if before it we have seen a string of the following forms its reverse or its reverse with a character appended to it so a string of length since the last character of a string of length would be the middle character of the palindrome obtained after concatenation For each string of length it s enough to check if before it we have seen a string of the following forms its reverse or the reverse of the string without considering the first character so a string of length since the first character of a string of length would be the middle character of the palindrome obtained after concatenation All this can be checked using a frequency matrix map set or other data structures 
https://codeforces.com//contest/1713/problem/C,1496886,C,1713C,1713,C. Build Permutation,A array a of size n is called if for all valid indices i 0 le i le n 1 a i i is a perfect square dagger Given an integer n Find a permutation ddagger p of 0 1 2 ldots n 1 that is good or determine that no such permutation exists dagger An integer x is said to be a perfect square if there exists an integer y such that x y 2 ddagger An array b is a permutation of an array a if b consists of the elements of a in arbitrary order For example 4 2 3 4 is a permutation of 3 2 4 4 while 1 2 2 is not a permutation of 1 2 3 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nconst int MAX = 200200;\n\nconst int MOD = 998244353;\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vi res(n);\n\n    int curr = n-1;\n\n    while (curr > 0) {\n        int base;\n        for (base = 0; base*base < curr; base++);\n        int need = base*base-curr;\n        int start = curr;\n        for (int i = need; i <= start; i++) {\n            res[i] = curr;\n            curr--;\n        }\n    }\n    for (int i = 0; i < n; i++) cout << res[i] << "" "";\n    cout << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""input.in"", ""r"", stdin);\n    // freopen(""input.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}']",,,"['constructive algorithms', 'dp', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Build Permutation.json,https://codeforces.com//blog/entry/105419,First let s prove that the answer always exists Let s call the smallest square number that is not smaller than is Therefore which means Proof So we can fill for Using this method we can recursively reduce to then all the way down to We can prove that as Time complexity Solution 
https://codeforces.com//contest/1279/problem/D,504276,D,1279D,1279,D. Santa's Bot,Santa Claus has received letters from n different kids throughout this year Of course each kid wants to get some presents from Santa in particular the i th kid asked Santa to give them one of k i different items as a present Some items could have been asked by multiple kids Santa is really busy so he wants the New Year Bot to choose the presents for all children Unfortunately the Bot s algorithm of choosing presents is bugged To choose a present for some kid the Bot does the following choose one kid x equiprobably among all n kids choose some item y equiprobably among all k x items kid x wants choose a kid z who will receive the present equipropably among all n kids this choice is independent of choosing x and y the resulting triple x y z is called of the Bot If kid z listed item y as an item they want to receive then the decision Otherwise the Bot s choice is Santa is aware of the bug but he can t estimate if this bug is really severe To do so he wants to know the probability that one decision generated according to the aforementioned algorithm is Can you help him ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int M = 998244353;\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nint pw(int a, int n) {\n  int res = 1;\n  while (n) {\n    if (n % 2 == 0) {\n      a = mul(a, a);\n      n/= 2;\n    } else {\n      res = mul(res,a);\n      n--;\n    }\n  }\n  return res;\n}\n\nint inv(int x) {\n  return pw(x, M - 2);\n}\n\nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  int mod = M;\n  vector <int> a(1000000);\n  int id = 0;\n  vector <vector <int> > p;\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    vector <int> t;\n    for (int i = 0; i < k; i++) {\n      int x;\n      cin >> x;\n      x--;\n      t.push_back(x);\n      a[x]++;\n    }\n    p.push_back(t);\n    id += k;\n  }\n  int ans = 0;\n  int kek = inv(n);\n  for (int i = 0; i < n; i++) {\n    int ok = inv(p[i].size());\n    for (int x : p[i]) {\n      int prob = mul(mul(kek, ok), mul(a[x], kek));\n      ans += prob;\n      if (ans >= M) ans -= M;\n    }\n  }\n  cout << ans << endl;\n}\n']",,,"['combinatorics', 'math', 'probabilities']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Santa's Bot.json,https://codeforces.com//blog/entry/72577,First of all how to deal with the fractions modulo According to Fermat s little theorem if is coprime with So the inverse element for the denominator is taken modulo A cool property of fractions taken modulo or any other number such that denominator is coprime with it is that if we want to add two fractions together and calculate the result modulo some number we can convert these fractions beforehand and then just add them as integer numbers The same works with subtracting multiplying dividing and exponentiating fractions Okay now for the solution itself We know that there are at most possible pairs of we can iterate on these pairs calculate the probability that the fixed pair is included in the robot s decision that probability is and calculate the probability that extends to a valid triple it is equal to where is the number of kids who want item Multiplying these two probabilities we get the probability that is chosen produces a valid decision since these events are independent and we sum up these values over all possible pairs 
https://codeforces.com//contest/899/problem/F,139225,F,899F,899,F. Letters Removing,Petya has a string of length consisting of small and large English letters and digits He performs operations Each operation is described with two integers and and a character Petya removes from the string all characters on positions between and inclusive It s obvious that the length of the string remains the same or decreases after each operation Find how the string will look like after Petya performs all operations ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int M=(int)2e5+5;\nset<int>st[128];\nset<int>::iterator it,it1;\nchar S[M],A[5];\nint n,m;\nint mark[M];\nint val[M*4];\nvoid build(int L,int R,int p){\n\tval[p]=R-L+1;\n\tif(L==R)return;\n\tint mid=(L+R)>>1;\n\tbuild(L,mid,p<<1),build(mid+1,R,p<<1|1);\n}\nvoid update(int L,int R,int p,int x){\n\tval[p]--;\n\tif(L==R)return;\n\tint mid=(L+R)>>1;\n\tif(mid>=x)update(L,mid,p<<1,x);\n\telse update(mid+1,R,p<<1|1,x);\n}\nint query(int L,int R,int p,int v){\n\tif(L==R)return L;\n\tint mid=(L+R)>>1;\n\tif(val[p<<1]>=v)return query(L,mid,p<<1,v);\n\telse return query(mid+1,R,p<<1|1,v-val[p<<1]);\n}\nint main(){\n\tscanf(""%d %d"",&n,&m);\n\tbuild(1,n,1);\n\tscanf(""%s"",S+1);\n\tfor(int i=1;i<=n;i++)st[(int)S[i]].insert(i);\n\tfor(int i=1,l,r,x;i<=m;i++){\n\t\tscanf(""%d %d"",&l,&r);\n\t\tl=query(1,n,1,l);\n\t\tr=query(1,n,1,r);\n\t\tscanf(""%s"",A);\n\t\tx=A[0];\n\t\tfor(it=st[x].lower_bound(l);it!=st[x].end()&&(*it)<=r;){\n\t\t\tit1=it;\n\t\t\tupdate(1,n,1,(*it1));\n\t\t\tit++;\n\t\t\tst[x].erase(it1);\n\t\t}\n\t}\n\tfor(int i=0;i<128;i++)\n\t\tfor(it=st[i].begin();it!=st[i].end();it++)\n\t\t\tmark[(*it)]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(mark[i])\n\t\t\tputchar(S[i]);\n\tputchar(\'\\n\');\n\treturn 0;\n}\n']",,,"['data structures', 'strings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Letters Removing.json,https://codeforces.com//blog/entry/56392,For each character we should use set where we will store positions of all non deleted characters Let the next query equals to Then at first we should transform the given positions and to the positions of the initial string taking into account already deleted characters We can do it with help of segments tree or sqrt decomposition After we transformed and we should find the first position in set for character with help of lower bound which is in range and remove positions from the corresponding set until they are in range Also we need to update information in data structure which we use to transform the given in the query and to the positions in the initial string This algorithm will fit into the time limit because we will delete each position no more than once After we process all queries we should iterate through all sets find all non deleted positions and print characters which are in that positions in the initial string do not forget before that to sort all non deleted positions in increasing order 
https://codeforces.com//contest/1934/problem/E,2505364,E,1934E,1934,E. Weird LCM Operations,Given an integer n you construct an array a of n integers where a i i for all integers i in the range 1 n An operation on this array is defined as follows Select three distinct indices i j and k from the array and let x a i y a j and z a k Update the array as follows a i operatorname lcm y z a j operatorname lcm x z and a k operatorname lcm x y where operatorname lcm represents the least common multiple Your task is to provide a possible sequence of operations containing at most lfloor frac n 6 rfloor 5 operations such that after executing these operations if you create a set containing the greatest common divisors GCDs of all subsequences with a then all numbers from 1 to n should be present in this set After all the operations a i le 10 18 should hold for all 1 le i le n We can show that an answer always exists ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define int long long\n\nconst int N=2e3+5;\n\nvoid solve() {\n    int n;\n    cin>>n;\n    vector<tuple<int,int,int>>ans;\n    int now=n,low=n/2+2;\n    while(now!=2){\n        if(now<=low){\n            ans.emplace_back(1,now-1,now);\n            break;\n        }\n        if(now%4==0)ans.emplace_back(now/2-1,now-1,now);\n        else if(now%2==0)ans.emplace_back(now/2,now-2,now-1);\n        else ans.emplace_back(now-2,now-1,now);\n        now-=3;\n    }\n    cout<<ans.size()<<endl;\n    for(auto [i,j,k]:ans)cout<<i<<' '<<j<<' '<<k<<endl;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int T=1;\n    cin>>T;\n    while(T--){\n        solve();\n    }\n}""]",,,"['brute force', 'constructive algorithms', 'number theory']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Weird LCM Operations.json,https://codeforces.com//blog/entry/126423,SolutionFact 1 If for their pairwise GCDs are equal to their common GCD this means that where are pairwise coprime then making an operation on them gives and looking at the subsequences of size EXACTLY 2 we find all three GCD Let s call such tuple NICE Result If we can split all values in the array into independent NICE tuples then we can just perform an operation on each of them and the problem is solved Fact 2 We don t touch any value If there is then If we don t touch then we will always have another value that is divisible by it s easy to see that performing an operation on a multiple of leaves us with another multiple of so we will always have GCD equal to taking a subsequence Fact 3 A sequence of consecutive integers can be partitioned into disjoint sets of size each forming a NICE tuple if equals or For The sets and are NICE because the first and third terms are always odd and the second term is always even The set is NICE because it has the form of ensuring that the pairwise GCDs are equal to the common GCD For The sets and are NICE the same logic like follows If we can do one operation as and if we can do one operation as Let s group the remaining elements into the groups of size starting from the end and continuing until we reach the number Eventually we can count that we used no more than operations Solutions for should be found manually 
https://codeforces.com//contest/1452/problem/C,802106,C,1452C,1452,C. Two Brackets,You are given a string s consisting of brackets of two types and A string is called a regular bracket sequence RBS if it s of one of the following types empty string RBS RBS RBS RBS where plus is a concatenation of two strings In one move you can choose a non empty subsequence of the string s not necessarily consecutive that is an RBS remove it from the string and concatenate the remaining parts without changing the order What is the maximum number of moves you can perform ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nchar A[202020];\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%s"", A + 1);\n\t\tN = strlen(A + 1);\n\t\tint a = 0, b = 0;\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tif(A[i] == \'(\') a++;\n\t\t\telse if(A[i] == \'[\') b++;\n\t\t\telse if(A[i] == \')\') {\n\t\t\t\tif(a > 0) { a--; ans++; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(b > 0) { b--; ans++; }\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}']",,,['greedy'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Two Brackets.json,https://codeforces.com//blog/entry/84847,Notice that it s never optimal to erase a subsequence of length greater than because every RBS of length above contains an RBS of length inside and removing it won t break the regular property of the outside one So the task can be solved for the round and the square brackets independently the answer will be the sum of both Let s solve the version for brackets and In general you just want to remove consecutive substring until there is no more left in the string That can be done by processing the string from left and right and maintaining a stack of current brackets If the top bracket in it is and the current bracket is then you can increment the answer and remove that bracket from the stack Otherwise you push the current bracket to the stack Overall complexity per testcase 
https://codeforces.com//contest/1980/problem/E,2679077,E,1980E,1980,E. Permutation of Rows and Columns,You have been given a matrix a of size n by m containing a permutation of integers from 1 to n cdot m A permutation of n integers is an array containing all numbers from 1 to n exactly once For example the arrays 1 2 1 3 5 4 3 2 1 are permutations while the arrays 1 1 100 1 2 4 5 are not A matrix contains a permutation if when all its elements are written out the resulting array is a permutation Matrices 1 2 3 4 1 1 5 3 2 6 4 contain permutations while matrices 2 1 1 2 2 1 2 100 200 do not You can perform one of the following two actions in one operation choose columns c and d 1 le c d le m c ne d and swap these columns choose rows c and d 1 le c d le n c ne d and swap these rows You can perform any number of operations You are given the original matrix a and the matrix b Your task is to determine whether it is possible to transform matrix a into matrix b using the given operations ,"['#include <bits/stdc++.h>using namespace std;\xa0int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n, m; cin >> n >> m;        vector a(n, vector<int>(m)), b(n, vector<int>(m));        for (auto &v: a) for (int &x: v) cin >> x;        for (auto &v: b) for (int &x: v) cin >> x;        map<int, int> ai, aj;        map<int, vector<int>> imp, jmp;        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = a[i][j];                ai[x] = i, aj[x] = j;            }        }        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = b[i][j];                imp[ai[x]].push_back(i), jmp[aj[x]].push_back(j);            }        }        bool ans = true;        for (auto [_, v]: imp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        for (auto [_, v]: jmp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        cout << (ans ? ""YES"" : ""NO"") << ""\\n"";    }}']",,,"['constructive algorithms', 'data structures', 'greedy', 'hashing', 'implementation', 'math', 'matrices', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Permutation of Rows and Columns.json,https://codeforces.com//blog/entry/130135,For each element you can calculate its positions in both matrices You can see that the rearrangement of rows does not affect the column positions of the elements being rearranged Similarly column rearrangement does not affect row positions Since the permutation of rows affects the entire rows for all elements that have the same position row in the original matrix the position row in the resulting matrix must also match Similarly the columns must match In order to check the coincidence of rows and columns let s count 4 arrays the positions of rows and columns in the original and received matrices Then you need to check that for all with the same row value in the original matrix the row values in the resulting matrix are the same Similarly the values of the columns should be the same 
https://codeforces.com//contest/1991/problem/B,2781502,B,1991B,1991,B. AND Reconstruction,You are given an array b of n 1 integers An array a of n integers is called if b i a i a i 1 for 1 le i le n 1 where denotes the bitwise AND operator Construct a good array or report that no good arrays exist ,"['/** *    author:  tourist *    created: 28.07.2024 10:36:13**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    vector<int> b(n - 1);    for (int i = 0; i < n - 1; i++) {      cin >> b[i];    }    vector<int> a(n);    for (int i = 0; i < n; i++) {      a[i] = (i == 0 ? 0 : b[i - 1]) | (i == n - 1 ? 0 : b[i]);    }    bool ok = true;    for (int i = 0; i < n - 1; i++) {      ok &= (b[i] == (a[i] & a[i + 1]));    }    if (ok) {      for (int i = 0; i < n; i++) {        cout << a[i] << "" \\n""[i == n - 1];      }    } else {      cout << -1 << \'\\n\';    }  }  return 0;}']",,,"['bitmasks', 'constructive algorithms', 'greedy']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. AND Reconstruction.json,https://codeforces.com//blog/entry/132021,Let s construct an array a using the formula ai bi 1 bi assuming b0 and bn are 0 We then verify the condition bi ai ai 1 for 1 i n If any condition fails then such an array a does not exist Explanation Using the above construction method we get ai ai 1 bi 1 bi bi bi 1 bi bi 1 bi 1 If for any i bi bi 1 bi 1 bi then the constructed array a does not satisfy the required condition This indicates that there exists a bit in b where bi 1 1 bi 0 and bi 1 1 which can prove there is no solution Proof If ai 2 ai 1 bi 1 1 then ai 1 1 Similarly since ai ai 1 bi 1 then ai 1 However ai 1 ai 1 1 1 which contradicts bi 0 Therefore this configuration is unsolvable This shows that our construction method can construct a valid array a except in cases where the above bit configuration in b makes it unsolvable 
https://codeforces.com//contest/1228/problem/C,424244,C,1228C,1228,C. Primes and Multiplication,Let s introduce some definitions that will be needed later Let prime x be the set of prime divisors of x For example prime 140 2 5 7 prime 169 13 Let g x p be the maximum possible integer p k where k is an integer such that x is divisible by p k For example g 45 3 9 45 is divisible by 3 2 9 but not divisible by 3 3 27 g 63 7 7 63 is divisible by 7 1 7 but not divisible by 7 2 49 Let f x y be the product of g y p for all p in prime x For example f 30 70 g 70 2 cdot g 70 3 cdot g 70 5 2 1 cdot 3 0 cdot 5 1 10 f 525 63 g 63 3 cdot g 63 5 cdot g 63 7 3 2 cdot 5 0 cdot 7 1 63 You have integers x and n Calculate f x 1 cdot f x 2 cdot ldots cdot f x n bmod 10 9 7 ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int P = 1000000007;\n\nint mpow(int x, ll k, int p = P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll)x % p;\n    x = x * (ll)x % p;\n    k >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  int x;\n  ll n;\n\n  scanf(""%d%lld"", &x, &n);\n  int y = x;\n  int ans = 1;\n  function<void(int, int)> gao = [&](int p, int pk) {\n    ll v = 0, nn = n;\n    while (nn) {\n      v += (nn /= p);\n    }\n    ans = ans * (ll)mpow(p, v) % P;\n  };\n  for (int v = 2; v * v <= y; ++v)\n    if (y % v == 0) {\n      int pk = 1;\n      while (y % v == 0) {\n        y /= v;\n        pk *= v;\n      }\n      gao(v, pk);\n    }\n  if (y != 1)\n    gao(y, y);\n  printf(""%d\\n"", ans);\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']",,,"['math', 'number theory']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Primes and Multiplication.json,https://codeforces.com//blog/entry/70162,Let s say then Because if we describe and then Now let s go to the main step So we have to count for each in and calculate exponents You can count by following formula Fortunately since never exceeds we don t have to apply Euler s theorem here You just have to be careful about overflow issue Roughly calculated time complexity is because you use to get prime divisors of and the number of distinct prime divisors of is approximately 
https://codeforces.com//contest/354/problem/E,3670,E,354E,354,E. Lucky Number Representation,We know that lucky digits are digits and however Vasya s got another favorite digit and he assumes it also is lucky Lucky numbers are such integers whose decimal record only contains lucky digits For example numbers are lucky but are not Vasya has important positive integers he needs to remember Vasya is quite superstitious and he wants to remember lucky numbers only so he is asking you for each important number to represent it as a sum of exactly six lucky numbers Vasya just can t remember more numbers Then Vasya can just remember these six numbers and calculate the important number at any moment For each of important integers represent it as the sum of six lucky numbers or state that this is impossible ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint a[30];\nbool dp[30][10]; // pos, carry\nint c4[30][10],c7[30][10];\n\nll ten[20];\nll ans[10];\n\nvoid func(void){\n    int i,j,k,p,q;\n    \n    REP(i,30) REP(j,10) dp[i][j] = false;\n    dp[20][0] = true;\n    \n    for(i=19;i>=0;i--) REP(j,5){\n        REP(p,7) REP(q,7-p){\n            if((4*p+7*q+j) % 10 == a[i]){\n                int carry = (4*p+7*q+j) / 10;\n                if(dp[i+1][carry]){\n                    c4[i][j] = p;\n                    c7[i][j] = q;\n                    dp[i][j] = true;\n                }\n            }\n        }\n    }\n    \n    if(!dp[0][0]){\n        printf(""-1\\n"");\n        return;\n    }\n    \n    REP(i,6) ans[i] = 0;\n    i = 0; j = 0;\n    \n    while(i <= 18){\n        p = c4[i][j];\n        q = c7[i][j];\n        REP(k,p) ans[k] += ten[i] * 4;\n        REP(k,q) ans[p+k] += ten[i] * 7;\n        j = (4*p+7*q+j) / 10;\n        i++;\n    }\n    \n    REP(i,6){\n        printf(""%I64d"", ans[i]);\n        if(i == 5) printf(""\\n""); else printf("" "");\n    }\n}\n\nint main(void){\n    int Q,i,j;\n    ll N;\n    \n    ten[0] = 1;\n    for(i=1;i<=18;i++) ten[i] = ten[i-1] * 10;\n    \n    cin >> Q;\n    \n    REP(i,Q){\n        cin >> N;\n    //  cout << N << endl;\n        REP(j,20){\n            a[j] = (int)(N % 10);\n            N /= 10;\n        }\n        func();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'dfs and similar', 'dp']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Lucky Number Representation.json,https://codeforces.com//blog/entry/8672,First of all let write a DP with complexity where is the count of lucky numbers As we can see for all sufficiently large solution exists Really for every Now we can say that for we have a solution which is found using DP Let s solve the task for larger values of Next and key idea is to separate the task into two parts Let s choose and in such way that for them it was easy to find a solution and then merge these two solutions into one Let Here we can have a problem that there is no solution for number in this case we can do Now it is guaranteed that solutions exists for both and moreover the solution for number will contain only numbers of not more than 3 digits The proof is quite easy if it is obvious else if the solution uses some number of the form we can replace it with just and receive a correct solution for number but is doesn t exist So the solution for number we have found using DP now let s find the solution for If it will contains only of numbers of the form then we will be able to easily merge this solution with solution for so let s find such a solution Here we will use the fact that is divisible by 4 For simplicity let s divide by 1000 and in the end multiply all by the same 1000 Let Now let s construct the solution Consider for example P 95 we will walk through digits of this number last digit 5 means that we want to put digit 4 at the last decimal position of five answer numbers ok put it and in the last sixth number leave there digit 0 Go forward digit 9 we don t have nine numbers but we can replace seven fours with four sevens then to the second position we have to put fours and 4 sevens in total 6 numbers exactly as much as we have Thus if next digit we just put to the first answer numbers digit 4 to the next position if then we put 4 sevens and fours In all other numbers we just leave digit 0 at this position If answer for for the the answer for will be just Time complexity for one number During the competition many participants have wrote the following solution can we put the digit to the last decimal positions of the answer number in such way that we will get correct last digits in the sum and with carry to the next position equals to Then the solution exist iff To restore the answer we just have to remember for each state the previous state Base Transition brute force how many fours and sevens we will put to the th position 
https://codeforces.com//contest/745/problem/B,85235,B,745B,745,B. Hongcow Solves A Puzzle,Hongcow likes solving puzzles One day Hongcow finds two identical puzzle pieces with the instructions make a rectangle next to them The pieces can be described by an by grid of characters where the character denotes a part of the puzzle and denotes an empty part of the grid It is guaranteed that the puzzle pieces are one 4 connected piece See the input format and samples for the exact details on how a jigsaw piece will be specified The puzzle pieces are very heavy so Hongcow the puzzle pieces However he is allowed to move them in any directions The puzzle pieces also You are given as input the description of one of the pieces Determine if it is possible to make a rectangle from two identical copies of the given input The rectangle should be solid i e there should be no empty holes inside it or on its border Keep in mind that Hongcow is not allowed to flip or rotate pieces and they cannot overlap i e no two from different pieces can share the same position ,"['#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define FORU(i,j,k) for(int i=(j);i<=(k);++i)\n#define FORD(i,j,k) for(int i=(j);i>=(k);--i)\n\nusing namespace std;\n\nusing lli = long long int;\nusing pll = pair<lli, lli>;\n\nconst long long int oo = 1000*1000*1000;\n\nstruct Coord\n{\n\tint x, y;\n\tCoord(int x = 0, int y = 0) : x(x), y(y) {}\n\tCoord operator + (const Coord& droite) const\n\t{\n\t\treturn Coord(x + droite.x, y + droite.y);\n\t}\n};\n\nbool grid[1000][1000];\nint minX = 1000, minY = 1000;\nint maxX, maxY;\n\nint main()\n{\n\tint n, m;\n\tscanf(""%d%d"", &n, &m);\n\tFOR(i, n)\n\t\tFOR(j, m)\n\t\t{\n\t\t\tchar tmp;\n\t\t\tscanf("" %c"", &tmp);\n\t\t\tgrid[i][j] = tmp == \'X\';\n\t\t\tif(grid[i][j])\n\t\t\t{\n\t\t\t\tminX = min(minX, i);\n\t\t\t\tmaxX = max(maxX, i);\n\t\t\t\tminY = min(minY, j);\n\t\t\t\tmaxY = max(maxY, j);\n\t\t\t}\n\t\t}\n\tFORU(i, minX, maxX)\n\t\tFORU(j, minY, maxY)\n\t\t\tif(!grid[i][j])\n\t\t\t{\n\t\t\t\tprintf(""NO\\n"");\n\t\t\t\treturn 0;\n\t\t\t}\n\tprintf(""YES\\n"");\n\treturn 0;\n}\n']",,,['implementation'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Hongcow Solves A Puzzle.json,https://codeforces.com//blog/entry/49126,I really apologize for the ambiguity of this problem We worked hard to make it concise and accurate but we left out too many details Basically the idea is we want to overlay two of these pieces together so that no square has more than 1 X and the region of X s forms a rectangle Now for the solution First let s look at it backwards I have a rectangle and I cut it in two pieces These two pieces have the same exact shape What shapes can I form A necessary and sufficient condition is that the piece itself is a rectangle itself There are a few ways to check this One is find the min max x y coordinates and make sure the number of X s match the bounding box of all the points code 
https://codeforces.com//contest/1020/problem/A,207008,A,1020A,1020,A. New Building for SIS,You are looking at the floor plan of the Summer Informatics School s new building You were tasked with SIS logistics so you really care about travel time between different locations it is important to know how long it would take to get from the lecture room to the canteen or from the gym to the server room The building consists of towers floors each where the towers are labeled from to the floors are labeled from to There is a passage between any two adjacent towers two towers and for all on every floor where It takes exactly one minute to walk between any two adjacent floors of a tower as well as between any two adjacent towers provided that there is a passage on that floor It is not permitted to leave the building You have given pairs of locations floor of tower and floor of tower For each pair you need to determine the minimum walking time between these locations ,"['#include <bits/stdc++.h>\n#define sz(x) ((int)x.size())\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint n, h, a, b, Q;\nint main() {\n\tscanf(""%d%d%d%d%d"",&n,&h,&a,&b,&Q);\n\twhile(Q--) {\n\t\tint x1,y1,x2,y2;\n\t\tscanf(""%d%d%d%d"",&x1,&y1,&x2,&y2);\n\t\tif(x1 == x2) printf(""%d\\n"",abs(y1-y2));\n\t\telse {\n\t\t\tint d1;\n\t\t\tif(a<=y1 && y1<=b) d1 = y1;\n\t\t\telse if(y1 > b) d1 = b;\n\t\t\telse d1 = a;\n\t\t\tprintf(""%d\\n"",abs(d1-y1)+abs(x1-x2)+abs(d1-y2));\n\t\t}\n\t}\n\treturn 0;\n}']",,,['math'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. New Building for SIS.json,https://codeforces.com//blog/entry/61161,In this problem you need to find a shortest path between some locations in a building You need to look at some cases to solve this problem First if locations are in the same tower you don t need to use a passages between two towers at all and answer is In other case you have to use some passage between towers Obviously you need to use only passage on one floor The easiest way to do this is to write down floors in array the floor where you start the floor where you end your path first and last floors with passages After that you can choose floor where you will use a passage check if there is a passage at this floor and update answer with an expression like Another method is to choose a floor where you use a passage by case handling If you start on the floor and there is a passage you can just use this passage Otherwise you choose between floors and whichever is closer to the start 
https://codeforces.com//contest/875/problem/B,128559,B,875B,875,B. Sorting the Coins,Recently Dima met with Sasha in a philatelic store and since then they are collecting coins together Their favorite occupation is to sort collections of coins Sasha likes having things in order that is why he wants his coins to be arranged in a row in such a way that firstly come coins out of circulation and then come coins still in circulation For arranging coins Dima uses the following algorithm One step of his algorithm looks like the following He looks through all the coins from left to right If he sees that the th coin is still in circulation and th coin is already out of circulation he exchanges these two coins and continues watching coins from th Dima repeats the procedure above until it happens that no two coins were exchanged during this procedure Dima calls the number of steps required for him according to the algorithm above to sort the sequence e g the number of times he looks through the coins from the very beginning For example for the ordered sequence hardness of ordering equals one Today Sasha invited Dima and proposed him a game First he puts coins in a row all of them are out of circulation Then Sasha chooses one of the coins out of circulation and replaces it with a coin in circulation for times During this process Sasha constantly asks Dima what is the hardness of ordering of the sequence The task is more complicated because Dima should not touch the coins and he should determine hardness of ordering in his mind Help Dima with this task ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,x[300010],p;\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k;\n\tscanf(""%d"",&n);\n\tprintf(""1"");\n\tfor(i=1,k=n;i<=n;i++)\n\t  {\n\t   scanf(""%d"",&j);\n\t   x[j]=1;\n\t   p++;\n\t   while(x[k])\n\t     k--,p--;\n\t   printf("" %d"",p+1);\n\t  }\n\tprintf(""\\n"");\n\treturn 0;\n}\n']",,,"['dsu', 'implementation', 'sortings', 'two pointers']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Sorting the Coins.json,https://codeforces.com//blog/entry/55233,We denote for 0 a coin that has left circulation and for one coin in circulation We solve the problem for a fixed array If it consists of only 1 then the answer is 0 since the array is already sorted Otherwise consider the most right zero If there is not a single 1 to the left of this zero then the array is already sorted and the answer is Let 1 appears times to the left of the rightmost zero For one iteration the nearest 1 on the left will move to the position of this zero and zero will move one position to the left After this iteration ones will remain to the left of the rightmost zero Hence the answer is Let us return to the original problem We will keep the pointer to the rightmost zero Since as a result of queries the zeros only disappear the pointer moves only to the left If the rightmost zero has disappeared move the pointer to the left by a cycle until we find the next zero Consider pointer is at the position numeration from zero and there are only ones in the array On the right of all the symbols are ones so on the right there are only ones So on the left are ones This solution works in 
https://codeforces.com//contest/1670/problem/A,1390321,A,1670A,1670,A. Prof. Slim,Given an array of n integers a 1 a 2 ldots a n check if you can make this array sorted by using the following operation any number of times possibly zero An array is sorted if its elements are arranged in a non decreasing order select two indices i and j 1 le i j le n such that a i and a j have In other words one must be positive and one must be negative swap the of a i and a j For example if you select a i 3 and a j 2 then they will change to a i 3 and a j 2 Prof Slim saw that the problem is still too easy and isn t worth his time so he decided to give it to you to solve ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint a[1000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tif(a[i]<0) ++cnt;\n\t\t\ta[i]=max(a[i],-a[i]);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i<=cnt) a[i]*=-1;\n\t\tint flag=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tif(a[i]<a[i-1]) flag=0;\n\t\tif(flag) cout << ""YES\\n"";\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Prof. Slim.json,https://codeforces.com//blog/entry/102579,We can notice that to make the array sorted we must move all the negative signs to the beginning of the array So let s say the number of negative elements is Then we must check that the first elements are non increasing and the remaining elements are non decreasing Complexity is 
https://codeforces.com//contest/369/problem/A,4123,A,369A,369,A. Valera and Plates,Valera is a lazy student He has clean bowls and clean plates Valera has made an eating plan for the next days As Valera is lazy he will eat exactly one dish per day At that in order to eat a dish he needs exactly one plate or bowl We know that Valera can cook only two types of dishes He can eat dishes of the first type from bowls and dishes of the second type from either bowls or plates When Valera finishes eating he leaves a dirty plate bowl behind His life philosophy doesn t let him eat from dirty kitchenware So sometimes he needs to wash his plate bowl Find the minimum number of times Valera will need to wash a plate bowl if he acts optimally ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define lowbit(x) ((x) & (-(x)))\nusing namespace std;\ntypedef long long LL;\nconst int N = 1005;\nint n , m , k , a[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n    #endif\n    int ans = 0;\n    cin >> n >> m >> k;\n    for (int i = 0 ; i < n ; i ++) {\n        cin >> a[i];\n        if (a[i] == 2) {\n            if (k) k --;\n            else if (m) m --;\n            else ans ++;\n        }\n        else if (a[i] == 1) {\n            if (m) m --;\n            else ans ++;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;  \n}']",,,"['greedy', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Valera and Plates.json,https://codeforces.com//blog/entry/9760,We will use greedy algorithm Let s now th day and current dish is a dish of first type Then if we have the bowl let s use it Otherwise we will increase the answer If the current dish is a dish of the second type we first try to get the plate and then the bowl If there are no plates bowls at all then we will increase the answer Author s solution 5306397 
https://codeforces.com//contest/1517/problem/H,965878,H,1517H,1517,H. Fly Around the World,After hearing the story of Dr Zhang Wowo decides to plan his own flight around the world He already chose n checkpoints in the world map Due to the landform and the clouds he cannot fly too high or too low Formally let b i be the height of Wowo s aircraft at checkpoint i x i le b i le x i should be satisfied for all integers i between 1 and n where x i and x i are given integers The angle of Wowo s aircraft is also limited For example it cannot make a 90 degree climb Formally y i le b i b i 1 le y i should be satisfied for all integers i between 2 and n where y i and y i are given integers The final limitation is the speed of angling up or angling down An aircraft should change its angle slowly for safety concerns Formally z i le b i b i 1 b i 1 b i 2 le z i should be satisfied for all integers i between 3 and n where z i and z i are given integers Taking all these into consideration Wowo finds that the heights at checkpoints are too hard for him to choose Please help Wowo decide whether there exists a sequence of numbers b 1 ldots b n satisfying all the contraints above ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\n// mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \nmt19937 rng(0);\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n// ll abs(ll x) {\n// \tif (x < 0) x *= -1;\n// \treturn x;\n// }\n\n// ll __gcd(ll a, ll b) {\n// \tif (a == 0) return b;\n// \treturn __gcd(b%a,a);\n// }\n\n// str ts(ll x) { return ts((long long)x); }\n\nstruct frac {\n\tll n,d;\n\tfrac(ll _n, ll _d) {\n\t\tn = _n, d = _d;\n\t\tll g = __gcd(n,d); n /= g, d /= g;\n\t\tif (d < 0 || (d == 0 && n == -1)) n *= -1, d *= -1;\n\t}\n\tfrac(ll _n) : frac(_n,1) {}\n\tfrac() : frac(0) {}\n\tfriend frac abs(frac F) { return frac(abs(F.n),F.d); }\n\tfriend str ts(const frac& a) { return ts(a.n)+""/""+ts(a.d); }\n \n\tfriend bool operator<(const frac& l, const frac& r) { \n\t\tassert(l.d == 1 || r.d == 1);\n\t\treturn l.n*r.d < r.n*l.d; }\n\tfriend bool operator>(const frac& l, const frac& r) { \n\t\tassert(l.d == 1 || r.d == 1);\n\t\treturn l.n*r.d > r.n*l.d; }\n\tfriend bool operator==(const frac& l, const frac& r) { return l.n == r.n && l.d == r.d; }\n\tfriend bool operator!=(const frac& l, const frac& r) { return !(l == r); }\n \n\tfrac operator-() const { return frac(-n,d); }\n\tfriend frac operator+(const frac& l, const frac& r) { return frac(l.n*r.d+r.n*l.d,l.d*r.d); }\n\tfriend frac operator-(const frac& l, const frac& r) { return frac(l.n*r.d-r.n*l.d,l.d*r.d); }\n\tfriend frac operator*(const frac& l, const frac& r) { return frac(l.n*r.n,l.d*r.d); }\n\tfriend frac operator*(const frac& l, int r) { return l*frac(r,1); }\n\tfriend frac operator*(int r, const frac& l) { return l*r; }\n\tfriend frac operator/(const frac& l, const frac& r) { return l*frac(r.d,r.n); }\n\tfriend frac operator/(const frac& l, const int& r) { return l/frac(r,1); }\n\tfriend frac operator/(const int& l, const frac& r) { return frac(l,1)/r; }\n \n\tfriend frac& operator+=(frac& l, const frac& r) { return l = l+r; }\n\tfriend frac& operator-=(frac& l, const frac& r) { return l = l-r; }\n\ttemplate<class T> friend frac& operator*=(frac& l, const T& r) { return l = l*r; }\n\ttemplate<class T> friend frac& operator/=(frac& l, const T& r) { return l = l/r; }\n};\n\n\nbool flag;\n\nnamespace mine {\n/**\n * Description: Operations with fractions\n * Source: https://martin-thoma.com/fractions-in-cpp/\n * Verification: TopCoder MinimizeAbsoluteDifferenceDiv1\n */\n\n// https://codeforces.com/blog/entry/89968\n\nstruct Tag {\n\tll c, delta_x, delta_y;\n\t// transformation:\n\t// {x,y} -> {x+c*y+delta_x,y+delta_y}\n\n\t// this + t -> {(x+c*y+delta_x)+t.c*(y+delta_y)+t.delta_x,(y+delta_y)+t.delta_y}\n\tTag with_tag(Tag t) { // OK\n\t\treturn {c+t.c,delta_x+t.c*delta_y+t.delta_x,delta_y+t.delta_y};\n\t}\n\tTag inv() { // OK\n\t\treturn {-c,c*delta_y-delta_x,-delta_y};\n\t}\n\tfriend str ts(const Tag& t) { \n\t\treturn ""{c: ""+ts(t.c)+"", delta_x:""+ts(t.delta_x)+ts("", delta_y:"")+ts(t.delta_y)+""}""; \n\t}\n};\n\nTag undo_front(Tag a, Tag result) { // OK\n\tll t_c = result.c-a.c;\n\treturn {t_c,result.delta_x-a.delta_x-t_c*a.delta_y,result.delta_y-a.delta_y};\n}\n\n// a.delta_x+t.c*a.delta_y+t.delta_x = result.delta_x\n// a.delta_y+t.delta_y = result.delta_y\n// a.c+t.c = result.c\n\n// result.c-a.c, result.delta_x-a.delta_x-(result.c-a.c)*a.delta_y, result.delta_y-a.delta_y\n\nconst Tag ID{0,0,0};\nTag tag_x_plus_y() { return {1,0,0}; }\nTag tag_z(int z) { return {0,z,z}; }\n\nint N;\n\nstruct Vertex {\n\tll x,y,k;\n\tVertex(ll _x, ll _y, ll _k) {\n\t\tassert(_k > 0);\n\t\tll g = __gcd(__gcd(abs(_x),abs(_y)),_k);\n\t\tx = _x/g;\n\t\ty = _y/g;\n\t\tk = _k/g;\n\t\t// if (!(k <= N)) dbg(""HUH"",_x,_y,_k,x,y,k);\n\t\t// assert(k <= N);\n\t\tassert(abs(x) <= (ll)1e14);\n\t\tassert(abs(y) <= (ll)1e14);\n\t}\n\tVertex(ll _x, frac _y) : Vertex(_x*_y.d,_y.n,_y.d) {}\n\tVertex(frac _x, ll _y) : Vertex(_x.n,_y*_x.d,_x.d) {}\n\tVertex(ll _x, ll _y) : Vertex(_x,_y,1) {}\n\tVertex with_tag(Tag t) { return Vertex(x+t.c*y+t.delta_x*k,y+t.delta_y*k,k); }\n\tbool operator==(const Vertex& o) { return x == o.x && y == o.y && k == o.k; }\n\tfrac get_x() const { return frac(x,k); }\n\tfrac get_y() const { return frac(y,k); }\n\tfriend str ts(const Vertex& v) { \n\t\tV<frac> fracs{v.get_x(),v.get_y()};\n\t\treturn ts(fracs);\n\t}\n};\n\nfrac slope_between (Vertex a, Vertex b) {\n\t// (a.y/a.k-b.y/b.k)/(a.x/a.k-b.x/b.k)\n\tll num = a.y*b.k-b.y*a.k;\n\tll den = a.x*b.k-b.x*a.k;\n\tfrac res = frac(num,den);\n\t// dbg(res);\n\tassert(res.n == 1 || res.n == 0);\n\treturn res;\n}\n\nbool flag;\n\nVertex isect_x(Vertex a, Vertex b, int x) {\n\tif (flag) dbg(""ISECT X"",a,b,x);\n\tVertex result2{0,0,1};\n\tfrac _slope = slope_between(a,b);\n\tif (_slope.n == 0) {\n\t\treturn Vertex(x*a.k,a.y,a.k);\n\t}\n\tll slope = _slope.d;\n\treturn Vertex(x*a.k*slope,x*a.k+a.y*slope-a.x,a.k*slope);\n}\n\nVertex isect_y(Vertex a, Vertex b, int y) {\n\tfrac _slope = slope_between(a,b); \n\tll slope = _slope.d;\n\tll x_intercept = a.x-slope*a.y; // over a.k\n\tVertex result = Vertex(slope*y*a.k+x_intercept,y*a.k,a.k);\n\treturn result;\n}\n\nvoid apply_tag(Tag& a, Tag b) {\n\ta = a.with_tag(b);\n}\n\n\nbool collinear(Vertex a, Vertex b, Vertex c) {\n\tfrac f = (b.get_y()-a.get_y())*(c.get_x()-a.get_x())-(b.get_x()-a.get_x())*(c.get_y()-a.get_y());\n\treturn f.n == 0;\n}\n\nstruct Hull {\n\tdeque<pair<Vertex,Tag>> verts;\n\t// tag should be applied to vertex and everything before it\n\tTag prod = ID;\n\tHull() {}\n\tHull(V<Vertex> _verts) { // OK\n\t\tfor (Vertex v: _verts) add_back(v);\n\t}\n\tVertex get_back() { // OK\n\t\tassert(!verts.empty());\n\t\treturn verts.bk.f.with_tag(verts.bk.s);\n\t}\n\tVertex get_front() { // OK\n\t\tassert(!verts.empty());\n\t\treturn verts.ft.f.with_tag(prod);\n\t}\n\tvoid apply_back(Tag t) { // OK\n\t\tassert(!verts.empty());\n\t\tapply_tag(verts.bk.s,t);\n\t\tapply_tag(prod,t);\n\t}\n\tvoid x_plus_y() { // OK\n\t\tapply_back(tag_x_plus_y());\n\t}\n\tvoid advance_z(int z) { // OK\n\t\tapply_back(tag_z(z));\n\t}\n\tVertex poll_front() { // OK\n\t\tVertex v = get_front();\n\t\tprod = undo_front(verts.ft.s,prod);\n\t\tverts.pop_front();\n\t\tassert(sz(verts));\n\t\treturn v;\n\t}\n\tVertex poll_back() { // OK\n\t\tVertex v = get_back();\n\t\tTag last_tag = verts.bk.s;\n\t\tverts.pop_back(); assert(sz(verts));\n\t\tapply_tag(verts.bk.s,last_tag);\n\t\treturn v;\n\t}\n\tfrac get_front_x() { return get_front().get_x(); }\n\tfrac get_front_y() { return get_front().get_y(); }\n\tfrac get_back_x() { return get_back().get_x(); }\n\tfrac get_back_y() { return get_back().get_y(); }\n\tvoid add_front(Vertex v) {\n\t\tif (!verts.empty() && v == get_front()) return;\n\t\tverts.push_front({v,prod.inv()}); prod = ID;\n\t}\n\tvoid add_back(Vertex v) {\n\t\tif (!verts.empty() && v == get_back()) return;\n\t\tverts.pb({v,ID});\n\t}\n\tvoid cut_y_lower(int yl) {\n\t\twhile (get_front_y() < yl) {\n\t\t\tVertex v = poll_front();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_front_y() > yl)\n\t\t\t\tadd_front(isect_y(v,get_front(),yl));\n\t\t}\n\t}\n\tvoid cut_y_upper(int yu) {\n\t\twhile (get_back_y() > yu) {\n\t\t\tVertex v = poll_back();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_back_y() < yu)\n\t\t\t\tadd_back(isect_y(v,get_back(),yu));\n\t\t}\n\t}\n\tvoid cut_x_lower(int xl) {\n\t\twhile (get_front_x() < xl) {\n\t\t\tVertex v = poll_front();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_front_x() > xl)\n\t\t\t\tadd_front(isect_x(v,get_front(),xl));\n\t\t}\n\t}\n\tvoid cut_x_upper(int xu) {\n\t\twhile (get_back_x() > xu) {\n\t\t\tVertex v = poll_back(); \n\t\t\tassert(!verts.empty());\n\t\t\tif (get_back_x() < xu)\n\t\t\t\tadd_back(isect_x(v,get_back(),xu));\n\t\t}\n\t}\n\tfriend str ts(const Hull& h) {\n\t\tV<Vertex> converted;\n\t\tset<int> cands;\n\t\tcands.ins(0);\n\t\tcands.ins(sz(h.verts)-1);\n\t\tfor (int i: cands) {\n\t\t\tVertex v = h.verts[i].f;\n\t\t\tif (i == 0) {\n\t\t\t\tv = v.with_tag(h.prod);\n\t\t\t} else {\n\t\t\t\tFOR(j,i,sz(h.verts)) v = v.with_tag(h.verts[j].s);\n\t\t\t}\n\t\t\tconverted.pb(v);\n\t\t\t// while (sz(converted) > 2 && collinear(converted[sz(converted)-3],converted[sz(converted)-2],converted.bk)) {\n\t\t\t// \tconverted.erase(begin(converted)+sz(converted)-2);\n\t\t\t// }\n\t\t}\n\t\t// F0R(i,sz(converted)-1) {\n\t\t// \tfrac f = slope_between(converted[i],converted[i+1]);\n\t\t// \tfrac y_intercept = converted[i].get_y()-converted[i].get_x()*f;\n\t\t// \t// if (y_intercept.d) if (f.d%y_intercept.d != 0) {\n\t\t// \t// \tdbg(""FAILED"",converted[i],converted[i+1]);\n\t\t// \t// }\n\t\t// }\n\t\treturn ts(converted);\n\t}\n};\n\nvpi X,Y,Z;\nHull lower, upper;\n// if single point, both have it\n\nbool hull_empty() {\n\treturn lower.verts.empty();\n}\n\nvoid x_plus_y() {\n\tif (hull_empty()) return;\n\tlower.x_plus_y(); upper.x_plus_y();\n}\n\nvoid advance_z(int zl, int zu) {\n\tif (hull_empty()) return;\n\tlower.advance_z(zl); upper.advance_z(zu);\n\tupper.add_front(lower.get_front());\n\tlower.add_back(upper.get_back());\n}\n\nvoid clear() {\n\tupper.verts = lower.verts = {};\n}\n\nvoid cut_y_lower(int yl) {\n\tif (hull_empty()) return;\n\tif (lower.get_back_y() < yl) return clear();\n\tupper.cut_y_lower(yl);\n\tlower.cut_y_lower(yl);\n\tlower.add_front(upper.get_front());\n}\n\nvoid cut_y_upper(int yu) {\n\tif (hull_empty()) return;\n\tif (lower.get_front_y() > yu) return clear();\n\tupper.cut_y_upper(yu);\n\tlower.cut_y_upper(yu);\n\tupper.add_back(lower.get_back());\n}\n\nvoid cut_x_lower(int xl) {\n\tif (hull_empty()) return;\n\tif (lower.get_back_x() < xl) return clear();\n\tupper.cut_x_lower(xl);\n\tlower.cut_x_lower(xl);\n\tupper.add_front(lower.get_front());\n}\n\nvoid cut_x_upper(int xu) {\n\tif (hull_empty()) return;\n\tif (lower.get_front_x() > xu) return clear();\n\tupper.cut_x_upper(xu);\n\tlower.cut_x_upper(xu);\n\tlower.add_back(upper.get_back());\n}\n\n\nvoid print_hulls() {\n\t// if (flag) {\n\tdbg(""HULLS"");\n\tdbg(lower);\n\tdbg(upper);\n\tdbg(""----"");\n\t// }\n\t// dbg(lower);\n\t// dbg(upper);\n}\n\npi rand_pair() {\n\tint a = rng()%21-10;\n\tint b = rng()%21-10;\n\tif (a > b) swap(a,b);\n\treturn {a,b};\n}\n\nint rng_int(int l, int r) { return uniform_int_distribution<int>(l,r)(rng); }\n\npi rand_around(int x) {\n\tint a = rng_int(-1e8,1e8), b = rng_int(1e8,1e8);\n\tif (a > b) swap(a,b);\n\treturn {a,b};\n\t// return {rng_int(-1e8,x),rng_int(x,1e8)};\n\t// return {rng_int(max(-(int)1e8,x-5),x),rng_int(x,min((int)1e8,x+5))};\n}\n\npair<bool,vs> solve(int tc, int N, vpi X, vpi Y, vpi Z) {\n\tdbg(tc);\n\t// N = 3; \n\n\t// if (tc == 6649) {\n\t// \tps(N);\n\t// \teach(t,X) ps(t.f,t.s);\n\t// \teach(t,Y) ps(t.f,t.s);\n\t// \teach(t,Z) ps(t.f,t.s);\n\t// \t// ps(ts_sep(X,""\\n""));\n\t// \t// ps(ts_sep(Y,""\\n""));\n\t// \t// ps(ts_sep(Z,""\\n""));\n\t// }\n\n\t// dbg(N);\n\t// dbg(X);\n\t// dbg(Y);\n\t// dbg(Z);\n\n\tVertex lower_left(X[1].f,X[1].f-X[0].s);\n\tVertex upper_left(X[1].f,X[1].f-X[0].f);\n\tVertex upper_right(X[1].s,X[1].s-X[0].f);\n\tVertex lower_right(X[1].s,X[1].s-X[0].s);\n\tupper = Hull({lower_left,upper_left,upper_right});\n\tlower = Hull({lower_left,lower_right,upper_right});\n\tcut_y_lower(Y[0].f); cut_y_upper(Y[0].s);\n\t// dbg(""SOLUTION 1"");\n\tvs rec;\n\tif (!hull_empty()) {\n\t\trec.pb(""UPPER: ""+ts(upper));\n\t\trec.pb(""LOWER: ""+ts(lower));\n\t}\n\t// ps(""UPPER"",upper);\n\t// ps(""LOWER"",lower);\n\tFOR(i,2,N) {\n\t\t// dbg(""IT"",i);\n\t\t// dbg(sz(lower.verts),sz(upper.verts));\n\t\t// assert(!hull_empty());\n\t\t// flag = tc == 6649;\n\t\t// flag = N == 100000 && tc == 2 && i == 99999;\n\t\t// if (N == 100000 && tc == 2 && i == 99999) {\n\t\t// \tps(""HULL EMPTY BEFORE"",i);\n\t\t// \tps(X[i]);\n\t\t// \tps(Y[i-1]);\n\t\t// \tps(Z[i-2]);\n\t\t// if (tc == 6649) {\n\t\t// \tdbg(""ITERATION"",i);\n\t\t// \tdbg(upper);\n\t\t// \tdbg(lower);\n\t\t// }\n\t\t// \tps(upper);\n\t\t// \tps(lower);\n\t\t// }\n\t\t// if (flag) ps(""BEFORE ITERATION"",i,X[i],Y[i-1],Z[i-2]);\n\t\t// print_hulls();\n\n\t\tx_plus_y();\n\n\t\t// if (flag) dbg(""AFTER X PLUS Y"",i);\n\t\t// print_hulls();\n\n\t\tadvance_z(Z[i-2].f,Z[i-2].s);\n\n\t\t// if (flag) dbg(""AFTER Z"",i,Z[i-2]);\n\t\t// print_hulls();\n\n\t\tcut_x_lower(X[i].f); \n\n\t\t// if (flag) \n\t\t// \tdbg(""AFTER X LOWER"",i,X[i].f);\n\t\t// print_hulls();\n\n\t\tcut_x_upper(X[i].s);\n\n\t\t// if (flag) \n\t\t// \tdbg(""AFTER X HIGHER"",i,X[i].s);\n\t\t// print_hulls();\n\n\t\tcut_y_lower(Y[i-1].f); \n\n\t\t// if (flag) \n\t\t\t// dbg(""AFTER Y LOWER"",i,Y[i-1].f);\n\t\t// print_hulls();\n\n\t\tcut_y_upper(Y[i-1].s);\n\n\t\t// dbg(""AFTER Y HIGHER"",i,Y[i-1].s);\n\t\t// print_hulls();\n\t\t// if (N == 100000 && tc == 2 && hull_empty()) {\n\t\t// \tps(""HULL EMPTY AFTER"",i);\n\t\t// }\n\t\tif (!hull_empty()) {\n\t\t\trec.pb(""UPPER: ""+ts(upper));\n\t\t\trec.pb(""LOWER: ""+ts(lower));\n\t\t}\n\t\t// ps(""UPPER"",upper);\n\t\t// ps(""LOWER"",lower);\n\t}\n\tdbg(rec);\n\t// assert(!hull_empty());\n\tif (hull_empty()) return {0,rec};\n\telse return {1,rec};\n}\n\n}\n\nnamespace model {\n\nusing LL = long long;\n\ninline char GET_CHAR(){\n    const int maxn = 131072;\n    static char buf[maxn],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n    int res(0);\n    char c = getchar();\n    while(c < \'0\') c = getchar();\n    while(c >= \'0\') {\n        res = res * 10 + (c - \'0\');\n        c = getchar();\n    }\n    return res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n    LL res(1);\n    while(n) {\n        if(n & 1) {\n            res = res * (LL)x % mod;\n        }\n        x = x * (LL) x % mod;\n        n /= 2;\n    }\n    return res;\n}\nLL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }\n\ninline string itoa(int x, int width = 0) {\n    string res;\n    if(x == 0) res.push_back(\'0\');\n    while(x) {\n        res.push_back(\'0\' + x % 10);\n        x /= 10;\n    }\n    while((int)res.size() < width) res.push_back(\'0\');\n    reverse(res.begin(), res.end());\n    return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n    fwrite(buf, 1, _bl, stdout);\n    _bl = 0;\n}\n__inline void _putchar(char c) {\n    if(_bl == _B) flush();\n    buf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n    static char tmp[20];\n    int l = 0;\n    if(!x) tmp[l++] = \'0\';\n    else {\n        while(x) {\n            tmp[l++] = x % 10 + \'0\';\n            x /= 10;\n        }\n    }\n    for(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n    _putchar(c);\n}\nconst int N = 100011;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid no() {\n    printf(""NO\\n"");\n}\nvoid yes() {\n    printf(""YES\\n"");\n}\nconst int L = 1e9;\nstruct Frac {\n    LL x, y;\n    Frac() {\n        y = 1;\n        x = 0;\n    }\n    Frac(LL _x, LL _y) : x(_x), y(_y){\n        if(y < 0) {\n            y = -y; x = -x;\n        }\n        LL d = gcd(abs(x), y);\n        x /= d; y /= d;\n    }\n    Frac(LL a) {\n        x = a; y = 1;\n    }\n    Frac operator + (const Frac & b) const {\n        return Frac(x * b.y + y * b.x, y * b.y);\n    }\n    Frac operator - (const Frac & b) const {\n        return Frac(x * b.y - y * b.x, y * b.y);\n    }\n    Frac operator * (const Frac & b) const {\n        return Frac(x * b.x, y * b.y);\n    }\n    Frac operator / (const Frac & b) const {\n        LL dx = gcd(x, b.x);\n        LL dy = gcd(y, b.y);\n        return Frac(x / dx * (b.y / dy), (y / dy) * (b.x / dx));\n    }\n    bool operator == (const Frac & b) const {\n        return x * b.y == y * b.x;\n    }\n    bool operator != (const Frac & b) const {\n        return x * b.y != y * b.x;\n    }\n    bool operator < (const Frac & b) const {\n        return x * b.y < y * b.x;\n    }\n    bool operator > (const Frac & b) const {\n        return x * b.y > y * b.x;\n    }\n    bool operator <= (const Frac & b) const {\n        return x * b.y <= y * b.x;\n    }\n    bool operator >= (const Frac & b) const {\n        return x * b.y >= y * b.x;\n    }\n    Frac operator - () const {\n        return Frac(-x, y);\n    }\n\n    friend str ts(Frac f) {\n    \treturn ts(frac(f.x,f.y));\n    \t// return\n    \t// return ts(x)+""/""+ts(y)+c;\n    }\n};\nLL xmin[N], ymin[N], zmin[N], xmax[N], ymax[N], zmax[N];\nstruct P {\n    Frac x, y;\n    bool operator == (const P & b) const {\n        return x == b.x && y == b.y;\n    }\n    bool operator != (const P & b) const {\n        return x != b.x || y != b.y;\n    }\n    friend str ts(const P& p) {\n    \tV<Frac> v{p.x,p.y};\n    \treturn ts(v);\n    }\n    // void print(char c = \'\\n\') {\n    //     putchar(\'(\');\n    //     x.print(\',\');\n    //     y.print(\')\');\n    //     putchar(c);\n    // }\n    // void check() {\n    // }\n};\nstruct Op {\n    LL c, dx, dy;\n    //x -> x + c * y + dx, y -> y + dy\n    //x + c * y + dx - (y + dy) * c - dx + c * dy = x\n    Op() {\n        c = dx = dy = 0;\n    }\n    Op(LL z) {\n        c = 1;\n        dx = dy = z;\n    }\n    Op(const LL & c, const LL & dx, const LL & dy) : c(c), dx(dx), dy(dy) {\n    }\n    Op operator * (const Op & b) const {\n        return Op{c + b.c, dx + c * b.dy + b.dx, dy + b.dy};\n    }\n    Op inv() const {\n        return Op{-c, -dx + c * dy, -dy};\n    }\n    P operator * (const P & b) const {\n        return P{b.x + (Frac)c * b.y + dx, b.y + dy};\n    }\n    bool operator == (const Op & b) const {\n        return c == b.c && dx == b.dx && dy == b.dy;\n    }\n    void print() const {\n        printf(""op: %lld %lld %lld\\n"", c, dx, dy);\n    }\n    void check() {\n    }\n};\n\nbool collinear(P a, P b, P c) {\n\tFrac f = (b.y-a.y)*(c.x-a.x)-(b.x-a.x)*(c.y-a.y);\n\treturn f.x == 0;\n}\n\nstruct Deq {\n    deque<P> v;\n    deque<Op> op;\n    Op u;\n    bool empty() {\n        return v.empty();\n    }\n    int size() {\n        return v.size();\n    }\n    P back() {\n        return op.back() * v.back();\n    }\n    P front() {\n        return u * v.front();\n    }\n    P bac() {\n        return op.back() * op[size() - 2] * v[size() - 2];\n    }\n    P fron() {\n        return u * op.front().inv() * v[1];\n    }\n    void push_back(const P & x) {\n        v.push_back(x);\n        op.push_back(Op());\n    }\n    void push_front(const P & x) {\n        if(!v.empty()) {\n            op.push_front(u.inv());\n        }else {\n            op.push_front(Op());\n        }\n        u = Op();\n        v.push_front(x);\n    }\n    void pop_back() {\n        if(v.size() == 1) {\n            v.pop_back(); op.pop_back(); u = Op();\n        }else {\n            op[v.size() - 2] = op.back() * op[v.size() - 2];\n            v.pop_back(); op.pop_back();\n        }\n    }\n    void pop_front() {\n        if(v.size() == 1) {\n            v.pop_back(); op.pop_back(); u = Op();\n        }else {\n            u = u * op.front().inv();\n            v.pop_front();\n            op.pop_front();\n        }\n    }\n\n    void setback(const P & x) {\n        pop_back();\n        push_back(x);\n/*        if(v.size() >= 2) {\n            \n            op[v.size() - 2] = op.back() * op[v.size() - 2];\n        }else {\n            u = Op();\n        }\n        v.back() = x;\n        op.back() = Op();*/\n    }\n    void setfront(const P & x) {\n        pop_front();\n        push_front(x);\n/*        op.front() = u.inv() * op.front();\n        u = Op();\n        v.front() = x;*/\n    }\n    void apply(const Op & z) {        \n        if(!op.empty()) {\n            u = z * u;\n            op.back() = z * op.back();\n        }\n    }\n\n    friend str ts(const Deq& d) {\n\t\tV<P> converted;\n\t\tset<int> cands;\n\t\tcands.ins(0);\n\t\tcands.ins(d.op.size()-1);\n\n\t\tfor (int i: cands) {\n            P p = d.v[i];\n            if (i == 0) p = d.u*p;\n            else {\n\t            for (int j = i; j < d.op.size(); ++j) {\n\t                p = d.op[j]*p;\n\t            }\n            }\n            if (sz(converted) && converted.bk == p) continue;\n            // while (sz(converted) > 1 && collinear(converted[sz(converted)-2],converted.bk,p)) \n            // \tconverted.pop_back();\n            converted.pb(p);\n        }\n\t\treturn ts(converted);\n    }\n};\n\npair<bool,vs> solve(int N, vpi X, vpi Y, vpi Z) {\n\t// dbg(""SOLUTION 2"");\n\tn = N;\n\tFOR(i,1,n+1) {\n\t\txmin[i] = X[i-1].f;\n\t\txmax[i] = X[i-1].s;\n\t}\n\tFOR(i,2,n+1) {\n\t\tymin[i] = Y[i-2].f;\n\t\tymax[i] = Y[i-2].s;\n\t}\n\tFOR(i,3,n+1) {\n\t\tzmin[i] = Z[i-3].f;\n\t\tzmax[i] = Z[i-3].s;\n\t}\n    ymin[1] = -L;\n    ymax[1] = L;\n    zmin[2] = -L;\n    zmax[2] = L;\n\n    Deq v[2];\n    v[0].v.pb(P{xmin[1], -L});\n    v[0].v.pb(P{xmin[1], L});\n    v[0].v.pb(P{xmax[1], L});\n    v[1].v.pb(P{xmin[1], -L});\n    v[1].v.pb(P{xmax[1], -L});\n    v[1].v.pb(P{xmax[1], L});\n\n    for(int i = 0; i < 2; i++) {\n        v[i].op.resize(v[i].v.size());\n    }\n    vs rec;\n    for(int i = 2; i <= n + 1; i++) {\n        if(i == n + 1) break;\n        v[0].apply(Op(zmax[i]));\n        v[1].apply(Op(zmin[i]));\n        if(zmin[i] != zmax[i]) {\n            v[0].push_front(v[1].front());\n            v[1].push_back(v[0].back());\n        }\n\n        for(int d = 0; d < 2; d++) {\n            P t1, t2;\n            while(!v[d].empty() && (t1 = v[d].back()).y > ymax[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].bac()).y <= ymax[i]) {\n                    Frac c = (t1.x - t2.x) / (t1.y - t2.y);\n                    Frac delta = t1.x - t1.y * c;\n                    v[d].setback(P{(Frac)ymax[i] * c + delta, ymax[i]});\n                    if(d == 0) {\n                        v[d].push_back(P{L, ymax[i]});\n                    }\n                    break;\n                }else {\n                    v[d].pop_back();\n                }\n            }\n            while(!v[d].empty() && (t1 = v[d].back()).x > xmax[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].bac()).x <= xmax[i]) {\n                    Frac c = (t1.y - t2.y) / (t1.x - t2.x);\n                    Frac delta = t1.y - t1.x * c;\n                    v[d].setback(P{xmax[i], (Frac)xmax[i] * c + delta});\n                    if(d == 1) {\n                        v[d].push_back(P{xmax[i], L});   \n                    }\n                    break;\n                }else {\n                    v[d].pop_back();\n                }\n            }\n            while(!v[d].empty() && (t1 = v[d].front()).y < ymin[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].fron()).y >= ymin[i]) {\n                    Frac c = (t1.x - t2.x) / (t1.y - t2.y);\n                    Frac delta = t1.x - t1.y * c;\n                    v[d].setfront(P{(Frac)ymin[i] * c + delta, ymin[i]});\n                    if(d == 1) v[d].push_front(P{-L, ymin[i]});\n                    break;\n                }else {\n                    v[d].pop_front();\n                }\n            }\n\n            while(!v[d].empty() && (t1 = v[d].front()).x < xmin[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].fron()).x >= xmin[i]) {\n                    Frac c = (t1.y - t2.y) / (t1.x - t2.x);\n                    Frac delta = t1.y - t1.x * c;\n                    v[d].setfront(P{xmin[i], (Frac)xmin[i] * c + delta});\n                    if(d == 0) v[d].push_front(P{xmin[i], -L});\n                    break;\n                }else {\n                    v[d].pop_front();\n                }\n            }\n        }\n        if(v[0].empty() || v[1].empty()) {\n        \treturn {0,rec};\n        }\n\n        P t[2];\n        for(int d = 0; d < 2; d++) {\n            t[d] = v[d].back();\n        }\n        if(t[0].x > t[1].x) t[0].x = t[1].x;\n        if(t[1].y > t[0].y) t[1].y = t[0].y;\n\n\n        /*        tmp = Op();\n                  for(int j = v[0].size() - 1; j >= 0; j--) {\n                  tmp = tmp * v[0].op[j];\n                  }\n                  if(i == 9998) {\n                  printf(""!!%d\\n"", v[0].size());\n                  printf(""%lld %lld %lld %lld \\n"", xmin[i - 1], xmax[i - 1], ymin[i - 1], ymax[i - 1]);\n                  printf(""%lld %lld %lld %lld \\n"", xmin[i], xmax[i], ymin[i], ymax[i]);\n                  printf(""%d %d\\n"", i, v[0].size());\n                  v[0].op.back().print();\n                  v[0].op[v[0].size() - 2].print();\n                  tmp.print();\n                  v[0].u.print();\n                  }*/\n\n\n        v[0].pop_back();\n\n        /*tmp = Op();\n          for(int j = v[0].size() - 1; j >= 0; j--) {\n            tmp = tmp * v[0].op[j];\n        }\n        if(i == 9998) {\n            printf(""!!%d\\n"", v[0].size());\n            printf(""%lld %lld %lld %lld \\n"", xmin[i - 1], xmax[i - 1], ymin[i - 1], ymax[i - 1]);\n            printf(""%lld %lld %lld %lld \\n"", xmin[i], xmax[i], ymin[i], ymax[i]);\n            printf(""%d %d\\n"", i, v[0].size());\n            v[0].op.back().print();\n            \n            tmp.print();\n            v[0].u.print();\n        }*/\n\n\n        v[0].push_back(t[0]);\n        v[1].setback(t[1]);\n        \n        if(t[0] != t[1]) {\n            if(t[0].x == t[1].x) {\n                v[1].push_back(v[0].back());\n            }else if(t[1].y == t[0].y) {\n                v[0].push_back(v[1].back());\n            }else {\n                v[0].push_back(P{t[1].x, t[0].y});\n                v[1].push_back(P{t[1].x, t[0].y});\n            }\n        }\n        \n        for(int d = 0; d < 2; d++) {\n            t[d] = v[d].front();\n        }\n        if(t[0].y < t[1].y) t[0].y = t[1].y;\n        if(t[1].x < t[0].x) t[1].x = t[0].x;\n        v[0].setfront(t[0]);\n        v[1].setfront(t[1]);\n        if(t[0] != t[1]) {\n            if(t[0].x == t[1].x) {\n                v[0].push_front(v[1].front());\n            }else if(t[1].y == t[0].y) {\n                v[1].push_front(v[0].front());\n            }else {\n                v[0].push_front(P{t[0].x, t[1].y});\n                v[1].push_front(P{t[0].x, t[1].y});\n            }\n        }\n        // if (flag && (i-1)%1000 == 0) {\n    \t// rec.pb(""UPPER: ""+ts(v[0]));\n    \t// rec.pb(""LOWER: ""+ts(v[1]));\n        // }\n        // v[1].print();\n        // v[0].print();\n    }\n    return {1,rec};\n}\n}\n\nint main() {\n\tsetIO();\n\n\t// while (1) {\n\n\t// }\n\n\t// Tag x{3,4,5}, y{6,7,8};\n\t// Tag z = x.with_tag(y);\n\t// dbg(z);\n\t// dbg(z.with_tag(y.inv())); // {c: 3, delta_x:4, delta_y:5}\n\t// dbg(z.with_tag(x.inv())); \n\t// dbg(undo_front(x,z)); // {c: 6, delta_x:7, delta_y:8}\n\t// exit(0);\n\n\tint TC; re(TC);\n\t// int TC = 1000000;\n\tFOR(it,1,TC+1) {\n\t\t// dbg(""GOING"",it);\n\n\t\tint N = mine::rng_int(3,10);\n\t\tre(N); \n\n\t\tvpi X(N), Y(N-1), Z(N-2);\n\t\tvi sol(N);\n\t\tF0R(i,N) sol[i] = mine::rng_int(-1e7,1e7);\n\t\t// X.rsz(N), Y.rsz(N-1), Z.rsz(N-2); \n\t\tF0R(i,N) X[i] = mine::rand_around(sol[i]);\n\t\tF0R(i,N-1) Y[i] = mine::rand_around(sol[i+1]-sol[i]);\n\t\tF0R(i,N-2) Z[i] = mine::rand_around(sol[i+2]-2*sol[i+1]+sol[i]);\n\n\t\tre(X,Y,Z);\n\n\t\tflag = it == 2 && N == 100000;\n\n\t\tauto a = mine::solve(it,N,X,Y,Z);\n\t\t// ps();\n\t\tauto b = model::solve(N,X,Y,Z);\n\t\t// assert(sz(a.s) == sz(b.s));\n\t\t// F0R(i,min(sz(a.s),sz(b.s))) if (a.s[i] != b.s[i]) {\n\t\t// \tps(""FAILED"",it,i);\n\t\t// \tps(a.s[i]);\n\t\t// \tps(b.s[i]);\n\t\t// \texit(0);\n\t\t// }\n\t\t// F0R(i,sz(a.rec))\n\t\tdbg(a);\n\t\tdbg(b);\n\n\t\t// ps();\n\n\t\t// assert(a == b);\n\t\tif (a.f) ps(""YES"");\n\t\telse ps(""NO"");\n\t}\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']",,,"['dp', 'geometry']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. Fly Around the World.json,https://codeforces.com//blog/entry/89968,Consider the DP idea dp i x y represests whether there exists a sequence satisfying all the constraints Constraints about are ignored Then is a region on the plane We will prove that it is convex and then show that we can efficiently transform to Initially we can construct In represents and represents The constraints are is the intersection of these half planes so it is convex Calculate by We should take the new constraints into account Let s consider the last constraint first and ignore the first two for now If point in represents since will become in since Thus to transform to we simply apply the tranformation and then move the region by the vector is a linear transformation We call the new region Now we know that is between and So we should take the union of all for Finally we add the first two constraints about and back These constraints correspond to cutting the region by vertical or horizontal half planes The answer is yes if and only if is nonempty By the process above we can prove inductively that the region is always convex For each we only add vertical and horizontal half planes These half planes will cut some original edges of the convex polygon and add some new vertical or horizontal edges to it The transformation will change an edge with slope into an edge with slope vertical edges becomes edges with slope So we can also prove inductively that for any all the edges of have slope or for some integer These edges can be written as for integral and We now know that for any the region is always convex and all edges have slope or for some integer Next we describe how to implement the process described above efficiently We maintain two deques for the vertices on the upper and lower hull of the polygon Vertical edges are included in the upper hull if they have minimum coordinate and lower hull if they have maximum coordinate To cut the polygon by vertical or horizontal half planes we simply pop some vertices at the end of the deques And possibly add some new vertices at the front or back of the deques To apply the transformation we apply it to all vertices of the convex polygon Since we apply the same operation to all vertices this can be done by tags in constant time like the tags in segment trees We will explain the precision issues later Finally to take the union of all we move the upper hull by and the lower hull by These are again transformations applied to all vertices in each deque We use tags as well The new upper hull and new lower hull are not necessarily connected If they are not we connect their first and last vertices The time complexity is assuming each arithmetic operation costs constant time 
https://codeforces.com//contest/196/problem/A,1424,A,196A,196,A. Lexicographically Maximum Subsequence,You ve got string consisting of only lowercase English letters Find its lexicographically maximum subsequence We ll call a non empty string a of string String is than string if either and or exists such number that and Characters in lines are compared like their ASCII codes ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tstring s;\n\tcin>>s;\n\tstring t;\n\tREP(i,s.size()){\n\t\twhile(t.size() && t[t.size()-1]<s[i]) t.erase(t.end()-1);\n\t\tt.pb(s[i]);\n\t}\n\tcout<<t<<endl;\n\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']",,,"['greedy', 'strings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Lexicographically Maximum Subsequence.json,https://codeforces.com//blog/entry/4717,Solution is greedy First write all z letters if there is any answer must contain them all for sure Now it s time for y letters We can use only those of them which are on the right of last used z letter Then write x letters they must be on the right of the last used y and z letters And so on 
https://codeforces.com//contest/494/problem/C,19366,C,494C,494,C. Helping People,Malek is a rich man He also is very generous That s why he decided to split his money between poor people A charity institute knows poor people numbered from to The institute gave Malek recommendations A recommendation is a segment of people like which means the institute recommended that Malek gives one dollar to every person whose number is in this segment However this charity has very odd rules about the recommendations Because of those rules the recommendations are given in such a way that for every two recommendation and one of the following conditions holds The two segments are completely disjoint More formally either or One of the two segments are inside another More formally either or The of a charity is the value of maximum money a person has after Malek finishes giving his money The institute knows for each recommendation what is the probability that Malek will accept it They want to know the expected value of of this charity So they asked you for help You have been given the list of recommendations and for each recommendation the probability of it being accepted by Malek You have also been given how much money each person initially has You must find the expected value of ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX = 200010;\n\nint a[MAX];\n\nconst int N = 5010;\n\nvector <int> g[N];\nvector <double> f[N];\nint start[N], finish[N];\ndouble prob[N];\nint from[N], to[N];\n\nvoid solve(int i) {\n  int sz = g[i].size();\n  from[i] = 0;\n  if (sz == 0) {\n    for (int pos = start[i]; pos <= finish[i]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n  } else {\n    for (int pos = start[i]; pos < start[g[i][0]]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n    for (int j = 0; j + 1 < sz; j++) {\n      for (int pos = finish[g[i][j]] + 1; pos < start[g[i][j + 1]]; pos++) {\n        if (a[pos] > from[i]) {\n          from[i] = a[pos];\n        }\n      }\n    }\n    for (int pos = finish[g[i][sz - 1]] + 1; pos <= finish[i]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n  }\n  to[i] = from[i];\n  for (int j = 0; j < sz; j++) {\n    int u = g[i][j];\n    solve(u);\n    if (from[u] > from[i]) {\n      from[i] = from[u];\n    }\n    if (to[u] > to[i]) {\n      to[i] = to[u];\n    }\n  }\n  f[i].resize(to[i] - from[i] + 1);\n  for (int v = to[i]; v >= from[i]; v--) {\n    double cur = 1.0;\n    for (int j = 0; j < sz; j++) {\n      int u = g[i][j];\n      if (to[u] >= v) {\n        cur *= (1.0 - f[u][v - from[u]]);\n      }\n    }\n    f[i][v - from[i]] = 1.0 - cur;\n  }\n  f[i][0] = 1.0;\n  f[i].push_back(f[i][to[i] - from[i]] * prob[i]);\n  for (int v = to[i]; v > from[i]; v--) {\n    f[i][v - from[i]] = f[i][v - from[i]] * (1 - prob[i]) + f[i][v - from[i] - 1] * prob[i];\n  }\n  to[i]++;\n}\n\nint st[N];\npair < pair <int, int>, int > adds[N];\n\nint main() {\n  int n, q;\n  scanf(""%d %d"", &n, &q);\n  for (int i = 1; i <= n; i++) {\n    scanf(""%d"", a + i);\n  }\n  q++;\n  for (int i = 0; i < q; i++) {\n    if (i == q - 1) {\n      start[i] = 1;\n      finish[i] = n + 1;\n      prob[i] = 0.0;\n    } else {\n      scanf(""%d %d %lf"", start + i, finish + i, prob + i);\n    }\n    adds[i] = make_pair(make_pair(start[i], -finish[i]), i);\n  }\n  sort(adds, adds + q);\n  for (int i = 0; i < q; i++) {\n    g[i].clear();\n  }\n  int e = 0;\n  for (int id = 0; id < q; id++) {\n    int i = adds[id].second;\n    while (e > 0 && finish[st[e - 1]] < start[i]) {\n      e--;\n    }\n    if (e > 0) {\n      g[st[e - 1]].push_back(i);\n    }\n    st[e++] = i;\n  }\n  finish[q - 1] = n;\n  solve(q - 1);\n  double ans = from[q - 1];\n  for (int j = from[q - 1] + 1; j <= to[q - 1]; j++) {\n    ans += f[q - 1][j - from[q - 1]];\n  }\n  printf(""%.17f\\n"", ans);\n  return 0;\n}\n']",,,"['dp', 'probabilities']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Helping People.json,https://codeforces.com/blog/entry/15148,We ll first create a rooted tree from the given segments which each node represents a segment We ll solve the problem using dynamic programming on this tree First of all let s add a segment with probability of being chosen by Malek equal to The node representing this segment will be the root of the tree Please note by adding this segment the rules described in the statements are still in place Let s sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing Then we ll put the segment we added in the beginning A segment s father is the right most segment which comes before that segment and contains it Please note that since we added segment to the beginning every segment except the added segment has a father We build the tree by putting a segment s node child of its father s node In this tree for each two nodes and which none of them are in the subtree on another the segments representing these two nodes will not overlap Also for each two nodes and which is in subtree of segment representing node will be inside not necessarily strictly segment representing node We define as the maximum money a person in the segment initially has can be calculated using RMQ Let s define as the probability of that after Malek finishes giving his money the maximum in the segment is at most The properties of the tree we built allows us to calculate for every and in since If number of the segment we added is then the answer will be Calculating is described below Suppose is a child of and suppose Malek doesn t accept the th recommendation Then since we want the maximum number after money spreading to be at most in segment and since is inside we want the maximum number after money spreading to be at most If Malek accepts the recommendation then we want it to be at most So if probability of th recommendation being accepted by Malek be equal to then Using this formula we can calculate recursively and calculate the answer from it in The overall complexity will be for creating RMQ used for calculating the array and for the rest of the algorithm 
https://codeforces.com//contest/1342/problem/F,604761,F,1342F,1342,F. Make It Ascending,You are given an array a consisting of n elements You may apply several operations possibly zero to it During each operation you choose two indices i and j 1 le i j le n i ne j increase a j by a i and remove the i th element from the array so the indices of all elements to the right to it decrease by 1 and n also decreases by 1 Your goal is to make the array a strictly ascending That is the condition a 1 a 2 dots a n should hold where n is the resulting size of the array Calculate the minimum number of actions required to make the array strictly ascending ,"['#include <bits/stdc++.h>\nusing namespace std;\nint a[16];\nint f[16][1 << 15 | 1], g[16][1 << 15 | 1], sum[1 << 15 | 1];\nvector<int> x, y;\nint main() {\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t --) {\n\t\tint n;\n\t\tscanf(""%d"", &n);\n\t\tfor (int i = 0; i < n; i ++)\n\t\t            scanf(""%d"", &a[i]);\n\t\tint o = n;\n\t\tvector<int> ff[16];\n\t\tfor (int i = 0; i < (1 << n); i ++) {\n\t\t\t// printf(""push %d\\n"", i);\n\t\t\tff[__builtin_popcount(i)].push_back(i);\n\t\t}\n\t\t// for(int ss = 0; ss < n; ss ++)\n\t\t//     printf(""size %d\\n"", (int)ff[ss].size());\n\t\tfor (int ss = 0; ss < n; ss ++)\n\t\t            for (int ii = 0; ii < (int)ff[ss].size(); ii ++) {\n\t\t\tint s = ff[ss][ii];\n\t\t\tx.clear();\n\t\t\ty.clear();\n\t\t\ty.push_back(0);\n\t\t\tfor (int i = 0; i < n; i ++)\n\t\t\t                    if(s >> i & 1)\n\t\t\t                        x.push_back(i); else\n\t\t\t                        y.push_back(i);\n\t\t\tint n = y.size() - 1, m = x.size();\n\t\t\tfor (int i = 0; i < (1 << m); i ++)\n\t\t\t                    for (int j = sum[i] = 0; j < m; j ++)\n\t\t\t                        if(i >> j & 1)\n\t\t\t                            sum[i] += a[x[j]];\n\t\t\tfor (int i = 0; i < (1 << m); i ++)\n\t\t\t                    f[0][i] = INT_MAX;\n\t\t\tf[0][0] = 0;\n\t\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\t\tfor (int j = 0; j < (1 << m); j ++) {\n\t\t\t\t\tf[i][j] = INT_MAX;\n\t\t\t\t\tif(a[y[i]] > f[i - 1][j]) {\n\t\t\t\t\t\tf[i][j] = a[y[i]];\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int k = j; k; k = j & (k - 1))\n\t\t\t\t\t\t                                if(a[y[i]] + sum[k] > f[i - 1][j ^ k]) {\n\t\t\t\t\t\t\tif(a[y[i]] + sum[k] < f[i][j]) {\n\t\t\t\t\t\t\t\tf[i][j] = a[y[i]] + sum[k];\n\t\t\t\t\t\t\t\tg[i][j] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f[n][(1 << m) - 1] != INT_MAX) {\n\t\t\t\t// printf(""fetch %d %d\\n"", ss, s);\n\t\t\t\to = ss;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tout:\n\t\t        printf(""%d\\n"", o);\n\t\tint cc = (1 << x.size()) - 1;\n\t\tvector<int> out[16];\n\t\tfor (int i = y.size() - 1; i >= 1; i --) {\n\t\t\tfor (int j = 0; j < x.size(); j ++)\n\t\t\t                if(g[i][cc] >> j & 1) {\n\t\t\t\t// printf(""pushed"");\n\t\t\t\tout[y[i]].push_back(x[j]);\n\t\t\t}\n\t\t\t// printf(""used %d\\n"", g[i][cc]);\n\t\t\tcc ^= g[i][cc];\n\t\t}\n\t\tint p[16];\n\t\tfor (int i = 0; i < n; i ++)\n\t\t            p[i] = i;\n\t\tfor (int i = 1; i < y.size(); i ++) {\n\t\t\tfor (int j = 0; j < out[y[i]].size(); j ++) {\n\t\t\t\tprintf(""%d %d\\n"", p[out[y[i]][j]] + 1, p[y[i]] + 1);\n\t\t\t\tfor (int k = out[y[i]][j]; k < n; k ++)\n\t\t\t\t                    p[k] --;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['bitmasks', 'brute force', 'dp']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Make It Ascending.json,https://codeforces.com//blog/entry/76633,Suppose we don t have any constraints on the order of elements the resulting array just should not contain any duplicates Let s build the result one element after another in ascending order so each element we create is strictly greater than the previous To create an element just use some subset of elements and merge them into new element This process can be efficiently modeled with the following dynamic programming is the minimum value of the last element if we merged all the elements from into ascending numbers To model transitions we simply iterate on the mask of elements that will be merged into a new one and check if its sum is greater than the last element we created This runs in if we use an efficient way to iterate on all masks that don t intersect with the given mask Okay how about maintaining the order When we create an element by merging some elements of the original array let s choose some position of an element we use in merging and state that all other elements are added to it Then to ensure that the result is ascending the position of this element should be greater than the position of the element we chose while building the previous number We can add the position we have chosen for the last element to the states of our dynamic programming so it becomes the minimum value of the last element if we merged the of elements into numbers and the last element originally had index in the array Using some greedy optimizations for example we should not iterate on the position we are choosing to merge it can be chosen greedily as the leftmost position after the position of previous element we are taking into consideration we can make it yet with a small constant factor To restore the answer we can maintain the previous values of and in each state since just increases by with each transition 
https://codeforces.com//contest/1463/problem/B,836002,B,1463B,1463,B. Find The Array,You are given an array a 1 a 2 dots a n such that 1 le a i le 10 9 Let S be the sum of all elements of the array a Let s call an array b of n integers if 1 le b i le 10 9 for each i from 1 to n for every pair of adjacent integers from the array b i b i 1 either b i divides b i 1 or b i 1 divides b i or both 2 sum limits i 1 n a i b i le S Your task is to find any beautiful array It can be shown that at least one beautiful array always exists ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tvector<int> ans(n);\n\trep(i, n) {\n\t\tint x = 1; while (x * 2 <= a[i])x *= 2;\n\t\tans[i] = x;\n\t}\n\trep(i, n) {\n\t\tif (i > 0)cout << "" "";\n\t\tcout << ans[i];\n\t}\n\tcout << ""\\n"";\n\t\n}\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']",,,"['bitmasks', 'constructive algorithms', 'greedy']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Find The Array.json,https://codeforces.com//blog/entry/85707,It is enough to consider two possible arrays and It is not difficult to notice that in these arrays the condition is met that among two neighboring elements one divides the other It remains to show that at least one of these two arrays satisfies the condition Let s consider the sum of elements at odd positions and the sum of elements at even positions Since at least one of the values of and does not exceed because otherwise their sum will be strictly greater than Without losing generality assume that Note that for the second variant of the array the condition holds so 
https://codeforces.com//contest/961/problem/F,171417,F,961F,961,F. k-substrings,You are given a string consisting of lowercase Latin letters Let s denote substring of as a string Obviously and there are exactly such substrings Let s call some string an of a string iff the following conditions are met is an odd number is simultaneously a prefix and a suffix of For evey substring of you have to calculate the maximum length of its odd proper suprefix ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint P[3] = { 359, 1039, 2797 };\nll MO[3] = { MOD, MOD + 2, 1000000087 };\n\nchar in[1000050];\nll po[3][1000050];\nll sum[3][1000050];\nbool isEqual(int s1, int e1, int s2, int e2) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tll v1 = (sum[i][e1] - sum[i][s1 - 1]) % MO[i];\n\t\tv1 = (v1 + MO[i]) % MO[i];\n\t\tv1 = v1 * po[i][1000000 - e1] % MO[i];\n\n\t\tll v2 = (sum[i][e2] - sum[i][s2 - 1]) % MO[i];\n\t\tv2 = (v2 + MO[i]) % MO[i];\n\t\tv2 = v2 * po[i][1000000 - e2] % MO[i];\n\t\tif (v1 != v2) return false;\n\t}\n\treturn true;\n}\nint main() {\n\tint N, i, j;\n\tscanf(""%d"", &N);\n\tscanf(""%s"", in + 1);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tpo[i][0] = P[i];\n\t\tfor (j = 1; j <= 1000000; j++) po[i][j] = po[i][j - 1] * P[i] % MO[i];\n\t\tfor (j = 1; j <= N; j++) sum[i][j] = (sum[i][j - 1] + po[i][j] * in[j]) % MO[i];\n\t}\n\n\tvector <int> Va;\n\tint prv = -1;\n\tfor (i = (N + 1) / 2; i >= 1; i--) {\n\t\tint st = i, en = N + 1 - st;\n\t\tint L = en - st + 1;\n\t\tint mx = min(L - 1, prv + 2);\n\t\tif (mx % 2 == 0) mx--;\n\t\tfor (j = mx; j >= 1; j-=2) {\n\t\t\tif (isEqual(st, st + j - 1, en - j + 1, en)) break;\n\t\t}\n\t\tif (j >= 1) Va.push_back(j);\n\t\telse Va.push_back(-1);\n\t\tprv = j;\n\t}\n\treverse(all(Va));\n\tfor (auto it : Va) printf(""%d "", it);\n\treturn !printf(""\\n"");\n}']",,,"['binary search', 'hashing', 'string suffix structures']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. k-substrings.json,https://codeforces.com//blog/entry/58743,Let s look at suprefix of fixed substring we can t find its maximal length via binary search because this function isn t monotone in general case But by fixing not the left border but the center of the prefix we also fix the center of the corresponding suffix center of a prefix in position is tied with the center of the suffix in position and more important function becomes monotone So solution is next iterate over all valid centers of prefix and try to binary search maximal length of such substring that its center is in position and it s equal to the substing with center in then can be updated with value And don t forget to update each with value Easy way to check substrings for equality is to use hashes Harder way is to use string suffix structures like bundle of Suffix Array LCP Sparse Table or Suffix Tree LCA Note for SuffArray users don t forget about changing sort to stable sort merge sort and breaking if all suffixes are different This optimizations can save you from writing radix or bucket sort 
https://codeforces.com//contest/2008/problem/B,2850007,B,2008B,2008,B. Square or Not,A beautiful binary matrix is a matrix that has ones on its edges and zeros inside Today Sakurako was playing with a beautiful binary matrix of size r times c and created a binary string s by writing down all the rows of the matrix starting from the first and ending with the r th More formally the element from the matrix in the i th row and j th column corresponds to the i 1 c j th element of the string You need to check whether the beautiful matrix from which the string s was obtained could be In other words you need to check whether the string s could have been build from a beautiful binary matrix i e one where r c ,"['#include <bits/stdc++.h>using namespace std;\xa0namespace std {\xa0template <int D, typename T>struct Vec : public vector<Vec<D - 1, T>> {    static_assert(D >= 1);    template <typename... Args>    Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}};\xa0template <typename T>struct Vec<1, T> : public vector<T> {    Vec(int n = 0, T val = T()) : std::vector<T>(n, val) {}};\xa0template <class Fun>class y_combinator_result {    Fun fun_;\xa0   public:    template <class T>    explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\xa0    template <class... Args>    decltype(auto) operator()(Args &&...args) {        return fun_(std::ref(*this), std::forward<Args>(args)...);    }};\xa0template <class Fun>decltype(auto) y_combinator(Fun &&fun) {    return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));}\xa0}  // namespace std\xa0int32_t main() {    ios_base::sync_with_stdio(0);    cin.tie(0);\xa0    int t;    cin >> t;    while (t--) {        int n;        string s;        cin >> n >> s;        int x = sqrt(n);        if (x * x != n) {            cout << ""NO\\n"";        } else {            bool ok = 1;            for (int i = 0; i < x; i++) {                for (int j = 0; j < x; j++) {                    if (i == 0 || j == 0 || i == x - 1 || j == x - 1) {                        if (s[i * x + j] == \'0\') ok = 0;                    } else {                        if (s[i * x + j] == \'1\') ok = 0;                    }                }            }            cout << (ok ? ""YES\\n"" : ""NO\\n"");        }    }}']",,,"['brute force', 'math', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Square or Not.json,https://codeforces.com//blog/entry/133509,Assume that string was created from the beautiful binary matrix with size If or then the whole matrix consists of 1 This means that the string will have only one character and this is the only case such happening So if the whole string is constructed out of 1 we print Yes only if the size of the string is 4 since only is a good matrix for us Otherwise we have at least one 0 in the string Let s look at what is the index of the first 0 If it has index since the whole first line and the first character of the first line equal to 1 so now we have a fixed value of index of the first 0 minus 1 and the answer is Yes only if is the square root of 
https://codeforces.com//contest/1995/problem/B2,2772826,B2,1995B2,1995,B2. Bouquet  Hard Version ,A girl is preparing for her birthday and wants to buy the most beautiful bouquet There are a total of n different types of flowers in the store each of which is characterized by the number of petals and the quantity of this type of flower A flower with k petals costs k coins The girl has decided that the difference in the number of petals between any two flowers she will use to decorate her cake should not exceed one At the same time the girl wants to assemble a bouquet with the maximum possible number of petals Unfortunately she only has m coins and she cannot spend more What is the maximum total number of petals she can assemble in the bouquet ,"['#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/trie_policy.hpp>using namespace std;using namespace __gnu_pbds;typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;#ifndef ONLINE_JUDGE    #include ""debug.h""#else    #define dbg(...) 42    template<typename T>ostream&operator<<(ostream&os,vector<T>&vec){for(signed i=0;i+1<vec.size();++i){os<<vec[i]<<"" "";}if(vec.size()>0)os<<vec.back();return os;}#endif\xa0#define all(x) x.begin(), x.end()#define rall(x) x.rbegin(), x.rend()\xa0template<typename T>istream&operator>>(istream&is,vector<T>&vec){for(T&element:vec){is>>element;}return is;}template<typename T>void chmin(T&x,T y){x=min(x,y);}template<typename T>void chmax(T&x,T y){x=max(x,y);}\xa0#define int int64_t\xa0void test_case(signed ___) {    int64_t n, m;    cin >> n >> m;    vector<int> ar(n);    cin >> ar;\xa0    vector<int> c(n);    cin >> c;\xa0    map<int64_t, int64_t> mp;    for (int i = 0; i < n; ++i) {        mp[ar[i]] = c[i];    }\xa0    int64_t res = 0;\xa0    for (auto [x, y] : mp) {        int64_t can_buy_first = min(y, m/x);        int64_t nxt = x+1;        int64_t can_buy_second = 0;        if (mp.count(nxt)) {            can_buy_second = mp[x+1];        }        int64_t bought_second = min((m-can_buy_first*x)/nxt, can_buy_second);        int64_t need_inc = m - can_buy_first*x - bought_second*nxt;        int64_t can_sub = min(can_buy_first, can_buy_second-bought_second);        can_sub = min(can_sub, need_inc);        int64_t now = can_buy_first*x + bought_second*nxt + can_sub;        res = max(res, now);    }    cout << res << ""\\n"";}\xa0signed main(void) {    cin.tie(0)->sync_with_stdio(false);\xa0    signed tt = 1;    cin >> tt;    while (tt--)     test_case(69420);}']",,,"['binary search', 'data structures', 'greedy', 'math', 'sortings', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B2. Bouquet  Hard Version .json,https://codeforces.com//blog/entry/131851,SolutionWe already have a list of We can use hash map to be able to check for any by We again will try to assemble the bouquet only with flowers with petals We set Then we have Let s set Then we have Let s substitute flower with petals with flower with petals as many times as we can This can be done times as each operation will require us 1 coin 1 flower in the bouquet with petals and one 1 flower with petals not in the bouquet In total we can get petals This assembling is optimal Here is why Suppose that we have flowers with petals and flowers with petals and greater total value of We already know that by choosing of If then we can undo our operation times sum is still not greater than and we know that now there can t be more than flowers with petals as otherwise we didn t chose optimal If then if then it is just the case when we have only flowers with petals which will be considered in case if then and we already found the maximum So and and is not better than optimal Total time complexity is 
https://codeforces.com//contest/1810/problem/G,1858192,G,1810G,1810,G. The Maximum Prefix,You re going to generate an array a with a length of at most n where each a i equals either 1 or 1 You generate this array in the following way First you choose some integer k 1 le k le n which decides the length of a Then for each i 1 le i le k you set a i 1 with probability p i otherwise set a i 1 with probability 1 p i After the array is generated you calculate s i a 1 a 2 a 3 ldots a i Specially s 0 0 Then you let S equal to displaystyle max i 0 k s i That is S is the maximum prefix sum of the array a You are given n 1 integers h 0 h 1 ldots h n The of an array a with maximum prefix sum S is h S Now for each k you want to know the expected score for an array of length k modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = 1;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 1;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<Z> p(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        p[i] = Z(x) / y;\n    }\n    \n    std::vector<Z> h(n + 1);\n    for (int i = 0; i <= n; i++) {\n        std::cin >> h[i];\n    }\n    \n    for (int k = 1; k <= n; k++) {\n        std::vector<Z> g(n + 1);\n        g[0] += h[0] * (1 - p[k - 1]);\n        g[1] += h[0] * (1 - p[k - 1]);\n        for (int i = 1; i <= n; i++) {\n            g[i - 1] += h[i] * p[k - 1];\n            if (i < n) {\n                g[i + 1] += h[i] * (1 - p[k - 1]);\n            }\n        }\n        h = std::move(g);\n        Z ans = h[0];\n        std::cout << ans << "" \\n""[k == n];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,['dp'],3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. The Maximum Prefix.json,https://codeforces.com//blog/entry/114521,TutorialConsider this method to find maximal prefix sum let and We can discover that the only influence has to the whole array s maximal prefix sum is its maximal prefix sum Then we let be the expect score we can get if we assume that the maximal prefix sum of is Read the definition carefully The answer for each is since if the maximal prefix sum for is that is equivalent to removing them from the array And also And we have The first section represents chosing and the second one represents chosing We also have other solutions using inclusion exclusion or generate function Actually all the testers solutions differs from each other 
https://codeforces.com//contest/1946/problem/F,2546666,F,1946F,1946,F. Nobody is needed,Oleg received a permutation a of length n as a birthday present Oleg s friend Nechipor asks Oleg q questions each question is characterized by two numbers l and r in response to the question Oleg must say the number of sets of indices t 1 t 2 ldots t k of any length k ge 1 such that l le t i le r for each i from 1 to k t i t i 1 for each i from 1 to k 1 a t i 1 is divisible by a t i for each i from 1 to k 1 Help Oleg and answer all of Nechipor s questions ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=1e6+5;\nint n,m;\nint p[MAXN],q[MAXN],d[MAXN];\nvector<int> di[MAXN];\nvector<pair<int,int> > vec[MAXN];\nll ans[MAXN];\nstruct BIT{\nll a[MAXN];\nvoid init(){for(int i=1;i<=n;i++)a[i]=0;}\nll ask(int x){ll s=0;while(x){s+=a[x];x-=(x&-x);}return s;}\nvoid add(int x,int v){while(x<=n){a[x]+=v;x+=(x&-x);}return;}\n}T;\nvoid solve(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>p[i],q[p[i]]=i;\n\tT.init();\n\tfor(int i=1;i<=n;i++) vec[i].clear();\n\tfor(int i=1;i<=m;i++){\n\t\tint l,r;cin>>l>>r;\n\t\tvec[r].push_back(MP(l,i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tpriority_queue<int> Q;\n\t\tQ.push(i);d[i]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.top();Q.pop();\n\t\t\tfor(int v:di[p[u]]) if(q[v]<u){\n\t\t\t\tint p=q[v];\n\t\t\t\tif(!d[p]) Q.push(p);\n\t\t\t\td[p]+=d[u];\n\t\t\t}\n\t\t\t// cout<<""Add ""<<u<<\' \'<<d[u]<<endl;\n\t\t\tT.add(u,d[u]);\n\t\t\td[u]=0;\n\t\t}\n\t\tfor(auto it:vec[i]) ans[it.second]=T.ask(n)-T.ask(it.first-1);\n\t}\n\tfor(int i=1;i<=m;i++) cout<<ans[i]<<"" \\n""[i==m];\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(""Otomachi_Una.in"",""r"",stdin);\n\t// freopen(""Otomachi_Una.out"",""w"",stdout);\n\tfor(int i=1;i<MAXN;i++) for(int j=i;j<MAXN;j+=i) di[j].push_back(i);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}']",,,"['2-sat', 'data structures', 'dfs and similar', 'dp']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Nobody is needed.json,https://codeforces.com//blog/entry/127439,Let s iterate the left boundary of our queries from to and maintain the Fenwick tree where the number of sought sets of indices in which and Then the answer to the query with the left boundary at will be the sum over the interval in our Fenwick tree Now we just need to learn how to update our tree when transitioning from to Some new sets of indices may have been added starting at Let s denote as the position of the number in the permutation We ll create an auxiliary array We ll learn to calculate the dynamics the number of sought sets of indices where The base case will be Suppose we know the value of Then we can update if is divisible by and We can calculate this dynamics straightforwardly iterating over and is divisible by and is divisible by Notice that this will work in total for for the permutation Now we can iterate over all numbers again that are multiples of update the Fenwick tree and clear the array to reuse it in the future 
https://codeforces.com//contest/251/problem/C,2347,C,251C,251,C. Number Transformation,Little Petya likes positive integers a lot Recently his mom has presented him a positive integer There s only one thing Petya likes more than numbers playing with little Masha It turned out that Masha already has a positive integer Petya decided to turn his number into the number consecutively performing the operations of the following two types Subtract 1 from his number Choose any integer from to inclusive Then subtract number from his number Operation means taking the remainder from division of number by number Petya performs one operation per second Each time he chooses an operation to perform during the current move no matter what kind of operations he has performed by that moment In particular this implies that he can perform the same operation any number of times in a row Now he wonders in what minimum number of seconds he could transform his number into number Please note that numbers in the operations of the second type are selected anew each time independently of each other ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nconst int m = 360360;\n\nint k;\nint f[m+10];\n\nint go(int from, int to) {\n  int i, j;\n  for (i=0;i<m;i++) f[i] = 42424242;\n  f[from] = 0;\n  for (i=m-1;i>=1;i--)\n    if (f[i] < 42424242) {\n      if (f[i]+1 < f[i-1]) f[i-1] = f[i]+1;\n      for (j=2;j<=k;j++) {\n        int z = i-(i % j);\n        if (f[i]+1 < f[z]) f[z] = f[i]+1;\n      }\n    }\n  return f[to];\n}\n\nint main() {\n//  freopen(""in"", ""r"", stdin);\n//  freopen(""out"", ""w"", stdout);\n  long long a, b;\n  cin >> a >> b >> k;\n  long long ans = 0;\n  if (a/m == b/m) {\n    ans = go(a % m, b % m);\n  } else {\n    ans = go(a % m, 0);\n    ans += 1+go(m-1, b % m);\n    ans += (long long)(1+go(m-1, 0))*(a/m - b/m - 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n']",,,"['dp', 'greedy', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Number Transformation.json,https://codeforces.com//blog/entry/6054,Let be the least common multiple of all numbers from 2 to inclusive Note that if is divisible by then we can t decrease it with applying an operation of the second type It means that any optimal sequence of transformations will contain all numbers divisible by which are located between and Let s split our interval from to into several intervals between the numbers divisible by It may happen that the first and the last intervals will have length less than Now we can solve the problem for the first interval the last interval and for any interval between them After that we need to multiply the last result by the total number of intervals excluding the first and the last ones The only thing left is to add up obtained 3 values In order to solve the problem for one interval one can simply use bfs Be careful in the cases when we have only 1 or 2 intervals The complexity of described solution is 
https://codeforces.com//contest/1244/problem/F,438885,F,1244F,1244,F. Chips,There are n chips arranged in a circle numbered from 1 to n Initially each chip has black or white color Then k iterations occur During each iteration the chips change their colors according to the following rules For each chip i three chips are considered chip i itself and two its neighbours If the number of white chips among these three is greater than the number of black chips among these three chips then the chip i becomes white Otherwise the chip i becomes black Note that for each i from 2 to n 1 two neighbouring chips have numbers i 1 and i 1 The neighbours for the chip i 1 are n and 2 The neighbours of i n are n 1 and 1 The following picture describes one iteration with n 6 The chips 1 3 and 4 are initially black and the chips 2 5 and 6 are white After the iteration 2 3 and 4 become black and 1 5 and 6 become white Your task is to determine the color of each chip after k iterations ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar s[2000010];\nint a[2000010];\nvector<int> q;\ninline void check(int x, int rnd) {\n    if(a[x]) return;\n    a[x] = rnd;\n    int now = s[x];\n    if(rnd & 1) now = \'W\' + \'B\' - now;\n    int last = (x - 1 + n) % n, nxt = (x + 1) % n;\n    if((a[last] && a[last] != rnd) && (a[nxt] && a[nxt] != rnd)) s[x] = now;\n    else if(a[last] && (a[last] != rnd)) s[x] = s[last];\n    else s[x] = s[nxt];\n    q.push_back(x);\n}\nint main() {\n    scanf(""%d%d"", &n, &k);\n    scanf(""%s"", s);\n    for(int i = 0; i < n; i++) {\n        if(s[i] == s[(i - 1 + n) % n] || s[i] == s[(i + 1) % n]) a[i] = -1, q.push_back(i);\n    }\n    for(int i = 1; i <= k; i++) {\n        if(q.empty()) break;\n        vector<int> tmp = q;\n        q.clear();\n        for(auto j : tmp) {\n            check((j - 1 + n) % n, i);\n            check((j + 1) % n, i);\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        if(a[i] == 0 && (k % 2)) s[i] = \'W\' + \'B\' - s[i];\n    }\n    return puts(s), 0;\n}']",,,"['constructive algorithms', 'implementation']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Chips.json,https://codeforces.com//blog/entry/70553,The main observation for this problem is the following a chip changes its color if and only if both of its neighbours have the opposite colors so a chip changes its color only if both of its neighbours are and vice versa Let s denote such chips as and also let s denote an as a maximum by inclusion sequence of consecutive unstable chips Let s analyze each unstable segment If it covers the whole circle then the whole circle changes during each iteration so the answer depends on whether is odd or even Otherwise the unstable segment we analyze is bounded by two stable chips When the first chip in the unstable segment changes its color becomes equal to the color of its neighbour that does not belong to the unstable segment We can also say the same for the last chip So during each iteration all chips in the unstable segment change their colors and after that the segment shrinks the first and the last chip become stable and won t change their colors anymore All that s left is to find all unstable segments and analyze how they change 
https://codeforces.com//contest/434/problem/B,9713,B,434B,434,B. Nanami s Digital Board,Nanami is an expert at playing games This day Nanami s good friend Hajime invited her to watch a game of baseball Unwilling as she was she followed him to the stadium But Nanami had no interest in the game so she looked around to see if there was something that might interest her That s when she saw the digital board at one end of the stadium The digital board is pixels in height and pixels in width every pixel is either light or dark The pixels are described by its coordinate The th pixel of the th line is pixel The board displays messages by switching a combination of pixels to light and the rest to dark Nanami notices that the state of the pixels on the board changes from time to time At certain times certain pixels on the board may switch from light to dark or from dark to light Nanami wonders what is the area of the biggest light block such that a specific pixel is on its side A light block is a sub rectangle of the board in which all pixels are light Pixel belongs to a side of sub rectangle with and as its upper left and lower right vertex if and only if it satisfies the logical condition or and or or and Nanami has all the history of changing pixels also she has some questions of the described type can you answer them ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\nint n, m, q;\nconst int MAX_N = 1000 + 10;\nint a[MAX_N][MAX_N];\n\nstruct TR {\n\tbool flip, swap;\n\tint n;\n\n\tTR() {\n\t}\n\n\tTR(bool f, bool s, int n) :\n\t\t\tflip(f), swap(s), n(n) {\n\t}\n\n\tvoid trans(int&r, int&c) {\n\t\tif (swap) {\n\t\t\tstd::swap(r, c);\n\t\t}\n\t\tif (flip) {\n\t\t\tr = n - 1 - r;\n\t\t}\n\t}\n};\n\nstruct Board {\n\tint a[MAX_N][MAX_N], n, m;\n\tint up[MAX_N][MAX_N]; //r,c\n\tTR tr;\n\n\tvoid init(int n, int m, TR tr) {\n\t\tthis->n = n, this->m = m;\n\t\tthis->tr = tr;\n\t}\n\n\tvoid set(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t}\n\n\tvoid reset(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t\tprocessCol(c);\n\t}\n\n\tvoid processCol(int c) {\n\t\tup[0][c] = a[0][c];\n\t\tfor (int r = 1; r < n; ++r) {\n\t\t\tif (a[r][c] == 1) {\n\t\t\t\tup[r][c] = up[r - 1][c] + 1;\n\t\t\t} else {\n\t\t\t\tup[r][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid doit() {\n\t\tfor (int c = 0; c < m; ++c) {\n\t\t\tprocessCol(c);\n\t\t}\n\t}\n\n\tint ask(int r, int c) {\n\t\ttr.trans(r, c);\n//\t\tcout << r << "" "" << c << endl;\n\t\t//at row r, above it ,contain column c\n\t\t//min at left\n\t\tstatic int what[MAX_N];\n\t\twhat[c] = up[r][c];\n\t\tfor (int i = c - 1; i >= 0; --i) {\n\t\t\twhat[i] = min(what[i + 1], up[r][i]);\n\t\t}\n\t\tfor (int i = c + 1; i < m; ++i) {\n\t\t\twhat[i] = min(what[i - 1], up[r][i]);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint R = c;\n\t\tfor (int i = c; i >= 0; --i) {\n\t\t\twhile (R + 1 < m && what[R + 1] >= what[i])\n\t\t\t\t++R;\n\t\t\tans = max(ans, what[i] * (R - i + 1));\n\t\t}\n\t\tint L = c;\n\t\tfor (int i = c; i < m; ++i) {\n\t\t\twhile (L > 0 && what[L - 1] >= what[i])\n\t\t\t\t--L;\n\t\t\tans = max(ans, what[i] * (i - L + 1));\n\t\t}\n\t\treturn ans;\n\t}\n} D[4];\n\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tscanf(""%d"", a[i] + j);\n\t\t}\n\t}\n\tD[0].init(n, m, TR(false, false, n));\n\tD[1].init(n, m, TR(true, false, n));\n\tD[2].init(m, n, TR(false, true, m));\n\tD[3].init(m, n, TR(true, true, m));\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\tD[i].set(r, c, a[r][c]);\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < D[i].m; ++c) {\n\t\t\tD[i].processCol(c);\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tint op;\n\t\tscanf(""%d"", &op);\n\t\tif (op == 1) {\n\t\t\tint r, c;\n\t\t\tscanf(""%d%d"", &r, &c), --r, --c;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tD[i].reset(r, c, 1 - a[r][c]);\n\t\t\t}\n\t\t\ta[r][c] = 1 - a[r][c];\n\t\t} else {\n\t\t\tint r, c;\n\t\t\tscanf(""%d%d"", &r, &c), --r, --c;\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tans = max(ans, D[i].ask(r, c));\n\t\t\t}\n\t\t\tprintf(""%d\\n"", ans);\n\t\t}\n\t}\n}\n']",,,"['divide and conquer', 'dp', 'dsu', 'implementation', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Nanami s Digital Board.json,https://codeforces.com//blog/entry/12397,Consider a similar problem find the maximum light block of the whole board Constraints to this problem are the same as the original problem but with no further operations A brute force idea would be to enumerate all four edges of the block checking can be done with two dimensional prefix sums so the time complexity is Obviously it would receive a TLE verdict Why should we enumerate all four edges Let s enumerate the lower and upper edge and now our problem is only one dimensional which can be easily solved in time Now our complexity is still not fast enough Let s try to enumerate the lower edge only and now what we have is an array denoting the maximum height of each column To be specific suppose the lower edge is row then is the maximum value such that are all light If we choose columns and as the left and right edge then the area of the maximum light block with these three sides fixed would be Let what if we enumerate and find the leftmost and the rightmost To be more specific we enumerate a column and let the height of this column be the height of the block Now we want to stretch the left and right sides of the block so we re looking for the leftmost column such that Similarly look for the rightmost column then the maximum light block with its lower edge and a point in the upper edge fixed would be This approach can be optimized with disjoint set unions abbr DSU Imagine that initially the array is empty Let s add the elements of one by one from the largest to the smallest Maintain two DSUs and denote them as and When we add an element set the father of as in so that will be skipped during the find operation of DSU Similarly set the father of as in Simply find the root of in and and we would have and Now this problem can be solved in quasi quadratic time We can actually further optimize it to quadratic time using monotonic queues but we ll not talk about it here Let s go back to the original problem Suppose there are no modifications operations only contain queries Then we could simply maintain the array of every row and similarly maintain and arrays Use the approach described above to achieve quasi linear time for the answering of a query Now consider modifications Modification of a single pixel only changes the values of positions of the arrays So modifications can be handled in linear time The total complexity for the algorithm is where is the inverse of the Ackermann function which is often seen in the analysis of the time complexity of DSUs Solution 6712937 6713016 
https://codeforces.com//contest/1290/problem/E,529281,E,1290E,1290,E. Cartesian Tree ,Ildar is the algorithm teacher of William and Harris Today Ildar is teaching Cartesian Tree However Harris is sick so Ildar is only teaching William A cartesian tree is a rooted tree that can be constructed from a sequence of distinct integers We build the cartesian tree as follows If the sequence is empty return an empty tree Let the position of the element be x Remove element on the position x from the sequence and break it into the left part and the right part which might be empty not actually removing it just taking it away temporarily Build cartesian tree for each part Create a new vertex for the element that was on the position x which will serve as the root of the new tree Then for the root of the left part and right part if exists will become the children for this vertex Return the tree we have gotten For example this is the cartesian tree for the sequence 4 2 7 3 5 6 1 After teaching what the cartesian tree is Ildar has assigned homework He starts with an empty sequence a In the i th round he inserts an element with value i somewhere in a Then he asks a question what is the sum of the sizes of the subtrees for every node in the cartesian tree for the current sequence a Node v is in the node u subtree if and only if v u or v is in the subtree of one of the vertex u children The size of the subtree of node u is the number of nodes v such that v is in the subtree of u Ildar will do n rounds in total The homework is the sequence of answers to the n questions The next day Ildar told Harris that he has to complete the homework as well Harris obtained the final state of the sequence a from William However he has no idea how to find the answers to the n questions Help Harris ,"['#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int inf=1e8;\nint n,a[1500010],b[1500010],f[1500010],p;\nstruct st\n{\n    int f[2000010],g[2000010],x[2000010],ad[2000010],mi[2000010];\n    L s[2000010];\n    inline void down(int i,int k)\n    {\n        if(ad[i])\n          {\n           ad[i<<1]+=ad[i];\n           mi[i<<1]+=ad[i];\n           f[i<<1]+=ad[i];\n           g[i<<1]+=ad[i];\n           s[i<<1]+=(L)(k>>1)*ad[i];\n           ad[(i<<1)|1]+=ad[i];\n           mi[(i<<1)|1]+=ad[i];\n           f[(i<<1)|1]+=ad[i];\n           g[(i<<1)|1]+=ad[i];\n           s[(i<<1)|1]+=(L)(k>>1)*ad[i];\n           ad[i]=0;\n          }\n        if(mi[i]<f[i<<1])\n          {\n           mi[i<<1]=mi[i];\n           s[i<<1]-=(L)x[i<<1]*(f[i<<1]-mi[i]);\n           f[i<<1]=mi[i];\n          }\n        if(mi[i]<f[(i<<1)|1])\n          {\n           mi[(i<<1)|1]=mi[i];\n           s[(i<<1)|1]-=(L)x[(i<<1)|1]*(f[(i<<1)|1]-mi[i]);\n           f[(i<<1)|1]=mi[i];\n          }\n        mi[i]=inf;\n    }\n    inline void upd(int i)\n    {\n        s[i]=s[i<<1]+s[(i<<1)|1];\n        f[i]=max(f[i<<1],f[(i<<1)|1]);\n        x[i]=0;\n        if(f[i]==f[i<<1])\n          x[i]+=x[i<<1];\n        if(f[i]==f[(i<<1)|1])\n          x[i]+=x[(i<<1)|1];\n        g[i]=-inf;\n        if(f[i]==f[i<<1])\n          g[i]=max(g[i],g[i<<1]);\n        else\n          g[i]=max(g[i],f[i<<1]);\n        if(f[i]==f[(i<<1)|1])\n          g[i]=max(g[i],g[(i<<1)|1]);\n        else\n          g[i]=max(g[i],f[(i<<1)|1]);\n    }\n    inline void add(int i,int j,int k,int l,int r,int p)\n    {\n        if(l<=j && k<=r)\n          {\n           ad[i]+=p;\n           mi[i]+=p;\n           f[i]+=p;\n           g[i]+=p;\n           s[i]+=(k-j+1)*p;\n          }\n        else\n          {\n           down(i,k-j+1);\n           if(l<=(j+k>>1))\n             add(i<<1,j,j+k>>1,l,r,p);\n           if(r>(j+k>>1))\n             add((i<<1)|1,(j+k>>1)+1,k,l,r,p);\n           upd(i);\n          }\n    }\n    inline void modify(int i,int j,int k,int l,int p)\n    {\n        if(j==k)\n          {\n           ad[i]=0;\n           mi[i]=inf;\n           f[i]=p;\n           g[i]=0;\n           x[i]=1;\n           s[i]=p;\n          }\n        else\n          {\n           down(i,k-j+1);\n           if(l<=(j+k>>1))\n             modify(i<<1,j,j+k>>1,l,p);\n           else\n             modify((i<<1)|1,(j+k>>1)+1,k,l,p);\n           upd(i);\n          }\n    }\n    inline void minn(int i,int j,int k,int l,int r,int p)\n    {\n        if(p>=f[i])\n          return;\n        down(i,k-j+1);\n        if(l<=j && k<=r && p>g[i])\n          {\n           mi[i]=p;\n           s[i]-=(L)x[i]*(f[i]-p);\n           f[i]=p;\n          }\n        else\n          {\n           if(l<=(j+k>>1))\n             minn(i<<1,j,j+k>>1,l,r,p);\n           if(r>(j+k>>1))\n             minn((i<<1)|1,(j+k>>1)+1,k,l,r,p);\n           upd(i);\n          }\n    }\n}x,y;\ninline void add(int i)\n{\n    for(;i<=n;i+=(i&-i))\n      f[i]++;\n}\ninline int sum(int i)\n{\n    int k=0;\n    for(;i;i^=(i&-i))\n      k+=f[i];\n    return k;\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k;\n\tscanf(""%d"",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(""%d"",&a[i]),b[a[i]]=i;\n\tfor(p=1;p<n;p<<=1);\n\tfor(i=1;i<2*p;i++)\n\t  x.mi[i]=y.mi[i]=inf;\n\tfor(i=1;i<=n;i++)\n\t  {\n       x.f[p+i-1]=1;\n       x.x[p+i-1]=1;\n       x.s[p+i-1]=1;\n       y.f[p+i-1]=n-1;\n       y.x[p+i-1]=1;\n       y.s[p+i-1]=n-1;\n      }\n    for(i=p-1;i>0;i--)\n      {\n       x.upd(i);\n       y.upd(i);\n      }\n\tfor(i=1;i<=n;i++)\n\t  {\n       j=b[i];\n       add(b[i]);\n       k=sum(b[i]);\n       if(j<n)\n         x.add(1,1,p,j+1,n,1);\n       if(j>1)\n         x.minn(1,1,p,1,j-1,k);\n       x.modify(1,1,p,j,i+1);\n       if(j<n)\n         y.add(1,1,p,j+1,n,-1);\n       if(j<n)\n         y.minn(1,1,p,j+1,n,n-(k+1));\n       y.modify(1,1,p,j,n-1);\n       printf(""%lld\\n"",x.s[1]-((L)n*n-y.s[1]));\n      }\n\treturn 0;\n}\n']",,,['data structures'],3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Cartesian Tree .json,https://codeforces.com//blog/entry/73563,Instead of inserting numbers one by one let s imagine I have blanks in a row and I will fill the blanks with integers from in order and I want to know about the cartesian tree after each blank filled In the following parts of the solution I will use positions in the original array instead of positions in the contracted array to label things In the process of building a cartesian tree a node is created for each recursive call of building a tree for a subarray Let s label the node created at that moment to be We realize that will be the size of the subtree of that node However in our problem some positions can be blanks so the actual subtree size of a node is the number of positions that are not blanks in the subarray So now we are finding the sum of the number of non blanks in the range for each node in our cartesian tree Let be the number of non blanks in the first positions of the sequence Then we are finding sum of for each node To proceed observe a property for a cartesian tree Let s define for each integer let to be the largest such that is a node or just if there is no nodes of the form Similarly define to be the smallest such that is a node Then for each node of the following is true Except when is the root If we know sum of over all that is not sum of over all that is not sum of over all that is not sum of over all that is not Then we can find out the answer As it is more or less symmetric I will only care about part 1 and 2 from now on Let s find out what would happen to nodes of our tree if we fill into position replacing a blank Let s omit how the nodes connect each other and just track the labels of each node For convenience we will make the following definitions Call the nearest non blank position on the left side of Call the nearest non blank position on the right side of Call the leftmost non blank position Call the rightmost non blank position Firstly every node that is of the form where will be split into two halves of and Then duplicates nodes that represent the same range will be removed Finally there will be a new node that would represent the root which is Let s track how changes for all p in the range Some modification to values of and As the first step doesn t change whether values are or not and modifications to the second step can be easily handled part 2 can be easily maintained by a Fenwick tree So it remains to compute part 1 Imagine instead of computing sum of we are computing sum of Then we realise that we are having a Segment Tree Beats problem You have to maintain a sequence with 3 kinds of operation Do for in Query the sum of the whole array Check part 2 of this blog and this proof of time complexity Then we can solve this variation of the problem in So we have to modify the above variant into solving the real problem Look at what we do every time we are doing query 1 We are doing a total of times of changing some occurrences of value to value Which means we can maintain the frequency for values of Therefore for each put tag operation in our segment tree beats we just modify a Fenwick tree that represents the frequency of values in Because we have updates to the segment tree the total time complexity is It is also possible to replace with and we can support online queries but it is not required to pass this problem We also allowed methods of slower complexity i e to pass It basically is the same but does the above things by sqrt decomposition instead Care is needed to be sure that there is no extra factor 
https://codeforces.com//contest/493/problem/C,18744,C,493C,493,C. Vasya and Basketball,Vasya follows a basketball game and marks the distances from which each team makes a throw He knows that each successful throw has value of either 2 or 3 points A throw is worth 2 points if the distance it was made from doesn t exceed some value of meters and a throw is worth 3 points if the distance is larger than meters where is some integer Vasya would like the advantage of the points scored by the first team the points of the first team minus the points of the second team to be maximum For that he can mentally choose the value of Help him to do that ,"['#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\nusing namespace std;\n\nstruct Node\n{\n    int team;\n    int dist;\n};\n\nbool cmp(const Node &a, const Node &b)\n{\n    return a.dist < b.dist;\n}\n\nNode node[1000006];\n\nint scorea, scoreb;\nint cura, curb;\n\nint main()\n{\n    int n, m;\n    cin>>n;\n    for(int i = 0; i < n; ++i)\n    {\n        node[i].team = 1;\n        cin>>node[i].dist;\n    }\n    \n    cin>>m;\n    for(int i = 0; i < m; ++i)\n    {\n        node[i+n].team = 2;\n        cin>>node[i+n].dist;\n    }\n    \n    cura = scorea = n*2;\n    curb = scoreb = m*2;\n    n+=m;\n    \n    sort(node, node+n, cmp);\n    \n    for(int i = n-1; i >= 0;)\n    {       \n        do\n        {\n            if(node[i].team == 1)\n                cura++;\n            else\n                curb++;\n            i--;\n        }\n        while(i >= 0 && node[i].dist == node[i+1].dist);\n        \n        if((cura - curb > scorea - scoreb) || (cura - curb == scorea - scoreb && cura > scorea))\n        {\n            scorea = cura;\n            scoreb = curb;\n        }\n        \n    }\n    \n    cout<<scorea<<"":""<<scoreb<<endl;\n}']",,,"['binary search', 'brute force', 'data structures', 'implementation', 'sortings', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Vasya and Basketball.json,https://codeforces.com//blog/entry/14985,We need an array of pairs in each pair we save the distance and the number of team Then we sort the array Then we assume that all the throws bring 3 points Then we pass by the array and one of our numbers we decrease on 1 which one it depends on the second element of array Then we compare it with our answer In the end we print our answer 
https://codeforces.com//contest/1316/problem/E,552824,E,1316E,1316,E. Team Building,Alice the president of club FCB wants to build a team for the new volleyball tournament The team should consist of p players playing in p different positions She also recognizes the importance of audience support so she wants to select k people as part of the audience There are n people in Byteland Alice needs to select exactly p players one for each position and exactly k members of the audience from this pool of n people Her ultimate goal is to maximize the total strength of the club The i th of the n persons has an integer a i associated with him the strength he adds to the club if he is selected as a member of the audience For each person i and for each position j Alice knows s i j the strength added by the i th person to the club if he is selected to play in the j th position Each person can be selected at most once as a player or a member of the audience You have to choose exactly one player for each position Since Alice is busy she needs you to help her find the maximum possible strength of the club that can be achieved by an optimal choice of players and the audience ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nvoid upd(long long& a, long long b) {\n\ta = max(a, b);\n}\nint bx[10001];\nint a[200001];\nint s[200001][8];\nlong long f[100005][130];\nint n, p, k;\nint b[100005];\nbool cmp(const int& x, const int& y) {\n\treturn a[x] < a[y];\n}\n\n\nint main( ) {\n\tscanf(""%d %d %d"", &n, &p, &k);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf(""%d"", &a[i]);\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= p; j ++)\n\t\t\tscanf(""%d"", &s[i][j]);\n\tfor (int i = 1; i <= n; i ++) b[i] = i;\t\n\tsort(b + 1, b + 1 + n, cmp);\n\treverse(b + 1, b + 1 + n);\n\t\n\tfor (int i = 1; i < (1 << p); i ++)\n\t\tbx[i] = bx[i - (i & -i)] + 1;\n\tlong long ans = 0;\n\tfor (int r = 0; r <= n; ++ r)\n\t\tfor (int S = 0; S < (1 << p); ++ S)\n\t\t\tf[r][S] = -0x3f3f3f3f3f3f3f3fLL;\n\tf[0][0] = 0;\n\tfor (int r = 1; r <= n; ++ r) {\n\t\tfor (int S = 0; S < (1 << p); ++ S) {\n\t\t\tfor (int j = 1; j <= p; j ++) {\n\t\t\t\tif ((S >> (j - 1)) & 1) continue;\n\t\t\t\tint i = b[r];\n\t\t\t\tupd(f[r][S | (1 << (j - 1))], f[r - 1][S] + s[i][j]);\n\t\t\t}\n\t\t\tint N = r - 1 - bx[S];\n\t\t\tif (N < k) upd(f[r][S], f[r - 1][S] + a[b[r]]);\n\t\t\telse upd(f[r][S], f[r - 1][S]);\n\t\t}\n\t}\n\tfor (int r = 1; r <= n; ++ r) \n\t\tfor (int S = 0; S < (1 << p); ++ S) {\n\t\t\tans = max(ans, f[r][S]);\n\t\t}\n\tprintf(""%lld\\n"", ans);\n\treturn 0;\n}\n\n']",,,"['bitmasks', 'dp', 'greedy', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Team Building.json,https://codeforces.com//blog/entry/74493,Idea is DP bitmask First sort the people in non increasing order of let maximum strength of the club if we choose players from mask tells us about the positions in the team which have been covered Don t worry about the audience part as of now we will see how it is handled during transitions initial state Lets try to find If the th person is chosen to play in th position If we don t choose as a player then we can take him as an audience member or not take him at all I claim that if the no of audience members chosen till now then we must select as an audience member We can prove this If we don t select as audience we will need to select some strength in that case will include but not but as it is always better to select We now need to know how many audience members have been selected for state let be the no of persons who have not been selected as players then no of set bits in mask By the above logic we can say that if we have chosen already k audience members So the solution becomes if then 2 else 2 You need to choose maximum of and as would be the answer to our question Time Complexity 
https://codeforces.com//contest/689/problem/D,64400,D,689D,689,D. Friends and Subsequences,Mike and Mike are old childhood rivals they are opposite in everything they do except programming Today they have a problem they cannot solve on their own but together with you who knows Every one of them has an integer sequences and of length Being given a query of the form of pair of integers Mike can instantly tell the value of while Mike can instantly tell the value of Now suppose a robot you asks them all possible different queries of pairs of integers so he will make exactly queries and counts how many times their answers coincide thus for how many pairs is satisfied How many occasions will the robot count ,"['#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 200100;\n\nll sol;\nint a[N], b[20][N], lg[N], lef[N], rig[N], st[N], t, n, lefumic, lefuegal, rigumic, riguegal;\nint find(int st, int dr) {\n    int dif = dr - st + 1;\n    int l = lg[dif];\n    int dist = dif - (1<<l);\n    return max(b[l][st],b[l][st+dist]);\n}\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""a.in"", ""r"", stdin);\n    freopen(""a.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n;\n    FOR(i,1,n) {\n        cin >> b[0][i];\n    }\n    FOR(i,1,n) {\n        cin >> a[i];\n    }\n    FOR(i,2,n) {\n        lg[i] = lg[i / 2] + 1;\n    }\n    for(int p = 1; (1<<p) <= n; ++p) {\n        FOR(j,1,n-(1<<p)+1) {\n            int l = 1<<(p-1);\n            b[p][j] = max(b[p-1][j],b[p-1][j+l]);\n        }\n    }\n    FOR(i,1,n) {\n        while (t && a[i] < a[st[t]]) {\n            rig[st[t]] = i - 1;\n            --t;\n        }\n        st[++t] = i;\n    }\n    while(t) {\n        rig[st[t]] = n;\n        --t;\n    }\n    ROF(i,n,1) {\n        while (t && a[i] <= a[st[t]]) {\n            lef[st[t]] = i + 1;\n            --t;\n        }\n        st[++t] = i;\n    }\n    while(t) {\n        lef[st[t]] = 1;\n        --t;\n    }\n    FOR(i,1,n) {\n        int st = lef[i];\n        int dr = rig[i];\n        int lefu = st;\n        int rigu = i;\n        lefumic = i + 1;\n        while (lefu <= rigu) {\n            int mij = (lefu + rigu) >> 1;\n            if (find(mij,i) < a[i]) {\n                lefumic = mij;\n                rigu = mij - 1;\n            } else {\n                lefu = mij + 1;\n            }\n        }\n        lefu = st;\n        rigu = i;\n        lefuegal = i + 1;\n        while (lefu <= rigu) {\n            int mij = (lefu + rigu) >> 1;\n            if (find(mij,i) <= a[i]) {\n                lefuegal = mij;\n                rigu = mij - 1;\n            } else {\n                lefu = mij + 1;\n            }\n        }\n        lefu = i;\n        rigu = dr;\n        rigumic = i - 1;\n        while (lefu <= rigu) {\n            int mij = (lefu + rigu) >> 1;\n            if (find(i,mij) < a[i]) {\n                rigumic = mij;\n                lefu = mij + 1;\n            } else {\n                rigu = mij - 1;\n            }\n        }\n        lefu = i;\n        rigu = dr;\n        riguegal = i - 1;\n        while (lefu <= rigu) {\n            int mij = (lefu + rigu) >> 1;\n            if (find(i,mij) <= a[i]) {\n                riguegal = mij;\n                lefu = mij + 1;\n            } else {\n                rigu = mij - 1;\n            }\n        }\n        sol += 1LL * (riguegal-rigumic) * (lefumic-lefuegal) + 1LL * (riguegal-rigumic) * (i - lefumic + 1) + 1LL * (lefumic - lefuegal) * (rigumic - i + 1);\n    }\n    cout << sol;\n    return 0;\n}']",,,"['binary search', 'data structures']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Friends and Subsequences.json,https://codeforces.com//blog/entry/45912,First of all it is easy to see that if we fix l then have So we can just use binary search to find the smallest index rmin and biggest index rmax that satisfy the equality and add rmax rmin 1 to our answer To find the min and max values on a segment l r we can use Range Minimum Query data structure 
https://codeforces.com//contest/1205/problem/F,390602,F,1205F,1205,F. Beauty of a Permutation,Define the beauty of a permutation of numbers from 1 to n p 1 p 2 dots p n as number of pairs L R such that 1 le L le R le n and numbers p L p L 1 dots p R are consecutive R L 1 numbers in some order For example the beauty of the permutation 1 2 5 3 4 equals 9 and segments corresponding to pairs are 1 2 5 4 3 1 2 3 4 5 3 4 1 2 5 3 4 Answer q independent queries In each query you will be given integers n and k Determine if there exists a permutation of numbers from 1 to n with beauty equal to k and if there exists output one of them ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\npii h[105][105*107/2];\nint q,N[SZ],K[SZ];\nvector<int> aa[SZ];\nvector<int> qry[105][105*107/2];\nvector<int> ch[SZ];\nint an=0,ty[SZ];\nvector<int> op;\nvoid dfs(int w,int d=0)\n{\n//\tcerr<<w<<""!""<<ty[w]<<"":"";\n//\tfor(auto c:ch[w]) cout<<c<<"","";\n//\tcout<<""\\n"";\n\tif(!ch[w].size())\n\t{\n\t\top.pb(w);\n\t\treturn;\n\t}\n\tif(ty[w]==1)\n\t{\n\t\tvector<int> sb;\n\t\tint s=ch[w].size();\n\t\tfor(int t=1;t<s;t+=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tsb.pb(ch[w][0]);\n\t\tfor(int t=(s-1)-((s-1)&1);t>0;t-=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n\telse\n\t{\n\t\tvector<int> sb;\n\t\tfor(auto r:ch[w]) sb.pb(r);\n\t\tif(d) reverse(sb.begin(),sb.end());\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n}\nvector<int> cons(int n,int p)\n{\n//\tcerr<<n<<"",""<<p<<""\\n"";\n\tan=n;\n\tvector<int> st;\n\tfor(int i=1;i<=n;++i) ty[i]=0,ch[i].clear(),st.pb(i);\n\tint X=1,Y=p;\n\twhile(X!=n)\n\t{\n\t\tpii g=h[X][Y];\n\t\tassert(g.fi!=-1);\n\t\tint y=g.se%2; g.se/=2;\n\t\tint c=g.fi-X+1;\n\t\ttie(X,Y)=g;\n\t\t++an; ty[an]=y; ch[an].clear();\n\t\tfor(int j=1;j<=c;++j)\n\t\t\tch[an].pb(st.back()),st.pop_back();\n\t\treverse(ch[an].begin(),ch[an].end());\n\t\tst.pb(an);\n\t}\n\tassert(Y==n&&st.size()==1);\n\top.clear();\n\tdfs(an);\n\t#ifdef LOCAL\n\t#warning ""LOCAL ON""\n\tassert(op.size()==n);\n\tint sb=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tvector<int> g;\n\t\tfor(int j=i;j<n;++j)\n\t\t{\n\t\t\tg.pb(op[j]);\n\t\t\tsort(g.begin(),g.end());\n\t\t\tbool ok=1;\n\t\t\tfor(int w=0;w<g.size();++w)\n\t\t\t\tok&=g[w]==g[0]+w;\n\t\t\tif(ok) ++sb;\n\t\t}\n\t}\n//\tcerr<<sb<<""?\\n"";\n\tassert(sb==p);\n\t#endif\n\treturn op;\n}\nint main()\n{\n\tscanf(""%d"",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(""%d%d"",N+i,K+i),\n\t\tqry[N[i]][K[i]].pb(i);\n\tfor(int n=1;n<=100;++n)\n\t{\n\tmemset(h,-1,sizeof h);\n\th[n][n]=pii(0,0);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tfor(int j=n*(n+1)/2;j>=0;--j) if(~h[i][j].fi)\n\t\t{\n\t\t\tfor(int c=2;c<=i;++c)\n\t\t\t{\n\t\t\t\th[i-c+1][j+c*(c-1)/2]=pii(i,j*2);\n\t\t\t\tif(c>=4) h[i-c+1][j+1]=pii(i,j*2+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=n*(n+1)/2;j>=0;--j)\n\t\tif(h[1][j].fi!=-1&&qry[n][j].size())\n\t\t{\n\t\t\tauto u=cons(n,j);\n\t\t\tfor(auto r:qry[n][j]) aa[r]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tif(aa[i].size())\n\t\t{\n\t\t\tputs(""YES"");\n\t\t\tfor(auto x:aa[i])\n\t\t\t\tprintf(""%d "",x);\n\t\t\tputs("""");\n\t\t}\n\t\telse\n\t\t\tputs(""NO"");\n}\n']",,,"['constructive algorithms', 'math']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Beauty of a Permutation.json,https://codeforces.com/blog/entry/69158,We will denote if there exists a permutation of length with beauty equal to To begin with it is obvious that the beauty of a permutation of length is at least for indeed you can take each element individually and the entire permutation completely Statement 1 if and then Let be a permutation of length whose beauty is and be a permutation of length whose beauty is equal to Let us build from them a permutation of length whose beauty is We expand in the permutation to and to the rest of the elements greater than add We got a permutation of length Denote it by If is not between then we reverse the first elements and this will be done in a new permutation Now let be between Then what good pairs do we have in There are good pairs among the first elements there are good pairs if you count the first elements in one and we counted the interval from the first elements twice so we counted pairs At the same time this is all pairs because if some good segment contains and then it must contain as well Thus this statement is proved Statement 2 if then either or or exist such that and Show it We will call subsegments consisting of several consecutive numbers in some order Consider some kind of permutation of length of beauty Suppose that We want to show that in the permutation there is some good subsegment of length not equal to or with the following property for any other good subsegment if and intersect then one of them contains the second In this case by analogy with the proof of Proposition 1 we can squeeze the segment into one element obtaining some kind of permutation Then the number of good segments in the entire permutation will be equal to the number of good sub segments on the segment the number of good segments in since we counted the segment twice We will call such a segment Thus if in each permutation there is then the statement is true Suppose that then in the permutation there is a good segment of length not equal to or Let s say he s not very good Then there is another We denote if there exists a permutation of length with beauty equal to To begin with it is obvious that the beauty of a permutation of length is at least for indeed you can take each element individually and the entire permutation completely Statement 1 if and then Let mdash a permutation of length whose beauty is and mdash a permutation of length whose beauty is equal to Let us build from them a permutation of length whose beauty is We expand in the permutation to and to the rest of the elements greater than add We got a permutation of length Denote it by If is not between then we reverse the first elements and this will be done in a new permutation Now let be between Then what good pairs do we have in There are good pairs among the first elements there are good pairs if you count the first elements in one and we counted the interval from the first elements twice so we counted pairs At the same time this is all pairs because if some good segment contains and then it must contain as well Thus this statement is proved Statement 2 if then either or or such that and Show it We will call subsegments consisting of several consecutive numbers in some order Consider some kind of permutation of length of beauty Suppose that We want to show that in the permutation there is some good subsegment of length not equal to or with the following property for any other good subsegment if and intersect then one of them contains the second In this case by analogy with the proof of Proposition 1 we can squeeze the segment into one element obtaining some kind of permutation Then the number of good segments in the entire permutation will be equal to the number of good sub segments on the segment the number of good segments in since we counted the segment twice We will call such a segment Thus if in each permutation there is then the statement is true Let be a good segment that is not very good Then there is a good segment which intersects with but does not contain and is not contained in it The segments and form together segment It is easy to show that each of them is good and the numbers in the segments go monotonously Let us demonstrate this with an example the first segment is the second is Then together they will give the union of three segments As we can see each of these segments is good and also all numbers in the second segment are larger than all numbers in the first all numbers in the third segment are larger than all numbers in the second Let at the moment we have lined up a chain of good segments going consecutively where the union of any several consecutive ones is a good segment as well as all the numbers in more than all the numbers in or vice versa As long as is not equal to the whole segment we will do this since is very good there is a segment that intersects with it but is not contained in it does not contain It is easy to see that thanks to the segment our chain of good segments is extended Now suppose that is the whole segment While there is a segment of length greater than among the segments we will do the same if then we will find the necessary for it then will be split into two smaller good segments At the end of the process we get good segments of length each and the numbers are sorted monotonously Hence the numbers in the permutation were initially sorted monotonously whence the number of good segments is The statement is proved Now the left is easy for each from to we calculate what beauty values can be in a permutation of length using statement storing the corresponding values After that it is easy to answer the request by building a permutation of the desired beauty according to the algorithm with the approval of Asymptotics of With an incredibly small constant up to on this works for 300 ms Challenge improve the asymptotics to works in less than 30 ms 
https://codeforces.com//contest/630/problem/A,48786,A,630A,630,A. Again Twenty Five ,The HR manager was disappointed again The last applicant failed the interview the same way as 24 previous ones Do I give such a hard task the HR manager thought Just raise number to the power of and get last two digits of the number Yes of course can be rather big and one cannot find the power using a calculator but we need people who are able to think not just follow the instructions Could you pass the interview in the machine vision company in IT City ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    int n;\n    int a, b;\n\n    cout << 25;        \n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']",,,['number theory'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Again Twenty Five .json,https://codeforces.com//blog/entry/23604?locale=en,The problem of getting the last two digits is equivalent to the problem of getting the number modulo 100 So we need to calculate According to the rules of modular arithmetic So Let s note that 52 25 Then And so on All are equal to 25 for all n 2 So to solve the problem one need to just output 25 There is no need to read n 
https://codeforces.com//contest/230/problem/B,1886,B,230B,230,B. T-primes,We know that prime numbers are positive integers that have exactly two distinct positive divisors Similarly we ll call a positive integer if has exactly three distinct positive divisors You are given an array of positive integers For each of them determine whether it is prime or not ,"['#include <cstdio>\n\nlong long num[1000010];\nint notPrime[1000010], cnt;\n\nbool find(long long obj){\n\n    int l = 0, r = cnt;\n    while(l != r){\n        \n        int m = (l + r) / 2;\n        if(obj <= num[m]) r = m;\n        else l = m + 1;\n\n    }\n\n    return l < cnt && num[l] == obj;\n\n}\n\nint main(){\n\n    for(int i = 2; i * i <= 1000000; i++){\n\n        if(notPrime[i]) continue;\n\n        for(int j = i * i; j <= 1000000; j += i){\n            notPrime[j] = 1;\n        }\n\n    }\n\n    for(int i = 2; i <= 1000000; i++){\n        if(!notPrime[i]) num[cnt++] = (long long)i * i;\n    }\n\n    int n;\n    scanf(""%d"" ,&n);\n\n    while(n--){\n\n        long long obj;\n        scanf(""%I64d"" ,&obj);\n\n        puts(find(obj)? ""YES"": ""NO"");\n\n    }\n\n}\n']",,,"['binary search', 'implementation', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. T-primes.json,https://codeforces.com//blog/entry/5437,It can be shown that only squares of prime numbers are T primes and that there are not too many of them as many as there are prime numbers not greater than Precompute these numbers using for example the sieve of Eratosthenes and store them in an array or an std set then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers The complexity of the solution is linear in relation to or where one can also get a tighter bound Sample solution http pastie org 4897166 archived copy 
https://codeforces.com//contest/797/problem/C,103030,C,797C,797,C. Minimal string,Petya recieved a gift of a string with length up to characters for his birthday He took two more empty strings and and decided to play a game This game has two possible moves Extract the character of and append with this character Extract the character of and append with this character Petya wants to get strings and empty and string lexicographically minimal You should write a program that will help Petya win the game ,"['// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e5 + 5, mod = (int) 0;\nint best[N], q[N];\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = (int) s.size();\n\tbest[n] = 1e9;\n\tfor (int j = n - 1; j >= 0; --j) {\n\t\ts[j] -= \'a\';\n\t\tbest[j] = min(best[j + 1], (int) s[j]);\n\t}\n\tstring res = """";\n\tint t = 0;\n\tfor (int j = 0; j < n; ++j) {\n\t\tq[t++] = s[j];\n\t\twhile (t > 0 && q[t - 1] <= best[j + 1]) res += char(q[t - 1] + \'a\'), --t;\n\t}\n\tcout << res << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",,,"['data structures', 'greedy', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Minimal string.json,https://codeforces.com//blog/entry/51588,On every step you should maintain minimal alphabetic letter in current string this can be done by keeping array of 26 cells with number of times each letter appear in string nd updating it on every step Let s call string a stack and use its terms Now you extract letters from one by one Put the letter to the top of the stack Pop letters from the top of stack and push them to answer while they are less or equal than any letter left in string After string becomes empty push all the letters from stack to answer The answer will be lexicographically minimal It is obvious if we consider the case when current top of stack is strictly greater than any character from the remaining string or there is a character in that is strictly less than current top If current top is equal to some character then appending answer with the letter from top won t make answer worse Overall complexity where is the length of the alpabet in our case 
https://codeforces.com//contest/321/problem/A,3263,A,321A,321,A. Ciel and Robot,Fox Ciel has a robot on a 2D plane Initially it is located in 0 0 Fox Ciel code a command to it The command was represented by string Each character of is one move operation There are four move operations at all go up x y x y 1 go down x y x y 1 go left x y x 1 y go right x y x 1 y The robot will do the operations in from left to right and repeat it infinite times Help Fox Ciel to determine if after some steps the robot will located in ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool can[400][400];\n\nint main() {\n\tint a, b;\n\tcin >> a >> b;\n\tstring s;\n\tcin >> s;\n\tint dx = 0, dy = 0;\n\n\tcan[200 + dx][200 + dy] = true;\n\tfor (int i = 0; i < (int) s.size(); ++i) {\n\t\tif (s[i] == \'U\')\n\t\t\t++dy;\n\t\telse if (s[i] == \'D\')\n\t\t\t--dy;\n\t\telse if (s[i] == \'L\')\n\t\t\t--dx;\n\t\telse if (s[i] == \'R\')\n\t\t\t++dx;\n\t\tcan[200 + dx][200 + dy] = true;\n\t}\n\n//a*dx,a*dy\n\n\tfor (int ia = a - 180; ia <= a + 180; ++ia) {\n\t\tfor (int ib = b - 180; ib <= b + 180; ++ib) {\n\t\t\tint c[2], n = 0;\n\t\t\tif (dx == 0) {\n\t\t\t\tif (ia != 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (ia % dx != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tc[n++] = ia / dx;\n\t\t\t}\n\n\t\t\tif (dy == 0) {\n\t\t\t\tif (ib != 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (ib % dy != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tc[n++] = ib / dy;\n\t\t\t}\n\n\t\t\tif (n == 2 && c[0] != c[1])\n\t\t\t\tcontinue;\n\t\t\tif (n > 0 && c[0] < 0)\n\t\t\t\tcontinue;\n\n\t\t\tint da = a - ia, db = b - ib;\n\t\t\tif (can[200 + da][200 + db]) {\n\t\t\t\tcout << ""Yes"" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ""No"" << endl;\n\treturn 0;\n}\n']",,,"['binary search', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Ciel and Robot.json,https://codeforces.com//blog/entry/8192,Note that after Ciel execute string s it will moves dx dy And for each repeat it will alway moves dx dy So the total movement will be k dx dy dx p dy p which dx p dy p denotes the movement after execute first p characters We can enumerate p since 0 p s 100 and check if there are such k exists Note that there are some tricks Many people failed on this test case which no included in the pretest 
https://codeforces.com//contest/1265/problem/A,486708,A,1265A,1265,A. Beautiful String,A string is called beautiful if no two consecutive characters are equal For example and are beautiful strings while and are not Ahcl wants to construct a beautiful string He has a string s consisting of only characters and Ahcl needs to replace each character with one of the three characters or such that the resulting string is beautiful Please help him More formally after replacing all characters the condition s i neq s i 1 should be satisfied for all 1 leq i leq s 1 where s is the length of the string s ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=1e5+5;\nchar s[maxn];\nint n;\nint main(){\n\tint cas=read();\n\twhile(cas--){\n\t\tscanf(""%s"",s+1);\n\t\tn=strlen(s+1);\n\t\tint ok=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[i]==\'?\'){\n\t\t\t\tif(s[i-1]!=\'a\'&&s[i+1]!=\'a\')s[i]=\'a\';\n\t\t\t\telse if(s[i-1]!=\'b\'&&s[i+1]!=\'b\')s[i]=\'b\';\n\t\t\t\telse if(s[i-1]!=\'c\'&&s[i+1]!=\'c\')s[i]=\'c\';\n\t\t\t}else{\n\t\t\t\tif(s[i]==s[i-1]){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(""-1"");\n\t\telse{\n\t\t\tfor(int i=1;i<=n;i++)cout<<s[i];cout<<\'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n\n']",,,"['constructive algorithms', 'greedy']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Beautiful String.json,https://codeforces.com//blog/entry/71995,If string initially contains 2 equal consecutive letters or then the answer is obviously 1 Otherwise it is always possible to replacing all characters to make beautiful We will replacing one at a time and in any order from left to right for example For each since it is adjacent to at most 2 other characters and we have 3 options and for this there always exists at least one option which differ from 2 characters that are adjacent with this Simply find one and replace by it Time comlexity where is length of 
https://codeforces.com//contest/1322/problem/D,555656,D,1322D,1322,D. Reality Show,A popular reality show is recruiting a new cast for the third season n candidates numbered from 1 to n have been interviewed The candidate i has aggressiveness level l i and recruiting this candidate will cost the show s i roubles The show host reviewes applications of all candidates from i 1 to i n by increasing of their indices and for each of them she decides whether to recruit this candidate or not If aggressiveness level of the candidate i is strictly higher than that of any candidates then the candidate i will definitely be rejected Otherwise the host may accept or reject this candidate at her own discretion The host wants to choose the cast so that to maximize the total The show makes revenue as follows For each aggressiveness level v a corresponding profitability value c v is specified which can be positive as well as negative All recruited participants enter the stage one by one by increasing of their indices When the participant i enters the stage events proceed as follows The show makes c l i roubles where l i is initial aggressiveness level of the participant i If there are two participants with the same aggressiveness level on stage they immediately start a fight The outcome of this is the defeated participant is hospitalized and leaves the show aggressiveness level of the victorious participant is increased by one and the show makes c t roubles where t is the new aggressiveness level The fights continue until all participants on stage have distinct aggressiveness levels It is allowed to select an empty set of participants to choose neither of the candidates The host wants to recruit the cast so that the total profit is maximized The profit is calculated as the total revenue from the events on stage less the total expenses to recruit all accepted participants that is their total s i Help the host to make the show as profitable as possible ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=5005;\nint n,m,l[N],s[N],c[N];\nint mx[N],top[N],ans;\nint q[N][N],qq[N],f[N][N];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tFor(i,1,n) scanf(""%d"",&l[i]);\n\tFor(i,1,n) scanf(""%d"",&s[i]);\n\tFor(i,1,n+m) scanf(""%d"",&c[i]);\n\tFor(i,1,n) s[i]=c[l[i]]-s[i];\n\tint ans=0;//-(1<<30);\n\tmemset(f,233,sizeof(f));\n\tFor(i,1,n+m) f[i][0]=0;\n\tRep(i,n,1){\n\t\tint L=l[i];\n\t\tRep(j,mx[L],0){\n\t\t\tint val=f[L][j]+s[i],t=j+1;\n\t\t\t//cout<<L<<\' \'<<j<<\' \'<<t<<\' \'<<val<<endl;\n\t\t\tfor (int p=L;t;){\n\t\t\t\tmx[p]=max(mx[p],t);\n\t\t\t\tf[p][t]=max(f[p][t],val);\n\t\t\t\tp++; t/=2; val+=c[p]*t;\n\t\t\t}\n\t\t\tans=max(ans,val);\n\t\t}\n\t\tFor(j,1,n+m) f[j][0]=max(f[j][0],max(f[j-1][0],f[j-1][1]));\n\t\t/*q[L][++top[L]]=s[i]; ++mx[L];\n\t\tsort(q[L]+1,q[L]+top[L]+1,greater<int>());\n\t\tRep(j,mx[L]-1,0) f[L][j+1]=max(f[L][j+1],f[L][j]+s[i]);\n\t\tFor(j,L+1,n+m){\n\t\t\tint p1=0,p2=0,l1=mx[j-1]/2,l2=top[j];\n\t\t\tFor(k,0,l1) qq[k]=0;\n\t\t\tFor(k,0,mx[L-1]) qq[k/2]=max(qq[k/2],f[j-1][k]);\n\t\t\tFor(k,0,l1) qq[k]+=1ll*c[j]*k;\n\t\t\tint S=qq[0];\n\t\t\tfor (;p1<=l1||p2<=l2;){\n\t\t\t\tf[j][p1+p2]=S;\n\t\t\t\tif (p1==l1&&p2==l2) break;\n\t\t\t\tif (p2==l2||(p1<l1&&qq[p1+1]-qq[p1]>q[j][p2+1]))\n\t\t\t\t\tS+=qq[p1+1]-qq[p1],++p1;\n\t\t\t\telse S+=q[j][++p2];\n\t\t\t}\n\t\t\tmx[j]=l1+l2;\n\t\t\t//cout<<""len ""<<i<<\' \'<<j<<\' \'<<mx[j]<<\' \'<<f[j][0]<<\' \'<<f[j][1]<<endl;\n\t\t}*/\n\t}\n\tprintf(""%d\\n"",ans);\n} ']",,,"['bitmasks', 'dp']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Reality Show.json,https://codeforces.com//blog/entry/74148,First of all we will notice that the order of entering doesn t affect the answer Let s reverse the sequence We will add people in the non decreasing order Let s use dynamic programming is the answer if we processed first candidates with the maximum value less or equal and total number of people who will reach is How we should change values of when we go from to But how changes when we take th element After adding th element we also should change But every next lay will change less It clear that we can remove first parameter of and finally get the asymptotics 
https://codeforces.com//contest/1513/problem/C,954480,C,1513C,1513,C. Add One,You are given an integer n You have to apply m operations to it In a single operation you replace every digit d of the number with the decimal representation of integer d 1 For example 1912 becomes 21023 after applying the operation once You have to find the length of n after applying m operations Since the answer can be very large print it modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\nconst int N = 200010;\nconst int M = 200010;\nconst int mod = 1e9 + 7;\n\nint a[M][10];\nvoid prec() {\n    for (int i = 0; i < 9; ++i) a[1][i] = 1;\n    a[1][9] = 2;\n    for (int i = 2; i < M; ++i) {\n        for (int j = 0; j < 9; ++j) a[i][j] = a[i - 1][j + 1];\n        a[i][9] = (a[i - 1][1] + a[i - 1][0]) % mod;\n    }\n}\n\nvoid solve() {\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    string s = to_string(n);\n    int ans = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        ans = (ans + a[m][s[i] - \'0\']) % mod;\n    }\n    printf(""%d\\n"", ans);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    prec();\n    int t;\n    scanf(""%d"", &t);\n    for (int i = 0; i < t; ++i) solve();\n    return 0;\n}\n']",,,"['dp', 'matrices']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Add One.json,https://codeforces.com//blog/entry/89550,We can solve this problem using 1D dp Let be defined as the length of the string after applying operation times to the number Then in if The final number after applying operations to the number is Otherwise length would be the sum of operations and operations We can precalculate the above table until Now for each test case the final answer is where is in form of string Time Complexity O where 
https://codeforces.com//contest/1934/problem/D2,2505363,D2,1934D2,1934,D2. XOR Break — Game Version,Alice and Bob are playing a game The game starts with a positive integer n with players taking turns On each turn of the game the following sequence of events takes place The player having the integer p breaks it into two integers p 1 and p 2 where 0 lt p 1 lt p 0 lt p 2 lt p and p 1 oplus p 2 p If no such p 1 p 2 exist the player loses Otherwise the opponent does either select the integer p 1 or p 2 The game continues with the selected integer The opponent will try to break it As Alice your goal is to win You can execute a maximum of 63 break operations You have the choice to play first or second The system will act for Bob Here oplus denotes the bitwise XOR operation ,"['#include <bits/stdc++.h>\nusing namespace std;\n//#define endl \'\\n\'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    //IOS;\n\n\n\n    int T; cin >> T;\n    while(T--){\n        int n; cin >> n;\n        \n        if(__builtin_popcountll(n) % 2){\n            cout << ""second"" << endl;\n            while(1){\n                int ret1, ret2; cin >> ret1 >> ret2;\n                if(ret1 <= 0 && ret2 <= 0) break;\n                int cnt1 = __builtin_popcountll(ret1);\n                int cnt2 = __builtin_popcountll(ret2);\n                if(cnt1 % 2) swap(ret1, ret2);\n                int first = 63 - __builtin_clzll(ret1);\n                cout << (1ll << first) << \' \' << ret1 - (1ll << first) << endl;\n            }\n        }   \n        else{\n            cout << ""first"" << endl;\n            int ffirst = 63 - __builtin_clzll(n);\n            cout << (1ll << ffirst) << \' \' << n - (1ll << ffirst) << endl;\n            while(1){\n                int ret1, ret2; cin >> ret1 >> ret2;\n                if(ret1 <= 0 && ret2 <= 0) break;\n                int cnt1 = __builtin_popcountll(ret1);\n                int cnt2 = __builtin_popcountll(ret2);\n                if(cnt1 % 2) swap(ret1, ret2);\n                int first = 63 - __builtin_clzll(ret1);\n                cout << (1ll << first) << \' \' << ret1 - (1ll << first) << endl;\n            }\n        }\n    }\n}']",,,"['bitmasks', 'games', 'greedy', 'interactive']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D2. XOR Break — Game Version.json,https://codeforces.com//blog/entry/126423,Fact 1 If p1 has an odd bit count then it can only be broken into two numbers such that one has an odd bit count and the other has an even bit count Fact 2 If either p1 or p2 has an even bit count then this is a winning state Reason If either p1 or p2 has an even bit count without loss of generality assume it s p1 Then break it into 2msb of p1 and p1 2msb of p1 where msb is the most significant bit If the opponent chooses 2msb of p1 they instantly lose using Hint 1 so they are forced to choose the other number with an odd bit count From Fact 1 we can conclude that in the next turn the state will remain conserved for the current player Because we eliminate the most significant bit in every query this game will go on for at most 60 turns for the player who reached this position first At one point the player who is at this state will have a number with two set bits Hence from Hint 2 we can say this player will win So as Alice you will start first if n has an even number of bits and start second if it has an odd number of bits Proceed using the strategy discussed above So as Alice you have will start first if n has even number of bits and start second if it has odd number of bits Any proceed using the strategy discussed above 
https://codeforces.com//contest/1798/problem/C,1849269,C,1798C,1798,C. Candy Store,The store sells n types of candies with numbers from 1 to n One candy of type i costs b i coins In total there are a i candies of type i in the store You need to pack all available candies in packs each pack should contain only one type of candies Formally for each type of candy i you need to choose the integer d i denoting the number of type i candies in one pack so that a i is divided without remainder by d i Then the cost of one pack of candies of type i will be equal to b i cdot d i Let s denote this cost by c i that is c i b i cdot d i After packaging packs will be placed on the shelf Consider the cost of the packs placed on the shelf in order c 1 c 2 ldots c n Price tags will be used to describe costs of the packs One price tag can describe the cost of all packs from l to r inclusive if c l c l 1 ldots c r Each of the packs from 1 to n must be described by at least one price tag For example if c 1 ldots c n 4 4 2 4 4 to describe all the packs a 3 price tags will be enough the first price tag describes the packs 1 2 the second 3 the third 4 5 You are given the integers a 1 b 1 a 2 b 2 ldots a n b n Your task is to choose integers d i so that a i is divisible by d i for all i and the required number of price tags to describe the values of c 1 c 2 ldots c n is the minimum possible For a better understanding of the statement look at the illustration of the first test case of the first test Let s repeat the meaning of the notation used in the problem a i the number of candies of type i available in the store b i the cost of one candy of type i d i the number of candies of type i in one pack c i the cost of one pack of candies of type i is expressed by the formula c i b i cdot d i ,"['#pragma GCC optimization(""O3"")\n#pragma GCC optimization(""Ofast,unroll-loops"")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline ""\\n""                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<"" ""; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<""{""; _print(p.first);cerr<<"",""; _print(p.second);cerr<<""}"";}\ntemplate<class T>void _print(vector<T> v) {cerr<<"" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(set<T> v) {cerr<<"" [ ""; for (T i:v){_print(i); cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< "" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<"" [ ""; for(auto i:v) {_print(i);cerr<<"" "";} cerr<<""]"";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n; cin>>n;\n    vector<pair<ll,ll>> a(n);\n    for(auto &it:a){\n        cin>>it.f>>it.s;\n    }\n    ll ans=1;\n    ll num=a[0].f*a[0].s,den=a[0].f;\n    for(ll i=1;i<n;i++){\n        auto it=a[i];\n        ll now_num=it.f*it.s,now_den=it.f;\n        ll cur_check=__gcd(num,now_num);\n        ll lft=num/cur_check,rght=now_num/cur_check;\n        ll valid=1;\n        if(den%lft){\n            valid=0;\n        }\n        if(now_den%rght){  \n            valid=0;\n        }\n        if(valid){\n            den/=lft;\n            now_den/=rght;\n            den=__gcd(den,now_den);\n            num=cur_check;\n        }\n        else{\n            ans++;\n            num=now_num;\n            den=now_den;\n        }\n    }\n    cout<<ans<<nline; \n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(""input.txt"", ""r"", stdin);                                              \n    freopen(""output.txt"", ""w"", stdout);  \n    freopen(""error.txt"", ""w"", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}  ']",,,"['greedy', 'math', 'number theory']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Candy Store.json,https://codeforces.com//blog/entry/114208,To begin with let s understand when 1 price tag will be enough Let the total cost of all packs of candies be Two conditions are imposed on The first condition must be divided by each of the numbers because This is equivalent to the fact that is divided by where denotes the least common multiple The second condition is divided by We want to somehow appear in this condition Therefore multiply both parts by and we get that is divisible by That is is divided by This is equivalent to is divided by Thus if one price tag is enough it is necessary that was divided by and was divided by So a necessary and sufficient condition for one price tag will be is divided by It is not difficult to understand that if one price tag is enough for a set of candies then if you remove any type of candy from this set one price tag will still be enough This means that a simple greedy algorithm will work Let s select the largest prefix of candies such that one price tag is enough for it paste a price tag on this prefix and repeat for the remaining candies until the array ends 
https://codeforces.com//contest/1162/problem/B,339905,B,1162B,1162,B. Double Matrix,You are given n times m matrices containing integers A sequence of integers is strictly increasing if each next number is greater than the previous one A row is strictly increasing if all numbers from left to right are strictly increasing A column is strictly increasing if all numbers from top to bottom are strictly increasing A matrix is increasing if all rows are strictly increasing all columns are strictly increasing For example the matrix begin bmatrix 9 10 11 11 12 14 end bmatrix is increasing because each individual row and column is strictly increasing On the other hand the matrix begin bmatrix 1 1 2 3 end bmatrix is not increasing because the first row is not strictly increasing Let a position in the i th row from top and j th column from left in a matrix be denoted as i j In one operation you can choose any two numbers i and j and swap the number located in i j in the first matrix with the number in i j in the second matrix In other words you can swap two numbers in different matrices if they are located in the corresponding positions You would like to make both matrices increasing by performing some number of operations possibly none Determine if it is possible to do this If it is print otherwise print ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, M;\n    scanf(""%d%d"", &N, &M);\n    vector<vector<int> > A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n        A[i].resize(M);\n        for (int j = 0; j < M; ++j) {\n            scanf(""%d"", &A[i][j]);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        B[i].resize(M);\n        for (int j = 0; j < M; ++j) {\n            scanf(""%d"", &B[i][j]);\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (i < N - 1 && (min(A[i][j], B[i][j]) >= min(A[i+1][j], B[i+1][j]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n            if (i < N - 1 && (max(A[i][j], B[i][j]) >= max(A[i+1][j], B[i+1][j]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n            if (j < M - 1 && (min(A[i][j], B[i][j]) >= min(A[i][j+1], B[i][j+1]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n            if (j < M - 1 && (max(A[i][j], B[i][j]) >= max(A[i][j+1], B[i][j+1]))) {\n                printf(""Impossible\\n"");\n                return 0;\n            }\n        }\n    }\n    printf(""Possible\\n"");\n    return 0;\n}\n']",,,"['brute force', 'greedy']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Double Matrix.json,https://codeforces.com//blog/entry/66878,There are too many possibilities to try a brute force and a dp solution also might be too slow e g some bitmask dp There is a solution that uses 2sat but that is a bit hard to code so I won t go into details in this tutorial Let s instead look at a greedy solution First let s swap with if At the end for every and we have We now claim that there is a solution if and only if this configuration is valid We can guess this intuitively and by trying a few examples or we can do the proof below start of formal proof for why this works If this configuration is valid then obviously this solution works so we re done with this side of the implication The other way is to show if there exists a solution then this configuration is also valid We do this by contradiction We show if this configuration is not valid then there is no solution If this configuration is not valid without loss of generality let must go somewhere in the matrix and it needs to be before either or but we have so we have nowhere that we can put thus this shows there is no solution We can also extend this argument to the other cases end of proof for why this works So given the above claim the solution is simple Do the swaps so Then check if the two matrices are increasing and print Possible if so and Impossible otherwise The runtime is to read in the input do the swaps then do the checks that the matrices are valid 
https://codeforces.com//contest/1797/problem/B,1868414,B,1797B,1797,B. Li Hua and Pattern,Li Hua has a pattern of size n times n each cell is either blue or red He can perform operations In each operation he chooses a cell and changes its color from red to blue or from blue to red Each cell can be chosen as many times as he wants Is it possible to make the pattern that matches its rotation by 180 circ Suppose you were Li Hua please solve this problem ,"['// LUOGU_RID: 110066180\n#include<bits/stdc++.h>\n#define int long long\nconst int N=1e5+5,M=1005;\nusing namespace std;\nint n,a[M][M],k,sum;\nvoid solve()\n{\n\tcin>>n>>k;sum=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tcin>>a[i][j];\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(a[i][j]!=a[n-i+1][n-j+1]){sum++;a[n-i+1][n-j+1]=a[i][j];}\n\tif(sum>k||(((k-sum)&1)&&n%2==0))cout<<""No\\n"";\nelse cout<<""Yes\\n"";\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}']",,,"['constructive algorithms', 'greedy']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Li Hua and Pattern.json,https://codeforces.com//blog/entry/114890,We can calculate the minimum needed operations easily by enumerating through the cells and performing an operation if the color of the cell is different from the targeted cell Obviously if the problem has no solution Otherwise there are two cases If the solution exists if and only if as we must perform two operations each time to meet the requirement If the solution always exists as we can perform the remaining operations at the center of the pattern Time complexity 
https://codeforces.com//contest/2043/problem/F,3103851,F,2043F,2043,F. Nim,Recall the rules of the game Nim There are n piles of stones where the i th pile initially contains some number of stones Two players take turns choosing a non empty pile and removing any positive strictly greater than 0 number of stones from it The player unable to make a move loses the game You are given an array a consisting of n integers Artem and Ruslan decided to play Nim on segments of this array Each of the q rounds is defined by a segment l i r i where the elements a l i a l i 1 dots a r i represent the sizes of the piles of stones Before the game starts Ruslan can remove any number of piles from the chosen segment However at least so in a single round he can remove at most r i l i piles He is allowed to remove 0 piles After the removal the game is played on the remaining piles within the segment the changes made in one round do not affect the original array or any other rounds Ruslan wants to remove as many piles as possible so that Artem who always makes the first move loses For each round determine the maximum number of piles Ruslan can remove the number of ways to choose the number of piles for removal Two ways are considered different if there exists an index i such that the pile at index i is removed in one way but not in the other Since the number of ways can be large output it modulo 998 244 353 If Ruslan cannot ensure Artem s loss in a particular round output for that round ,"['#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(""1.in"", ""r"", stdin);  freopen(""1.out"", ""w"", stdout);}using ll = long long;\xa0const int kInf = 1e9;const int kMod = 998244353;void Add(int& x, int y) { ((x += y) >= kMod) && (x -= kMod); }\xa0const int kN = 1e5 + 5, kV = 64;int n, q;array<int, kN> a;array<array<int, kN>, kV> pre;\xa0struct Info {  int mn, c;  Info() { mn = kInf, c = 0; }  Info(int _mn, int _c) { mn = _mn, c = _c; }};array<array<Info, kV>, kV> dp;\xa0Info operator + (Info x, Info y) {  if(x.mn == y.mn) return Add(x.c, y.c), x;  return (x.mn < y.mn) ? x : y;}\xa0void Query(int l, int r) {  int len = r - l + 1;  array<int, kV> cnt;  for(int i = 0; i < kV; i++) {    cnt[i] = pre[i][r] - pre[i][l - 1];  }  if(cnt[0]) return void(cout << len - 1 << "" "" << cnt[0] << ""\\n"");  if(*max_element(ALL(cnt)) >= 2) {    ll sum = 0;    for(int i = 0; i < kV; i++) {      sum += (ll)cnt[i] * (cnt[i] - 1) / 2;    }    return void(cout << len - 2 << "" "" << sum % kMod << ""\\n"");  }  for(auto& k : dp) k.fill(Info());  for(int i = 1; i < kV; i++) {    if(!cnt[i]) { dp[i] = dp[i - 1]; continue; }    dp[i] = dp[i - 1];    dp[i][i] = dp[i][i] + Info(1, 1);    for(int j = 0; j < kV; j++) dp[i - 1][j].mn++;    for(int j = 0; j < kV; j++) {      dp[i][j] = dp[i][j] + dp[i - 1][i ^ j];    }  }  if(dp[kV - 1][0].mn == kInf) return void(cout << ""-1\\n"");  cout << len - dp[kV - 1][0].mn << "" "" << dp[kV - 1][0].c << ""\\n"";}\xa0void Solve() {  cin >> n >> q;  for(int i = 1; i <= n; i++) cin >> a[i];  for(int i = 0; i < kV; i++) {    for(int j = 1; j <= n; j++) {      pre[i][j] = pre[i][j - 1] + (a[j] == i);    }  }  for(int l, r; q--; ) cin >> l >> r, Query(l, r);}\xa0int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T = 1;  // cin >> T;  while(T--) Solve();  return 0;}']",,,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'games', 'greedy', 'implementation', 'shortest paths']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Nim.json,https://codeforces.com//blog/entry/137801,Let s recall the condition for the second player to win in the game of Nim The XOR of the sizes of the piles must be equal to That is we are asked to remove as many piles as possible so that the XOR becomes Notice the following fact Suppose there are piles of size on a segment If we remove an even number of piles the XOR does not change If we remove an odd number it changes by Therefore there is no point in keeping more than piles If we keep piles we can remove another piles and it will not change anything at all We will answer the queries independently Let s find the count of each of the elements in the given segment For example we can precompute how many times each element appears in each prefix Now we can write the following dynamic programming solution represents a pair of maximum amount of removed elements number of ways to remove that amount where we have considered the first of the values the current XOR among the non removed values is and if at least one element is not removed and otherwise Let the amount of the current value be From each state there are at most three transitions remove all elements with that value way keep element ways keep elements ways The base case is the rest are filled with for example The final state is If it s equal to there s no answer Since the XOR cannot exceed the number of states in the dynamic programming solution is From each state there are three transitions which fits within the time constraints 
https://codeforces.com//contest/1340/problem/B,599366,B,1340B,1340,B. Nastya and Scoreboard,The poor boy was very upset because of that He was so sad that he punched some kind of scoreboard with numbers The numbers are displayed in the same way as on an electronic clock each digit position consists of 7 segments which can be turned on or off to display different numbers The picture shows how all 10 decimal digits are displayed After the punch some segments stopped working that is some segments might stop glowing if they glowed earlier But Denis remembered how many sticks were glowing and how many are glowing now Denis broke k segments and he knows which sticks are working now Denis came up with the question what is the maximum possible number that can appear on the board if you turn on exactly k sticks which are off now It is that the number includes leading zeros ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst string DIGS[10] = {""1110111"", ""0010010"", ""1011101"", ""1011011"", ""0111010"", ""1101011"", ""1101111"", ""1010010"", ""1111111"", ""1111011""};\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint N, K; cin >> N >> K;\n\tvector<string> A(N);\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tvector<vector<bool>> poss(N+1, vector<bool>(K+1));\n\tposs[N][K] = true;\n\n\tvector<vector<int>> diffs(N, vector<int>(10));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tint diff = 0;\n\t\t\tbool good = true;\n\t\t\tfor (int v = 0; v < 7; v++) {\n\t\t\t\tif (DIGS[d][v] < A[i][v]) {\n\t\t\t\t\tgood = false;\n\t\t\t\t} else if (DIGS[d][v] > A[i][v]) {\n\t\t\t\t\tdiff++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiffs[i][d] = (good ? diff : -1);\n\t\t}\n\t}\n\n\tfor (int i = N-1; i >= 0; i--) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tint diff = diffs[i][d];\n\t\t\tif (diff == -1) continue;\n\t\t\tfor (int a = 0; a+diff <= K; a++) {\n\t\t\t\tif (poss[i+1][a+diff]) poss[i][a] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!poss[0][0]) {\n\t\tcout << -1 << \'\\n\';\n\t\texit(0);\n\t}\n\n\tstring ans;\n\tint cur = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tassert(poss[i][cur]);\n\t\tfor (int d = 9; true; d--) {\n\t\t\tassert(d >= 0);\n\t\t\tint diff = diffs[i][d];\n\t\t\tif (diff == -1) continue;\n\t\t\tif (cur+diff <= K && poss[i+1][cur+diff]) {\n\t\t\t\tans += char(\'0\'+d);\n\t\t\t\tcur += diff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \'\\n\';\n\n\treturn 0;\n}\n']",,,"['bitmasks', 'dp', 'graphs', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Nastya and Scoreboard.json,https://codeforces.com//blog/entry/76479,Let dp i j true if at the suffix i n you can turn on exactly j sticks and get the correct sequence of digits and false otherwise It is easy to recalculate this dynamics we will make transitions to all possible digits the mask at position i should be a submask of the digit Asymptotic calculate of the dynamics O 10nd Now let s go in order from 1 to n and will try to eagerly set the maximum possible figure using our dynamics It is easy to understand that in this way we get the maximum possible number of n digits 
https://codeforces.com//contest/1430/problem/F,755158,F,1430F,1430,F. Realistic Gameplay,Recently you ve discovered a new shooter They say it has realistic game mechanics Your character has a gun with magazine size equal to k and should exterminate n waves of monsters The i th wave consists of a i monsters and happens from the l i th moment of time up to the r i th moments of time All a i monsters spawn at moment l i and you have to exterminate all of them before the moment r i ends you can kill monsters right at moment r i For every two consecutive waves the second wave starts not earlier than the first wave ends though the second wave can start at the same moment when the first wave ends formally the condition r i le l i 1 holds Take a look at the notes for the examples to understand the process better You are confident in yours and your character s skills so you can assume that aiming and shooting are instant and you need exactly one bullet to kill one monster But reloading takes exactly 1 unit of time One of the realistic mechanics is a mechanic of reloading when you reload you throw away the old magazine with all remaining bullets in it That s why constant reloads may cost you excessive amounts of spent bullets You ve taken a liking to this mechanic so now you are wondering what is the minimum possible number of bullets you need to spend both used and thrown to exterminate all waves Note that you don t throw the remaining bullets away after eradicating all monsters and you start with a full magazine ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=2005;\nint n,k;\nint l[N],r[N],a[N];\nll f[N];\nint main(){\n\tscanf(""%d%d"",&n,&k);\n\tFor(i,1,n) scanf(""%d%d%d"",&l[i],&r[i],&a[i]);\n\tmemset(f,33,sizeof(f));\n\tf[0]=0;\n\tll ans=1ll<<60;\n\tFor(i,1,n){\n\t\tint nT=l[i];\n\t\tll cost=k,Bul=k;\n\t\tFor(j,i,n){\n\t\t\tif (!Bul&&l[j]!=r[j-1])\tBul=k,cost+=k;\n\t\t\t//cout<<i<<\' \'<<j<<\' \'<<Bul<<\' \'<<cost<<endl; \n\t\t\tif (Bul+1ll*(r[j]-l[j])*k<a[j]) break;\n\t\t\tint v=min(Bul,1ll*a[j]),rem=a[j];\n\t\t\tBul-=v; rem-=v;\n\t\t\tint round=(rem+k-1)/k;\n\t\t\tcost+=1ll*round*k;\n\t\t\tBul+=1ll*round*k;\n\t\t\tBul-=rem;\n\t\t\t//cout<<i<<\' \'<<j<<\' \'<<Bul<<\' \'<<cost<<\' \'<<round<<endl;\n\t\t\tif (r[j]!=l[j+1]||round!=r[j]-l[j]){\n\t\t\t\tif (j==n) ans=min(ans,f[i-1]+cost-Bul);\n\t\t\t\tf[j]=min(f[j],f[i-1]+cost);\n\t\t\t}\n\t\t\tif (round!=r[j]-l[j]&&!Bul)\n\t\t\t\tBul+=k,cost+=k;\n\t\t}\n\t}\n\tif (ans>1ll<<58)\n\t\tans=-1;\n\tcout<<ans<<endl;\n}']",,,"['dp', 'greedy']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Realistic Gameplay.json,https://codeforces.com//blog/entry/83614,Note some observations if we meet a new wave and start shooting it s optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave That s why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments Moreover since the next wave starts not earlier than the previous ends we can think that when we start dealing with one wave we ve already dealt with the previous one Also instead of keeping track of the remaining bullets let s just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them So we can write the next dp is the minimum number of bullets we spend dealing with the first waves and now we standing at the moment with full magazine Obviously Now with fixed we can iterate over the index of a wave before which we ll reload throwing away remaining bullets And for waves we need to check that we are able to exterminate all these waves without throwing away any bullets We can check it with several formulas If it s possible for segment then the possibility for the segment is just checking that we can exterminate the th wave having bullets in the start in no more than reloads plus checking that we have at least one unit before for a reload As a result the time complexity of the solution is 
https://codeforces.com//contest/1704/problem/H1,1489131,H1,1704H1,1704,H1. Game of AI  easy version ,Cirno is playing a war simulator game with n towers numbered from 1 to n and n bots numbered from 1 to n The i th tower is initially occupied by the i th bot for 1 le i le n Before the game Cirno first chooses a permutation p p 1 p 2 ldots p n of length n A permutation of length n is an array of length n where each integer between 1 and n appears exactly once After that she can choose a sequence a a 1 a 2 ldots a n 1 le a i le n and a i ne i for all 1 le i le n The game has n rounds of attacks In the i th round if the p i th bot is still in the game it will begin its attack and as the result the a p i th tower becomes occupied by the p i th bot the bot that previously occupied the a p i th tower will no longer occupy it If the p i th bot is not in the game nothing will happen in this round After each round if a bot doesn t occupy any towers it will be eliminated and leave the game Please note that no tower can be occupied by more than one bot but one bot can occupy more than one tower during the game At the end of the game Cirno will record the result as a sequence b b 1 b 2 ldots b n where b i is the number of the bot that occupies the i th tower at the end of the game However as a mathematics master she wants you to solve the following counting problem instead of playing games Count the number of different pairs of sequences a and b that we can get from all possible choices of sequence a and permutation p Since this number may be large output it modulo M ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 18:10:18       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nvector<Mint> fact;\nvector<Mint> inv_fact;\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n >> md;\n  fact = inv_fact = {1};\n  C(2 * n + 1, 0);\n  Mint ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; 2 * j <= i; j++) {\n      Mint dp = fact[i] * C(i - j - 1, j - 1) * inv_fact[j];\n      int ones = n - i;\n      Mint add = dp * C(n, i) * power(Mint(n - 1), j) * power(Mint(n - j - ones), ones);\n      ans += add;\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'dp', 'fft', 'math']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H1. Game of AI  easy version .json,https://codeforces.com//blog/entry/105464,Consider calculate the number of possible sequences for a fixed sequence We can find that if that means is occupied by finally so we have i If that means for all that is occupied before it begins its attack As a result we must have The sequences which satisfies the above conditions is also possible to match a valid The attacking order can be arranged easily Now for how to count we can build a graph according to the information given by We can see that the graph will in the form of some chains Also we can find that for a graph which consists of some chains we can find the unique which satisfies the graph Then some positions of array is also fixed except the top of each chain As for how to decide the these is the top of some chain we need to divide into two situations one is the chain s length is greater than we can see that this can take any number between and except The other one is the chain s length is one so cannot be any bottom of each chain Then we can easily calculate the number of arrays by product the possible number of values of each In conclusion we can enumerate the number of chains and the number of chains with length then use combination number to calculate Time complexity is 
https://codeforces.com//contest/1702/problem/G1,1456432,G1,1702G1,1702,G1. Passable Paths  easy version ,Polycarp grew a tree from n vertices We remind you that a tree of n vertices is an undirected connected graph of n vertices and n 1 edges that does not contain cycles He calls a set of vertices if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice The path can visit other vertices not from this set In other words a set of vertices is called if there is a simple path that passes through all the vertices of this set and possibly some other For example for a tree below sets 3 2 5 1 5 4 1 4 are and 1 3 5 1 2 3 4 5 are not Polycarp asks you to answer q queries Each query is a set of vertices For each query you need to determine whether the corresponding set of vertices is ,"['/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll int\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,m,g[21][N],h[N];\nvector<ll> ke[N],have[2];\nvoid dfs (ll u, ll p){\n    rv(v,ke[u]) if (v!=p){\n        h[v]=h[u]+1;\n        g[0][v]=u;\n        for (ll i=1;(1<<i)<=h[v];i++) g[i][v]=g[i-1][g[i-1][v]]; \n        dfs(v,u);\n    }\n}\nll lca (ll u, ll v){\n    if (u==v) return u;\n    if (h[u]<h[v]) swap(u,v);\n    reb(i,20,0) if ((h[u]-(1<<i)>=h[v])) u=g[i][u];\n    if (u==v) return u;\n    reb(i,20,0) if (g[i][u]!=g[i][v]) u=g[i][u],v=g[i][v];\n    return g[0][u]; \n}\nll park (ll u, ll k){\n    ll v=u;\n    reb(i,20,0) if (k&(1<<i)) v=g[i][v];\n    return v;\n}\nbool cmp (ll u, ll v){\n    return (h[u]>h[v]);\n}\nvector<ll> a;\nset<ll> st;\nvoid solo()\n{\n    cin>>n;\n    rep(i,1,n-1){\n        ll u,v;\n        cin>>u>>v;\n        ke[u].pb(v);\n        ke[v].pb(u);\n    }\n    dfs(1,0);\n    cin>>q;\n    while (q--){\n        cin>>m;\n        a.clear();\n        rep(i,1,m){\n            ll x;\n            cin>>x;\n            a.pb(x);\n        }\n        if (m==1){\n            cout<<""YES\\n""; continue;\n        }\n        ll all=a[0];\n        rv(i,a) all=lca(all,i);\n        st.clear();\n        rv(i,a) if (all!=i) st.insert(park(i,h[i]-h[all]-1));\n        if (st.size()>2){\n            cout<<""NO\\n""; continue;\n        }\n        ll S=*st.begin(),T=*st.rbegin();\n        sort(a.begin(),a.end(),cmp);\n        have[0].clear();\n        have[1].clear();\n        rv(i,a) if (i!=all){\n            if (lca(i,S)==S) have[0].pb(i);\n            else have[1].pb(i);\n        }\n        bool ok=1;\n        rep(i,0,1) if (!have[i].empty()){\n            ll c=have[i][0];\n            rv(u,have[i]) if (lca(u,c)!=u) ok=0;\n        }\n        if (ok) cout<<""YES\\n"";\n        else cout<<""NO\\n"";\n    }\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   //cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']",,,"['dfs and similar', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G1. Passable Paths  easy version .json,https://codeforces.com//blog/entry/104763,If the answer is then we can choose a subset of the tree vertices forming a simple path and containing all the vertices of our set Let s choose the minimum possible path its ends vertices from the set The constraints allow us to answer the query in hang the tree by one of the ends and check if it is true that there is only one selected vertex that does not have any selected ones in the subtree if there is one such vertex then it is the second end To make it easier to search for one of the ends we will hang the tree by any vertex before the queries calculate their depths and take the deepest of the set 
https://codeforces.com//contest/1165/problem/F1,344229,F1,1165F1,1165,F1. Microtransactions  easy version , Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are n types of microtransactions in the game Each microtransaction costs 2 burles usually and 1 burle if it is on sale Ivan has to order exactly k i microtransactions of the i th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for 1 burle and otherwise he can buy it for 2 burles There are also m special offers in the game shop The j th offer d j t j means that microtransactions of the t j th type are on sale during the d j th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst LL N=4e5+7,mod=998244353,INF=1e9;\nint n,m;\nint a[N],b[N];\nvector<int>v[N];\nint check(int x,int y){\n    int re=x,cnt=0;\n    int flag=0;\n    for(int i=1;i<=n;i++)b[i]=a[i];\n    for(int i=x;i>=1;i--){\n            //cout<<i<<\' \'<<re<<endl;\n        for(int j=0;j<v[i].size();j++){\n            while(b[v[i][j]]&&re){\n                re--;\n                y--;\n                b[v[i][j]]--;\n            }\n        }\n        if(re>=i)re--,flag++;\n    }\n    return flag/2>=y;\n}\nint main()\n{\n    cin>>n>>m;\n    int cnt=0;\n    for(int i=1;i<=n;i++){\n        scanf(""%d"",&a[i]);\n        cnt+=a[i];\n    }\n    int x,y;\n    for(int i=1;i<=m;i++){\n        scanf(""%d%d"",&x,&y);\n        v[x].PB(y);\n    }\n    int ans=INF;\n    int l=cnt,r=2*cnt;\n    while(l<=r){\n        int mid=l+r>>1;\n        if(check(mid,cnt)){\n            ans=min(ans,mid);\n            r=mid-1;\n        }\n        else l=mid+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n']",,,"['binary search', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F1. Microtransactions  easy version .json,https://codeforces.com//blog/entry/67041,Let s iterate over all possible answers Obviously this value is always in the range The first day when Ivan can order all microtransactions he wants will be the answer How to check if the current day is enough to order everything Ivan wants If we had several sale days for some type of microtransaction of course we can use only such days that are not greater than the fixed last day let s use the last one it is always not worse than some of the previous days Then let s iterate over all days from to and do the following firstly let s increase our balance by one burle Then let s try to order all microtransactions for which the current day is the last sale day and pay one burle per copy If we are out of money at some moment then just say that we should order all microtransactions that remain in this sale day during the last day for two burles per copy It is true because it does not matter which types will remain because this day is the last sale day for all of these types So after all we had some remaining microtransactions that we cannot buy during sales and the current balance And the current day is good if the number of such microtransactions multiplied by two is not greater than the remaining balance 
https://codeforces.com//contest/1105/problem/E,284898,E,1105E,1105,E. Helping Hiasat ,Hiasat registered a new account in NeckoForces and when his friends found out about that each one of them asked to use his name as Hiasat s handle Luckily for Hiasat he can change his handle in some points in time Also he knows the exact moments friends will visit his profile page Formally you are given a sequence of events of two types 1 Hiasat can change his handle 2 s friend s visits Hiasat s profile The friend s will be happy if each time he visits Hiasat s profile his handle would be s Hiasat asks you to help him find the maximum possible number of happy friends he can get ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch=\'*\'; (ch<\'0\'||ch>\'9\')&&ch!=\'-\'; ch=getchar());\n    if(ch==\'-\') fu=1, ch=getchar();\n    for(v=0; ch>=\'0\'&&ch<=\'9\'; ch=getchar()) v=v*10+ch-\'0\';\n    if(fu) v=-v;\n}\nbitset<100010> a[44];\nint now,n,t,ans,m,ren,c[55][55],p[500010],tp[500010];\nstring s;\nmap<string,int> M;\nbool u[500010];\nint main(){\n//\tfreopen(""t.in"",""r"",stdin);\n//\tfreopen(""t.out"",""w"",stdout);\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tnow=0;\n\tFOR(i,1,n){\n\t\tcin>>tp[i];\n\t\tif (tp[i]==1){\n\t\t\tif (tp[i-1]==1) continue;\n\t\t\t++now;\n\t\t}\n\t\telse{\n\t\t\tcin>>s;\n\t\t\tif (M.find(s)==M.end()) M[s]=++ren;\n\t\t\tt=M[s];\n\t\t\ta[t][now]=1;\n\t\t}\n\t}\n\tFOR(i,1,ren) c[i][i]=1;\n\tFOR(i,1,ren)\n\t\tFOR(j,i+1,ren)\n\t\t\tif (((int)(a[i]&a[j]).count())!=0){\n\t\t\t\tc[i][j]=c[j][i]=0;\n\t\t\t}\n\t\t\telse c[i][j]=c[j][i]=1;\n\tint rp=10000;\n\twhile (rp--){\n\t\tFOR(i,1,ren) p[i]=i;\n\t\trandom_shuffle(p+1,p+ren+1);\n\t\tint s=0;\n\t\tFOR(i,1,ren) u[i]=0;\n\t\tFOR(i,1,ren){\n\t\t\tbool gg=0;\n\t\t\tint x=p[i];\n\t\t\tFOR(j,1,ren)\n\t\t\t\tif (u[j] && !c[j][x]) gg=1;\n\t\t\tif (!gg){\n\t\t\t\t++s;\n\t\t\t\tu[x]=1;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,s);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n\t\n}\n']",,,"['bitmasks', 'brute force', 'dp', 'meet-in-the-middle']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Helping Hiasat .json,https://codeforces.com//blog/entry/64664,Let s change this problem to a graph problem first Let s say that each action of the first type is a border Consider all friends visiting our profile after this border but before the next one Clearly we can satisfy at most one of them Let s change the friends into graph nodes and add edges between every two friends that are between the same borders Then it s enough to solve the maximum independent set of the graph clearly any possible answer must be an independent set and by any independent set we can always build a way to change our handle The maximum independent set can be solved in where is the number of friends But since is up to it is too slow However we can apply the meet in the middle approach and then it becomes or The simplest way is to do the following notice that the independent set is same as clique if all edges are inverted so we will solve a max clique problem Let s write a bruteforce which returns size of the largest clique which forms a subset of mask The answer will be just to run solve of full mask How to write solve Let s find a of mask let it be vertex There are two cases The vertex is not in an answer Kick it and run a recursive call The vertex is in answer Hence all other vertices of answers are neighbors of Run the recursive call from where denotes the mask of neighbors Clearly it works in However if we add memorization don t calculate for same mask twice it is magically becomes Why Consider the recursion there are at most recursion calls before we arrive into the state where there are no set bits of the first half This part will take at most then And clearly there are at most states with no set bits in the first half 
https://codeforces.com//contest/681/problem/B,62558,B,681B,681,B. Economy Game,Kolya is developing an economy simulator game His most favourite part of the development process is in game testing Once he was entertained by the testing so much that he found out his game coin score become equal to Kolya remembers that at the beginning of the game his game coin score was equal to and that he have bought only some houses for game coins each cars for game coins each and computers for game coins each Kolya is now interested whether he could have spent all of his initial game coins buying only houses cars and computers or there is a bug in the game Formally is there a triple of non negative integers and such that Please help Kolya answer this question ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\n\nll a = 1234567;\nll b = 123456;\nll c = 1234;\n\nint main() {\n\tcin >> n;\n\tfor (ll i = 0; i * a <= n; ++i) {\n\t\tfor (ll j = 0; i * a + j * b <= n; ++j) {\n\t\t\tif ((n - i * a - j * b) % 1234 == 0) {\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ""NO\\n"";\n\treturn 0;\n}\n']",,,['brute force'],1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Economy Game.json,https://codeforces.com//blog/entry/45425,We can simply try every from to and from and if is non negative and divided by then the answer is YES If there is no such and then the answer is NO Code 
https://codeforces.com//contest/807/problem/B,105602,B,807B,807,B. T-Shirt Hunt,Not so long ago the Codecraft 17 contest was held on Codeforces The top 25 participants and additionally random 25 participants out of those who got into top 500 will receive a Codeforces T shirt Unfortunately you didn t manage to get into top 25 but you got into top 500 taking place Now the elimination round of 8VC Venture Cup 2017 is being held It has been announced that the Codecraft 17 T shirt winners will be chosen as follows Let be the number of points of the winner of the elimination round of 8VC Venture Cup 2017 Then the following pseudocode will be executed i s div 50 mod 475repeat 25 times i i 96 42 mod 475 print 26 i Here is the integer division operator is the modulo the remainder of division operator As the result of pseudocode execution 25 integers between 26 and 500 inclusive will be printed These will be the numbers of places of the participants who get the Codecraft 17 T shirts It is guaranteed that the 25 printed integers will be pairwise distinct for any value of You re in the lead of the elimination round of 8VC Venture Cup 2017 having points You believe that having at least points in the current round will be enough for victory To change your final score you can make any number of successful and unsuccessful hacks A successful hack brings you 100 points an unsuccessful one takes 50 points from you It s difficult to do successful hacks though You want to win the current round and at the same time ensure getting a Codecraft 17 T shirt What is the smallest number of hacks you have to do to achieve that ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool tshirt(int p, int score) {\n    int r = (score/50)%475;\n    for(int i=0;i<25;i++) {\n        r = (r*96+42)%475;\n        if(r+26 == p) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int p, x, y;\n    cin >> p >> x >> y;\n    int score = x;\n    while(score-50 >= y) {\n        score -= 50;\n    }\n    while(!tshirt(p,score)) {\n        score += 50;\n    }\n    score -= x;\n    score += 50;\n    if(score < 0) {\n        score = 0;\n    }\n    cout << score/100 << endl;\n}']",,,"['brute force', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. T-Shirt Hunt.json,https://codeforces.com/blog/entry/51883,This problem was inspired by this comment http codeforces com blog entry 49663comment 337281 The hacks don t necessarily have to be stupid though Initially we have points To win the current round we need to score any number of points such that If we know our final score we can check if we get the T shirt using the given pseudocode Moreover since hacks change our score only by multiples of 50 the difference has to be divisible by 50 Naturally out of all satisfying the conditions above we need to aim at the smallest possible since it s easy to decrease our score but difficult to increase How many successful hacks do we need to make our score equal to If we need 0 successful hacks since we can just make unsuccessful hacks If and is divisible by 100 we need exactly successful hacks If and is not divisible by 100 we need successful hacks and one unsuccessful hack All these cases can be described by a single formula for the number of successful hacks here denotes integer division The constraints were low enough and the number of required hacks was also low enough A less effective but easier solution can be achieved if we just iterate over both the number of successful and unsuccessful hacks we make Once we know these two numbers we know our final score and we can explicitly check if this score gives us both the victory and the T shirt 
https://codeforces.com//contest/1572/problem/A,1113063,A,1572A,1572,A. Book,You are given a book with n chapters Each chapter has a specified list of other chapters that need to be understood in order to understand this chapter To understand a chapter you must read it after you understand every chapter on its required list Currently you don t understand any of the chapters You are going to read the book from the beginning till the end repeatedly until you understand the whole book Note that if you read a chapter at a moment when you don t understand some of the required chapters you don t understand this chapter Determine how many times you will read the book to understand every chapter or determine that you will never understand every chapter no matter how many times you read the book ,"[""/**\n *    author:  tourist\n *    created: 18.09.2021 17:31:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    vector<int> deg(n);\n    for (int i = 0; i < n; i++) {\n      int x;\n      cin >> x;\n      while (x--) {\n        int j;\n        cin >> j;\n        --j;\n        g[j].push_back(i);\n        deg[i] += 1;\n      }\n    }\n    set<int> s;\n    for (int i = 0; i < n; i++) {\n      if (deg[i] == 0) {\n        s.insert(i);\n      }\n    }\n    int last = -1;\n    int ans = 1;\n    for (int iter = 0; iter < n; iter++) {\n      if (s.empty()) {\n        ans = -1;\n        break;\n      }\n      auto it = s.lower_bound(last);\n      if (it == s.end()) {\n        ans += 1;\n        it = s.begin();\n      }\n      int i = *it;\n      s.erase(it);\n      for (int j : g[i]) {\n        --deg[j];\n        if (deg[j] == 0) {\n          s.insert(j);\n        }\n      }\n      last = i;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]",,,"['binary search', 'brute force', 'data structures', 'dp', 'graphs', 'implementation', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Book.json,https://codeforces.com//blog/entry/95086,There are two main solutions in this task The first solution simulates the process of reading the book Let be the number of chapters that need to be understood in order to understand th chapter We will keep this array updated during the simulation Now we will simulate the process by keeping a set of chapters that are ready to be understood Suppose we have just understood chapter We will update array by iterating over all chapters that require to be understood If some chapter becomes ready to be understood we will insert it to the set Then we will lowerbound on our set to the next chapter that can be understood and when we hit the end the answer increases by one and we come back to the beginning The entire process runs in The second solution is more graph based We will construct a graph where there is a directed edge from to if chapter is needed to understand chapter This edge has weight if and otherwise The answer is the length of the longest weighted path in this graph incremented by If there exists a cycle we should output If the graph is a DAG we can use toposort and a simple DP to calculate the answer This solution works in 
https://codeforces.com//contest/1104/problem/A,286140,A,1104A,1104,A. Splitting into digits,Vasya has his favourite number n He wants to split it to some non zero digits It means that he wants to choose some digits d 1 d 2 ldots d k such that 1 leq d i leq 9 for all i and d 1 d 2 ldots d k n Vasya likes beauty in everything so he wants to find any solution with the minimal possible number of different digits among d 1 d 2 ldots d k Help him ,"['#include <cstdio>\n#include <cstdlib>\nusing namespace std;\nint main() {\n    int n;\n    scanf(""%d"", &n);\n    printf(""%d\\n"", n);\n    for (int i = 1; i <= n; ++i)\n        printf(""1 "");\n    return 0;\n}']",,,"['constructive algorithms', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Splitting into digits.json,https://codeforces.com//blog/entry/64722,It was a joke Let s split number to digits equal to Their sum is and the number of different digits is So it can be found as the answer 
https://codeforces.com//contest/917/problem/E,151491,E,917E,917,E. Upside Down,As we all know Eleven has special abilities Thus Hopper convinced her to close the gate to the Upside Down World with her mind Upside down monsters like to move between the worlds so they are going to attack Hopper and Eleven in order to make them stop The monsters live in the vines The vines form a tree with vertices numbered from through There s a lowercase English letter written in each tunnel edge Upside down is a magical world There are types of monsters in upside down numbered from through Each type of monster has a special word that gives them powers The special word of type is There are monsters in upside down Each one is at a junction vertex and is going to some other junction If monster of type goes from junction to junction the power it gains is the number of times it sees its special world consecutively in the tunnels More formally If is the string we get when we concatenate the letters written in the tunnels on the shortest path from to then the power the monster gains is the number of occurrences of in Hopper and Eleven want to get prepared so for each monster they want to know the power the monster gains after moving ,"['//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=200111;\nconst int maxTRIEn=1800111;\nnamespace KMP\n{\n\tll rdown(ll p,ll q){return q<0?rdown(-p,-q):(p>0?p/q:-(-p+q-1)/q);}\n\tll rup(ll p,ll q){return -rdown(-p,q);}\n\tstruct sub\n\t{\n\t\tint s,d,cnt;//d>0\n\t\tsub(int S=0,int D=0,int CNT=0){s=S;d=D;cnt=CNT;}\n\t\tint end()const{return s+(cnt-1)*d;}\n\t\tbool has(int x)const{return x>=s&&x<=end()&&(x-s)%d==0;}\n\t\tint calc(const sub &t)\n\t\t{\n\t\t\tif(d==t.d)\n\t\t\t{\n\t\t\t\tif((s-t.s)%d!=0)return 0;\n\t\t\t\telse return max(0,(min(end(),t.end())-max(s,t.s))/d+1);\n\t\t\t}\n\t\t\telse if(cnt==1)return t.has(s);\n\t\t\telse return has(t.s);\n\t\t}\n\t\tsub flip(int x){return sub(x-(s+(cnt-1)*d),d,cnt);}\n\t};\n\tvector<int> Fail[maxn],Slink[maxn];\n\tvoid construct(char s[],int n,int id)\n\t{\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\n\t\tfail.resize(n+1);\n\t\tslink.resize(n+1);\n\t\tfail[0]=0;fail[1]=0;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tint &p=fail[i];\n\t\t\tp=fail[i-1];\n\t\t\twhile(p&&s[p+1]!=s[i])p=fail[p];\n\t\t\tif(s[p+1]==s[i])p++;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)slink[i]=fail[i]==0?0:(i-fail[i]==fail[i]-fail[fail[i]]?slink[fail[i]]:fail[i]);\n\t}\n\tvector<sub> extract(int id,int x)\n\t{\n\t\tvector<int> &fail=Fail[id],&slink=Slink[id];\n\t\tassert(x<fail.size()&&x<slink.size());\n\t\tvector<sub> ret;\n\t\twhile(x)\n\t\t{\n\t\t\tint d=x-fail[x];\n\t\t\tret.PB(sub(slink[x]+d,d,(x-slink[x])/d));\n\t\t\tx=slink[x];\n\t\t}\n\t\treverse(ret.begin(),ret.end());\n\t\tif(ret.back().cnt>1)ret.back().cnt--,ret.PB(sub(ret.back().end()+ret.back().d,1,1));\n\t\treturn ret;\n\t}\n\tint query(int x,int xl,int y,int yl,int tot)\n\t{\n\t\tif(xl==0||yl==0||xl+yl<tot)return 0;\n\t\tvector<sub> vx=extract(x,xl);\n\t\tvector<sub> vy=extract(y,yl);\n\t\tfor(int i=0;i<vy.size();i++)vy[i]=vy[i].flip(tot);\n\t\treverse(vy.begin(),vy.end());\n\t\tint itx=0,ity=0,ret=0;\n\t\twhile(itx<vx.size()&&ity<vy.size())\n\t\t{\n\t\t\tret+=vx[itx].calc(vy[ity]);\n\t\t\tif(vx[itx].end()<=vy[ity].end())itx++;\n\t\t\telse ity++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst ll hs_B=233;\nconst ll hs_mod=100000000000031ll;\nint bit_tab[maxTRIEn];\nvoid bit_add(int x,int coef)\n{\n\tfor(int i=x;i<maxTRIEn;i+=i&(-i))bit_tab[i]+=coef;\n}\nint bit_query(int x)\n{\n\tint ret=0;\n\tfor(int i=x;i;i-=i&(-i))ret+=bit_tab[i];\n\treturn ret;\n}\nconst int HashMsk=(1<<22)-1;\nstruct HashTable\n{\n\tint hs[HashMsk],val[HashMsk];\n\tHashTable(){memset(hs,-1,sizeof(hs));memset(val,-1,sizeof(val));}\n\tint getpos(int p){return ((p<<5)^(p>>3))&HashMsk;}\n\tint find(int chs)\n\t{\n\t\tint p=getpos(chs);\n\t\twhile(hs[p]!=-1&&hs[p]!=chs)p=(p+1)&HashMsk;\n\t\treturn val[p];\n\t}\n\tint& get(int chs)\n\t{\n\t\tint p=getpos(chs);\n\t\twhile(hs[p]!=-1&&hs[p]!=chs)p=(p+1)&HashMsk;\n\t\tif(hs[p]==-1)hs[p]=chs,val[p]=-1;\n\t\treturn val[p];\n\t}\n};\nnamespace AC\n{\n\t//TRIE\n\tint tot=1;\n\tvector<pair<char,int> > go[maxTRIEn];\n\tHashTable gomp;\n\tll hs[maxTRIEn];\n\tint fa[maxTRIEn],pc[maxTRIEn];\n\tpair<ll,int> hs_arr[maxTRIEn];\n\t\n\tint insert(int p,int c)\n\t{\n\t\tint &q=gomp.get(p<<8|c);\n\t\tif(q==-1)\n\t\t{\n\t\t\tq=++tot,fa[q]=p,pc[q]=c,hs[q]=(hs[p]*hs_B+c+1)%hs_mod;\n\t\t\tgo[p].PB(MP(c,q));\n\t\t\tassert(tot<maxTRIEn);\n\t\t}\n\t\treturn q;\n\t}\n\tint fail[maxTRIEn];\n\tvector<int> con[maxTRIEn];//store fail tree\n\tint fdfn[maxTRIEn],fdfnr[maxTRIEn],dfntot;\n\tvoid fdfs(int x)\n\t{\n\t\tfdfn[x]=++dfntot;\n\t\tfor(int i=0;i<con[x].size();i++)\n\t\t{\n\t\t\tint u=con[x][i];\n\t\t\tfdfs(u);\n\t\t}\n\t\tfdfnr[x]=dfntot;\n\t}\n\t\n\t//HLD\n\tint son[maxTRIEn],top[maxTRIEn],lv[maxTRIEn];\n\tset<int> st[maxTRIEn];\n\tint dfs(int x)\n\t{\n\t\tint sz=1,mx=0;\n\t\tson[x]=0;\n\t\tfor(int t=0;t<go[x].size();t++)\n\t\t{\n\t\t\tint u=go[x][t].SS;\n\t\t\tlv[u]=lv[x]+1;\n\t\t\tint szu=dfs(u);\n\t\t\tsz+=szu;\n\t\t\tif(szu>mx)son[x]=u,mx=szu;\n\t\t}\n\t\treturn sz;\n\t}\n\tvoid dfs2(int x,int tp)\n\t{\n\t\ttop[x]=tp;\n\t\tif(son[x])dfs2(son[x],tp);\n\t\tfor(int t=0;t<go[x].size();t++)\n\t\t{\n\t\t\tint u=go[x][t].SS;\n\t\t\tif(u==son[x])continue;\n\t\t\tdfs2(u,u);\n\t\t}\n\t}\n\tvoid construct_HLD()\n\t{\n\t\tlv[1]=0;\n\t\tdfs(1);\n\t\tdfs2(1,1);\n\t}\n\tvoid HLDflip(int x)\n\t{\n\t\tint g=top[x];\n\t\tif(st[g].find(lv[x])==st[g].end())st[g].insert(lv[x]);\n\t\telse st[g].erase(lv[x]);\n\t}\n\tint HLDquery(int x)\n\t{\n\t\twhile(x)\n\t\t{\n\t\t\tif(st[top[x]].size()>0&&*st[top[x]].begin()<=lv[x])return *(--st[top[x]].lower_bound(lv[x]+1));\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint q[maxTRIEn],qn;\n\tvoid construct()\n\t{\n\t\tconstruct_HLD();\n\t\tfor(int i=1;i<=tot;i++)hs_arr[i]=MP(hs[i],i);\n\t\tsort(hs_arr+1,hs_arr+tot+1);\n\t\tqn=0;q[qn++]=1;\n\t\tfor(int i=0;i<qn;i++)\n\t\t{\n\t\t\tint x=q[i];\n\t\t\tfor(int j=0;j<go[x].size();j++)\n\t\t\t{\n\t\t\t\tq[qn++]=go[x][j].SS;\n\t\t\t}\n\t\t}\n\t\tfail[1]=1;\n\t\tfor(int i=1;i<qn;i++)\n\t\t{\n\t\t\tint x=q[i];\n\t\t\tint &p=fail[x];\n\t\t\tif(fa[x]==1)p=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp=fail[fa[x]];\n\t\t\t\twhile(p!=1&&gomp.find(p<<8|pc[x])==-1)p=fail[p];\n\t\t\t\tif(gomp.find(p<<8|pc[x])!=-1)p=gomp.find(p<<8|pc[x]);\n\t\t\t}\n\t\t\tcon[fail[x]].PB(x);\n\t\t}\n\t\tfdfs(1);\n\t}\n\tint qans[maxTRIEn],qans2[maxTRIEn];\n\tvector<pair<int,int> > qr[maxTRIEn],qr2[maxTRIEn];\n\tvoid dfs_solve_p1(int x)\n\t{\n\t\tbit_add(fdfn[x],1);\n\t\tfor(int i=0;i<qr[x].size();i++)\n\t\t{\n\t\t\tint pos=qr[x][i].FF;\n\t\t\tqans[qr[x][i].SS]+=bit_query(fdfnr[pos])-bit_query(fdfn[pos]-1);\n\t\t}\n\t\tfor(int i=0;i<go[x].size();i++)dfs_solve_p1(go[x][i].SS);\n\t\tbit_add(fdfn[x],-1);\n\t}\n\tvoid dfs_solve_p2(int x,ll hs=0,ll hs_bs=1)\n\t{\n\t\tint p=lower_bound(hs_arr+1,hs_arr+tot+1,MP(hs,0))-hs_arr;\n\t\tif(hs_arr[p].FF==hs)HLDflip(hs_arr[p].SS);\n\t\tfor(int i=0;i<qr2[x].size();i++)\n\t\t{\n\t\t\tqans2[qr2[x][i].SS]=HLDquery(qr2[x][i].FF);\n\t\t}\n\t\tfor(int i=0;i<go[x].size();i++)dfs_solve_p2(go[x][i].SS,(hs+hs_bs*(go[x][i].FF+1))%hs_mod,hs_bs*hs_B%hs_mod);\n\t\tif(hs_arr[p].FF==hs)HLDflip(hs_arr[p].SS);\n\t}\n\tvoid add_query(int ui,int vi,int si,int ti,int id)\n\t{\n\t\tqr[ui].PB(MP(ti,id));\n\t\tqr[vi].PB(MP(si,id));\n\t\tqr2[si].PB(MP(ui,id*2));\n\t\tqr2[ti].PB(MP(vi,id*2+1));\n\t}\n\tpair<int,pair<int,int> > get_query(int id)\n\t{\n\t\treturn MP(qans[id],MP(qans2[id*2],qans2[id*2+1]));\n\t}\n\tvoid solve()\n\t{\n\t\tmemset(qans,0,sizeof(qans));\n\t\tdfs_solve_p1(1);\n\t\tdfs_solve_p2(1);\n\t}\n};\nint n,m,q;\nvector<pair<int,char> > con[maxn];\nvector<pair<int,int> > qr[maxn];\nint qu[maxn],qv[maxn],qx[maxn],uid[maxn],vid[maxn];\nvector<int> sid[maxn];\nint cur_rt,cur_lv;\nint dlv[maxn],sz[maxn],arr[maxn],an,gr[maxn],id[maxn];\nvoid pdfs(int x,int pre=-1)\n{\n\tsz[x]=1;arr[an++]=x;dlv[x]=cur_lv+1;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i].FF;\n\t\tif(u==pre||dlv[u]<cur_lv)continue;\n\t\tpdfs(u,x);\n\t\tsz[x]+=sz[u];\n\t}\n}\nint findrt(int x)\n{\n\tan=0;\n\tpdfs(x);\n\tint ret=x;\n\tfor(int i=0;i<an;i++)if(sz[arr[i]]*2>=sz[x]&&sz[arr[i]]<sz[ret])ret=arr[i];\n\treturn ret;\n}\nvoid dfs(int x,int pre,int g)\n{\n\tgr[x]=g;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i].FF;\n\t\tif(u==pre||dlv[u]<cur_lv)continue;\n\t\tid[u]=AC::insert(id[x],con[x][i].SS-\'a\');\n\t\tdfs(u,x,pre==-1?u:g);\n\t}\n}\nvoid solve(int X,int lv)\n{\n\tcur_lv=lv;\n\tint rt=findrt(X);\n\tcur_rt=rt;\n\tdlv[rt]=lv;\n\tid[rt]=1;\n\tdfs(rt,-1,rt);\n\tstatic bool vis[maxn];\n\tfor(int i=0;i<an;i++)vis[arr[i]]=1;\n\tfor(int i=0;i<an;i++)\n\t{\n\t\tint x=arr[i];\n\t\tfor(int j=0;j<qr[x].size();j++)\n\t\t{\n\t\t\tint y=qr[x][j].FF;\n\t\t\tif(vis[y]&&gr[y]!=gr[x])\n\t\t\t{\n\t\t\t\tuid[qr[x][j].SS]=id[x];\n\t\t\t\tvid[qr[x][j].SS]=id[y];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<an;i++)vis[arr[i]]=0;\n\tfor(int i=0;i<con[rt].size();i++)\n\t{\n\t\tint u=con[rt][i].FF;\n\t\tif(dlv[u]<lv)continue;\n\t\tsolve(u,lv+1);\n\t}\n}\nchar s[maxn];\nint main()\n{\n\tscanf(""%d%d%d"",&n,&m,&q);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tchar c;\n\t\tscanf(""%d %d %c"",&x,&y,&c);\n\t\tcon[x].PB(MP(y,c));\n\t\tcon[y].PB(MP(x,c));\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(""%s"",s+1);\n\t\tint l=strlen(s+1);\n\t\tint p;\n\t\tp=1;sid[i].PB(1);\n\t\tfor(int j=1;j<=l;j++)p=AC::insert(p,s[j]-\'a\'),sid[i].PB(p);\n\t\tKMP::construct(s,l,i);\n\t\treverse(s+1,s+l+1);\n\t\tp=1;sid[i+m].PB(1);\n\t\tfor(int j=1;j<=l;j++)p=AC::insert(p,s[j]-\'a\'),sid[i+m].PB(p);\n\t\tKMP::construct(s,l,i+m);\n\t\treverse(s+1,s+l+1);\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint u,v,x;\n\t\tscanf(""%d%d%d"",&u,&v,&x);\n\t\tqr[u].PB(MP(v,i));\n\t\tqu[i]=u;qv[i]=v;qx[i]=x;\n\t}\n\tsolve(1,0);\n\tAC::construct();\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tAC::add_query(uid[i],vid[i],sid[qx[i]].back(),sid[qx[i]+m].back(),i);\n\t}\n\tAC::solve();\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tpair<int,pair<int,int> > pp=AC::get_query(i);\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tpair<int,pair<int,int> > pp=AC::get_query(i);\n\t\tint ans=pp.FF;\n\t\tans+=KMP::query(qx[i],pp.SS.FF,qx[i]+m,pp.SS.SS,sid[qx[i]].size()-1);\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}\n']",,,"['data structures', 'string suffix structures', 'strings', 'trees']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Upside Down.json,https://codeforces.com//blog/entry/57420,Assume is reverse of Use centroid decomposition When solving the problem for subtree assume its centroid is For a fixed query assume and are both in and path from to goes through the centroid this happens exactly one time for each and Assume is string of path from to and is string of path from to We should find the number of occurrences of in If number of occurrences of in is then First two variables can be calculated using aho corasick and segment tree is the number of occurrences of in the path such that some part of it belongs to and some to So so far the the time complexity is Now for counting first calculate the suffix tree for each string for each and A suffix tree is a trie so let be the vertex we reach when we ask the string of path from root to one by in the suffix tree of string We can calculate this fast for every and if we merge this suffix trees into one trie we do this before we start the centroid decomposition algorithm in per process We associate a value to each vertex of the trie initially zero for every vertex Now we traverse this trie like DFS When we reach a vertex we iterate over all suffixes there are suffixes that end in the suffixes that equal the string of path from root of the trie to vertex and for each suffix suffix of string with length we add to the of each vertex in the subtree of the vertex where the suffix ends and we subtract this number when we re exiting vertex in DFS Now back to the centroid decomposition equals of vertex in trie where the suffix when in DFS we re at vertex in trie where ends where is the size of the longest suffix of that is a prefix of the string of the path from root to and similarly is the size of the longest suffix of that is a prefix of the string of the path from root to For achieving this goal we can use persistent segment tree on the starting time finishing time range of vertices in the trie or without using persistent segment tree we could calculate every after the centroid decomposition is finished kind of offline Total time complexity where 
https://codeforces.com//contest/1556/problem/A,1093322,A,1556A,1556,A. A Variety of Operations,William has two numbers a and b initially both equal to William mastered performing three different operations with them quickly Before performing each operation some positive integer k is picked which is then used to perform one of the following operations note that for each operation you can choose a positive integer k add number k to both a and b or add number k to a and subtract k from b or add number k to b and subtract k from a Note that after performing operations numbers a and b may become negative as well William wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nset<int> r[maxn];\nint ans = 0;\nbool chk(int a) {\n    if (r[a].empty()) return 1;\n    if (*r[a].rbegin() <= a) return 1;\n    return 0;\n}\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        int c, d;\n        scanf(""%d%d"", &c, &d);\n        int ans = -1;\n        if ((c % 2) != (d % 2)) ans = -1;\n        else if (c == d) ans = 1;\n        else ans = 2;\n        if (c == 0 && d == 0) ans = 0;\n        printf(""%d\\n"", ans);\n    }\n    return (0-0); //<3\n}']",,,['math'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. A Variety of Operations.json,https://codeforces.com//blog/entry/94384,Note that after any of the operations the parity of the expression does not change so if the initial difference of the pair is odd then it is impossible to get this pair Now note that if we can get a pair then it can be obtained in no more than operations To do this consider three cases in this case answer is because initial pair is in this case answer is For this it is enough for us to use the operation of the first type with in this case answer is For this we can use the operations of the first type with After that it is enough for us to use either an operation of the second type with if or an operation of the third type with otherwise 
https://codeforces.com//contest/1807/problem/G1,1838167,G1,1807G1,1807,G1. Subsequence Addition  Easy Version ,Initially array a contains just the number 1 You can perform several operations in order to change the array In an operation you can select some subsequence dagger of a and add into a an element equal to the sum of all elements of the subsequence You are given a final array c Check if c can be obtained from the initial array a by performing some number possibly 0 of operations on the initial array dagger A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several possibly zero but not all elements In other words select k 1 leq k leq a distinct indices i 1 i 2 dots i k and insert anywhere into a a new element with the value equal to a i 1 a i 2 dots a i k ,"['#include ""iostream""\n#include ""vector""\n#include ""algorithm""\n#include ""string""\n#include ""map""\n#include ""bitset""\n#include ""set""\n#include ""numeric""\n#include ""iomanip""\n#include ""random""\n\n#define sz(x) (int)(x.size())\n#define ll long long\n#define int long long\n#define pii pair <int, int>\n#define x first\n#define y second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\nusing namespace std;\n\nvoid solve() {\n    ll n;\n    cin >> n;\n    vector <int> v(n);\n    for (auto & e : v) cin >> e;\n    sort(all(v));\n    int f = 1;\n    int s = 1;\n    if (v[0] != 1) f = 0;\n    for (int i = 1; i < n; i++) {\n        if (v[i] > s) {\n            f = 0;\n        }\n        s += v[i];\n    }\n    if (f) {\n        cout << ""YES\\n"";\n    } else {\n        cout << ""NO\\n"";\n    }\n}\n\nsigned main() {\n//    freopen(""monument.in"", ""r"", stdin);\n//    freopen(""monument.out"", ""w"", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n\n']",,,"['brute force', 'data structures', 'dp', 'greedy', 'implementation', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\G1. Subsequence Addition  Easy Version .json,https://codeforces.com//blog/entry/114143,Firstly let s note that it doesn t matter in what order we add the elements to the array since if we can add an element in any position if it s possible to get the said elements of the array then we can obtain them in any order Now let s note that it s always optimal to obtain the needed elements in sorted order since we only use smaller values in order to obtain the current one so we will consider the array as sorted If the first element of the array isn t then we immediately know such an array doesn t exist Otherwise we can use dynamic programming for finding out if the remaining elements are obtainable Let s denote a boolean array which tells us whether sum is obtainable Initially since the first element is guaranteed to be We will go in increasing order of and if we calculated an element to be obtainable in the past we update all obtainable values with the new value We do this in by going through all sums and updating is true if it already was true or if was true and we add to that sum the new value The total time complexity of this solution is 
https://codeforces.com//contest/1810/problem/F,1858191,F,1810F,1810,F. M-tree,A rooted tree is called if every vertex of the tree either is a leaf a vertex with no children or has exactly m children For a good tree each leaf u has a positive integer c u written on it and we define the value of the leaf as c u mathrm dep u where mathrm dep u represents the number of edges of the path from vertex u to the root also known as the depth of u The of a good tree is the value of all its leaves Now you are given an array of n integers a 1 a 2 ldots a n which are the integers that should be written on the leaves You need to construct a good tree with n leaves and write the integers from the array a to all the leaves Formally you should assign each leaf u an index b u where b is a permutation of length n and represent that the integer written on leaf u is c u a b u Under these constraints you need to the value of the good tree You have q queries Each query gives you x y and changes a x to y and after that you should output the minimum value of a good tree based on the current array a A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::map<int, int> f;\n    f[0] = 0;\n    \n    auto split = [&](int x) {\n        auto it = std::prev(f.upper_bound(x));\n        f[x] = it->second;\n    };\n    \n    auto add = [&](int x) {\n        split(x);\n        auto it = f.find(x);\n        while (it->second == m - 1) {\n            it = f.erase(it);\n        }\n        if (it->first > x) {\n            f[x] = 0;\n        }\n        split(it->first + 1);\n        it->second += 1;\n    };\n    \n    auto del = [&](int x) {\n        split(x);\n        auto it = f.find(x);\n        while (it->second == 0) {\n            it = f.erase(it);\n        }\n        if (it->first > x) {\n            f[x] = m - 1;\n        }\n        split(it->first + 1);\n        it->second -= 1;\n    };\n    \n    for (int i = 0; i < n; i++) {\n        add(a[i]);\n    }\n    \n    while (q--) {\n        int x, y;\n        std::cin >> x >> y;\n        x--;\n        del(a[x]);\n        add(a[x] = y);\n        \n        del(0);\n        \n        auto it = std::prev(f.end());\n        while (it != f.begin() && std::prev(it)->second == 0) {\n            it--;\n            f.erase(std::next(it));\n        }\n        std::cout << it->first << "" \\n""[q == 0];\n        \n        add(0);\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['data structures', 'math', 'sortings', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. M-tree.json,https://codeforces.com//blog/entry/114521,TutorialLet be the number of occurances of integer in the array To check whether the answer can be or not we can do the following greedy Starting with a single vertex written which is the root For each from large ones to small ones if the number of current leaves is smaller than then we can not make the answer Otherwise let leaves stop and other leaves grow children each these vertices are no longer leaves but their children are We can discover that each round the stopped vertices have which represents their value is We can use the following code to calculate it Since a negtive number multiplies is still a negtive number the code can be as following Find out something The final is just which represents it s equivalent to checking So now the answer is just This is the highest bit plus one of in base representation except for that it s just some In this case the answer is but not We can use a segment tree supporting interval min max query and interval covering to solve the question 
https://codeforces.com//contest/1902/problem/E,2362202,E,1902E,1902,E. Collapsing Strings,You are given n strings s 1 s 2 dots s n consisting of lowercase Latin letters Let x be the length of string x Let a C a b of two strings a and b be the following operation if a is empty C a b b if b is empty C a b a if the last letter of a is equal to the first letter of b then C a b C a 1 a 1 b 2 b where s l r is the substring of s from the l th letter to the r th one otherwise C a b a b i e the concatenation of two strings Calculate sum limits i 1 n sum limits j 1 n C s i s j ,"[""#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nstruct Trie {\n    char a_init;\n    int D;\n    int INVALID = -1;\n    std::vector<std::vector<int>> child;\n    std::vector<int> par;\n\n    using T_NODE = int;\n    std::vector<T_NODE> v_info;\n\n    Trie(char a_init = 'a', int D = 26)\n        : a_init(a_init), D(D), child(1, std::vector<int>(D, INVALID)), par(1, -1), v_info(1) {}\n\n    int step(int now, char c) const {\n        if (now == INVALID) return INVALID;\n        return child.at(now).at(c - a_init);\n    }\n\n    int add_word(const std::string &str, T_NODE info) {\n        int now = 0;\n        for (auto &c : str) {\n            if (child[now][c - a_init] == INVALID) {\n                par.push_back(now);\n                child[now][c - a_init] = child.size();\n                child.emplace_back(D, INVALID);\n                v_info.resize(child.size());\n            }\n            now = child[now][c - a_init];\n        }\n        v_info[now] += info;\n        return now;\n    }\n};\n\n\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    vector<string> S(N);\n    for (auto &s : S) cin >> s;\n\n    Trie trie;\n    for (auto s : S) trie.add_word(s, 1);\n\n    for (int i = (int)trie.par.size() - 1; i; --i) trie.v_info.at(trie.par.at(i)) += trie.v_info.at(i);\n\n    long long ret = 0;\n    for (const auto &s : S) ret += (long long)s.size() * N * 2;\n\n    for (auto t : S) {\n        reverse(t.begin(), t.end());\n        int now = 0;\n        for (char c : t) {\n            now = trie.step(now, c);\n            if (now < 0) break;\n            ret -= trie.v_info.at(now) * 2;\n        }\n    }\n\n    cout << ret << '\\n';\n}\n""]",,,"['data structures', 'strings', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Collapsing Strings.json,https://codeforces.com//blog/entry/122951,Let s suppose that when we calculate the collapse of two strings and we reverse the string first so that instead of checking and removing the last letters of we do this to the first letters of Then where is the longest common prefix of the reversed version of and Then the answer to the problem becomes We need some sort of data structure that allows us to store all strings and for every string calculate the total LCP of it with all strings in the structure There are many ways to implement it hashing suffix arrays etc but in our opinion one of the most straightforward is using a trie Build a trie on all strings Then for every vertex of the trie calculate the number of strings that end in the subtree of that vertex you can maintain it while building the trie when you add a new string into it increase this value by on every vertex you go through If you want to find the of two strings and using a trie you can use the fact that it is equal to the number of vertices that are both on the path to and on the path to at the same time except for the root vertex This method can be expanded to querying the sum of of a given string and all strings in the trie as follows try to find in the trie While searching for it you will descend in the trie and go through vertices that represent prefixes of For every such prefix you need the number of strings in the trie that have the same prefix and it is equal to the number of strings ending in the subtree of the corresponding vertex which we already calculated Don t forget that you shouldn t consider the root since the root represents the empty prefix This solution works in or where is the total length of the strings given in the input and is the size of the alphabet 
https://codeforces.com//contest/1814/problem/F,1867161,F,1814F,1814,F. Communication Towers,There are n communication towers numbered from 1 to n and m bidirectional wires between them Each tower has a certain set of frequencies that it accepts the i th of them accepts frequencies from l i to r i Let s say that a tower b is accessible from a tower a if there exists a frequency x and a sequence of towers a v 1 v 2 dots v k b where consecutive towers in the sequence are directly connected by a wire and each of them accepts frequency x Note that accessibility is not transitive i e if b is accessible from a and c is accessible from b then c may not be accessible from a Your task is to determine the towers that are accessible from the 1 st tower ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << "" ""; cout << v[i];\n\t}\n\tcout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nusing ar = array<int, 3>;\nstruct ufundo {\nprivate:\n\tvector<int> par, sz;\n\tvector<ar> mem;\n\tvector<bool> can;\npublic:\n\tufundo(int n) {\n\t\tpar.resize(n, 0);\n\t\tsz.resize(n, 1);\n\t\tcan.resize(n, false);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t\tcan[0] = true;\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) {\n\t\t\tmem.push_back({ -1,-1,-1 });\n\t\t\treturn;\n\t\t}\n\t\tar cur;\n\t\tif (sz[x] > sz[y])swap(x, y);\n\t\tcur[0] = x;\n\t\tcur[1] = y;\n\t\tcur[2] = 0;\n\t\tif (can[x])cur[2] |= 1;\n\t\tif (can[y])cur[2] |= 2;\n\t\tcan[x] = can[y] = false;\n\t\tpar[x] = y; sz[y] += sz[x];\n\t\tmem.push_back(cur);\n\t}\n\tvoid addcan(int k) {\n\t\tcan[k] = true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint getsize(int k) {\n\t\treturn sz[find(k)];\n\t}\n\tvoid undo(int num) {\n\t\trep(_, num) {\n\t\t\tassert(mem.size());\n\t\t\tar a = mem.back(); mem.pop_back();\n\t\t\tif (a[0] < 0)continue;\n\t\t\tint x = a[0], y = a[1], s = a[2];\n\t\t\tpar[x] = x;\n\t\t\tsz[y] -= sz[x];\n\t\t\tif (can[y])can[x] = true;\n\t\t\tif (s & 1)can[x] = true;\n\t\t\tif (s & 2)can[y] = true;\n\t\t}\n\t}\n\tvector<int> query() {\n\t\tvector<int> res;\n\t\trep(i, par.size()) {\n\t\t\tif (can[i])res.push_back(i + 1);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tvector<int> l(n), r(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)r[i]++;\n\tint sz = (1 << 18);\n\tusing ar = array<int, 3>;\n\tauto resol = [&](int a, int b) {\n\t\tvector<int> res;\n\t\tvector<ar> vs;\n\t\tvs.push_back({ 0,0,sz });\n\t\twhile (!vs.empty()) {\n\t\t\tar v = vs.back(); vs.pop_back();\n\t\t\tif (v[2] <= a || b <= v[1])continue;\n\t\t\tif (a <= v[1] && v[2] <= b) {\n\t\t\t\tres.push_back(v[0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvs.push_back({ 2 * v[0] + 1,v[1],(v[1] + v[2]) / 2 });\n\t\t\t\tvs.push_back({ 2 * v[0] + 2,(v[1] + v[2]) / 2,v[2] });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t};\n\tvector<vector<P>> ads(2 * sz - 1);\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tint cl = max(l[a], l[b]);\n\t\tint cr = min(r[a], r[b]);\n\t\tauto ks = resol(cl, cr);\n\t\tfor (int k : ks) {\n\t\t\tads[k].push_back({ a,b });\n\t\t}\n\t}\n\tufundo u(n);\n\tfunction<void(int)> dfs = [&](int k) {\n\t\tfor (auto p : ads[k]) {\n\t\t\tu.unite(p.first, p.second);\n\t\t}\n\t\tif (k >= sz - 1) {\n\t\t\tint loc = u.find(0);\n\t\t\tu.addcan(loc);\n\t\t}\n\t\telse {\n\t\t\tdfs(2 * k + 1);\n\t\t\tdfs(2 * k + 2);\n\t\t}\n\n\t\tu.undo(ads[k].size());\n\t};\n\tdfs(0);\n\tauto ans = u.query();\n\tcoutarray(ans);\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']",,,"['brute force', 'divide and conquer', 'dsu']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Communication Towers.json,https://codeforces.com//blog/entry/114854,Let s consider the sweep line approach by the value of the variable the vertex is active from the moment to the moment And we have to find vertices that are reachable in the graph of active vertices from the vertex So we rephrased the problem as follows there are vertices that are active at some moments and we want to get some information about connectivity during each moment of time This is a standard offline dynamic connectivity problem which can be solved with a divide and conquer approach described here Now we are able to find the connectivity component of the th vertex for each value of It remains to understand how to combine answers for all values of fast enough Let s try to visualize the components as vertices of a directed graph We assign a vertex to each component and when two components merge we add two directed edges from the new vertex to the vertices corresponding to the components and now we can use the reachability information in this graph Each vertex of the original graph corresponds to one of the sinks in this graph and sinks that correspond to the vertices of some component are reachable from the vertex corresponding to that component To restore all the vertex indices later we will mark all components containing the vertex while we run our dynamic connectivity approach Then the vertex of the original graph is included in the answer if the vertex representing the component containing only the vertex is reachable from any of the marked vertices Now all you need to do is run DFS or BFS from all the marked vertices in the component graph 
https://codeforces.com//contest/814/problem/C,108815,C,814C,814,C. An impassioned circulation of affection,Nadeko s birthday is approaching As she decorated the room for the party a long garland of Dianthus shaped paper pieces was placed on a prominent part of the wall Brother Koyomi will like it Still unsatisfied with the garland Nadeko decided to polish it again The garland has pieces numbered from to from left to right and the th piece has a colour denoted by a lowercase English letter Nadeko will repaint of the pieces to give each of them an arbitrary new colour still denoted by a lowercase English letter After this work she finds out all subsegments of the garland containing pieces of only colour Brother Koyomi s favourite one and takes the length of the longest among them to be the of the garland For instance let s say the garland is represented by and Brother Koyomi s favourite colour is Among all subsegments containing pieces of only is the longest with a length of Thus the of this garland equals But problem arises as Nadeko is unsure about Brother Koyomi s favourite colour and has swaying ideas on the amount of work to do She has plans on this each of which can be expressed as a pair of an integer and a lowercase letter meanings of which are explained above You are to find out the maximum achievable after repainting the garland according to each plan ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint q[1600][26];\n\nstring s;\n\nint n;\n\nvoid precalc(){\n    for (int k = 1; k <= n; k++)\n        for (int col = 0; col < 26; col++){\n            vector<int> mas;\n            mas.push_back(-1);\n            for (int i = 0; i < n; i++)\n                if (s[i] != col + \'a\')\n                    mas.push_back(i);\n            mas.push_back(n);\n            if (mas.size() < k + 2)\n                q[k][col] = n;\n            else\n            for (int i = k; i < mas.size() - 1; i++)\n                q[k][col] = max(q[k][col], mas[i + 1] - mas[i - k] - 1);\n        }\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> s;\n    precalc();\n    int zap;\n    cin >> zap;\n    for (int i = 0; i < zap; i++){\n        int k;\n        char col;\n        cin >> k >> col;\n        cout << q[k][col - \'a\'] << \'\\n\';\n    }\n}\n']",,,"['brute force', 'dp', 'strings', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. An impassioned circulation of affection.json,https://codeforces.com//blog/entry/52449,The first thing to notice is that we are only changing other colours to Koyomi s favourite one Furthermore we won t create disconnected segments of that colour for that s no better than painting just around the longest among them This leads us to a straightforward approach when faced with a query we check each segment and determine whether it s possible to fill this segment with letter within at most replacements This can be done by finding the number of times occurs in that segment denote it by and checking whether But this solution would be too slow Since the number of different queries is we can calculate all answers beforehand For each letter and a segment we ll be able to fill the whole segment with within moves Use this information to update the answers and employing a prefix max method gives us a time complexity of where equals Refer to the code for a possible implementation Find out the solutions and the solutions some of them may get TLE remember to check against maximum data next time 
https://codeforces.com//contest/546/problem/E,28219,E,546E,546,E. Soldier and Traveling,In the country there are cities and bidirectional roads between them Each city has an army Army of the th city consists of soldiers Now soldiers roam After roaming each soldier has to either stay in his city or to go to the one of neighboring cities by at Check if is it possible that after roaming there will be exactly soldiers in the th city ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\n#define INF 10000000\nint n,m;\n//vector<int>edge[105];\nint a[105],b[105],c[105];\n\nstruct edgee\n{\n\tint to,cap,rev;\n};\nvector<edgee>G[505];\nbool used[505];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edgee){to,cap,G[to].size()});\n\tG[to].push_back((edgee){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedgee &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\n\nint main(){\n\tcin >> n >> m;\n\tint sum = 0,sum2 = 0;\n\trep2(i,n){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\trep2(i,n){\n\t\tcin >> b[i];\n\t\tsum2 += b[i];\n\t}\n\trep2(i,n) add_edge(0,i,a[i]);\n\trep2(i,n) add_edge(200+i,500,b[i]);\n\trep2(i,n) add_edge(i,200+i,200);\n\trep(i,m){\n\t\tint u,v; cin >> u >> v;\n\t\tadd_edge(u,200+v,200);\n\t\tadd_edge(v,200+u,200);\n\t}\n\tint f = max_flow(0,500);\n\tif(f != sum || f != sum2){\n\t\tcout << ""NO"" << endl;\n\t}\n\telse{\n\t\tcout << ""YES"" << endl; int r[105][105]={};\n\t\trep2(i,n){\n\t\t\trep(j,G[i].size()){\n\t\t\t\tif(200<=G[i][j].to && G[i][j].to<=400){\n\t\t\t\t\tr[i][G[i][j].to-200] = 200-G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep2(i,n){\n\t\t\trep2(j,n){\n\t\t\t\tcout << r[i][j] << (j==n?\'\\n\':\' \');\n\t\t\t}\n\t\t}\n\t}\n}']",,,"['flows', 'graphs', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Soldier and Traveling.json,https://codeforces.com//blog/entry/18034,There are few ways to solve this task but I ll describe the simplest in my opinion one Let s build a flow network in following way Make a source Make a first group of vertices consisting of n vertices each of them for one city Connect a source with ith vertex in first group with edge that has capacity ai Make a sink and second group of vertices in the same way but use bi except for ai If there is a road between cities i and j or i j Make two edges first should be connecting ith vertex from first group and jth vertex from second group and has infinity capacity Second should be similar but connect jth from first group and ith from second group Then find a maxflow in any complexity If maxflow is equal to sum of ai and is equal to sum of bi then there exists an answer How can we get it We just have to check how many units are we pushing through edge connecting two vertices from different groups I told about many solutions because every solution which doesn t use greedy strategy can undo it s previous pushes and does it in reasonable complexity should pass 
https://codeforces.com//contest/1619/problem/C,1234624,C,1619C,1619,C. Wrong Addition,Tanya is learning how to add numbers but so far she is not doing it correctly She is adding two numbers a and b using the following algorithm If one of the numbers is shorter than the other Tanya adds leading zeros so that the numbers are the same length The numbers are processed from right to left that is from the least significant digits to the most significant In the first step she adds the last digit of a to the last digit of b and writes their sum in the answer At each next step she performs the same operation on each pair of digits in the same place and writes the result to the side of the answer For example the numbers a 17236 and b 3465 Tanya adds up as follows large begin array r begin array r 17236 03465 end array hline begin array r 1106911 end array end array calculates the sum of 6 5 11 and writes 11 in the answer calculates the sum of 3 6 9 and writes the result to the left side of the answer to get 911 calculates the sum of 2 4 6 and writes the result to the left side of the answer to get 6911 calculates the sum of 7 3 10 and writes the result to the left side of the answer to get 106911 calculates the sum of 1 0 1 and writes the result to the left side of the answer and get 1106911 As a result she gets 1106911 You are given two positive integers a and s Find the number b such that by adding a and b as described above Tanya will get s Or determine that no suitable b exists ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,a,s,b;\n\nll rek(ll a,ll s){\n    if(s){\n        ll b;\n        ll va=a%10, vs=s%10;\n        a/=10; s/=10;\n        //cout<<va<<"" ""<<vs<<"" ""<<a<<"" ""<<s<<""\\n"";\n        if(vs>=va){\n            b=rek(a,s);\n            if(b!=-1){\n                b*=10;\n                b+=vs-va;\n                return b;\n            }\n        }\n        if(s%10==1 && vs<va && (a<=s/10)){\n            b=rek(a,s/10);\n            if(b!=-1){\n                b*=10;\n                b+=vs-va+10;\n                return b;\n            }\n        }\n        return -1;\n    }\n    else return 0;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>a>>s;\n        b=rek(a,s);\n        cout<<b<<""\\n"";\n    }\n}\n']",,,['implementation'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Wrong Addition.json,https://codeforces.com//blog/entry/98159,Let s compute the answer to the array where is the digit at the position in the number we are looking for Let be the position of the last digit in number be the position of the last digit in number Then denote and consider the cases if then the sum of was exactly then if then the sum was greater than and we need to look at the next digit of the number If there isn t one we can t get the answer we ll output Otherwise we recalculate and reduce by one if now and then Otherwise we deduce since we cannot get more than when adding two digits and the cases where have already been considered before After considering the cases reduce and by one and repeat the checks as long as or In the situation where but we will still have uncheked digits of number so we will also output Otherwise we output an array with the answer without leading zeros 
https://codeforces.com//contest/605/problem/D,42720,D,605D,605,D. Board Game,You are playing a board card game In this game the player has two characteristics and the white magic skill and the black magic skill respectively There are spell cards lying on the table each of them has four characteristics and In one move a player can pick one of the cards and cast the spell written on it but only if first two of it s characteristics meet the requirement and i e if the player has enough magic skill to cast this spell However after casting the spell the characteristics of a player change and become equal to and At the beginning of the game both characteristics of a player are equal to zero The goal of the game is to cast the th spell Your task is to make it in as few moves as possible You are allowed to use spell in any order and any number of times for example you may not use some spells at all ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,a[N],b[N],c[N],d[N],e[N],dis[N],vis[N],pre[N],q[N],m;\nVI vx,vy,dd;\nset<PII> cc[N];\nvoid modify(int x,PII s) {\n\tfor (;x<=m;x+=x&-x) cc[x].insert(s);\n}\nvoid query(int x,int v) {\n\tdd.clear();\n\tfor (;x;x-=x&-x) {\n\t\twhile (1) {\n\t\t\tauto it=cc[x].lower_bound(mp(v,-1));\n\t\t\tif (it==cc[x].end()) break;\n\t\t\tdd.pb(it->se);\n\t\t\tcc[x].erase(it);\n\t\t}\n\t}\n}\nvoid print(int u) {\n\tprintf(""%d\\n"",dis[u]+1);\n\tfor (;u!=-1;u=pre[u]) {\n\t\tprintf(""%d "",u+1);\n\t}\n\tputs("""");\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d%d%d%d"",a+i,b+i,c+i,d+i),vx.pb(a[i]),vx.pb(c[i]),vy.pb(b[i]),vy.pb(d[i]);\n\tsort(all(vx)); sort(all(vy));\n\tif (vx[0]!=0||vy[0]!=0) {\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\trep(i,0,n) vis[i]=0;\n\tvis[n-1]=1; q[0]=n-1; pre[n-1]=-1;\n\tm=SZ(vx);\n\trep(i,0,n) {\n\t\te[i]=m-(lower_bound(vx.begin(),vx.end(),a[i])-vx.begin());\n\t\tc[i]=m-(lower_bound(vx.begin(),vx.end(),c[i])-vx.begin());\n\t\tmodify(c[i],mp(d[i],i));\n\t}\n\tint t=1;\n\trep(i,0,t) {\n\t\tint u=q[i];\n\t\tif (a[u]==0&&b[u]==0) {\n\t\t\tprint(u);\n\t\t\treturn 0;\n\t\t}\n\t\tquery(e[u],b[u]);\n\t\tfor (auto v:dd) {\n\t\t\tif (vis[v]) continue;\n\t\t\tdis[v]=dis[u]+1; vis[v]=1;\n\t\t\tpre[v]=u; q[t++]=v;\n\t\t}\n\t}\n\tputs(""-1"");\n}\n']",,,"['data structures', 'dfs and similar']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Board Game.json,https://codeforces.com//blog/entry/22019,Consider n vectors starting at points a i b i and ending at points c i d i Run BFS On each of its stages we must able to perform such an operation get set of vectors starting inside rectangle 0 x c i 0 y d i and never consider these vectors again It can be managed like this Compress x coordinates For each x we ll hold the list of vectors which first coordinate is x Create a segment tree with first coordinate as index and second coordinate as value The segment tree must be able to find index of minimum for segment and to set value at point Now consider we have to find all the vectors with first coordinate from 0 to x and second coordinate from 0 to y Let s find index of minimum in the segment tree for segment 0 x This minimum points us to the vector x y whose x that index of minimum and y value of minimum Remove it from list of vectors adding also to the queue of the BFS and set in the segment tree to this index second coordinate of the next vector with first coordinate x Continue this way while minimum on a segment remains less than y So on each step we will find list of not yet visited vectors in the bottom right rectangle and each vector would be considered only once after what it would be deleted from data structures 
https://codeforces.com//contest/258/problem/E,2446,E,258E,258,E. Little Elephant and Tree,The Little Elephant loves trees very much he especially loves root trees He s got a tree consisting of nodes the nodes are numbered from 1 to with root at node number Each node of the tree contains some list of numbers which initially is empty The Little Elephant wants to apply operations On the th operation he first adds number to lists of all nodes of a subtree with the root in node number and then he adds number to lists of all nodes of the subtree with root in node After applying all operations the Little Elephant wants to count for each node number the number of integers such that the lists of the th and the th nodes contain at least one common number Help the Little Elephant count numbers for him ,"['#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing std::vector;\nusing std::pair;\nusing std::make_pair;\n\n#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i) \n\nconst int N = 100000;\n\nint n, m, label_count, label[N], size[N], position[N];\nvector <int> tree[N];\n\nvoid dfs(int p, int u) {\n    label[u] = label_count ++;\n    position[label[u]] = u;\n    size[u] = 1;\n    foreach (iter, tree[u]) {\n        if (*iter != p) {\n            dfs(u, *iter);\n            size[u] += size[*iter];\n        }\n    }\n}\n\nint a[N], b[N];\n\nvector <pair <int, int> > events;\n\nint get_id(int l, int r) {\n    return l + r | l != r;\n}\n\nint cover[N << 1], total[N << 1];\n\nvoid update(int l, int r) {\n    int m = l + r >> 1;\n    total[get_id(l, r)] = total[get_id(l, m)] + total[get_id(m + 1, r)];\n    if (cover[get_id(l, r)]) {\n        total[get_id(l, r)] = r - l + 1;\n    }\n}\n\nvoid modify(int l, int r, int a, int b, int c) {\n    if (b < l || r < a) {\n        return;\n    }\n    if (a <= l && r <= b) {\n        cover[get_id(l, r)] += c;\n        if (l == r) {\n            total[get_id(l, r)] = cover[get_id(l, r)] > 0;\n        } else {\n            update(l, r);\n        }\n        return;\n    }\n    int m = l + r >> 1;\n    modify(l, m, a, b, c);\n    modify(m + 1, r, a, b, c);\n    update(l, r);\n}\n\nint answer[N];\n\nint main() {\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n - 1; ++ i) {\n        int a, b;\n        scanf(""%d%d"", &a, &b);\n        a --, b --;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    label_count = 0;\n    dfs(-1, 0);\n    for (int i = 0; i < m; ++ i) {\n        scanf(""%d%d"", a + i, b + i);\n        a[i] --;\n        b[i] --;\n        events.push_back(make_pair(label[a[i]], i << 1));\n        events.push_back(make_pair(label[a[i]] + size[a[i]], (i << 1) | 1));\n        events.push_back(make_pair(label[b[i]], i << 1));\n        events.push_back(make_pair(label[b[i]] + size[b[i]], (i << 1) | 1));\n    }\n    std::sort(events.begin(), events.end());\n    memset(cover, 0, sizeof(cover));\n    for (int now = 0, pt = 0; now < n; ++ now) {\n        while (pt < (int)events.size() && events[pt].first == now) {\n            int id = events[pt].second >> 1;\n            int delta = (events[pt].second & 1) ? -1 : 1;\n            modify(0, n - 1, label[a[id]], label[a[id]] + size[a[id]] - 1, delta);\n            modify(0, n - 1, label[b[id]], label[b[id]] + size[b[id]] - 1, delta);\n            pt ++;\n        }\n        answer[position[now]] = std::max(total[get_id(0, n - 1)] - 1, 0);\n    }\n    for (int i = 0; i < n; ++ i) {\n        printf(""%d%c"", answer[i], i == n - 1 ? \'\\n\' : \' \');\n    }\n    return 0;\n}\n']",,,"['data structures', 'dfs and similar', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Little Elephant and Tree.json,https://codeforces.com//blog/entry/6213,Very useful thing in this problem is ordering all vertices in DFS order preorped After that any subtree can be represented as a some sequence of continuous vertices Consider that we have some fixed vertex Which vertices should be included in Obviously if in the path from the root to is some non empty vertex i e such that has at least one integer in its list than each vertex from substree should be included in but since we now working with preorder traversal of the tree we consider that every vertex from some segment must be included to More generally let for each vertex keep some set of segments If on the th operation we have two vertices and we add segment to vertex and to vertex Also for each vertex we add segment where is a segment in our preored traversal for subtree After that you can see that if we unite all segments from all vertices on the path from the root to some vertex we find the result for which will be the size of the resulting set So now we need some data structure that would support three operations add l r subtract l r count The first one should add 1 to all positions from to inclusive The second should subtract 1 from all positions from to inclusive The last should count the number of non zero element This all can be done either with segment tree or sqrt decomposition 
https://codeforces.com//contest/1933/problem/E,2499501,E,1933E,1933,E. Turtle vs. Rabbit Race  Optimal Trainings,Isaac begins his training There are n running tracks available and the i th track 1 le i le n consists of a i equal length sections Given an integer u 1 le u le 10 9 finishing each section can increase Isaac s ability by a certain value described as follows Finishing the 1 st section increases Isaac s performance by u Finishing the 2 nd section increases Isaac s performance by u 1 Finishing the 3 rd section increases Isaac s performance by u 2 ldots Finishing the k th section k ge 1 increases Isaac s performance by u 1 k The value u 1 k can be negative which means finishing an extra section decreases Isaac s performance You are also given an integer l You must choose an integer r such that l le r le n and Isaac will finish section of track l l 1 dots r that is a total of sum i l r a i a l a l 1 ldots a r sections Answer the following question what is the optimal r you can choose that the increase in Isaac s performance is maximum possible If there are multiple r that maximize the increase in Isaac s performance output the r To increase the difficulty you need to answer the question for q different values of l and u ,"['/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e5+10;\nint n,a[N];\nvoid leeminhduc2()\n{\n    cin >> n;\n    for (int i=1;i<=n;i++)\n    {\n        cin >> a[i];\n        a[i]+=a[i-1];\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int l,u;\n        cin >> l >> u;\n        int lf=l,rg=n;\n        int pos=upper_bound(a+1,a+n+1,a[l-1]+u)-a;\n        if (pos==n+1) cout << n << "" "" ;\n        else if (pos==l) cout << l << "" "";\n        else\n            if (1ll*(u+u-(a[pos-1]-a[l-1])+1)*(a[pos-1]-a[l-1])/2>=1ll*(1+u)*u/2-1ll*(a[pos]-a[l-1]-u)*(a[pos]-a[l-1]-u-1)/2)\n                cout << pos-1 << "" "";\n            else\n                cout << pos << "" "";\n    }\n    cout << ""\\n"";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n']",,,"['binary search', 'implementation', 'math', 'ternary search']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Turtle vs. Rabbit Race  Optimal Trainings.json,https://codeforces.com//blog/entry/126560,Notice that if we choose some such that the sum of does not exceed then completing each of the sections will increase our abilities Using prefix sums and binary search we will find the largest such Smaller values will increase our abilities by a smaller amount so there is no point in checking them However it is worth considering the value Despite the fact that some of the sections of the track will only decrease our abilities the overall increase may be positive for example if the increases on the track are Considering following values is pointless as completing all following tracks will only decrease our abilities Also for finding the answer ternary search can be used 
https://codeforces.com//contest/1349/problem/C,619061,C,1349C,1349,C. Orac and Game of Life,Orac likes games Recently he came up with the new game You should play this game on a black and white grid with n rows and m columns Each cell is either black or white For each iteration of the game the initial iteration is 0 the color of each cell will change under the following rules If there are no adjacent cells with the same color as this cell on the current iteration the color of it on the next iteration will be the same Otherwise the color of the cell on the next iteration will be different Two cells are adjacent if they have a mutual edge Now Orac has set an initial situation and he wants to know for the cell i j in i th row and j th column what will be its color at the iteration p He may ask you these questions several times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll INF = (ll)2e18;\nconst int N = 1010;\nchar s[N][N];\nint n, m;\nconst int DX[] = {-1, 1, 0, 0};\nconst int DY[] = {0, 0, -1, 1};\nll dist[N][N];\npii q[N * N];\nint topQ;\n\nbool checkCell(int x, int y) {\n\treturn 0 <= x && x < n && 0 <= y && y <= m;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint k;\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%s"", s[i]);\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < m; y++) {\n\t\t\tdist[x][y] = INF;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint xx = x + DX[i], yy = y + DY[i];\n\t\t\t\tif (!checkCell(xx, yy)) continue;\n\t\t\t\tif (s[xx][yy] == s[x][y]) dist[x][y] = 0;\n\t\t\t}\n\t\t\tif (dist[x][y] == 0) q[topQ++] = mp(x, y);\n\t\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint x = q[i].first, y = q[i].second;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint xx = x + DX[j], yy = y + DY[j];\n\t\t\tif (!checkCell(xx, yy)) continue;\n\t\t\tif (dist[xx][yy] <= dist[x][y] + 1) continue;\n\t\t\tdist[xx][yy] = dist[x][y] + 1;\n\t\t\tq[topQ++] = mp(xx, yy);\n\t\t}\n\t}\n\twhile(k--) {\n\t\tint x, y;\n\t\tll t;\n\t\tscanf(""%d%d%lld"", &x, &y, &t);\n\t\tx--;y--;\n\t\tchar ans = s[x][y];\n\t\tif (t >= dist[x][y] && (t - dist[x][y]) % 2 == 1) ans ^= 1;\n\t\tprintf(""%c\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']",,,"['dfs and similar', 'graphs', 'implementation', 'shortest paths']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Orac and Game of Life.json,https://codeforces.com//blog/entry/77284,A cell is said to be if and only if there is a cell adjacent to which has the same color to If a cell is not good it is said to be Therefore the color of a cell changes after a turn if and only if the cell is good According to the definition any cell never changes its color if every cell is bad Also a good cell would never turn into a bad cell For a bad cell if there is a good cell adjacent to will turn into a good cell after a turn because currently has a different color from and the color of will change after a turn but the color of won t change otherwise after a turn the color of and cells adjacent to stays the same so is still bad For a cell let be the number of turns needed for that becomes a good cell According to the paragraph above equals to the minimal Manhattan distance from to a good cell Therefore can be figured out by BFS Notice that for the color of stays the same after the th turn for the color of changes after the th turn Therefore each query can be processed with time complexity The total time complexity is 
https://codeforces.com//contest/659/problem/D,53565,D,659D,659,D. Bicycle Race,Maria participates in a bicycle race The speedway takes place on the shores of Lake Lucerne just repeating its contour As you know the lake shore consists only of straight sections directed to the north south east or west Let s introduce a system of coordinates directing the axis from west to east and the axis from south to north As a starting position of the race the southernmost point of the track is selected and if there are several such points the most western among them The participants start the race moving to the north At all straight sections of the track the participants travel in one of the four directions north south east or west and change the direction of movement only in bends between the straight sections The participants of course never turn back that is they do not change the direction of movement from north to south or from east to west or vice versa Maria is still young so she does not feel confident at some turns Namely Maria feels insecure if at a failed or untimely turn she gets into the water In other words Maria considers the turn dangerous if she immediately gets into the water if it is ignored Help Maria get ready for the competition determine the number of dangerous turns on the track ,"['#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n\n#define ull long long\n\n#define x first\n#define y second\n#define mp std::make_pair\n#define pii std::pair<ull,ull>\n\nconst int MAXN=1000;\n\npii operator - (pii A,pii B) { return mp(A.x-B.x,A.y-B.y); }\null operator * (pii A,pii B) { return A.x*B.y-A.y*B.x; }\n\npii p[MAXN+10];\n\nint n;\n\nvoid init()\n{\n\tstd::cin>>n;\n\tint lx,ly,fx,fy;\n\tfor (int i=1;i<=n;i++) {\n\t\tint x,y; scanf(""%d%d"",&x,&y);\n\t\tif (i>1) p[i-1]=mp(x-lx,y-ly);\n\t\telse fx=x,fy=y;\n\t\tlx=x; ly=y; }\n\tscanf(""%d%d"",&fx,&fy);\n\tp[n]=mp(fx-lx,fy-ly);\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tint nxt=(i==n)?(1):(i+1);\n\t\tif (p[i]*p[nxt]>0) ans++; }\n\tstd::cout<<ans<<std::endl;\n\treturn ;\n}\n\nint main()\n{\n\tinit();\n\treturn 0;\n}']",,,"['geometry', 'implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Bicycle Race.json,https://codeforces.com//blog/entry/44093,From the track description follows that Maria moves the way that the water always located to the right from her so she could fall into the water only while turning left To check if the turn is to the left let s give every Maria s moves directions a number moving to the north moving to the west to the south and to the east Then the turn is to the left if and only if the number of direction after performing a turn is equal to the number before performing a turn plus one modulo This solution has complexity One can solve this problem in alternative way Let the answer be equal to that means that the number of inner corners of degrees equals but the number of inner corners of degrees to As soon as the sum of the inner corners values of polygon of vertices is equal to then equals to This leads us to being the answer for the problem calculated in 
https://codeforces.com//contest/1242/problem/D,461422,D,1242D,1242,D. Number Discovery,Ujan needs some rest from cleaning so he started playing with infinite sequences He has two integers n and k He creates an infinite sequence s by repeating the following steps Find k smallest distinct positive integers that are not in s Let s call them u 1 u 2 ldots u k from the smallest to the largest Append u 1 u 2 ldots u k and sum i 1 k u i to s in this order Go back to the first step Ujan will stop procrastinating when he writes the number n in the sequence s Help him find the index of n in s In other words find the integer x such that s x n It s possible to prove that all positive integers are included in s only once ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nll K;\n\nll sum(ll a, ll b) { // a to a-b+1\n\treturn b*(2*a-b+1)/2;\n}\n\nll cdiv(ll a, ll b) { return (a+b-1)/b; }\nll ind(ll a, ll b) {\n\tll num = a-b;\n\t// 1..K -> 1..K\n\t// K+1..2K -> K+2..2K+1\n\tll rem = num%K; if (rem == 0) rem = K;\n\treturn (num-1)/K*(K+1)+rem;\n\t// there are n-x.s, groups of K\n}\n\nll range(ll L, ll R) {\n\treturn (L+R)*(R-L+1)/2;\n}\n\nll range(ll L, ll R, ll X) {\n\tif (X < L) return range(L,R);\n\tif (X > R) return range(L-1,R-1);\n\treturn range(L-1,R)-X;\n}\n\npl lastSum(ll n) {\n\tif (n < K*(K+1)/2) return {0,0};\n\t// x, x-2, ..., x-K <= n -> K*x <= n+K*(K+1)/2-1\n\tll x = (n+K*(K+1)/2-1)/K; auto a = lastSum(x);\n\tif (a.f == x) {\n\t\tll xind = ind(x-1,a.s-1); int pos = xind%(K+1);\n\t\tif (pos == K) return {range(x-K,x-1),xind/(K+1)+1};\n\t\treturn {range(x-pos-K,x-pos-1),xind/(K+1)};\n\t} else {\n\t\tll xind = ind(x,a.s); int pos = xind%(K+1);\n\t\tif (range(x-pos+1,x-pos+K,a.f) <= n) return {range(x-pos+1,x-pos+K,a.f),xind/(K+1)+1};\n\t\treturn {range(x-pos+1-K,x-pos,a.f),xind/(K+1)};\n\t}\n}\n\nll solve(ll n) {\n\tauto x = lastSum(n);\n\tif (x.f == n) return x.s*(K+1);\n\treturn ind(n,x.s);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) {\n\t\tll N; re(N,K);\n\t\t/*FOR(i,1,K+1) assert(ind(i,0) == i);\n\t\tFOR(i,K+1,2*K+1) assert(ind(i,0) == i+1);\n\t\texit(0);*/\n\t\tps(solve(N));\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']",,,['math'],3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Number Discovery.json,https://codeforces.com//blog/entry/71216,Let s make some definitions is if is appended into by summation form For example if then are non self numbers is if is not non self number Let In other words is th interval of positive integers with size Now let me introduce some strong lemma Every interval has non self number Furthermore we can of using non self number of How is this possible First you can prove there is only non self number in Now let s try induction Suppose has only non self number and each numbers of self numbers form summation then you can describe generated summations as follows Where means index of subintervals in and means added offset into th subinterval since s non self number can be located at left or inside of th subinterval Using this fact you can solve this problem in per test case Some testers solved this problem by detecting pattern of distribution of non self numbers 
https://codeforces.com//contest/1497/problem/E2,925010,E2,1497E2,1497,E2. Square-Free Division  hard version ,There is an array a 1 a 2 ldots a n of n positive integers You should divide it into a minimal number of continuous segments such that in each segment there are no two numbers on different positions whose product is a perfect square Moreover it is allowed to do at most k such operations before the division choose a number in the array and change its value to any positive integer What is the minimum number of continuous segments you should use if you will make changes optimally ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    vector<int> h(1e7 + 5);\n    vector<int> e(1e7 + 5, 1);\n    vector<int> minD(1e7 + 5, -1);\n    minD[1] = 1;\n    for (ll i = 2; i < 1e7 + 5; ++i) {\n        if (e[i]) {\n            minD[i] = i;\n            for (ll j = i; j * i < 1e7 + 5; ++j) {\n                e[i * j] = 0;\n                if (minD[i * j] == -1) {\n                    minD[i * j] = i;\n                } else {\n                    minD[i * j] = min(minD[i * j], (int)i);\n                }\n\n            }\n        }\n    }\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            int ans = 1;\n            map<int, int> cnt;\n            while (minD[a[i]] != 1) {\n                ++cnt[minD[a[i]]];\n                a[i] /= minD[a[i]];\n            }\n            for (auto &elem : cnt) {\n                if (elem.se % 2) {\n                    ans *= elem.fi;\n                }\n            }\n            a[i] = ans;\n        }\n        vector<vector<int>> sameSegment(k + 1, vector<int>(n));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) h[a[j]] = 0;\n            int l = 0, cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                ++h[a[j]];\n                if (h[a[j]] > 1) {\n                    ++cnt;\n                }\n                while (cnt > i) {\n                    if (h[a[l]] > 1) {\n                        --cnt;\n                    }\n                    --h[a[l]];\n                    ++l;\n                }\n                sameSegment[i][j] = l;\n            }\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(n, 1e9));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int z = 0; z <= i; ++z) {\n                    int ans = 1;\n                    if (sameSegment[i - z][j] - 1 != -1) {\n                        ans += dp[z][sameSegment[i - z][j] - 1];\n                    }\n                    dp[i][j] = min(dp[i][j], ans);\n                }\n            }\n        }\n        int res = 1e9;\n        for (int j = 0; j <= k; ++j) {\n            res = min(res, dp[j][n - 1]);\n        }\n        cout << res << \'\\n\';\n    }\n}\n/*\n*/\n']",,,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E2. Square-Free Division  hard version .json,https://codeforces.com//blog/entry/88677,Let s use the same definitions as in tutorial of E1 So after making for all we need to split the whole array into minimal amount of contiguous subsegments with all different elements Also we can change elements how we want Firstly for each and let s find such minimal index so that after making changes the segment contains only distinct values For fixed if is increased then increases too that s why for fixed we can use the two pointers technique This allows us to calculate in Now for each and let s calculate the minimal amount of contiguous subsegments that prefix is possible to divide into after making changes For each let s consider the amount of changes on the last subsegment Let s say that then This is done in so the total complexity of the solution after making is 
https://codeforces.com//contest/1494/problem/B,913251,B,1494B,1494,B. Berland Crossword,Berland crossword is a puzzle that is solved on a square grid with n rows and n columns Initially all the cells are white To solve the puzzle one has to color some cells on the border of the grid black in such a way that exactly U cells in the top row are black exactly R cells in the rightmost column are black exactly D cells in the bottom row are black exactly L cells in the leftmost column are black Note that you can color zero cells black and leave every cell white Your task is to check if there exists a solution to the given puzzle ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\n\n\nvoid solve()\n{\n    int n, U, R, D, L;\n    cin>>n>>U>>R>>D>>L;\n\n    for (int mask = 0; mask<16; mask++)\n    {\n        bool check = true;\n\n        int u = 0, d = 0, r = 0, l = 0;\n        if (mask&1)\n        {\n            u++; l++;\n        }\n        if (mask&2)\n        {\n            l++; d++;\n        }\n        if (mask&4)\n        {\n            d++; r++;\n        }\n        if (mask&8)\n        {\n            r++; u++;\n        }\n        if (u>U || u + (n-2)<U) check = false;\n        if (d>D || d + (n-2)<D) check = false;\n        if (l>L || l + (n-2)<L) check = false;\n        if (r>R || r + (n-2)<R) check = false;\n\n        if (check) {cout<<""YES""<<endl; return;}\n    }\n    cout<<""NO""<<endl;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}']",,,"['bitmasks', 'brute force', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Berland Crossword.json,https://codeforces.com//blog/entry/88344,Consider some corner of the picture If it s colored black then it contributes to counts to both of the adjacent sides Otherwise it contributes to none All the remaining cells can contribute only to the side they are on There are of such cells on each side So let s try all options of coloring the corners After fixing the colors of the corners we can calculate the number of cells that have to be colored on each side That is calculated by taking the initial requirement and subtracting the adjacent colored corners from it If any of the numbers is below or above then that corner coloring doesn t work Otherwise you can always color the cells in some way Overall complexity per testcase 
https://codeforces.com//contest/1969/problem/F,2619522,F,1969F,1969,F. Card Pairing,There is a deck of n cards each card has one of k types You are given the sequence a 1 a 2 dots a n denoting the types of cards in the deck from top to bottom Both n and k are even numbers You play a game with these cards First you draw k topmost cards from the deck Then the following happens each turn of the game you choose two cards from your hand and play them If these cards have the same type you earn a coin then if the deck is not empty you draw two top cards from it then if both your hand and your deck are empty the game ends Otherwise the new turn begins You have to calculate the maximum number of coins you can earn during the game ,"['#include ""bits/stdc++.h""#pragma GCC optimize (""O3"")#pragma GCC target (""sse4"") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\xa0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\xa0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}void __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}void __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}void __print(bool x) {cerr << (x ? ""true"" : ""false"");}\xa0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}template<typename T>void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}void _print() {cerr << ""]\\n"";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;#else#define dbg(x...)#endif\xa0\xa0const int MOD = 1000000007;const char nl = \'\\n\';const int MX = 100001; \xa0set<int> cur;\xa0void flip(int X) {    if (cur.count(X)) {        cur.erase(X);    } else cur.ins(X);}\xa0void solve() {    int N, K; cin >> N >> K;    vi A(N); F0R(i, N) cin >> A[i];    F0R(i, N) A[i]--;    F0R(i, K) flip(A[i]);    int dp[(N-K)/2 + 1];    F0R(i, (N-K)/2 + 1) dp[i] = MX;    F0R(i, (N-K)/2) {        if (sz(cur) == K) {            dp[i] = 0;            goto done;        }        flip(A[K+i*2]); flip(A[K+i*2+1]);    }    dp[(N-K)/2] = 0;    done:    ;\xa0    F0R(i, (N-K)/2) {        bool ev[K]; F0R(j, K) ev[j] = false;        FOR(j, K+i*2, N) {            ev[A[j]] = !ev[A[j]];        }        cur.clear();        int cOdd = K, cEv = 0;        F0R(i, K) if (ev[i]) {            cEv++; cOdd--;        }        int c0 = (cOdd * (cOdd - 1)) / 2;        int c1 = cOdd * cEv;        int c2 = (cEv * (cEv - 1)) / 2;        set<pi> used;        FOR(j, i+1, (N-K)/2) {            flip(A[K+j*2-2]); flip(A[K+j*2-1]);            if (sz(cur) == 2) {                pi cp = {*cur.begin(), *cur.rbegin()};                if (used.count(cp)) continue;                if (!ev[cp.f] && !ev[cp.s]) {                    c0--;                } else if (ev[cp.f] && ev[cp.s]) {                    c2--;                } else c1--;                used.ins(cp);                int cv = dp[i];                if (ev[*cur.begin()]) cv++;                if (ev[*cur.rbegin()]) cv++;                ckmin(dp[j], cv);            }        }        if (c0) {            ckmin(dp[(N-K)/2], dp[i]);        } else if (c1) {            ckmin(dp[(N-K)/2], dp[i] + 1);        } else if (c2) {            ckmin(dp[(N-K)/2], dp[i] + 2);        }    }\xa0    cur.clear();    F0R(i, N) flip(A[i]);    cout << (N-sz(cur))/2 - dp[(N-K)/2] << nl;\xa0\xa0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\xa0    int T = 1;//    cin >> T;    while(T--) {        solve();    }\xa0\treturn 0;}\xa0\xa0']",,,"['dp', 'greedy', 'hashing', 'implementation']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Card Pairing.json,https://codeforces.com//blog/entry/129022,It s pretty obvious that every time we have a pair of equal cards in hand we should play one of these pairs If you re interested in a formal proof please read the paragraph in italic otherwise skip it Whenever we have a pair of equal cards we will always play it at some moment and earn a coin and it does not matter in which order we play different pairs So we have to make a meaningful choice about which cards we play only when all cards in our hand are different In the ideal situation if there are cards of type we want to earn coins by playing these cards But whenever we play only one card of type and there is an odd number of cards of type left both in hand and in deck we lose a coin because the number of pairs we can make decreases by Let s calculate the answer as the maximum possible number of pairs we can form equal to minus the minimum number of coins we lose in such a way Since we play a pair when we have at least one pair we can lose coins only when all cards in our hand are different So let s try to use a dynamic programming of the form is the minimum number of coins we could lose when we have drawn first cards from the deck and all cards in our hand are different Let s analyze the transitions of this dynamic programming When transitioning out of we can iterate on the pair of cards we play since we consider the situation when all cards in our hand are different we can play any pair of different cards for each of these two cards check if we lose a coin by playing them and try to find the next moment when all cards in our hand will be different or update the answer if there is no such moment However when implemented naively it is too slow might take up to We can use the following optimizations to improve it this is one of my favorite techniques Let s assign each card type a random bit number let it be for type Then let be the XOR of the numbers assigned to the first cards in the deck Suppose we are considering transitions from we try to play cards of type and when will be the next moment when we have all types of cards If this moment is then we need to take an odd number of cards of type and from moment to moment and an even number of cards for all other types So we can see that and this allows us to locate the next moment when we have different cards more easily in or even we have up to pairs of cards we can play from each state but only different states we can go into and no two transitions lead to the same state Let s try to make only transitions from each state When considering a state we can split all cards into two types the ones that make us lose a coin when we play them group and all the others group First let s try to play two cards from the group if we find a combination of them such that after playing it we never have different cards in our hand because this transition updates the answer directly without any increases Otherwise perform all transitions with pairs of cards from group and try to play a pair of cards from different groups If we find a combination that updates the answer directly we again can stop considering transitions the next transitions we use won t be more optimal And then we do the same with transitions where we use a pair of cards of group This way we will consider at most transitions from each state Combining these two optimizations results in a solution in or but there are other optimizations you can try 
https://codeforces.com//contest/1172/problem/C1,355010,C1,1172C1,1172,C1. Nauuo and Pictures  easy version ,Nauuo is a girl who loves random picture websites One day she made a random picture website by herself which includes n pictures When Nauuo visits the website she sees exactly one picture The website does not display each picture with equal probability The i th picture has a non negative weight w i and the probability of the i th picture being displayed is frac w i sum j 1 nw j That is to say the probability of a picture to be displayed is proportional to its weight However Nauuo discovered that some pictures she does not like were displayed too often To solve this problem she came up with a great idea when she saw a picture she likes she would add 1 to its weight otherwise she would subtract 1 from its weight Nauuo will visit the website m times She wants to know the expected weight of each picture after all the m visits modulo 998244353 Can you help her The expected weight of the i th picture can be denoted by frac q i p i where gcd p i q i 1 you need to print an integer r i satisfying 0 le r i 998244353 and r i cdot p i equiv q i pmod 998244353 It can be proved that such r i exists and is unique ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define maxn 300005\n#define ll long long\n#define ld double\n#define mod 998244353\n#define maxm 3005\nusing namespace std;\nint n, m; \nint a[maxn], w[maxn];\nll ksm(ll a, ll b)\n{\n\tif(!b) return 1;\n\tll ns = ksm(a, b >> 1);\n\tns = ns * ns % mod;\n\tif(b & 1) ns = ns * a % mod;\n\treturn ns;\n}\nll dp[maxm][maxm];\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tll S[2] = {0, 0};\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &w[i]), \n\t\tS[a[i]] += w[i], \n\t\tS[a[i]] %= mod;\n\tll f[2] = {S[0], S[1]};\n\tdp[1][0] = 1;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tll n1 = S[1] + j, n2 = S[0] - (i - 1 - j);\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tll bk = ksm((n1 + n2) % mod, mod - 2);\n\t\t\tn1 = n1 * bk % mod, \n\t\t\tn2 = n2 * bk % mod;\n\t\t\tdp[i + 1][j] += n2 * dp[i][j], dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += n1 * dp[i][j], dp[i + 1][j + 1] %= mod;\n\t\t}\n\tfor(int j = 0; j <= m + 1; j++)\n\t\tf[1] += dp[m + 1][j] * j, f[1] %= mod, \n\t\tf[0] -= dp[m + 1][j] * (m - j), f[0] %= mod;\n\tS[0] = ksm(S[0], mod - 2);\n\tS[1] = ksm(S[1], mod - 2);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tll ns = f[a[i]] * S[a[i]] % mod * w[i] % mod;\n\t\tif(ns < 0) ns += mod;\n\t\tprintf(""%lld\\n"", ns);\n\t}\n\treturn 0;\n}']",,,"['dp', 'probabilities']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C1. Nauuo and Pictures  easy version .json,https://codeforces.com//blog/entry/67511,Tutorial First let s focus on a single picture with weight which Nauuo likes so we only have to know the sum of the weights of the pictures Nauuo likes and the sum of the disliked ones instead of all the weights Then we can use DP to solve this problem Let be the expected weight of a picture Nauuo likes with weight after another visits since and Obviously The state transition The next visit displays the picture we focus on Probaility Lead to The next visit displays a picture Nauuo likes but is not the one we focus on Probaility Lead to The next visit displays a picture Nauuo doesn t like Probaility Lead to So Let be the expected weight of a picture Nauuo doesn t like with weight after another visits since and The state transition is similar Note that have some relation In fact we can let be and are the initial ones here But up to now we can only solve the easy version To solve the hard version let s introduce a lemma Proof Obviously this is true when Then suppose we have already proved Also a brief but not so strict proof the increment in each step is proportional to the expectation So we only have to calculate In conclusion If the expected weight of the th picture is otherwise the expected weight is Last question how to calculate the result modulo If you don t know how please read the wiki to learn it You can calculate and store all the inverses at first then you can get an solution instead of here 
https://codeforces.com//contest/1613/problem/E,1209365,E,1613E,1613,E. Crazy Robot,There is a grid consisting of n rows and m columns Each cell of the grid is either free or blocked One of the free cells contains a lab All the cells beyond the borders of the grid are also blocked A crazy robot has escaped from this lab It is currently in some free cell of the grid You can send one of the following commands to the robot move right move down move left or move up Each command means moving to a neighbouring cell in the corresponding direction However as the robot is crazy it will do anything except following the command Upon receiving a command it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked If there is such a direction then it will move to a neighbouring cell in that direction Otherwise it will do nothing We want to get the robot to the lab to get it fixed For each free cell determine if the robot can be forced to reach the lab starting in this cell That is after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses it will end up in a lab ,"['#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt(), m = nxt();\n\tvector<string> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tvector<pair<int, int>> coords;\n\tvector<vector<int>> g;\n\tvector<vector<int>> id(n, vector<int>(m, -1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] == \'#\') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid[i][j] = g.size();\n\t\t\tg.push_back({});\n\t\t\tcoords.push_back({i, j});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] == \'#\') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\t\t\tif (abs(dx) + abs(dy) != 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint ni = i + dx, nj = j + dy;\n\t\t\t\t\tif (clamp(ni, 0, n - 1) != ni || clamp(nj, 0, m - 1) != nj) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[ni][nj] == \'#\') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tg[id[i][j]].push_back(id[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint lab = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] == \'L\') {\n\t\t\t\tlab = id[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tconst int sz = g.size();\n\tvector<char> used(sz);\n\tvector<int> rem(sz);\n\tfor (int i = 0; i < sz; ++i) {\n\t\trem[i] = g[i].size();\n\t}\n\tvector<int> st = {lab};\n\tused[lab] = true;\n\twhile (!st.empty()) {\n\t\tint v = st.back();\n\t\tst.pop_back();\n\t\tfor (int x : g[v]) {\n\t\t\t--rem[x];\n\t\t\tif (!used[x] && rem[x] <= 1) {\n\t\t\t\tused[x] = 1;\n\t\t\t\tst.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < sz; ++i) {\n\t\tif (used[i] && i != lab) {\n\t\t\tauto [x, y] = coords[i];\n\t\t\ta[x][y] = \'+\';\n\t\t}\n\t}\n\tfor (auto s : a) {\n\t\tcout << s << ""\\n"";\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']",,,"['dfs and similar', 'graphs']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Crazy Robot.json,https://codeforces.com//blog/entry/97467,One way to think about this problem is in game theory terms Imagine a following game Two players alternate moves The first players chooses a direction The second player chooses a different direction and moves a robot there The game ends when the robot reaches the lab and the first player wins Otherwise it s a draw What s the outcome of the game if both players play optimally as in the first player tries to win the second player tries to draw Does it sound easier Well it sure does if you ever dealt with solving games on arbitrary graphs You can skim through this article if that s unfamiliar to you The state of the game is a pair If a direction is not chosen denote it with it s the first player s move Otherwise it s the second player s move You can even implement it as is Or you can adjust a part of this algorithm for this particular problem Initially all the states are drawing only the state is winning What we basically need is a way to determine if a state is winning or not From game theory we can tell that the state is winning if there s a transition from it to a losing state The state is losing if all the transitions from it lead to winning states So is winning if any of are losing Promote that one step further The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states Rephrase it The state is winning if it has at least one winning state neighbour and no more than one non winning state neighbour Let s store the number of non winning neighbouring states for each cell Initially it s the number of neighbouring free cells If some state becomes marked as winning decrease the value for each of its neighbours by If some state s value reaches or after this operation mark it as winning Since what this does is basically a traversal of a grid this can be done with a DFS BFS starting from the lab Overall complexity per testcase 
https://codeforces.com//contest/95/problem/D,500,D,95D,95,D. Horse Races,Petya likes horse racing very much Horses numbered from to take part in the races Petya wants to evaluate the probability of victory for some reason to do that he needs to know the amount of nearly lucky horses numbers A number is an integer number that has at least two lucky digits the distance between which does not exceed Petya learned from some of his mates from Lviv that lucky digits are digits and The distance between the digits is the absolute difference between their positions in the number of a horse For example if then numbers are nearly lucky and numbers are not Petya prepared intervals and invented number common for all of them Your task is to find how many nearly happy numbers there are in each of these segments Since the answers can be quite large output them modulo ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1000+20;\nconst int mod=1000000007;\n\nint f[maxn][maxn];\nchar L[maxn],R[maxn];\nint test,dist;\n\nvoid renew(int &a,int b)\n{\n\ta+=b;\n\tif (a>=mod) a-=mod;\n}\n\nint calc(char st[],bool flag)\n{\n\tint n=strlen(st+1);\n\tint res=0;\n\tfor (int i=1;i<n;i++)\n\tfor (int j=1;j<10;j++)\n\tif (j==4 || j==7) renew(res,f[i-1][1]);\n\telse renew(res,f[i-1][dist+1]);\n\n\tint state=dist+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint digit=st[i]-\'0\';\n\t\tfor (int j=(i>1?0:1);j<digit;j++)\n\t\tif (state==0) renew(res,f[n-i][0]);else\n\t\tif (j==4 || j==7)\n\t\t{\n\t\t\tif (state<=dist) renew(res,f[n-i][0]);\n\t\t\telse renew(res,f[n-i][1]);\n\t\t} else\n\t\t{\n\t\t\tif (state+1<=dist) renew(res,f[n-i][state+1]);\n\t\t\telse renew(res,f[n-i][dist+1]);\n\t\t}\n\n\t\tif (state==0) state=0;else\n\t\tif (digit==4 || digit==7)\n\t\t{\n\t\t\tif (state<=dist) state=0;\n\t\t\telse state=1;\n\t\t} else state=min(state+1,dist+1);\n\t}\n\tif (flag) renew(res,state==0);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(""%d%d"",&test,&dist);\n\n\tf[0][0]=1;\n\tfor (int i=1;i<=1005;i++)\n\tfor (int j=0;j<=dist+1;j++)\n\tfor (int k=0;k<10;k++)\n\tif (j==0) renew(f[i][j],f[i-1][j]);else\n\tif (k==4 || k==7)\n\t{\n\t\tif (j<=dist) renew(f[i][j],f[i-1][0]);\n\t\telse renew(f[i][j],f[i-1][1]);\n\t} else\n\t{\n\t\tif (j+1<=dist) renew(f[i][j],f[i-1][j+1]);\n\t\telse renew(f[i][j],f[i-1][dist+1]);\n\t}\n\n\tfor (;test--;)\n\t{\n\t\tscanf(""%s%s"",L+1,R+1);\n\t\tint A=calc(R,1);\n\t\tint B=calc(L,0);\n\t\tA-=B;\n\t\tif (A<0) A+=mod;\n\t\tprintf(""%d\\n"",A);\n\t}\n}\n']",,,"['dp', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Horse Races.json,https://codeforces.com//blog/entry/2257,Let we have array DP x y z number of x digits number if last lucky digit was on position y bool z 0 or 1 was the pair of lucky digits with less than or equal distance then K call it lucky pair Now let S string which represent number N Let F x y z result for substring of first x digits y position of last lucky digit z 0 or 1 was the lucky pair before Try to assign some digits on position x If this digit is less than S i then add to result for F x y z DP n x 1 yy zz yy updated position of last lucky digit zz updated bool for lucky pairs If this digit is equal to S i add F x 1 yy zz DP can be calculated simply Let from state x y z we place some digit d on position x Then we can go to state x 1 yy zz Again yy and zz updated parameters 
https://codeforces.com//contest/1826/problem/E,1909269,E,1826E,1826,E. Walk the Runway,A fashion tour consists of m identical runway shows in different cities There are n models willing to participate in the tour numbered from 1 to n People in different cities have different views on the fashion industry so they rate each model differently In particular people in city i rate model j with rating r i j You are to choose some number of k models and their order let the chosen models have indices j 1 j 2 dots j k in the chosen order In each city these k models will walk the runway one after another in this order To make the show exciting in each city the ratings of models should be strictly increasing in the order of their performance More formally for any city i and index t 2 leq t leq k the ratings must satisfy r i j t 1 r i j t After all the fashion industry is all about money so choosing model j to participate in the tour profits you p j money Compute the maximum total profit you can make by choosing the models and their order while satisfying all the requirements ,"['#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nconst int N = 5005;\nbitset<N> cant[N];\nint reward[N];\n\nint a[N][N];\nint n, m;\n\nll dp[N];\nint order[N];\n\nvoid solve(){\n    cin >> m >> n;\n    for(int i=1;i<=n;i++) cin >> reward[i];\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            cin >> a[i][j];\n        }\n    }\n    for(int r=1;r<=m;r++){\n        vector<pii> models;\n        for(int i=1;i<=n;i++){\n            models.pb(mp(a[r][i], i));\n        }\n        sort(models.begin(), models.end());\n        bitset<N> was;\n        for(int i=0;i<n;i++){\n            int j = i;\n            while(j + 1 < n && models[j + 1].st == models[j].st) j++;\n            for(int k=i;k<=j;k++){\n                was[models[k].nd] = true;\n            }\n            for(int k=i;k<=j;k++){\n                cant[models[k].nd] |= was;\n            }\n            i = j;\n        }\n    }\n    const ll inf = 1e18;\n    for(int i=1;i<=n;i++) dp[i] = -inf;\n    vector<pii> ord;\n    for(int i=1;i<=n;i++) ord.pb(mp(a[1][i], i));\n    sort(ord.begin(), ord.end());\n    for(int i=1;i<=n;i++) order[i] = ord[i - 1].nd;\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        dp[i] = reward[order[i]];\n        ans = max(ans, dp[i]);\n    }\n    for(int i=1;i<n;i++){\n        int who = order[i];\n        for(int j=i+1;j<=n;j++){\n            if(!cant[who][order[j]]){\n                dp[j] = max(dp[j], dp[i] + reward[order[j]]);\n                ans = max(ans, dp[j]);\n            }\n        }\n    }\n    cout << ans << ""\\n"";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    // cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n']",,,"['bitmasks', 'brute force', 'data structures', 'dp', 'graphs', 'implementation', 'sortings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Walk the Runway.json,https://codeforces.com//blog/entry/115892,At first let s define the relation between two models that go one after another in the show Their ratings must satisfy for all cities Now let s precompute this relations for all pairs of models naively in which is ok for now Now we have the relations model can go before model let s build a graph of such relations This graph has no cycles since the ratings are strictly increasing Now we can build the topological sorting of this graph and compute the biggest profit if the last model is model in Now how to calculate this relation for all pairs of models fast enough Let s process each city one by one and update the relations using bitsets More formally let s store a bitset of all the models that can be before model in city If we process the models in order of increasing rating we can update each models bitset of relations in so the total time complexity would be which is fast enough 
https://codeforces.com//contest/336/problem/A,3386,A,336A,336,A. Vasily the Bear and Triangle,Vasily the bear has a it has one vertex at point and the opposite vertex at point Of course the sides of Vasya s favorite rectangle are parallel to the coordinate axes Vasya also loves triangles if the triangles have one vertex at point That s why today he asks you to find two points and such that the following conditions hold the coordinates of points are integers Besides the following inequation holds the triangle formed by point and is rectangular and isosceles is right all points of the favorite rectangle are located inside or on the border of triangle the area of triangle is as small as possible Help the bear find the required points It is not so hard to proof that these points are unique ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint x, y, x1, y1, x2, y2;\n\nint main()\n{\n\tscanf(""%d %d"", &x, &y);\n\tif (x > 0)\n\t{\n\t\tif (y > 0)\n\t\t{\n\t\t\tx1 = x + y, y1 = 0;\n\t\t\tx2 = 0, y2 = x + y;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tx1 = x - y, y1 = 0;\n\t\t\tx2 = 0, y2 = 0 - (x - y);\n\t\t}\n\t}\n\n\telse\n\t{\n\t\tif (y < 0)\n\t\t{\n\t\t\tx1 = x + y, y1 = 0;\n\t\t\tx2 = 0, y2 = x + y;\n\t\t}\n\t\t\n\t\telse\n\t\t{\n\t\t\tx1 = x - y, y1 = 0;\n\t\t\tx2 = 0, y2 = 0 - (x - y);\n\t\t}\n\t}\n\t\n\tif (x1 > x2)\n\t\tswap(x1, x2), swap(y1, y2);\n\tprintf(""%d %d %d %d\\n"", x1, y1, x2, y2);\n\treturn 0;\n}\n']",,,"['implementation', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Vasily the Bear and Triangle.json,https://codeforces.com//blog/entry/8574, Then first point is second Swap points if needed according to statement Let s see why this is the answer Conditions and give us that one point is on X axis and the other on Y axis Let s see how it works for and Other cases can be proved in similar way We need to show that belongs to our triangle including it s borders In fact belongs to segment connecting with Line through and is Using coordinates in this equation proves the statement Author s solution 
https://codeforces.com//contest/1388/problem/B,686567,B,1388B,1388,B. Captain Flint and a Long Voyage,In the beginning uncle Bogdan wrote on a board a positive integer x consisting of n digits After that he wiped out x and wrote integer k instead which was the concatenation of binary representations of digits x consists of without leading zeroes For example let x 729 then k 111101001 since 7 111 2 10 9 1001 After some time uncle Bogdan understood that he doesn t know what to do with k and asked Denis to help Denis decided to wipe last n digits of k and named the new number as r As a result Denis proposed to find such integer x of length n that r as number is maximum possible If there are multiple valid x then Denis is interested in the minimum one All crew members including captain Flint himself easily solved the task All except cabin boy Kostya who was too drunk to think straight But what about you Note in this task we compare integers x or k as numbers despite what representations they are written in so 729 1999 or 111 1000 ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main() {\n\tint a[N];\n\tf(i, N)a[i] = 0;\n\tint n, k, t;\n\tint x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(""%d"", &t);\n\tf(tt, t) {\n\t\tscanf(""%d"", &n);\n\t\tk = (n + 3) / 4;\n\t\tf(i, n - k)printf(""9"");\n\t\tf(i, k)printf(""8"");\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}']",,,"['greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Captain Flint and a Long Voyage.json,https://codeforces.com//blog/entry/80828,Statement This is so because if contains digits which in their binary notation are shorter than digits then the number written on the board and therefore the number obtained by removing the last digits of the number will be shorter than if you use only the digits and which means it will not be the maximum possible Statement Obviously the more the more and Therefore to maximize must be However due to the fact that is without the last digits at the end of the number it is possible to replace a certain number of digits with so that will still be the maximum possible Statement and We can see that the binary notations of the digits and are long and differ in the last digit Suppose the suffix of a number consists of digits Then the maximum is achieved if at least digits are removed from the end of By the condition of the problem exactly digits are removed which means and then Complexity 
https://codeforces.com//contest/977/problem/E,181256,E,977E,977,E. Cyclic Components,You are given an undirected graph consisting of n vertices and m edges Your task is to find the number of connected components which are cycles Here are some definitions of graph theory An undirected graph consists of two sets set of nodes called vertices and set of edges Each edge connects a pair of vertices All edges are bidirectional i e if a vertex a is connected with a vertex b a vertex b is also connected with a vertex a An edge can t connect vertex with itself there is at most one edge between a pair of vertices Two vertices u and v belong to the same connected component if and only if there is at least one path along edges connecting u and v A connected component is a cycle if and only if its vertices can be reordered in such a way that the first vertex is connected with the second vertex by an edge the second vertex is connected with the third vertex by an edge the last vertex is connected with the first vertex by an edge all the described edges of a cycle are distinct A cycle doesn t contain any other edges except described above By definition any cycle contains three or more vertices ,"['/*input\n17 15\n1 8\n1 12\n5 11\n11 9\n9 15\n15 5\n4 13\n3 13\n4 3\n10 16\n7 10\n16 7\n14 3\n14 4\n17 6\n\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define db(a) cerr<<#a<<"" = ""<<a<<\'\\n\'\nusing namespace std;\n\nconst int maxn = 2e5 + 1000;\nvector<int> adj[maxn];\nbool vis[maxn];\nint n, m, ans;\n\nbool g = 1;\nvoid dfs(int v){\n\tvis[v] = 1;\n\tif(adj[v].size() != 2) g = 0;\n\tfor(auto u : adj[v]){\n\t\tif(vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\nint main(){\n\tcin >> n >> m;\n\tfor(int i=0; i<m; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadj[a-1].push_back(b-1);\n\t\tadj[b-1].push_back(a-1);\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i]){\n\t\t\tg = 1;\n\t\t\tdfs(i);\n\t\t\tans += g;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}\n\t']",,,"['dfs and similar', 'dsu', 'graphs']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Cyclic Components.json,https://codeforces.com//blog/entry/59281,Let s solve this problem for each connected component of the given graph separately It is easy to see that the connected component is a cycle iff the degree of each its vertex equals to So the solution is to count the number of components such that every vertex in the component has degree The connected components of the graph can be easily found by simple dfs or bfs 
https://codeforces.com//contest/1884/problem/E,2278163,E,1884E,1884,E. Hard Design,Consider an array of integers b 0 b 1 ldots b n 1 Your goal is to make all its elements equal To do so you can perform the following operation several possibly zero times Pick a pair of indices 0 le l le r le n 1 then for each l le i le r increase b i by 1 i e replace b i with b i 1 After performing this operation you receive r l 1 2 coins The value f b is defined as a pair of integers cnt cost where cnt is the number of operations required to make all elements of the array equal and cost is the total number of coins you can receive among all possible ways to make all elements equal within cnt operations In other words first you need to minimize the number of operations second you need to maximize the total number of coins you receive You are given an array of integers a 0 a 1 ldots a n 1 Please find the value of f for all cyclic shifts of a Formally for each 0 le i le n 1 you need to do the following Let c j a j i pmod n for each 0 le j le n 1 Find f c Since cost can be very large output it modulo 10 9 7 Please note that under a fixed cnt you need to maximize the total number of coins cost not its remainder modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 65536, stdin), p1 == p2) ? EOF : *p1 ++)\n#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++\n#define putchar(x) (p3 - obuf < 1000000) ? (*p3++ = x) : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x)\nusing namespace std;\nstatic char buf[29999999], *p1 = buf, *p2 = buf, obuf[29999999], *p3 = obuf;\ntemplate <typename item>\ninline void read (register item &x) {\n    x = 0;\n\tregister char c = getchar();\n    while (c < \'0\' || c > \'9\') c = getchar();\n    while (c >= \'0\' && c <= \'9\') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n}\nstatic char cc[15];\ntemplate <typename item>\ninline void print (register item x) {\n\tregister int len = 0;\n\tdo cc[len++] = x % 10 + \'0\', x /= 10; while (x);\n\twhile (len--) putchar(cc[len]);\n}\nint N;ll A[2000006];\nconst ll inf=1e16,mod=1e9+7;\nstruct node{int x,y;ll cnt;}B[4000006];\nint tot;ll d[2000006];\nint stk[2000005],tail;\nvoid add(ll &x,const ll y){\n\tif((x+=y)>=mod)x-=mod;\n}\nbool cmp(node a,node b){\n\treturn a.x<b.x;\n}\nbool cmp1(node a,node b){\n\treturn a.y>b.y;\n}\nstruct BIT{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tv%=mod;\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))add(val[i],v);\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))add(res,val[i]);\n\t\treturn res;\n\t}\n}b0,b2,b3;\nstruct BIT1{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))val[i]+=v;\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))res+=val[i];\n\t\treturn res;\n\t}\n}B1;\nll res1[1000005],res2[1000005],sum[2000005];\nvoid solve(){\n\tread(N);ll mx=0ll;tot=0;\n\tfor(int i=1;i<=N;++i)read(A[i]),mx=max(mx,A[i]),res1[i]=res2[i]=0ll;\n\tif(N==1){print(0);putchar(\' \');print(0);putchar(\'\\n\');return ;}\n\tA[0]=inf;for(int i=N+1;i<=2*N;++i)A[i]=A[i-N];\n\tfor(int i=1;i<2*N;++i){\n\t\tsum[i]=sum[i-1];\n\t\tif(A[i+1]<A[i])sum[i]+=A[i]-A[i+1];\n\t}\n    for(int i=0;i<2*N;++i)d[i]=A[i]-A[i+1];tail=0;\n    for(int i=0;i<2*N;++i){\n    \tif(d[i]<0ll){\n    \t\twhile(d[i]<0ll){\n    \t\t\tif(d[stk[tail]]<-d[i]){\n    \t\t\t\tB[++tot]=node{stk[tail],i,d[stk[tail]]};\n    \t\t\t\td[i]+=d[stk[tail]];d[stk[tail--]]=0ll;\n\t\t\t\t}else {\n\t\t\t\t\tB[++tot]=node{stk[tail],i,-d[i]};\n\t\t\t\t\td[stk[tail]]+=d[i];d[i]=0ll;\n\t\t\t\t\tif(!d[stk[tail]])--tail;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d[i]>0ll)stk[++tail]=i; \n\t}\n\twhile(tail){\n\t\tB[++tot]=node{stk[tail],2*N,d[stk[tail]]};\n\t\td[stk[tail--]]=0ll;\n\t}\n    for(int i=1;i<=N;++i)res1[i]=sum[i+N-2]-sum[i-1]+mx-A[i];\n    b0.init();b2.init();b3.init();B1.init();\n\tsort(B+1,B+tot+1,cmp);int nd=1;\n    for(int i=0;i<=2*N;++i){\n    \twhile(nd<=tot&&B[nd].x<=i){\n    \t\tb0.modify(B[nd].y,1ll*(B[nd].y-B[nd].x)*(B[nd].y-B[nd].x)%mod*(B[nd].cnt%mod)%mod);\n    \t\tB1.modify(B[nd].y,B[nd].cnt);b2.modify(B[nd].y,1ll*B[nd].y*B[nd].cnt%mod);\n    \t\tb3.modify(B[nd].y,1ll*B[nd].y*B[nd].y%mod*B[nd].cnt%mod); ++nd;\n\t\t}\n    \tif(i+1<=N){\n    \t\tres2[i+1]=(res2[i+1]+mod-(b0.query(i+N-1)+mod-b0.query(i))%mod)%mod;\n    \t\tll allcnt=B1.query(i+N-1)-B1.query(i);res2[i+1]=(res2[i+1]+1ll*N*N%mod*((mx-A[i+1]-allcnt)%mod)%mod)%mod;\n\t\t\tallcnt%=mod;res2[i+1]=(res2[i+1]+1ll*i*i%mod*allcnt)%mod;\n\t\t\tll c3=b3.query(i+N-1)-b3.query(i)+mod,c2=b2.query(i+N-1)-b2.query(i)+mod;c3%=mod;c2%=mod;\n\t\t\tres2[i+1]=(res2[i+1]+mod-2ll*i*c2%mod)%mod;\n\t\t\tres2[i+1]=(res2[i+1]+c3)%mod;   \n\t\t} \n\t\tif(i-(N-2)<=N&&i-(N-2)>=1)res2[i-(N-2)]=(res2[i-(N-2)]+b0.query(i)-b0.query(i-(N-2)-1)+mod)%mod;\n\t} nd=1;B1.init();b2.init();b3.init();sort(B+1,B+tot+1,cmp1);\n\tfor(int i=2*N;i>=1;--i){\n\t\twhile(nd<=tot&&B[nd].y>=i){\n\t\t\tif(B[nd].x){\n\t\t\t\tB1.modify(B[nd].x,B[nd].cnt); b2.modify(B[nd].x,1ll*B[nd].x*B[nd].cnt%mod);\n\t\t\t    b3.modify(B[nd].x,1ll*B[nd].x*B[nd].x%mod*B[nd].cnt%mod);\n\t\t\t}\n\t\t\t++nd; \n\t\t}\n\t\tif(i-(N-1)<=N&&i-(N-1)>=1){\n\t\t\tint l=i-(N-1);\n\t\t\tll c1=B1.query(i-1)-B1.query(l-1),c2=b2.query(i-1)-b2.query(l-1)+mod,c3=b3.query(i-1)-b3.query(l-1)+mod;\n\t\t//\tcout<<l<<"" ""<<c1<<endl;\n\t\t\tc2%=mod;c3%=mod;c1%=mod;\n\t\t    res2[l]=(res2[l]+1ll*i*i%mod*c1%mod)%mod;\n\t\t    res2[l]=(res2[l]-2ll*i*c2%mod+mod)%mod;\n\t\t    res2[l]=(res2[l]+c3)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tprint(res1[i]);putchar(\' \');\n\t\tprint(res2[i]);putchar(\'\\n\');\n\t}\n}\nint main(){\n\tint t;read(t);\n\twhile(t--)solve(); \n\tfwrite(obuf, p3 - obuf, 1, stdout);\n    return 0;\n}']",,,"['greedy', 'implementation', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Hard Design.json,https://codeforces.com//blog/entry/121618,Let s learn how to solve a problem for a given array Notice that we want to make all elements equal to the maximum value in the array For convenience let s solve a similar problem that is easier to implement We ll create an array Then instead of performing an addition operation we ll perform a subtraction operation by on a range aiming to make all elements of the array equal to Let be the position of the minimum element in the array We can apply the operation times on the entire array and then recursively solve the problem for the left and right parts relative to the position However this doesn t help us solve the problem for all shifts Let s find the nearest element less than or equal to each element on the left denoted as and the nearest element less than each element on the right denoted as this can be done using linear algorithms Then we can observe that when we consider the subarray in our recursive solution we add to the answer a value equal to We have found a solution to the problem in time for a fixed array If we consider all shifts of the array the nearest elements on the left right either remain unchanged or simply do not exist in which case we consider their values to be Therefore if we fix the position want to determine how much it affects the answer for each position in the array we have three shift ranges for which we can add different values Hence we have ranges on which we need to add certain values Since we don t have to make these additions immediately we can create an array the value that needs to be added to all elements starting from position Then adding the number on the range changes this array as follows The answer to the problem is This subproblem can be solved in time Next we need to learn how to calculate the total cost The approach will be similar but now we need to add a more complex function If both nearest elements are within a shift range we will add a fixed number If there is no nearest element on the left right we will add a value of the form or where is the index of the start of the shift position Both cases can be solved similarly If we expand the brackets we get an expression of the form where are known coefficients Let s represent the answer for a fixed shift in this form and we need to find the value of each coefficient which is simply adding a fixed number on a range as we discussed in the previous paragraph This can also be solved in time 
https://codeforces.com//contest/1051/problem/A,222357,A,1051A,1051,A. Vasya And Password,Vasya came up with a password to register for a string s The password in should be a string consisting of lowercase and uppercase Latin letters and digits But since takes care of the security of its users user passwords must contain at least one digit at least one uppercase Latin letter and at least one lowercase Latin letter For example the passwords and are valid and the passwords and are not A substring of string s is a string x s l s l 1 dots s l len 1 1 le l le s 0 le len le s l 1 len is the length of the substring Note that the empty string is also considered a substring of s it has the length 0 Vasya s password however may come too weak for the security settings of He likes his password so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions This operation should be performed once and ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint T;\nstring S,A=""aA1"";\nint N;\n\nbool ok(string S) {\n\tint mask=0;\n\tFORR(c,S) {\n\t\tif(c>=\'0\' && c<=\'9\') mask |= 1;\n\t\tif(c>=\'a\' && c<=\'z\') mask |= 2;\n\t\tif(c>=\'A\' && c<=\'Z\') mask |= 4;\n\t}\n\treturn mask==7;\n}\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>S;\n\t\tN=S.size();\n\t\t\n\t\tif(ok(S)) {\n\t\t\tcout<<S<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(i,N) {\n\t\t\tstring T=S;\n\t\t\tFOR(j,3) {\n\t\t\t\tT[i]=A[j];\n\t\t\t\tif(ok(T)) {\n\t\t\t\t\tcout<<T<<endl;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(i,N-1) {\n\t\t\tstring T=S;\n\t\t\tFOR(x,3) {\n\t\t\t\tFOR(y,3) {\n\t\t\t\t\tT[i]=A[x];\n\t\t\t\t\tT[i+1]=A[y];\n\t\t\t\t\tif(ok(T)) {\n\t\t\t\t\t\tcout<<T<<endl;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout:\n\t\t;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']",,,"['greedy', 'implementation', 'strings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Vasya And Password.json,https://codeforces.com//blog/entry/61969,There are just a few general cases in the task to consider If the password is already valid nothing has to be changed just print Try to change exactly one character iterate over all positions in and all three options for character any digit any lowercase or uppercase Latin letter After the replacement the string is checked for the validity and printed if it turned out to be valid We weren t able to replace a substring of length 0 or 1 then the answer is at least 2 We can obtain it in a following manner replace the first two characters to if the third character is an uppercase Latin letter to if the third character is a lowercase Latin letter and to if the third character is a digit 
https://codeforces.com//contest/1511/problem/C,955214,C,1511C,1511,C. Yet Another Card Deck,You have a card deck of n cards numbered from top to bottom i e the top card has index 1 and bottom card index n Each card has its color the i th card has color a i You should process q queries The j th query is described by integer t j For each query you should find the highest card in the deck with color t j i e the card with minimum index print the position of the card you found take the card and place it on top of the deck ,"['#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int q = scan();\n  vector pos(50, n);\n  for (int i : Rep(n)) chmin(pos[scan() - 1], i);\n  while (q--) {\n    int t = scan() - 1;\n    cout << pos[t] + 1 << "" \\n""[q == 0];\n    for (auto&& e : pos) e += e < pos[t];\n    pos[t] = 0;\n  }\n}\n']",,,"['brute force', 'data structures', 'implementation', 'trees']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Yet Another Card Deck.json,https://codeforces.com//blog/entry/89634,Let s look at one fixed color When we search a card of such color we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index It means that for each color we take and move the same card one card for each color In other words we need to keep track of only cards where is the number of colors As a result if is the position of a card of color then we can simulate a query in the following way for each color such that we increase by one since the card will move down and then set Complexity is But if we look closely we may note that we don t even need array We can almost manually find the first card of color and move it to the first position either by series of swaps or for example using function present in C and it will work fast Why Let s look at one color For the first time it will cost operations to search the corresponding card and move it to the position But after that at any moment of time the position of the card won t exceed since all cards before are pairwise different due to the nature of queries So all next moves the color costs only time As a result the complexity of such almost naive solution is 
https://codeforces.com//contest/1731/problem/E,1711455,E,1731E,1731,E. Graph Cost,You are given an initially empty undirected graph with n nodes numbered from 1 to n i e n nodes and 0 edges You want to add m edges to the graph so the graph won t contain any self loop or multiple edges If an edge connecting two nodes u and v is added its weight must be equal to the greatest common divisor of u and v i e gcd u v In order to add edges to the graph you can repeat the following process any number of times possibly zero choose an integer k ge 1 add exactly k edges to the graph each having a weight equal to k 1 Adding these k edges costs k 1 in total Note that you can t create self loops or multiple edges Also if you can t add k edges of weight k 1 you can t choose such k For example if you can add 5 more edges to the graph of weight 6 you may add them and it will cost 6 for the whole pack of 5 edges But if you can only add 4 edges of weight 6 to the graph you can t perform this operation for k 5 Given two integers n and m find the minimum total cost to form a graph of n vertices and exactly m edges using the operation above If such a graph can t be constructed output 1 Note that the final graph may consist of several connected components ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nnamespace Prime\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll M=(ll)(N-1)*(N-1);\n\tui pr[N],mn[N],phi[N],cnt;\n\tint mu[N];\n\tvoid init_prime()\n\t{\n\t\tui i,j,k;\n\t\tphi[1]=mu[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tif (!mn[i])\n\t\t\t{\n\t\t\t\tpr[cnt++]=i;\n\t\t\t\tphi[i]=i-1; mu[i]=-1;\n\t\t\t\tmn[i]=i;\n\t\t\t}\n\t\t\tfor (j=0; (k=i*pr[j])<N; j++)\n\t\t\t{\n\t\t\t\tmn[k]=pr[j];\n\t\t\t\tif (i%pr[j]==0)\n\t\t\t\t{\n\t\t\t\t\tphi[k]=phi[i]*pr[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tphi[k]=phi[i]*(pr[j]-1);\n\t\t\t\tmu[k]=-mu[i];\n\t\t\t}\n\t\t}\n\t\t//for (i=2;i<N;i++) if (mu[i]<0) mu[i]+=p;\n\t}\n\ttemplate<typename T> T getphi(T x)\n\t{\n\t\tassert(M>=x);\n\t\tT r=x;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\tif (x>=N) return r/x*(x-1);\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<typename T> vector<pair<T,ui>> getw(T x)\n\t{\n\t\tassert(M>=x);\n\t\tvector<pair<T,ui>> r;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\tif (x>=N)\n\t\t{\n\t\t\tr.push_back({x,1});\n\t\t\treturn r;\n\t\t}\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\treturn r;\n\t}\n}\nusing Prime::pr,Prime::phi,Prime::getw;\nusing Prime::mu,Prime::init_prime;\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tinit_prime();\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j;\n\t\tll m;\n\t\tcin>>n>>m;\n\t\tvector<ll> cnt(n+1);\n\t\tfor (i=1; i<=n; i++) cnt[i]=(ll)(n/i)*(n/i);\n\t\tfor (i=1; i<=n; i++) for (j=2; j*i<=n; j++) cnt[i]+=cnt[j*i]*mu[j];\n\t\tfor (i=2; i<=n; i++) cnt[i]=(cnt[i]-1>>1)/(i-1);\n\t\tll res=0;\n\t\t// dbg(cnt);\n\t\tfor (i=n; i>=2; i--)\n\t\t{\n\t\t\tll d=min(cnt[i],m/(i-1));\n\t\t\tm-=d*(i-1);\n\t\t\tres+=d*i;\n\t\t\t// dbg(m,res,i);\n\t\t}\n\t\tif (m) cout<<""-1\\n"";\n\t\telse cout<<res<<\'\\n\';\n\t}\n}\n']",,,"['dp', 'greedy', 'math', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Graph Cost.json,https://codeforces.com//blog/entry/110630,In each step adding edges to the graph with weights costs one more than the number of edges added So the total cost of adding edges in steps will be Since the number of edges is given i e fixed to find the minimum cost we need to minimize the number of steps Firstly let s calculate the number of pairs where with for each in time It can be solved in a standard way using the M bius function or using Dynamic Programming where is the required number that can be calculated as Knowing all we can calculate the maximum number of steps we can perform using edges of weight And Note that array is non increasing and if we have at least one pack of size then we have at least one pack of each size where So our task is an extension of the task where you need to take a subset of of minimum size with sum equal to and can be solved with the same greedy strategy Let s just take packs greedily starting from weight down to weight We ll take packs as many packs as possible For a fixed weight we can calculate the maximum number of packs we can take as If edges can t be constructed then we return Otherwise we return where is the total number of packs Time Complexity 
https://codeforces.com//contest/263/problem/B,2517,B,263B,263,B. Squares,Vasya has found a piece of paper with a coordinate system written on it There are distinct squares drawn in this coordinate system Let s number the squares with integers from 1 to It turned out that points with coordinates and are the opposite corners of the th square Vasya wants to find such integer point with integer coordinates of the plane that belongs to exactly drawn squares We ll say that a point belongs to a square if the point is located either inside the square or on its boundary Help Vasya find a point that would meet the described limits ,"['#include <cstdio>\n#include <algorithm>\n\nint aa[100], n, k;\n\nint main() {\n    scanf(""%d%d"", &n, &k);\n    for(int i=0; i<n; i++) scanf(""%d"", aa+i);\n    std::sort(aa, aa+n);\n    aa[n] = aa[n-1]+1;\n    int i;\n    for(i=0; i<n; i++) {\n        if(aa[i] == aa[i+1]) continue;\n        if(i == n-k) {\n            printf(""%d %d\\n"", aa[i], aa[i]);\n            break;\n        }\n    }\n    if(i == n) puts(""-1"");\n    return 0;\n}\n']",,,"['greedy', 'implementation', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Squares.json,https://codeforces.com//blog/entry/6419,If then the answer doesn t exist Otherwise let s sort the squares by descending of their sizes Now you can print any point that belongs to the th square and doesn t belong to the th square One of the possible answers is 
https://codeforces.com//contest/1943/problem/E1,2535044,E1,1943E1,1943,E1. MEX Game 2  Easy Version ,Alice and Bob play yet another game on an array a of size n Alice starts with an empty array c Both players take turns playing with Alice starting first On Alice s turn she picks one element from a appends that element to c and then deletes it from a On Bob s turn he picks at most k elements from a and then deletes it from a The game ends when the array a is empty Alice s score is defined to be the MEX dagger of c Alice wants to maximize her score while Bob wants to minimize it Find Alice s final score if both players play optimally The array will be given in compressed format Instead of giving the elements present in the array we will be giving their frequencies Formally you will be given m the maximum element in the array and then m 1 integers f 0 f 1 ldots f m where f i represents the number of times i occurs in the array a dagger The operatorname MEX minimum excludant of an array of integers is defined as the smallest non negative integer which does not occur in the array For example The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"['/**\n *    author:  tourist\n *    created: 16.03.2024 11:13:36\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int m, k;\n    cin >> m >> k;\n    vector<int> f(m + 1);\n    for (int i = 0; i <= m; i++) {\n      cin >> f[i];\n    }\n    int low = 0, high = m + 1;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      bool win = true;\n      for (int pref = 1; pref <= mid; pref++) {\n        vector<int> a(f.begin(), f.begin() + mid);\n        sort(a.begin(), a.end());\n        a.resize(pref);\n        int els = pref;\n        for (int i = 0; i < pref - 1; i++) {\n          if (a[i + 1] <= k) {\n            win = false;\n            break;\n          }\n          els -= 1;\n          int steps = k;\n          int suf = 1;\n          while (steps > 0) {\n            while (suf < els && a[pref - suf] == a[pref - (suf + 1)]) {\n              suf += 1;\n            }\n            int diff = a[pref - suf] - (suf == els ? 0 : a[pref - (suf + 1)]);\n            if (steps / suf >= diff) {\n              steps -= suf * diff;\n              for (int j = 0; j < suf; j++) {\n                a[pref - 1 - j] -= diff;\n              }\n            } else {\n              int all = steps / suf;\n              for (int j = 0; j < suf; j++) {\n                a[pref - 1 - j] -= all;\n              }\n              steps -= all * suf;\n              assert(0 <= steps && steps < suf);\n              for (int j = 0; j < steps; j++) {\n                a[pref - suf + j] -= 1;\n              }\n              steps = 0;\n              break;\n            }\n          }\n        }\n      }\n      if (win) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['binary search', 'brute force', 'greedy']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E1. MEX Game 2  Easy Version .json,https://codeforces.com//blog/entry/127195,SolutionFor now lets try to see if This is equivalent to Alice being able to take occurence of everything when the game is reduced to numbers Alice s strategy here is actually easy to find At every step Alice will choose the minimum such that and she hasn t chosen yet You can reason this with greedy stays ahead exchange argument whatever you want This gives us a nice definition of Alice s moves however we seemingly have to maintain the sorted sequence of always But we can actually rewrite Bob s moves such that it does not affect the sorted order of and always keeps it sorted Here by sorted order we mean some permutation of such that whenever First instead of subtracting we will do subtractions of only Then the only case when sorted order can be destroyed is when there exists and such that and we do an operation on but occurs before in the sorted order This issue can simply be fixed by doing the operation on the smallest according to sorted order such that Now we have a good way of representing Alice moves Suppose we fixed the element that Bob wins on Then Bob s strategy will obviously be to make the frequency of that element as small as possible but he must make sure to never violate sorted condition Since Bob will make at most moves you can just simulate his moves The main details of the simulation is that you need to figure out upto what index all values will become equal when doing k operations or nearly equal off by 1 and then first take all elements to that state Let be the remaining operations from the operations after this and the length of the equal sequence Then you will reduce every frequency by and finally reduce the first mod numbers of this sequence Check the code for more details A naive implementation takes per move so per element we fix total to check With a binary search on the answer you get It can be optimized further but it wasnt needed to pass Most other polynomial solutions should pass this 
https://codeforces.com//contest/798/problem/A,103599,A,798A,798,A. Mike and palindrome,Mike has a string consisting of only lowercase English letters He wants to character from the string so that the resulting one is a palindrome A palindrome is a string that reads the same backward as forward for example strings are palindromes but strings are not ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pr;\nconst double pi=acos(-1);\n#define rep(i,a,n) for(int i=a;i<=n;i++)\n#define per(i,n,a) for(int i=n;i>=a;i--)\n#define Rep(i,u) for(int i=head[u];i;i=Next[i])\n#define clr(a) memset(a,0,sizeof a)\n#define pb push_back\n#define mp make_pair\n#define putk() putchar(\' \')\nld eps=1e-9;\nll pp=1000000007;\nll mo(ll a,ll pp){if(a>=0 && a<pp)return a;a%=pp;if(a<0)a+=pp;return a;}\nll powmod(ll a,ll b,ll pp){ll ans=1;for(;b;b>>=1,a=mo(a*a,pp))if(b&1)ans=mo(ans*a,pp);return ans;}\nll gcd(ll a,ll b){return (!b)?a:gcd(b,a%b);}\nll read(){\n\tll ans=0;\n\tchar last=\' \',ch=getchar();\n\twhile(ch<\'0\' || ch>\'9\')last=ch,ch=getchar();\n\twhile(ch>=\'0\' && ch<=\'9\')ans=ans*10+ch-\'0\',ch=getchar();\n\tif(last==\'-\')ans=-ans;\n\treturn ans;\n}\nvoid put(ll a){\n\tif(a<0)putchar(\'-\'),a=-a;\n\tint top=0,q[20];\n\twhile(a)q[++top]=a%10,a/=10;\n\ttop=max(top,1);\n\twhile(top--)putchar(\'0\'+q[top+1]);\n}\n//head\nchar str[1100000];\nint n;\nint main(){\n//\tfreopen(""1.in"",""r"",stdin);\n\tscanf(""%s"",str+1);\n\tn=strlen(str+1);\n\tint ans=0;\n\trep(i,1,n/2)\n\t\tif(str[i]!=str[n+1-i])++ans;\n\tif(ans==1 || (ans==0 && n%2==1))puts(""YES"");\n\telse puts(""NO"");\n\treturn 0;\n}']",,,"['brute force', 'constructive algorithms', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Mike and palindrome.json,https://codeforces.com//blog/entry/51652,Let be the number of such that If then the answer is NO since we must change more than 1 character If then the answer is YES If and is odd answer is YES since we can change the character in the middle otherwise if is even the answer is NO because we must change at least one character Complexity is Solution Link First of all you must notice that the operation of removing the first character and appending it to the left is equivalent to cyclically shifting the string one position to the left Let s denote by the smallest number of operations for making the first strings equal to string moved times Let be the the string moved times then The answer is The complexity is Solution Link First of all the answer is always YES If then the answer is Now suppose that the gcd of the sequence is After we perform one operation on and the new gcd must satisfy and and Similarly because is the gcd of the new sequence it must satisfy Using the above observations we can conclude that so the gcd of the sequence can become at most times bigger after an operation This means that in order to make the gcd of the sequence bigger than we need to make all numbers even Now the problem is reduced to the following problem Given a sequence of zero or one in one move we can change numbers with numbers equal to Find the minimal number of moves to make the whole sequence equal to It can be proved that it is optimal to solve the task for consecutive ones independently so we divide the array into the minimal number of subarrays full of ones if their lengths are the answer is Complexity is Solution Link In the beginning it s quite easy to notice that the condition is greater than the sum of all elements in is equivalent to is greater than the sum of the remaining elements in Now let s store an array of indices with and then sort it in decreasing order according to array that is we must have Our answer will always have size First suppose that is odd Add the first index to our set that is make Now for the remaining elements we will consider them consecutively in pairs Suppose we are at the moment inspecting and If we make else we make Why does this subset work Well it satisfies the condition for because each time for consecutive non intersecting pairs of elements we select the bigger one and we also add to the set so in the end the sum of the selected elements will be bigger than the sum of the remaining ones It also satisfies the condition for because is equal or greater than the complement element of that is the index which we could ve selected instead of from the above procedure if we selected then it would be and vice versa Similarly is greater than the complement of and so on In the end we also add the last element from the last pair and this makes the sum of the chosen subset strictly bigger than the sum of the remaining elements The case when is even can be done exactly the same as when is odd we just pick the last remaining index in the end The complexity is Solution Link Let s consider instead of Let s also define the sequence where such that or if there is no such Lets make a directed graph with vertices be the indices of the permutation with edges of type representing that If we topologically sort this graph then we can come up with a possible permutation if is the topologically sorted graph then we can assign to number In this problem we will use this implementation of topological sort But how we can find the edges First of all there are edges of the form if For a vertex he visited all the unmarked vertices and you know for sure that for all these But how we can check if was already marked The vertex will become marked after turn of vertex or will never become unmarked if So there is a direct edge from to if or and Suppose we already visited a set of vertices and for every visited vertex we assigned to value for simplicity just to forget about all visited vertices and now we want to find quickly for a fixed vertex an unvisited vertex with condition that there is edge or say it there isn t such if we can do that in subquadratic time then the task is solved As stated above the first condition is if this condition is easy to check The second condition is and now consider vertices with indices from interval and take with maximal If we found edge otherwise there are no remaining edges We can find such vertex using segment tree and updating values while we visit a new vertex In total we will visit vertices and query the segment tree at most times for every new vertex and for finding that there aren t remaining edges Complexity and memory are and Solution Link 
https://codeforces.com//contest/732/problem/F,76076,F,732F,732,F. Tourist Reform,Berland is a tourist country At least it can become such the government of Berland is confident about this There are cities in Berland some pairs of which are connected by two ways roads Each road connects two different cities In Berland there are no roads which connect the same pair of cities It is possible to get from any city to any other city using given two ways roads According to the reform each road will become one way It will be oriented to one of two directions To maximize the tourist attraction of Berland after the reform for each city the value will be calculated It will equal to the number of cities for which there is an oriented path from the city to the city In other words will equal the number of cities which can be reached from the city by roads The government is sure that tourist s attention will be focused on the minimum value of Help the government of Berland make the reform to maximize the minimum of ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 404040;\nint n , m , u[N] , v[N];\nvector<pii> g[N];\npii ans[N];\n\nnamespace BCC{\n    vi key;\n    vector<pii> bcc[N];\n    int dfn[N] , low[N] , id[N] , st[N] , _st , _;\n    void dfs(int c,int dep,vector<pii> g[]){\n        int cc=0;st[_st++]=c;\n        dfn[c]=low[c]=dep;\n        //cout << c << "" "" << dep << endl;\n        for(auto e:g[c]){\n            int t=e.fi;\n            if(!dfn[t]){\n                ans[e.se] = mp(c,t);\n                dfs(t,dep+1,g);\n                low[c]=min(low[c],low[t]);\n                if(low[t]>dfn[c]) key.pb(e.se);\n            } else if(dfn[t] != dfn[c] - 1 || cc++){\n                low[c] = min(low[c] , dfn[t]);\n                if(dfn[t] < dfn[c]) ans[e.se] = mp(c , t);\n            }\n        }\n        if(low[c]==dfn[c]){\n            do{id[st[--_st]]=_;}while(st[_st]!=c);\n            _++;\n        }\n    }\n    int sz[N];\n    void dfs(int c,int fa){\n        for(auto t : bcc[c]) if(t.fi != fa){\n            int a = u[t.se] , b = v[t.se];\n            if(id[a] == c) swap(a , b);\n            ans[t.se] = mp(a , b);\n            //ans[t.se] = mp(0 , 0);\n            dfs(t.fi , c);\n        }\n    }\n    int solve(int n,vector<pii> g[]){\n        rep(i,0,n) if(!dfn[i]) dfs(i,1,g);\n        rep(i,0,n) sz[id[i]]++;\n        rep(i,0,n) for(auto j:g[i]) if(id[i]!=id[j.fi])\n            bcc[id[i]].pb(mp(id[j.fi],j.se));\n        int id = -1 , Max = -1;\n        rep(i,0,_) if(sz[i] > Max) Max = sz[i] , id = i;\n        dfs(id , -1);\n        printf(""%d\\n"",Max);\n        rep(i,0,m) printf(""%d %d\\n"",ans[i].fi + 1,ans[i].se + 1);\n        return _;\n    }\n};\n\nint main(){\n    scanf(""%d%d"",&n,&m);\n    rep(i,0,m){\n        scanf(""%d%d"",u + i , v + i);\n        --u[i];--v[i];\n        g[u[i]].pb(mp(v[i] , i));\n        g[v[i]].pb(mp(u[i] , i));\n    }\n    BCC::solve(n,g);\n    return 0;\n}\n']",,,"['dfs and similar', 'graphs']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Tourist Reform.json,https://codeforces.com//blog/entry/47890,Firstly we have to find all the bridges and divide the graph into 2 edge connected components Then we calculate the size of each component It can be easily proved that the answer is equal to size of the largest component Then we need to orient the edges somehow Start DFS from any vertex of the largest component If we traverse the edge coming from vertex and it has not been oriented yet we orient it from to if it s a bridge so it leads to the largest component or from to otherwise When all vertices are visited and all edges are oriented we can print the answer Time complexity 
https://codeforces.com//contest/997/problem/C,194452,C,997C,997,C. Sky Full of Stars,On one of the planets of Solar system in Atmosphere University many students are fans of bingo game It is well known that one month on this planet consists of n 2 days so calendars represented as square matrix n by n are extremely popular Weather conditions are even more unusual Due to the unique composition of the atmosphere when interacting with sunlight every day sky takes one of three colors blue green or red To play the bingo you need to observe the sky for one month after each day its cell is painted with the color of the sky in that day that is blue green or red At the end of the month students examine the calendar If at least one row or column contains only cells of one color that month is called lucky Let s call two colorings of calendar different if at least one cell has different colors in them It is easy to see that there are 3 n cdot n different colorings How much of them are lucky Since this number can be quite large print it modulo 998244353 ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 2333333\nll fac[SZ],rfac[SZ];\nconst int MOD=998244353;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nll C(int a,int b)\n{\n\tif(b>a||b<0) return 0;\n\treturn fac[a]*rfac[a-b]%MOD*rfac[b]%MOD;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i) fac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i;--i) rfac[i-1]=rfac[i]*i%MOD;\n\tint n;\n\tcin>>n;\n\tll ans=qp(qp(3,n)-3,n);\n\tfor(int i=1;i<=n;++i)\n\t\tif(i&1)\n\t\t{\n\t\tans-=C(n,i)*qp(qp(3,n-i)-1,n)*3;ans%=MOD;\n\t\tans-=C(n,i)*(qp(3,i)-3)%MOD*\n\t\tqp(qp(3,n-i),n);ans%=MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\tans+=C(n,i)*qp(qp(3,n-i)-1,n)*3;ans%=MOD;\n\t\tans+=C(n,i)*(qp(3,i)-3)%MOD*\n\t\tqp(qp(3,n-i),n);ans%=MOD;\n\t\t}\n\tans=qp(3,(ll)n*n)-ans;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<""\\n"";\n}\n']",,,"['combinatorics', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Sky Full of Stars.json,https://codeforces.com/blog/entry/60357,Let be the set of all colorings where th line contains only one color and be the set of colorings where th column contains only one color This way you need to calculate As usual we can use inclusion exclusion formula to reduce the calculation of multiplications to calculation all possible intersections of sets above More over due to the obvious symmetry to calculate the size of intersection of some set of and it is not important to know exact indices only number of taken s and number of s This way Where is the number of colorings where first rows and first columns are onecolored It turns out that formula for differs significantly depending on presence of zero in it s arguments Let s examine the case where zero is present the Indeed you should choose one color in each of the first columns and the rest should be painted in any way If both arguments are that is there is at least one one colored column and at least one colored row than we can notice that all one colored rows and columns are in fact of one color This way Since we should first select the globally common color and then paint all the rest in any way Summation of all s gives solution with or complexity depending on implementation But we need to go faster Let s sum all summands with or in a stupid way in Then examine all other summands We have a formula Let s replace our variables Since we haveNote that Using this we can collect all summands for fixed however with fixed we have not summands but We can workaround it by adding and removing the missing summand Let s go This formula has only summands nd hence can be evaluated fast enough To calculate powers of number fast we can use binary pow method 
https://codeforces.com//contest/1438/problem/A,793472,A,1438A,1438,A. Specific Tastes of Andre ,Andre has very specific tastes Recently he started falling in love with arrays Andre calls an nonempty array b if sum of its elements is divisible by the length of this array For example array 2 3 1 is good as sum of its elements 6 is divisible by 3 but array 1 1 2 3 isn t good as 7 isn t divisible by 4 Andre calls an array a of length n if the following conditions hold Every nonempty subarray of this array is For every i 1 le i le n 1 leq a i leq 100 Given a positive integer n output any array of length n We can show that for the given constraints such an array always exists An array c is a subarray of an array d if c can be obtained from d by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n;\n        cin >> n;\n\n        for(int i = 0; i < n; ++i)\n            cout << 1 << "" "";\n        cout << ""\\n"";\n    }\n}']",,,"['constructive algorithms', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Specific Tastes of Andre .json,https://codeforces.com//blog/entry/84589,The array is perfect since the sum of every subarray is exactly equal to its length and thus divisible by it 
https://codeforces.com//contest/514/problem/E,22327,E,514E,514,E. Darth Vader and Tree,When Darth Vader gets bored he sits down on the sofa closes his eyes and thinks of an infinite rooted tree where each node has exactly sons at that for each node the distance between it an its th left child equals to The Sith Lord loves counting the number of nodes in the tree that are at a distance at most from the root The distance is the sum of the lengths of edges on the path between nodes But he has got used to this activity and even grew bored of it Why does he do that then you may ask It s just that he feels superior knowing that only he can solve this problem Do you want to challenge Darth Vader himself Count the required number of nodes As the answer can be rather large find it modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef vector<ll> VL;\ntypedef vector<VL> matrix;\nmatrix mul(const matrix &a,const matrix &b) {\n\tint n=SZ(a);\n\tmatrix c(n,VL(n,0));\n\trep(i,0,n) rep(j,0,n) rep(k,0,n) c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod;\n\treturn c;\n}\nvoid multo(matrix &a,const matrix &b) {\n\tint n=SZ(a);\n\tmatrix c(n,VL(n,0));\n\trep(i,0,n) rep(j,0,n) rep(k,0,n) c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod;\n\trep(i,0,n) rep(j,0,n) a[i][j]=c[i][j];\n}\nmatrix add(const matrix &a,const matrix &b) {\n\tint n=SZ(a);\n\tmatrix c(n,VL(n,0));\n\trep(i,0,n) rep(j,0,n) {\n\t\tc[i][j]=a[i][j]+b[i][j];\n\t\tif (c[i][j]>=mod) c[i][j]-=mod;\n\t}\n\treturn c;\n}\nvoid addto(matrix &a,const matrix &b) {\n\tint n=SZ(a);\n\trep(i,0,n) rep(j,0,n) { a[i][j]+=b[i][j]; if (a[i][j]>=mod) a[i][j]-=mod;}\n}\nmatrix unit(int n,int w=1) {\n\tmatrix c(n,VL(n,0));\n\trep(i,0,n) c[i][i]=w;\n\treturn c; \n}\nmatrix powmod(matrix a,ll b) {\n\tint n=SZ(a);\n\tmatrix res=unit(n);\n\tfor (;b;b>>=1) { if(b&1) multo(res,a);multo(a,a);}\n\treturn res;\n}\nmatrix powsmod(matrix a,ll b) {\n\tint n=SZ(a);\n\tmatrix res=unit(n),_a=a;\n\tint k=0;for (;b>>k;k++);--k;\n\twhile(--k>=0) {\n\t\taddto(a,unit(n));multo(res,a);\n\t\taddto(a,unit(n,-1));multo(a,a);\n\t\tif ((b>>k)&1) multo(res,_a),addto(res,unit(n)),multo(a,_a);\n\t}\n\treturn res;\n}\nvoid print(const matrix &a) {\n\tint n=SZ(a);\n\trep(i,0,n) {rep(j,0,n) cout<<a[i][j]<<"" "";puts("""");}\n\tputs("""");\n}\n\nint n,x,p,cnt[110];\nint main() {\n\tscanf(""%d%d"",&n,&x);\n\trep(i,0,n) {\n\t\tscanf(""%d"",&p);\n\t\tcnt[p]++;\n\t}\n\tmatrix base=unit(102,0);\n\tbase[101][101]=1;\n\trep(i,0,100) base[i][i+1]=1;\n\trep(i,1,100+1) base[i-1][0]=cnt[i];\n\tbase[101][0]=1;\n\tbase=powmod(base,x+1);\n\tprintf(""%I64d\\n"",base[101][0]);\n}\n']",,,"['dp', 'matrices']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Darth Vader and Tree.json,https://codeforces.com//blog/entry/16398,It s easy to realize that where dp i is number of vertices which are situated on a distance i from the root and cnt j is number of children which are situated on a distance j Answer Let the dynamics condition Let s build a transformation matrix of 101 101 size Now to move to the next condition we need to multiply A by B So if matrix C A Bx 100 then the answer will be situated in the very right cell of this matrix For x 100 we ll find the answer using dynamics explained in the beginning 
https://codeforces.com//contest/1299/problem/C,536065,C,1299C,1299,C. Water Balance,There are n water tanks in a row i th of them contains a i liters of water The tanks are numbered from 1 to n from left to right You can perform the following operation choose some subsegment l r 1 le l le r le n and redistribute water in tanks l l 1 dots r evenly In other words replace each of a l a l 1 dots a r by frac a l a l 1 dots a r r l 1 For example if for volumes 1 3 6 7 you choose l 2 r 3 new volumes of water will be 1 4 5 4 5 7 What is the lexicographically smallest sequence of volumes of water that you can achieve As a reminder A sequence a is lexicographically smaller than a sequence b of the same length if and only if the following holds in the first leftmost position where a and b differ the sequence a has a smaller element than the corresponding element in b ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010000;\nint n,a[N],t;\nPII st[N];\nll s[N];\ndb sval[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",a+i);\n\t\ts[i]=s[i-1]+a[i];\n\t}\n\trep(i,1,n+1) {\n\t\tdb val=a[i];\n\t\tPII pr=mp(i,i);\n\t\twhile (t>0&&sval[t-1]>val) {\n\t\t\t--t;\n\t\t\tval=1.*(s[i]-s[st[t].fi-1])/(i-st[t].fi+1);\n\t\t\tpr=mp(st[t].fi,i);\n\t\t}\n\t\tsval[t]=val;\n\t\tst[t]=pr;\n\t\tt++;\n\t}\n\trep(i,0,t) rep(j,st[i].fi,st[i].se+1) printf(""%.10f\\n"",sval[i]);\n}\n']",,,"['data structures', 'geometry', 'greedy']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Water Balance.json,https://codeforces.com//blog/entry/73763,Let s try to make the operation simpler When we apply the operation only the sum of the segment matters And so let s instead define the operation on prefix sum array Replace each of by You may see how similar it is to a line function Hence we get the idea to plot points included and our operation is just drawing a line between points on integer coordinates Nicely if sequence is lexicographically smaller than sequence then prefix sum array of is smaller than prefix sum array of So we need to find the lexicographically smallest array And then it is easy to see the lexicographically smallest sequence will be the lower part of the convex hull If you re interested you can solve IMO 2018 SL A4 by plotting similar points I have written my solutionhere 
https://codeforces.com//contest/1010/problem/B,201803,B,1010B,1010,B. Rocket,Natasha is going to fly to Mars Finally Natasha sat in the rocket She flies flies but gets bored She wishes to arrive to Mars already So she decides to find something to occupy herself She couldn t think of anything better to do than to calculate the distance to the red planet Let s define x as the distance to Mars Unfortunately Natasha does not know x But it is known that 1 le x le m where Natasha knows the number m Besides x and m are positive integers Natasha can ask the rocket questions Every question is an integer y 1 le y le m The correct answer to the question is 1 if x y 0 if x y and 1 if x y But the rocket is broken it does not always answer correctly Precisely let the correct answer to the current question be equal to t then if the rocket answers this question correctly then it will answer t otherwise it will answer t In addition the rocket has a sequence p of length n Each element of the sequence is either 0 or 1 The rocket processes this sequence in the cyclic order that is 1 st element 2 nd 3 rd ldots n 1 th n th 1 st 2 nd 3 rd ldots n 1 th n th ldots If the current element is 1 the rocket answers correctly if 0 lies Natasha doesn t know the sequence p but she knows its length n You can ask the rocket no more than 60 questions Help Natasha find the distance to Mars Assume that the distance to Mars does not change while Natasha is asking questions Your solution will not be accepted if it does not receive an answer 0 from the rocket even if the distance to Mars is uniquely determined by the already received rocket s answers ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  //freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin » t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nvoid solve(bool read) {\n  int m, n;\n  cin >> m >> n;\n  vector<bool> correct(n, false);\n  for (int i = 0; i < n; ++i) {\n    cout << 1 << endl;\n    int ans;\n    cin >> ans;\n    if (ans == 0) {\n      return;\n    }\n    correct[i] = (ans == 1);\n  }\n  int L = 1, R = m + 1;\n  int cnt = 0;\n  while (L < R) {\n    int M = (L + R) / 2;\n    cout << M << endl;\n    int ans;\n    cin >> ans;\n    if (!correct[cnt]) {\n      ans = -ans;\n    }\n    cnt = (cnt + 1) % n;\n    if (ans == 0) {\n      return;\n    }\n    if (ans == 1) {\n      L = M;\n    } else {\n      R = M;\n    }\n  }\n}\n\n']",,,"['binary search', 'interactive']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Rocket.json,https://codeforces.com/blog/entry/60851,First we learn the sequence For this print the query 1 times If the answer is 0 that is the distance to Mars is equal to one then immediately terminate the program Otherwise it is clear that the correct answer is 1 that is the distance to Mars is greater than one If th answer of rocket is 1 then that is the rocket answered the truth otherwise untruth On this we will spend no more than queries within the given constraints it is Now you can find the number using binary search For each answer you need to check if the corresponding element of the sequence equals to then the answer sign must be changed On this we will spend no more than queries within the given constraints it is The total number of queries does not exceed Complexity Bonus Try to solve a similar problem but with a constraint 
https://codeforces.com//contest/1200/problem/E,387085,E,1200E,1200,E. Compress Words,Amugae has a sentence consisting of n words He want to compress this sentence into one word Amugae doesn t like repetitions so when he merges two words into one word he removes the longest prefix of the second word that coincides with a suffix of the first word For example he merges and into Amugae will merge his sentence left to right i e first merge the first two words then merge the result with the third word and so on Write a program that prints the compressed word after the merging process ends ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mxN=1e5;\nint n;\nstring ans;\n\nint kmp(string s) {\n\tvector<int> pf(s.size());\n\tfor(int j=1; j<s.size(); ++j) {\n\t\tint k=pf[j-1];\n\t\twhile(s[k]!=s[j]) {\n\t\t\tif(!k) {\n\t\t\t\tk=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk=pf[k-1];\n\t\t}\n\t\tpf[j]=k+1;\n\t}\n\treturn pf.back();\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; ++i) {\n\t\tif(!i) {\n\t\t\tcin >> ans;\n\t\t\tcontinue;\n\t\t}\n\t\tstring s;\n\t\tcin >> s;\n\t\tstring t=s;\n\t\tt+='#';\n\t\tint a=min((int)ans.size(), (int)s.size());\n\t\tt.insert(t.end(), ans.end()-a, ans.end());\n\t\tint x=kmp(t);\n\t\twhile(x--)\n\t\t\tans.pop_back();\n\t\tans.insert(ans.end(), s.begin(), s.end());\n\t}\n\tcout << ans;\n}""]",,,"['brute force', 'hashing', 'implementation', 'string suffix structures', 'strings']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Compress Words.json,https://codeforces.com/blog/entry/69035,Denote the words from left to right as If we define string as the result of merging as described in the problem times we can get by the following process If length of length of Assume the length of is and the length of is Construct the string for string is the substring from index to Get the KMP failure function from string We can get maximum overlapped length of s prefix and s suffix from this function Suppose the last element of the failure function smaller than the length of is Then the longest overlapped length of s suffix and s prefix is Let Then Otherwise Construct as We can get from the same process described in 1 In this process we can get from in time complexity So we can get the answer of this problem in 
https://codeforces.com//contest/956/problem/F,168084,F,956F,956,F. Minimal Subset Difference,We call a positive integer a beautiful integer if and only if it is possible to split the multiset of its digits in the decimal representation into two subsets such that the difference between the sum of digits in one subset and the sum of digits in the other subset is Each digit should belong to exactly one subset after the split There are queries for you Each query is described with three integers and which mean that you are asked how many integers between and inclusive are beautiful ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int DEBUG = 0;\nmt19937 mt(123);\n\nunordered_map<bitset<87>, int > ma[19];\nLL table[400000][10];\nint tcnt = 0;\n\ninline bitset<87> tra(bitset<87> b, int dig) {\n    bitset<87> res = (b << dig) | (b >> dig);\n    forn(i, dig) if (b.test(i)) {\n        res.set(dig - i);\n    }\n    return res;\n}\n\nint n;\nLL from, to;\nint k;\nvector<LL> ans;\n\nint solve(bitset<87> b, int rem) {\n    auto it = ma[rem].find(b);\n    if (it != ma[rem].end()) {\n        return it->second;\n    }\n    int ind = tcnt++;\n    if (rem == 0) {\n        int cur = 0;\n        forn(i, 10) {\n            cur |= b.test(i);\n            table[ind][i] = cur;\n        }\n    } else {\n        forn(i, 10) {\n            int cur = solve(tra(b, i), rem - 1);\n            forn(j, 10) {\n                table[ind][j] += table[cur][j];\n            }\n        }\n    }\n    return ma[rem][b] = ind;\n}\n\nLL solve(LL bound, int k) {\n    if (bound == 0) {\n        return 1;\n    }\n    vector<int> dig;\n    while (bound > 0) {\n        dig.pb(bound % 10);\n        bound /= 10;\n    }\n    reverse(dig.begin(), dig.end());\n    int sz = dig.size();\n    bitset<87> b;\n    b.reset();\n    b.set(0);\n    LL ans = 0;\n    forn(i, sz) {\n        forn(j, dig[i] + (i == sz - 1)) {\n            ans += table[solve(tra(b, j), sz - 1 - i)][k];\n        }\n        b = tra(b, dig[i]);\n    }\n    return ans;\n}\n\nLL gen(LL bound) {\n    int times = mt() % 60 + 1;\n    LL res = bound;\n    forn(i, times) {\n        res = mt() % bound + 1;\n    }\n    return res;\n}\n\nint main() {\n    if (DEBUG) {\n        n = 50000;\n    } else {\n        scanf(""%d"", &n);\n    }\n    forn(i, n) {\n        if (DEBUG) {\n            from = gen(LL(1e18));\n            to = gen(LL(1e18));\n            if (from > to) {\n                swap(from, to);\n            }\n            k = mt() % 10;\n        } else {\n            scanf(""%I64d%I64d%d"", &from, &to, &k);\n        }\n        ans.pb(solve(to, k) - solve(from - 1, k));\n    }\n    for (LL x : ans) printf(""%I64d\\n"", x);\n    return 0;\n}\n']",,,"['bitmasks', 'dp']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Minimal Subset Difference.json,https://codeforces.com//blog/entry/58544,Let f x be the minimal subset difference mentioned in the problem statement The problem seems like a regular digit DP problem However it s a bit hard to reduce the number of DP states Let s take a careful consideration For a given integer x we can use knapsack DP to determine f x Denote the sum of digits of x as s x You can just calculate whether there is a subset such that the sum of the subset is a fixed number y and then find the maximal y which concludes f x s x 2y By the way this type of knapsack DP could be implemented by bitwise operation If we defined dp len sum state as the number of integers x such that the length of x is len the digit sum is sum and the knapsack DP array is state an array only consisting 0 and 1 which could be represented as bit vector the problem would be difficult to solve For example to represent x 88888888899999999 a case of f x 0 the length of state might be 73 which is a bit long vector Although most of states satisfy dp len sum state 0 there are still many states which might be used You may notice the order of digits is unnecessary for the knapsack DP If we defined state as the number of appearance of digits 1 2 9 digit 0 is unnecessary the number of states would be Hence we can apply knapsack DP for each state first and then calculate for digit DP Here are more details Let s redefine dp len k state as the number of ways to arrange the lowest len digits of x such that f x k and the other digits higher than the lowest len digits form the state i e the number of appearance of digits 1 2 9 We firstly search all the states such that the total number of appearance 18 and f x k and then set dp 0 k state 1 After searching we calculate dp len k new state from dp len 1 k state 0 by enumerating the len th digit However the number of dp len k state 0 is still too large to calculate for digit DP You should notice that in decimal representation it always has 0 f x 9 for any integer x Furthermore because of the distribution of digits most of states are in cases of f x 0 1 you can make a knapsack DP to prove In addition it is easy to show f x and s x always have the same parity so we can apply inclusion exclusion principle to solve the problem only in the cases of f x 2 and another counting problem with fixed parity of s x The total time complexity in above is where L 18 is the maximal length of x D 9 is the maximal digit and S 3 104 is the number of distinct states such that there exists dp len k state 0 0 len L 2 k 9 However it can hardly pass the tests with n 5 104 because we have some fairly worse tests to maximize the times of dp access e g l and r have a lot of 9 as digits and k 1 We could make a tradeoff between pretreatment and queries by several ways For example define dp len k state upp as the similar but it memorizes that the len th digit is less than upp If we did that the total time complexity would be which is acceptable The aforementioned solution is not easy to code you can use some advanced approach to get accepted though Here are bonuses for advanced solutions 
https://codeforces.com//contest/1279/problem/F,504278,F,1279F,1279,F. New Year and Handle Change,New Year is getting near So it s time to change handles on codeforces Mishka wants to change his handle but in such a way that people would not forget who he is To make it work he only allowed to change letters case More formally during handle change he can choose any segment of his handle i i l 1 and apply or to all letters of his handle on this segment more fomally replace all uppercase letters with corresponding lowercase or vice versa The length l is fixed for all changes Because it is not allowed to change codeforces handle too often Mishka can perform at most k such operations What is the value of min lower upper where lower is the number of lowercase letters and upper is the number of uppercase letters can be obtained after optimal sequence of changes ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n \nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, l;\n  cin >> n >> k >> l;\n  string s;\n  cin >> s;\n  vector <int> ret;\n  for (auto c : s) {\n    if (\'a\' <= c && c <= \'z\') ret.push_back(0);\n    else ret.push_back(1);\n  }\n  const ll inf = (ll) (1e18) + 7;\n  ll ans = n;\n  for (int t = 0; t < 2; t++) {\n    auto f = [&] (int m) {\n      vector <pair <ll, int> > dp(n, make_pair(inf, 0));\n      for (int i = 0; i < n; i++) {\n        {\n          auto go = (i >= l ? dp[i - l] : make_pair(0ll, 0));\n          go.first += m;\n          go.second++;\n          dp[i] = min(dp[i], go);\n        }\n        {\n          auto go = (i > 0 ? dp[i - 1] : make_pair(0ll, 0));\n          go.first += ret[i];\n          dp[i] = min(dp[i], go);\n        }\n      }\n      return dp[n - 1];\n    };\n    if (f(0).second <= k) {\n      ans = min(ans, f(0).first);\n    } else {\n      int l = 0, r = n + 228;\n      while (l < r - 1) {\n        int mid = (l + r) / 2;\n        if (f(mid).second <= k) {\n          r = mid;\n        } else {\n          l = mid;\n        }\n      }\n      auto go = f(r);\n      ans = min(ans, go.first - r * (ll) k);\n    }\n    for (int &x : ret) {\n      x ^= 1;\n    }\n  }\n  cout << ans << \'\\n\';\n}']",,,"['binary search', 'dp']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. New Year and Handle Change.json,https://codeforces.com//blog/entry/72577,Let s simplify the problem a bit we need either to minimize the number of lowercase letters or to minimize the number of uppercase letters Both variants can be described by the following model we have a binary array where if is in the correct case and otherwise We can do at most operations set on the segment and we d like to minimize the total sum of At first let s start with a solution which is pretty slow but correct Let be the minimum sum of the prefix such that operations was already applied on it In order to calculate this somehow efficiently we need to understand that it s optimal to avoid intersections of segments of applied operations so we can further specify the state of with the following all applied operations have their right borders It s easy to specify the transitions we either apply set operation on and relax with or not and relax with It still so we d like to optimize it more and we can do it using the lambda optimization i e aliens trick Here we will try to describe what aliens trick is and the features of its application on the discrete calculations In general aliens trick allows you to get rid of the restriction on the total number of operations applied to the array sometimes it s the number of segments in the partition of the array by replacing it with the binary search of the value connected to it The is the cost of using the operation or the cost to use one more segment in the partition In other words we can use as many operations as we want but we need to pay for each of them Often we can calculate the answer without the restriction faster The main restriction of the using this dp optimization is the following in case of the discrete model consider the answer for the fixed or If we look at the function it should be somewhat convex i e or sometimes for all possible Let s look at the answers of the modified version of the problem with cost for each used operation as function It s easy to prove that and it s also somewhat convex for a fixed as a sum of convex functions But more important it has the following property let be the position where the is the minimum possible It can be proven from the convex property that This property leads to the solution binary search while keeping track of the i e find the minimum that But there are several problems related to the discrete origin of the problem The is not unique In general case there is a segment where the minimum can be achieved But there is still a property that and So we need to ensure that we will always find either minimum such or maximum such The second problem comes from the first one There are situations when It creates a problem in the next situation suppose the binary search finished with the and But we need to use exactly operations what to do Using float values will not help so we don t need them so we ll use usual integer bs Suppose we minimized the then we can show that or in other words So we can claim that we calculated the value not only for but also for In the end if we can efficiently calculate and for the fixed then we can binary search extract and claim that the Finally let s discuss how to calculate and for a fixed Since is just a minimum cost and the is the minimum number of operations with such cost We can calculate it by simplifying our starting Remember the cost is calculated in a next way for each remaining in we pay and for each used operation we pay Let where is minimum cost on the prefix of length and is minimum number of operations can be achieved Then the transitions are almost the same we either let be and relax with or start new operation and relax with The result is pair Some additional information we should carefully choose the borders of the binary search we should choose the left border so it s optimal to use operation whenever we can usually or And we should choose the right border so it s never optimal to use even one operation usually more than the maximum possible answer The total complexity is P S We don t have the strict proof that the is convex but we have faith and stress We d appreciate it if someone would share the proof in the comment section 
https://codeforces.com//contest/312/problem/B,3074,B,312B,312,B. Archer,SmallR is an archer SmallR is taking a match of archer with Zanoes They try to shoot in the target in turns and SmallR shoots first The probability of shooting the target each time is for SmallR while for Zanoes The one who shoots in the target first should be the winner Output the probability that SmallR will win the match ,"['#include<iostream>\n#include<cstdio>\nusing namespace std;\ndouble a,b,c,d,x,y;\nint main()\n{\n    cin>>a>>b>>c>>d;\n    x=a/b,y=c/d;\n    printf(""%.10lf\\n"",x/(1-(1-x)*(1-y)));\n    return 0;\n}']",,,"['math', 'probabilities']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Archer.json,https://codeforces.com//blog/entry/7785,let p a b q 1 c d 1 a b The answer of this problem can be showed as p q 0 p q 1 p q 2 That is the sum of a geometric progression which is infinite but 0 q 1 We can get the limit by the formula p 1 q 
https://codeforces.com//contest/1337/problem/A,594573,A,1337A,1337,A. Ichihime and Triangle,Ichihime is the current priestess of the Mahjong Soul Temple She claims to be human despite her cat ears These days the temple is holding a math contest Usually Ichihime lacks interest in these things but this time the prize for the winner is her favorite cookies Ichihime decides to attend the contest Now she is solving the following problem You are given four positive integers a b c d such that a leq b leq c leq d Your task is to find three integers x y z satisfying the following conditions a leq x leq b b leq y leq c c leq z leq d There exists a triangle with a positive non zero area and the lengths of its three sides are x y and z Ichihime desires to get the cookie but the problem seems too hard for her Can you help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t; \n    cin >> t;\n    while(t--)\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n    \n        cout << b << "" "" << c << "" "" << c << ""\\n"";\n    }\n\n    return 0;\n}']",,,"['constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Ichihime and Triangle.json,https://codeforces.com//blog/entry/76099,There are many possible solutions one of them is to always output You can easily prove that always satisfies the requirements 
https://codeforces.com//contest/1336/problem/C,594567,C,1336C,1336,C. Kaavi and Magic Spell,Kaavi the mysterious fortune teller deeply believes that one s fate is inevitable and unavoidable Of course she makes her living by predicting others future While doing divination Kaavi believes that magic spells can provide great power for her to see the future Kaavi has a string T of length m and all the strings with the prefix T are magic spells Kaavi also has a string S of length n and an empty string A During the divination Kaavi needs to perform a sequence of operations There are two different operations Delete the first character of S and add it at the of A Delete the first character of S and add it at the of A Kaavi can perform n operations To finish the divination she wants to know the number of different operation sequences to make A a magic spell i e with the prefix T As her assistant can you help her The answer might be huge so Kaavi only needs to know the answer modulo 998 244 353 Two operation sequences are considered different if they are different in length or there exists an i that their i th operation is different A substring is a contiguous sequence of characters within a string A prefix of a string S is a substring of S that occurs at the beginning of S ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 3123;\nconst int P = 998244353;\nint n, m;\nint dp[maxN][maxN], ans;\nchar s[maxN], t[maxN];\nint main()\n{\n\tscanf(""%s"", s);\n\tscanf(""%s"", t);\n\tint n = strlen(s);\n\tint m = strlen(t);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i < m)\n\t\t{\n\t\t\tif (t[i] == s[0])\n\t\t\t\tdp[0][i] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (dp[i][j])\n\t\t\t{\n\t\t\t\tif (i + 1 >= m && j == 0)\n\t\t\t\t\tans = (ans + dp[i][j]) % P;\n\t\t\t\tif (i == n - 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (j > 0 && (j - 1 >= m || t[j - 1] == s[i + 1]))\n\t\t\t\t\tdp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % P;\n\t\t\t\tint back = j + i + 1;\n\t\t\t\tif (back < n && (back >= m || t[back] == s[i + 1]))\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % P;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(""%d\\n"", ans * 2 % P);\n}\n']",,,"['dp', 'strings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Kaavi and Magic Spell.json,https://codeforces.com//blog/entry/76099,We can use DP to solve this problem Let be the answer when has already been used and the current will be in the position after all operations are finished Specially means that all characters in the current won t be in the position after all operations are finished By definition and The state transition If has already had the prefix so you can stop performing operations at any position there are positions in total Otherwise only when you can add at the back of there are different operation sequences in this situation If or you can add at the back of there are different operation sequences in this situation If you can add at the front of there are different operation sequences in this situation You can always add at the front back of in this situation different operation sequences However if you can let to match different operation sequences So if Otherwise The answer is 
