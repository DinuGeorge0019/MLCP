problem_link,problem_name,problem_statement,problem_solution,tags,dificulty
https://codeforces.com//contest/431/problem/B,B. Shower Line,Many students live in a dormitory A dormitory is a whole new world of funny amusements and possibilities but it does have its drawbacks There is only one shower and there are multiple students who wish to have a shower in the morning That s why every morning there is a line of five people in front of the dormitory shower door As soon as the shower opens the first person from the line enters the shower After a while the first person leaves the shower and the next person enters the shower The process continues until everybody in the line has a shower Having a shower takes some time so the students in the line talk as they wait At each moment of time the students talk in pairs the th man in the line for the current moment talks with the th one Let s look at this process in more detail Let s number the people from 1 to 5 Let s assume that the line initially looks as 23154 person number 2 stands at the beginning of the line Then before the shower opens 2 talks with 3 1 talks with 5 4 doesn t talk with anyone Then 2 enters the shower While 2 has a shower 3 and 1 talk 5 and 4 talk too Then 3 enters the shower While 3 has a shower 1 and 5 talk 4 doesn t talk to anyone Then 1 enters the shower and while he is there 5 and 4 talk Then 5 enters the shower and then 4 enters the shower We know that if students and talk then the th student s happiness increases by and the th student s happiness increases by Your task is to find such initial order of students in the line that the total happiness of all students will be maximum in the end Please note that some pair of students may have a talk several times In the example above students 1 and 5 talk while they wait for the shower to open and while 3 has a shower ,"['#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint g[6][6],x[6],pd[6],ans;\nvoid dfs(int k){\n\tif (k==6){\n\t\tint num=0;\n\t\tfor (int i=1;i<=4;i++)\n\t\t\tfor (int j=1;j<=(5-i+1)/2;j++)\n\t\t\t\tnum+=g[x[i+j*2-2]][x[i+j*2-1]]+g[x[i+j*2-1]][x[i+j*2-2]];\n\t\tans=max(ans,num);\n\t\treturn;\n\t}\n\tfor (int i=1;i<=5;i++)\n\t\tif (pd[i]==0){\n\t\t\tpd[i]=1; x[k]=i; dfs(k+1); pd[i]=0;\n\t\t}\n}\nint main(){\n\tfor (int i=1;i<=5;i++)\n\t\tfor (int j=1;j<=5;j++)\n\t\t\tscanf(""%d"",&g[i][j]);\n\tmemset(pd,0x00,sizeof pd); ans=0;\n\tdfs(1);\n\tcout<<ans<<endl;\n\treturn 0;\n}']","['brute force', 'implementation']",1200
https://codeforces.com//contest/603/problem/E,E. Pastoral Oddities,In the land of Bovinia there are pastures but no paths connecting the pastures Of course this is a terrible situation so Kevin Sun is planning to rectify it by constructing undirected paths connecting pairs of distinct pastures To make transportation more efficient he also plans to pave some of these new paths Kevin is very particular about certain aspects of path paving Since he loves odd numbers he wants each pasture to have an odd number of paved paths connected to it Thus we call a paving if each pasture is incident to an odd number of paved paths He also enjoys short paths more than long paths so he would like the longest paved path to be as short as possible After adding each path Kevin wants to know if a sunny paving exists for the paths of Bovinia and if at least one does the minimum possible length of the longest path in such a paving Note that longest path here means maximum weight edge ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 611111\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m;\nint x[N], y[N], l[N];\npair<int, int> q[N];\n\nint p[N], sz[N];\nint odd;\n\nvector<int> z, z3;\nvector<pair<int, int> > z2;\n\nint ans[N];\n\nint u[N];\n\n\nvoid unite(int id) {\n\tint a = x[id];\n\twhile (p[a] != a) a = p[a];\n\tint b = y[id];\n\twhile (p[b] != b) b = p[b];\n\tif (a == b) return;\n\n\tif (sz[a] < sz[b]) swap(a, b);\n\n\tif (sz[a] % 2 == 1&& sz[b] % 2 == 1) {\n\t\tz3.pb(2);\n\t\todd -= 2;\n\t} else {\n\t\tz3.pb(0);\n\t}\n\n\tz2.pb(mp(a, sz[a]));\n\tsz[a] += sz[b];\n\n\tz.pb(b);\n\n\tp[b] = a;\n}\n\nvoid backup(int ver) {\n\twhile (z.size() > ver) {\n\t\todd += z3.back();\n\t\tz3.pop_back();\n\n\t\tsz[z2.back().F] = z2.back().S;\n\t\tz2.pop_back();\n\n\t\tp[z.back()] = z.back();\n\t\tz.pop_back();\n\t}\n}\n\nvoid go(int l, int r, int ll, int rr) {\n\tif (l > r) return;\n\n\tif (odd == 0) {\n\t\tputs(""!"");\n\t}\n\n\tint ver = z.size();\n\n\tint mid = (l + r) / 2;\n\tint nmid = -1;\n\n\tfor (int i = l; i <= mid; i++) if (u[i] < ll) unite(i);\n\tif (odd == 0) {\n\t\tputs(""!"");\n\t}\n\n\tfor (int i = ll; i <= rr; i++) if (q[i].S <= mid) {\n\t\tunite(q[i].S);\n\t\tif (odd == 0) {\n\t\t\tnmid = i;\n\t\t\tbreak;\n\t\t}\t\t\n\t}\n\tbackup(ver);\n\n\tif (nmid == -1) {\n\t\tfor (int i = l; i <= mid; i++) ans[i] = -1;\n\t\tfor (int i = l; i <= mid; i++) if (u[i] < ll) {\n\t\t\tunite(i);\n\t\t}\n\n\t\tgo(mid + 1, r, ll, rr);\n\n\t\tbackup(ver);\n\t\treturn;\n\t}\n\tans[mid] = q[nmid].F;\n\n\tfor (int i = ll; i < nmid; i++) if (q[i].S < l) unite(q[i].S);\n\n\tgo(l, mid - 1, nmid, rr);\n\tbackup(ver);\n\n\n\tfor (int i = l; i <= mid; i++) if (u[i] < ll) unite(i);\n\n\tgo(mid + 1, r, ll, nmid);\n\n\tbackup(ver);\n}\n\nint main(){\n//\tfreopen(TASK"".in"",""r"",stdin);\t\n//\tfreopen(TASK"".out"",""w"",stdout);\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%d%d%d"", &x[i], &y[i], &l[i]);\n\n\t\tq[i] = mp(l[i], i);\n\t}\n\tsort(q, q + m);\n\tfor (int i = 0; i < m; i++) {\n\t\tu[q[i].S] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = i;\n\t\tsz[i] = 1;\n\t}\t\t\n\todd = n;\n\n\tgo(0, m - 1, 0, m - 1);\n\n\tfor (int i = 0; i < m; i++) printf(""%d\\n"", ans[i]);\n\treturn 0;\n}']","['data structures', 'divide and conquer', 'dsu', 'math', 'trees']",3000
https://codeforces.com//contest/197/problem/A,A. Plate Game,You ve got a rectangular table with length and width and the infinite number of plates of radius Two players play the following game they take turns to put the plates on the table so that the plates don t lie on each other but they can touch each other and so that any point on any plate is located within the table s border During the game one cannot move the plates that already lie on the table The player who cannot make another move loses Determine which player wins the one who moves first or the one who moves second provided that both players play optimally well ,"['#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int A, B, R;\n    cin >> A >> B >> R;\n    R *= 2;\n    if (A < R || B < R)\n        cout << ""Second\\n"";\n    else\n        cout << ""First\\n"";\n    return 0;\n}\n']","['constructive algorithms', 'games', 'math']",1600
https://codeforces.com//contest/302/problem/A,A. Eugeny and Array,Eugeny has array consisting of integers Each integer equals to 1 or to 1 Also he has queries Query number is given as a pair of integers The response to the query will be integer if the elements of array can be rearranged so as the sum otherwise the response to the query will be integer Help Eugeny answer all his queries ,"['#include <iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nint a[300000];\nint s[300000];\n\nint main()\n{\n\tint n,m;\n\tcin >> n >> m;\n\tmemset(s,0,sizeof(s));\n\tint p = 0;\n\tint q = 0;\n\tfor (int i = 1; i <= n ; i++)\n\t{\n\t\tscanf(""%d"", &a[i]);\n\t\t//s[i] = s[i-1] + a[i];\n\t\tif (a[i] == 1) p++;\n\t\tif (a[i] == -1) q++;\n\t}\n\tfor (int i = 0; i< m; i++)\n\t{\n\t\tint l,r;\n\t\tscanf(""%d %d"", &l, &r);\n\t\tint u = r - l + 1;\n\t\tif (u% 2==1)\n\t\t{\n\t\t\t printf(""0\\n"");\n\t\t\t continue;\n\t\t\t}\n\t\tu = u / 2;\n\t\tif (p >= u && q >= u) printf(""1\\n""); else printf(""0\\n"");\n\t}\n\t//system(""pause"");\n}\n\n/*\n2 3\n1 -1\n1 1\n1 2\n2 2\n*/\n']",['implementation'],800
https://codeforces.com//contest/25/problem/B,B. Phone numbers,Phone number in Berland is a sequence of digits Often to make it easier to memorize the number it is divided into groups of two or three digits For example the phone number is easier to remember as Your task is to find for a given phone number any of its divisions into groups of two or three digits ,"['#include <assert.h>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <list>\n#include <stack>\n#include <string.h>\n#include <stdlib.h>\n#include <vector>\n#include <utility>\n#include <list>\n#define INF 0x3fffffff\n#define LINF 0x3fffffffffffffffll\n#define DINF 1e100;\n\ntypedef long long ll;\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PDD pair<double, double>\n#define PIL pair<int, ll>\n#define PLI pair<ll, int>\n#define PID pair<int, double>\n#define PDI pair<double, int>\n#define PLD pair<ll, double>\n#define PDL pair<double, ll>\n\n#define NUL(x) memset(x, 0, sizeof(x))\n#define MINUS(x) memset(x, 0xff, sizeof(x))\n#define PQ(x) priority_queue< x >  //highest first\n#define PQR(x) priority_queue< x , vector< x > , greater < x > > //lowest first\n#define MP make_pair\n#define PB push_back\n#define IT(x) for (typeof((x).begin()) it = (x).begin() ; it != (x).end() ; it++)\n#define IT2(x) for (typeof((x).begin()) it2 = (x).begin() ; it2 != (x).end() ; it2++)\n#define FOR(i, a, b) for (int i = (a) ; i< (b) ; i++)\n#define DEB(x...) fprintf(stderr,x);\n//#define DEB\n\nusing namespace std;\n\nbool testc(int tc=0)\n{\n\n}\n\nchar buf[150];\nint main()\n{\n  int n;\n  scanf(""%i "", &n);\n  gets(buf);\n  int i=0;\n  if (n%2)\n    {\n      printf(""%c"", buf[0]);\n      i++;\n    }\n  while(i<n)\n    {\n      printf(""%c%c"", buf[i], buf[i+1]);\n      i+=2;\n      if (i<n) printf(""-"");\n    }\n  printf(""\\n"");\n  return 0;\n}\n']",['implementation'],1100
https://codeforces.com//contest/1419/problem/B,B. Stairs,Jett is tired after destroying the town and she wants to have a rest She likes high places that s why for having a rest she wants to get high and she decided to craft staircases A staircase is a squared figure that consists of square cells Each staircase consists of an arbitrary number of stairs If a staircase has n stairs then it is made of n columns the first column is 1 cell high the second column is 2 cells high ldots the n th column if n cells high The lowest cells of all stairs must be in the same row A staircase with n stairs is called nice if it may be covered by n squares made of cells All squares should fully consist of cells of a staircase This is how a nice covered staircase with 7 stairs looks like Find out the maximal number of nice staircases that can be built using no more than x cells No cell can be used more than once ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint pw[MAXN], t[MAXN];\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    int T; cin >> T;\n    pw[0] = 1; For(i, 1, 62) pw[i] = pw[i-1] * 2;\n    For(i, 1, 63) t[i] = t[i-1] + pw[i-1];\n    while(T--) {\n    \tint x; cin >> x;\n    \tFor(i, 1, 63) {\n    \t\tif(x < t[i] * (t[i] + 1) / 2) {\n    \t\t\tprintf(""%d\\n"", i - 1); break;\n\t\t\t}\n\t\t\telse x -= t[i] * (t[i] + 1) / 2;\n\t\t}\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']","['brute force', 'constructive algorithms', 'greedy', 'implementation', 'math']",1200
https://codeforces.com//contest/1889/problem/D,D. Game of Stacks,You have n stacks r 1 r 2 ldots r n Each stack contains some positive integers ranging from 1 to n Define the following functions function init pos stacks an array that contains n stacks r 1 r 2 r n return get stacks pos function get stacks pos if stacks pos is empty return pos else new pos the top element of stacks pos pop the top element of stacks pos return get stacks new pos You want to know the values returned by texttt init 1 texttt init 2 ldots texttt init n Note that during these calls the stacks r 1 r 2 ldots r n don t change so the calls texttt init 1 texttt init 2 ldots texttt init n are independent ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n/**\n * Description: Disjoint Set Union with path compression\n * and union by size. Add edges and test connectivity.\n * Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e;\n\tvoid init(int N) { e = vi(N, -1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tvoid add_edge(int x, int y) {  // union by size\n\t\tx = get(x), y = get(y);\n\t\tassert(x != y);\n\t\t// if (x == y) return 0;\n\t\te[y] += e[x];\n\t\te[x] = y;\n\t}\n};\n\n/**tcT> T kruskal(int N, vector<pair<T,pi>> ed) {\n    sort(all(ed));\n    T ans = 0; DSU D; D.init(N); // edges that unite are in MST\n    each(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;\n    return ans;\n}*/\n\nint N;\nV<vi> C;\n// DSU D;\nvi ans;\n\n// int query(int x) {\n// \tvi stk{x};\n// \twhile (true) {\n// \t\tif (final_ans[stk.bk]) {\n\n// \t\t}\n// \t}\n// }\n\nint timer = 0;\n\nvi vis;\n\nvoid dfs(int x) {\n\t++timer;\n\tvi stk{x};\n\tvis[stk.bk] = timer;\n\twhile (true) {\n\t\tif (!ans[stk.bk] && !sz(C[stk.bk])) { ans[stk.bk] = stk.bk; }\n\t\tif (ans[stk.bk]) {\n\t\t\teach(x, stk) ans[x] = ans[stk.bk];\n\t\t\treturn;\n\t\t}\n\t\tint nxt = C[stk.bk].bk;\n\t\tif (vis[nxt] != timer) {\n\t\t\tstk.pb(nxt);\n\t\t\tvis[stk.bk] = timer;\n\t\t} else {\n\t\t\twhile (true) {\n\t\t\t\tassert(sz(stk));\n\t\t\t\tC[stk.bk].pop_back();\n\t\t\t\tif (stk.bk == nxt) break;\n\t\t\t\tvis[stk.bk] = 0;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tassert(stk.bk == nxt);\n\t\t}\n\t}\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tre(N);\n\t// D.init(N + 1);\n\t// D.add_edge(1, 2);\n\t// dbg(D.get(1), D.get(2));\n\t// exit(0);\n\tC.rsz(N + 1);\n\tFOR(i, 1, N + 1) {\n\t\tdef(int, K);\n\t\tC[i].rsz(K);\n\t\tre(C[i]);\n\t}\n\tans.rsz(N + 1);\n\tvis = vi(N + 1);\n\tFOR(i, 1, N + 1) dfs(i);\n\tans.erase(begin(ans));\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['brute force', 'dfs and similar', 'graphs', 'implementation', 'trees']",3000
https://codeforces.com//contest/939/problem/E,E. Maximize ,You are given a multiset consisting of positive integers initially empty There are two kind of queries Add a positive integer to the newly added integer is not less than any number in it Find a subset of the set such that the value is maximum possible Here means maximum value of elements in the average value of numbers in Output this maximum possible value of ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\n#define F first\n#define S second\n\nconst int MAXN = 5e5 + 10;\n\nint n, q;\nll p[MAXN], a[MAXN];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(12);\n\tcin >> q;\n\twhile (q--){\n\t\tint t; cin >> t;\n\t\tif (t == 1){\n\t\t\tint x; cin >> x;\n\t\t\ta[n++] = x;\n\t\t\tp[n] = p[n-1] + a[n-1];\n\t\t}\n\t\telse{\n\t\t\tint lo = -1, hi = n-1;\n\t\t\twhile (hi-lo>1){\n\t\t\t\tint mid = hi+lo>>1;\n\t\t\t\tif ((a[n-1] + p[mid]) * (mid + 2) > (a[n-1] + p[mid+1]) * (mid + 1))\n\t\t\t\t\tlo = mid;\n\t\t\t\telse\n\t\t\t\t\thi = mid;\n\t\t\t}\n\t\t\tcout << a[n-1] - (a[n-1] + p[hi])/ ld(hi + 1) << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}\n']","['binary search', 'greedy', 'ternary search', 'two pointers']",1800
https://codeforces.com//contest/1926/problem/G,G. Vlad and Trouble at MIT,Vladislav has a son who really wanted to go to MIT The college dormitory at MIT Moldova Institute of Technology can be represented as a tree with n vertices each vertex being a room with exactly one student A is a connected undirected graph with n vertices and n 1 edges Tonight there are three types of students students who want to party and play music marked with texttt P students who wish to sleep and enjoy silence marked with texttt S and students who don t care marked with texttt C Initially all the edges are walls which allow music to pass through so when a partying student puts music on it will be heard in every room However we can place some walls on any edges thick walls don t allow music to pass through them The university wants to install some thick walls so that every partying student can play music and no sleepy student can hear it Because the university lost a lot of money in a naming rights lawsuit they ask you to find the minimum number of thick walls they will need to use ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nchar s[N];\nint f[N][2];\nvector<int>g[N];\nconst int INF=0x3f3f3f3f;\nvoid dfs(int u)\n{\n\t//u 0 作为S\n\tf[u][1]=f[u][0]=0;\n\tif(s[u-1]==\'S\')f[u][1]=INF;\n\tif(s[u-1]==\'P\')f[u][0]=INF;\n\tfor(auto v:g[u])\n\t{\n\t\tdfs(v);\n\t\tf[u][0]+=min(f[v][0],f[v][1]+1);\n\t\tf[u][1]+=min(f[v][1],f[v][0]+1);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++)g[i].clear();\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tcin>>s;\n\t\tdfs(1);\n\t\tcout<<min(f[1][0],f[1][1])<<""\\n"";\n\t}\n\t\n\treturn 0;\n}']","['dfs and similar', 'dp', 'flows', 'graphs', 'greedy', 'implementation', 'trees']",1900
https://codeforces.com//contest/1716/problem/F,F. Bags with Balls,There are n bags each bag contains m balls with numbers from 1 to m For every i in 1 m there is exactly one ball with number i in each bag You have to take exactly one ball from each bag all bags are different so for example taking the ball 1 from the first bag and the ball 2 from the second bag is not the same as taking the ball 2 from the first bag and the ball 1 from the second bag After that you calculate the number of balls with numbers among the ones you have taken Let the number of these balls be F Your task is to calculate the sum of F k over all possible ways to take n balls one from each bag ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 2020;\nMint S[N][N];\nMint C[N];\nMint pw[N];\n\nvoid solve() {\n\tint n, m, k;\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tC[0] = 1;\n\tfor (int i = 0; i < k; i++)\n\t\tC[i + 1] = C[i] * Mint(n - i);\n\tpw[0] = 1;\n\tpw[1] = Mint((m + 1) / 2) / Mint(m);\n\tfor (int i = 1; i < k; i++)\n\t\tpw[i + 1] = pw[i] * pw[1];\n\tMint ans = 0;\n\tfor (int p = 1; p <= k; p++)\n\t\tans += S[k][p] * C[p] * pw[p];\n\tans *= Mint(m).pow(n);\n\tprintf(""%u\\n"", ans.x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tS[0][0] = 1;\n\tfor (int n = 1; n < N; n++)\n\t\tfor (int k = 1; k <= n; k++)\n\t\t\tS[n][k] = S[n - 1][k] * k + S[n - 1][k - 1];\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math', 'number theory']",2500
https://codeforces.com//contest/628/problem/A,A. Tennis Tournament,A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n  int n, b, p;\n  in >> n >> b >> p;\n  out << (2 * b + 1) * (n - 1) << "" "" << n * p << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","['implementation', 'math']",1000
https://codeforces.com//contest/727/problem/B,B. Bill Total Value,Vasily exited from a store and now he wants to recheck the total price of all purchases in his bill The bill is a string in which the names of the purchases and their prices are printed in a row without any spaces Check has the format where name of the th purchase is a non empty string of length not more than consisting of lowercase English letters and the price of the th purchase is a non empty string consisting of digits and dots decimal points It is possible that purchases with equal names have different prices The price of each purchase is written in the following format If the price is an integer number of dollars then cents are not written Otherwise after the number of dollars a dot decimal point is written followed by cents if number of cents is between and inclusively there is a leading zero Also every three digits from less significant to the most in dollars are separated by dot decimal point No extra leading zeroes are allowed The price always starts with a digit and ends with a digit For example and are valid prices and are not valid Write a program that will find the total price of all purchases in the given bill ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld EPS = 1e-7;\n\nint run() {\n    string s;\n    cin >> s;\n    s += ""a"";\n    ll ans = 0;\n    \n    ll cur_num = -1;\n    int last_dot = -INF;\n    \n    for (int i = 0; i < (int) s.size(); i++) {\n        if (s[i] == \'.\') {\n            last_dot = i;\n            continue;\n        }\n        \n        if (\'a\' <= s[i] && s[i] <= \'z\') {\n            if (cur_num != -1) {\n                if (i - last_dot != 3) {\n                    cur_num *= 100;\n                }\n                \n                ans += cur_num;\n            }\n            \n            cur_num = -1;\n            continue;\n        }\n        \n        if (cur_num == -1) {\n            cur_num = s[i] - \'0\';\n        } else {\n            cur_num = cur_num * 10 + (s[i] - \'0\');\n        }\n    }\n    \n    if (ans % 100 == 0) {\n        string t = to_string(ans / 100);\n        vector<char> pp;\n        for (int i = 0; i < (int) t.size(); i++) {\n            int j = (int) t.size() - i - 1;\n            if (i % 3 == 0 && i != 0) {\n                pp.push_back(\'.\');\n            }\n            pp.push_back(t[j]);\n        }\n        \n        reverse(pp.begin(), pp.end());\n        for (char c : pp) {\n            cout << c;\n        }\n        \n        cout << ""\\n"";\n    } else {\n        string t = to_string(ans / 100);\n        vector<char> pp;\n        for (int i = 0; i < (int) t.size(); i++) {\n            int j = (int) t.size() - i - 1;\n            if (i % 3 == 0 && i != 0) {\n                pp.push_back(\'.\');\n            }\n            pp.push_back(t[j]);\n        }\n        \n        reverse(pp.begin(), pp.end());\n        for (char c : pp) {\n            cout << c;\n        }\n        \n        string tt = to_string(ans % 100);\n        while ((int) tt.size() < 2) {\n            tt = ""0"" + tt;\n        }\n        \n        cout << \'.\' << tt << ""\\n"";\n    }\n\n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    return run();\n}\n']","['expression parsing', 'implementation', 'strings']",1600
https://codeforces.com//contest/1445/problem/A,A. Array Rearrangment,You are given two arrays a and b each consisting of n positive integers and an integer x Please determine if one can rearrange the elements of b so that a i b i leq x holds for each i 1 le i le n ,"['#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nint T;\n\nconst int N = 50 + 5;\nint n, x, a[N], b[N];\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> T;\n\n    while (T--) {\n        cin >> n >> x;\n\n        for (int i = 0; i < n; i++) cin >> a[i];\n        for (int i = 0; i < n; i++) cin >> b[i];\n\n        sort(a, a + n);\n        sort(b, b + n, greater<int>());\n\n        bool ok = 1;\n        for (int i = 0; i < n; i++) ok &= (a[i] + b[i] <= x);\n\n        cout << (ok? ""Yes"" : ""No"") << \'\\n\';\n    }\n}\n']","['greedy', 'sortings']",800
https://codeforces.com//contest/1186/problem/E,E. Vus the Cossack and a Field,Vus the Cossack has a field with dimensions n times m which consists of and He is building an infinite field from this field He is doing this in this way He takes the current field and finds a new inverted field In other words the new field will contain only there where was in the current field and there where was To the current field he adds the inverted field to the right To the current field he adds the inverted field to the bottom To the current field he adds the current field to the bottom right He repeats it For example if the initial field was begin matrix 1 0 1 1 end matrix After the first iteration the field will be like this begin matrix 1 0 0 1 1 1 0 0 0 1 1 0 0 0 1 1 end matrix After the second iteration the field will be like this begin matrix 1 0 0 1 0 1 1 0 1 1 0 0 0 0 1 1 0 1 1 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 1 0 0 0 0 1 1 end matrix And so on Let s numerate lines from top to bottom from 1 to infinity and columns from left to right from 1 to infinity We call the submatrix x 1 y 1 x 2 y 2 all numbers that have coordinates x y such that x 1 leq x leq x 2 and y 1 leq y leq y 2 The Cossack needs sometimes to find the sum of all the numbers in submatrices Since he is pretty busy right now he is asking you to find the answers ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=1005;\n\nint n,m;\nchar a[MAXN][MAXN];\nint s[MAXN][MAXN];\nint calc(int x)\n{\n\tint ans=0;\n\tfor(;x;x>>=1)ans^=(x&1);\n\treturn ans;\n}\nll gsum(int x,int y,int t)\n\t{return t?(x+1)*(y+1)-s[x][y]:s[x][y];}\nll work(int x,int y)\n{\n\tif(!x || !y)return 0;\n\t--x;--y;\n\tint tx=x/n,ty=y/m;\n\tll ans=1ll*(tx>>1)*(y+1)*n+1ll*(ty>>1)*(x%(2*n)+1)*m;\n\tif((tx&1) && (ty&1))ans+=gsum(n-1,m-1,calc(tx-1)^calc(ty-1));\n\tif(tx&1)ans+=gsum(n-1,y%m,calc(tx-1)^calc(ty));\n\tif(ty&1)ans+=gsum(x%n,m-1,calc(tx)^calc(ty-1));\n\tans+=gsum(x%n,y%m,calc(tx)^calc(ty));\n\treturn ans;\n}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(""code.in"",""r"",stdin);\n    //freopen(""code.out"",""w"",stdout);\n    #endif\n    int Q,x1,y1,x2,y2;\n    scanf(""%d%d%d"",&n,&m,&Q);\n    for(int i=0;i<n;i++)\n    \tscanf(""%s"",a[i]);\n    for(int i=0;i<n;i++)\n    \tfor(int j=0;j<m;j++)\n    \t\tif(i && j)s[i][j]=s[i-1][j]+s[i][j-1]+(a[i][j]-\'0\')-s[i-1][j-1];\n    \t\telse if(i)s[i][j]=s[i-1][j]+(a[i][j]-\'0\');\n    \t\telse if(j)s[i][j]=s[i][j-1]+(a[i][j]-\'0\');\n    \t\telse s[i][j]=a[i][j]-\'0\';\n/*for(int i=0;i<n;i++)\n{\n\tfor(int j=0;j<m;j++)\n\t\tcout<<gsum(i,j,1)<<"" "";\n\tcout<<endl;\n}\ncout<<endl;*/\n    while(Q--)\n    {\n    \tscanf(""%d%d%d%d"",&x1,&y1,&x2,&y2);\n    \t--x1;--y1;\n    \tprintf(""%I64d\\n"",work(x2,y2)-work(x1,y2)-work(x2,y1)+work(x1,y1));\n    }\n    return 0;\n}\n']","['divide and conquer', 'implementation', 'math']",2500
https://codeforces.com//contest/451/problem/D,D. Count Good Substrings,We call a string if after merging all the consecutive equal characters the resulting string is palindrome For example is good because after the merging step it will become Given a string you have to find two values the number of good substrings of even length the number of good substrings of odd length ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define fst first\n#define snd second\n#define mp make_pair\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\n#define ri(x) scanf(""%d"", &x)\n#define rii(x,y) scanf(""%d%d"", &x, &y)\n#define riii(x,y,z) scanf(""%d%d%d"", &x, &y, &z)\n#define ria(a, n) rep(_, n) scanf(""%d"", &a[_])\n\n#define pi(x) printf(""%d\\n"", x)\n#define pia(a, n) rep(_, n) printf(""%d%c"", a[_], _==n-1?\'\\n\': \' \')\n\n#define Ttimes int T; scanf(""%d"", &T); while(T--)\n\nconst int maxn = 100000 + 10;\n\nint main() {\n    string s; cin >> s;\n    long long c[2][2]={{}};\n    for(int i = 0; i < s.length(); ++i) {\n        int j = i&1;\n        int k = s[i]-\'a\';\n        c[j][k]++;\n    }\n\n\n    long long a1 = 0, a2 = 0;\n    for(int i = 0; i < 2; ++i)\n        for(int j = 0; j < 2; ++j) {\n            a1 += c[i][j] * (c[i][j] - 1) / 2;\n            a1 += c[i][j];\n        }\n    a2 += c[0][0] * c[1][0];\n    a2 += c[0][1] * c[1][1];\n\n    cout << a2 << \' \' << a1 << endl;\n    return 0;\n}']",['math'],2000
https://codeforces.com//contest/1067/problem/D,D. Computer Game,Ivan plays some computer game There are n quests in the game Each quest can be upgraded once this increases the reward for its completion Each quest has 3 parameters a i b i p i reward for completing quest before upgrade reward for completing quest after upgrade a i b i and probability of successful completing the quest Each second Ivan can try to complete one quest and he will succeed with probability p i In case of success Ivan will get the reward and opportunity to upgrade any one quest not necessary the one he just completed In case of failure he gets nothing Quests after completing Ivan has t seconds He wants to maximize expected value of his total gain after t seconds Help him to calculate this value ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 120000;\n\nint n;\nll t;\n\nld p[MAXN];\nll a[MAXN];\nvector<pair<ld, ld> > vv;\nld br[MAXN];\n\nld eps1 = 1e-12;\n\nbool bad(pair<ld, ld> a, pair<ld, ld> b, pair<ld, ld> c) {\n\treturn (b.second - a.second) / (a.first - b.first) >= (c.second - b.second) / (b.first - c.first);\n}\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\tscanf(""%d%lld"", &n, &t);\n\tld b = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tll B;\n\t\tscanf(""%lld%lld%Lf"", a + i, &B, p + i);\n\t\tb = max(b, B * p[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (p[i] != 0) {\n\t\t\tvv.emplace_back(1 - p[i], b - p[i] * a[i]);\n\t\t}\n\t}\n\tif (vv.size() == 0) {\n\t\tcout << 0 << ""\\n"";\n\t\treturn 0;\n\t}\n\tsort(ALL(vv));\n\treverse(ALL(vv));\n\tvector<pair<ld, ld>> st;\n\tfor (auto p: vv) {\n\t\tif (!st.empty() && abs(st.back().first - p.first) <= eps1) {\n\t\t\tif (st.back().second < p.second)\n\t\t\t\tcontinue;\n\t\t\tst.pop_back();\n\t\t}\n\t\twhile (st.size() >= 2 && bad(st[st.size() - 2], st[st.size() - 1], p))\n\t\t\tst.pop_back();\n\t\tst.push_back(p);\n\t}\n\tld k = 0;\n\tint now = 0;\n\tfor (int i = 0; i + 1 < st.size(); ++i)\n\t\tbr[i] = (st[i + 1].second - st[i].second) / (st[i].first - st[i + 1].first);\n\tll tmpt = t;\n\twhile (t) {\n\t\twhile (now + 1 < st.size() && br[now] <= k)\n\t\t\t++now;\n\t\tvector<pair<ld, ld>> go;\n\t\tgo.push_back(st[now]);\n\t\tfor (int i = 0; i < 40; ++i)\n\t\t\tgo.emplace_back(go.back().first * go.back().first, go.back().second * (1 + go.back().first));\n\t\tfor (int i = go.size() - 1; i >= 0; --i) {\n\t\t\tif ((1ll << i) <= t && (now + 1 == st.size() || go[i].first * k + go[i].second <= br[now])) {\n\t\t\t\tt -= (1ll << i);\n\t\t\t\tk = go[i].first * k + go[i].second;\n\t\t\t}\n\t\t}\n\t\tif (t) {\n\t\t\tk = go[0].first * k + go[0].second;\n\t\t\t--t;\n\t\t}\n\t}\n\tcout << tmpt * b - k << ""\\n"";\n\treturn 0;\n}\n\n\n']","['dp', 'greedy', 'math', 'probabilities']",3100
https://codeforces.com//contest/1105/problem/C,C. Ayoub and Lost Array,Ayoub had an array a of integers of size n and this array had two interesting properties All the integers in the array were between l and r inclusive The sum of all the elements was divisible by 3 Unfortunately Ayoub has lost his array but he remembers the size of the array n and the numbers l and r so he asked you to find the number of ways to restore the array Since the answer could be very large print it modulo 10 9 7 i e the remainder when dividing by 10 9 7 In case there are no satisfying arrays Ayoub has a wrong memory print 0 ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch=\'*\'; (ch<\'0\'||ch>\'9\')&&ch!=\'-\'; ch=getchar());\n    if(ch==\'-\') fu=1, ch=getchar();\n    for(v=0; ch>=\'0\'&&ch<=\'9\'; ch=getchar()) v=v*10+ch-\'0\';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint n,l,r;\nLL ans,f[200010][3],s[3];\nint main(){\n//\tfreopen(""t.in"",""r"",stdin);\n//\tfreopen(""t.out"",""w"",stdout);\n\tcin>>n>>l>>r;\n\t--l;\n\ts[0]=r/3-l/3;\n\ts[1]=(r+2)/3-(l+2)/3;\n\ts[2]=(r+1)/3-(l+1)/3;\n\tf[0][0]=1;\n\tFOR(i,0,n-1)\n\t\tFOR(j,0,2)\n\t\t\tif (f[i][j]){\n\t\t\t\tFOR(k,0,2)\n\t\t\t\t\t(f[i+1][(j+k)%3]+=f[i][j]*s[k])%=MO;\n\t\t\t}\n\tans=(f[n][0]%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math']",1500
https://codeforces.com//contest/711/problem/D,D. Directed Roads,ZS the Coder and Chris the Baboon has explored Udayland for quite some time They realize that it consists of towns numbered from to There are directed roads in the Udayland th of them goes from town to some other town ZS the Coder can flip the direction of any road in Udayland i e if it goes from town to town before the flip it will go from town to town after ZS the Coder considers the roads in the Udayland if there is a sequence of distinct towns such that for every there is a road from town to town and another road from town to town In other words the roads are confusing if form a directed cycle of some towns Now ZS the Coder wonders how many sets of roads there are variants in initial configuration can he choose to flip such that after flipping each road in the set exactly once the resulting network will be confusing Note that it is allowed that after the flipping there are more than one directed road from some town and possibly some towns with no roads leading out of it or multiple roads between any pair of cities ,"['#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int maxn = (int)1e6;\nconst int inf = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll INF = (ll)1e18;\nconst double eps = 1e-9;\n\nint n, a[200200];\nvector<int> g[200200];\nbool used[200200];\nint sz[200200];\nint col[200200];\nint T = 0;\n\nvoid dfs(int v, int c) {\n\tif (col[v] == c) return;\n\tcol[v] = c;\n\tsz[c]++;\n\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\tdfs(g[v][i], c);\n\t}\n}\n\nint szv = 0, v[200200], p[200200];\nint ex[200200];\n\nint main()\n{\n\n\tex[0] = 1;\n\tfor (int i = 1; i < 200200; i++) {\n\t\tex[i] = 2 * ex[i - 1];\n\t\tif (ex[i] >= mod) ex[i] -= mod;\n\t}\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", a + i);\n\t\ta[i]--;\n\t\tg[i].pb(a[i]);\n\t\tg[a[i]].pb(i);\n\t}\n\t\n\tmemset(col, -1, sizeof col);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i, T);\n\t\t\tT++;\n\t\t}\n\t}\n\t\n\tint ans = 1;\n\tmemset(p, -1, sizeof p);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!used[col[i]]) {\n\t\t\tused[col[i]] = 1;\n\t\t\tint j = i;\n\t\t\tint cnt = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (p[j] != -1) break;\n\t\t\t\tp[j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t\tj = a[j];\n\t\t\t}\n\t\t\tint m = cnt - p[j];\n\t\t\tint cur = ex[m] - 2;\n\t\t\tif (cur < 0) cur += mod;\n\t\t\tint c = sz[col[i]] - m;\n\t\t\tcur = 1ll * cur * ex[c] % mod;\n\t\t\tans = 1ll * ans * cur % mod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}\n']","['combinatorics', 'dfs and similar', 'graphs', 'math']",1900
https://codeforces.com//contest/1619/problem/F,F. Let's Play the Hat ,n people gathered in a room with m tables n ge 2m They want to play the Hat k times Thus k games will be played at each table Each player will play in k games To do this they are distributed among the tables for each game During each game one player plays at exactly one table A player can play at different tables Players want to have the most fair schedule of games For this reason they are looking for a schedule table distribution for each game such that At any table in each game there are either lfloor frac n m rfloor people or lceil frac n m rceil people that is either n m rounded down or n m rounded up Different numbers of people can play different games at the same table Let s calculate for each player the value b i the number of times the i th player played at a table with lceil frac n m rceil persons n m rounded up Any two values of b imust differ by no more than 1 In other words for any two players i and j it must be true b i b j le 1 For example if n 5 m 2 and k 2 then at the request of the first item either two players or three players should play at each table Consider the following schedules First game 1 2 3 are played at the first table and 4 5 at the second one The second game at the first table they play 5 1 and at the second 2 3 4 This schedule is since b 2 2 the second player played twice at a big table and b 5 0 the fifth player did not play at a big table First game 1 2 3 are played at the first table and 4 5 at the second one The second game at the first table they play 4 5 2 and at the second one 1 3 This schedule is b 1 2 1 1 1 any two values of b i differ by no more than 1 Find any fair game schedule for n people if they play on the m tables of k games ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,n,m,k,pik,arv,su,ms,va,mv,x,l;\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n>>m>>k;\n        va=n/m; su=(n+m-1)/m;\n        if(va==su) mv=m;\n        else ms=n-m*va,mv=m-ms;\n        arv=min(ms*su,mv*va);\n        x=0;\n        for(int i=0; i<k; i++){\n            l=x;\n            l%=n;\n            for(int j=0; j<m; j++) if(j<ms){\n                cout<<su<<"" "";\n                for(int u=0; u<su; u++){\n                    cout<<l+1<<"" "";\n                    l++;\n                    l%=n;\n                }\n                cout<<""\\n"";\n            }\n            else{\n                cout<<va<<"" "";\n                for(int u=0; u<va; u++){\n                    cout<<l+1<<"" "";\n                    l++;\n                    l%=n;\n                }\n                cout<<""\\n"";\n            }\n            x+=arv;\n        }\n    }\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'math']",2000
https://codeforces.com//contest/1312/problem/D,D. Count the Arrays,Your task is to calculate the number of arrays such that each array contains n elements each element is an integer from 1 to m for each array there is one pair of equal elements for each array a there exists an index i such that the array is before the i th element and after it formally it means that a j a j 1 if j i and a j a j 1 if j ge i ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = 998244353;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nconst int maxN = 2 * (int)1e5 + 100;\n\nint fact[maxN], invfact[maxN], inv[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\nint invNumber(int a) {\n    return pw(a, mod - 2);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    init();\n    int n, m;\n    cin >> n >> m;\n    if (n == 2) {\n        cout << 0;\n        return 0;\n    }\n    cout << mult(pw(2, n - 3), mult(cnk(m, n - 1), n - 2));\n    return 0;\n}']","['combinatorics', 'math']",1700
https://codeforces.com//contest/1421/problem/E,E. Swedish Heroes,While playing yet another strategy game Mans has recruited n Swedish heroes whose powers which can be represented as an array a Unfortunately not all of those mighty heroes were created as capable as he wanted so that he decided to do something about it In order to accomplish his goal he can pick two consecutive heroes with powers a i and a i 1 remove them and insert a hero with power a i a i 1 back in the same position For example if the array contains the elements 5 6 7 8 he can pick 6 and 7 and get 5 6 7 8 5 13 8 After he will perform this operation n 1 times Mans will end up having only one hero He wants his power to be as big as possible What s the largest possible power he can achieve ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing llint = long long;\n\ninline void err() { cerr << endl; }\n\ntemplate<typename hd, typename... tl> void err(hd a, tl... b) {\n#ifdef KH_CODE\n\tcerr << a << \' \'; err(b...);\n#endif\n}\n\ntemplate<typename hd, typename tl> void chkmin(hd& a, tl b) {\n\tif(b < a) a = b;\n}\n\ntemplate<typename hd, typename tl> void chkmax(hd& a, tl b) {\n\tif(a < b) a = b;\n}\n\nconst int MX = 200005;\n\nllint a[MX];\nvector <pair<llint, int>> V;\nvector<int> buf;\n\nint main() {\n#ifdef KH_CODE\n\tfreopen(""in.txt"", ""r"", stdin);\n\tfreopen(""out.txt"", ""w"", stdout);\n#endif\n\n\tios_base::sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tllint tot = 0, rlt = -LLONG_MAX;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ttot += a[i];\n\t\tV.push_back({a[i], i});\n\t}\n\tif(n == 1) cout << a[0] << endl;\n\telse if(n == 2) cout << -(a[0] + a[1]) << endl;\n\telse if(n == 3) cout << max(a[0] + a[1] - a[2], a[2] + a[1] - a[0]) << endl;\n\telse {\n\t\tsort(V.begin(), V.end());\n\t\tint s = 2 - n % 3;\n\t\ts = n - s;\n\t\ts %= 3;\n\t\tint c = 0;\n\t\tllint cur = 0;\n\t\twhile(s <= n) {\n\t\t\twhile(c < s) cur += V[c++].first;\n\t\t\tif(abs(s * 2 - n) <= 1) {\n\t\t\t\tllint tp = 0;\n\t\t\t\tbuf.clear();\n\t\t\t\tfor(int i = 0; i < s; i++) {\n\t\t\t\t\ttp += V[i].first;\n\t\t\t\t\tbuf.push_back(V[i].second);\n\t\t\t\t}\n\t\t\t\tsort(buf.begin(), buf.end());\n\t\t\t\tbool ok = 0;\n\t\t\t\tfor(int i = 0; i < buf.size() - 1; i++) if(buf[i + 1] - buf[i] != 2) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ok) rlt = max(rlt, tot -  tp * 2);\n\t\t\t\telse rlt = max(rlt, tot - 2 * (tp - V[s - 1].first + V[s].first));\n\t\t\t}\n\t\t\telse rlt = max(rlt, tot - 2 * cur);\n\t\t\ts += 3;\n\t\t}\n\t\tcout << rlt << endl;\n\t}\n\n\treturn 0;\n}\n\n']","['brute force', 'dp', 'implementation']",2700
https://codeforces.com//contest/468/problem/B,B. Two Sets,Little X has distinct integers He wants to divide all of them into two sets and The following two conditions must be satisfied If number belongs to set then number must also belong to set If number belongs to set then number must also belong to set Help Little X divide the numbers into two sets or determine that it s impossible ,"['//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""[""#x""] Time : %.3lf s.\\n"", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(""["" x ""] Time : %.3lf s.\\n"", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""B""\n\n#ifdef LOCAL\nstatic struct __timestamper {\n    string what;\n    __timestamper(const char* what) : what(what){};\n    __timestamper(const string& what) : what(what){};\n    ~__timestamper(){\n        TIMESTAMPf(""%s"", what.data());\n    }\n} __TIMESTAMPER(""end"");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\n\nconst int MAXN = 110000;\nint p[MAXN];\nint can[2][MAXN];\n\nint get(int a) {\n    if (a == p[a]) return a;\n    return p[a] = get(p[a]);\n}\n\n\nvoid join(int a, int b) {\n    a = get(a);\n    b = get(b);\n    p[a] = b;\n    can[0][b] &= can[0][a];\n    can[1][b] &= can[1][a];\n}\n\n\nint main(){\n  #ifdef LOCAL\n    assert(freopen(TASKNAME"".in"",""r"",stdin));\n    assert(freopen(TASKNAME"".out"",""w"",stdout));\n  #endif\n    int n, a, b;\n    scanf(""%d%d%d"",&n,&a,&b);\n    vector<pair<int,int>> v(n);\n    for (int i = 0; i < (int)v.size(); i++) \n        scanf(""%d"",&v[i].first), v[i].second = i;\n\n    for (int i = 0; i < n; i++)\n        p[i] = i, can[0][i] = can[1][i] = 1;\n\n    sort(v.begin(), v.end());\n\n    for (int i = 0; i < (int)v.size(); i++) {\n        int x = v[i].first;\n        {\n        int id = lower_bound(v.begin(), v.end(), mp(a - x, -1)) - v.begin();\n        if (id < (int)v.size() && v[id].first == a - x)\n            join(v[i].second, v[id].second);\n        else\n            can[0][get(v[i].second)] = 0;\n        }\n        {\n        int id = lower_bound(v.begin(), v.end(), mp(b - x, -1))  - v.begin();\n        if (id < (int)v.size() && v[id].first == b - x)\n            join(v[i].second, v[id].second);\n        else\n            can[1][get(v[i].second)] = 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n        if (!can[0][i] && !can[1][i] && p[i] == i) {\n            printf(""NO\\n"");\n            return 0;\n        }\n\n    printf(""YES\\n"");\n    for (int i = 0; i < n; i++)\n        printf(""%d%c"", can[1][get(i)], "" \\n""[i==n-1]);\n\n      \n    return 0;\n}']","['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",2000
https://codeforces.com//contest/1797/problem/A,A. Li Hua and Maze,There is a rectangular maze of size n times m Denote r c as the cell on the r th row from the top and the c th column from the left Two cells are if they share an edge A is a sequence of empty cells Each cell is initially empty Li Hua can choose some cells except x 1 y 1 and x 2 y 2 and place an obstacle in each of them He wants to know the minimum number of obstacles needed to be placed so that there isn t a from x 1 y 1 to x 2 y 2 Suppose you were Li Hua please solve this problem ,"[""// LUOGU_RID: 110066126\n#include<bits/stdc++.h>\n#define int long long\nconst int N=1e5+5,M=305;\nusing namespace std;\nint n,m,x,y,xx,yy,sum1,sum2;\nvoid solve()\n{\n\tcin>>n>>m;sum1=4;sum2=4;\n\tcin>>x>>y>>xx>>yy;\n\tif(x==1||x==n)sum1--;\n\tif(y==1||y==m)sum1--;\n\tif(xx==1||xx==n)sum2--;\n\tif(yy==1||yy==m)sum2--;\n\tcout<<min(sum1,sum2)<<'\\n';\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}""]","['constructive algorithms', 'flows', 'graphs', 'greedy', 'implementation']",800
https://codeforces.com//contest/710/problem/A,A. King Moves,The only king stands on the standard chess board You are given his position in format where is the column from a to h and is the row from 1 to 8 Find the number of moves permitted for the king Check the king s moves here https en wikipedia org wiki King chess ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <ctype.h>\n#include <deque>\n#include <queue>\n#include <cstring>\n#include <set>\n#include <list>\n#include <map>\n#include <random>\n#include <unordered_map>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<bool> vb;\ntypedef std::vector<string> vs;\ntypedef std::vector<double> vd;\ntypedef std::vector<long long> vll;\ntypedef std::vector<std::vector<int> > vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef std::vector<std::pair<int, int> > vpi;\ntypedef vector<vpi> vvpi;\ntypedef std::pair<int, int> pi;\ntypedef std::pair<ll, ll> pll;\ntypedef std::vector<pll> vpll;\n\nconst long long mod = 1000000007;\n\n#define all(c) (c).begin(),(c).end()\n#define sz(c) (int)(c).size()\n#define forn(i, a, b) for(int i = a; i < b; i++)\n\n#define pb push_back\n#define mp make_pair\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n    char c;\n    char d;\n    cin>>c>>d;\n    int a=0, b=0;\n    if(c==\'a\' || c==\'h\') a=1;\n    if(d==\'1\' || d==\'8\') b=1;\n    if(a+b==2) cout<<3;\n    else if(a+b==1) cout<<5;\n    else cout<<8;\n    \n    \n    \n}\n\n\n']",['implementation'],800
https://codeforces.com//contest/246/problem/E,E. Blood Cousins Return,Polycarpus got hold of a family tree The found tree describes the family relations of people numbered from 1 to Every person in this tree has at most one direct ancestor Also each person in the tree has a name the names are not necessarily unique We call the man with a number a 1 ancestor of the man with a number if the man with a number is a direct ancestor of the man with a number We call the man with a number a ancestor of the man with a number if the man with a number has a 1 ancestor and the man with a number is a ancestor of the 1 ancestor of the man with a number In the tree the family ties do not form cycles In other words there isn t a person who is his own direct or indirect ancestor that is who is an ancestor of himself for some We call a man with a number the son of the man with a number if the man with a number is a ancestor of the man with a number Polycarpus is very much interested in how many sons and which sons each person has He took a piece of paper and wrote pairs of numbers Help him to learn for each pair the number of distinct names among all names of the sons of the man with number ,"['#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\nconst int maxn=1000*100*2;\nvi g[maxn], q[maxn], qi[maxn], rt;\nchar S[100000];\nstring s[maxn], ts[maxn];\nint n, m, nm[maxn], ans[maxn], l[maxn], zz;\nvector<set<int> > T[maxn];\nvoid mer(set<int> &l, set<int> &r)\n{\n    if (l.size()<r.size()) l.swap(r);\n    for (set<int>::iterator it=r.begin(); it!=r.end(); it++)\n        l.insert(*it);\n}\nint nh;\nvoid dfs(int v, int h=0)\n{\n    nh++;\n    for (int i=0;i<q[v].size();i++)\n    {\n        int th=h+q[v][i];\n        l[qi[v][i]]=T[th].size();\n    }\n    set<int> tst;\n    tst.insert(lower_bound(ts, ts+zz, s[v])-ts);\n    T[h].push_back(tst);\n    for (int i=0; i<g[v].size(); i++)\n        dfs(g[v][i], h+1);\n    for (int i=0;i<q[v].size();i++)\n    {\n        int th=h+q[v][i], tl=l[qi[v][i]], tr=T[th].size();\n        if (tl==tr) continue;\n        for (int j=tr-1; j-1>=tl; j--)\n        {\n            mer(T[th][j-1], T[th][j]);\n            T[th].pop_back();\n        }\n        ans[qi[v][i]]=T[th][tl].size();\n    }\n}\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i=0; i<n;i++)\n    {\n        int p; scanf(""%s %d"", S, &p);\n        s[i]=ts[i]=string(S, S+strlen(S));\n        p--;\n        if (p!=-1) g[p].push_back(i); else rt.push_back(i);\n    }\n    scanf(""%d"", &m);\n    for (int i=0; i<m; i++)\n    {\n        int v, k;\n        scanf(""%d %d"", &v, &k);\n        v--;\n        q[v].push_back(k);\n        qi[v].push_back(i);\n    }\n    sort(ts, ts+n); zz=unique(ts, ts+n)-ts;\n    for (int i=0; i<rt.size(); i++) dfs(rt[i], nh);\n    for (int i=0; i<m; i++) printf(""%d\\n"", ans[i]);\n    return 0;\n}\n']","['binary search', 'data structures', 'dfs and similar', 'dp', 'sortings']",2400
https://codeforces.com//contest/1780/problem/E,E. Josuke and Complete Graph,Josuke received a huge undirected weighted complete dagger graph G as a gift from his grandfather The graph contains 10 18 vertices The peculiarity of the gift is that the weight of the edge between the different vertices u and v is equal to gcd u v ddagger Josuke decided to experiment and make a new graph G To do this he chooses two integers l le r and deletes all vertices except such vertices v that l le v le r and also deletes all the edges except between the remaining vertices Now Josuke is wondering how many different weights are there in G Since their count turned out to be huge he asks for your help dagger A complete graph is a simple undirected graph in which every pair of distinct vertices is adjacent ddagger gcd x y denotes the greatest common divisor GCD of the numbers x and y ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n    ll l, r;\n    cin >> l >> r;\n    l--;\n    ll ans = 0;\n    for (int i = 1, j; i <= l; i = j + 1) {\n        j = l / (l / i);\n        ll need = l / i + 2;\n        ans += min<ll>(j, r / need);\n        ans -= min<ll>(i - 1, r / need);\n    }\n    ans += max<ll>(0, r / 2 - l);\n    cout << ans << ""\\n"";\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}']","['binary search', 'brute force', 'data structures', 'math', 'number theory']",2400
https://codeforces.com//contest/796/problem/F,F. Sequence Recovery,Zane once had a sequence consisting of integers but he has lost it A sequence is said to be if and only if all of its integers are non negative and do not exceed in value However Zane remembers having played around with his sequence by applying operations to it There are two types of operations 1 Find the maximum value of integers with indices such that given and 2 Assign as the value of the integer with index given and After he finished playing he restored his sequence to the state it was before any operations were applied That is sequence was no longer affected by the applied type 2 operations Then he lost his sequence at some time between now and then Fortunately Zane remembers all the operations and the order he applied them to his sequence along with the results of all type 1 operations Moreover among all sequences that would produce the same results when the same operations are applied in the same order he knows that his sequence has the greatest We define of a sequence as the bitwise OR result of all integers in such sequence For example the of Zane s sequence is Zane understands that it might not be possible to recover exactly the lost sequence given his information so he would be happy to get any sequence consisting of integers that 1 would give the same results when the same operations are applied in the same order and2 has the same as that of Zane s original sequence If there is such a sequence find it Otherwise it means that Zane must have remembered something incorrectly which is possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define oo 1000000010\n#define mod 1000000007\nconst int N = 300010;\nint n , m ;\n\nint t[N] , l[N] , r[N] , x[N];\n\nint arr[N];\n\nint cnt = 0;\n\nint seg[4 * N];\n\nbool done[N];\n\nint Mx;\n\nint build(int s,int e,int idx){\n    if(s == e)\n        return seg[idx] = arr[s];\n    return seg[idx] = max(build(s,((s+e) >> 1),(idx << 1)),build(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nint L , R , val;\n\nvoid update2(int s,int e,int idx){\n    if(s > R || e < L) return;\n    if(s >= L && e <= R){\n        seg[idx] = min(seg[idx] , val);\n        return;\n    }\n    update2(s,((s+e) >> 1),(idx << 1));\n    update2(((s+e) >> 1) + 1,e,(idx << 1) + 1);\n}\n\nint get2(int i){\n    int s = 0 , e = n - 1 , res = Mx , idx = 1;\n    while(true){\n        res = min(res , seg[idx]);\n        if(s == e) break;\n        if(i > ((s + e) >> 1)){\n            s = ((s + e) >> 1) + 1;\n            idx = (idx << 1) + 1;\n        }\n        else{\n            e = ((s+e) >> 1);\n            idx = (idx << 1);\n        }\n    }\n    return res;\n}\n\nint update(int s,int e,int idx){\n    if(s > R || e < L) \n        return seg[idx];\n    if(s == e)\n        return seg[idx] = val;\n    return seg[idx] = max(update(s,((s+e) >> 1),(idx << 1)) , update(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nint getmax(int s,int e,int idx){\n    if(s > R || e < L)\n        return 0;\n    if(s >= L && e <= R)\n        return seg[idx];\n    return max(getmax(s,((s+e) >> 1),(idx << 1)) , getmax(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nbool check(int Val){\n    Mx = Val;\n    for(int i = 0 ;i < n;i++) \n        arr[i] = Val , done[i] = false;\n    build(0,n-1,1);\n    for(int i = 0 ;i < m;i++){\n        if(t[i] == 2){\n            if(done[l[i]]) continue;\n            arr[l[i]] = get2(l[i]);\n            done[l[i]] = true;\n            continue;\n        }\n        L = l[i] , R = r[i] , val = x[i];\n        update2(0, n - 1 , 1);\n    }\n    for(int i = 0 ;i < n;i++){\n        if(!done[i])\n            arr[i] = get2(i);\n    }\n    build(0,n-1,1);\n    for(int i = 0 ;i < m;i++){\n        if(t[i] == 2){\n            L = R = l[i];\n            val = x[i];\n            update(0,n-1,1);\n        }\n        else{\n            L = l[i] , R = r[i];\n            if(getmax(0,n-1,1) != x[i])\n                return false;\n        }\n    }\n    return true;\n}\n\nmap < int , bool > Done;\n\ninline int get(int val){\n    for(int i = 29 ;i >= 0 ;i--){\n        if(((val >> i) & 1) == 1)\n            return (1 << i) - 1;\n    }\n    return 0; \n}\n\nint main(){\n    scanf(""%d%d"",&n,&m);\n    for(int i = 0 ;i < m;i++){\n        scanf(""%d%d%d"",&t[i],&l[i],&r[i]);\n        if(t[i] == 1){\n            l[i]--,r[i]--;\n            scanf(""%d"",&x[i]);\n        }\n        else{\n            x[i] = r[i];\n            l[i]--;\n            r[i] = l[i];\n        }\n    }\n    int val = (int)1e9 + 1;\n    if(!check(val)){\n        puts(""NO"");\n        return 0;\n    }\n    puts(""YES"");\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] == val) continue;\n        if(Done[arr[i]]){\n            arr[i] = get(arr[i]);\n            continue;\n        }\n        Done[arr[i]] = true;\n    }\n    int o = 0;\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] == val){\n            continue;\n        }\n        o |= arr[i];\n    }\n    o ^= ((1 << 30) - 1);\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] != val) continue;\n        arr[i] = 0;\n        for(int j = 29 ;j >=0 ;j--){\n            if(((o >> j) & 1) == 0) continue;\n            if((arr[i] ^ (1 << j)) >= val) continue;\n            arr[i] ^= (1 << j);\n            o ^= (1 << j);\n        }\n    }\n\n    for(int i = 0 ;i < n;i++){\n        if(i) putchar(\' \');\n        printf(""%d"",arr[i]);\n    }\n    puts("""");\n    return 0;\n}']","['bitmasks', 'data structures', 'greedy']",2800
https://codeforces.com//contest/1499/problem/E,E. Chaotic Merge,You are given two strings x and y both consist only of lowercase Latin letters Let s be the length of string s Let s call a sequence a a merging sequence if it consists of exactly x zeros and exactly y ones in some order A merge z is produced from a sequence a by the following rules if a i 0 then remove a letter from the beginning of x and append it to the end of z if a i 1 then remove a letter from the beginning of y and append it to the end of z Two merging sequences a and b are different if there is some position i such that a i neq b i Let s call a string z if for all i from 2 to z z i 1 neq z i Let s l r for some 1 le l le r le s be a substring of consecutive letters of s starting from position l and ending at position r inclusive Let f l 1 r 1 l 2 r 2 be the number of different merging sequences of x l 1 r 1 and y l 2 r 2 that produce merges Note that only non empty substrings of x and y are considered Calculate sum limits 1 le l 1 le r 1 le x 1 le l 2 le r 2 le y f l 1 r 1 l 2 r 2 Output the answer modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N, M;\nchar X[1010];\nchar Y[1010];\n\nll D[1010][1010];\nll E[1010][1010];\n\nint main() {\n\tscanf(""%s"", X + 1);\n\tscanf(""%s"", Y + 1);\n\tN = strlen(X + 1);\n\tM = strlen(Y + 1);\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tD[i][0] = (X[i] == X[i - 1] ? 0 : D[i - 1][0]) + 1;\n\t}\n\tfor(int i = 1; i <= M; i++) {\n\t\tE[0][i] = (Y[i] == Y[i - 1] ? 0 : E[0][i - 1]) + 1;\n\t}\n\n\tll ans = 0;\n\tfor(int i = 1; i <= N; i++) {\n\t\tfor(int j = 1; j <= M; j++) {\n\t\t\tif(X[i] != X[i - 1]) D[i][j] = D[i - 1][j];\n\t\t\tif(X[i] != Y[j]) {\n\t\t\t\tD[i][j] = (D[i][j] + E[i - 1][j]) % MOD;\n\t\t\t\tif(i > 1) D[i][j] = (D[i][j] + E[0][j]) % MOD;\n\t\t\t}\n\t\t\tif(Y[j] != Y[j - 1]) E[i][j] = E[i][j - 1];\n\t\t\tif(X[i] != Y[j]) {\n\t\t\t\tE[i][j] = (E[i][j] + D[i][j - 1]) % MOD;\n\t\t\t\tif(j > 1) E[i][j] = (E[i][j] + D[i][0]) % MOD;\n\t\t\t}\n\t\t\tans = (ans + D[i][j] + E[i][j]) % MOD;\n\t\t}\n\t}\n\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}']","['combinatorics', 'dp', 'math', 'strings']",2400
https://codeforces.com//contest/495/problem/A,A. Digital Counter,Malek lives in an apartment block with floors numbered from to The apartment has an elevator with a digital counter showing the floor that the elevator is currently on The elevator shows each digit of a number with light sticks by turning them on or off The picture below shows how the elevator shows each digit One day when Malek wanted to go from floor to floor using the elevator he noticed that the counter shows number instead of Then when the elevator started moving the number on the counter changed to After a little thinking Malek came to the conclusion that there is only one explanation for this One of the sticks of the counter was broken Later that day Malek was thinking about the broken stick and suddenly he came up with the following problem Suppose the digital counter is showing number Malek calls an integer if it s possible that the digital counter was supposed to show but because of some possibly none broken sticks it s showing instead Malek wants to know number of good integers for a specific So you must write a program that calculates this number Please note that the counter shows two digits ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\nint val[10]={127-2,16+64,127-8-64,127-8-32,127-1-4-32,127-16-32,127-16,1+16+64,127,127-32};\nint n;\nint main()\n{\n    scanf(""%d"",&n);\n    int d1=(n/10),d2=(n%10),cnt1=0,cnt2=0;\n    for(int i=0;i<10;i++) if((val[d1]&val[i])==val[d1]) cnt1++;\n    for(int i=0;i<10;i++) if((val[d2]&val[i])==val[d2]) cnt2++;\n    printf(""%d\\n"",cnt1*cnt2);\n    return 0;\n}\n']",['implementation'],1100
https://codeforces.com//contest/1028/problem/B,B. Unnatural Conditions,Let s x be sum of digits in decimal representation of positive integer x Given two integers n and m find some positive integers a and b such that s a ge n s b ge n s a b le m ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tint k = 200;\n\tfor (int i = 0; i < k; ++i)\n\t\tcout << 9;\n\tfor (int i = 0; i < k - 1; ++i)\n\t\tcout << 0;\n\tcout << 1 << ""\\n"";\n\tfor (int i = 0; i < k; ++i)\n\t\tcout << 9;\n\tcout << ""\\n"";\n\treturn 0;\n}\n\n\n']","['constructive algorithms', 'math']",1200
https://codeforces.com//contest/374/problem/A,A. Inna and Pink Pony,Dima and Inna are doing so great At the moment Inna is sitting on the magic lawn playing with a pink pony Dima wanted to play too He brought an chessboard a very tasty candy and two numbers and Dima put the chessboard in front of Inna and placed the candy in position on the board The boy said he would give the candy if it reaches one of the corner cells of the board He s got one more condition There can only be actions of the following types move the candy from position on the board to position move the candy from position on the board to position move the candy from position on the board to position move the candy from position on the board to position Naturally Dima doesn t allow to move the candy beyond the chessboard borders Inna and the pony started shifting the candy around the board They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position to one of the chessboard corners Help them cope with the task ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint n, m, x, y, a, b , ans;\n\nint dist(int xx, int yy) {\n    if (xx % a != x % a || yy % b != y % b) return 1000000000;\n    int res = abs(xx - x) / a + abs(yy - y) / b;\n    return res % 2 ? 1000000000 : max(abs(xx - x) / a, abs(yy - y) / b);\n}\n\n\nint main() {\n    cin >> n >> m >> x >> y >> a >> b;\n\n    if (x == 1 && y == 1 || x == 1 && y == m || x == n && y == 1 || x == n && y == m) {\n        cout << ""0\\n"";\n        return 0;\n    }\n\n    if (x + a > n && x - a < 1 || y + b > m && y - b < 1) {\n        cout << ""Poor Inna and pony!\\n"";\n        return 0;\n    }\n    int ans = min(min(dist(1, 1), dist(1, m)), min(dist(n, 1), dist(n, m)));\n    if (ans == 1000000000) cout << ""Poor Inna and pony!\\n"";\n    else cout << ans << ""\\n"";\n\n    return 0;\n}\n']","['greedy', 'implementation']",2000
https://codeforces.com//contest/988/problem/D,D. Points and Powers of Two,There are n distinct points on a coordinate line the coordinate of i th point equals to x i Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two It is necessary to consider each pair of points not only adjacent Note that any subset containing one element satisfies the condition above Among all these subsets choose a subset with maximum possible size In other words you have to choose the maximum possible number of points x i 1 x i 2 dots x i m such that for each pair x i j x i k it is true that x i j x i k 2 d where d is some non negative integer number not necessarily the same for each pair of points ,"['/// In The Name Of God\n\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl \'\\n\'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)5e5 + 7;\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint n;\nll a[N];\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (""in.txt"", ""r"", stdin);\n\t#endif\n\tKazakhstan\n\tcin >> n;\n\tset <ll> st;\n\trep(i, 1, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tst.insert(x);\n\t}\n\tn = 0;\n\tfor (auto it : st) a[++n] = it;\n\trep(i, 1, n) {\n\t\tll x = 1;\n\t\trep(d, 0, 30) {\n\t\t\tif (st.count(a[i] + x) && st.count(a[i] + x + x)) cout << 3 << nl << a[i] << \' \' << a[i] + x << \' \' << a[i] + x + x, ioi\n\t\t\tx *= 2;\n\t\t}\n\t}\n\trep(i, 1, n) {\n\t\tll x = 1;\n\t\trep(d, 0, 30) {\n\t\t\tif (st.count(a[i] + x)) cout << 2 << nl << a[i] << \' \' << a[i] + x, ioi\n\t\t\tx *= 2;\n\t\t}\n\t}\n\tcout << 1 << nl << a[1];\n\tioi\n}\n']","['brute force', 'math']",1800
https://codeforces.com//contest/1207/problem/B,B. Square Filling,You are given two matrices A and B Each matrix contains exactly n rows and m columns Each element of A is either 0 or 1 each element of B is initially 0 You may perform some operations with matrix B During each operation you choose any submatrix of B having size 2 times 2 and replace every element in the chosen submatrix with 1 In other words you choose two integers x and y such that 1 le x n and 1 le y m and then set B x y B x y 1 B x 1 y and B x 1 y 1 to 1 Your goal is to make matrix B equal to matrix A Two matrices A and B are equal if and only if every element of matrix A is equal to the corresponding element of matrix B Is it possible to make these matrices equal If it is you have to come up with a sequence of operations that makes B equal to A Note that you don t have to minimize the number of operations ,"['#include <bits/stdc++.h>\nusing namespace std;\nint a[55][55], b[55][55];\nint main() {\n    ios :: sync_with_stdio(0);\n    int n, m;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= m; j++) cin >> a[i][j];\n    int ans = 0;\n    for(int i = 1; i < n; i++) {\n        for(int j = 1; j < m; j++) {\n            if(a[i][j] + a[i + 1][j] + a[i][j + 1] + a[i + 1][j + 1] == 4) {\n                b[i][j] = 1, b[i + 1][j] = 1, b[i][j + 1] = 1, b[i + 1][j + 1] = 1;\n                ans++;\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++) if(a[i][j] ^ b[i][j]) return puts(""-1""), 0;\n    cout << ans << endl;\n    for(int i = 1; i < n; i++) {\n        for(int j = 1; j < m; j++) {\n            if(a[i][j] + a[i + 1][j] + a[i][j + 1] + a[i + 1][j + 1] == 4) {\n                cout << i << \' \' << j << endl;\n            }\n        }\n    }\n}']","['constructive algorithms', 'greedy', 'implementation']",1200
https://codeforces.com//contest/1520/problem/A,A. Do Not Be Distracted ,Polycarp has 26 tasks Each task is designated by a capital letter of the Latin alphabet The teacher asked Polycarp to solve tasks in the following way if Polycarp began to solve some task then he must solve it to the end without being distracted by another task After switching to another task Polycarp cannot return to the previous task Polycarp can only solve one task during the day Every day he wrote down what task he solved Now the teacher wants to know if Polycarp followed his advice For example if Polycarp solved tasks in the following order then the teacher will see that on the third day Polycarp began to solve the task then on the fifth day he got distracted and began to solve the task on the eighth day Polycarp returned to the task Other examples of when the teacher is suspicious and If Polycarp solved the tasks as follows then the teacher cannot have any suspicions Please note that Polycarp is not obligated to solve all tasks Other examples of when the teacher doesn t have any suspicious and Help Polycarp find out if his teacher might be suspicious ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl ""\\n""\n\n#define sz(x) int((x).size())\n\nvoid solve() {\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tbool vis[26] {};\n\tint prev = -1;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x = s[i] - \'A\';\n\t\tif(vis[x] && prev != x) {\n\t\t\tcout << ""NO"" << endl;\n\t\t\treturn;\n\t\t}\n\t\tvis[x] = true;\n\t\tprev = x;\n\t}\n\tcout << ""YES"" << endl;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']","['brute force', 'implementation']",800
https://codeforces.com//contest/294/problem/E,E. Shaass the Great,The great Shaass is the new king of the Drakht empire The empire has cities which are connected by bidirectional roads Each road has an specific length and connects a pair of cities There s a unique simple path connecting each pair of cities His majesty the great Shaass has decided to tear down one of the roads and build another road with the same length between some pair of cities He should build such road that it s still possible to travel from each city to any other city He might build the same road again You as his advisor should help him to find a way to make the described action You should find the way that minimize the total sum of pairwise distances between cities after the action So calculate the minimum sum ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nstruct Edge\n{\n    int from, to, len, next;\n}edge[4999 * 2];\nint head[5000], L;\nvoid init(int n)\n{\n    memset(head, -1, 4 * n);\n    L = 0;\n}\nvoid add_edge(int u, int v, int len)\n{\n    edge[L].from = u;\n    edge[L].to = v;\n    edge[L].len = len;\n    edge[L].next = head[u];\n    head[u] = L++;\n}\nint size[5000];\nlong long dp[5000];\nvoid dfs(int u, int fu)\n{\n    size[u] = 1;\n    dp[u] = 0;\n    for (int i = head[u]; i != -1; i = edge[i].next)\n    {\n        int v = edge[i].to;\n        if (v == fu)\n            continue;\n        dfs(v, u);\n        size[u] += size[v];\n        dp[u] += dp[v] + (long long)size[v] * edge[i].len;\n    }\n}\nlong long sum, tot;\nint m;\nvoid dfs2(int u, int fu)\n{\n    sum = min(sum, dp[u]);\n    for (int i = head[u]; i != -1; i = edge[i].next)\n    {\n        int v = edge[i].to;\n        if (v == fu)\n            continue;\n        tot += (long long)(m - size[v]) * size[v] * edge[i].len;\n        dp[v] = dp[u] + (long long)(m - size[v] * 2) * edge[i].len;\n        dfs2(v, u);\n    }\n}\nconst long long inf = 0x7f7f7f7f7f7f7f7fLL;\nint main()\n{\n    int n;\n    scanf(""%d"", &n);\n    init(n);\n    for (int i = 1; i < n; ++i)\n    {\n        int u, v, len;\n        scanf(""%d%d%d"", &u, &v, &len);\n        add_edge(--u, --v, len);\n        add_edge(v, u, len);\n    }\n    long long ans = inf;\n    for (int i = 0; i < n * 2 - 2; i += 2)\n    {\n//      edge[i].flag = edge[i ^ 1].flag = 1;\n        tot = 0;\n        sum = inf;\n        dfs(edge[i].from, edge[i].to);\n        m = size[edge[i].from];\n        dfs2(edge[i].from, edge[i].to);\n        tot += (long long)(n - m) * sum;\n        sum = inf;\n        dfs(edge[i].to, edge[i].from);\n        m = size[edge[i].to];\n        dfs2(edge[i].to, edge[i].from);\n        tot += (long long)(n - m) * sum;\n        tot += (long long)m * (n - m) * edge[i].len;\n        ans = min(tot, ans);\n//      edge[i].flag = edge[i ^ 1].flag = 0;\n    }\n    printf(""%I64d\\n"", ans);\n    return 0;\n}\n']","['dp', 'trees']",2300
https://codeforces.com//contest/1340/problem/C,C. Nastya and Unexpected Guest,On the way from Denis s house to the girl s house is a road of n lines This road can t be always crossed in one green light Foreseeing this the good mayor decided to place safety islands in some parts of the road Each safety island is located after a line as well as at the beginning and at the end of the road Pedestrians can relax on them gain strength and wait for a green light Denis came to the edge of the road exactly at the moment when the green light turned on The boy knows that the traffic light first lights up g seconds green and then r seconds red then again g seconds green and so on Formally the road can be represented as a segment 0 n Initially Denis is at point 0 His task is to get to point n in the shortest possible time He knows many different integers d 1 d 2 ldots d m where 0 leq d i leq n are the coordinates of points in which the safety islands are located Only at one of these points the boy can be at a time when the red light is on Unfortunately Denis isn t always able to control himself because of the excitement so some restrictions are imposed He must always move while the green light is on because it s difficult to stand when so beautiful girl is waiting for you Denis can change his position by pm 1 in 1 second While doing so he must always stay inside the segment 0 n He can change his direction only on the safety islands because it is safe This means that if in the previous second the boy changed his position by 1 and he walked on a safety island then he can change his position by pm 1 Otherwise he can change his position only by 1 Similarly if in the previous second he changed his position by 1 on a safety island he can change position by pm 1 and at any other point by 1 At the moment when the red light is on the boy must be on one of the safety islands He can continue moving in any direction when the green light is on Denis has crossed the road as soon as his coordinate becomes equal to n This task was not so simple because it s possible that it is impossible to cross the road Since Denis has all thoughts about his love he couldn t solve this problem and asked us to help him Find the minimal possible time for which he can cross the road according to these rules or find that it is impossible to do ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint N, M; cin >> N >> M;\n\tvector<int> X(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> X[i];\n\t}\n\tsort(X.begin(), X.end());\n\tassert(X[0] == 0);\n\tassert(X[M-1] == N);\n\n\tint G, R; cin >> G >> R;\n\tvector<bool> vis(M * G);\n\tvis[0] = true;\n\n\tvector<int> islands; islands.reserve(M);\n\tislands.push_back(0);\n\n\tvector<int> q; q.reserve(M*G);\n\n\tint ans = -1;\n\tfor (int T = 0; !islands.empty(); T++) {\n\t\tq.clear();\n\t\tfor (int i : islands) {\n\t\t\tq.push_back(i*G);\n\t\t}\n\t\tislands.clear();\n\n\t\tfor (int z = 0; z < int(q.size()); z++) {\n\t\t\tint cur = q[z];\n\t\t\tint i = cur / G;\n\t\t\tint t = cur % G;\n\t\t\tfor (int j : {i-1, i+1}) {\n\t\t\t\tif (!(0 <= j && j < M)) continue;\n\t\t\t\tint nt = t + abs(X[i] - X[j]);\n\t\t\t\tif (nt > G) continue;\n\n\t\t\t\tif (j == M-1) {\n\t\t\t\t\tint cnd = T * (G+R) + nt;\n\t\t\t\t\tif (ans == -1 || cnd < ans) {\n\t\t\t\t\t\tans = cnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nt == G) {\n\t\t\t\t\tnt = 0;\n\t\t\t\t}\n\n\t\t\t\tif (vis[j*G + nt]) continue;\n\t\t\t\tvis[j*G+nt] = true;\n\n\t\t\t\tif (nt) {\n\t\t\t\t\tq.push_back(j*G+nt);\n\t\t\t\t} else {\n\t\t\t\t\tislands.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n""]","['dfs and similar', 'dp', 'graphs', 'shortest paths']",2400
https://codeforces.com//contest/1083/problem/B,B. The Fair Nut and Strings,Recently the Fair Nut has written k strings of length n consisting of letters and He calculated c the number of strings that are prefixes of at least one of the written strings Then he lost his sheet with strings He remembers that all written strings were lexicographically than string s and than string t He is interested what is the maximum value of c that he could get A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll k;\n\nchar wcz[2][nax];\n\nll wyn;\n\nll dol=1, gor=1;\nll mie=0;\n\nint main()\n{\n\tscanf(""%d%lld"", &n, &k);\n\tfor (int h=0; h<2; h++)\n\t\tscanf(""%s"", wcz[h]+1);\n\tint w=1;\n\twhile(w<=n && wcz[0][w]==wcz[1][w])\n\t{\n\t\tw++;\n\t\twyn++;\n\t}\n\tif (w>n)\n\t{\n\t\tprintf(""%d\\n"", n);\n\t\treturn 0;\n\t}\n\tfor (int i=w; i<=n; i++)\n\t{\n\t\tif (i>w)\n\t\t{\n\t\t\tmie*=2;\n\t\t\tif (wcz[0][i]==\'a\')\n\t\t\t{\n\t\t\t\tmie+=dol;\n\t\t\t}\n\t\t\tif (wcz[1][i]==\'b\')\n\t\t\t{\n\t\t\t\tmie+=gor;\n\t\t\t}\n\t\t}\n\t\tdol=min(dol, k);\n\t\tgor=min(gor, k);\n\t\tmie=min(mie, k);\n\t\twyn+=min(dol+gor+mie, k);\n\t}\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['greedy', 'strings']",2000
https://codeforces.com//contest/723/problem/B,B. Text Document Analysis,Modern text editors usually show some information regarding the document being edited For example the number of words the number of pages or the number of characters In this problem you should implement the similar functionality You are given a string which only consists of uppercase and lowercase English letters underscore symbols they are used as separators parentheses both opening and closing It is guaranteed that each opening parenthesis has a succeeding closing parenthesis Similarly each closing parentheses has a preceding opening parentheses matching it For each pair of matching parentheses there are no other parenthesis between them In other words each parenthesis in the string belongs to a matching opening closing pair and such pairs can t be nested For example the following string is valid is a maximal sequence of consecutive letters i e such sequence that the first character to the left and the first character to the right of it is an underscore a parenthesis or it just does not exist For example the string above consists of seven words and Write a program that finds the length of the longest word outside the parentheses print if there is no word outside the parentheses the number of words inside the parentheses print if there is no word inside the parentheses ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tstring st, cur;\n\tcin >> st;\n\tint inp(0);\n\tint ans1(0), ans2(0);\n\tst.push_back('(');\n\tfor(int i(0); i < (int)st.size(); i++) {\n\t\tif(st[i] == '_' || st[i] == '(' || st[i] == ')') {\n\t\t\tif(!cur.empty()) {\n\t\t\t\tif(inp) {\n\t\t\t\t\tans2++;\n\t\t\t\t}else {\n\t\t\t\t\tans1 = max(ans1, (int)cur.size());\n\t\t\t\t}\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t\tif(st[i] == '(') {\n\t\t\t\tinp = true;\n\t\t\t}else if(st[i] == ')') {\n\t\t\t\tinp = false;\n\t\t\t}\n\t\t}else {\n\t\t\tcur.push_back(st[i]);\n\t\t}\n\t}\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n""]","['expression parsing', 'implementation', 'strings']",1100
https://codeforces.com//contest/1464/problem/E,E. No Game No Life,Let s consider the following game of Alice and Bob on a directed acyclic graph Each vertex may contain an arbitrary number of chips Alice and Bob make turns alternating Alice goes first In one turn player can move exactly one chip along any edge outgoing from the vertex that contains this chip to the end of this edge The one who cannot make a turn loses Both players play optimally Consider the following process that takes place every second on a given graph with n vertices An integer v is chosen equiprobably from 1 n 1 If v leq n we add a chip to the v th vertex and go back to step 1 If v n 1 Alice and Bob play the game with the current arrangement of chips and the winner is determined After that the process is terminated Find the probability that Alice will win the game It can be shown that the answer can be represented as frac P Q where P and Q are coprime integers and Q not equiv 0 pmod 998 244 353 Print the value of P cdot Q 1 bmod 998 244 353 ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\nconst ll MOD = 998244353;\nconst ll Inv2 = (MOD + 1) / 2;\n\nint n,m,N;\nint SG[MAXN];\n\nll p[MAXN << 2];\nll q[MAXN << 2];\n\nvector<int> e[MAXN];\n\nll power(ll a,ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nvoid dfs(int u)\n{\n\tif (~SG[u])\n\t\treturn;\n\tvector<int> nxt;\n\tfor (int i = 0;i < e[u].size();i++)\n\t{\n\t\tdfs(e[u][i]);\n\t\tnxt.push_back(SG[e[u][i]]);\n\t}\n\tsort(nxt.begin(),nxt.end());\n\tint i = 0;\n\tfor (int j = 0;j < nxt.size();j++)\n\t\tif (i == nxt[j])\n\t\t\ti++;\n\tSG[u] = i;\n}\n\nvoid FWT(ll *a,bool inv)\n{\n\tfor (int i = 1;i < N;i <<= 1)\n\t\tfor (int j = 0;j < N;j += i << 1)\n\t\t\tfor (int k = 0;k < i;k++)\n\t\t\t{\n\t\t\t\tll x = a[j + k],y = a[j + k + i];\n\t\t\t\ta[j + k] = (inv ? (x + y) * Inv2 % MOD : (x + y) % MOD);\n\t\t\t\ta[j + k + i] = (inv ? (x - y) * Inv2 % MOD : (x - y) % MOD);\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"",&n,&m);\n\tN = 1;\n\twhile (N - 1 < n)\n\t\tN <<= 1;\n\tfor (int u,v,i = 1;i <= m;i++)\n\t{\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].push_back(v);\n\t}\n\tmemset(SG,-1,sizeof(SG));\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tdfs(i);\n\t\tp[SG[i]]++;\n\t}\n\tll Inv = power(n + 1,MOD - 2);\n\tfor (int i = 0;i < N;i++)\n\t\t(p[i] *= Inv) %= MOD;\n\tp[0]--;\n\tq[0] = -Inv;\n\tFWT(p,0);\n\tFWT(q,0);\n\tfor (int i = 0;i < N;i++)\n\t\tq[i] = q[i] * power(p[i],MOD - 2) % MOD;\n\tFWT(q,1);\n\tprintf(""%lld\\n"",(MOD + 1 - q[0]) % MOD);\n\treturn 0;\n}']","['bitmasks', 'dp', 'games', 'math', 'matrices', 'probabilities']",2700
https://codeforces.com//contest/767/problem/B,B. The Queue,Finally Vasya have come of age and that means he can finally get a passport To do it he needs to visit the passport office but it s not that simple There s only one receptionist at the passport office and people can queue up long before it actually opens Vasya wants to visit the passport office tomorrow He knows that the receptionist starts working after minutes have passed after midnight and closes after minutes have passed after midnight so that is the last minute when the receptionist is still working The receptionist spends exactly minutes on each person in the queue If the receptionist would stop working within minutes he stops serving visitors other than the one he already serves Vasya also knows that exactly visitors would come tomorrow For each visitor Vasya knows the point of time when he would come to the passport office Each visitor queues up and doesn t leave until he was served If the receptionist is free when a visitor comes in particular if the previous visitor was just served and the queue is empty the receptionist begins to serve the newcomer immediately For each visitor the point of time when he would come to the passport office is positive Vasya can come to the office at the time zero that is at midnight if he needs so but he can come to the office only at integer points of time If Vasya arrives at the passport office at the same time with several other visitors he yields to them and stand in the queue after the last of them Vasya wants to come at such point of time that he will be served by the receptionist and he would spend the minimum possible time in the queue Help him ,"['#include<bits/stdc++.h>\nusing namespace std;\nlong long int S,E,L,res,bes;\nint n;\nvoid upd(long long int wait, long long int tt){\n\tif(bes == -1 || bes > wait)\n\t\tbes = wait, res = tt;\n}\nint main(){\n\tscanf(""%I64d%I64d%I64d"",&S,&E,&L);\n\tscanf(""%d"",&n);\n\tbes = -1;\n\tres = -1;\n\tlong long int now = S;\n\tfor(int i=0; i<n; i++){\n\t\tlong long int tt;\n\t\tscanf(""%I64d"",&tt);\n\t\tif(now >= tt){\n\t\t\tif(now + L > E)break;\n\t\t\tlong long int wait = now - (tt-1);\n\t\t\tupd(wait, tt-1);\n\t\t\tnow += L;\n\t\t}else{\n\t\t\tupd(0, now);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(now + L <= E)\n\t\tupd(0, now);\n\tprintf(""%I64d\\n"",res);\n\treturn 0;\n}\n']","['brute force', 'greedy']",2100
https://codeforces.com//contest/1137/problem/A,A. Skyscrapers,Dora loves adventures quite a lot During some journey she encountered an amazing city which is formed by n streets along the Eastern direction and m streets across the Southern direction Naturally this city has nm intersections At any intersection of i th Eastern street and j th Southern street there is a monumental skyscraper Dora instantly became curious and decided to explore the heights of the city buildings When Dora passes through the intersection of the i th Eastern and j th Southern street she examines those two streets After Dora learns the heights of all the skyscrapers on those two streets she wonders how one should reassign heights to the skyscrapers on those two streets so that the maximum height would be as small as possible and the result of comparing the heights of any two skyscrapers on one street wouldn t change Formally on every of nm intersections Dora solves an independent problem She sees n m 1 skyscrapers and for each of them she knows its real height Moreover any two heights can be compared to get a result greater smaller or equal Now Dora wants to select some integer x and assign every skyscraper a height from 1 to x When assigning heights Dora wants to preserve the relative order of the skyscrapers in both streets That is the result of any comparison of heights of two skyscrapers in the current Eastern street shouldn t change and the result of any comparison of heights of two skyscrapers in current Southern street shouldn t change as well Note that skyscrapers located on the Southern street are not compared with skyscrapers located on the Eastern street only However the skyscraper located at the streets intersection can be compared with both Southern and Eastern skyscrapers For every intersection Dora wants to calculate the minimum possible x For example if the intersection and the two streets corresponding to it look as follows Then it is optimal to replace the heights of the skyscrapers as follows note that all comparisons less equal greater inside the Eastern street and inside the Southern street are preserved The largest used number is 5 hence the answer for this intersection would be 5 Help Dora to compute the answers for each intersection ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n, vector<int>(m));\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cin >> a[i][j];\n    }\n  }\n  vector<vector<int>> row_less(n, vector<int>(m));\n  vector<vector<int>> row_more(n, vector<int>(m));\n  for (int i = 0; i < n; ++i) {\n    vector<int> b = a[i];\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n    for (int j = 0; j < m; ++j) {\n      row_less[i][j] = lower_bound(b.begin(), b.end(), a[i][j]) - b.begin();\n      row_more[i][j] = b.size() - 1 - row_less[i][j];\n    }\n  }\n  vector<vector<int>> col_less(n, vector<int>(m));\n  vector<vector<int>> col_more(n, vector<int>(m));\n  for (int i = 0; i < m; ++i) {\n    vector<int> b(n);\n    for (int j = 0; j < n; ++j) {\n      b[j] = a[j][i];\n    }\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n    for (int j = 0; j < n; ++j) {\n      col_less[j][i] = lower_bound(b.begin(), b.end(), a[j][i]) - b.begin();\n      col_more[j][i] = b.size() - 1 - col_less[j][i];\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (j) {\n        cout << "" "";\n      }\n      cout << 1 + max(row_less[i][j], col_less[i][j]) + max(row_more[i][j], col_more[i][j]);\n    }\n    cout << ""\\n"";\n  }\n  return 0;\n}\n']","['implementation', 'sortings']",1600
https://codeforces.com//contest/1703/problem/F,F. Yet Another Problem About Pairs Satisfying an Inequality,You are given an array a 1 a 2 dots a n Count the number of pairs of indices 1 leq i j leq n such that a i i a j j ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""../debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""../input.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n\tfstart;\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n; cin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto& x : a) {\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\n\t\tvector<int> lessThanI(n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] < i) {\n\t\t\t\tlessThanI[i] = 1;\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tlessThanI[i] += lessThanI[i - 1];\n\t\t}\n\t\t\n\t\tll res = 0;\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tif (a[j] >= j)\n\t\t\t\tcontinue;\n\t\t\tif (a[j] - 1 >= 0)\n\t\t\t\tres += lessThanI[a[j] - 1];\n\t\t}\n\n\t\tcout << res << ""\\n"";\n\t}\n\n\n\tfinish;\n}\n\n']","['binary search', 'data structures', 'dp', 'greedy', 'sortings']",1300
https://codeforces.com//contest/1042/problem/E,E. Vasya and Magic Matrix,Vasya has got a magic matrix a of size n times m The rows of the matrix are numbered from 1 to n from top to bottom the columns are numbered from 1 to m from left to right Let a ij be the element in the intersection of the i th row and the j th column Vasya has also got a chip Initially the chip is in the intersection of the r th row and the c th column that is in the element a rc Vasya performs the following process as long as possible among all elements of the matrix having their value less than the value of the element with the chip in it Vasya randomly and equiprobably chooses one element and moves his chip to this element After moving the chip he adds to his score the square of the Euclidean distance between these elements that is between the element in which the chip is now and the element the chip was moved from The process ends when there are no elements having their values less than the value of the element with the chip in it Euclidean distance between matrix elements with coordinates i 1 j 1 and i 2 j 2 is equal to sqrt i 1 i 2 2 j 1 j 2 2 Calculate the expected value of the Vasya s final score It can be shown that the answer can be represented as frac P Q where P and Q are coprime integer numbers and Q not equiv 0 mod 998244353 Print the value P cdot Q 1 modulo 998244353 ,"['#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who’s Kobe? \n// Fisherman can’t stop us\n// Average ABCDE on a good day\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nint N, M, R, C;\npair<int, pair<int, int> > A[1000005];\n\nll expo(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (b == 1)\n        return a % MOD;\n    if (b % 2 == 0)\n        return expo(a*a % MOD, b/2);\n    return a*expo(a*a % MOD, (b-1)/2) % MOD;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n\n    cin >> N >> M;\n    for (int i = 0; i < N; i++)\n        for (int j = 0, a; j < M; j++)\n        {\n            cin >> a;\n            A[M*i + j] = make_pair(a, make_pair(i + 1, j + 1));\n        }\n    cin >> R >> C;\n\n    sort(A, A + N*M);\n    ll sumsq = 0, sumx = 0, sumy = 0, totale = 0;\n    for (int i = 0; i < N*M;)\n    {\n        int j = i;\n        ll sumsq1 = 0, sumx1 = 0, sumy1 = 0, e1 = 0;\n        while (j < N*M && A[i].first == A[j].first)\n        {\n            ll x = A[j].second.first, y = A[j].second.second;\n            ll e = (sumsq + i*(x*x % MOD + y*y % MOD) % MOD) % MOD;\n            e = (e - 2*x*sumx % MOD) % MOD;\n            e = (e - 2*y*sumy % MOD) % MOD;\n            e = (e + totale) % MOD;\n            e = e*expo(i, MOD - 2) % MOD;\n            if (x == R && y == C)\n            {\n                if (e < 0)\n                    e += MOD;\n                cout << e << ""\\n"";\n                return 0;\n            }\n            sumsq1 = (sumsq1 + x*x % MOD + y*y % MOD) % MOD;\n            sumx1 = (sumx1 + x) % MOD;\n            sumy1 = (sumy1 + y) % MOD;\n            e1 = (e1 + e) % MOD;\n            j++;\n        }\n        sumsq = (sumsq + sumsq1) % MOD;\n        sumx = (sumx + sumx1) % MOD;\n        sumy = (sumy + sumy1) % MOD;\n        totale = (totale + e1) % MOD;\n        i = j;\n    }\n\n    return 0;\n}\n']","['dp', 'math', 'probabilities']",2300
https://codeforces.com//contest/1102/problem/A,A. Integer Sequence Dividing,You are given an integer sequence 1 2 dots n You have to divide it into two sets A and B in such a way that each element belongs to set and sum A sum B is minimum possible The value x is the absolute value of x and sum S is the sum of elements of the set S ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n// \tfreopen(""input.txt"",""r"",stdin);\n\tint n;\n\tcin >> n;\n\tif(n&1)cout << (((n + 1)/2)&1);\n\telse cout << ((n/2)&1);\n}']",['math'],800
https://codeforces.com//contest/469/problem/A,A. I Wanna Be the Guy,There is a game called I Wanna Be the Guy consisting of levels Little X and his friend Little Y are addicted to the game Each of them wants to pass the whole game Little X can pass only levels of the game And Little Y can pass only levels of the game You are given the indices of levels Little X can pass and the indices of levels Little Y can pass Will Little X and Little Y pass the whole game if they cooperate each other ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,i,j,x,f[200];\nint main()\n{\n\tscanf(""%d"",&n);\n\tscanf(""%d"",&m);\n\tfor(i=1;i<=n;i++)f[i]=1;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(""%d"",&x);\n\t\tf[x]=0;\n\t}\n\tscanf(""%d"",&m);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(""%d"",&x);\n\t\tf[x]=0;\n\t}\n\tfor(i=1;i<=n;i++)if(f[i])break;\n\tif(i==n+1)puts(""I become the guy."");\n\telse puts(""Oh, my keyboard!"");\n}']","['greedy', 'implementation']",800
https://codeforces.com//contest/1706/problem/A,A. Another String Minimization Problem,You have a sequence a 1 a 2 ldots a n of length n consisting of integers between 1 and m You also have a string s consisting of m characters You are going to perform the following n operations At the i th 1 le i le n operation you replace either the a i th the m 1 a i th character of s with You can replace the character at any position multiple times through the operations Find the lexicographically smallest string you can get after these operations A string x is lexicographically smaller than a string y of the same length if and only if in the first position where x and y differ the string x has a letter that appears earlier in the alphabet than the corresponding letter in y ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 55;\n\nchar ans[N];\nint T, n, m;\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\tm = read();\n\t\trep(i, 1, m) ans[i] = \'B\';\n\t\trep(i, 1, n) {\n\t\t\tint a = read();\n\t\t\ta = min(a, m - a + 1);\n\t\t\tif (ans[a] == \'B\')\n\t\t\t\tans[a] = \'A\';\n\t\t\telse\n\t\t\t\tans[m - a + 1] = \'A\';\n\t\t}\n\t\trep(i, 1, m) putchar(ans[i]);\n\t\tputchar(\'\\n\');\n\t}\n}']","['2-sat', 'constructive algorithms', 'greedy', 'string suffix structures', 'strings']",800
https://codeforces.com//contest/1263/problem/B,B. PIN Codes,A PIN code is a string that consists of exactly 4 digits Examples of possible PIN codes and Please note that the PIN code can begin with any digit even with Polycarp has n 2 le n le 10 bank cards the PIN code of the i th card is p i Polycarp has recently read a recommendation that it is better to set different PIN codes on different cards Thus he wants to change the minimal number of digits in the PIN codes of his cards so that all n codes would become different Formally in one step Polycarp picks i th card 1 le i le n then in its PIN code p i selects one position from 1 to 4 and changes the digit in this position to any other He needs to change the minimum number of digits so that all PIN codes become different Polycarp quickly solved this problem Can you solve it ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int T;\n  scanf(""%d"", &T);\n  while (T-- > 0) {\n    int n;\n    scanf(""%d"", &n);\n    vector<string> val(n);\n    for (int i = 0; i < n; i++) {\n      char buff[256];\n      scanf(""%s"", buff);\n      val[i] = buff;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      bool has_same = false;\n      for (int j = 0; j < i; j++) {\n        if (val[i] == val[j]) {\n          has_same = true;\n          break;\n        }\n      }\n      if (has_same) {\n        string temp = val[i];\n        bool found = false;\n        for (int d = 0; d < 4; d++) {\n          for (int v = 0; v < 10; v++) {\n            temp[d] = v + \'0\';\n            bool fail = false;\n            for (int k = 0; k < n; k++) {\n              if (k == i) continue;\n              if (temp == val[k]) {\n                fail = true;\n                break;\n              }\n            }\n            if (!fail) {\n              val[i] = temp;\n              found = true;\n            }\n            if (found) break;\n          }\n          if (found) break;\n        }\n        ans++;\n      }\n    }\n    printf(""%d\\n"", ans);\n    for (int i = 0; i < n; i++) {\n      printf(""%s\\n"", val[i].c_str());\n    }\n  }\n  return 0;\n}\n']","['greedy', 'implementation']",1400
https://codeforces.com//contest/1499/problem/F,F. Diameter Cuts,You are given an integer k and an undirected tree consisting of n vertices The length of a simple path a path in which each vertex appears at most once between some pair of vertices is the number of edges in this path A diameter of a tree is the maximum length of a simple path between all pairs of vertices of this tree You are about to remove a set of edges from the tree The tree splits into multiple smaller trees when the edges are removed The set of edges is valid if all the resulting trees have diameter less than or equal to k Two sets of edges are different if there is an edge such that it appears in only one of the sets Count the number of valid sets of edges modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N, K;\nint sz[5050];\nll D[5050][5050];\nll tmp[5050];\n\nvector<int> adj[5050];\n\nvoid dfs(int v, int p) {\n\tsz[v] = 1;\n\tD[v][0] = 1;\n\tfor(int i : adj[v]) {\n\t\tif(i == p) continue;\n\t\tdfs(i, v);\n\t\tfor(int j = 0; j <= sz[v] + sz[i]; j++) tmp[j] = 0;\n\t\tll tot = 0;\n\t\tfor(int j = 0; j <= sz[i]; j++) tot = (tot + D[i][j]) % MOD;\n\n\t\tfor(int j = 0; j <= sz[v]; j++) tmp[j] = (D[v][j] * tot) % MOD;\n\t\tfor(int j = 0; j <= sz[v]; j++) {\n\t\t\tfor(int k = 0; k <= sz[i]; k++) {\n\t\t\t\tif(j + k + 1 > K) continue;\n\t\t\t\tint m = max(j, k + 1);\n\t\t\t\ttmp[m] = (tmp[m] + D[v][j] * D[i][k]) % MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j <= sz[v] + sz[i]; j++) D[v][j] = tmp[j];\n\t\tsz[v] += sz[i];\n\t}\n\t// printf(""%d\\n"", v);\n\t// for(int i = 0; i <= sz[v]; i++) printf(""%lld "", D[v][i]); puts("""");\n}\n\nint main() {\n\tscanf(""%d%d"", &N, &K);\n\tfor(int i = 1; i < N; i++) {\n\t\tint a, b; scanf(""%d%d"", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\n\tdfs(1, 0);\n\tll ans = 0;\n\tfor(int i = 0; i <= N; i++) ans = (ans + D[1][i]) % MOD;\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}']","['combinatorics', 'dfs and similar', 'dp', 'trees']",2400
https://codeforces.com//contest/295/problem/B,B. Greg and Graph,Greg has a weighed directed graph consisting of vertices In this graph any pair of distinct vertices has an edge between them in both directions Greg loves playing with the graph and now he has invented a new game The game consists of steps On the th step Greg removes vertex number from the graph As Greg removes a vertex he also removes all the edges that go in and out of this vertex Before executing each step Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices The shortest path can go through any remaining vertex In other words if we assume that is the shortest path between vertices and in the graph that formed before deleting vertex then Greg wants to know the value of the following sum Help Greg print the value of the required sum before each step ,"['#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstring>\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define fup FOR\n#define fdo FORD\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define siz SZ\n#define CLR(x) memset((x), 0, sizeof(x))\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second \n#define FI X\n#define SE Y\n#define SQR(a) ((a)*(a))\n#define DEBUG 1\n#define debug(x) {if (DEBUG)cerr <<#x <<"" = "" <<x <<endl; }\n#define debugv(x) {if (DEBUG) {cerr <<#x <<"" = ""; FORE(it, (x)) cerr <<*it <<"", ""; cout <<endl; }}\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int>P;\ntypedef vector<int>VI;\nconst int INF=1E9+7;\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n#define MAXN 507\n\nint n,G[MAXN][MAXN],best[MAXN][MAXN],x[MAXN];\nbool vis[MAXN];\nvector<LL> ans;\nVI is;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n    cout << setprecision(15) << fixed;\n\t//in\n    cin >> n;\n    REP(i,n) REP(j,n) cin >> G[i][j];\n    REP(i,n) cin >> x[i];\n\t//sol\n    REP(i,n) REP(j,n) best[i][j] = INF;\n    REP(i,n) best[i][i]=0;\n    FORD(f,n-1,0) {\n        int v = x[f]-1;\n        REP(i,n) if(vis[i]) REP(j,n) if(vis[j]) {\n       // FORE(i,is) FORE(j,is) {\n            mini(best[v][i], G[v][j] + best[j][i]);\n            mini(best[i][v], G[j][v] + best[i][j]);\n        }\n        REP(i,n) if(vis[i]) REP(j,n) if(vis[j])\n        //FORE(i,is) FORE(j,is)\n            mini(best[i][j], best[i][v] + best[v][j]);\n        vis[v] = true;\n        LL sum = 0;\n        is.PB(v);\n//        cout << vis[0] << "" "" << vis[1] << "" "" << best[0][1] << "" "" << best[1][0] << endl;\n        REP(i,n) if(vis[i]) REP(j,n) if(vis[j])\n        //FORE(i,is) FORE(j,is)\n            sum += best[i][j];\n        ans.PB(sum);\n    }\n\t//out\n    reverse(ALL(ans));\n    FORE(i,ans)\n        cout << *i << "" "";\n    cout << endl;\n\treturn 0;\n}\n\n']","['dp', 'graphs', 'shortest paths']",1700
https://codeforces.com//contest/703/problem/A,A. Mishka and Game,Mishka is a little polar bear As known little bears loves spending their free time playing dice for chocolates Once in a wonderful sunny morning walking around blocks of ice Mishka met her friend Chris and they started playing the game Rules of the game are very simple at first number of rounds is defined In every round each of the players throws a cubical dice with distinct numbers from to written on its faces Player whose value after throwing the dice is greater wins the round In case if player dice values are equal no one of them is a winner In average player who won most of the rounds is the winner of the game In case if two players won the same number of rounds the result of the game is draw Mishka is still very little and can t count wins and losses so she asked you to watch their game and determine its result Please help her ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name"".in"", ""r"", stdin); \\\n        freopen(name"".out"", ""w"", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << "" = "" << head << "" <<"" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=\',\' || c!=0) {\n        if (*s==\'(\' || *s==\'[\' || *s==\'{\' || *s==\'<\') c++;\n        if (*s==\')\' || *s==\']\' || *s==\'}\' || *s==\'>\') c--;\n        cerr << *s++;\n    }\n    cerr << "" = "" << head << "", "";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << ""\\033[32m>> "" << __LINE__ << "": "" << __PRETTY_FUNCTION__ << endl; \\\n    cout << ""   ""; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << ""\\033[0m""; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss="""", const string se="""") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? """" : "", "") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << ""("" << pair.F << "", "" << pair.S << "")"";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), ""["", ""]"");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), ""{"", ""}"");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), ""|"", ""|"");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << ""{"";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?"""":"", "") << it->F << "":"" << it->S;\n    }\n    o << ""}"";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << ""Not lucky"" << endl;\n        exit(0);\n    }\n}\n\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    int N;\n    cin >> N;\n    int a = 0, b = 0;\n    for (int i=0; i<N; i++) {\n        int x, y;\n        cin>>x>>y;\n        if (x>y) a++;\n        else if (x<y) b++;\n    }\n\n\n    cout << (a == b ? ""Friendship is magic!^^"" :\n             a > b ? ""Mishka"" : ""Chris"") << endl;\n    return 0;\n}\n\n']",['implementation'],800
https://codeforces.com//contest/1379/problem/C,C. Choosing flowers,Vladimir would like to prepare a present for his wife they have an anniversary He decided to buy her n flowers Vladimir went to a flower shop and he was amazed to see that there are m types of flowers being sold there and there is unlimited supply of flowers of each type Vladimir wants to choose flowers to maximize the happiness of his wife He knows that after receiving the first flower of the i th type happiness of his wife increases by a i and after receiving each consecutive flower of this type her happiness increases by b i That is if among the chosen flowers there are x i 0 flowers of type i his wife gets a i x i 1 cdot b i additional happiness and if there are no flowers of type i she gets nothing for this particular type Please help Vladimir to choose exactly n flowers to maximize the total happiness of his wife ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n\tint t;\n\tcin >> t;\n\n\tfor(int x = 0; x < t; x++) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tvector< pair<int, int> > arr;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tarr.emplace_back(a, b);\n\t\t}\n\t\tsort(arr.begin(), arr.end());\n\t\tvector<int> sufsum(m);\n\t\tsufsum[m - 1] = arr[m - 1].first;\n\t\tfor(int i = m - 2; i >= 0; i--) {\n\t\t\tsufsum[i] = sufsum[i + 1] + arr[i].first;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint j = lower_bound(arr.begin(), arr.end(), make_pair(arr[i].second + 1, 0LL)) - arr.begin();\n\n\t\t\tint cnt = m - j;\n\t\t\tif(cnt > n - 1) {\n\t\t\t\tcnt = n - 1;\n\t\t\t\tj = m - cnt;\n\t\t\t}\n\n\t\t\tif(cnt == n - 1 && i >= j && j >= 1 && arr[j - 1].first > arr[i].second) {\n\t\t\t\tj--;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif(i < j) {\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tassert(cnt <= n);\n\t\t\tint c = (j == m ? 0 : sufsum[j]) + (i < j ? arr[i].first : 0) + (n - cnt) * arr[i].second;\n\t\t\tans = max(ans, c);\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\n\treturn 0;\n}']","['binary search', 'brute force', 'data structures', 'dfs and similar', 'dp', 'greedy', 'sortings', 'two pointers']",2000
https://codeforces.com//contest/1799/problem/E,E. City Union,You are given n times m grid Some cells are filled and some are empty A is a maximal by inclusion set of filled cells such that it is possible to get from any cell in the set to any other cell in the set by moving to adjacent by side cells without moving into any cells not in the set In other words a city is a connected component of filled cells with edges between adjacent by side cells Initially there are on the grid You want to change some empty cells into filled cells so that both of the following are satisfied There is on the resulting grid The shortest path between any two filled cells achievable only by moving onto filled cells is equal to the Manhattan distance between them The between two cells a b and c d is equal to a c b d Find a way to add filled cells that satisfies these conditions and minimizes the total number of filled cells ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::string> s(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> s[i];\n    }\n    \n    std::vector<int> minr(n, m), maxr(n, -1), minc(m, n), maxc(m, -1);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (s[i][j] == \'#\') {\n                minr[i] = std::min(minr[i], j);\n                maxr[i] = std::max(maxr[i], j);\n                minc[j] = std::min(minc[j], i);\n                maxc[j] = std::max(maxc[j], i);\n            }\n        }\n    }\n    \n    std::function<void(int, int)> work = [&](int x, int y) -> void {\n        s[x][y] = \'#\';\n        minr[x] = std::min(minr[x], y);\n        maxr[x] = std::max(maxr[x], y);\n        minc[y] = std::min(minc[y], x);\n        maxc[y] = std::max(maxc[y], x);\n        \n        for (int j = minr[x]; j <= maxr[x]; j++) {\n            if (s[x][j] == \'.\') {\n                work(x, j);\n            }\n        }\n        for (int i = minc[y]; i <= maxc[y]; i++) {\n            if (s[i][y] == \'.\') {\n                work(i, y);\n            }\n        }\n    };\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = minr[i]; j <= maxr[i]; j++) {\n            if (s[i][j] == \'.\') {\n                work(i, j);\n            }\n        }\n    }\n    for (int j = 0; j < m; j++) {\n        for (int i = minc[j]; i <= maxc[j]; i++) {\n            if (s[i][j] == \'.\') {\n                work(i, j);\n            }\n        }\n    }\n    \n    int u1 = 0;\n    while (minr[u1] > maxr[u1]) {\n        u1++;\n    }\n    int d1 = u1;\n    while (d1 + 1 < n && minr[d1 + 1] <= maxr[d1] && maxr[d1 + 1] >= minr[d1]) {\n        d1++;\n    }\n    int u2 = d1 + 1;\n    while (u2 < n && minr[u2] > maxr[u2]) {\n        u2++;\n    }\n    if (u2 < n) {\n        int d2 = u2;\n        while (d2 + 1 < n && minr[d2 + 1] <= maxr[d2] && maxr[d2 + 1] >= minr[d2]) {\n            d2++;\n        }\n        \n        int r1 = -1, l2 = m;\n        int r2 = -1, l1 = m;\n        for (int i = u1; i <= d1; i++) {\n            r1 = std::max(r1, maxr[i]);\n            l1 = std::min(l1, minr[i]);\n        }\n        for (int i = u2; i <= d2; i++) {\n            r2 = std::max(r2, maxr[i]);\n            l2 = std::min(l2, minr[i]);\n        }\n        if (r1 < l2) {\n            work(d1, r1);\n            work(u2, l2);\n            for (int i = d1 + 1; i <= u2; i++) {\n                work(i, r1);\n            }\n        } else {\n            work(d1, l1);\n            work(u2, r2);\n            for (int i = d1 + 1; i <= u2; i++) {\n                work(i, l1);\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << s[i] << ""\\n"";\n    }\n    std::cout << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['constructive algorithms', 'dfs and similar', 'dsu', 'geometry', 'greedy', 'implementation', 'math']",2300
https://codeforces.com//contest/1743/problem/A,A. Password,Monocarp has forgotten the password to his mobile phone The password consists of 4 digits from 0 to 9 note that it can start with the digit 0 Monocarp remembers that his password had exactly two different digits and each of these digits appeared exactly two times in the password Monocarp also remembers some digits which were definitely not used in the password You have to calculate the number of different sequences of 4 digits that could be the password for Monocarp s mobile phone i e these sequences should meet all constraints on Monocarp s password ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n    }\n    \n    std::cout << (10 - n) * (9 - n) * 3 << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['brute force', 'combinatorics', 'implementation', 'math']",800
https://codeforces.com//contest/546/problem/D,D. Soldier and Number Game,Two soldiers are playing a game At the beginning first of them chooses a positive integer and gives it to the second soldier Then the second one tries to make maximum possible number of rounds Each round consists of choosing a positive integer such that is divisible by and replacing with When becomes equal to and there is no more possible valid moves the game is over and the score of the second soldier is equal to the number of rounds he performed To make the game more interesting first soldier chooses of form for some positive integer and Here by we denote the of that is defined as a product of all positive integers not large than What is the maximum possible score of the second soldier ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\nint n;\nint a[1000005],b[1000005];\nvector<int> x[5000005];\nint c[5000005];\nlong long r[5000005];\nint main(){\n    cin >> n; rep2(i,n) scanf(""%d%d"",&a[i],&b[i]);\n    for(int i=2;i<=5000000;i++){\n    \tif(c[i]) continue; c[i] = 1;\n    \tfor(int j=2;i*j<=5000000;j++){\n    \t\tint x = j*i;\n    \t\twhile(x%i==0){\n    \t\t\tx/=i;\n    \t\t\tc[i*j]++;\n    \t\t}\n    \t}\n    }\n    for(int i=2;i<=5000000;i++) r[i] = r[i-1]+c[i];\n    rep2(i,n) printf(""%lld\\n"",r[a[i]]-r[b[i]]);\n}']","['constructive algorithms', 'dp', 'math', 'number theory']",1700
https://codeforces.com//contest/1296/problem/E2,E2. String Coloring  hard version , You are given a string s consisting of n lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in s After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;\nchar a[N];\nint l[N],r[N];\nvector<int>v[N];\nint c[N];\nint s[N];\nint main()\n{\n    cin>>n;\n    scanf(""%s"",a+1);\n    for(int i=0;i<26;i++)c[i]=0;\n    int ans=0;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<26;j++){\n            if(c[j]<=a[i]-\'a\'){\n                s[i]=j;\n                ans=max(ans,j);\n                c[j]=a[i]-\'a\';\n                break;\n            }\n        }\n    }\n\n    cout<<ans+1<<endl;\n    for(int i=1;i<=n;i++){\n        printf(""%d "",s[i]+1);\n    }\n    return 0;\n}\n/*\n*/\n']","['data structures', 'dp']",2000
https://codeforces.com//contest/1749/problem/D,D. Counting Arrays,Consider an array a of length n with elements numbered from 1 to n It is possible to remove the i th element of a if gcd a i i 1 where gcd denotes the greatest common divisor After an element is removed the elements to the right are shifted to the left by one position An array b with n integers such that 1 le b i le n i 1 is a if it is possible to remove all elements of a if you remove the b 1 th element then the b 2 th then the b n th element For example let a 42 314 1 1 is a removal sequence when you remove the 1 st element of the array the condition gcd 42 1 1 holds and the array becomes 314 when you remove the 1 st element again the condition gcd 314 1 1 holds and the array becomes empty 2 1 is not a removal sequence when you try to remove the 2 nd element the condition gcd 314 2 1 is false An array is if it has removal sequences For example the array 1 2 5 is ambiguous it has removal sequences 3 1 1 and 1 2 1 The array 42 314 is not ambiguous the only removal sequence it has is 1 1 You are given two integers n and m You have to calculate the number of arrays a such that the length of a is from 1 to n and each a i is an integer from 1 to m ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  friend ModInt operator+(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) += rhs;\n  }\n  friend ModInt operator-(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) -= rhs;\n  }\n  friend ModInt operator*(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) *= rhs;\n  }\n  friend ModInt operator/(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) /= rhs;\n  }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  \n  T RC(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return rfact(p) * fact(q) * fact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n  //+1がn個、-1がm個で prefix sumが常にk以上\n  T catalan(ll n,ll m,ll k){\n    if(n>m-k)return 0;\n    else return C(n+m,m)-C(n+m,n+k-1);\n  }\n};\nusing modint = ModInt< MOD9 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  modint dec=1;\n  ll g=1;\n  modint ret=0;\n  auto pt=prime_table(n+5);\n  rep(i,1,n+1){\n    if(pt[i])g*=i;\n    chmin(g,m+1);\n    dec*=m/g;\n    //cout<<i spa g spa dec<<endl;\n    ret+=pow(m,i)-dec;\n  }\n  cout<<ret<<endl;\n  return 0;\n}']","['combinatorics', 'dp', 'math', 'number theory']",1900
https://codeforces.com//contest/1726/problem/G,G. A Certain Magical Party,There are n people at a party The i th person has an amount of happiness a i Every person has a certain kind of personality which can be represented as a binary integer b If b 0 it means the happiness of the person will increase if he tells the story to someone happy than them If b 1 it means the happiness of the person will increase if he tells the story to someone happy than them Let us define a as an ordering of the people from left to right Now the following process occurs We go from left to right The current person tells the story to all people other than himself Note that while this happens After the person is done he counts the number of people who currently have strictly less more happiness than him as per his kind of personality and his happiness increases by that value Note that only the current person s happiness value increases As the organizer of the party you don t want anyone to leave sad Therefore you want to count the number of speaking orders such that at the end of the process n people have happiness Two speaking orders are considered different if there exists at least one person who does not have the same position in the two speaking orders ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint():v(0) {}\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tbool operator==(const mint& o) const {\n\t\treturn v == o.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& o) { \n\t\tif ((v += o.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& o) { \n\t\tif ((v -= o.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& o) { \n\t\tv = int((ll)v*o.v%MOD); return *this; }\n\tmint& operator/=(const mint& o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\nusing mi = mint<MOD,5>; // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi,mi>;\nusing vpmi = V<pmi>;\n\nV<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvmi invs, fac, ifac;\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = mi(-(ll)MOD/i*(int)invs[MOD%i]);\n\tFOR(i,1,SZ) fac[i] = fac[i-1]*i, ifac[i] = ifac[i-1]*invs[i];\n}\nmi comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn fac[a]*ifac[b]*ifac[a-b]; }\n\nint main() {\n\t// read read read\n\tsetIO();\n\tints(N);\n\tvi A(N), B(N); re(A,B);\n\tgenFac(3*N+5);\n\tvpi pairs;\n\tF0R(i,N) pairs.pb({A[i],B[i]});\n\tsor(pairs);\n\n\tint max_lb = 0, max_ub = 3*N;\n\tint sofar = 0;\n\tmi mul = 1;\n\tint num = 0;\n\n\tfor (int r = 0; r < N; ) {\n\t\tint l = r;\n\t\tAR<int,2> cnt{};\n\t\twhile (r < N && pairs.at(l).f == pairs.at(r).f) {\n\t\t\t++cnt.at(pairs.at(r).s);\n\t\t\t++r;\n\t\t}\n\t\tif (cnt.at(0)) {\n\t\t\t// 0 <= max-pairs.at(l).f <= sofar\n\t\t\tckmax(max_lb, pairs.at(l).f);\n\t\t\tckmin(max_ub, sofar + pairs.at(l).f);\n\t\t\tsofar += cnt.at(0);\n\t\t\tmul *= fac.at(cnt.at(0));\n\t\t}\n\t\tif (cnt.at(1)) {\n\t\t\tbool contains = (max_lb <= pairs.at(l).f && pairs.at(l).f <= max_ub);\n\t\t\tif (cnt.at(1) > 1) {\n\t\t\t\tif (r < N) {\n\t\t\t\t\tps(0);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\tif (contains) {\n\t\t\t\t\twhile (sofar < N) mul *= ++sofar;\n\t\t\t\t} else {\n\t\t\t\t\tmul = 0;\n\t\t\t\t}\n\t\t\t\tps(mul);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tif (r == N) {\n\t\t\t\tdbg(""OH"", contains, max_lb, max_ub);\n\t\t\t\tif (contains) {\n\t\t\t\t\tnum += N;\n\t\t\t\t\tdbg(""HA"");\n\t\t\t\t}\n\t\t\t\tckmax(max_lb, pairs.at(l).f+1);\n\t\t\t}\n\t\t\tckmax(max_lb, N-1+pairs.at(l).f-sofar);\n\t\t\tckmin(max_ub, N-1+pairs.at(l).f);\n\t\t\tsofar += cnt.at(1);\n\t\t}\n\t}\n\tassert(sofar == N);\n\tnum += max(max_ub - max_lb + 1, 0);\n\tps(mul * num);\n\n\t// if = max:\n\t\t// b=1: OK\n\t// else:\n\t\t// b=0: (# less after) = max-a\n\t\t// b=1: (# greater after) + (# before) = max-a\n\t\t// N-1-(# <= after) = max-a\n\n\t\t// (# less after) = smth\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['combinatorics', 'data structures', 'greedy', 'sortings']",3300
https://codeforces.com//contest/1194/problem/E,E. Count The Rectangles,There are n segments drawn on a plane the i th segment connects two points x i 1 y i 1 and x i 2 y i 2 Each segment is non degenerate and is either horizontal or vertical formally for every i in 1 n either x i 1 x i 2 or y i 1 y i 2 but only one of these conditions holds Only segments of different types may intersect no pair of horizontal segments shares any common points and no pair of vertical segments shares any common points We say that four segments having indices h 1 h 2 v 1 and v 2 such that h 1 h 2 and v 1 v 2 form a rectangle if the following conditions hold segments h 1 and h 2 are horizontal segments v 1 and v 2 are vertical segment h 1 intersects with segment v 1 segment h 2 intersects with segment v 1 segment h 1 intersects with segment v 2 segment h 2 intersects with segment v 2 Please calculate the number of ways to choose four segments so they form a rectangle Note that the conditions h 1 h 2 and v 1 v 2 should hold ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n \nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<ll, ll> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<ll> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n \n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define F0R(i, a) for (ll i = 0; i < (a); i++)\n#define FORd(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (ll i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \n#define sz(x) (ll)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n \nconst ll MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst ll MX = 100001;\nconst ld PI = 4*atan((ld)1);\n \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n \ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n \nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n \n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n \n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n \nusing namespace input;\n \nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n \n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n \n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; trav(a,x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // prll w/ spaces\n    }\n}\n \nusing namespace output;\n \nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n \nusing namespace io;\n \ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n \ntemplate<class T> struct modll {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n \n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modll(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modll(T v = 0, T m = 0) : val(v) { normalize(); }\n \n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modll& a) { return os << a.val; }\n    friend bool operator==(const modll& a, const modll& b) { return a.val == b.val; }\n    friend bool operator!=(const modll& a, const modll& b) { return !(a == b); }\n \n    friend void check(modll& a, modll& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modll operator+(modll a, modll b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modll operator-(modll a, modll b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modll operator-(const modll& a) { return modll(0)-a; }\n \n    friend modll operator*(modll a, modll b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modll exp(modll a, ll p) {\n        modll ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modll inv(const modll& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modll operator/(modll a, modll b) { \n        check(a,b); return a*inv(b); \n    }\n};\n \ntypedef modll<ll> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n ll ans;\nint main() {\n    setIO();\n    ll n; cin >> n;\n    vector<pair<ll, pi>> horzs; // y, left x, right x\n    vector<pair<pi, ll>> verts; //bottom y, top y, x val\n    for(ll i = 0; i < n; i++){\n    \tll x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    \t/*x1 = x2 = i;\n    \ty1 = 0, y2 = 5000;*/\n    \tif(x1 == x2){ // vert\n    \t\tverts.pb(mp(mp(min(y1, y2), max(y1, y2)), x1));\n    \t}\n    \telse horzs.pb(mp(y1, mp(min(x1, x2), max(x1, x2))));\n    }\n    sort(horzs.begin(), horzs.end());\n    sort(verts.begin(), verts.end());\n    \n\tfor(ll i = sz(horzs)-1; i >= 0; i--){\n\t\tll curtop = horzs[i].f;\n\t\tll curleftx = horzs[i].s.f;\n\t\tll currightx = horzs[i].s.s;\n\t\tTree<ll> xvals;\n\t\tvector<pi> erasers;\n\t\tfor(ll j = sz(verts)-1; j>= 0; j--){\n\t\t\tif(verts[j].f.s < curtop) continue;\n\t\t\tif(verts[j].f.f > curtop) continue;\n\t\t\txvals.insert(verts[j].s);\n\t\t\terasers.pb(mp(verts[j].s, verts[j].f.f));\n\t\t}\n\t\tll ind = 0;\n\t\tfor(ll j = i-1; j >= 0; j--){\n\t\t\tif(horzs[j].s.f >= currightx) continue;\n\t\t\tif(horzs[j].s.s <= curleftx) continue;\n\t\t\tll cury = horzs[j].f;\n\t\t\twhile(ind < erasers.size() && erasers[ind].s > cury){\n\t\t\t\txvals.erase(erasers[ind].f);\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tll nums = (ll)xvals.order_of_key(min(horzs[j].s.s+1, (ll)currightx+1))-(ll)xvals.order_of_key(max(horzs[j].s.f, (ll)curleftx));\n\t\t\tans+=(nums*(nums-1))/2;\n\t\t}\n\t}\n\tcout << ans;\n}\n \n/* stuff you should look for\n    * ll overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n']","['bitmasks', 'brute force', 'data structures', 'geometry', 'sortings']",2200
https://codeforces.com//contest/1042/problem/F,F. Leaf Sets,You are given an undirected tree consisting of n vertices The vertex is called a leaf if it has exactly one vertex adjacent to it The distance between some pair of vertices is the number of edges in the shortest path between them Let s call some set of leaves if the maximum distance between any pair of leaves in it is less or equal to k You want to split leaves into beautiful sets What is the minimal number of sets in such a split ,"['#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who’s Kobe? \n// Fisherman can’t stop us\n// Average ABCDE on a good day\nusing namespace std;\n\nconst int MAXN = 1000005;\nint N, K;\nvector<int> adj[MAXN];\nint A[MAXN];\nint ans = 0;\n\nvoid dfs(int cur, int prv)\n{\n    if (adj[cur].size() == 1)\n    {\n        A[cur] = 0;\n        return;\n    }\n\n    vector<int> v;\n    for (auto nxt : adj[cur])\n    {\n        if (nxt == prv)\n            continue;\n        dfs(nxt, cur);\n        if (A[nxt] != -1)\n            v.push_back(A[nxt] + 1);\n    }\n    sort(v.begin(), v.end());\n    while (!v.empty() && v.back() >= K)\n    {\n        v.pop_back();\n        ans++;\n    }\n    while (v.size() >= 2 && v.back() + v[v.size() - 2] > K)\n    {\n        v.pop_back();\n        ans++;\n    }\n    if (!v.empty())\n        A[cur] = v.back();\n}\n\nint main()\n{\n    scanf(""%d %d"", &N, &K);\n    for (int i = 0, a, b; i < N - 1; i++)\n    {\n        scanf(""%d %d"", &a, &b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int root = -1;\n    for (int i = 1; i <= N; i++)\n        if (adj[i].size() > 1)\n        {\n            root = i;\n            break;\n        }\n\n    memset(A, -1, sizeof(A));\n    dfs(root, 0);\n    ans += A[root] != -1;\n    cout << ans << ""\\n"";\n\n    return 0;\n}\n']","['data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings', 'trees']",2400
https://codeforces.com//contest/1301/problem/A,A. Three Strings,You are given three strings a b and c of the same length n The strings consist of lowercase English letters only The i th letter of a is a i the i th letter of b is b i the i th letter of c is c i For every i 1 leq i leq n you swap i e exchange c i with either a i or b i So in total you ll perform exactly n swap operations each of them either c i leftrightarrow a i or c i leftrightarrow b i i iterates over all integers between 1 and n inclusive For example if a is b is and c is you can make c equal to taking the 1 st and the 4 th letters from a and the others from b In this way a becomes and b becomes Is it possible that after these swaps the string a becomes exactly the same as the string b ,"['#include <bits/stdc++.h>\n\nint T, n;\nstd::string a, b, c;\n\nbool solve() {\n    for (int i = 0; i < n; i++) {\n        if (a[i] == b[i]) {\n            if (a[i] != c[i]) { return false; }\n        } else if (a[i] == c[i] || b[i] == c[i]) {\n            \n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for (std::cin >> T; T; T--) {\n        std::cin >> a >> b >> c; n = a.size();\n        printf(""%s\\n"", solve() ? ""YES"" : ""NO"");\n    }\n    return 0;\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/1175/problem/B,B. Catch Overflow ,You are given a function f written in some basic language The function accepts an integer value which is immediately written into some variable x x is an integer variable and can be assigned values from 0 to 2 32 1 The function contains three types of commands for n for loop end every command between for n and corresponding end is executed n times add adds to x After the execution of these commands value of x is returned Every for n is matched with end thus the function is guaranteed to be valid for n can be immediately followed by end add command can be outside of any for loops Notice that add commands might overflow the value of x It means that the value of x becomes greater than 2 32 1 after some add command Now you run f 0 and wonder if the resulting value of x is correct or some overflow made it incorrect If overflow happened then output OVERFLOW otherwise print the resulting value of x ,"['#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MAXV = (1ll<<32);\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tll res = 0;\n\tvector<ll> stack = {1};\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tif (str == ""add"") {\n\t\t\tres += stack.back();\n\t\t} else if (str == ""for"") {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tstack.push_back(min(MAXV, k*stack.back()));\n\t\t} else if (str == ""end"") {\n\t\t\tstack.pop_back();\n\t\t}\n\t}\n\tif (res >= MAXV) cout << ""OVERFLOW!!!\\n"";\n\telse cout << res << \'\\n\';\n}\n']","['data structures', 'expression parsing', 'implementation']",1600
https://codeforces.com//contest/846/problem/D,D. Monitor,Recently Luba bought a monitor Monitor is a rectangular matrix of size But then she started to notice that some pixels cease to work properly Luba thinks that the monitor will become broken the first moment when it contains a square consisting entirely of broken pixels She knows that pixels are already broken and for each of them she knows the moment when it stopped working Help Luba to determine when the monitor became broken or tell that it s still not broken even after all pixels stopped working ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 514\n#define Q (N * N)\nint n , m , k , q , x[ Q ] , y[ Q ] , t[ Q ];\nint s[ N ][ N ] , c[ N ][ N ];\nbool broken( int cur ){\n  for( int i = 0 ; i <= n ; i ++ )\n    for( int j = 0 ; j <= m ; j ++ )\n      c[ i ][ j ] = 0;\n  for( int i = 0 ; i < q ; i ++ )\n    if( t[ i ] <= cur )\n      c[ x[ i ] ][ y[ i ] ] = 1;\n  for( int i = 1 ; i <= n ; i ++ )\n    for( int j = 1 ; j <= m ; j ++ )\n      if( c[ i ][ j ] ){\n        s[ i ][ j ] = min( s[ i - 1 ][ j ] ,\n                           min( s[ i ][ j - 1 ] , s[ i - 1 ][ j - 1 ] ) ) + 1;\n        if( s[ i ][ j ] >= k )\n          return true;\n      }else\n        s[ i ][ j ] = 0;\n  return false;\n}\nint main(){\n  cin >> n >> m >> k >> q;\n  for( int i = 0 ; i < q ; i ++ )\n    cin >> x[ i ] >> y[ i ] >> t[ i ];\n  int bl = 0 , br = 1000000000 , ba = -1;\n  while( bl <= br ){\n    int bmid = (bl + br) >> 1;\n    if( broken( bmid ) ) ba = bmid , br = bmid - 1;\n    else bl = bmid + 1;\n  }\n  cout << ba << endl;\n}\n']","['binary search', 'data structures']",1900
https://codeforces.com//contest/1010/problem/E,E. Store,Natasha was already going to fly back to Earth when she remembered that she needs to go to the Martian store to buy Martian souvenirs for her friends It is known that the Martian year lasts x max months month lasts y max days day lasts z max seconds Natasha also knows that this store works according to the following schedule 2 months in a year were selected x l and x r 1 le x l le x r le x max 2 days in a month y l and y r 1 le y l le y r le y max and 2 seconds in a day z l and z r 1 le z l le z r le z max The store works at all such moments month x day y second z when simultaneously x l le x le x r y l le y le y r and z l le z le z r Unfortunately Natasha does not know the numbers x l x r y l y r z l z r One Martian told Natasha I went to this store n m times n times of them it was opened and m times closed He also described his every trip to the store the month day second of the trip and whether the store was open or closed at that moment Natasha can go to the store k times For each of them determine whether the store at the time of the trip is open closed or this information is unknown ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin » t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nstruct SegTree {\n  int shift;\n  vector<int> tree;\n  vector<int> xs;\n  void build() {\n    make_unique(xs);\n    shift = 1;\n    while (shift < xs.size()) {\n      shift *= 2;\n    }\n    tree.assign(2 * shift, 0);\n  }\n  int get_lower_bound(int coord) {\n    return lower_bound(all(xs), coord) - xs.begin();\n  }\n  int get_sum(int l, int r) {\n    l = get_lower_bound(l);\n    r = get_lower_bound(r);\n    l += shift;\n    r += shift;\n    int res = 0;\n    while (l < r) {\n      if (l & 1) {\n        res += tree[l++];\n        continue;\n      }\n      if (r & 1) {\n        res += tree[--r];\n        continue;\n      }\n      l /= 2;\n      r /= 2;\n    }\n    return res;\n  }\n  void update(int x, int val) {\n    int v = get_lower_bound(x);\n    assert(xs[v] == x);\n    v += shift;\n    while (v) {\n      tree[v] += val;\n      v /= 2;\n    }\n  }\n};\n\nstruct LargeTree {\n  int shift;\n  vector<SegTree> trees;\n  LargeTree(int n) {\n    shift = 1;\n    while (shift < n) {\n      shift *= 2;\n    }\n    trees.resize(2 * shift);\n  }\n  void build() {\n    for (int i = 0; i < trees.size(); ++i) {\n      trees[i].build();\n    }\n  }\n  void raw_insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].xs.push_back(y);\n      x /= 2;\n    }\n  }\n  void insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].update(y, 1);\n      x /= 2;\n    }\n  }\n  int count(int lx, int rx, int ly, int ry) {\n    lx += shift;\n    rx += shift;\n    int res = 0;\n    while (lx < rx) {\n      if (lx & 1) {\n        res += trees[lx++].get_sum(ly, ry);\n        continue;\n      }\n      if (rx & 1) {\n        res += trees[--rx].get_sum(ly, ry);\n        continue;\n      }\n      lx /= 2;\n      rx /= 2;\n    }\n    return res;\n  }\n};\n\nconst int C = 100500;\n\nstruct Query {\n  int z;\n  int lx, rx;\n  int ly, ry;\n  int sign;\n  int id;\n};\n\nint pidorand() {\n  return (rand() << 16) | rand();\n}\n\n#ifndef AIM\n#define rand pidorand\n#endif\n\nvoid solve(bool read) {\n  //read = false;\n  LargeTree tree(C);\n  vector<int> borders(3);\n  for (int i = 0; i < 3; ++i) {\n    if (read) {\n      cin >> borders[i];\n    } else {\n      borders[i] = 100000;\n    }\n  }\n  int n, m, k;\n  if (read) {\n    cin >> n >> m >> k;\n  } else {\n    n = 1;\n    m = 100000;\n    k = 100000;\n  }\n  vector<int> mins(3, C), maxes(3, 0);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      int cur;\n      if (read) {\n        cin >> cur;\n      } else {\n        cur = rand() % borders[j] + 1;\n      }\n      relax_min(mins[j], cur);\n      relax_max(maxes[j], cur);\n    }\n  }\n  auto is_into = [&] (const vector<int>& cur) {\n    for (int i = 0; i < 3; ++i) {\n      if (cur[i] < mins[i] || cur[i] > maxes[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  vector<vector<vector<int>>> not_visited(C);\n  for (int i = 0; i < m; ++i) {\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n    }\n    if (is_into(cur)) {\n      cout << ""INCORRECT\\n"";\n      return;\n    }\n    not_visited[cur[2]].push_back({cur[0], cur[1]});\n    tree.raw_insert(cur[0], cur[1]);\n  }\n  tree.build();\n\n  cout << ""CORRECT\\n"";\n\n  vector<int> res(k, 0);\n  vector<bool> is_inside(k, false);\n  vector<vector<Query>> queries(C);\n  for (int i = 0; i < k; ++i) {\n    auto cur_mins = mins;\n    auto cur_maxes = maxes;\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n      relax_min(cur_mins[j], cur[j]);\n      relax_max(cur_maxes[j], cur[j]);\n    }\n    if (is_into(cur)) {\n      is_inside[i] = true;\n      continue;\n    }\n    Query cur_q = {cur_maxes[2], cur_mins[0], cur_maxes[0] + 1, cur_mins[1], cur_maxes[1] + 1, 1, i};\n    queries[cur_q.z].push_back(cur_q);\n    cur_q.z = cur_mins[2] - 1;\n    cur_q.sign = -1;\n    if (cur_q.z >= 0) {\n      queries[cur_q.z].push_back(cur_q);\n    }\n  }\n\n  for (int z = 0; z < C; ++z) {\n    for (auto& vec : not_visited[z]) {\n      tree.insert(vec[0], vec[1]);\n    }\n    for (auto& q : queries[z]) {\n      res[q.id] += q.sign * tree.count(q.lx, q.rx, q.ly, q.ry);\n    }\n  }\n\n  for (int i = 0; i < k; ++i) {\n    if (is_inside[i]) {\n      cout << ""OPEN\\n"";\n      continue;\n    }\n    if (res[i] > 0) {\n      cout << ""CLOSED\\n"";\n      continue;\n    }\n    cout << ""UNKNOWN\\n"";\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']",['data structures'],2700
https://codeforces.com//contest/1217/problem/F,F. Forced Online Queries Problem,You are given an undirected graph with n vertices numbered from 1 to n Initially there are no edges You are asked to perform some queries on the graph Let last be the answer to the latest query of the second type it is set to 0 before the first such query Then the queries are the following 1 x y 1 le x y le n x ne y add an undirected edge between the vertices x last 1 mod n 1 and y last 1 mod n 1 if it doesn t exist yet otherwise remove it 2 x y 1 le x y le n x ne y check if there exists a path between the vertices x last 1 mod n 1 and y last 1 mod n 1 which goes only through currently existing edges and set last to 1 if so and 0 otherwise Good luck ,"['#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/06, 00:30:55\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst int B = 1000;\nint n, m;\nint T[200001];\nint X[200001];\nint Y[200001];\nvector<pii> es;\n\nint par[200001];\nint find(int x) {\n    if (par[x]) return par[x] = find(par[x]);\n    return x;\n}\n\nbool merge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    par[y] = x;\n    return 1;\n}\n\nint last;\nvector<int> edge[200001];\nbool vis[200001];\n\nvoid dfs(int x, bool ch) {\n    vis[x] = ch;\n    for (int i : edge[x]) {\n        if (vis[i] == ch) continue;\n        dfs(i, ch);\n    }\n}\n\nvoid solve(int st, int ed) {\n    for (int i = 1; i <= n; ++i) {\n        par[i] = 0;\n    }\n    vector<pii> ch;\n    for (int i = st; i <= ed; ++i) {\n        if (T[i] == 1) {\n            int x = X[i], y = Y[i];\n            if (x > y) swap(x, y);\n            ch.emplace_back(x, y);\n            x = x % n + 1;\n            y = y % n + 1;\n            if (x > y) swap(x, y);\n            ch.emplace_back(x, y);\n        }\n    }\n    sort(ch.begin(), ch.end());\n    vector<int> in(ch.size());\n    for (pii i : es) {\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it != ch.end() && *it == i) continue;\n        merge(i.fs, i.se);\n    }\n    vector<int> er;\n    for (pii i : es) {\n        if (i.fs > i.se) swap(i.fs, i.se);\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it == ch.end() || *it != i) continue;\n        in[it - ch.begin()] = 1;\n        int x = find(i.fs);\n        int y = find(i.se);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n        er.push_back(x);\n        er.push_back(y);\n    }\n    for (int i = st; i <= ed; ++i) {\n        if (T[i] == 1) {\n            int x = X[i], y = Y[i];\n            if (last) {\n                x = x % n + 1;\n                y = y % n + 1;\n            }\n            if (x > y) swap(x, y);\n            int j = lower_bound(ch.begin(), ch.end(), pii(x, y)) - ch.begin();\n            x = find(x);\n            y = find(y);\n            if (in[j]) {\n                edge[x].erase(find(edge[x].begin(), edge[x].end(), y));\n                edge[y].erase(find(edge[y].begin(), edge[y].end(), x));\n            }\n            else {\n                edge[x].push_back(y);\n                edge[y].push_back(x);\n                er.push_back(x);\n                er.push_back(y);\n            }\n            in[j] ^= 1;\n        }\n        else {\n            int x = X[i], y = Y[i];\n            if (last) {\n                x = x % n + 1;\n                y = y % n + 1;\n            }\n            x = find(x);\n            y = find(y);\n            dfs(x, 1);\n            last = vis[y];\n            dfs(x, 0);\n            printf(""%d"", last);\n        }\n    }\n    for (int i : er) edge[i].clear();\n    vector<pii> nxt;\n    for (pii i : es) {\n        if (i.fs > i.se) swap(i.fs, i.se);\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it != ch.end() && *it == i) {\n            if (in[it - ch.begin()] == 0) continue;\n            in[it - ch.begin()] = 0;\n        }\n        nxt.push_back(i);\n    }\n    for (int i = 0; i < ch.size(); ++i) {\n        if (in[i]) nxt.push_back(ch[i]);\n    }\n    swap(es, nxt);\n    sort(es.begin(), es.end());\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i) {\n        cin >> T[i] >> X[i] >> Y[i];\n    }\n    for (int it = 0; it < B; ++it) {\n        int st = it * B + 1;\n        int ed = min((it + 1) * B, m);\n        if (st > ed) break;\n        solve(st, ed);\n    }\n    return 0;\n}\n']","['data structures', 'divide and conquer', 'dsu', 'graphs', 'trees']",2600
https://codeforces.com//contest/1588/problem/C,C. Game with Stones,Bob decided to take a break from calculus homework and designed a game for himself The game is played on a sequence of piles of stones which can be described with a sequence of integers s 1 ldots s k where s i is the number of stones in the i th pile On each turn Bob picks a pair of non empty adjacent piles i and i 1 and takes one stone from each If a pile becomes empty its adjacent piles The game ends when Bob can t make turns anymore Bob considers himself a winner if at the end all piles are empty We consider a sequence of piles if Bob can start with it and win with some sequence of moves You are given a sequence a 1 ldots a n count the number of subsegments of a that describe a winning sequence of piles In other words find the number of segments l r 1 leq l leq r leq n such that the sequence a l a l 1 ldots a r is winning ,"['#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 1600;\n\nlint query(int s, int e){\n\tcout << ""? "" << s << "" "" << e << endl;\n\tlint x; cin >> x; return x;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n; cin >> n;\n\t\tvector<lint> a(n + 1);\n\t\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\t\t// even negated\n\t\tfor(int i = 2; i <= n; i += 2) a[i] *= -1; \n\t\tfor(int i = 1; i <= n; i++) a[i] += a[i - 1];\n\t\tlint ans = 0;\n\t\tvector<pi> cnts;\n\t\tfor(int i = 1; i <= n; i++) cnts.emplace_back(a[i], i);\n\t\tsort(all(cnts));\n\t\tvector<pi> stk[2];\n\t\tfor(int i = n; i; i--){\n\t\t\tpi val(a[i], i);\n\t\t\tif(i % 2 == 0) val.first *= -1;\n\t\t\twhile(sz(stk[i % 2]) && stk[i % 2].back().first >= val.first) stk[i % 2].pop_back();\n\t\t\tstk[i % 2].push_back(val);\n\t\t\tint lastpos = n;\n\t\t\t{\n\t\t\t\tauto l = lower_bound(all(stk[0]), pi(-a[i - 1], -1));\n\t\t\t\tif(l != stk[0].begin()) lastpos = min(lastpos, (int)prev(l)->second - 1);\n\t\t\t}\t\n\t\t\t{\n\n\t\t\t\tauto l = lower_bound(all(stk[1]), pi(a[i - 1], -1));\n\t\t\t\tif(l != stk[1].begin()) lastpos = min(lastpos, (int)prev(l)->second - 1);\n\t\t\t}\n\t\t\t/*\n\t\t\t   for(int j = i; j <= n; j++){\n\t\t\t   if(j % 2 == 0 && a[j] > a[i - 1]) break;\n\t\t\t   if(j % 2 == 1 && a[j] < a[i - 1]) break;\n\t\t\t   lastpos = j;\n\t\t\t}*/\n\t\t\tauto s = lower_bound(all(cnts), pi(a[i - 1], i));\n\t\t\tauto e = upper_bound(all(cnts), pi(a[i - 1], lastpos));\n\t\t\tans += e - s;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n']","['binary search', 'data structures', 'divide and conquer', 'games', 'greedy']",2300
https://codeforces.com//contest/1038/problem/F,F. Wrap Around,You are given a binary string s Find the number of distinct binary strings of length n which contain s as a substring The cyclical string t contains s as a substring if there is some cyclical shift of string t such that s is a substring of this cyclical shift of t For example the cyclical string contains substrings and but doesn t contain and Two cyclical strings are called different if they differ from each other as strings For example two different strings which differ from each other by a cyclical shift are still considered cyclical strings ,"['#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\ntypedef long long LL;\nint used[N],Next[N],a[N];char s[N];\nLL F[N][N][2],tmp[N][2],ans;int n,m;\nvoid clear(){\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int k=0;k<m;k++)\n\t\t\tF[i][k][0]=F[i][k][1]=0;\n}\nvoid dp(int st,int ed){\n\tfor (int i=st;i<=ed;i++)\n\t\tfor (int k=0;k<m;k++)\n\t\t\tfor (int ok=0;ok<2;ok++)\n\t\t\t\tif (F[i-1][k][ok]){\n\t\t\t\t\tfor (int cur=0;cur<2;cur++){\n\t\t\t\t\t\tif (used[i]!=-1&&used[i]!=cur) continue;\n\t\t\t\t\t\tint j=k;\n\t\t\t\t\t\tfor (;j&&a[j+1]!=cur;j=Next[j]);\n\t\t\t\t\t\tj+=a[j+1]==cur;\n\t\t\t\t\t\tif (j==m) F[i][0][1]+=F[i-1][k][ok];\n\t\t\t\t\t\t\t else F[i][j][ok]+=F[i-1][k][ok];\n\t\t\t\t\t}\n\t\t\t\t}\n}\nint main(){\n\tscanf(""%d"",&n);\n\tscanf(""%s"",s+1);m=strlen(s+1);\n\tfor (int i=1;i<=m;i++)\n\t\ta[i]=s[i]-\'0\';\n\tfor (int i=2,j=0;i<=m;i++){\n\t\tfor (;j&&a[j+1]!=a[i];j=Next[j]);\n\t\tNext[i]=(j+=a[j+1]==a[i]);\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=-1;\n\tclear();F[0][0][0]=1;dp(1,n);\n\tfor (int k=0;k<m;k++)\n\t\tans+=F[n][k][1];\n\tfor (int len=1;len<m;len++){\n\t\tfor (int i=1;i<=n;i++) used[i]=-1;\n\t\tfor (int i=1;i<=len;i++)\n\t\t\tused[n-len+i]=a[i];\n\t\tfor (int i=len+1;i<=m;i++)\n\t\t\tused[i-len]=a[i];\n\t\tclear();F[n-len+1][0][0]=1;\n\t\tdp(n-len+2,n);\n\t\tfor (int k=0;k<m;k++)\n\t\t\tfor (int ok=0;ok<2;ok++) \n\t\t\t\ttmp[k][ok]=F[n][k][ok];\n\t\tclear();\n\t\tfor (int k=0;k<m;k++)\n\t\t\tfor (int ok=0;ok<2;ok++)\n\t\t\t\tF[0][k][ok]=tmp[k][ok];\n\t\tdp(1,n);\n\t\tfor (int k=0;k<m;k++)\n\t\t\tans+=F[n][k][0];\n\t}\n\tprintf(""%lld\\n"",ans);\n}']","['dp', 'strings']",2900
https://codeforces.com//contest/1103/problem/A,A. Grid game,You are given a 4x4 grid You play a game there is a sequence of tiles each of them is either 2x1 or 1x2 Your task is to consequently place all tiles from the given sequence in the grid When tile is placed each cell which is located in fully occupied row or column is deleted cells are deleted at the same time independently You can place tile in the grid at any position the only condition is that tiles and tile parts should not overlap Your goal is to proceed all given figures and avoid crossing at any time ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  string s;\n  cin >> s;\n\n  int cur_0 = 1;\n  int cur_1 = 1;\n\n  for (char ch : s) {\n    if (ch == \'0\') {\n      cout << ""1 "" << cur_0 << ""\\n"";\n      if (cur_0 == 4) {\n        cur_0 = 1;\n      } else {\n        ++cur_0;\n      }\n    } else {\n      cout << ""3 "" << cur_1 << ""\\n"";\n      if (cur_1 == 3) {\n        cur_1 = 1;\n      } else {\n        cur_1 += 2;\n      }\n    }\n  }\n}\n\n']","['constructive algorithms', 'implementation']",1400
https://codeforces.com//contest/1249/problem/A,A. Yet Another Dividing into Teams,You are a coach of a group consisting of n students The i th student has programming skill a i You want to divide them into teams in such a way that No two students i and j such that a i a j 1 belong to the same team i e skills of each pair of students in the same team have the difference strictly greater than 1 the number of teams is the minimum possible You have to answer q independent queries ,"['#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<\'0\'||c>\'9\');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>=\'0\'&&c<=\'9\');\n\treturn res;\n}\nint s[100010];\nint main() {\n\tint T=read();\n\twhile(T--){\n\t\tint N=read();\n\t\tfor(int i=1; i<=N; i++){\n\t\t\ts[i]=read();\n\t\t}\n\t\tsort(s+1, s+1+N);\n\t\tint ans = 1;\n\t\tfor(int i=1; i<N; i++){\n\t\t\tif(s[i]==s[i+1]-1)ans=2;\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}\n']",['math'],800
https://codeforces.com//contest/1932/problem/F,F. Feed Cats,There is a fun game where you need to feed cats that come and go The level of the game consists of n steps There are m cats the cat i is present in steps from l i to r i inclusive In each step you can feed all the cats that are currently present or do nothing If you feed the same cat more than once it will overeat and you will immediately lose the game Your goal is to feed as many cats as possible without causing any cat to overeat Find the maximum number of cats you can feed Formally you need to select several integer points from the segment from 1 to n in such a way that among given segments none covers two or more of the selected points and as many segments as possible cover one of the selected points ,"['//Be Name KHODA\n#pragma GCC optimize(""Ofast"")\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define pb push_back\n#define pp pop_back\n#define lb lower_bound\n#define ub upper_bound\n#define cl clear\n#define bg begin\n#define arr(x) array<int , x>\n#define endl \'\\n\'\n\nint t , n , m;\nvector<int> sgsr[1000001] , sgsl[1000001];\nmultiset<int> ls;\nll dp[1000001];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> t;\n    for(int ii = 0 ; ii < t ; ii++){\n        cin >> n >> m;\n        for(int i = 1 ; i <= n ; i++) sgsr[i].cl() , sgsl[i].cl();\n        fill(&dp[0] , &dp[n + 1] , 0) , ls.cl();\n        for(int i = 0 ; i < m ; i++){\n            int l , r;\n            cin >> l >> r;\n            sgsr[r].pb(l) , sgsl[l].pb(r);\n        }\n        dp[0] = 0;\n        for(int i = 1 ; i <= n ; i++){\n            for(int l : sgsr[i - 1]) ls.erase(ls.find(l));\n            for(int r : sgsl[i]) ls.insert(i);\n            if(ls.empty()) dp[i] = dp[i - 1];\n            else{\n                ll dd = dp[*(ls.bg()) - 1] + (1ll * (int)ls.size());\n                dp[i] = max(dd , dp[i - 1]);\n            }\n        }\n        ll o = 0;\n        for(int i = 0 ; i <= n ; i++) o = max(o , dp[i]);\n        cout << o << endl;\n    }\n}']","['data structures', 'dp', 'sortings']",1900
https://codeforces.com//contest/1809/problem/C,C. Sum on Subarrays,For an array a a 1 a 2 dots a n let s denote its a l r as the array a l a l 1 dots a r For example the array a 1 3 1 has 6 non empty subarrays a 1 1 1 a 1 2 1 3 a 1 3 1 3 1 a 2 2 3 a 2 3 3 1 a 3 3 1 You are given two integers n and k Construct an array a consisting of n integers such that all elements of a are from 1000 to 1000 a has exactly k subarrays with positive sums the rest dfrac n 1 cdot n 2 k subarrays of a have negative sums ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    int x = 0;\n    while ((x + 1) * (x + 2) / 2 <= k) {\n        x += 1;\n    }\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        if (i < x) {\n            a[i] = 2;\n        } else if (i == x) {\n            a[i] = -2 * x - 1 + 2 * (k - x * (x + 1) / 2);\n        } else {\n            a[i] = -1000;\n        }\n        std::cout << a[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['constructive algorithms', 'greedy', 'math']",1500
https://codeforces.com//contest/1671/problem/D,D. Insert a Progression,You are given a sequence of n integers a 1 a 2 dots a n You are also given x integers 1 2 dots x You are asked to insert each of the extra integers into the sequence a Each integer can be inserted at the beginning of the sequence at the end of the sequence or between any elements of the sequence The score of the resulting sequence a is the sum of absolute differences of adjacent elements in it left sum limits i 1 n x 1 a i a i 1 right What is the smallest possible score of the resulting sequence a ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:41:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    long long ans = 0;\n    for (int i = 0; i < n - 1; i++) {\n      ans += abs(a[i] - a[i + 1]);\n    }\n    {\n      int mn = (int) 1e9;\n      mn = min(mn, a[0] - 1);\n      mn = min(mn, a[n - 1] - 1);\n      for (int i = 0; i < n; i++) {\n        mn = min(mn, 2 * (a[i] - 1));\n      }\n      ans += mn;\n    }\n    int mx = *max_element(a.begin(), a.end());\n    if (mx < x) {\n      int mn = (int) 1e9;\n      mn = min(mn, x - a[0]);\n      mn = min(mn, x - a[n - 1]);\n      for (int i = 0; i < n; i++) {\n        mn = min(mn, 2 * (x - a[i]));\n      }\n      ans += mn;\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy']",1600
https://codeforces.com//contest/489/problem/A,A. SwapSort,In this problem your goal is to sort an array consisting of integers in at most swaps For the given array find the sequence of swaps that makes the array sorted in the non descending order Swaps are performed consecutively one after another Note that in this problem you do not have to minimize the number of swaps your task is to find any sequence that is no longer than ,"['#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\nconst int MAX = 3000 + 10;\nint rec[MAX];\nint main(){\n    int n;\n    scanf(""%d"", &n);\n    for(int i= 0 ; i < n ; i++){\n        scanf(""%d"", &rec[i]);\n    }\n    vector<pair<int,int>> v;\n    for(int i = 0 ; i < n ; i++){\n        int tmp = i;\n        for(int j = i ; j < n ; j++){\n            if(rec[tmp] > rec[j])\n                tmp = j;\n        }\n        if(tmp != i) v.push_back(make_pair(tmp, i));\n        swap(rec[tmp], rec[i]);\n    }\n    printf(""%d\\n"", v.size());\n    for(int i= 0 ; i < v.size() ; i++)\n        printf(""%d %d\\n"", v[i].first, v[i].second);\n    return 0;\n}\n']","['greedy', 'implementation', 'sortings']",1200
https://codeforces.com//contest/818/problem/F,F. Level Generation,Ivan is developing his own computer game Now he tries to create some levels for his game But firstly for each level he needs to draw a graph representing the structure of the level Ivan decided that there should be exactly vertices in the graph representing level and the edges have to be bidirectional When constructing the graph Ivan is interested in special edges called An edge between two vertices and is called a if this edge belongs to every path between and and these vertices will belong to different connected components if we delete this edge For each level Ivan wants to construct a graph where at least half of the edges are He also wants to maximize the number of edges in each constructed graph So the task Ivan gave you is given numbers for each tell the maximum number of edges in a graph with vertices if at least half of the edges are ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL C2( LL x ){ return x * ( x - 1 ) / 2; }\nint main(){\n  int q; cin >> q; while( q -- ){\n    LL n , a = 0; cin >> n;\n    LL bl = 1 , br = n - 1;\n    while( bl <= br ){\n      LL mid = (bl + br) >> 1;\n      LL res = C2( n - mid );\n      if( res < mid ){\n        a = max( a , mid + res );\n        br = mid - 1;\n      }else{\n        a = max( a , mid + mid );\n        bl = mid + 1;\n      }\n    }\n    cout << a << endl;\n  }\n}\n']","['binary search', 'math', 'ternary search']",2100
https://codeforces.com//contest/1721/problem/D,D. Maximum AND,You are given two arrays a and b consisting of n integers each Let s define a function f a b as follows let s define an array c of size n where c i a i oplus b i oplus denotes bitwise XOR the value of the function is c 1 mathbin c 2 mathbin cdots mathbin c n i e bitwise AND of the entire array c Find the maximum value of the function f a b if you can reorder the array b in an arbitrary way leaving the initial order is also an option ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    auto check = [&](int x) {\n        std::vector<int> c(n), d(n);\n        for (int i = 0; i < n; i++) {\n            c[i] = a[i] & x;\n            d[i] = ~b[i] & x;\n        }\n        std::sort(c.begin(), c.end());\n        std::sort(d.begin(), d.end());\n        return c == d;\n    };\n    \n    int ans = 0;\n    for (int d = 29; d >= 0; d--) {\n        if (check(ans | 1 << d)) {\n            ans |= 1 << d;\n        }\n    }\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['bitmasks', 'dfs and similar', 'divide and conquer', 'greedy', 'sortings']",1800
https://codeforces.com//contest/814/problem/A,A. An abandoned sentiment from past,A few years ago Hitagi encountered a giant crab who stole the whole of her body weight Ever since she tried to avoid contact with others for fear that this secret might be noticed To get rid of the oddity and recover her weight a special integer sequence is needed Hitagi s sequence has been broken for a long time but now Kaiki provides an opportunity Hitagi s sequence has a length of Lost elements in it are denoted by zeros Kaiki provides another sequence whose length equals the number of lost elements in i e the number of zeros Hitagi is to replace each zero in with an element from so that Hitagi knows however that If the resulting sequence is an increasing sequence then it has the power to recover Hitagi from the oddity You are to determine whether this is possible or Kaiki s sequence is just another fake In other words you should detect whether it is possible to replace each zero in with an integer from so that each integer from is used exactly once and the resulting sequence is increasing ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint n, k;\n\nint a[maxn];\n\nint pos;\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> k;\n    if (k > 1){\n        cout << ""Yes"";\n        return 0;\n    }\n    for (int i = 0; i < n; i++){\n        cin >> a[i];\n        if (a[i] == 0)\n            pos = i;\n        if (i > 0 && a[i] < a[i - 1] && a[i] != 0){\n            cout << ""Yes"";\n            return 0;\n        }\n    }\n    int x;\n    cin >> x;\n    if ((pos == 0 || a[pos - 1] < x) && (pos == n - 1 || a[pos + 1] > x))\n        cout << ""No"";\n    else\n        cout << ""Yes"";\n}\n']","['constructive algorithms', 'greedy', 'implementation', 'sortings']",900
https://codeforces.com//contest/616/problem/B,B. Dinner with Emma,Jack decides to invite Emma out for a dinner Jack is a modest student he doesn t want to go to an expensive restaurant Emma is a girl with high taste she prefers elite places Munhattan consists of streets and avenues There is exactly one restaurant on the intersection of each street and avenue The streets are numbered with integers from to and the avenues are numbered with integers from to The cost of dinner in the restaurant at the intersection of the th street and the th avenue is Jack and Emma decide to choose the restaurant in the following way Firstly Emma chooses the street to dinner and then Jack chooses the avenue Emma and Jack makes their choice optimally Emma wants to maximize the cost of the dinner Jack wants to minimize it Emma takes into account that Jack wants to minimize the cost of the dinner Find the cost of the dinner for the couple in love ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tint mx = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint mn = 2e9;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tmn = min(mn, a);\n\t\t}\n\t\tmx = max(mx, mn);\n\t}\n\tcout << mx << ""\\n"";\n\treturn 0;\n}\n\n\n']","['games', 'greedy']",1000
https://codeforces.com//contest/1325/problem/D,D. Ehab the Xorcist,Given 2 integers u and v find the shortest array such that bitwise xor of its elements is u and the sum of its elements is v ,"['///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 3e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nll n, m, x, s;\nll cnt[70];\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> x >> s;\n    if(x % 2 != s % 2) return cout<< -1, 0;\n    if(x > s) return cout<< -1, 0;\n\n    if(x == 0 && s == 0)\n        return cout<< 0, 0;\n\n    int X = x, S = s;\n    if(x == s)\n    {\n        cout<< 1 <<""\\n""<< x;\n        return 0;\n    }\n\n    /// 2\n    for(int i = 0; i < 60; i++)\n        if(x&(1ll<<i))\n            s -= (1ll<<i);\n        else\n          cnt[i+1] = 1;\n\n    bool T = 1;\n    for(int i = 0; i < 60; i++)\n        if((s & (1ll<<i)) && !cnt[i])\n            T = 0;\n\n    if(T)\n    {\n        cout<< 2 <<""\\n"";\n        int a = x, b = 0;\n        for(int i = 0; i < 60; i++)\n            if(s & (1ll<<i))\n            {\n                a += (1ll<<(i-1));\n                b += (1ll<<(i-1));\n            }\n        cout<< a <<"" ""<< b;\n        return 0;\n    }\n\n    x = X, s = S;\n    int a = x, b = 0, c = 0;\n    s -= x;\n    for(int i = 0; i < 60; i++)\n        if(s & (1ll<<i))\n        {\n            b += (1ll<<(i-1));\n            c += (1ll<<(i-1));\n        }\n    cout<< 3 <<""\\n""<< a <<"" ""<< b <<"" ""<< c;\n}\n\n']","['bitmasks', 'constructive algorithms', 'greedy', 'number theory']",1700
https://codeforces.com//contest/668/problem/D,D. Little Artem and Time Machine,Little Artem has invented a time machine He could go anywhere in time but all his thoughts of course are with computer science He wants to apply this time machine to a well known data structure Artem wants to create a basic multiset of integers He wants these structure to support operations of three types Add integer to the multiset Note that the difference between set and multiset is that multiset may store several instances of one integer Remove integer from the multiset Only one instance of this integer is removed Artem doesn t want to handle any exceptions so he assumes that every time remove operation is called that integer is presented in the multiset Count the number of instances of the given integer that are stored in the multiset But what about time machine Artem doesn t simply apply operations to the multiset one by one he now travels to different moments of time and apply his operation there Consider the following example First Artem adds integer to the multiset at the st moment of time Then Artem adds integer to the multiset at the moment Then Artem asks how many are there in the multiset at moment The answer is Then Artem returns back in time and asks how many integers are there in the set at moment Since was added only at moment the number of integers at moment equals to Then Artem goes back in time again and removes from the multiset at moment Finally Artyom asks at moment how many integers are there in the set The result is since we have removed at the moment Note that Artem dislikes exceptions so much that he assures that after each change he makes all delete operations are applied only to element that is present in the multiset The answer to the query of the third type is computed at the moment Artem makes the corresponding query and are not affected in any way by future changes he makes Help Artem implement time travellers multiset ,"['#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\n\nunsigned long long readTimeStampCounter() {\n\tunsigned a = 123456789, b = 987654321;\n#ifdef __GNUC__\n\tasm(\n\t\t""rdtsc;\\n\\t""\n\t\t: ""=d"" (a), ""=a"" (b)\n\t);\n#else\n\t__asm {\n\t\trdtsc;\n\t\tmov a, edx;\n\t\tmov b, eax;\n\t};\n#endif\n\treturn (unsigned long long)a << 32 | b;\n}\nunsigned xor128() {\n\tstatic unsigned x = 123456789, y = 362436069,\n\t\tz = (unsigned)(readTimeStampCounter() >> 32), w = (unsigned)readTimeStampCounter();\n\tunsigned t = x ^ (x << 11);\n\tx = y; y = z; z = w;\n\treturn w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n}\n\n\nstruct Node {\n\tstatic const int K = 3;\n\tstatic Node nullNode;\n\n\tNode *left, *right;\n\tint size;\n\tint pos;\n\tint val, sum;\n\n\tbool isNull() const { return this == &nullNode; }\n\n\tNode *set(int p, int v) {\n\t\tleft = right = &nullNode;\n\t\tpos = p;\n\t\tval = v;\n\t\treturn update();\n\t}\n\n\tinline Node *update() {\n\t\tassert(!isNull());\n\t\tsize = left->size + 1 + right->size;\n\t\tsum = left->sum + val + right->sum;\n\t\treturn this;\n\t}\n\tinline void propagate() {}\n\tinline Node *linkl(Node *c) {\n\t\tleft = c;\n\t\treturn update();\n\t}\n\tinline Node *linkr(Node *c) {\n\t\tright = c;\n\t\treturn update();\n\t}\n\tinline Node *linklr(Node *l, Node *r) {\n\t\tleft = l, right = r;\n\t\treturn update();\n\t}\n};\nNode Node::nullNode = {\n\t&nullNode, &nullNode,\n\t0, -1,\n\t0, 0\n};\n\nstruct RBST {\n\ttypedef Node *Ref;\n\tstatic const int MaxHeight = 32 * 4;\n\tstatic Ref join(Ref l, Ref r) {\n\t\tif(l->isNull()) return r;\n\t\tif(r->isNull()) return l;\n\t\tif((int)(xor128() % (l->size + r->size)) < l->size) {\n\t\t\tl->propagate();\n\t\t\treturn l->linkr(join(l->right, r));\n\t\t} else {\n\t\t\tr->propagate();\n\t\t\treturn r->linkl(join(l, r->left));\n\t\t}\n\t}\n\ttypedef pair<Ref, Ref> RefPair;\n\tstatic RefPair splitRemovePos(Ref t, int pos, bool remove) {\n\t\tif(t->isNull()) return RefPair(&Node::nullNode, &Node::nullNode);\n\t\tt->propagate();\n\t\tif(pos == t->pos && remove) {\n\t\t\tNode *l = t->left, *r = t->right;\n\t\t\t*t = Node::nullNode;\n\t\t\treturn RefPair(l, r);\n\t\t} else if(pos <= t->pos) {\n\t\t\tRefPair p = splitRemovePos(t->left, pos, remove);\n\t\t\treturn RefPair(p.first, t->linkl(p.second));\n\t\t} else {\n\t\t\tRefPair p = splitRemovePos(t->right, pos, remove);\n\t\t\treturn RefPair(t->linkr(p.first), p.second);\n\t\t}\n\t}\n\tstatic Ref insertPos(Ref t, Ref n) {\n\t\tif(xor128() % (t->size + 1) == 0 || n->pos == t->pos) {\n\t\t\tRefPair p = splitRemovePos(t, n->pos, true);\n\t\t\treturn n->linklr(p.first, p.second);\n\t\t}\n\t\tt->propagate();\n\t\tif(n->pos < t->pos)\n\t\t\treturn t->linkl(insertPos(t->left, n));\n\t\telse\n\t\t\treturn t->linkr(insertPos(t->right, n));\n\t}\n};\n\nint main() {\n\trep(k, 100) xor128();\n\tint Q;\n\twhile(~scanf(""%d"", &Q)) {\n\t\tmap<int, int> valID;\n\t\tvector<Node> nodes(Q);\n\t\tvector<Node*> seqs(Q, &Node::nullNode);\n\t\tfor(int i = 0; i < Q; ++ i) {\n\t\t\tint ty;\n\t\t\tscanf(""%d"", &ty);\n\t\t\tint t; int x;\n\t\t\tscanf(""%d%d"", &t, &x);\n\t\t\tint k = valID.emplace(x, valID.size()).first->second;\n\t\t\tif(ty == 1) {\n\t\t\t\tNode *a = &nodes[i];\n\t\t\t\ta->set(t, 1);\n\t\t\t\tseqs[k] = RBST::insertPos(seqs[k], a);\n\t\t\t} else if(ty == 2) {\n\t\t\t\tNode *a = &nodes[i];\n\t\t\t\ta->set(t, -1);\n\t\t\t\tseqs[k] = RBST::insertPos(seqs[k], a);\n\t\t\t} else if(ty == 3) {\n\t\t\t\tauto p = RBST::splitRemovePos(seqs[k], t, false);\n\t\t\t\tint ans = p.first->sum;\n\t\t\t\tseqs[k] = RBST::join(p.first, p.second);\n\t\t\t\tprintf(""%d\\n"", ans);\n\t\t\t} else abort();\n\t\t}\n\t}\n\treturn 0;\n}\n']",['data structures'],2000
https://codeforces.com//contest/1900/problem/B,B. Laura and Operations,Nemanja wrote some digits on the board All of them are either 1 2 or 3 The number of digits 1 is a The number of digits 2 is b and the number of digits 3 is c He told Laura that in one operation she can do the following Select two different digits and erase them from the board After that write the digit 1 2 or 3 different from both erased digits For example let the digits be 1 1 1 2 3 3 She can choose digits 1 and 3 and erase them Then the board will look like this 1 1 2 3 After that she has to write another digit 2 so at the end of the operation the board will look like 1 1 2 3 2 Nemanja asked her whether it was possible for only digits of one type to remain written on the board after some operations If so which digits can they be Laura was unable to solve this problem and asked you for help As an award for helping her she will convince Nemanja to give you some points ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint a, b, c;\nvoid solve(){\n\tscanf(""%d%d%d"", &a, &b, &c);\n\tprintf(""%d %d %d\\n"", 1 - (b + c) % 2, 1 - (a + c) % 2, 1 - (a + b) % 2);\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']","['dp', 'math']",900
https://codeforces.com//contest/322/problem/B,B. Ciel and Flowers,Fox Ciel has some flowers red flowers green flowers and blue flowers She wants to use these flowers to make several bouquets There are 4 types of bouquets To make a red bouquet it needs 3 red flowers To make a green bouquet it needs 3 green flowers To make a blue bouquet it needs 3 blue flowers To make a mixing bouquet it needs 1 red 1 green and 1 blue flower Help Fox Ciel to find the maximal number of bouquets she can make ,"['#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\n#define inf 1023456789\n#define linf 1023456789123456789ll\n#define pii pair<int,int>\n#define pipii pair<int, pii >\n#define pll pair<long long,long long>\n#define vint vector<int>\n#define vvint vector<vector<int> >\n\n#define DEBUG\n#ifdef DEBUG\n#define db(x) cerr << #x << "" = "" << x << endl\n#else\n#define db(x)\n#endif\n\nint main()\n{\n\tint f[3];\n\tint mn = inf;\n\tfor(int i=0; i<3; i++)\n\t{\n\t\tscanf(""%d"",&f[i]);\n\t\tmn = min(mn, f[i]);\n\t}\n\tint res = 0;\n\tfor(int i=0; i<=min(2, mn); i++)\n\t{\n\t\tint pom = i;\n\t\tfor(int j=0; j<3; j++)pom += (f[j] - i)/3;\n\t\tres = max(res,pom);\n\t}\n\tprintf(""%d\\n"",res);\n\treturn 0;\n}']","['combinatorics', 'math']",1600
https://codeforces.com//contest/77/problem/D,D. Domino Carpet,Having watched the commercial virus Hexadecimal also wanted to get a Domino Carpet and wanted badly to be photographed in front of it But of course a virus will never consent to buying a licensed Carpet So she ordered a truck of dominoes and decided to make such a Carpet herself The original Domino Carpet is a field of squares in size Each square is half of a domino and can be rotated either vertically or horizontally independently from its neighbors Vertically rotated domino halves look like this And horizontally rotated halves look like this Notice that some halves looks the same in both rotations but other halves differ Dominoes bought by Hexadecimal are represented by uncuttable chips in size which can be laid either vertically or horizontally If the chip is laid vertically then both of it s halves should be laid vertically orientated if the chip is laid horizontally then both of it s halves should be laid horizontally The samples of valid and invalid dominoes laid vertically and horizontally are Virus Hexadecimal assembles her own Domino Carpet so that the following conditions are satisfied each carpet square is covered by a domino chip i e there are no empty squares all domino chips lie entirely within the carpet and don t overlap with each other if there is a horizontal domino chip with its left half in column then there are no horizontal domino chips with their left halves in columns or Before starting to assemble her own Domino Carpet the virus wants to know the number of ways to achieve the intended purpose modulo You can assume that the virus has an infinitely large number of dominoes of each type ,"['#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define y0 y3487465\n#define y1 y8687969\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) {\n    re x > 0 ? x : -x;\n}\n\nconst string dom[2][7] = {\n    {""........."",""....O...."",""O.......O"",""O...O...O"",""O.O...O.O"",""O.O.O.O.O"",""OOO...OOO""},\n    {""........."",""....O...."",""..O...O.."",""..O.O.O.."",""O.O...O.O"",""O.O.O.O.O"",""O.OO.OO.O""}};\n\nconst int mod = 1000000007;\n\nint n;\nint m;\nchar w[1002][1002];\nint g[250][250];\nint can[250], can2[250];\nint cnt[251], res[251];\n\nint get (int i, int j) {\n    string s = """";\n    for (int p = 0; p < 3; p++)\n        for (int q = 0; q < 3; q++)\n            s += w[i + p][j + q];\n    int res = 0;\n    for (int p = 0; p < 2; p++)\n        for (int q = 0; q < 7; q++)\n            if (s == dom[p][q])\n                res |= (p + 1);\n    re res;\n}\n\nint main() {\n    scanf (""%d%d"", &n, &m); \n    gets (w[0]);\n    for (int i = 0; i < 4 * n + 1; i++) gets (w[i]);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            g[i][j] = get (4 * i + 1, 4 * j + 1);\n        for (int j = 0; j < m; j++) {\n            can[j] = int (n % 2 == 0);\n            for (int i = 0; i < n; i++) can[j] &= int ((g[i][j] & 2) != 0);\n        }\n    for (int j = 0; j + 1 < m; j++) {\n        memset (cnt, 0, sizeof (cnt));\n        cnt[0] = 1;\n        for (int i = 0; i < n; i++) {\n            if (g[i][j] & g[i][j + 1] & 1)\n                cnt[i + 1] = (cnt[i + 1] + cnt[i]) % mod;\n            if (i + 1 < n && int (g[i][j] & g[i + 1][j] & g[i][j + 1] & g[i + 1][j + 1] & 2))   \n                cnt[i + 2] = (cnt[i + 2] + cnt[i]) % mod;\n        }\n        can2[j] = (cnt[n] - can[j] * can[j + 1] + mod) % mod;\n    }\n    memset (res, 0, sizeof (res));\n    res[0] = 1;\n    for (int j = 0; j < m; j++) {\n        if (can[j]) res[j + 1] = (res[j + 1] + res[j]) % mod;\n        if (j + 1 < m) res[j + 2] = (res[j + 2] + (ll)res[j] * can2[j]) % mod;\n    }\n    printf (""%d\\n"", res[m]);\n    return 0;\n}']","['dp', 'implementation']",2300
https://codeforces.com//contest/474/problem/B,B. Worms,It is lunch time for Mole His friend Marmot prepared him a nice game for lunch Marmot brought Mole ordered piles of worms such that th pile contains worms He labeled all these worms with consecutive integers worms in first pile are labeled with numbers to worms in second pile are labeled with numbers to and so on See the example for a better understanding Mole can t eat all the worms Marmot brought a lot and as we all know Mole is blind so Marmot tells him the labels of the best juicy worms Marmot will only give Mole a worm if Mole says correctly in which pile this worm is contained Poor Mole asks for your help For all juicy worms said by Marmot tell Mole the correct answers ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxN = 100000;\nint n, s[kMaxN + 1];\n\nint main() {\n    scanf(""%d"", &n);\n    for (int i = 1; i <= n; ++ i) {\n        scanf(""%d"", &s[i]);\n        s[i] += s[i - 1];\n    }\n    int m;\n    scanf(""%d"", &m);\n    for (int x; m --; ) {\n        scanf(""%d"", &x);\n        int p = lower_bound(s + 1, s + n + 1, x) - s;\n        printf(""%d\\n"", p);\n    }\n    return 0;\n}\n']","['binary search', 'implementation']",1200
https://codeforces.com//contest/1703/problem/G,"G. Good Key, Bad Key",There are n chests The i th chest contains a i coins You need to open all n chests 1n There are two types of keys you can use to open a chest a good key which costs k coins to use a bad key which does not cost any coins but will halve all the coins in each unopened chest The halving operation to the nearest integer for each chest halved In other words using a bad key to open chest i will do a i lfloor frac a i 2 rfloor a i 1 lfloor frac a i 1 2 rfloor dots a n lfloor frac a n 2 rfloor any key both good and bad breaks after a usage that is it is a one time use You need to use in total n keys one for each chest Initially you have no coins and no keys If you want to use a good key then you need to buy it During the process you are allowed to go into debt for example if you have 1 coin you are allowed to buy a good key worth k 3 coins and your balance will become 2 coins Find the maximum number of coins you can have after opening all n chests in order from chest 1 to chest n ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""../debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""../input.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\nstruct segtree {\n\n\tstruct node {\n\t\tll set, sum;\n\t};\n\n\tvector<node> t;\n\tint size;\n\tll NEUTRAL_ELEMENT = 0;\n\tll NO_OPERATION = 0; \n\n\n\tll op_modify(ll a, ll b, ll length) {\n\t\tif (b == NO_OPERATION)\n\t\t\treturn a;\n\t\treturn b * length + a; \n\t}\n\tll op_sum(ll a, ll b) {\n\t\treturn a + b;\n\t}\n\n\tsegtree(int n) {\n\t\tsize = 1;\n\t\twhile (size < n)\n\t\t\tsize *= 2;\n\t\tt.resize(2 * size, { NO_OPERATION, 0 });\n\t}\n\n\tvoid propagate(int x, int lx, int rx) {\n\t\tif (lx == rx || t[x].set == NO_OPERATION)\n\t\t\treturn;\n\t\tint mx = (lx + rx) / 2;\n\t\tt[2 * x].set = op_modify(t[2 * x].set, t[x].set, 1);\n\t\tt[2 * x].sum = op_modify(t[2 * x].sum, t[x].set, mx - lx + 1);\n\t\tt[2 * x + 1].set = op_modify(t[2 * x + 1].set, t[x].set, 1);\n\t\tt[2 * x + 1].sum = op_modify(t[2 * x + 1].sum, t[x].set, rx - (mx + 1) + 1);\n\t\tt[x].set = NO_OPERATION;\n\t}\n\n\n\n\tvoid modify(int l, int r, int v, int x, int lx, int rx) {\n\t\tpropagate(x, lx, rx);\n\t\tif (l > rx || r < lx) {\n\t\t\treturn;\n\t\t}\n\t\tif (l <= lx && rx <= r) {\n\t\t\tt[x].set = op_modify(t[x].set, v, 1);\n\t\t\tt[x].sum = op_modify(t[x].sum, v, rx - lx + 1);\n\t\t\treturn;\n\t\t}\n\t\tint mx = (lx + rx) / 2;\n\t\tmodify(l, r, v, 2 * x, lx, mx);\n\t\tmodify(l, r, v, 2 * x + 1, mx + 1, rx);\n\t\tt[x].sum = op_sum(t[2 * x].sum, t[2 * x + 1].sum);\n\t}\n\tvoid modify(int l, int r, int v) {\n\t\tmodify(l, r, v, 1, 0, size - 1);\n\t}\n\n\tll sum(int l, int r, int x, int lx, int rx) {\n\t\tpropagate(x, lx, rx);\n\t\tif (l > rx || r < lx) {\n\t\t\treturn NEUTRAL_ELEMENT;\n\t\t}\n\t\tif (l <= lx && rx <= r) {\n\t\t\treturn t[x].sum;\n\t\t}\n\t\tint mx = (lx + rx) / 2;\n\t\tll s1 = sum(l, r, 2 * x, lx, mx);\n\t\tll s2 = sum(l, r, 2 * x + 1, mx + 1, rx);\n\t\treturn op_sum(s1, s2);\n\t}\n\tll sum(int l, int r) {\n\t\treturn sum(l, r, 1, 0, size - 1);\n\t}\n};\n\n\n\nsigned main() {\n\tfstart;\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, k; cin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (auto& x : a)\n\t\t\tcin >> x;\n\n\t\tvector<ll> p(n + 1, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i + 1] = p[i] + a[i];\n\n\t\tvector<ll> backP(n + 1, 0);\n\t\t/*for (int i = n - 1; i >= 0; i--)\n\t\t\tbackP[i] = (backP[i + 1]) / 2 + a[i] / 2;*/\n\t\t//segtree st(n + 1);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t//for (int j = 0; j < 31; j++) {\n\t\t\t//\tif (i - j < 0)\n\t\t\t//\t\tbreak;\n\t\t\t//\t//st.modify(max(0, i - j), i, a[i]);\n\t\t\t//\tbackP[i - j] += a[i];\n\t\t\t//\ta[i] /= 2;\n\t\t\t//}\n\n\t\t\tfor (int j = i; j >= 0 && a[i]; j--) {\n\t\t\t\ta[i] /= 2;\n\t\t\t\tbackP[j] += a[i];\n\t\t\t}\n\t\t}\n\n\n\t\tll bestRes = backP[0];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// от 0 до i покупаем за k, потом за \n\t\t\tll nowRes = p[i + 1] - (ll)k * ((ll)i + 1);\n\t\t\tnowRes += backP[i + 1];\n\t\t\t//nowRes += st.sum(i + 1, i + 1);\n\t\t\tbestRes = max(bestRes, nowRes);\n\t\t}\n\n\t\tcout << bestRes << ""\\n"";\n\t}\n\n\n\tfinish;\n}\n\n']","['bitmasks', 'brute force', 'dp', 'greedy', 'math']",1600
https://codeforces.com//contest/1348/problem/F,F. Phoenix and Memory,Phoenix is trying to take a photo of his n friends with labels 1 2 dots n who are lined up in a row in a special order But before he can take the photo his friends get distracted by a duck and mess up their order Now Phoenix must restore the order but he doesn t remember completely He only remembers that the i th friend from the left had a label between a i and b i inclusive Does there exist a unique way to order his friends based of his memory ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200010;\nstruct P {\n\tint l,r,id;\n}p[MAXN];\nstruct cmp {\n\tbool operator () (P a,P b) {return a.r>b.r;}\n};\nint n,a[MAXN],b[MAXN],xl[MAXN],xr[MAXN],rev[MAXN];\nbool cmp1 (P a,P b) {return a.l<b.l;}\nbool cmp2 (P a,P b) {return a.r>b.r;}\npriority_queue <P,vector<P>,cmp> q,q2;\nmultiset <int> ms;\nint main () {\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(""%d%d"",&p[i].l,&p[i].r);\n\t\tp[i].id=i;\n\t}\n\tmultiset<int>::iterator it;\n\tsort(p+1,p+n+1,cmp1);\n\tint cur=1,flg=0;\n\tfor (int i=1;i<=n;i++) {\n\t\twhile (cur<=n&&p[cur].l<=i) {\n\t\t\tq.push(p[cur]);\n\t\t\tcur++;\n\t\t}\n\t\tP tmp=q.top();\n\t\tq.pop();\n\t\ta[tmp.id]=b[tmp.id]=i,xl[tmp.id]=tmp.l,xr[tmp.id]=tmp.r,rev[i]=tmp.id;\n\t\tq2.push(tmp);\n\t\twhile (!q2.empty()&&q2.top().r<i) {\n\t\t\tP tmp2=q2.top();\n\t\t\tq2.pop();\n\t\t\tit=ms.find(a[tmp2.id]);\n\t\t\tms.erase(it);\n\t\t}\n\t\tif (!ms.empty()&&!flg) {\n\t\t\tit=ms.end();\n\t\t\tit--;\n\t\t\tif (*it>=tmp.l) {\n\t\t\t\tflg=1;\n\t\t\t\tswap(b[tmp.id],b[rev[*it]]);\n\t\t\t}\n\t\t}\n\t\tms.insert(i);\n\t}\n\tif (flg) {\n\t\tprintf(""NO\\n"");\n\t\tfor (int i=1;i<=n;i++) {printf(""%d "",a[i]);}\n\t\tprintf(""\\n"");\n\t\tfor (int i=1;i<=n;i++) {printf(""%d "",b[i]);}\n\t\tprintf(""\\n"");\n\t} else {\n\t\tprintf(""YES\\n"");\n\t\tfor (int i=1;i<=n;i++) {printf(""%d "",a[i]);}\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","['data structures', 'dfs and similar', 'graphs', 'greedy']",2600
https://codeforces.com//contest/363/problem/A,A. Soroban,You know that Japan is the country with almost the largest electronic devices per person ratio So you might be quite surprised to find out that the primary school in Japan teaches to count using a an abacus developed in Japan This phenomenon has its reasons of course but we are not going to speak about them Let s have a look at the Soroban s construction Soroban consists of some number of rods each rod contains five beads We will assume that the rods are horizontal lines One bead on each rod the leftmost one is divided from the others by a bar the reckoning bar This single bead is called and four others are Each rod is responsible for representing a single digit from 0 to 9 We can obtain the value of a digit by following simple algorithm Set the value of a digit equal to 0 If the go dama is shifted to the right add 5 Add the number of ichi damas shifted to the left Thus the upper rod on the picture shows digit 0 the middle one shows digit 2 and the lower one shows 7 We will consider the top rod to represent the last decimal digit of a number so the picture shows number 720 Write the program that prints the way Soroban shows the given number ,"['#include <iostream>\n#include <string>\nusing namespace std;\nstring a[10]={\n""O-|-OOOO"",\n""O-|O-OOO"",\n""O-|OO-OO"",\n""O-|OOO-O"",\n""O-|OOOO-"",\n""-O|-OOOO"",\n""-O|O-OOO"",\n""-O|OO-OO"",\n""-O|OOO-O"",\n""-O|OOOO-""};\nint main(){\n    int n;\n    cin>>n;\n    if (n==0){\n        cout<<a[0]; return 0;\n    }\n    while (n>0){\n        cout<< a[n%10];\n        n=n/10;\n        if (n>0) cout<<""\\n"";\n    }\n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1339/problem/A,A. Filling Diamonds,You have integer n Calculate how many ways are there to fully cover belt like area of 4n 2 triangles with diamond shapes Diamond shape consists of two triangles You can move rotate or flip the shape but you cannot scale it 2 coverings are different if some 2 triangles are covered by the same diamond shape in one of them and by different diamond shapes in the other one Please look at pictures below for better understanding On the left you can see the diamond shape you will use and on the right you can see the area you want to fill These are the figures of the area you want to fill for n 1 2 3 4 You have to answer t independent test cases ,"['\ufeff#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tUL Q; cin >> Q;\n\t\trep(i, Q) {\n\t\t\tUL N; cin >> N;\n\t\t\tcout << N << endl;\n\t\t}\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n']","['brute force', 'dp', 'implementation', 'math']",900
https://codeforces.com//contest/754/problem/D,D. Fedor and coupons,All our characters have hobbies The same is true for Fedor He enjoys shopping in the neighboring supermarket The goods in the supermarket have unique integer ids Also for every integer there is a product with id equal to this integer Fedor has discount coupons the th of them can be used with products with ids ranging from to inclusive Today Fedor wants to take exactly coupons with him Fedor wants to choose the coupons in such a way that the number of such products that all coupons can be used with this product is as large as possible for better understanding see examples Fedor wants to save his time as well so he asks you to choose coupons for him Help Fedor ,"['//No exams!\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back \n#define MP make_pair\ntypedef long long ll;\nconst ll INF=1<<28;\nconst ll LINF=1ll<<61;\nint n,k;\npair<pair<int,int>,int> id[300111];\npair<int,int> a[300111];\nset<pair<int,int> >st;\nint solve(int tmp=0)\n{\n\tst.clear();\n\tint ans=0,ansid=k;\n\tfor(int i=1;i<k;i++)st.insert(MP(a[i].SS,i));\n\tfor(int i=k;i<=n;i++)\n\t{\n\t\tst.insert(MP(a[i].SS,i));\n\t\twhile(st.size()>k)\n\t\t{\n\t\t\tst.erase(st.begin());\n\t\t}\n\t\tint t=max(0,st.begin()->FF-a[i].FF+1);\n\t\tif(t>ans)\n\t\t{\n\t\t\tans=t;\n\t\t\tansid=i;\n\t\t}\n\t\tif(tmp==i)\n\t\t{\n\t\t\tprintf(""%d\\n"",ans);\n\t\t\tfor(auto x:st)\n\t\t\t{\n\t\t\t\tprintf(""%d "",id[x.SS].SS);\n\t\t\t}\n\t\t\tputs("""");\n\t\t\texit(0);\n\t\t}\n\t}\n\treturn ansid;\n}\nint main()\n{\n\tscanf(""%d%d"",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d%d"",&a[i].FF,&a[i].SS);\n\t\tid[i]=MP(a[i],i);\n\t}\n\tsort(a+1,a+n+1);\n\tsort(id+1,id+n+1);\n\tsolve(solve());\n\treturn 0;\n}']","['binary search', 'data structures', 'greedy', 'sortings']",2100
https://codeforces.com//contest/204/problem/D,D. Little Elephant and Retro Strings,The Little Elephant has found a ragged old black and white string on the attic The characters of string are numbered from the left to the right from to where is the length of the string Let s denote the th character of string as As the string is black and white each character of the string is either letter or letter Unfortunately the string is very old and some characters are damaged The damaged positions are denoted as The Little Elephant in determined to restore the string and hang it on the wall For that he needs to replace each character by a or a The string must look good on the wall so it must be The Little Elephant considers a string beautiful if it has two non intersecting substrings of a given length such that the left one fully consists of characters and the right one fully consists of characters More formally there are four integers such that and Help the Little Elephant find the number of different beautiful strings he can obtain from string Two strings are considered different if there is such position where the character in the first string differs from the corresponding character in the second string If this string doesn t contain characters and it is already beautiful the answer is As the answer can be rather large print it modulo ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long ull;\n\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nconst int mod = 1000000007;\n\nint n,k;\nchar s[1111111];\nchar t[1111111];\nvi v1,v2;\n\nint sum[1111111];\nvi tmp;\n\nint tp[1111111];\nint w[1111111];\nint q[1111111];\nint sw[1111111];\n\nvi solve(char *s){\n\ttmp.clear();\n\ttmp.resize(n, 0);\n\tCL(w,0);CL(sw,0);CL(q,0);\n\tint num = 0;\n\tint lastw = -1;\n\tREP(i,n){\n\t\tif(s[i]==\'X\') q[i]=1;\n\t\tif(i) q[i]+=q[i-1];\n\t\tif(s[i]==\'B\' || s[i]==\'X\') num++;\n\t\telse num = 0;\n\n\t\tif(num>=k){\n\t\t\tint pos = i - k;\n\t\t\tif(pos<0) tmp[i] = 1;\n\t\t\telse  tmp[i] = w[pos];\n\t\t}\n\n\t\tw[i] = 0;\n\t\tif(s[i]==\'W\' || s[i]==\'X\'){\n\t\t\tif(i==0) w[i] = 1;\n\t\t\telse {\n\t\t\t\tif(i-1-k<-1){\n\t\t\t\t\tw[i] = tp[q[i-1]];\n\t\t\t\t}else{\n\t\t\t\t\tint pos = i-1-k;\n\t\t\t\t\tif(lastw>pos) pos = lastw-1;\n\t\t\t\t\tw[i] += sw[i-1] - (pos>=0?sw[pos]:0);\n\t\t\t\t}\n\t\t\t\tw[i]%=mod;\n\t\t\t\tif(w[i]<0) w[i]+=mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsw[i] = w[i];\n\t\tif(i) sw[i]+=sw[i-1],sw[i]%=mod;\n\t\t\n\t//\tcout<<i<<"" -> w[i] ""<<w[i]<<""   sw[i] ""<<sw[i]<<""  tmp ""<<tmp[i]<<endl;\n\t\tif(s[i]==\'W\') lastw=i;\n\t}\n\t\n\treturn tmp;\n}\n\nint go(string z, int pos){\n\tif(pos==z.size()){\n\t\tint num=0;\n\t\tREP(i,n){\n\t\t\tif(z[i]==\'B\') num++;\n\t\t\telse num = 0;\n\t\t\tif(num==k){\n\t\t\t\tnum=0;\n\t\t\t\tFOR(j,i,n){\n\t\t\t\t\tif(z[j]==\'W\') num++;\n\t\t\t\t\telse num=0;\n\t\t\t\t\tif(num==k) return 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tif(z[pos]==\'X\'){\n\t\tstring t1 = z;\n\t\tt1[pos]=\'B\';\n\t\tres += go(t1, pos+1);\n\t\tt1[pos]=\'W\';\n\t\tres += go(t1, pos+1);\n\t\treturn res;\n\t}\n\treturn go(z,pos+1);\n}\nint num(){\n\tstring z = s;\n\treturn go(z, 0);\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\ttp[0]= 1;\n\tFOR(i,1,1111111) tp[i]=(tp[i-1]*2)%mod;\n\tcin>>n>>k;\n\n\tscanf("" %s"",s);\n\t\n\tv1 = solve(s);\n\t//REP(i,v1.size()) cout<<v1[i]<<\' \';puts("""");\n\n\tREP(i,n) t[i] = s[n-1-i];\n\tREP(i,n) if(t[i]==\'W\') t[i]=\'B\';\n\telse if(t[i]==\'B\') t[i]=\'W\';\n\tv2 = solve(t);\n\treverse(v2.begin(),v2.end());\n\t//REP(i,v2.size()) cout<<v2[i]<<\' \';puts("""");\n\n\tll res = 0;\n\tREP(i,v1.size()){\n\t\tsum[i] = v1[i];\n\t\tif(i){\n\t\t\tint add = sum[i-1];\n\t\t\tif(s[i]==\'X\') add*=2,add%=mod;\n\t\t\tsum[i] += add;\n\t\t\tsum[i] %= mod;\n\t\t}\n\t}\n\t//REP(i,v1.size()) cout<<i<<\' \'<<sum[i]<<endl;\n\n\t\n\n\tFOR(i,1,v2.size())if(v2[i]){\n\t\tres += v2[i] * ll(sum[i-1]);\n\t\t//cout<<""add ""<<i<<\' \'<<v2[i]<<"" ""<< ll(sum[i-1])<<endl;\n\t\tres %= mod;\n\t}\n//\tcout<<res<<\' \'<<num()<<endl;\n\tcout<<res<<endl;\n\t\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']",['dp'],2400
https://codeforces.com//contest/43/problem/B,B. Letter,Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading He knows heading and text that he wants to send Vasya can use every single heading letter no more than once Vasya doesn t have to cut the spaces out of the heading he just leaves some blank space to mark them Help him find out if he will manage to compose the needed text ,"['#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std; \n\n#define DEBUG(x) cout << \'>\' << #x << \':\' << x << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FOR2(i, a, b) for (int i = (a); i > (b); --i)\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\nconst int INF = 1<<29;\ntypedef long long ll;\n\ninline int two(int n) { return 1 << n; }\ninline int test(int n, int b) { return n & two(b); }\ninline void set_bit(int & n, int b) { n |= two(b); }\ninline void unset_bit(int & n, int b) { n &= ~two(b); }\ninline int last_bit(int n) { return n & (-n); }\ninline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; }\n\ntemplate<class T> void chmax(T & a, const T & b) { a = max(a, b); }\ntemplate<class T> void chmin(T & a, const T & b) { a = min(a, b); }\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint cnt1[500], cnt2[500];\n\nvoid read(int * cnt)\n{\n\tstring line, word;\n\tgetline(cin, line);\n\n\tistringstream is(line);\n\twhile (is >> word)\n\t{\n\t\tfor (int i = 0; i < word.size(); ++i)\n\t\t\tif (isalpha(word[i])) ++cnt[word[i]];\n\t}\n}\n\nint main()\n{\n\tmap<string, int> m1, m2;\n\tread(cnt1);\n\tread(cnt2);\n\n\tbool ok = true;\n\tFOR(i, 0, 500)\n\t\tif (cnt1[i] < cnt2[i]) ok = false;\n\n\tif (ok) cout << ""YES"" << endl;\n\telse cout << ""NO"" << endl;\n\n\treturn 0;\n}\n']","['implementation', 'strings']",1100
https://codeforces.com//contest/630/problem/I,I. Parking Lot,To quickly hire highly skilled specialists one of the new IT City companies made an unprecedented move Every employee was granted a car and an employee can choose one of four different car makes The parking lot before the office consists of one line of parking spaces Unfortunately the total number of cars is greater than the parking lot capacity Furthermore even amount of cars of each make is greater than the amount of parking spaces That s why there are no free spaces on the parking lot ever Looking on the straight line of cars the company CEO thought that parking lot would be more beautiful if it contained exactly successive cars of the same make Help the CEO determine the number of ways to fill the parking lot this way ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\nll cnk(ll n, int k)\n{\n    ll res = 1;\n    forn(i, k) res = (res * (n - i)) / (i + 1);\n    return res;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    int n;\n\n    cin >> n;\n    ll res = pw(2 * (n - 3)) * 6 + pw(2 * (n - 4)) * 9 * (n - 3);\n    //ll res = pw(2 * (n - 2)) * (n - 1) - pw(2 * (n - 3)) * (2 * (n - 2));\n    /*int sgn = 1;\n    for (int i = n - 2; i >= n; --i)\n    {\n        res += pw(2 * i) * (i + 1) * sgn;\n        sgn = -sgn;\n    } */\n    res = 4 * res;\n\n    cout << res;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","['combinatorics', 'math']",1700
https://codeforces.com//contest/1328/problem/B,B. K-th Beautiful String,For the given integer n n 2 let s write down all the strings of length n which contain n 2 letters and two letters in alphabetical order Recall that the string s of length n is lexicographically less than string t of length n if there exists such i 1 le i le n that s i t i and for any j 1 le j i s j t j The lexicographic comparison of strings is implemented by the operator in modern programming languages For example if n 5 the strings are the order does matter It is easy to show that such a list of strings will contain exactly frac n cdot n 1 2 strings You are given n n 2 and k 1 le k le frac n cdot n 1 2 Print the k th string from the list ,"[""// clang-format off\n// powered by c++11\n// by Isaunoya\n#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i=(x);i<=(y);++i)\n#define Rep(i,x,y) for(register int i=(x);i>=(y);--i)\nusing namespace std;using db=double;using ll=long long;\nusing uint=unsigned int;using ull=unsigned long long;\nusing pii=pair<int,int>;\n#define Tp template\n#define fir first\n#define sec second\nTp<class T>void cmax(T&x,const T&y){if(x<y)x=y;}Tp<class T>void cmin(T&x,const T&y){if(x>y)x=y;}\n#define all(v) v.begin(),v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\nTp<class T>void sort(vector<T>&v){sort(all(v));}Tp<class T>void reverse(vector<T>&v){reverse(all(v));}\nTp<class T>void unique(vector<T>&v){sort(all(v)),v.erase(unique(all(v)),v.end());}inline void reverse(string&s){reverse(s.begin(),s.end());}\nconst int SZ=1<<23|233;\nstruct FILEIN{char qwq[SZ],*S=qwq,*T=qwq,ch;\n#ifdef __WIN64\n#define GETC getchar\n#else\ninline char GETC(){return(S==T)&&(T=(S=qwq)+fread(qwq,1,SZ,stdin),S==T)?EOF:*S++;}\n#endif\ninline FILEIN&operator>>(char&c){while(isspace(c=GETC()));return*this;}inline FILEIN&operator>>(string&s){s.clear();while(isspace(ch=GETC()));if(!~ch)return*this;s=ch;while(!isspace(ch=GETC())&&~ch)s+=ch;return*this;}\ninline FILEIN&operator>>(char*str){char*cur=str;while(*cur)*cur++=0;cur=str;while(isspace(ch=GETC()));if(!~ch)return*this;*cur=ch;while(!isspace(ch=GETC())&&~ch)*++cur=ch;*++cur=0;return*this;}\nTp<class T>inline void read(T&x){bool f=0;while((ch=GETC())<48&&~ch)f^=(ch==45);x=~ch?(ch^48):0;while((ch=GETC())>47)x=x*10+(ch^48);x=f?-x:x;}\ninline FILEIN&operator>>(int&x){return read(x),*this;}inline FILEIN&operator>>(ll&x){return read(x),*this;}inline FILEIN&operator>>(uint&x){return read(x),*this;}inline FILEIN&operator>>(ull&x){return read(x),*this;}\ninline FILEIN&operator>>(double&x){read(x);bool f=x<0;x=f?-x:x;if(ch^'.')return*this;double d=0.1;while((ch=GETC())>47)x+=d*(ch^48),d*=.1;return x=f?-x:x,*this;}\n}in;\nstruct FILEOUT{const static int LIMIT=1<<22;char quq[SZ],ST[233];int sz,O,pw[233];\nFILEOUT(){set(7);rep(i,pw[0]=1,9)pw[i]=pw[i-1]*10;}~FILEOUT(){flush();}\ninline void flush(){fwrite(quq,1,O,stdout),fflush(stdout),O=0;}\ninline FILEOUT&operator<<(char c){return quq[O++]=c,*this;}inline FILEOUT&operator<<(string str){if(O>LIMIT)flush();for(char c:str)quq[O++]=c;return*this;}\ninline FILEOUT&operator<<(char*str){if(O>LIMIT)flush();char*cur=str;while(*cur)quq[O++]=(*cur++);return*this;}\nTp<class T>void write(T x){if(O>LIMIT)flush();if(x<0){quq[O++]=45;x=-x;}do{ST[++sz]=x%10^48;x/=10;}while(x);while(sz)quq[O++]=ST[sz--];}\ninline FILEOUT&operator<<(int x){return write(x),*this;}inline FILEOUT&operator<<(ll x){return write(x),*this;}inline FILEOUT&operator<<(uint x){return write(x),*this;}inline FILEOUT&operator<<(ull x){return write(x),*this;}\nint len,lft,rig;void set(int l){len=l;}inline FILEOUT&operator<<(double x){bool f=x<0;x=f?-x:x,lft=x,rig=1.*(x-lft)*pw[len];return write(f?-lft:lft),quq[O++]='.',write(rig),*this;}\n}out;\n#define int long long\nstruct Math{\nvector<int>fac,inv;int mod;\nvoid set(int n,int Mod){fac.resize(n+1),inv.resize(n+1),mod=Mod;rep(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;inv[n]=qpow(fac[n],mod-2);Rep(i,n-1,0)inv[i]=inv[i+1]*(i+1)%mod;}\nint qpow(int x,int y){int ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}int C(int n,int m){if(n<0||m<0||n<m)return 0;return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint gcd(int x,int y){return!y?x:gcd(y,x%y);}int lcm(int x,int y){return x*y/gcd(x,y);}\n}math;\n// clang-format on\nsigned main(){\n\t//code begin.\n\tint _;\n\tin >> _;\n\twhile(_ --) {\n\t\tint n , k;\n\t\tin >> n >> k;\n\t\tk --;\n\t\tint pos1 = n - 2, pos2 = n - 1, cnt = 1;\n\t\twhile(k) {\n\t\t\tif(k < cnt) {\n\t\t\t\tpos2 -= k;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tpos1 --;\n\t\t\tk -= cnt;\n\t\t\tcnt ++;\n\t\t}\n\t\trep(i , 0 , n - 1) {\n\t\t\tif(i == pos1 || i == pos2) {\n\t\t\t\tout << 'b' ;\n\t\t\t}\n\t\t\telse \n\t\t\t\tout << 'a' ;\n\t\t}\n\t\tout << '\\n';\n\t}\n\treturn 0;\n\t//code end.\n}\n""]","['binary search', 'brute force', 'combinatorics', 'implementation', 'math']",1300
https://codeforces.com//contest/912/problem/E,E. Prime Gift,Opposite to Grisha s nice behavior Oleg though he has an entire year at his disposal didn t manage to learn how to solve number theory problems in the past year That s why instead of Ded Moroz he was visited by his teammate Andrew who solemnly presented him with a set of numbers alongside with a simple task Oleg is to find the th smallest integer such that its prime divisors are in this set ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, w[16];\nlong long K, M;\nvector<long long>V1;\nvector<long long>V2;\nvoid DFS(int b, int e, vector<long long> &t, long long cur) {\n\tint i;\n\tif (b == e) {\n\t\tt.push_back(cur);\n\t\treturn;\n\t}\n\tDFS(b + 1, e, t, cur);\n\twhile (cur <= M / w[b]) {\n\t\tcur *= w[b];\n\t\tDFS(b + 1, e, t, cur);\n\t}\n}\nlong long Count(long long a) {\n\tint i, pv = V2.size()-1;\n\tlong long r = 0;\n\tfor (i = 0; i < V1.size(); i++) {\n\t\twhile (pv >= 0 && V2[pv] > a / V1[i])pv--;\n\t\tr += pv + 1;\n\t}\n\treturn r;\n}\nint main() {\n\tint i;\n\tscanf(""%d"", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(""%d"", &w[i]);\n\t}\n\tsort(w, w + n);\n\tscanf(""%lld"", &K);\n\tM = 1e18;\n\tDFS(0, min(n, 6), V1, 1);\n\tif (n >= 6) {\n\t\tDFS(6, n, V2, 1);\n\t}\n\telse V2.push_back(1);\n\tsort(V1.begin(), V1.end());\n\tsort(V2.begin(), V2.end());\n\tlong long b = 1, e = M, mid, r = 0;\n\twhile (b <= e) {\n\t\tmid = (b + e) >> 1;\n\t\tif (Count(mid) >= K) {\n\t\t\tr = mid;\n\t\t\te = mid - 1;\n\t\t}\n\t\telse b = mid + 1;\n\t}\n\tprintf(""%lld\\n"", r);\n}']","['binary search', 'dfs and similar', 'math', 'meet-in-the-middle', 'number theory', 'two pointers']",2400
https://codeforces.com//contest/708/problem/E,E. Student s Camp,Alex studied well and won the trip to student camp Alushta located on the seashore Unfortunately it s the period of the strong winds now and there is a chance the camp will be destroyed Camp building can be represented as the rectangle of concrete blocks height and blocks width Every day there is a breeze blowing from the sea Each block except for the blocks of the upper and lower levers such that there is no block to the left of it is destroyed with the probability Similarly each night the breeze blows in the direction to the sea Thus each block again except for the blocks of the upper and lower levers such that there is no block to the right of it is destroyed with the same probability Note that blocks of the upper and lower level are so there are only blocks that can be destroyed The period of the strong winds will last for days and nights If during this period the building will split in at least two connected components it will collapse and Alex will have to find another place to spend summer Find the probability that Alex won t have to look for other opportunities and will be able to spend the summer in this camp ,"[""// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\n#define int long long\n\nconst int N = (int) 2e5 + 5, mod = (int) 1e9 + 7, M = 3005;\nint pw(int a, int b) { return b != 0? pw(a * a % mod, b >> 1) * (b & 1? a: 1) % mod: 1; }\nint f[N], invf[N], pickp[N], pickn[N], sd[N], dest[N], lp[M], rp[M], olp[M], orp[M], lps[M];\nint comb(int n, int r) {\n    if (n < 0 || r < 0 || n - r < 0) return 0;\n    return f[n] * invf[r] % mod * invf[n - r] % mod;\n}\nint mul(int x, int y) { return x * y % mod; }\nint add(int x, int y) { return (x + y + 100 * mod) % mod; }\nint sadd(int &x, int y) { return x = add(x, y); }\n\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    f[0] = invf[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * i % mod, invf[i] = pw(f[i], mod - 2);\n    int n, m;\n    cin >> n >> m;\n    int pa, pb;\n    cin >> pa >> pb;\n    for (int i = 0; i < N; ++i)\n        pickp[i] = pw(pa, i) * pw(pw(pb, mod - 2), i) % mod, pickn[i] = pw(pb - pa, i) * pw(pw(pb, mod - 2), i) % mod;\n    int k;\n    cin >> k;\n    for (int j = 0; j < N; ++j) {\n        dest[j] = comb(k, j) * pickp[j] % mod * pickn[k - j] % mod;\n        sadd(sd[j], add(j == 0? 0: sd[j - 1], dest[j]));\n    }\n    lp[0] = 1;\n    rp[m - 1] = 1;\n    for (int d = 0; d < n + 1; ++d) {\n        memcpy(olp, lp, sizeof lp);\n        memcpy(orp, rp, sizeof rp);\n        memset(lp, 0, sizeof lp);\n        memset(lps, 0, sizeof lps);\n        memset(rp, 0, sizeof rp);\n        int sumrp = 0, all = 0, cur_val = 0;\n        for (int j = 0; j < m; ++j)\n            sadd(all, olp[j]);\n        if (d == n) {\n            cout << all;\n            return 0;\n        }\n        for (int j = m - 1; j >= 0; --j)\n            lps[j] = add(lps[j + 1], olp[j]);\n        for (int j = 0; j < m; ++j) {\n            sadd(rp[j], -mul(cur_val, dest[m - j - 1]));\n            sadd(rp[j], -mul(lps[j + 1], mul(sd[j], dest[m - j - 1])));\n            sadd(rp[j], mul(mul(all, sd[j]), dest[m - j - 1]));\n//            cout << j << ' ' << all << ' ' << cnt << ' ' << sd[j] << ' ' << dest[m - j - 1] << ' ' << cur_val << ' ' << lps[j + 1] << endl;\n            sadd(sumrp, orp[j]);\n            sadd(cur_val, mul(sumrp, dest[j + 1]));\n        }\n        for (int j = 0; j < m; ++j) {\n            lp[j] = rp[m - j - 1];\n        }\n    }\n\n\n\n\n\n}\n\n\n\n\n\n\n\n""]","['dp', 'math']",3100
https://codeforces.com//contest/1262/problem/A,A. Math Problem,Your math teacher gave you the following problem There are n segments on the x axis l 1 r 1 l 2 r 2 ldots l n r n The segment l r includes the bounds i e it is a set of such x that l le x le r The length of the segment l r is equal to r l Two segments a b and c d have a common point intersect if there exists x that a leq x leq b and c leq x leq d For example 2 5 and 3 10 have a common point but 5 6 and 1 4 don t have You should add one segment which has at least one common point with each of the given segments and as short as possible i e has minimal length The required segment can degenerate to be a point i e a segment with length zero The added segment may or may not be among the given n segments In other words you need to find a segment a b such that a b and every l i r i have a common point for each i and b a is minimal ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        int a1 = inf, a2 = -inf;\n        rep(i, 0, n) {\n            int l, r;\n            cin >> l >> r;\n            setmin(a1, r);\n            setmax(a2, l);\n        }\n        if (a1 <= a2) {\n            cout << a2 - a1 << ""\\n"";\n        } else {\n            cout << 0 << ""\\n"";\n        }\n    }\n    return 0;\n}']","['greedy', 'math']",1100
https://codeforces.com//contest/617/problem/C,C. Watering Flowers,A flowerbed has many flowers and two fountains You can adjust the water pressure and set any values and giving the distances at which the water is spread from the first and second fountain respectively You have to set such and that all the flowers are watered that is for each flower the distance between the flower and the first fountain doesn t exceed or the distance to the second fountain doesn t exceed It s OK if some flowers are watered by both fountains You need to decrease the amount of water you need that is set such and that all the flowers are watered and the is minimum possible Find this minimum value ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <int, PII> PIP;\ntypedef pair <ll, int> PLI;\ntypedef pair <PII, ll> PIIL;\ntypedef pair <int, ll> PIL;\ntypedef unsigned int ui;\nconst int mod = 1e9+7;\nconst int inf = 1e9+9;\nconst ll MOD = 1e9+696969;\nconst ll INF = 1e18;\n#define maxn 2010\ninline ll sqr(ll a) {\n\treturn a*a;\n}\nint n;\nPII t[maxn];\nll d[maxn][2];\nll odl(int a, int b)\n{\n\treturn sqr(t[a].e1 - t[b].e1) + sqr(t[a].e2 - t[b].e2);\n}\n\nint main()\n{\n\tscanf(""%d%d%d"", &n, &t[0].e1, &t[0].e2);\n\tscanf(""%d%d"", &t[n+1].e1, &t[n+1].e2);\n\tfor (int i=1; i<=n; ++i) scanf(""%d%d"", &t[i].e1, &t[i].e2);\n\tfor (int i=1; i<=n; ++i)\n\t  d[i][0] = odl(0, i), d[i][1] = odl(n+1, i);\n\n\tll res = INF;\n\tfor (int j=0; j<2; ++j) {\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tll wart = d[i][0]; //kwadrat\n\t\tll MIN = 0;\n\t\tfor (int j=1; j<=n; ++j)\n\t\t  if (d[j][0] > wart) MIN = max(MIN, d[j][1]);\n\t\tres = min(res, wart + MIN);\n\t}\n\tfor (int j=1; j<=n; ++j) swap(d[j][0], d[j][1]);\n\t}\n\n\tcout << res;\n}\n']",['implementation'],1600
https://codeforces.com//contest/796/problem/B,B. Find The Bone,Zane the wizard is going to perform a magic show shuffling the cups There are cups numbered from to placed along the axis on a table that has holes on it More precisely cup is on the table at the position The problematic bone is initially at the position Zane will confuse the audience by swapping the cups times the th time of which involves the cups at the positions and If the bone happens to be at the position where there is a hole at any time it will fall into the hole onto the ground and will not be affected by future swapping operations Do not forget that Zane is a wizard When he swaps the cups he does not move them ordinarily Instead he teleports the cups along with the bone if it is inside to the intended positions Therefore for example when he swaps the cup at and the one at they will not be at the position at any moment during the operation Zane s puppy Inzane is in trouble Zane is away on his vacation and Inzane cannot find his beloved bone as it would be too exhausting to try opening all the cups Inzane knows that the Codeforces community has successfully helped Zane so he wants to see if it could help him solve his problem too Help Inzane determine the final position of the bone ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, h[1000020];\nbool fall;\nint bone, x, y;\nint main() {\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tbone = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%d"", &x);\n\t\th[x] = 1;\n\t}\n\tif (h[1] == 1) {\n\t\tfall = true;\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(""%d%d"", &x, &y);\n\t\tif (fall) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == bone) {\n\t\t\tbone = y;\n\t\t} else if (y == bone) {\n\t\t\tbone = x;\n\t\t}\n\t\tif (h[bone] == 1) {\n\t\t\tfall = true;\n\t\t}\n\t}\n\tprintf(""%d\\n"", bone);\n}']",['implementation'],1300
https://codeforces.com//contest/1016/problem/D,D. Vasya And The Matrix,Now Vasya is taking an exam in mathematics In order to get a good mark Vasya needs to guess the matrix that the teacher has constructed Vasya knows that the matrix consists of rows and columns For each row he knows the xor bitwise excluding or of the elements in this row The sequence denotes the xor of elements in rows with indices respectively Similarly for each column he knows the xor of the elements in this column The sequence denotes the xor of elements in columns with indices respectively Help Vasya Find a matrix satisfying the given constraints or tell him that there is no suitable matrix ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=111;\nint n, m, a[N], b[N], ans[N][N];\nvoid no(){\n  puts(""NO"");\n  exit(0);\n}\nint xa[N], xb[N];\nvoid go(int bt){\n  vector<int> ixa, ixb;\n  for(int i=0; i<n; i++) if(xa[i]) ixa.push_back(i);\n  for(int i=0; i<m; i++) if(xb[i]) ixb.push_back(i);\n  while(ixa.size() and ixb.size()){\n    int iia=ixa.back(); ixa.pop_back();\n    int iib=ixb.back(); ixb.pop_back();\n    ans[iia][iib]^=(1<<bt);\n  }\n  while(ixa.size()>1u){\n    int iia1=ixa.back(); ixa.pop_back();\n    int iia2=ixa.back(); ixa.pop_back();\n    ans[iia1][0]^=(1<<bt);\n    ans[iia2][0]^=(1<<bt);\n  }\n  while(ixb.size()>1u){\n    int iib1=ixb.back(); ixb.pop_back();\n    int iib2=ixb.back(); ixb.pop_back();\n    ans[0][iib1]^=(1<<bt);\n    ans[0][iib2]^=(1<<bt);\n  }\n  if(ixa.size() or ixb.size()) no();\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0; i<n; i++) cin>>a[i];\n  for(int i=0; i<m; i++) cin>>b[i];\n  for(int bt=0; bt<30; bt++){\n    for(int i=0; i<n; i++) xa[i]=(a[i]>>bt)&1;\n    for(int i=0; i<m; i++) xb[i]=(b[i]>>bt)&1;\n    go(bt);\n  }\n  puts(""YES"");\n  for(int i=0; i<n; i++)\n    for(int j=0; j<m; j++)\n      printf(""%d%c"", ans[i][j], "" \\n""[j+1==m]);\n  for(int i=0; i<n; i++)\n    for(int j=0; j<m; j++){\n      a[i]^=ans[i][j];\n      b[j]^=ans[i][j];\n    }\n  assert(*max_element(a, a+n) == 0);\n  assert(*max_element(b, b+m) == 0);\n}\n']","['constructive algorithms', 'flows', 'math']",1800
https://codeforces.com//contest/1681/problem/A,A. Game with Cards,Alice and Bob play a game Alice has n cards the i th of them has the integer a i written on it Bob has m cards the j th of them has the integer b j written on it On the first turn of the game chooses one of his her cards and puts it on the table plays it On the second turn chooses one of his her cards and plays it On the third turn chooses one of his her cards and plays it and so on the players take turns and each player has to choose one of his her cards with greater integer than the card played by the other player on the last turn If some player cannot make a turn he she loses For example if Alice has 4 cards with numbers 10 5 3 8 and Bob has 3 cards with numbers 6 11 6 the game may go as follows Alice can choose any of her cards She chooses the card with integer 5 and plays it Bob can choose any of his cards with number greater than 5 He chooses a card with integer 6 and plays it Alice can choose any of her cards with number greater than 6 She chooses the card with integer 10 and plays it Bob can choose any of his cards with number greater than 10 He chooses a card with integer 11 and plays it Alice can choose any of her cards with number greater than 11 but she has no such cards so she loses Both Alice and Bob play You have to answer two questions who wins if Alice is the first player who wins if Bob is the first player ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:34:34       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int m;\n    cin >> m;\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n    }\n    int x = *max_element(a.begin(), a.end());\n    int y = *max_element(b.begin(), b.end());\n    if (x < y) {\n      cout << ""Bob"" << \'\\n\';\n      cout << ""Bob"" << \'\\n\';\n      continue;\n    }\n    if (x > y) {\n      cout << ""Alice"" << \'\\n\';\n      cout << ""Alice"" << \'\\n\';\n      continue;\n    }\n    cout << ""Alice"" << \'\\n\';\n    cout << ""Bob"" << \'\\n\';\n  }\n  return 0;\n}\n']","['games', 'greedy']",800
https://codeforces.com//contest/1742/problem/F,F. Smaller,Alperen has two strings s and t which are both initially equal to He will perform q operations of two types on the given strings 1 k x Append the string x exactly k times at the end of string s In other words s s underbrace x dots x k text times 2 k x Append the string x exactly k times at the end of string t In other words t t underbrace x dots x k text times After each operation determine if it is possible to the characters of s and t such that s is lexicographically smaller dagger than t Note that the strings change after performing each operation and go back to their initial states dagger Simply speaking the lexicographical order is the order in which words are listed in a dictionary A formal definition is as follows string p is lexicographically smaller than string q if there exists a position i such that p i q i and for all j i p j q j If no such i exists then p is lexicographically smaller than q if the length of p is less than the length of q For example texttt abdc texttt abe and texttt abc texttt abcd where we write p q if p is lexicographically smaller than q ,"['#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\n#define vi vector<int>\n\nvoid solve()\n{\n\tmap<char,int> m1,m2;\n\tm1[\'a\']++;\n\tm2[\'a\']++;\n\n\tint q;\n\tcin>>q;\n     int len1=1,len2=1;\n\twhile(q--)\n\t{\n\t\tint p;\n\t\tcin>>p;\n\n\t\t int k;\n\t\t cin>>k;\n\t\t string a;\n\t\t cin>>a;\n\n\t\t map<char,int> temp;\n\t\t for(int i=0;i<a.size();i++)\n\t\t \t temp[a[i]]++;\n\n\t\t for(auto x:temp)\n\t\t {\n\t\t \t if(p==1)\n\t\t \t {\n\t\t \t \t m1[x.first]+=(x.second*k);\n\t\t \t \t len1+=(x.second*k);\n\t\t \t }\n\t\t \t else\n\t\t \t {\n\t\t \t \tlen2+=(x.second*k);\n\t\t \t \tm2[x.first]+=(x.second*k);\n\t\t \t }\n\t\t }\n       bool ans=false;\n\n         char first=\'a\';\n         while(m1[first]==0)\n         {\n         \t first++;\n         }\n\n         for(char a1=first+1;a1<=\'z\';a1++)\n         {\n         \t if(m2[a1])\n         \t {\n         \t \t ans=true;\n         \t \t break;\n         \t }\n         }\n\n       //cout<<first<<endl;\n          if((len1==m1[first]) and (m2[first]>len1))\n          {\n          \t ans=true;\n          }\n\n          if(ans)\n          \t cout<<""YES""<<endl;\n          \telse\n          \t\tcout<<""NO""<<endl;\n\n\n\n        \n\n\t}\n}\n\nint32_t main()\n{\n\t int t=1;\n\n\t cin>>t;\n\n\t while(t--)\n\t {\n\t \t solve();\n\t }\n\t return 0;\n}                                    ']","['constructive algorithms', 'greedy', 'strings']",1500
https://codeforces.com//contest/950/problem/B,B. Intercepted Message,Hacker Zhorik wants to decipher two secret messages he intercepted yesterday Yeah message is a sequence of encrypted blocks each of them consists of several bytes of information Zhorik knows that each of the messages is an archive containing one or more files Zhorik knows how each of these archives was transferred through the network if an archive consists of files of sizes bytes then the th file is split to one or more blocks here the total length of the blocks is equal to the length of the file and after that all blocks are transferred through the network maintaining the order of files in the archive Zhorik thinks that the two messages contain the same archive because their total lengths are equal However each file can be split in blocks in different ways in the two messages You are given the lengths of blocks in each of the two messages Help Zhorik to determine what is the maximum number of files could be in the archive if the Zhorik s assumption is correct ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nlong long a[N],b[N];\nint ans,n,m;\nset<long long> s;\n\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(""%I64d"",&a[i]),a[i]+=a[i-1],s.insert(a[i]);\n\tfor(int i=1;i<=m;i++)scanf(""%I64d"",&b[i]),b[i]+=b[i-1],ans+=s.count(b[i]);\n\tcout<<ans;\n\treturn 0;\n}\n\n\n']","['greedy', 'implementation']",1100
https://codeforces.com//contest/703/problem/C,C. Chris and Road,And while Mishka is enjoying her trip Chris is a little brown bear No one knows where and when he met Mishka but for a long time they are together excluding her current trip However best friends are important too John is Chris best friend Once walking with his friend John gave Chris the following problem At the infinite horizontal road of width bounded by lines and there is a bus moving presented as a convex polygon of vertices The bus moves continuously with a constant speed of in a straight line in direction of decreasing coordinates thus in time of its points are changing Formally after time each of coordinates of its points will be decreased by There is a pedestrian in the point who can move only by a vertical pedestrian crossing presented as a segment connecting points and with any speed not exceeding Thus the pedestrian can move only in a straight line in any direction with any speed not exceeding and not leaving the road borders The pedestrian can instantly change his speed thus for example he can stop instantly Please look at the sample note picture for better understanding We consider the pedestrian is if at any moment the point he is located in lies the bus polygon this means that if the point lies on the polygon vertex or on its edge the pedestrian is not hit by the bus You are given the bus position at the moment Please help Chris determine minimum amount of time the pedestrian needs to cross the road and reach the point and not to be hit by the bus ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name"".in"", ""r"", stdin); \\\n        freopen(name"".out"", ""w"", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << "" = "" << head << "" <<"" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=\',\' || c!=0) {\n        if (*s==\'(\' || *s==\'[\' || *s==\'{\' || *s==\'<\') c++;\n        if (*s==\')\' || *s==\']\' || *s==\'}\' || *s==\'>\') c--;\n        cerr << *s++;\n    }\n    cerr << "" = "" << head << "", "";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << ""\\033[32m>> "" << __LINE__ << "": "" << __PRETTY_FUNCTION__ << endl; \\\n    cout << ""   ""; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << ""\\033[0m""; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss="""", const string se="""") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? """" : "", "") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << ""("" << pair.F << "", "" << pair.S << "")"";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), ""["", ""]"");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), ""{"", ""}"");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), ""|"", ""|"");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << ""{"";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?"""":"", "") << it->F << "":"" << it->S;\n    }\n    o << ""}"";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << ""Not lucky"" << endl;\n        exit(0);\n    }\n}\n\nusing pdd = pair<double, double>;\n\nconst double INF = 1e15;\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    int N;\n    double W, V, U;\n    cin >> N >> W >> V >> U;\n\n    double mt = INF, xt = 0.0;\n\n    for (int i=0; i<N; i++) {\n        double x, y;\n        cin >> x >> y;\n        \n        double t = x / V - y / U;\n        mt = min(t, mt);\n        xt = max(t, xt);\n    }\n\n    const double EPS = 1e-12;\n\n    cout << fixed << setprecision(10);\n    if (mt >= -EPS) {\n        cout << W / U << endl;\n    } else {\n        cout << W/U + xt << endl;\n    }\n\n    return 0;\n}\n\n']","['geometry', 'implementation']",2100
https://codeforces.com//contest/1079/problem/C,C. Playing Piano,Little Paul wants to learn how to play piano He already has a melody he wants to start with For simplicity he represented this melody as a sequence a 1 a 2 ldots a n of key numbers the more a number is the closer it is to the right end of the piano keyboard Paul is very clever and knows that the essential thing is to properly assign fingers to notes he s going to play If he chooses an inconvenient fingering he will then waste a lot of time trying to learn how to play the melody by these fingers and he will probably not succeed Let s denote the fingers of hand by numbers from 1 to 5 We call a any sequence b 1 ldots b n of fingers numbers A fingering is if for all 1 leq i leq n 1 the following holds if a i a i 1 then b i b i 1 because otherwise Paul needs to take his hand off the keyboard to play the i 1 st note if a i a i 1 then b i b i 1 because of the same if a i a i 1 then b i neq b i 1 because using the same finger twice in a row is dumb Please provide any convenient fingering or find out that there is none ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint a[(int)2e5];\nint dp[(int)2e5][6];\nint u[(int)2e5][6];\nint p[(int)2e5][6];\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    u[1][1] = 1;\n    u[1][2] = 1;\n    u[1][3] = 1;\n    u[1][4] = 1;\n    u[1][5] = 1;\n    for(int i = 1; i < n; i++)\n    {\n        for(int t = 1; t <= 5; t++)\n        {\n            if(!u[i][t])continue;\n            if(a[i + 1] > a[i])\n            {\n                for(int j = t + 1; j <= 5;j++)\n                {\n                    p[i + 1][j] = t;\n                    u[i + 1][j] = 1;\n                }\n            }\n            if(a[i + 1] < a[i])\n            {\n                for(int j = 1; j < t;j++)\n                {\n                    p[i + 1][j] = t;\n                    u[i +1][j] = 1;\n                }\n            }\n            if(a[i + 1]==a[i])\n            {\n                for(int j = 1; j <= 5;j++)\n                {\n                    if(j == t)\n                        continue;\n                    p[i + 1][j] = t;\n                    u[i +1][j] = 1;\n                }\n            }\n        }\n    }\n    int e = 0;\n    for(int j = 1; j<=5;j++)\n        if(u[n][j])\n            e = j;\n    if(e == 0)\n    {\n        cout << -1;\n        return 0;\n    }\n    vector<int> ans;\n    //return 0;\n    for(int i = n; i >=1;i--)\n    {\n        ans.push_back(e);\n        e = p[i][e];\n    }\n    reverse(ans.begin(),ans.end());\n    for(auto x: ans)\n        cout << x << ' ';\n}\n""]",['dp'],1700
https://codeforces.com//contest/1372/problem/C,C. Omkar and Baseball,Patrick likes to play baseball but sometimes he will spend so many hours hitting home runs that his mind starts to get foggy Patrick is sure that his scores across n sessions follow the identity permutation ie in the first game he scores 1 point in the second game he scores 2 points and so on However when he checks back to his record he sees that all the numbers are mixed up Define a special exchange as the following choose any subarray of the scores and permute elements such that no element of subarray gets to the same position as it was before the exchange For example performing a special exchange on 1 2 3 can yield 3 1 2 but it cannot yield 3 2 1 since the 2 is in the same position Given a permutation of n integers please help Patrick find the minimum number of special exchanges needed to make the permutation sorted It can be proved that under given constraints this number doesn t exceed 10 18 An array a is a subarray of an array b if a can be obtained from b by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef pair<int ,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double rl;\n\ntypedef pii int2;\ntypedef tuple<int, int, int>           int3;\ntypedef tuple<int, int, int, int>      int4;\ntypedef tuple<int, int, int, int, int> int5;\n\ntypedef pll ll2;\ntypedef tuple<ll, ll, ll>         ll3;\ntypedef tuple<ll, ll, ll, ll>     ll4;\ntypedef tuple<ll, ll, ll, ll, ll> ll5;\n\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vll_ll;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\ntypedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n\n#define FOR(i,N) for(int i=0; i<N; i++)\n\n#define popc __builtin_popcountll\n// #define popc __builtin_popcount\n\ntemplate<typename A>\nstring to_string(A* ptr)\n{\n    stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill (\'0\') << std::hex << (uint64_t)(uintptr_t)ptr;\n    return ss.str();\n}\n\nstring to_string(char c)\n{\n    return ((string)""\'""+c)+ ""\'"";\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#if !ONLINE_JUDGE && 1\n#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\nconst int MX=2e5+99;\nint n, a[MX];\n\nll solve()\n{\n    //bool id=true;\n    //bool all_neq=true;\n\n    int cnt_neq=0;\n    int mn_neq=n+1, mx_neq=0;\n\n    for(int i=1; i<=n; i++)\n    {\n        if(a[i]!=i)\n        {\n            cnt_neq++;\n            mn_neq=min(mn_neq, i);\n            mx_neq=max(mx_neq, i);\n        }\n    }\n\n    if(cnt_neq==0) return 0;\n    if(mx_neq-mn_neq+1==cnt_neq)\n    {\n        return 1;\n    }\n    return 2;\n\n    //return -1;\n}\n\nint main()\n{\n#if !ONLINE_JUDGE && 1\n    freopen(""C.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n#endif\n#if 0\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n#endif\n\n    int TT;\n#if 1\n    cin >> TT;\n#else\n    TT=1;\n#endif\n    for(int ttt=0; ttt<TT; ttt++)\n    {\n        cin >> n;\n        for(int i=1; i<=n; i++) cin >> a[i];\n        cout << solve() << \'\\n\';\n    }\n\n    return 0;\n}\n']","['constructive algorithms', 'math']",1500
https://codeforces.com//contest/1843/problem/A,A. Sasha and Array Coloring,Sasha found an array a consisting of n integers and asked you to paint elements You have to paint each element of the array You can use as many colors as you want but each element should be painted into exactly one color and for each color there should be at least one element of that color The of one color is the value of max S min S where S is the sequence of elements of that color The of the whole coloring is the of costs over all colors For example suppose you have an array a color red 1 color red 5 color blue 6 color blue 3 color red 4 and you painted its elements into two colors as follows elements on positions 1 2 and 5 have color 1 elements on positions 3 and 4 have color 2 Then the cost of the color 1 is max 1 5 4 min 1 5 4 5 1 4 the cost of the color 2 is max 6 3 min 6 3 6 3 3 the total cost of the coloring is 7 For the given array a you have to calculate the possible cost of the coloring ,"['#include<bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve()\n{\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0;i < n;i++) std::cin >> a[i];\n    std::sort(a.begin(), a.end());\n    int ans = 0;\n    for(int i = 0;i < n - 1 -i;i ++) ans += a[n - 1 - i] - a[i];\n    std::cout << ans << ""\\n"";\n}\nint main()\n{\n    int t;\n    std::cin >> t;\n    while(t--) solve();\n    return 0;\n}']","['greedy', 'sortings', 'two pointers']",800
https://codeforces.com//contest/903/problem/E,E. Swapping Characters,We had a string consisting of lowercase Latin letters We made copies of this string thus obtaining identical strings After that in each of these strings we swapped exactly two characters the characters we swapped could be identical but they had different indices in the string You are given strings and you have to restore any string so that it is possible to obtain these strings by performing aforementioned operations Note that the total length of the strings you are given doesn t exceed 5000 that is ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nstring in[5550];\nvector <int> Vl[5550];\nchar u[5550];\n\nint cnt[26];\nint cnt2[26];\nint main() {\n\tint K, N, i, j, k, l;\n\tscanf(""%d %d"", &K, &N);\n\tfor (i = 0; i < K; i++) {\n\t\tscanf(""%s"", u);\n\t\tin[i] = string(u);\n\t}\n\tfor (i = 0; i < N; i++) cnt[in[0][i] - \'a\']++;\n\tfor (i = 1; i < K; i++) {\n\t\tfor (j = 0; j < 26; j++) cnt2[j] = 0;\n\t\tfor (j = 0; j < N; j++) cnt2[in[i][j] - \'a\']++;\n\t\tfor (j = 0; j < 26; j++) if (cnt[j] != cnt2[j]) return !printf(""-1\\n"");\n\t}\n\n\tbool chk2 = false;\n\tfor (i = 0; i < 26; i++) if (cnt[i] >= 2) chk2 = true;\n\n\tfor (i = 1; i < K; i++) {\n\t\tfor (j = 0; j < N; j++) if (in[0][j] != in[i][j]) Vl[i].push_back(j);\n\t\tif (Vl[i].size() > 4) return !printf(""-1\\n"");\n\t}\n\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = i + 1; j < N; j++) {\n\t\t\tswap(in[0][i], in[0][j]);\n\t\t\tfor (k = 1; k < K; k++) {\n\t\t\t\tint c = 0;\n\t\t\t\tif (in[0][i] != in[k][i]) c++;\n\t\t\t\tif (in[0][j] != in[k][j]) c++;\n\t\t\t\tfor (auto it : Vl[k]) if (it != i && it != j && in[0][it] != in[k][it]) c++;\n\t\t\t\tif (c > 2) break;\n\t\t\t\tif (c == 0 && !chk2) break;\n\t\t\t}\n\t\t\tif (k >= K) return !printf(""%s\\n"", in[0].c_str());\n\t\t\tswap(in[0][i], in[0][j]);\n\t\t}\n\t}\n\treturn !printf(""-1\\n"");\n}']","['brute force', 'hashing', 'implementation', 'strings']",2200
https://codeforces.com//contest/1207/problem/A,A. There Are Two Types Of Burgers,There are two types of burgers in your restaurant hamburgers and chicken burgers To assemble a hamburger you need two buns and a beef patty To assemble a chicken burger you need two buns and a chicken cutlet You have b buns p beef patties and f chicken cutlets in your restaurant You can sell one hamburger for h dollars and one chicken burger for c dollars Calculate the maximum profit you can achieve You have to answer t independent queries ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    ios :: sync_with_stdio(0);\n    cin >> t;\n    while(t--) {\n        int a, b, c, x, y;\n        cin >> a >> b >> c >> x >> y;\n        a /= 2;\n        int ans = 0;\n        if(x < y) swap(x, y), swap(b, c);\n        ans += x * min(a, b);\n        a -= min(a, b);\n        ans += y * min(a, c);\n        cout << ans << endl;\n    }\n}']","['brute force', 'greedy', 'implementation', 'math']",800
https://codeforces.com//contest/1197/problem/C,C. Array Splitting,You are given a array a 1 a 2 dots a n for each index i 1 condition a i ge a i 1 holds and an integer k You are asked to divide this array into k non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let max i be equal to the maximum in the i th subarray and min i be equal to the minimum in the i th subarray The cost of division is equal to sum limits i 1 k max i min i For example if a 2 4 5 5 8 11 19 and we divide it into 3 subarrays in the following way 2 4 5 5 8 11 19 then the cost of division is equal to 4 2 5 5 19 8 13 Calculate the minimum cost you can obtain by dividing the array a into k non empty consecutive subarrays ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 300300;\nint n, k;\nint a[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tn--;\n\tk--;\n\tint ans = a[n] - a[0];\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = a[i + 1] - a[i];\n\tsort(a, a + n);\n\treverse(a, a + n);\n\tfor (int i = 0; i < k; i++)\n\t\tans -= a[i];\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","['greedy', 'sortings']",1400
https://codeforces.com//contest/992/problem/B,B. Nastya Studies Informatics,Today on Informatics class Nastya learned about GCD and LCM see links below Nastya is very intelligent so she solved all the tasks momentarily and now suggests you to solve one of them as well We define a pair of integers if and where denotes the greatest common divisor of and and denotes the least common multiple of and You are given two integers and You are to find the number of pairs of integers such that Note that pairs and are considered different if ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nT gcd(T a, T b) {\n\tT t;\n\twhile (a) {\n\t\tt = a;\n\t\ta = b % a;\n\t\tb = t;\n\t}\n\treturn b;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tll l, r, x, y;\n\tcin >> l >> r >> x >> y;\n\n\tset<ll> d;\n\tfor (ll i=1; i*i<=y; i++) {\n\t\tif (y % i == 0) {\n\t\t\td.insert(i);\n\t\t\td.insert(y / i);\n\t\t}\n\t}\n\n\tll c = 0;\n\n\tfor (ll a : d) {\n\t\tfor (ll b : d) {\n\t\t\tll g = gcd(a, b);\n\t\t\tif (g == x && a*b/g == y && l <= a && a <= r && l <= b && b <= r)\n\t\t\t\tc++;\n\t\t}\n\t}\n\n\tcout << c;\n}']","['math', 'number theory']",1600
https://codeforces.com//contest/467/problem/E,E. Alex and Complicated Task,After you have read all the problems probably you think Alex is genius person That s true One day he came up with the following task Given a sequence of integer numbers You are to find a longest sequence that satisfies the following conditions for all valid integer for all valid integer sequence is subsequence of not necessarily contiguous subsequence And finally Alex had given this complicated task to George and George gave it to you Help George to cope with the task ,"[' /*                                                                       \nnikto ne smeet obijat\' malen\'kogo begemotika\n  _ _ _ _\n /.  _  .\\\n|   /_\\   |\n|_ _ _ _ _|\n   NIKTO                                                             \n*/\n#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <cassert>\n#include <math.h>\n#include <vector>\n#include <map>\n#include <time.h>\nusing namespace std;           \n#define forn(i, x, n) for(int i = x; i <= n; ++i)\n#define for1(i, n, x) for(int i = n; i >= x; --i)\n#define file """"//"".""\n#define ll long long  \n#define ull unsigned long long\n#define PII pair <int, int>\n#define mp make_pair\n#define fr first\n#define sec second                       \n#define pb push_back\n                                             \nconst int maxn = 500500;\nconst int INF = int(1e9) + 7;\n                  \nint ans, res[maxn];\n\nmap <int, int> cnt, Left;\npair < PII, int > st[maxn];\nint sz;\n\nvoid Add_ans(int a, int b) {\n\tres[++ans] = a;\n\tres[++ans] = b;\n\tres[++ans] = a;\n\tres[++ans] = b;\n\tsz = 0;\n\tcnt.clear();\n\tLeft.clear();\n}\n\nint a[maxn];    \nint n;              \n\nbool added;\nint main() {\n/*                                                               \n\tfreopen(file""in"", ""r"", stdin);\n\tfreopen(file""out"", ""w"", stdout);\n*/                  \n\tscanf(""%d"", &n);    \n\tforn(i, 1, n) {               \n\t\tscanf(""%d"", &a[i]);\n\t}\n\n\tforn(i, 1, n) {\n\t\t++cnt[a[i]];\n\t\tif (cnt[a[i]] == 4) {\n\t\t\tAdd_ans(a[i], a[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (Left.find(a[i]) == Left.end())\n\t\t\tLeft[a[i]] = i;\n\t    else {    \n\t    \tadded = 0;\n\t    \tfor(;sz;) {\n\t    \t\tint l = st[sz].fr.fr, r = st[sz].fr.sec, val = st[sz].sec;\n\t    \t\tif (Left[a[i]] < l)\t{\n\t    \t\t\t--sz;\n\t    \t\t\tcontinue;\t\n\t    \t\t}      \n\t    \t\tif (l < Left[a[i]] && Left[a[i]] < r) {\n\t    \t\t\tAdd_ans(val, a[i]);\n\t    \t\t\tadded = 1;\n\t    \t\t}\t      \n\t    \t\tbreak;\n\t \t    }\n\t \t    if (!added)\n\t \t    \tst[++sz] = mp(mp(Left[a[i]], i), a[i]);\n\t    }    \n\t}\n       \n    printf(""%d\\n"", ans);\n\tforn(i, 1, ans) {\n\t\tprintf(""%d "", res[i]);\n\t}\n\treturn 0;      \t\n}\n                          ']","['data structures', 'dp', 'greedy']",2300
https://codeforces.com//contest/1811/problem/B,B. Conveyor Belts,Conveyor matrix m n is matrix of size n times n where n is an number The matrix consists of concentric ribbons moving clockwise In other words the conveyor matrix for n 2 is simply a matrix 2 times 2 whose cells form a cycle of length 4 clockwise For any natural k ge 2 the matrix m 2k is obtained by adding to the matrix m 2k 2 an outer layer forming a clockwise cycle You are standing in a cell with coordinates x 1 y 1 and you want to get into a cell with coordinates x 2 y 2 A cell has coordinates x y if it is located at the intersection of the xth row and the yth column Standing on some cell every second you will move to the cell next in the direction of movement of the tape on which you are You can also move to a neighboring cell by spending one unit of energy Movements happen instantly and you can make an unlimited number of them at any time Your task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates x 1 y 1 to the cell with coordinates x 2 y 2 For example n 8 initially you are in a cell with coordinates 1 3 and you want to get into a cell with coordinates 6 4 You can immediately make 2 movements once you are in a cell with coordinates 3 3 and then after 8 seconds you will be in the right cell ,"['#pragma GCC optimize(""Ofast"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\n#define fi first\n#define se second\n#define E \'\\n\'\nmt19937 gen(chrono::system_clock().now().time_since_epoch().count());\n\nvoid svin() {\n    int n, x1, y1, x2, y2;\n    cin >> n >> x1 >> y1 >> x2 >> y2;\n    x1 = min(x1, n - x1 + 1);\n    y1 = min(y1, n - y1 + 1);\n    int k1 = min(x1, y1);\n    x2 = min(x2, n - x2 + 1);\n    y2 = min(y2, n - y2 + 1);\n    int k2 = min(x2, y2);\n//    cout << x1 << \' \' << y1 << \' \' << x2 << \' \' << y2 << E;\n    cout << abs(k1 - k2) << E;\n    return;\n}\n\nint32_t main () {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#ifdef LOCAL\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif // LOCAL\n    int qq;\n    cin >> qq;\n    while(qq--) {\n        svin();\n    }\n    return 0;\n}\n']","['implementation', 'math']",1000
https://codeforces.com//contest/1277/problem/B,B. Make Them Odd,There are n positive integers a 1 a 2 dots a n For the one move you can choose any even value c and divide by two elements that equal c For example if a 6 8 12 6 3 12 and you choose c 6 and a is transformed into a 3 8 12 3 3 12 after the move You need to find the minimal number of moves for transforming a to an array of only odd integers each element shouldn t be divisible by 2 ,"['#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(i,t){\n    int n;cin>>n;\n    vector<ll> A;\n    rep(j,n){\n      ll a;cin>>a;\n      A.push_back(a);\n    }\n\n    map<ll,ll> mp;\n    rep(j,n){\n      ll a = A[j];\n      ll count = 0;\n      while(a%2 == 0){\n        a/=2;\n        count++;\n      }\n      if(mp.count(a) == 0){\n        mp[a] = count;\n      }else{\n        mp[a] = max(mp[a], count);\n      }\n    }\n    ll ans = 0;\n    for(auto itr=mp.begin(); itr!=mp.end(); itr++){\n      ans += itr->second;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n']","['greedy', 'number theory']",1200
https://codeforces.com//contest/596/problem/B,B. Wilbur and Array,Wilbur the pig is tinkering with arrays again He has the array initially consisting of zeros At one step he can choose any index and either add to all elements or subtract from all elements His goal is to end up with the array Of course Wilbur wants to achieve this goal in the minimum number of steps and asks you to compute this value ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2e5 + 49;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nll a[maxN], b[maxN];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> b[i];\n\tll x = 0, y = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] += x - y;\n\t\tif (a[i] < b[i])\n\t\t\tx += b[i] - a[i];\n\t\telse\n\t\t\ty += a[i] - b[i];\t\n\t}\n\tcout << x + y << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","['greedy', 'implementation']",1100
https://codeforces.com//contest/911/problem/A,A. Nearest Minimums,You are given an array of integer numbers Find the distance between two closest nearest minimums in it It is guaranteed that in the array a minimum occurs at least two times ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    vector<int> a(N);\n    for (int i = 0; i < N; i++)\n        cin >> a[i];\n    int L = *min_element(RA(a));\n    int prev = INT_MIN / 2;\n    int ans = INT_MAX;\n    for (int i = 0; i < N; i++)\n        if (a[i] == L)\n        {\n            ans = min(ans, i - prev);\n            prev = i;\n        }\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']",['implementation'],1100
https://codeforces.com//contest/1948/problem/B,B. Array Fix,You are given an integer array a of length n You can perform the following operation any number of times possibly zero take any element of the array a which is at least 10 delete it and instead insert the digits that element consisted of in the same position in order they appear in that element For example if we apply this operation to the 3 rd element of the array 12 3 45 67 then the array becomes 12 3 4 5 67 if we apply this operation to the 2 nd element of the array 2 10 then the array becomes 2 1 0 Your task is to determine whether it is possible to make a sorted in non descending order using the aforementioned operation In other words you have to determine if it is possible to transform the array a in such a way that a 1 le a 2 le dots le a k where k is the current length of the array a ,"['/**\n *    author:  tourist\n *    created: 15.03.2024 10:39:06\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    bool fail = false;\n    int p = 0;\n    for (int x : a) {\n      if (x >= 10 && x / 10 >= p && x % 10 >= x / 10) {\n        p = x % 10;\n      } else {\n        if (x >= p) {\n          p = x;\n        } else {\n          fail = true;\n          break;\n        }\n      }\n    }\n    cout << (fail ? ""NO"" : ""YES"") << \'\\n\';\n  }\n  return 0;\n}\n']","['brute force', 'dp', 'greedy', 'implementation']",1100
https://codeforces.com//contest/187/problem/D,D. BRT Contract ,In the last war of PMP he defeated all his opponents and advanced to the final round But after the end of semi final round evil attacked him from behind and killed him God bless him Before his death PMP signed a contract with the bus rapid transit BRT that improves public transportations by optimizing time of travel estimation You should help PMP finish his last contract Each BRT line is straight line that passes intersecting on its ways At each intersection there is traffic light that periodically cycles between green and red It starts illuminating green at time zero During the green phase which lasts for seconds traffic is allowed to proceed After the green phase the light changes to red and remains in this color for seconds During the red phase traffic is prohibited from proceeding If a vehicle reaches the intersection exactly at a time when the light changes to red it should stop but the vehicle is clear to proceed if the light has just changed to green All traffic lights have the same timing and are synchronized In other words the period of red and green phase is the same for all of traffic lights and they all start illuminating green at time zero The BRT Company has calculated the time that a bus requires to pass each road segment A road segment is the distance between two consecutive traffic lights or between a traffic light and source or destination station More precisely BRT specialists provide positive integers the time in seconds that a bus needs to traverse th road segment in the path from source to destination The value denotes the time that a bus needs to pass the distance between source and the first intersection The value denotes the time between the last intersection and destination In one day buses leave the source station The th bus starts from source at time in seconds Decision makers of BRT Company want to know what time a bus gets to destination The bus is considered as point A bus will always move if it can The buses do not interfere with each other ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nint q;\nlong long g,r;\nlong long gr;\nlong long li[101000];\nlong long sl[101000];\nlong long qu[101000];\nlong long ans[101000];\nlong long dp[101000];\nlong long ev[201000];\ninline long long mod(long long a,long long b){\n    a%=b;\n    if(a<0)a+=b;\n    return a;\n}\nlong long tre[1010000];\ninline void down(int np){\n    if(tre[np]!=-1){\n        tre[np*2]=tre[np*2+1]=tre[np];\n        tre[np]=-1;\n    }\n}\ninline void add(int np,int l,int r,int x,int y,int c){\n//    printf(""add %d %d %d %d %d %d\\n"",np,l,r,x,y,c);\n    if(x==y)return;\n    if(l==x&&r==y){\n        tre[np]=c;\n        return;\n    }\n    down(np);\n    int m=(l+r)/2;\n    if(x<=m&&y>=m){\n        add(np*2,l,m,x,m,c);\n        add(np*2+1,m,r,m,y,c);\n    }else if(x>=m){\n        add(np*2+1,m,r,x,y,c);\n    }else{\n        add(np*2,l,m,x,y,c);\n    }\n}\ninline int que(int np,int l,int r,int x){\n    if(tre[np]!=-1)return tre[np];\n    if(r==l+1)return tre[np];\n    down(np);\n    int m=(l+r)/2;\n    if(x>=m)return que(np*2+1,m,r,x);\n    else return que(np*2,l,m,x);\n}\nint evc;\ninline int lshua(int x){\n    return upper_bound(ev,ev+evc,x)-ev-1;\n}\ninline void build(){\n    int i;\n    memset(tre,-1,sizeof(tre));\n    evc=0;\n    ev[evc++]=0;\n    for(i=0;i<n;i++){\n        ev[evc++]=mod(g-sl[i],gr);\n        ev[evc++]=mod(g+r-sl[i],gr);\n    }\n    sort(ev,ev+evc);\n    evc=unique(ev,ev+evc)-ev;\n    //printf(""evc=%d\\n"",evc);\n    //for(i=0;i<evc;i++)printf(""%d "",ev[i]);puts("""");\n    dp[n]=0;\n    for(i=n-1;i>=0;i--){\n        long long sp=mod(0-sl[i],gr);\n        int k=que(1,0,evc,lshua(sp));\n        if(k==-1)dp[i]=sl[n]-sl[i];\n        else{\n            long long qq=sl[k]-sl[i];\n            qq=(qq/gr+1)*gr;\n            qq+=dp[k];\n            dp[i]=qq;\n        }\n        //printf(""dp[%d]=%d\\n"",i,dp[i]);\n        long long e1=mod(g-sl[i],gr);\n        long long e2=mod(g+r-sl[i],gr);\n        int ee1=lshua(e1);\n        int ee2=lshua(e2);\n        if(ee1<ee2)add(1,0,evc,ee1,ee2,i);\n        else{\n            add(1,0,evc,ee1,evc,i);\n            add(1,0,evc,0,ee2,i);\n        }\n    }\n}\ninline void solve(){\n    int i;\n    build();\n    for(i=0;i<q;i++){\n        long long qq=qu[i];\n        long long rr=qq/gr;\n        qq%=gr;\n        int qqq=lshua(qq);\n        int k=que(1,0,evc,qqq);\n        //printf(""qq=%I64d qqq=%d k=%d\\n"",qq,qqq,k);\n        if(k==-1)ans[i]=qu[i]+sl[n];\n        else{\n            qq+=sl[k];\n            qq=(qq/gr+1)*gr;\n            qq+=dp[k];\n            ans[i]=qq+rr*gr;\n        }\n    }\n}\nint main(){\n    int i;\n    scanf(""%d%I64d%I64d"",&n,&g,&r);\n    gr=g+r;\n    for(i=0;i<=n;i++){\n        scanf(""%I64d"",&li[i]);\n        sl[i]=li[i];\n        if(i)sl[i]+=sl[i-1];\n    }\n    scanf(""%d"",&q);\n    for(i=0;i<q;i++)scanf(""%I64d"",&qu[i]);\n    solve();\n    for(i=0;i<q;i++)printf(""%I64d\\n"",ans[i]);\n}\n\n']",['data structures'],2800
https://codeforces.com//contest/1850/problem/E,E. Cardboard for Pictures,Mircea has n pictures The i th picture is a square with a side length of s i centimeters He mounted each picture on a square piece of cardboard so that each picture has a border of w centimeters of cardboard on all sides In total he used c square centimeters of cardboard Given the picture sizes and the value c can you find the value of w Please note that the piece of cardboard goes behind each picture not just the border ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tll n, c;  cin >> n >> c;\n\tvector<ll> a(n);\n\tfor (auto &ai: a) {\n\t\tcin >> ai;\n\t}\n\tll lo = 0, hi = 1;\n\twhile (true) {\n\t\tll sum = 0;\n\t\tfor (auto ai: a) {\n\t\t\tsum += (ai + 2 * hi) * (ai + 2 * hi);\n\t\t}\n\t\tif (sum >= c)  break;\n\t\thi *= 2;\n\t}\n\n\twhile (lo <= hi) {\n\t\tll mid = (lo + hi) / 2;\n\t\tll sum = 0;\n\t\tfor (auto ai: a) {\n\t\t\tsum += (ai + 2 * mid) * (ai + 2 * mid);\n\t\t}\n\t\tif (sum >= c)  hi = mid - 1;\n\t\telse  lo = mid + 1;\n\t}\n\tcout << lo << ""\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","['binary search', 'geometry', 'implementation', 'math']",1100
https://codeforces.com//contest/789/problem/B,B. Masha and geometric depression,Masha really loves algebra On the last lesson her strict teacher Dvastan gave she new exercise You are given geometric progression defined by two integers and Remind that a geometric progression is a sequence of integers where for each the respective term satisfies the condition where is called the common ratio of the progression Progressions in Uzhlyandia are unusual both and Also Dvastan gave Masha bad integers and an integer Masha writes all progression terms one by one onto the board including repetitive while condition is satisfied means absolute value of There is an exception if a term equals one of the bad integers Masha skips it doesn t write onto the board and moves forward to the next term But the lesson is going to end soon so Masha has to calculate how many integers will be written on the board In order not to get into depression Masha asked you for help help her calculate how many numbers she will write or print in case she needs to write infinitely many integers ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nmap<ll, int> bad;\nint main()\n{\n    ll b1,q,l,m;\n    scanf(""%lld%lld%lld%lld"",&b1,&q,&l,&m);\n    while(m--)\n    {\n        ll x;\n        scanf(""%lld"",&x);\n        bad[x]++;\n    }\n    ll ans = 0;\n    int cnt = 0;\n    while(llabs(b1)<=l&&cnt<100000)\n    {\n        ++cnt;\n        if(!bad[b1]) ans++;\n        b1*=q;\n    }\n    if(ans > 2000) puts(""inf"");\n    else printf(""%lld\\n"",ans);\n    return 0;\n    \n    if(b1==0)\n    {\n        if(bad[0]) puts(""0"");\n        else puts(""inf"");\n    } \n    else\n    if(q==0)\n    {\n        ll ans = 0;\n        if(!bad[b1]) ans++;\n        if(!bad[0]) puts(""inf"");\n        else printf(""%lld\\n"",ans);\n    }                                                                         \n    else if(q==1)\n    {\n        if(bad[b1]) puts(""0"");\n        else puts(""inf"");\n    }\n    else if(q==-1)\n    {\n        if(bad[b1]&&bad[-b1]) puts(""0"");\n        else puts(""inf"");\n    }\n    else\n    {\n        ll ans = 0;\n        while(llabs(b1)<=l)\n        {\n            if(!bad[b1]) ans++;\n            b1*=q;\n        }\n        printf(""%lld\\n"",ans);\n    }\n    return 0;\n}\n']","['brute force', 'implementation', 'math']",1700
https://codeforces.com//contest/832/problem/C,C. Strange Radiation,people are standing on a coordinate axis in points with positive integer coordinates strictly less than For each person we know in which direction left or right he is facing and his maximum speed You can put a bomb in some point with non negative integer coordinate and blow it up At this moment all people will start running with their maximum speed in the direction they are facing Also two strange rays will start propagating from the bomb with speed one to the right and one to the left Of course the speed is strictly greater than people s maximum speed The rays are strange because if at any moment the position and the direction of movement of some ray and some person coincide then the speed of the person immediately increases by the speed of the ray You need to place the bomb is such a point that the minimum time moment in which there is a person that has run through point and there is a person that has run through point is as small as possible In other words find the minimum time moment such that there is a point you can place the bomb to so that at time moment some person has run through and some person has run through point ,"['#include<stdio.h>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct ppl {\n\tint x, v;\n\tbool operator< (const ppl& c) const {\n\t\treturn x < c.x;\n\t}\n} ba[101010];\n\nconst double endp = 1e6;\nint N, S;\n\nint main(){\n\tscanf(""%d%d"", &N, &S);\n\tfor(int i=0; i<N; i++){\n\t\tint typ;\n\t\tscanf(""%d%d%d"", &ba[i].x, &ba[i].v, &typ);\n\t\tif(typ == 1) ba[i].v *= -1;\n\t}\n\tsort(ba, ba+N);\n\tdouble mi=1e-7, mx=1e7, md;\n\twhile(mx-mi > 1e-8){\n\t\tmd = (mi+mx)/2.;\n\t\tdouble xmiL=1e6, xmxL=0, xmiR=1e6, xmxR=0;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tdouble tim, rem, v;\n\t\t\tif(ba[i].v < 0) rem = ba[i].x, v = -ba[i].v;\n\t\t\telse rem = endp - ba[i].x, v = ba[i].v;\n\t\t\ttim = rem / v;\n\t\t\tif(tim <= md){\n\t\t\t\tif(ba[i].v < 0) xmiL=0, xmxL=1e6;\n\t\t\t\telse xmiR = 0, xmxR=1e6;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdouble co = (tim-md) * v * (S+v) / S;\n\t\t\tif(rem < co){ continue; }\n\n\t\t\tdouble real = co + (md - co/(S+v)) * S, l, r;\n\t\t\tif(ba[i].v < 0) l = ba[i].x, r = real;\n\t\t\telse l = endp-real, r = ba[i].x;\n\t\t\tif(ba[i].v < 0) xmiL = min(xmiL, l), xmxL = max(xmxL, r);\n\t\t\telse xmiR = min(xmiR, l), xmxR = max(xmxR, r);\n\t\t}\n\t\tdouble xmi = max(xmiL, xmiR), xmx = min(xmxL, xmxR);\n\t\tif(ceil(xmi) <= floor(xmx)) mx = md;\n\t\telse mi = md;\n\t}\n\tprintf(""%.10lf\\n"", (mi+mx)/2.);\n\treturn 0;\n}\n']","['binary search', 'implementation', 'math']",2500
https://codeforces.com//contest/930/problem/C,C. Teodor is not a liar ,Young Teodor enjoys drawing His favourite hobby is drawing segments with integer borders inside his huge segment One day Teodor noticed that picture he just drawn has one interesting feature there doesn t exist an integer point that belongs each of segments in the picture Having discovered this fact Teodor decided to share it with Sasha Sasha knows that Teodor likes to show off so he never trusts him Teodor wants to prove that he can be trusted sometimes so he decided to convince Sasha that there is no such integer point in his picture which belongs to each segment However Teodor is lazy person and neither wills to tell Sasha all coordinates of segments ends nor wills to tell him their amount so he suggested Sasha to ask him series of questions Given the integer point how many segments in Fedya s picture contain that point promising to tell correct answers for this questions Both boys are very busy studying and don t have much time so they ask you to find out how many questions can Sasha ask Teodor that having only answers on his questions Sasha can t be sure that Teodor isn t lying to him Note that Sasha doesn t know amount of segments in Teodor s picture Sure Sasha is smart person and never asks about same point twice ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 100001;\n\nint fen[MAXN];\nint fl[MAXN];\nint fr[MAXN];\nint c[MAXN];\n\nvoid init() {\n    memset(fen, 0, sizeof(fen));\n}\n\nint n, m;\n\nvoid upd(int x, int y) {\n    for (int i = x; i <= n; i |= (i + 1)) {\n        fen[i] = max(fen[i], y);\n    }\n}\n\nint gt(int x) {\n    int ans = 0;\n    for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n        ans = max(ans, fen[i]);\n    }\n\n    return ans;\n}\n\nint main() {\n#ifdef BZ\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        ++c[a];\n        --c[b + 1];\n    }\n\n    for (int i = 2; i <= m; ++i) {\n        c[i] += c[i - 1];\n    }\n\n    init();\n    for (int i = 1; i <= m; ++i) {\n        upd(c[i], fl[i] = (gt(c[i]) + 1));\n    }\n\n    init();\n    int ans = 0;\n    for (int i = m; i >= 1; --i) {\n        upd(c[i], fr[i] = (gt(c[i]) + 1));\n        ans = max(ans, fl[i] + fr[i] - 1);\n    }\n\n\n    cout << ans << ""\\n"";\n}']","['data structures', 'dp']",1900
https://codeforces.com//contest/346/problem/C,C. Number Transformation II,You are given a sequence of positive integers and two non negative integers and Your task is to transform into To do that you can perform the following moves subtract 1 from the current subtract mod from the current Operation mod means taking the remainder after division of number by number Now you want to know the minimum number of moves needed to transform into ,"['#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n//#pragma comment(linker,""/STACK:102400000,102400000"")\n\nint n;\nvector <int> xs;\nvector <int> nex_xs;\nint A, B;\n\nmap <int, int> occur;\n\nint MAIN()\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint t;\n\t\tcin >> t;\n\t\tif(!occur.count(t))\n\t\t\txs.push_back(t);\n\t\toccur[t] = 1;\n\t}\n\tcin >> A >> B;\n\tint ans = 0;\n\twhile(A != B)\n\t{\n\t\tnex_xs.clear();\n\t\tint bestA = A - 1;\n\t\tfor(int i = 0; i < xs.size(); i++)\n\t\t{\n\t\t\tint t = xs[i];\n\t\t\tint v = (A / t) * t;\n\t\t\tif(v >= B)\n\t\t\t{\n\t\t\t\tnex_xs.push_back(t);\n\t\t\t\tbestA = min(bestA, v);\n\t\t\t}\n\t\t}\n\t\tA = bestA;\n\t\txs = nex_xs;\n\t\tans ++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint main()\n{\n\t#ifdef LOCAL_TEST\n\t\tfreopen(""in.txt"", ""r"", stdin);\n\t\tfreopen(""out.txt"", ""w"", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\treturn MAIN();\n}\n']","['greedy', 'math']",2200
https://codeforces.com//contest/920/problem/D,D. Tanks,Petya sometimes has to water his field To water the field Petya needs a tank with exactly ml of water Petya has got tanks th of them initially containing ml of water The tanks are really large any of them can contain any amount of water no matter how large this amount is Also Petya has got a scoop that can contain up to ml of water initially the scoop is empty This scoop can be used to get some water from some tank and after that pour it all into some tank it is impossible to get water from multiple tanks without pouring it or leave some water in the scoop when pouring it When Petya tries to get some water from a tank he gets water where is the current volume of water in the tank Is it possible to obtain a tank with exactly ml of water using these operations If it is possible print a sequence of operations that allows to do it If there are multiple ways to obtain needed amount of water in some tank print any of them ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nbool dp[5050][5050];\nbool prv[5050][5050];\nint in[5050];\nint main() {\n\tint N, K, V, i, j;\n\tscanf(""%d %d %d"", &N, &K, &V);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in[i]);\n\n\tint s = 0;\n\tfor (i = 1; i <= N; i++) s += in[i];\n\tif (s < V) return !printf(""NO\\n"");\n\n\tdp[0][0] = true;\n\tfor (i = 1; i <= N; i++) {\n\t\tint x = in[i] % K;\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tif (!dp[i - 1][j]) continue;\n\t\t\tdp[i][j] = true;\n\t\t\tprv[i][j] = false;\n\n\t\t\tdp[i][(j + x) % K] = true;\n\t\t\tprv[i][(j + x) % K] = true;\n\t\t}\n\t}\n\n\tif (!dp[N][V%K]) return !printf(""NO\\n"");\n\n\tvector <int> Vl[2];\n\tint v = V%K;\n\tfor (i = N; i >= 1; i--) {\n\t\tint x = in[i] % K;\n\t\tif (prv[i][v]) {\n\t\t\tVl[1].push_back(i);\n\t\t\tv = (v - x + K) % K;\n\t\t}\n\t\telse Vl[0].push_back(i);\n\t}\n\tsort(all(Vl[0]));\n\tsort(all(Vl[1]));\n\n\tprintf(""YES\\n"");\n\tif (!Vl[0].empty()) {\n\t\tfor (i = 1; i < Vl[0].size(); i++) printf(""%d %d %d\\n"", 100000, Vl[0][i], Vl[0][0]);\n\t}\n\tif (!Vl[1].empty()) {\n\t\tfor (i = 1; i < Vl[1].size(); i++) printf(""%d %d %d\\n"", 100000, Vl[1][i], Vl[1][0]);\n\t}\n\n\ts = 0;\n\tfor (auto it : Vl[1]) s += in[it];\n\n\tint p0, p1;\n\tif (Vl[0].empty()) p0 = Vl[1][1], p1 = Vl[1][0];\n\telse if (Vl[1].empty()) p0 = Vl[0][0], p1 = Vl[0][1];\n\telse p0 = Vl[0][0], p1 = Vl[1][0];\n\n\tif (s > V) printf(""%d %d %d\\n"", (s - V) / K, p1, p0);\n\tif (s < V) printf(""%d %d %d\\n"", (V - s) / K, p0, p1);\n\treturn 0;\n}\n//*/']","['dp', 'greedy', 'implementation']",2400
https://codeforces.com//contest/1370/problem/E,E. Binary Subsequence Rotation,Naman has two binary strings s and t of length n a binary string is a string which only consists of the characters and He wants to convert s into t using the following operation as few times as possible In one operation he can choose any subsequence of s and rotate it clockwise once For example if s 1 textbf 1 101 textbf 00 he can choose a subsequence corresponding to indices 1 based 2 6 7 and rotate them clockwise The resulting string would then be s 1 textbf 0 101 textbf 10 A string a is said to be a subsequence of string b if a can be obtained from b by deleting some characters without changing the ordering of the remaining characters To perform a clockwise rotation on a sequence c of size k is to perform an operation which sets c 1 c k c 2 c 1 c 3 c 2 ldots c k c k 1 simultaneously Determine the minimum number of operations Naman has to perform to convert s into t or say that it is impossible ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nset < int > go[2];\n\nmain() {\n    //freopen(""input.txt"", ""r"", stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, cnt0 = 0, cnt1 = 0, ans = 0;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    string S = s, T = t;\n    sort(S.begin(), S.end());\n    sort(T.begin(), T.end());\n    if (S != T) {\n        cout << -1;\n        exit(0);\n    }\n    for (int i = 0; i < n; ++i) {\n        if (s[i] != t[i]) {\n            go[s[i] - \'0\'].insert(i);\n        }\n    }\n    while ((int)go[0].size() > 0 || (int)go[1].size() > 0) {\n        int start = n + 1, f;\n        if ((int)go[0].size() > 0) {\n            int d = (*go[0].begin());\n            if (d < start) start = d, f = 0;\n        }\n        if ((int)go[1].size() > 0) {\n            int d = (*go[1].begin());\n            if (d < start) start = d, f = 1;\n        }\n        ans++;\n        while (1) {\n            go[f].erase(start);\n            f = (f^1);\n            auto p = go[f].lower_bound(start);\n            if (p == go[f].end()) break;\n            start = (*p);\n        }\n    }\n    cout << ans << \'\\n\';\n    return 0;\n}\n\n\n']","['binary search', 'constructive algorithms', 'data structures', 'greedy']",2100
https://codeforces.com//contest/1380/problem/G,G. Circular Dungeon,You are creating a level for a video game The level consists of n rooms placed in a circle The rooms are numbered 1 through n Each room contains exactly one exit completing the j th room allows you to go the j 1 th room and completing the n th room allows you to go the 1 st room You are given the description of the multiset of n chests the i th chest has treasure value c i Each chest can be of one of two types regular chest when a player enters a room with this chest he grabs the treasure and proceeds to the next room mimic chest when a player enters a room with this chest the chest eats him alive and he loses The player starts in a random room with each room having an equal probability of being chosen The players earnings is equal to the total value of treasure chests he d collected before he lost You are allowed to choose the order the chests go into the rooms For each k from 1 to n place the chests into the rooms in such a way that each room contains one chest k chests are mimics the expected value of players earnings is possible Please note that for each k the placement is chosen independently It can be shown that it is in the form of frac P Q where P and Q are non negative integers and Q ne 0 Report the values of P cdot Q 1 pmod 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N; cin >> N;\n    vi C(N); F0R(i, N) cin >> C[i];\n\n    mi in = inv(mi(N));\n\n    sort(all(C)); reverse(all(C));\n    mi pre[N+1];\n    pre[0] = 0;\n    F0R(i, N) pre[i+1] = pre[i] + C[i];\n\n    FOR(K, 1, N+1) {\n        mi ans = 0;\n        for (int i = 0; i < N; i += K) {\n            ans += (i / K) * (pre[min(i+K, N)] - pre[i]);\n        }\n        ans *= in;\n        cout << ans << "" "";\n    }\n    cout << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['greedy', 'math', 'probabilities']",2600
https://codeforces.com//contest/1208/problem/G,G. Polygons,You are given two integers n and k You need to construct k regular polygons having same circumcircle with number of sides l between 3 and n You can rotate them to minimize the total number of distinct points on the circle Find the minimum number of such points ,"[""/**\n *    author:  tourist\n *    created: 25.08.2019 18:13:14       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  long long ans = (long long) 9e18;\n  for (int take2 = 0; take2 < 2; take2++) {\n    vector<int> phi(n + 1);\n    for (int i = 1; i <= n; i++) {\n      phi[i] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n      for (int j = i + i; j <= n; j += i) {\n        phi[j] -= phi[i];\n      }\n    }\n    if (!take2) {\n      for (int i = 4; i <= n; i += 2) {\n        phi[i] = (int) 1e9;\n      }\n    }\n    sort(phi.begin() + 3, phi.end());\n    long long cur = 1 + take2;\n    for (int i = 3; i <= k + 2; i++) {\n      cur += phi[i];\n    }\n    ans = min(ans, cur);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","['greedy', 'math', 'number theory']",2800
https://codeforces.com//contest/1073/problem/D,D. Berland Fair,XXI Berland Annual Fair is coming really soon Traditionally fair consists of n booths arranged in a circle The booths are numbered 1 through n clockwise with n being adjacent to 1 The i th booths sells some candies for the price of a i burles per item Each booth has an unlimited supply of candies Polycarp has decided to spend at most T burles at the fair However he has some plan in mind for his path across the booths at first he visits booth number 1 if he has enough burles to buy candy from the current booth then he buys it immediately then he proceeds to the next booth in the clockwise order regardless of if he bought a candy or not Polycarp s money is finite thus the process will end once he can no longer buy candy at any booth Calculate the number of candies Polycarp will buy ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct BIT {\n  vector<long long> dat;\n\n  BIT(int n) : dat(n + 1) {}\n\n  void update(int k, long long v) {\n    for (int i = k + 1; i < dat.size(); i += i & -i) {\n      dat[i] += v;\n    }\n  }\n  \n  long long query(int k) {\n    long long ans = 0;\n    for (int i = k; i > 0; i -= i & -i) {\n      ans += dat[i];\n    }\n    return ans;\n  }\n\n  long long query(int l, int r) {\n    return query(r) - query(l);\n  }\n};\n\nint main() {\n  int n;\n  long long T;\n  cin >> n >> T;\n  BIT bit0(n * 2);\n  BIT bit1(n * 2);\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", &a[i]);\n    bit0.update(i, 1);\n    bit0.update(i + n, 1);\n    bit1.update(i, a[i]);\n    bit1.update(i + n, a[i]);\n  }\n  int k = 0;\n  long long ans = 0;\n  int left = n;\n  while (left > 0) {\n    long long s = bit1.query(k, k + n);\n    if (s > T) {\n      int l = k;\n      int r = k + n;\n      while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (bit1.query(k, m) <= T) {\n          l = m;\n        } else {\n          r = m;\n        }\n      }\n      ans += bit0.query(k, l);\n      T -= bit1.query(k, l);\n      k = l % n;\n      bit0.update(k, -1);\n      bit0.update(k + n, -1);\n      bit1.update(k, -a[k]);\n      bit1.update(k + n, -a[k]);\n      left--;\n    } else {\n      ans += (T / s) * bit0.query(k, k + n);\n      T %= s;\n    }\n  }\n  cout << ans << endl;\n}\n\n']","['binary search', 'brute force', 'data structures', 'greedy']",1700
https://codeforces.com//contest/478/problem/A,A. Initial Bet,There are five people playing a game called Generosity Each person gives some non zero number of coins as an initial bet After all players make their bets of coins the following operation is repeated for several times a coin is passed from one player to some other player Your task is to write a program that can given the number of coins each player has at the end of the game determine the size of the initial bet or find out that such outcome of the game cannot be obtained for any positive number of coins in the initial bet ,"['#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nint x,sum,i;\n\nint main(){\n    sum=0;\n    for(i=0;i<5;i++){\n        cin>>x;\n        sum+=x;\n    }\n    if(sum%5==0&&sum)cout<<sum/5<<endl;\n    else cout<<-1<<endl;\n    return 0;\n}\n']",['implementation'],1100
https://codeforces.com//contest/429/problem/D,D. Tricky Function,Iahub and Sorin are the best competitive programmers in their town However they can t both qualify to an important contest The selection will be made with the help of a single problem Blatnatalag a friend of Iahub managed to get hold of the problem before the contest Because he wants to make sure Iahub will be the one qualified he tells Iahub the following task You re given an 1 based array with elements Let s define function as Function g is calculated by the following pseudo code int g int i int j int sum 0 for int k min i j 1 k max i j k k 1 sum sum a k return sum Find a value Probably by now Iahub already figured out the solution to this problem Can you ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint a[100500];\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf(""%d"", &n);\n\tforn(i, n)\n\t\tscanf(""%d"", &a[i]);\n\tint ans = 1 + a[1] * a[1];\n\tfor (int d = 1; d < n; d++) {\n\t\tif (d * d >= ans) break;\n\t\tint s = 0;\n\t\tint q = inf;\n\t\tint l = 1;\n\t\tint r = d + 1;\n\t\tforn (j, d)\n\t\t\ts += a[j + 1];\n\t\tq = min(q, abs(s));\n\t\twhile (r < n) {\n\t\t\ts -= a[l];\n\t\t\ts += a[r];\n\t\t\tl++;\n\t\t\tr++;\n\t\t\tq = min(q, abs(s));\n\t\t}\n\t\tif ((int64)q * q + (int64)d * d < ans)\n\t\t\tans = q * q + d * d;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","['data structures', 'divide and conquer', 'geometry']",2200
https://codeforces.com//contest/1445/problem/B,B. Elimination,There is a famous olympiad which has more than a hundred participants The Olympiad consists of two stages the elimination stage and the final stage At least a hundred participants will advance to the final stage The elimination stage in turn consists of two contests A result of the elimination stage is the total score in two contests but unfortunately the jury lost the final standings and has only standings for the first and for the second contest separately In each contest the participants are ranked by their point score in non increasing order When two participants have a tie earned the same score they are ranked by their passport number in accordance with local regulations all passport numbers are distinct In the first contest the participant on the 100 th place scored a points Also the jury checked all participants from the 1 st to the 100 th place inclusive in the first contest and found out that all of them have at least b points in the second contest Similarly for the second contest the participant on the 100 th place has c points And the jury checked that all the participants from the 1 st to the 100 th place inclusive have at least d points in the first contest After two contests all participants are ranked by their total score in two contests in non increasing order When participants have the same total score tie breaking with passport numbers is used The to qualify to the final stage is the total score of the participant on the 100 th place Given integers a b c d please help the jury determine the smallest possible value of the cutoff score ,"[""#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nint T;\n\nint a, b, c, d;\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> T;\n\n    while (T--) {\n        cin >> a >> b >> c >> d;\n\n        cout << max(a + b, c + d) << '\\n';\n    }\n}\n""]","['greedy', 'math']",900
https://codeforces.com//contest/498/problem/B,B. Name That Tune,It turns out that you are a great fan of rock band AC PE Peter learned that and started the following game he plays the first song of the list of songs of the group and you have to find out the name of the song After you tell the song name Peter immediately plays the following song in order and so on The th song of AC PE has its recognizability This means that if the song has not yet been recognized by you you listen to it for exactly one more second and with probability of percent you recognize it and tell it s name Otherwise you continue listening it Note that you can only try to guess it only when it is integer number of seconds after the moment the song starts playing In all AC PE songs the first words of chorus are the same as the title so when you ve heard the first seconds of th song and its chorus starts you immediately guess its name for sure For example in the song Highway To Red the chorus sounds pretty late but the song has high recognizability In the song Back In Blue on the other hand the words from the title sound close to the beginning of the song but it s hard to name it before hearing those words You can name both of these songs during a few more first seconds Determine the expected number songs of you will recognize if the game lasts for exactly seconds i e you can make the last guess on the second after that the game stops ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n\n  int n, maxt;\n  while (scanf(""%d%d"", &n, &maxt) == 2) {\n    vector<ld> ps(n);\n    vi ts(n);\n    forn (i, n) {\n      int p;\n      scanf(""%d%d"", &p, &ts[i]);\n      ps[i] = p / 100.0;\n    }\n\n    vector<ld> cdyn(maxt + 1, 0);\n    cdyn[maxt] = 1;\n\n    vector<ld> ndyn(maxt + 1, 0);\n    vector<ld> toadd(maxt + 2, 0);\n\n    ld ans = 0;\n    forn (id, n) {\n      fill(ndyn.begin(), ndyn.end(), 0);\n      fill(toadd.begin(), toadd.end(), 0);\n\n/*      ld toCur = 1;\n      for (int was = 1; was < ts[id]; was++) {\n        ld cprob = toCur * ps[id];\n\n        for (int olt = was; olt <= maxt; olt++) {\n          ndyn[olt - was] += cprob * cdyn[olt];\n        }\n\n        toCur *= 1 - ps[id];\n      }*/\n      ld toCur = 1;\n      for (int was = 1; was < ts[id]; was++) toCur *= 1 - ps[id];\n      for (int olt = 1; olt <= maxt; olt++) {\n        toadd[olt - 1] += ps[id] * cdyn[olt];\n        if (olt >= ts[id]) {\n          toadd[olt - ts[id]] -= toCur * ps[id] * cdyn[olt];\n        }\n      }\n      \n      for (int i = maxt; i >= 0; i--) {\n        ndyn[i] = toadd[i];\n        if (i < maxt) ndyn[i] += ndyn[i + 1] * (1 - ps[id]);\n      }\n      for (int olt = ts[id]; olt <= maxt; olt++) {\n        ndyn[olt - ts[id]] += toCur * cdyn[olt];\n      }\n\n      {\n        ld csum = 0;\n        for (ld x : ndyn) csum += x;\n        ans += csum;\n      }\n      cdyn.swap(ndyn);\n    }\n    printf(""%.18f\\n"", (double)ans);\n  }\n\n  return 0;\n}\n']","['dp', 'probabilities', 'two pointers']",2400
https://codeforces.com//contest/497/problem/C,C. Distributing Parts ,You are an assistant director in a new musical play The play consists of musical parts each part must be performed by exactly one actor After the casting the director chose actors who can take part in the play Your task is to assign the parts to actors However there are several limitations First each actor has a certain voice range and there are some parts that he cannot sing Formally there are two integers for each actor and the pitch of the lowest and the highest note that the actor can sing There also are two integers for each part and the pitch of the lowest and the highest notes that are present in the part The th actor can perform the th part if and only if i e each note of the part is in the actor s voice range According to the contract the th actor can perform at most parts Besides you are allowed not to give any part to some actors then they take part in crowd scenes The rehearsal starts in two hours and you need to do the assignment quickly ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\nconst int M = 100000;\n\nstruct Input {\n\tint n;\n\tint a[N], b[N];\n\tint m;\n\tint c[M], d[M], k[M];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d%d"", &a[i], &b[i]);\n\t\t}\n\t\tcin >> m;\n\t\tforn (i, m) {\n\t\t\tscanf(""%d%d%d"", &c[i], &d[i], &k[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tbool res;\n\tint ans[N];\n\t\n\tvoid write () {\n\t\tif (!res) {\n\t\t\tputs(""NO"");\n\t\t\treturn;\n\t\t}\n\t\tputs(""YES"");\n\t\tforn (i, n) {\n\t\t\tif (i) {\n\t\t\t\tprintf("" "");\n\t\t\t}\n\t\t\tprintf(""%d"", ans[i] + 1);\n\t\t}\n\t\tputs("""");\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tvoid solve () {\n\t\tve<pa<int, pii> > q;\n\t\tforn (i, n) {\n\t\t\tq.pb(mp(b[i], mp(0, i)));\n\t\t}\n\t\tforn (i, m) {\n\t\t\tq.pb(mp(d[i], mp(1, i)));\n\t\t}\n\t\tsort(all(q));\n\t\t\n\t\tset<pii> s;\n\t\tforn (i, sz(q)) {\n\t\t\tif (q[i].sc.fs == 0) {\n\t\t\t\ts.insert(mp(-a[q[i].sc.sc], q[i].sc.sc));\n\t\t\t} else {\n\t\t\t\tforn (j, k[q[i].sc.sc]) {\n\t\t\t\t\tauto it = s.upper_bound(mp(-c[q[i].sc.sc], N));\n\t\t\t\t\tif (it == s.begin()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t--it;\n\t\t\t\t\tans[it->sc] = q[i].sc.sc;\n\t\t\t\t\ts.erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = s.empty();\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n']","['data structures', 'greedy', 'implementation', 'sortings', 'two pointers']",2100
https://codeforces.com//contest/1617/problem/B,B. GCD Problem,Given a positive integer n Find three positive integers a b c such that a b c n and operatorname gcd a b c where operatorname gcd x y denotes the greatest common divisor GCD of integers x and y ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\t[](){\n\t\t\tint n;\n\t\t\tcin >> n;\n\t\t\tfor (int i = 2; i <= n; i += 1)\n\t\t\t\tif (gcd(n - i - 1, i) == 1) {\n\t\t\t\t\tcout << i << "" "" << n - 1 - i << "" 1\\n"";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}();\n\t}\n\treturn 0;\n}']","['brute force', 'constructive algorithms', 'math', 'number theory']",900
https://codeforces.com//contest/371/problem/E,E. Subway Innovation,Berland is going through tough times the dirt price has dropped and that is a blow to the country s economy Everybody knows that Berland is the top world dirt exporter The President of Berland was forced to leave only of the currently existing subway stations The subway stations are located on a straight line one after another the trains consecutively visit the stations as they move You can assume that the stations are on the axis the th station is at point with coordinate In such case the distance between stations and is calculated by a simple formula Currently the Ministry of Transport is choosing which stations to close and which ones to leave Obviously the residents of the capital won t be too enthusiastic about the innovation so it was decided to show the best side to the people The Ministry of Transport wants to choose such stations that minimize the average commute time in the subway Assuming that the train speed is constant it is a fixed value the average commute time in the subway is calculated as the sum of pairwise distances between stations divided by the number of pairs that is and divided by the speed of the train Help the Minister of Transport to solve this difficult problem Write a program that given the location of the stations selects such stations that the average commute time in the subway is minimized ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname """"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define sz size()\nconst int N = 400500;\nstruct node {\n\tll x, id;\n}a[N];\nbool cmp (node a, node b) {\n\treturn a.x < b.x;\n}\nll n, k;\n\nll d[N];\n\nvector <int> ans;\n\nint main ()\n{\t\n\t#ifndef ONLINE_JUDGE\n\tfreopen (fname""in"",""r"",stdin);\n\tfreopen (fname""out"",""w"",stdout);\n\t#endif\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tcin >> a[i].x;\n\t\ta[i].id = i;\n\t}\n\n\tcin >> k;\n\n\tsort(a + 1, a + 1 + n, &cmp);\n\n\tll mn = 0, id = k, sum = 0, now = 0;\n\n\tfor (int i = 1; i <= k; i ++ ) {\n\t\tmn += a[i].x * 1ll * (i - 1) - sum;\n\t\tsum += a[i].x;\n\t}\n\n\tnow = mn;\n\n\tfor (int i = k + 1; i <= n; i ++ ) {\n\t\tsum -= a[i - k].x;\n\t\tnow -= (sum - a[i - k].x * (k - 1));\n\t\tnow += (a[i].x * (k - 1) - sum);\n\t\tsum += a[i].x;\n\t\tif (mn > now) {\n\t\t\tmn = now;\n\t\t\tid = i;\n\t\t}\n\t}\n\n\tfor (int i = id; i >= id - k + 1; i -- ) ans.pb(a[i].id);\n\n\tsort(ans.begin(), ans.end());\n\n\tfor (int i = 0; i < ans.size(); i ++ ) cout << ans[i] << "" "";\n\n\treturn 0;\n}']","['greedy', 'math', 'two pointers']",2000
https://codeforces.com//contest/195/problem/E,E. Building Forest,An is an acyclic weighted digraph in which from each vertex at most one edge goes The of vertex of an oriented weighted forest is a vertex from which no edge goes and which can be reached from vertex moving along the edges of the weighted oriented forest We denote the root of vertex as The of vertex is the sum of weights of paths passing from the vertex to its root Let s denote the depth of the vertex as Let s consider the process of constructing a weighted directed forest Initially the forest does not contain vertices Vertices are added sequentially one by one Overall there are performed operations of adding The th adding operation is described by a set of numbers and means that we should add vertex number and edges to the graph an edge from vertex to vertex with weight an edge from vertex to vertex with weight and so on If then only vertex is added to the graph there are no added edges Your task is like this given the operations of adding vertices calculate the sum of the weights of all edges of the forest resulting after the application of all defined operations modulo ,"['#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vll;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\n#define MOD 1000000007\n\nstatic pair<int, ll> find(vi &parent, vll &weight, int x)\n{\n    int y = x;\n    ll w = 0;\n    while (parent[y] >= 0)\n    {\n        w = (w + weight[y]) % MOD;\n        y = parent[y];\n    }\n\n    ll ws = 0;\n    while (parent[x] >= 0)\n    {\n        int n = parent[x];\n        ll wn = weight[x];\n\n        parent[x] = y;\n        weight[x] = (w - ws) % MOD;\n        ws = (ws + wn) % MOD;\n        x = n;\n    }\n\n    return make_pair(y, w);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N;\n    vi parent(N, -1);\n    vll weight(N, 0);\n    ll ans = 0;\n    for (int i = 0; i < N; i++)\n    {\n        int K;\n        cin >> K;\n        for (int j = 0; j < K; j++)\n        {\n            int v;\n            ll x;\n            cin >> v >> x;\n            v--;\n            pair<int, ll> root = find(parent, weight, v);\n            ll w = (root.second + x) % MOD;\n            ans = (ans + w) % MOD;\n            parent[root.first] = i;\n            weight[root.first] = w;\n            cerr << i << \' \' << root.first << \' \' << w << \'\\n\';\n        }\n    }\n    ans %= MOD;\n    if (ans < 0)\n        ans += MOD;\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']","['data structures', 'dsu', 'graphs']",2000
https://codeforces.com//contest/401/problem/C,C. Team,Now it s time of Olympiads Vanya and Egor decided to make his own team to take part in a programming Olympiad They ve been best friends ever since primary school and hopefully that can somehow help them in teamwork For each team Olympiad Vanya takes his play cards with numbers He takes only the cards containing numbers 1 and 0 The boys are very superstitious They think that they can do well at the Olympiad if they begin with laying the cards in a row so that there wouldn t be a pair of any side adjacent cards with zeroes in a row there wouldn t be a group of three consecutive cards containing numbers one Today Vanya brought cards with zeroes and cards with numbers one The number of cards was so much that the friends do not know how to put all those cards in the described way Help them find the required arrangement of the cards or else tell the guys that it is impossible to arrange cards in such a way ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nint n,m,a,b;\n\nint main()\n{\n    scanf(""%d%d"",&n,&m);\n    if(m<n-1||(n+1)*2<m)puts(""-1"");\n    else if(m==n-1)\n    {\n        putchar(\'0\');\n        for(int i=0;i<m;i++)\n        {\n            putchar(\'1\');\n            putchar(\'0\');\n        }\n    }\n    else if(n==m)\n    {\n        for(int i=0;i<m;i++)\n        {\n            putchar(\'1\');\n            putchar(\'0\');\n        }\n    }\n    else\n    {\n        a=n+1;\n        b=m-a;\n        if(a&&b)printf(""11""),a--,b--;\n        else printf(""1""),a--;\n        for(int i=0;i<n;i++)\n        {\n            putchar(\'0\');\n            if(a&&b)printf(""11""),a--,b--;\n            else printf(""1""),a--;\n        }\n    }\n    return 0;\n}\n']","['constructive algorithms', 'greedy', 'implementation']",1400
https://codeforces.com//contest/1825/problem/B,B. LuoTianyi and the Table,LuoTianyi gave an array b of n cdot m integers She asks you to construct a table a of size n times m filled with these n cdot m numbers and each element of the array must be used Also she asked you to maximize the following value This means that we consider n cdot m subtables with the upper left corner in 1 1 and the bottom right corner in i j 1 le i le n 1 le j le m for each such subtable calculate the difference of the maximum and minimum elements in it then sum up all these differences You should maximize the resulting sum Help her find the maximal possible value you don t need to reconstruct the table itself ,"['#pragma GCC optimize(""Ofast,unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")\n#include<bits/stdc++.h>\n#define int long long\nconst int N=2e5+5,M=305;\nusing namespace std;\nint n,m,b[N],sum;\nvoid solve()\n{\n\tcin>>n>>m;sum=0;if(n>m)swap(n,m);\n\tfor(int i=1;i<=n*m;i++)cin>>b[i];\n\tsort(b+1,b+n*m+1);\n\tint maxn=b[n*m],maxn2=b[n*m-1];\n\tsum=max((maxn-b[2])*(n-1)+(n*m-n)*(maxn-b[1]),\n\t\t\t(maxn2-b[1])*(n-1)+(n*m-n)*(maxn-b[1]));\n\tcout<<sum<<\'\\n\';\n}\nint tt;\nsigned main()\n{\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\ttt=1;\n\tcin>>tt;\n\twhile(tt--)solve();\n}']","['greedy', 'math']",1000
https://codeforces.com//contest/218/problem/B,B. Airport,Lolek and Bolek are about to travel abroad by plane The local airport has a special Choose Your Plane offer The offer s conditions are as follows it is up to a passenger to choose a plane to fly on if the chosen plane has empty seats at the given moment then the ticket for such a plane costs zlotys units of Polish currency The only ticket office of the airport already has a queue of passengers in front of it Lolek and Bolek have not stood in the queue yet but they are already wondering what is the maximum and the minimum number of zlotys the airport administration can earn if all passengers buy tickets according to the conditions of this offer The passengers buy tickets in turn the first person in the queue goes first then goes the second one and so on up to th person ,"['/*\n * =====================================================================================\n *\n *         Author:  KissBuaa.DS(AC)\n *        Company:  BUAA-ACMICPC-Group\n *\n * =====================================================================================\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n//#include <stdbool.h>\n#include <math.h>\n#define LL long long\n#define CLR(x) memset(x,0,sizeof(x))\n#define typec double\n#define sqr(x) ((x)*(x))\n#define abs(x) ((x)<0?(-(x)):(x))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define PI acos(-1.0)\n#define lowbit(x) ((x)&(-(x)))\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\n#define inf 100000000\n//For C++\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <list>\n#include <iostream>\nusing namespace std;\n#define N 2010\nint A[N],hehe[N];\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    for (int i=1;i<=m;i++)\n    {\n      cin >> A[i];\n      hehe[i] = A[i];\n    }\n    int now;\n    int ans1=0,ans2=0;\n    for (int i=1;i<=n;i++)\n    {\n        int big =-1;\n        for (int j=1;j<=m;j++)\n        {\n            if (big<A[j] && A[j]>0)\n            {\n                big  = A[j];\n                now = j;\n            }\n        }\n        if (big>0)\n        {\n            ans1+=big;\n            A[now]--;\n        }\n    }\n    for (int i=1;i<=n;i++)\n    {\n        int small = 999999999;\n        for(int j=1;j<=m;j++)\n            if (small>hehe[j] && hehe[j]>0)\n            {\n                small = hehe[j];\n                now = j;\n            }\n        if (small!=999999999)\n        {\n            ans2+=small;\n            hehe[now]--;\n        }\n    }\n    cout << ans1 << "" "" << ans2 <<endl;\n\n    return 0;\n}\n']",['implementation'],1100
https://codeforces.com//contest/1553/problem/F,F. Pairwise Modulo,You have an array a consisting of n distinct positive integers numbered from 1 to n Define p k as p k sum 1 le i j le k a i bmod a j where x bmod y denotes the remainder when x is divided by y You have to find and print p 1 p 2 ldots p n ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 3e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: range sum queries and point updates for $D$ dimensions\n * Source: https://codeforces.com/blog/entry/64914\n * Verification: SPOJ matsum\n * Usage: \\texttt{BIT<int,10,10>} gives 2D BIT\n * Time: O((\\log N)^D)\n */\n\ntemplate <class T, int ...Ns> struct BIT {\n\tT val{}; void upd(T v) { val += v; }\n\tT query() { return val; }\n};\ntemplate <class T, int N, int... Ns> struct BIT<T, N, Ns...> {\n\tBIT<T,Ns...> bit[N+1];\n\ttemplate<typename... Args> void upd(int pos, Args... args) { assert(pos > 0);\n\t\tfor (; pos<=N; pos+=pos&-pos) bit[pos].upd(args...); }\n\ttemplate<typename... Args> T sum(int r, Args... args) {\n\t\tT res=0; for (;r;r-=r&-r) res += bit[r].query(args...); \n\t\treturn res; }\n\ttemplate<typename... Args> T query(int l, int r, Args... \n\t\targs) { return sum(r,args...)-sum(l-1,args...); }\n}; \n// template<class T, int N> int get_kth(const BIT<T,N>& bit, T des) { \n// \tassert(des > 0);\n// \tint ind = 0;\n// \tfor (int i = 1<<bits(N); i; i /= 2)\n// \t\tif (ind+i <= N && bit.bit[ind+i].val < des)\n// \t\t\tdes -= bit.bit[ind += i].val;\n// \tassert(ind < N); return ind+1;\n// }\n\nBIT<ll,MX> sub, num;\nint N;\n\nint main() {\n\tsetIO();\n\tre(N);\n\tvl A(N); re(A);\n\tll ans = 0, prefix_sum = 0;\n\tF0R(i,N) {\n\t\t// dbg(""??"",i,A[i],prefix_sum,ans);\n\t\tans += A[i]*i;\n\t\tans += prefix_sum; prefix_sum += A[i];\n\n\t\t// dbg(""BEFORE ANS"",i,ans);\n\t\tfor (ll cur = A[i]; cur < MX; cur += A[i]) {\n\t\t\tll p = i-num.sum(cur-1); // how many at least cur\n\t\t\tans -= p*A[i];\n\t\t}\n\n\t\t// dbg(""END ANS"",i,ans,sub.sum(A[i]));\n\t\tans -= sub.sum(A[i]); // OK\n\t\tnum.upd(A[i],1); // OK\n\t\tfor (int cur = A[i]; cur < MX; cur += A[i]) sub.upd(cur,A[i]);\n\t\t// A[i]%x\n\t\tpr(ans,\' \');\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['data structures', 'math']",2300
https://codeforces.com//contest/1095/problem/F,F. Make It Connected,You are given an undirected graph consisting of n vertices A number is written on each vertex the number on vertex i is a i Initially there are no edges in the graph You may add some edges to this graph but you have to pay for them The cost of adding an edge between vertices x and y is a x a y coins There are also m special offers each of them is denoted by three numbers x y and w and means that you can add an edge connecting vertices x and y and pay w coins for it You don t have to use special offers if there is a pair of vertices x and y that has a special offer associated with it you still may connect these two vertices paying a x a y coins for it What is the minimum number of coins you have to spend to make the graph connected Recall that a graph is connected if it s possible to get from any vertex to any other vertex using only the edges belonging to this graph ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint par[200010];\nint root(int v){return par[v] < 0 ? v : (par[v] = root(par[v]));}\n\nint merge(int x,int y){\n    if((x = root(x)) == (y = root(y))) return 0 ;\n\tif(par[y] < par[x])\tswap(x, y);\n\tpar[x] += par[y];\n\tpar[y] = x;\n\treturn 1;\n}\n\n\nint main(){\n\tfast_io;\n\tfor (int i = 0; i < 200010; ++i)\n\t{\n\t\tpar[i]=-1;\n\t}\n\tint n,m;\n\tcin>>n>>m;\n\tvector<pair<ll,pair<int,int> > >edge;\n\tpair<ll,int> a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i].first;\n\t\ta[i].second=i+1;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tll x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tedge.push_back({z,{x,y}});\n\t}\n\tsort(a,a+n);\n\tfo(i,1,n-1){\n\t\tedge.push_back({a[i].first+a[0].first,{a[i].second,a[0].second}});\n\t}\n\tsort(edge.begin(), edge.end());\n\tll ans=0;\n\tfor(auto i:edge){\n\t\tint x=i.second.first;\n\t\tint y=i.second.second;\n\t\tll w=i.first;\n\t\tif(merge(x,y)){\n\t\t\tans+=w;\n\t\t}\n\t}\n\tshow(ans);\n\treturn 0;\n}']","['dsu', 'graphs', 'greedy']",1900
https://codeforces.com//contest/1163/problem/A,A. Eating Soup,What the cats do when they unite Right they have a party Since they wanted to have as much fun as possible they invited all their friends Now n cats are at the party sitting in a circle and eating soup The rules are simple anyone having finished their soup leaves the circle Katie suddenly notices that whenever a cat leaves the place where she was sitting becomes an empty space which means the circle is divided into smaller continuous groups of cats sitting next to each other At the moment Katie observes there are m cats who left the circle This raises a question for Katie what is the maximum possible number of groups the circle is divided into at the moment Could you help her with this curiosity You can see the examples and their descriptions with pictures in the Note section ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\n\nint main() {\n\tcin >> n >> m;\n\tif (!m) cout << 1 << endl;\n\telse if (m <= n / 2) cout << m << endl;\n\telse cout << n - m << endl;\n\treturn 0;\n}']","['greedy', 'math']",900
https://codeforces.com//contest/6/problem/E,E. Exposition,There are several days left before the fiftieth birthday of a famous Berland s writer Berlbury In this connection the local library decided to make an exposition of the works of this famous science fiction writer It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period It is obvious that if the books differ much in size the visitors will not like it That was why the organizers came to the opinion that the difference between the highest and the lowest books in the exposition should be not more than millimeters The library has volumes of books by Berlbury arranged in chronological order of their appearance The height of each book in millimeters is know it is As Berlbury is highly respected in the city the organizers want to include into the exposition as many books as possible and to find out what periods of his creative work they will manage to cover You are asked to help the organizers cope with this hard task ,"['#include <cstdio>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int N = 100*1001;\nint n,k,h[N],e[N];\n\nmultiset<int> s;\n\nbool ok() {\n    if (s.empty()) return true;\n    return ( (*s.rbegin())-(*s.begin()) <= k );\n}\n\nint main() {\n    scanf(""%d%d"",&n,&k);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&h[i]);\n    for(int i=0;i<n;i++) {\n        if (i==0) e[i]=0; else e[i]=e[i-1];\n        while(e[i]<n && ok()) {\n            s.insert(h[e[i]]);\n            e[i]++;\n        }\n        if (!ok()) {\n            e[i]--;\n            s.erase(s.find(h[e[i]]));\n        }\n        s.erase(s.find(h[i]));\n    }\n   // for(int i=0;i<n;i++) printf(""%d\\n"",e[i]);\n    int best = 1;\n    for(int i=0;i<n;i++) best=max(best,e[i]-i);\n    int c=0;\n    for(int i=0;i<n;i++) if (e[i]-i==best) c++;\n    printf(""%d %d\\n"",best,c);\n    for(int i=0;i<n;i++)\n        if (e[i]-i==best) printf(""%d %d\\n"",i+1,e[i]);\n    return 0;\n}\n\n']","['binary search', 'data structures', 'dsu', 'trees', 'two pointers']",1900
https://codeforces.com//contest/385/problem/B,B. Bear and Strings,The bear has a string record is the string s length consisting of lowercase English letters The bear wants to count the number of such pairs of indices that string contains at least one string as a substring String contains string if there is such index that Help the bear cope with the given problem ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar str[5555];\nint n;\n\nint main() {\n    scanf(""%s"", str);\n    n = strlen(str);\n    int ans = 0, max_i = -1;\n    for (int i = 0; i < n; ++ i) {\n        if (i >= 3 && str[i - 3] == \'b\' && str[i - 2] == \'e\' && str[i - 1] == \'a\' && str[i] == \'r\') max_i = i - 3;\n        ans += max_i + 1;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","['brute force', 'greedy', 'implementation', 'math', 'strings']",1200
https://codeforces.com//contest/1654/problem/C,C. Alice and the Cake,Alice has a cake and she is going to cut it She will perform the following operation n 1 times choose a piece of the cake initially the cake is all one piece with weight w ge 2 and cut it into two smaller pieces of weight lfloor frac w 2 rfloor and lceil frac w 2 rceil lfloor x rfloor and lceil x rceil denote floor and ceiling functions respectively After cutting the cake in n pieces she will line up these n pieces on a table in an arbitrary order Let a i be the weight of the i th piece in the line You are given the array a Determine whether there exists an initial weight and sequence of operations which results in a ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<long long> a(n);\n\tgenerate(all(a), nxt);\n\tlong long s = accumulate(all(a), 0ll);\n\tmultiset<long long> S(all(a));\n\tvector<long long> cur = {s};\n\tint rem = n - 1;\n\twhile (!cur.empty()) {\n\t\tauto x = cur.back();\n\t\tcur.pop_back();\n\t\tif (auto it = S.find(x); it != S.end()) {\n\t\t\tS.erase(it);\n\t\t} else if (rem == 0 || x == 1) {\n\t\t\tcout << ""No\\n"";\n\t\t\treturn;\n\t\t} else {\n\t\t\tcur.push_back(x / 2);\n\t\t\tcur.push_back((x + 1) / 2);\n\t\t\t--rem;\n\t\t}\n\t}\n\tcout << ""Yes\\n"";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","['data structures', 'greedy', 'implementation', 'sortings']",1400
https://codeforces.com//contest/1848/problem/E,E. Vika and Stone Skipping,In Vika s hometown Vladivostok there is a beautiful sea Often you can see kids skimming stones This is the process of throwing a stone into the sea at a small angle causing it to fly far and bounce several times off the water surface Vika has skimmed stones many times and knows that if you throw a stone from the shore perpendicular to the coastline with a force of f it will first touch the water at a distance of f from the shore then bounce off and touch the water again at a distance of f 1 from the previous point of contact The stone will continue to fly in a straight line reducing the distances between the points where it touches the water until it falls into the sea Formally the points at which the stone touches the water surface will have the following coordinates f f f 1 f f 1 f 2 f f 1 f 2 ldots 1 assuming that 0 is the coordinate of the shoreline Once while walking along the embankment of Vladivostok in the evening Vika saw a group of guys skipping stones across the sea launching them from the same point with different forces She became interested in what is the maximum number of guys who can launch a stone with their force f i so that all f i are and all n stones touched the water at the point with the coordinate x assuming that 0 is the coordinate of the shoreline After thinking a little Vika answered her question After that she began to analyze how the answer to her question would change if she multiplied the coordinate x by some positive integers x 1 x 2 x q which she picked for analysis Vika finds it difficult to cope with such analysis on her own so she turned to you for help Formally Vika is interested in the answer to her question for the coordinates X 1 x cdot x 1 X 2 X 1 cdot x 2 X q X q 1 cdot x q Since the answer for such coordinates can be quite large find it modulo M ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int N = 1 << 22;\n\nvector<int> pr;\nint lpd[N], cnt[N], inv[N], cnt2;\nint x, q, mod;\nint mul(int x, int y) {return ((1ll * x) * y) % mod;}\nint Pow(int x, int y) {int res = 1; for (; y; x = mul(x, x), y >>= 1) if (y & 1) res = mul(res, x); return res;}\n\nint val, zero;\n\nvoid ins(int p) {\n    if (p == 2) {\n        cnt2++;\n        return;\n    }\n    int val2 = 1, zero2 = 0;\n    int tmp = cnt[p] + 1;\n    while (tmp % mod == 0) tmp /= mod, zero2++;\n    val2 = tmp % mod;\n    val = mul(val, inv[val2]), zero -= zero2;\n    cnt[p]++;\n    tmp = cnt[p] + 1;\n    val2 = 1, zero2 = 0;\n    while (tmp % mod == 0) tmp /= mod, zero2++;\n    val2 = tmp % mod;\n    val = mul(val, val2), zero += zero2;\n}\n\nvoid frank() {\n    memset(lpd, -1, sizeof lpd);\n    for (int i = 2; i < N; ++i) {\n        if (lpd[i] == -1) lpd[i] = i, pr.pb(i);\n        for (auto p: pr) {\n            if (p * i >= N) break;\n            lpd[p * i] = p;\n            if (i % p == 0) break;\n        }\n    }\n    cin >> x >> q >> mod;\n    inv[1] = 1;\n    for (int i = 2; i < N; ++i) inv[i] = mul(inv[mod % i], mod - mod / i);\n    val = 1, zero = 0;\n    for (auto p: pr) {\n        if (p * p > x) break;\n        while (x % p == 0) {\n            ins(p);\n            x /= p;\n        }\n    }\n    if (x >= N) val = mul(val, 2);\n    else if(x > 1) ins(x);\n    while (q--) {\n        cin >> x;\n        while (x > 1) {\n            int p = lpd[x];\n            ins(p);\n            x /= p;\n        }\n        cout << (zero ? 0 : val) << ""\\n"";\n    }\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while (t--) {\n        frank();\n    }\n}']","['brute force', 'implementation', 'math', 'number theory']",2600
https://codeforces.com//contest/1608/problem/G,G. Alphabetic Tree,You are given m strings and a tree on n nodes Each edge has some letter written on it You have to answer q queries Each query is described by 4 integers u v l and r The answer to the query is the total number of occurrences of str u v in strings with indices from l to r str u v is defined as the string that is made by concatenating letters written on the edges on the shortest path from u to v in order that they are traversed ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//yosupo\n//TKPPC G\nstruct SA{\n\tint n;\n\tvi sa,as,lcp;\n\tSA(){}\n\ttemplate<class t> SA(t s):n(s.size()),sa(n),as(n),lcp(n-1){\n\t\trep(i,n)sa[i]=n-1-i;\n\t\tstable_sort(all(sa),[&](int a,int b){return s[a]<s[b];});\n\t\tvi c(n);\n\t\trep(i,n)c[i]=s[i];\n\t\tfor(int w=1;w<n;w*=2){\n\t\t\tvi d(c);\n\t\t\trep(i,n){\n\t\t\t\tif(i&&sa[i-1]+w<n&&d[sa[i-1]]==d[sa[i]]&&d[sa[i-1]+w/2]==d[sa[i]+w/2])\n\t\t\t\t\tc[sa[i]]=c[sa[i-1]];\n\t\t\t\telse\n\t\t\t\t\tc[sa[i]]=i;\n\t\t\t}\n\t\t\tvi e(sa),f(n);\n\t\t\tiota(all(f),0);\n\t\t\trep(i,n){\n\t\t\t\tint j=e[i]-w;\n\t\t\t\tif(j>=0)sa[f[c[j]]++]=j;\n\t\t\t}\n\t\t}\n\t\t//as\n\t\trep(i,n)as[sa[i]]=i;\n\t\t//lcp\n\t\tint w=0;\n\t\tfor(auto i:as){\n\t\t\tif(w)w--;\n\t\t\tif(i<n-1){\n\t\t\t\twhile(max(sa[i],sa[i+1])+w<n&&s[sa[i]+w]==s[sa[i+1]+w])w++;\n\t\t\t\tlcp[i]=w;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//CF530F\n//returns the suffix tree\n//the i-th (0<=i<=n-1) element corresponds to the lexicographically i-th suffix\nstruct ste{\n\tint to,l,r;\n\toperator int()const{return to;}\n};\nostream&operator<<(ostream&os,const ste&a){\n\treturn os<<""ste{""<<a.to<<"",[""<<a.l<<"",""<<a.r<<""]}"";\n}\npair<vvc<ste>,int> stree(const SA&sa){\n\tint n=sa.n,s=n*2-1;\n\tvi len(s);\n\trep(i,n)len[i]=n-sa.sa[i];\n\trep(i,n-1)len[i+n]=sa.lcp[i];\n\tvi idx(n-1);\n\tiota(all(idx),n);\n\tstable_sort(all(idx),[&](int a,int b){return len[a]>len[b];});\n\tunionfind uf(s);\n\tvi par(s,-1),c(s,-1);\n\trep(i,n)c[i]=sa.sa[i];\n\tfor(auto i:idx){\n\t\tint a=uf.find(i-n),b=uf.find(i-n+1);\n\t\tuf.unite(i,a);\n\t\tuf.unite(i,b);\n\t\tpar[a]=i;\n\t\tpar[b]=i;\n\t\tc[i]=c[a];\n\t}\n\tpar[n==1?0:idx.back()]=s++;\n\tlen.pb(0);\n\tuf=unionfind(s);\n\trep(i,s-1)if(len[i]==len[par[i]])\n\t\tuf.unite(i,par[i]);\n\tvi vs;\n\trep(i,s)if(uf.find(i)==i)vs.pb(i);\n\tauto z=[&](int i){return lower_bound(all(vs),uf.find(i))-vs.bg;};\n\tvvc<ste> res(vs.size());\n\trep(ii,s-1){\n\t\tint i=ii/2+ii%2*n;\n\t\tint a=z(i),b=z(par[i]);\n\t\tif(a==b)continue;\n\t\tres[b].pb(ste{a,c[i]+len[par[i]],c[i]+len[i]});\n\t}\n\treturn make_pair(res,z(s-1));\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.clear();buf.resize(s=n,0);}\n\tvoid init(const vc<t>&a){\n\t\ts=si(a);\n\t\tbuf.resize(s);\n\t\trep(i,s)buf[i]=a[i];\n\t\trep(i,s){\n\t\t\tint j=i+((i+1)&(-i-1));\n\t\t\tif(j<s)buf[j]+=buf[i];\n\t\t}\n\t}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tvoid add_range(int b,int e,t v){\n\t\tadd(b,v);\n\t\tadd(e,-v);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\ntemplate<class t>\nstruct Point1D{\n\tBIT<t> bit;\n\tvi pos;\n\tvoid addp(int p){\n\t\tpos.pb(p);\n\t}\n\tvoid init(){\n\t\tmkuni(pos);\n\t\tbit.init(pos.size());\n\t}\n\tint idx(int p){\n\t\treturn lwb(pos,p);\n\t}\n\tvoid addv(int p,t v){\n\t\tbit.add(idx(p),v);\n\t}\n\tt sum(int b,int e){\n\t\treturn bit.sum(idx(b),idx(e));\n\t}\n\t//[-inf,p)\n\tt getpref(int p){\n\t\treturn bit.get(idx(p)-1);\n\t}\n};\n\ntemplate<class t>\nstruct Point2D{\n\tvc<Point1D<t>> buf;\n\tvi pos,xs,ys;\n\tvoid addp(int x,int y){\n\t\txs.pb(x);\n\t\tys.pb(y);\n\t}\n\tint idx(int p){\n\t\treturn lwb(pos,p);\n\t}\n\tvoid init(){\n\t\tpos=xs;\n\t\tmkuni(pos);\n\t\tbuf.resize(pos.size());\n\t\trep(i,xs.size())\n\t\t\tfor(int j=idx(xs[i]);j<int(buf.size());j+=(j+1)&(-j-1))\n\t\t\t\tbuf[j].addp(ys[i]);\n\t\tfor(auto&b:buf)b.init();\n\t}\n\tvoid addv(int x,int y,t v){\n\t\tfor(int j=idx(x);j<int(buf.size());j+=(j+1)&(-j-1))\n\t\t\tbuf[j].addv(y,v);\n\t}\n\t//[x1,x2)*[y1,y2)\n\tt rect(int x1,int x2,int y1,int y2){\n\t\tt res=0;\n\t\tfor(int j=idx(x1)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres-=buf[j].sum(y1,y2);\n\t\tfor(int j=idx(x2)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres+=buf[j].sum(y1,y2);\n\t\treturn res;\n\t}\n\t//NOT VERIFIED\n\t//[-inf,x)*[-inf,y)\n\tt getpref(int x,int y){\n\t\tt res=0;\n\t\tfor(int j=idx(x)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres+=buf[j].getpref(y);\n\t\treturn res;\n\t}\n};\n\n\n//KUPC 2020 C\n//重心分解してクエリに答える\n//クエリ (a,b) に対しては，LCA から a までのパスと，LCA から b までのパスの情報を使って答える．\n//パスの情報は N に保存される\n//N() が単位元的な役割\n//N.extend(e) で辺 e を使って下に下って新しいノードを作る\n//N 同士のマージをやると計算量が壊れるが extend なら．．．というときに使える\ntemplate<class E,class N>\nstruct cdecomp{\n\tconst vvc<E>&g;\n\tint n;\n\tvi rem;\n\t\n\tint ts(int v,int p){\n\t\tint res=1;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e])\n\t\t\tres+=ts(e,v);\n\t\treturn res;\n\t}\n\tint fc(int v,int p,int s){\n\t\tint ret=1,mx=0;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e]){\n\t\t\tint f=fc(e,v,s);\n\t\t\tif(f<=0)\n\t\t\t\treturn f;\n\t\t\telse{\n\t\t\t\tret+=f;\n\t\t\t\tmx=max(mx,f);\n\t\t\t}\n\t\t}\n\t\tmx=max(mx,s-ret);\n\t\tif(mx*2<=s)\n\t\t\treturn -v;\n\t\telse\n\t\t\treturn ret;\n\t}\n\t\n\tcdecomp(const vvc<E>&gg):g(gg),n(g.size()),rem(n){\n\t}\n\t\n\tvc<N> buf0;\n\tvc<N> buf1;\n\tvi tp;\n\tvvc<tuple<int,int,int>> bucket;\n\t\n\tvoid dfs1(int v,int p,int i,N cur0,N cur1){\n\t\tbuf0[v]=cur0;\n\t\tbuf1[v]=cur1;\n\t\ttp[v]=i;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e]){\n\t\t\tdfs1(e,v,i==-1?e:i,cur0.extend(e),cur1.extend(e));\n\t\t}\n\t}\n\t\n\ttemplate<class F>\n\tvoid con(int r,const vc<tuple<int,int,int>>&qs,F f){\n\t\tr=-fc(r,-1,ts(r,-1));\n\t\t\n\t\tN ini0,ini1;\n\t\tini0.init(0);\n\t\tini1.init(1);\n\t\tdfs1(r,-1,-1,ini0,ini1);\n\t\tfor(const auto&w:qs){\n\t\t\tint a,b,i;tie(a,b,i)=w;\n\t\t\tif(tp[a]!=tp[b]){\n\t\t\t\tf(i,buf0[a],buf1[b],r);\n\t\t\t}else{\n\t\t\t\tbucket[tp[a]].pb(w);\n\t\t\t}\n\t\t}\n\t\t\n\t\trem[r]=1;\n\t\tfor(auto e:g[r])if(!rem[e]){\n\t\t\tvc<tuple<int,int,int>> tmp;\n\t\t\ttmp.swap(bucket[e]);\n\t\t\tcon(e,tmp,f);\n\t\t}\n\t}\n\t\n\t//f(idx,N lf,N rt,int lca) がよばれる\n\t//[qs[i].a,lca) が lf に，[qs[i].b,lca) が rt に入るらしい\n\ttemplate<class F>\n\tvoid slv(const vc<pi>&qs,F f){\n\t\tfill(all(rem),0);\n\t\tbuf0.resize(n);\n\t\tbuf1.resize(n);\n\t\ttp.resize(n);\n\t\tbucket.resize(n);\n\t\t\n\t\tvc<tuple<int,int,int>> tmp(si(qs));\n\t\trep(i,si(qs))\n\t\t\ttmp[i]=mt(qs[i].a,qs[i].b,i);\n\t\tcon(0,tmp,f);\n\t}\n};\n\nstruct E{\n\tint to;\n\tchar c;\n\toperator int()const{return to;}\n};\n\nSA sa[2];\nvvc<ste> st[2];\nint stroot[2];\nvi in[2],out[2];\nint ord[2];\n\nvoid dfs(int k,int v){\n\tin[k][v]=ord[k]++;\n\tfor(auto e:st[k][v])\n\t\tdfs(k,e.to);\n\tout[k][v]=ord[k];\n}\n\nstring z[2];\n\nstruct N{\n\tint k,v,dig,len;\n\tvoid init(int kk){\n\t\tk=kk;\n\t\tv=stroot[k];\n\t\tdig=-1;\n\t\tlen=-1;\n\t}\n\tN extend(const E&e)const{\n\t\tif(v==-1)return N{-1,-1,-1,-1};\n\t\tN res=*this;\n\t\tif(res.dig==-1){\n\t\t\trep(i,si(st[k][v])){\n\t\t\t\tif(z[k][st[k][v][i].l]==e.c){\n\t\t\t\t\tres.dig=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res.dig==-1){\n\t\t\t\treturn N{-1,-1,-1,-1};\n\t\t\t}\n\t\t\tres.len=0;\n\t\t}\n\t\tconst auto&f=st[k][v][res.dig];\n\t\tif(z[k][f.l+res.len]!=e.c)return N{-1,-1,-1,-1};\n\t\tres.len++;\n\t\tif(f.r-f.l==res.len){\n\t\t\treturn N{k,f.to,-1,-1};\n\t\t}else{\n\t\t\treturn res;\n\t\t}\n\t}\n\tpi getlr(){\n\t\tif(v==-1)return pi(-1,-1);\n\t\tint w=v;\n\t\tif(len>0){\n\t\t\tw=st[k][v][dig].to;\n\t\t}\n\t\treturn pi(in[k][w],out[k][w]);\n\t}\n};\n\n/*\n//example\nauto slv=[&](int dst,N x,N y,int lca){\n\tx.off^=y.off;\n\trep(i,y.s)x.add(y.vs[i]);\n\tif(cv[lca]!=-1)x.add(cv[lca]);\n\tans[dst]=x.getans(ks[dst]);\n};\n*/\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\t\n\tvvc<E> tr(n);\n\trep(i,n-1){\n\t\tint u,v;cin>>u>>v;\n\t\tu--;v--;\n\t\tstring s;cin>>s;\n\t\ttr[u].pb(E{v,s[0]});\n\t\ttr[v].pb(E{u,s[0]});\n\t}\n\t\n\tz[0]=""$"";\n\tvi off(m),len(m);\n\trep(i,m){\n\t\toff[i]=si(z[0]);\n\t\tstring s;cin>>s;\n\t\tlen[i]=si(s);\n\t\tz[0]+=s;\n\t\tz[0]+=\'$\';\n\t}\n\tz[1]=z[0];\n\treverse(all(z[1]));\n\t\n\trep(k,2){\n\t\ttie(st[k],stroot[k])=stree(sa[k]=SA(z[k]));\n\t\tin[k].resize(si(st[k]));\n\t\tout[k].resize(si(st[k]));\n\t\tdfs(k,stroot[k]);\n\t\tdmp(k);\n\t\tdmp(st[k]);\n\t\tdmp(in[k]);\n\t}\n\t\n\tusing P=pair<pi,pi>;\n\tvc<pi> uv(q);\n\tvvc<int> baka(m+1);\n\tvc<P> ls(q);\n\trep(i,q){\n\t\tint u,v,l,r;cin>>u>>v>>l>>r;\n\t\tu--,v--,l--;\n\t\tuv[i]=pi(v,u);\n\t\tbaka[l].pb(i*2);\n\t\tbaka[r].pb(i*2+1);\n\t}\n\t\n\tauto unko=[&](int idx,N lf,N rt,int){\n\t\tls[idx]=P(lf.getlr(),rt.getlr());\n\t};\n\t\n\tcdecomp<E,N> cd(tr);\n\tcd.slv(uv,unko);\n\t\n\tdmp(ls);\n\t\n\tPoint2D<int> p2d;\n\trep(i,m){\n\t\trng(j,off[i],off[i]+len[i]+1){\n\t\t\tint x=in[0][sa[0].as[j]];\n\t\t\tint y=in[1][sa[1].as[si(z[1])-j]];\n\t\t\tdmp2(x,y);\n\t\t\tp2d.addp(x,y);\n\t\t}\n\t}\n\tp2d.init();\n\t\n\tvi ans(q);\n\t\n\trep(i,m+1){\n\t\tfor(auto w:baka[i]){\n\t\t\tauto [xl,xr]=ls[w/2].a;\n\t\t\tauto [yl,yr]=ls[w/2].b;\n\t\t\tans[w/2]+=p2d.rect(xl,xr,yl,yr)*(w%2==0?-1:1);\n\t\t}\n\t\tif(i<m){\n\t\t\trng(j,off[i],off[i]+len[i]+1){\n\t\t\t\tint x=in[0][sa[0].as[j]];\n\t\t\t\tint y=in[1][sa[1].as[si(z[1])-j]];\n\t\t\t\tp2d.addv(x,y,1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,q)print(ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['binary search', 'data structures', 'dfs and similar', 'hashing', 'string suffix structures', 'strings', 'trees']",3500
https://codeforces.com//contest/1290/problem/A,A. Mind Control,You and your n 1 friends have found an array of integers a 1 a 2 dots a n You have decided to share it in the following way All n of you stand in a line in a particular order Each minute the person at the front of the line chooses either the first or the last element of the array removes it and keeps it for himself He then gets out of line and the next person in line continues the process You are standing in the m th position in the line you may choose up to k different people in the line and persuade them to always take either the first or the last element in the array on their turn for each person his own choice not necessarily equal for all people no matter what the elements themselves are Suppose that you re doing your choices optimally What is the greatest integer x such that no matter what are the choices of the friends you didn t choose to control the element you will take from the array will be x Please note that the friends you don t control may do their choice and they will not necessarily take the biggest element available ,"[""/**\n *    author:  tourist\n *    created: 02.02.2020 17:03:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> what(m);\n    for (int x = 0; x < m; x++) {\n      int y = m - 1 - x;\n      what[x] = max(a[x], a[n - 1 - y]);\n    }\n    k = min(k, m - 1);\n    int ans = 0;\n    for (int fix = 0; fix <= k; fix++) {\n      int fiy = k - fix;\n      int mn = (int) 2e9;\n      for (int i = fix; i <= m - 1 - fiy; i++) {\n        mn = min(mn, what[i]);\n      }\n      ans = max(ans, mn);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]","['brute force', 'data structures', 'implementation']",1600
https://codeforces.com//contest/1433/problem/C,C. Dominant Piranha,There are n piranhas with sizes a 1 a 2 ldots a n in the aquarium Piranhas are numbered from left to right in order they live in the aquarium Scientists of the Berland State University want to find if there is piranha in the aquarium The piranha is called if it can eat all the other piranhas in the aquarium except itself of course Other piranhas will do nothing while the piranha will eat them Because the aquarium is pretty narrow and long the piranha can eat only one of the adjacent piranhas during one move Piranha can do as many moves as it needs or as it can More precisely The piranha i can eat the piranha i 1 if the piranha i 1 exists and a i 1 a i The piranha i can eat the piranha i 1 if the piranha i 1 exists and a i 1 a i When the piranha i eats some piranha its a i becomes a i 1 Your task is to find piranha in the aquarium or determine if there are no such piranhas Note that you have to find exactly one dominant piranha you don t have to find all of them For example if a 5 3 4 4 5 then the third piranha can be Consider the sequence of its moves The piranha eats the second piranha and a becomes 5 underline 5 4 5 the underlined piranha is our candidate The piranha eats the third piranha and a becomes 5 underline 6 5 The piranha eats the first piranha and a becomes underline 7 5 The piranha eats the second piranha and a becomes underline 8 You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define forinc(i,a,b) for(int i=a;i<=b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forv(i,x) for(auto &i:x)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r)\n{\n    return l+rng()%(r-l+1);\n}\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c==\'-\');for(;isdigit(c);c=getchar()) x=x*10+c-\'0\';n?-x:x;})\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define batbit(i,x) (x|(1ll<<i))\n#define getbit(i,x) ((x>>i)&1)\n\nconst int mn=3e5+10;\nint a[mn];\n\nmain()\n{\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        int ma=0,kq=0,ok=0;\n        forinc(i,1,n)\n        {\n            cin >> a[i];\n            ma=max(ma,a[i]);\n            if(a[i]!=a[i-1]&&i!=1) ok=1;\n        }\n        forinc(i,1,n) if(a[i]==ma)\n        {\n            if(i!=1&&a[i]>a[i-1])\n            {\n                kq=i;\n                break;\n            }\n            if(i!=n&&a[i]>a[i+1])\n            {\n                kq=i;\n                break;\n            }\n        }\n        if(!ok) cout << -1 << ""\\n"";\n        else cout << kq << ""\\n"";\n    }\n}\n']","['constructive algorithms', 'greedy']",900
https://codeforces.com//contest/868/problem/A,A. Bark to Unlock,As technologies develop manufacturers are making the process of unlocking a phone as user friendly as possible To unlock its new phone Arkady s pet dog Mu mu has to bark the password once The phone represents a password as a string of two lowercase English letters Mu mu s enemy Kashtanka wants to unlock Mu mu s phone to steal some sensible information but it can only bark distinct words each of which can be represented as a string of two lowercase English letters Kashtanka wants to bark several words not necessarily distinct one after another to pronounce a string containing the password as a substring Tell if it s possible to unlock the phone in this way or not ,"['#include <cstdio>\n\nchar a[4], b[101][4];\n\nint main() {\n\tint i, j, n;\n\tscanf(""%s%d"", a, &n);\n\tfor (i = 0; i < n; i++) scanf(""%s"", b[i]);\n\tfor (i = 0; i < n; i++) if (b[i][0] == a[0] && b[i][1] == a[1]) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (b[i][0] == a[1] && b[j][1] == a[0]) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\tputs(""NO"");\n\treturn 0;\n}']","['brute force', 'implementation', 'strings']",900
https://codeforces.com//contest/1839/problem/A,A. The Good Array,You are given two integers n and k An array a 1 a 2 ldots a n of length n consisting of zeroes and ones is if for integers i from 1 to n of the following conditions are satisfied at least lceil frac i k rceil of the first i elements of a are equal to 1 at least lceil frac i k rceil of the last i elements of a are equal to 1 Here lceil frac i k rceil denotes the result of division of i by k rounded up For example lceil frac 6 3 rceil 2 lceil frac 11 5 rceil lceil 2 2 rceil 3 and lceil frac 7 4 rceil lceil 1 75 rceil 2 Find the minimum possible number of ones in a good array ,"['#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define pb push_back\nusing namespace std;\nvoid init() {\n\t\n}\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tint a[n + 1];\n\tfor (int i = 1; i <= n; i++) a[i] = 0;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\ta[i] = a[(n + 1) - i] = (i % k == 1);\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcnt += a[i];\n\t\tif (cnt < i / k + bool(i % k)) {\n\t\t\tif (!a[i]) {\n\t\t\t\ta[i] = 1;\n\t\t\t\tcnt++;\n\t\t\t} else throw runtime_error("""");\n\t\t}\n\t}\n\tcout << cnt << endl;\n}\nint32_t main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tinit();\n\tint t = 1;\n\tcin >> t;\n\twhile (t--) solve();\n}']","['greedy', 'implementation', 'math']",800
https://codeforces.com//contest/790/problem/D,D. Bear and Rectangle Strips,Limak has a grid that consists of rows and columns The th cell in the th row contains an integer which can be positive negative or zero A non empty rectangle of cells is called if and only if the sum of numbers in its cells is equal to Limak wants to choose some nice rectangles and give them to his friends as gifts No two chosen rectangles should share a cell What is the maximum possible number of nice rectangles Limak can choose ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 3e5 + 10;\nint a[2][maxn];\nint n;\n\nint read() {\n  if (scanf(""%d"", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < n; ++j) {\n      scanf(""%d"", a[i] + j);\n    }\n  }\n  return 1;\n}\n\nint go[3][maxn];\n\nint ans[maxn];\n\nvector<pair<int, int> > toup[maxn][2];\n\nvoid mmax(int &x, int y) {\n  x = max(x, y);\n}\n\nvoid process(int s, int t, int val) {\n  mmax(ans[max(s, t)], val);\n\n  for (int j = 0; j < 3; ++j) {\n    int from = (!j ? s : (j == 1 ? t : max(s, t)));\n    from = go[j][from];\n    if (from > n) {\n      continue;\n    }\n    int ns = s, nt = t;\n    if (j != 1) {\n      ns = from;\n    }\n    if (j != 0) {\n      nt = from;\n    }\n\n    mmax(ans[max(ns, nt)], val + 1);\n    if (ns < nt) {\n      toup[ns][1].pb(mp(val + 1, nt));\n    }\n    if (nt < ns) {\n      toup[nt][0].pb(mp(val + 1, ns));\n    }\n  }\n}\n\nvoid solve() {\n  for (int iter = 0; iter < 3; ++iter) {\n    go[iter][n] = n + 1;\n    map<long long, int> last;\n\n    long long sum = 0;\n    last[sum] = n;\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = 0; j < 2; ++j) {\n        if ((iter + 1) & (1 << j)) {\n          sum += a[j][i];\n        }\n      }\n      auto &cur = go[iter][i];\n      cur = go[iter][i + 1];\n      auto iter = last.find(sum);\n      if (iter != last.end()) {\n        int pos = iter->second;\n        cur = min(cur, pos);\n      }\n      last[sum] = i;\n    }\n  }\n\n  for (int i = 0; i <= n; ++i) {\n    ans[i] = 0;\n    toup[i][0].clear();\n    toup[i][1].clear();\n  }\n\n  for (int i = 0; i < n; ++i) {\n    process(i, i, ans[i]);\n\n    for (int j = 0; j < 2; ++j) {\n      int best = n + 1;\n      for (auto p : toup[i][j]) {\n        if (p.first == ans[i] + 1) {\n          best = min(best, p.second);\n        }\n      }\n      if (best > n) {\n        continue;\n      }\n\n      int s = i, t = best;\n      if (!j) {\n        swap(s, t);\n      }\n      process(s, t, ans[i] + 1);\n    }\n  }\n\n  int res = *max_element(ans, ans + n + 1);\n  printf(""%d\\n"", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK "".out"", ""w"", stdout);\n  assert(freopen(TASK "".in"", ""r"", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""Time %.2f\\n"", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']",['dp'],3000
https://codeforces.com//contest/1588/problem/D,D. Strange LCS,You are given n strings s 1 s 2 ldots s n each consisting of lowercase and uppercase English letters In addition it s guaranteed that each character occurs in each string Find the longest common subsequence of these strings A string t is a subsequence of a string s if t can be obtained from s by deletion of several possibly zero or all symbols ,"['#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 1600;\n\nint nxt[11][111][52];\nvector<int> occur[11][52];\n\nint dp[105][512];\npi trk[105][512];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 52; j++){\n\t\t\t\toccur[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tint n; cin >> n;\n\t\tvector<string> s(n);\n\t\tlint prominent = (1ll << 52) - 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\tlint msk = 0;\n\t\t\tfor(auto &j : s[i]){\n\t\t\t\tif(isupper(j)) j -= \'A\';\n\t\t\t\telse j -= \'a\' - 26;\n\t\t\t\tmsk |= (1ll << j);\n\t\t\t}\n\t\t\tprominent &= msk;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstring t;\n\t\t\tfor(auto &j : s[i]){\n\t\t\t\tif((prominent >> j) & 1) t.push_back(j);\n\t\t\t}\n\t\t\ts[i] = t;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < sz(s[i]); j++){\n\t\t\t\tfor(int k = 0; k < 52; k++){\n\t\t\t\t\tif(s[i][j] == k) nxt[i][j][k] = j;\n\t\t\t\t\telse nxt[i][j][k] = (j == 0 ? -1 : nxt[i][j - 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < sz(s[i]); j++){\n\t\t\t\toccur[i][s[i][j]].push_back(j);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tint tot = 0;\n\t\tpi stpos(-1, -1);\n\t\tfor(int i = 0; i < sz(s[n - 1]); i++){\n\t\t\tchar c = s[n - 1][i];\n\t\t\tfor(int j = 0; j < (1<<(n - 1)); j++){\n\t\t\t\tbool ok = 1;\n\t\t\t\tvector<int> pos(n); pos[n - 1] = i;\n\t\t\t\tfor(int k = 0; k < n-1; k++){\n\t\t\t\t\tif((j >> k) & 1){\n\t\t\t\t\t\tif(sz(occur[k][c]) == 1){\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[k] = occur[k][c][(j >> k) & 1];\n\t\t\t\t}\n\t\t\t\tif(ok == 0) continue;\n\t\t\t\tfor(int k = 0; k < 52; k++){\n\t\t\t\t\tvector<int> nxtpos(n);\n\t\t\t\t\tfor(int x = 0; x < n; x++){\n\t\t\t\t\t\tif(pos[x] == 0) nxtpos[x] = -1;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnxtpos[x] = nxt[x][pos[x] - 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(count(all(nxtpos), -1)) continue;\n\t\t\t\t\tint msk = 0;\n\t\t\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\t\t\tif(occur[x][k][0] != nxtpos[x]) msk |= (1<<x);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j] < dp[nxtpos[n - 1]][msk]){\n\t\t\t\t\t\tdp[i][j] = dp[nxtpos[n - 1]][msk];\n\t\t\t\t\t\ttrk[i][j] = pi(nxtpos[n - 1], msk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j]++;\n\t\t\t\tif(dp[i][j] > tot){\n\t\t\t\t\ttot = dp[i][j];\n\t\t\t\t\tstpos = pi(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(tot == 0) cout << ""0\\n\\n"";\n\t\telse{\n\t\t\tcout << tot << ""\\n"";\n\t\t\tvector<int> v;\n\t\t\tfor(int i = 0; i < tot; i++){\n\t\t\t\tv.push_back(s[n - 1][stpos.first]);\n\t\t\t\tstpos = trk[stpos.first][stpos.second];\n\t\t\t}\n\t\t\treverse(all(v));\n\t\t\tfor(auto &i : v){\n\t\t\t\tif(i < 26) cout << (char)(i + \'A\');\n\t\t\t\telse cout << (char)(i - 26 + \'a\');\n\t\t\t}\n\t\t\tcout << ""\\n"";\n\t\t}\n\t}\n}\n\n']","['bitmasks', 'dp', 'graphs', 'strings']",2600
https://codeforces.com//contest/850/problem/D,D. Tournament Construction,Ivan is reading a book about tournaments He knows that a tournament is an oriented graph with exactly one oriented edge between each pair of vertices The score of a vertex is the number of edges going outside this vertex Yesterday Ivan learned Landau s criterion there is tournament with scores if and only if for all and Now Ivan wanna solve following problem given a of numbers is there a tournament with given set of scores I e is there tournament with sequence of scores such that if we remove duplicates in scores we obtain the required set Find a tournament with possible number of vertices ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VL vector<long long>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int SIZE = 1e6+10;\n#define FN 500010\n#define FM 4200010\n#define INF 1034567890\n#define FOR(it,c) for ( __typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++ )\nusing namespace std;\ntypedef long long LL;\nstruct E {\n    int k,c;\n    E(){}\n    E( int _k, int _c ):k(_k),c(_c){}\n} es[FM];\n\nstruct Flow {\n    int n,m,dis[FN];\n    int qq[FN],qr,ql;\n    vector<int> e[FN];\n    void init( int _n ) {\n        n=_n; m=0;\n        for ( int i=0; i<n; i++ ) e[i]=vector<int>();\n    }\n    void add_edge( int a, int b, int c ) {\n        e[a].push_back(m); es[m]=E(b,c); m++;\n        e[b].push_back(m); es[m]=E(a,0); m++;\n    }\n    bool BFS() {\n        memset(dis,-1,n*sizeof(int));\n        ql=qr=0;\n        qq[qr++]=0;\n        dis[0]=0;\n        while ( ql!=qr && dis[n-1]==-1 ) {\n            int p=qq[ql++];\n            FOR(it,e[p]) {\n                E ee=es[*it];\n                if ( ee.c==0 || dis[ee.k]!=-1 ) continue;\n                dis[ee.k]=dis[p]+1;\n                qq[qr++]=ee.k;\n            }\n        }\n        return dis[n-1]!=-1;\n    }\n    LL go( int p, LL c ) {\n        if ( p==n-1 ) return c;\n        LL ret=0,tmp;\n        FOR(it,e[p]) {\n            E &ee=es[*it];\n            if ( ee.c==0 || dis[p]+1!=dis[ee.k] ) continue;\n            tmp=go(ee.k,min(c-ret,(LL)ee.c));\n            ret+=tmp; ee.c-=tmp; es[(*it)^1].c+=tmp;\n            if ( ret==c ) break;\n        }\n        if ( ret==0 ) dis[p]=-1;\n        return ret;\n    }\n    LL maxflow() {\n        LL ret=0;\n        while ( BFS() ) ret+=go(0,1LL<<60);\n        return ret;\n    }\n} flow;\nint C2[100];\nint dp[32][2000][62],a[31];\nint rn;\nPII rd[100000];\nchar an[65][65];\nvoid go(int m,int ss,int nn){\n    printf(""%d\\n"",nn);\n    VI d;\n    while(m){\n        int u=dp[m][ss][nn];\n        m--;\n        REP(i,u)d.PB(a[m]);\n        ss-=u*a[m];\n        nn-=u;\n    }\n    int n=SZ(d);\n    int ed=1+C2[SZ(d)]+SZ(d);\n    flow.init(ed+1);\n    REP(i,n)REP(j,i){\n        rn++;\n        rd[rn]=MP(j,i);\n        flow.add_edge(0,rn,1);\n        flow.add_edge(rn,C2[SZ(d)]+i+1,1);\n        flow.add_edge(rn,C2[SZ(d)]+j+1,1);\n    }\n    REP(i,SZ(d)){\n        flow.add_edge(C2[SZ(d)]+i+1,ed,d[i]);\n    }\n    flow.maxflow();\n    REP(i,SZ(d))REP(j,SZ(d))an[i][j]=\'0\';\n    for(int i=0;i<flow.m;i+=2){\n        int x=es[i+1].k;\n        int y=es[i].k;\n        if(x<=C2[SZ(d)]&&y>C2[SZ(d)]&&!es[i].c){\n            int from=y-C2[SZ(d)]-1;\n            int to=rd[x].F+rd[x].S-from;\n            an[y-C2[SZ(d)]-1][to]=\'1\';\n        }\n    }\n    REP(i,SZ(d))puts(an[i]);\n}\nint main(){\n    REP(i,100)C2[i]=i*(i-1)/2;\n    DRI(m);\n    REP(i,m)RI(a[i]);\n    sort(a,a+m);\n    dp[0][0][0]=INF;\n    REP(i,m){\n        int r=m-i-1;\n        REP(ss,2000)REP(nn,62){\n            if(!dp[i][ss][nn])continue;\n            int now_ss=ss;\n            for(int k=1;k+nn+r<=61;k++){\n                now_ss+=a[i];\n                if(now_ss>=C2[k+nn]){\n                    dp[i+1][now_ss][k+nn]=k;\n                }\n                else break;\n            }\n        }\n    }\n    for(int i=1;i<=61;i++){\n        if(dp[m][C2[i]][i]){\n            go(m,C2[i],i);\n            return 0;\n        }\n    }\n    return 0*puts(""=("");\n}\n']","['constructive algorithms', 'dp', 'graphs', 'greedy', 'math']",2800
https://codeforces.com//contest/861/problem/B,B. Which floor ,In a building where Polycarp lives there are number of flats on each floor Unfortunately Polycarp don t remember how many flats are on each floor but he remembers that the flats are numbered from from lower to upper floors That is the first several flats are on the first floor the next several flats are on the second and so on Polycarp don t remember the total number of flats in the building so you can consider the building to be infinitely high i e there are infinitely many floors Note that the floors are numbered from Polycarp remembers on which floors several flats are located It is guaranteed that this information is not self contradictory It means that there exists a building with equal number of flats on each floor so that the flats from Polycarp s memory have the floors Polycarp remembers Given this information is it possible to restore the exact floor for flat ,"['#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(""%d"",&num1)\n#define sll(num1) scanf(""%lld"",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define TRACE\n \n//FILE *fin = freopen(""in"",""cc"",stdin);\n//FILE *fout = freopen(""out"",""s2numx"",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << "": "" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << "" | "" << #nn3 << "": "" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << endl;\n#define trace5(num1, bin, ch, d, txx)    cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #txx << "": "" << txx << endl;\n#define trace6(num1, bin, ch, d, txx, det) cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #txx << "": "" << txx << "" | "" << #det << "": "" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, txx)\n#define trace6(num1, bin, ch, d, txx, det)\n \n#endif\n\n#define pi(numx) printf(""%d\\num1"",numx)\n#define ff first\n#define ss second\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ll long long\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n\n#define lb lower_bound\n#define ub upper_bound\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define freq first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\nbool don[105];\nVI idxx;\nint main(){\n    fast\n    int num1,num2;\n    cin>>num1>>num2;\n    int cc[num2];\n    int freq[num2];\n    for(int i = 0 ; i < num2 ;i++){\n        cin >> cc[i] >> freq[i];\n        \n    }\n    if(num1==1){\n        cout << 1;\n    }\n    else{\n    for(int i=1;i<=100;i++){\n    \tfor(int j=0;j<num2;j++){\n    \t\tif(ceil((double)cc[j]/i)==freq[j]&& j!=num2-1){\n    \t\t\tcontinue;\n    \t\t}\n    \t\telse if(ceil((double)cc[j]/i)==freq[j] && j==num2-1){\n    \t\t\tdon[i]==true;\n    \t\t\tidxx.pb((int)ceil((double)num1/i));\n    \t\t}\n    \t\telse{\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    }\n    if(idxx.size()!=0){\n        sort(idxx.begin(),idxx.end());\n        if(idxx[0]==idxx[idxx.size()-1])\n            cout<<idxx[0];\n        else\n            cout<<-1;\n        }\n        else\n            cout<<-1;\n    }\n}']","['brute force', 'implementation']",1500
https://codeforces.com//contest/1453/problem/E,E. Dog Snacks,Gildong is playing with his dog Badugi They re at a park that has n intersections and n 1 bidirectional roads each 1 meter in length and connecting two intersections with each other The intersections are numbered from 1 to n and for every a and b 1 le a b le n it is possible to get to the b th intersection from the a th intersection using some set of roads Gildong has put one snack at every intersection of the park Now Gildong will give Badugi a mission to eat all of the snacks Badugi starts at the 1 st intersection and he will move by the following rules Badugi looks for snacks that are as close to him as possible Here the distance is the length of the shortest path from Badugi s current location to the intersection with the snack However Badugi s sense of smell is limited to k meters so he can only find snacks that are less than or equal to k meters away from himself If he cannot find any such snack he fails the mission Among all the snacks that Badugi can smell from his current location he chooses a snack that minimizes the distance he needs to travel from his current intersection If there are multiple such snacks Badugi will choose one arbitrarily He repeats this process until he eats all n snacks After that he has to find the 1 st intersection again which also must be less than or equal to k meters away from the last snack he just ate If he manages to find it he completes the mission Otherwise he fails the mission Unfortunately Gildong doesn t know the value of k So he wants you to find the minimum value of k that makes it possible for Badugi to complete his mission if Badugi moves optimally ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nconst int N=200005;\nint n,flag,dp[N],deg[N];\nvector<int>E[N];\ninline void add(int x,int y){\n\tE[x].PB(y),E[y].PB(x);\n\tdeg[x]++,deg[y]++;\n}\ninline void getDP(int x,int f,int dis){\n\tif(x!=1&&deg[x]==1){\n\t\tdp[x]=0;\n\t\treturn ;\n\t}\n\tvector<int>temp;\n\tRep(y,E[x]){\n\t\tif(y==f)continue;\n\t\tgetDP(y,x,dis);\n\t\ttemp.PB(dp[y]);\n\t}\n\tsort(temp.begin(),temp.end());\n\tint size=temp.size();\n\tif(temp[size-1]>=dis){\n\t\tflag=0;\n\t}\n\telse if(temp[size-1]==dis-1){\n\t\tif(size>=2&&temp[size-2]==dis-1)flag=0;\n\t\telse dp[x]=dis;\n\t}\n\telse dp[x]=temp[0]+1;\n}\nint _;\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(_);\n    while(_--){\n    \tread(n);\n    \tF(i,1,n)E[i].clear(),deg[i]=0;\n    \tint tu,tv;\n    \tF(i,1,n-1){\n    \t\tread(tu),read(tv),add(tu,tv);\n    \t\t//cout<<tu<<\' \'<<tv<<endl;\n\t\t}\n    \tint L=1,R=n;\n    \twhile(L<R){\n    \t\tflag=1;\n    \t\tint mid=(L+R)>>1;\n    \t\tgetDP(1,0,mid);\n    \t\tif(flag&&dp[1]<=mid)R=mid;\n    \t\telse L=mid+1;\n\t\t}\n\t\tcout<<L<<\'\\n\';\n\t}\n    return 0;\n}']","['binary search', 'dfs and similar', 'dp', 'greedy', 'trees']",2300
https://codeforces.com//contest/78/problem/B,B. Easter Eggs,The Easter Rabbit laid eggs in a circle and is about to paint them Each egg should be painted one color out of 7 red orange yellow green blue indigo or violet Also the following conditions should be satisfied Each of the seven colors should be used to paint at least one egg Any four eggs should be painted different colors Help the Easter Rabbit paint the eggs in the required manner We know that it is always possible ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n\nchar C[] = ""ROYGBIV"";\n\nint main() {\n\n    int N;\n    scanf(""%d"", &N);\n    for (int i = 0; i < N-3; i++) {\n        putchar(C[i%4]);\n    }\n    puts(""BIV"");\n\n    return 0;\n}\n']","['constructive algorithms', 'implementation']",1200
https://codeforces.com//contest/962/problem/D,D. Merge Equals,You are given an array of positive integers While there are at least two equal elements we will perform the following operation We choose the smallest value x that occurs in the array 2 or more times Take the first two occurrences of x in this array the two leftmost occurrences Remove the left of these two occurrences and the right one is replaced by the sum of this two values that is 2 cdot x Determine how the array will look after described operations are performed For example consider the given array looks like 3 4 1 2 2 1 1 It will be changed in the following way 3 4 1 2 2 1 1 rightarrow 3 4 2 2 2 1 rightarrow 3 4 4 2 1 rightarrow 3 8 2 1 If the given array is look like 1 1 3 1 1 it will be changed in the following way 1 1 3 1 1 rightarrow 2 3 1 1 rightarrow 2 3 2 rightarrow 3 4 ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n;\nmap<ll,set<int>> m;\nset<pl> en;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n; \n    vi a(n);\n    F0R(i,n) {\n        cin >> a[i]; \n        m[a[i]].insert(i);\n    }\n    while (sz(m)) {\n        auto a = *m.begin(); m.erase(m.begin());\n        while (sz(a.s) >= 2) {\n            a.s.erase(a.s.begin());\n            m[2*a.f].insert(*a.s.begin());\n            a.s.erase(a.s.begin());\n        }\n        if (sz(a.s) == 1) en.insert({*a.s.begin(),a.f});\n    }\n    cout << sz(en) << ""\\n"";\n    for (auto a: en) cout << a.s << "" "";\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)']","['data structures', 'implementation']",1600
https://codeforces.com//contest/1654/problem/A,A. Maximum Cake Tastiness,There are n pieces of cake on a line The i th piece of cake has weight a i 1 leq i leq n The tastiness of the cake is the maximum total weight of two adjacent pieces of cake i e max a 1 a 2 a 2 a 3 ldots a n 1 a n You want to maximize the tastiness of the cake You are allowed to do the following operation at most once doing more operations would ruin the cake Choose a contiguous subsegment a l r of pieces of cake 1 leq l leq r leq n and reverse it The subsegment a l r of the array a is the sequence a l a l 1 dots a r If you reverse it the array will become a 1 a 2 dots a l 2 a l 1 underline a r underline a r 1 underline dots underline a l 1 underline a l a r 1 a r 2 dots a n 1 a n For example if the weights are initially 5 2 1 4 7 3 you can reverse the subsegment a 2 5 getting 5 underline 7 underline 4 underline 1 underline 2 3 The tastiness of the cake is now 5 7 12 while before the operation the tastiness was 4 7 11 Find the maximum tastiness of the cake after doing the operation at most once ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tsort(all(a));\n\tcout << a[n - 1] + a[n - 2] << ""\\n"";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation', 'sortings']",800
https://codeforces.com//contest/143/problem/A,A. Help Vasilisa the Wise 2,Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer However Vasilisa the Wise does not know what the box s secret is since she cannot open it again She hopes that you will help her one more time with that The box s lock looks as follows it contains identical deepenings for gems as a square and some integer numbers are written at the lock s edge near the deepenings The example of a lock is given on the picture below The box is accompanied with gems Their shapes match the deepenings shapes and each gem contains one number from to each number is written on exactly one gem The box will only open after it is decorated with gems correctly that is each deepening in the lock should be filled with exactly one gem Also the sums of numbers in the square s rows columns and two diagonals of the square should match the numbers written at the lock s edge For example the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below Now Vasilisa the Wise wants to define given the numbers on the box s lock which gems she should put in the deepenings to open the box Help Vasilisa to solve this challenging task ,"[""#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <numeric>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define two(X) (1<<(X))\n#define SIZE(A) ((int)(A.size()))\n#define LENGTH(A) ((int)A.length())\n#define random(x) (rand()%x)\n#define randomize() (srand((int)time(0)))\n\ntypedef long long int64;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nconst int INF=0x7FFFFFFF;\nconst double eps=1e-10;\nconst double pi=acos(-1.0);\n\n\nint r1,r2,c1,c2,d1,d2;\n\nint main()\n{\n\tcin>>r1>>r2>>c1>>c2>>d1>>d2;\n\tfor (int i=1; i<=9; i++)\n\t\tfor (int j=1; j<=9; j++)\n\t\t\tfor (int x=1; x<=9; x++)\n\t\t\t\tfor (int y=1; y<=9; y++)\n\t\t\t\t\tif (i+j==r1 && x+y==r2 && i+x==c1 && j+y==c2 && i+y==d1 && j+x==d2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i==j || i==x || i==y || j==x || j==y || x==y) continue;\n\t\t\t\t\t\tcout<<i<<' '<<j<<endl;\n\t\t\t\t\t\tcout<<x<<' '<<y<<endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}\n\n""]","['brute force', 'math']",1000
https://codeforces.com//contest/1349/problem/C,C. Orac and Game of Life,Orac likes games Recently he came up with the new game You should play this game on a black and white grid with n rows and m columns Each cell is either black or white For each iteration of the game the initial iteration is 0 the color of each cell will change under the following rules If there are no adjacent cells with the same color as this cell on the current iteration the color of it on the next iteration will be the same Otherwise the color of the cell on the next iteration will be different Two cells are adjacent if they have a mutual edge Now Orac has set an initial situation and he wants to know for the cell i j in i th row and j th column what will be its color at the iteration p He may ask you these questions several times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll INF = (ll)2e18;\nconst int N = 1010;\nchar s[N][N];\nint n, m;\nconst int DX[] = {-1, 1, 0, 0};\nconst int DY[] = {0, 0, -1, 1};\nll dist[N][N];\npii q[N * N];\nint topQ;\n\nbool checkCell(int x, int y) {\n\treturn 0 <= x && x < n && 0 <= y && y <= m;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint k;\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%s"", s[i]);\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < m; y++) {\n\t\t\tdist[x][y] = INF;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint xx = x + DX[i], yy = y + DY[i];\n\t\t\t\tif (!checkCell(xx, yy)) continue;\n\t\t\t\tif (s[xx][yy] == s[x][y]) dist[x][y] = 0;\n\t\t\t}\n\t\t\tif (dist[x][y] == 0) q[topQ++] = mp(x, y);\n\t\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint x = q[i].first, y = q[i].second;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint xx = x + DX[j], yy = y + DY[j];\n\t\t\tif (!checkCell(xx, yy)) continue;\n\t\t\tif (dist[xx][yy] <= dist[x][y] + 1) continue;\n\t\t\tdist[xx][yy] = dist[x][y] + 1;\n\t\t\tq[topQ++] = mp(xx, yy);\n\t\t}\n\t}\n\twhile(k--) {\n\t\tint x, y;\n\t\tll t;\n\t\tscanf(""%d%d%lld"", &x, &y, &t);\n\t\tx--;y--;\n\t\tchar ans = s[x][y];\n\t\tif (t >= dist[x][y] && (t - dist[x][y]) % 2 == 1) ans ^= 1;\n\t\tprintf(""%c\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']","['dfs and similar', 'graphs', 'implementation', 'shortest paths']",2000
https://codeforces.com//contest/224/problem/B,B. Array,You ve got an array consisting of integers Your task is to find a minimal by inclusion segment such that among numbers there are exactly distinct numbers Segment are integers of length satisfying the given property is called if there is no segment satisfying the property and less then in length such that Note that the segment doesn t have to be minimal in length among all segments satisfying the given property ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#define Eo(x) {cerr << #x << "" = "" << (x) << endl;}\n#define E(x) {cerr << #x << "" = "" << (x) << \' \';}\n\nusing namespace std;\nmap<int,int> cnt;\nconst int N = 100005;\nint ar[N];\n\nint main(){\n\tint n, k;\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=0; i<n; ++i) scanf(""%d"", ar+i);\n\n\tint l, r;\n\tfor (r = 0; r<n; ++r){\n\t\t++cnt[ar[r]];\n\t\tif (cnt.size() >= k) break;\n\t}\n\tif (cnt.size() < k){\n\t\tprintf(""%d %d\\n"", -1, -1);\n\t\treturn 0;\n\t}\n\tfor (l = 0; l<r; ++l){\n\t\tif (cnt[ar[l]] == 1) break;\n\t\t--cnt[ar[l]];\n\t}\n\tprintf(""%d %d\\n"", l+1, r+1);\n\treturn 0;\n}\n']","['bitmasks', 'implementation', 'two pointers']",1500
https://codeforces.com//contest/499/problem/A,A. Watching a movie,You have decided to watch the best moments of some movie There are two buttons on your player Watch the current minute of the movie By pressing this button you watch the current minute of the movie and the player automatically proceeds to the next minute of the movie Skip exactly minutes of the movie is some fixed positive integer If the player is now at the th minute of the movie then as a result of pressing this button it proceeds to the minute Initially the movie is turned on in the player on the first minute and you want to watch exactly best moments of the movie the th best moment starts at the th minute and ends at the th minute more formally the th best moment consists of minutes Determine what is the minimum number of minutes of the movie you have to watch if you want to watch all the best moments ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint main(){\n    DRII(n,x);\n    int now=1;\n    int an=0;\n    REP(i,n){\n        DRII(u,v);\n        while(now+x<=u)now+=x;\n        while(now<=v){\n            an++;\n            now++;\n        }\n    }\n    printf(""%d\\n"",an);\n    return 0;\n}\n']","['greedy', 'implementation']",1000
https://codeforces.com//contest/1103/problem/D,D. Professional layer,Cardbluff is popular sport game in Telegram Each Cardbluff player has ever dreamed about entrance in the professional layer There are n judges now in the layer and you are trying to pass the entrance exam You have a number k your skill in Cardbluff Each judge has a number a i an indicator of uncertainty about your entrance to the professional layer and a number e i an experience playing Cardbluff To pass the exam you need to convince all judges by playing with them You can play only game with each judge As a result of a particular game you can divide the uncertainty of i th judge by any natural divisor of a i which is at most k If GCD of all indicators is equal to 1 you will enter to the professional layer and become a judge Also you want to minimize the total amount of spent time So if you play with x judges with total experience y you will spend x cdot y seconds Print minimal time to enter to the professional layer or 1 if it s impossible ,"['//#pragma GCC diagnostic error ""-std=c++11""\n#pragma optimize(""unroll-loops,no-stack-protector"")\n#include<bits/stdc++.h>\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define ALL(a) a.begin(),a.end()\n#define lowbit(x) ((x)&-(x))\n#define dec minus_down\nusing namespace std;\ntypedef unsigned long long u64;\ntypedef unsigned int u32;\ntypedef pair<int,int>pii;\ntypedef vector<int>VI;\ntypedef long long i64;\ntypedef long long ll;\ntypedef double ld;\nnamespace io{\n\tstruct eof{eof(){}};\n\tconst int L=(1<<21)|5;\n\tchar ibuf[L],*iS,*iT,obuf[L],*oS=obuf,*oT=obuf+L-1,c,qu[55];int f,qr;\n\t#define gc() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,L,stdin),(iS==iT?EOF:*iS++)):*iS++)\n\tinline void flush(){fwrite(obuf,1,oS-obuf,stdout),oS=obuf;}\n\tinline void putc(char x){*oS++=x;if(oS==oT)flush();}\n\ttemplate<class I>inline void gi(I&x){\n\t\tfor(f=1,c=gc();(c<\'0\'||c>\'9\')&&(c!=EOF);c=gc())if(c==\'-\')f=-1;\n \t\tif(c==EOF)throw eof();\n\t\tfor(x=0;c<=\'9\'&&c>=\'0\';c=gc())x=x*10+(c&15);x*=f;\n\t}\n\ttemplate<class I>inline void print(I x){\n\t\tif(!x)putc(\'0\');if(x<0)putc(\'-\'),x=-x;\n\t\twhile(x)qu[++qr]=x%10+\'0\',x/=10;while(qr)putc(qu[qr--]);\n\t}\n#if __cplusplus < 201103L\n\t// do nothing\n#else\n\tstruct StringReader{\n\t\tfunction<bool(char)>chk;\n\t\tStringReader(){chk=[&](char c){return c<=\'z\'&&c>=\'a\';};}\n\t\tStringReader(function<bool(char)>func){chk=func;}\n\t\tinline char read(){for(c=gc();!chk(c);c=gc());return c;}\n\t\tinline void gs(char*s){for(c=gc();!chk(c);c=gc());for(;chk(c);c=gc())*s++=c;*s=0;}\n\t\tstring readString(){string s;for(c=gc();!chk(c);c=gc());for(;chk(c);c=gc())s+=c;return s;}\n\t};\n#endif\n\tinline void ps(const char*s){int l=strlen(s),x;for(x=0;x<l;x++)putc(s[x]);}\n\tstruct IOC{~IOC(){flush();}}ioc;\n\tinline double readld(){\n\t\tdouble x=0,y=1;\n\t\tfor(c=gc();c<\'0\'||c>\'9\';c=gc())if(c==\'-\')y=-1;assert(c!=\'.\');\n\t\tfor(;c<=\'9\'&&c>=\'0\';c=gc())x=x*10+(c&15);x*=y;assert(c!=\'e\');\n\t\tif(c==\'.\')for(c=gc();c<=\'9\'&&c>=\'0\';c=gc())y*=0.1,x+=y*(c&15);\n\t\treturn x;\n\t}\n\tinline void printld(double x,int y){\n\t\tif(x<0)putc(\'-\'),x=-x;x+=.5*pow(.1,y);print((u64)x),putc(\'.\');\n\t\tfor(x-=(u64)x;y;--y)x*=10,putc((int)x+\'0\'),x-=(int)x;\n\t}\n}using io::gi;using io::print;using io::putc;\ntemplate<class T>int ctz(T a){return sizeof(T)>4?__builtin_ctzll(a):__builtin_ctz(a);}\ntemplate<class T>inline T gcd(T a,T b){\n\tint shift=ctz(a|b);\n\tfor(b>>=ctz(b),a>>=ctz(a);a;a-=b,a>>=ctz(a))if(a<b)swap(a,b);\n\treturn b<<shift;\n}\ntemplate<class T>void exgcd(T a,T b,T&x,T&y){\n\tif(!b)return (void)(x=1,y=0);\n\texgcd(b,a%b,y,x),y-=a/b*x;\n}\ntemplate<class T>T Inv(T a,T p){T x,y;exgcd(a,p,x,y);return (x%p+p)%p;}\ninline int fpow(int a,int t,int p){static int r;for(r=1;t;a=(ll)a*a%p,t>>=1)if(t&1)r=(ll)r*a%p;return r;}\nstring to_string(string s){return \'""\'+s+\'""\';};\nstring to_string(const char*s){return to_string(string(s));}\nstring to_string(bool f){return f?""true"":""false"";}\ntemplate<class A,class B>string to_string(pair<A,B>p){return ""(""+to_string(p.fi)+"", ""+to_string(p.se)+"")"";}\ntemplate<class T>string to_string(T v){string s=""{"",e="""";for(auto&x:v)s+=e+to_string(x),e="", "";s+=""}"";return s;}\nvoid debug_out(){cerr<<endl;}template<class A,class...B>void debug_out(A x,B...y){cerr<<"" ""<<to_string(x),debug_out(y...);}\nvoid scan(){}template<class A,class...B>void scan(A&a,B&...b){gi(a),scan(b...);}\ntemplate<class T>void read(T first,T last){for(;first!=last;++first)gi(*first);}\ntemplate<class T>void write(T first,T last){for(;first!=last;putc(++first==last?\'\\n\':\' \'))print(*first);}\ntemplate<class T>void show(T x){print(x),putc(\'\\n\');}\ntemplate<class A,class...B>void show(A a,B...b){print(a),putc(\' \'),show(b...);}\ntemplate<class T>inline bool chkmin(T&a,T b){return b<a?a=b,true:false;}\ntemplate<class T>inline bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>inline T abs(T x){return x<0?-x:x;}\nconst int P=1e9+7,mod=P;\ninline void inc(int&x,int y){x+=y;x<P?:x-=P;}\ninline void inc(int&x,u64 y){x=(x+y)%P;}\ninline void dec(int&x,int y){x-=y;x>=0?:x+=P;}\ninline void dec(int&x,u64 y){x-=y%P;x>=0?:x+=P;}\ninline int add(int x,int y){return (x+=y)<mod?x:x-mod;}\ninline int sub(int x,int y){return (x-=y)<0?x+mod:x;}\ninline int mul(int x,int y){return i64(x)*y%mod;}\ninline void addx(int&x,int y){(x+=y)<mod?:x-=mod;}\ninline void subx(int&x,int y){(x-=y)>=0?:x+=mod;}\ntemplate<class T>inline int sgn(T x){return (x>0)-(x<0);}\ninline int fpow(int a,i64 t){\n\tstatic const int fmod=mod-1;\n\tt%=fmod;if(t<0)t+=fmod;int r;\n\tfor(r=1;t;t>>=1,a=mul(a,a))if(t&1)r=mul(r,a);\n\treturn r;\n}\nconst int N=1e6+5,M=1<<12|5,L=12;\nconst i64 inf=1LL<<60;\nint n,m,f[M];\ni64 a[N],g,e[N],k;\nvector<i64>p;\nmap<vector<i64>,vector<i64>>ff;\ni64 dp[M][L],cp[M][L];\nvoid dfs(const vector<i64>&cur,i64 num,int subset,int pos){\n\tif(pos==cur.size()){f[subset]=1;return;}\n\tdfs(cur,num,subset,pos+1);\n\tif(num<=k/cur[pos])dfs(cur,num*cur[pos],subset|1<<pos,pos+1);\n}\nint main(){\n\tint i,j,s,l;\n\tscan(n,k);\n\tread(a+1,a+n+1),read(e+1,e+n+1);\n\tfor(i=1;i<=n;++i)g=__gcd(g,a[i]);\n\tfor(i=2;i64(i)*i<=g;++i)if(g%i==0){\n\t\twhile(g%i==0)g/=i;\n\t\tp.pb(i);\n\t}\n\tif(g>1)p.pb(g);\n\tm=p.size();\n\tfor(i=1;i<=n;++i){\n\t\tvector<i64>kk(m,1); \n\t\tfor(j=0;j<m;++j)while(a[i]%p[j]==0)a[i]/=p[j],kk[j]*=p[j];\n\t\tff[kk].pb(e[i]);\n\t}\n\tfor(i=0;i<1<<m;++i)for(j=0;j<=m;++j)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(auto &g:ff){\n\t\tsort(ALL(g.se));\n\t\tmemset(f,0,sizeof(int)*(1<<m));\n\t\tdfs(g.fi,1LL,0,0);\n\t\tfor(i=0;i<m;++i)for(j=0;j<1<<m;++j)if(~j>>i&1)f[j]+=f[j|1<<i];\n\t\tvector<int> op;\n\t\tfor(i=1;i<1<<m;++i)if(f[i]==1)op.pb(i);\n\t\tl=g.se.size();\n\t\tif(l>m)l=m;\n\t\tfor(s=0;s<l;++s){\n\t\t\tbool f=false;\n\t\t\tmemcpy(cp,dp,sizeof(dp[0])*(1<<m));\n\t\t\tfor(int t:op)for(i=0;i<1<<m;++i)for(j=0;j<m;++j)if(dp[i][j]!=inf)f|=chkmin(cp[i|t][j+1],dp[i][j]+g.se[s]);\n\t\t\tmemcpy(dp,cp,sizeof(cp[0])*(1<<m));\n\t\t\tif(!f)break;\n\t\t}\n\t}\n\ti64 res=inf;\n\tfor(i=0;i<=m;++i)if(dp[(1<<m)-1][i]!=inf)chkmin(res,dp[(1<<m)-1][i]*i); \n\tif(res==inf)puts(""-1"");else cout<<res<<endl;\n}\n']","['bitmasks', 'dp']",3100
https://codeforces.com//contest/703/problem/E,E. Mishka and Divisors,After playing with her beautiful array Mishka decided to learn some math After learning how to multiply divide and what is divisibility she is now interested in solving the following problem You are given integer and array of integers You are to find subsequence of array elements such that the product of its elements is divisible by and it contains minimum possible number of elements Formally you are to find a sequence of indices such that is divisible by while is minimum possible among all such variants If there are more than one such subsequences you should choose one among them such that sum of its elements is Mishka quickly solved this problem Will you do so ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name"".in"", ""r"", stdin); \\\n        freopen(name"".out"", ""w"", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << "" = "" << head << "" <<"" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=\',\' || c!=0) {\n        if (*s==\'(\' || *s==\'[\' || *s==\'{\' || *s==\'<\') c++;\n        if (*s==\')\' || *s==\']\' || *s==\'}\' || *s==\'>\') c--;\n        cerr << *s++;\n    }\n    cerr << "" = "" << head << "", "";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << ""\\033[32m>> "" << __LINE__ << "": "" << __PRETTY_FUNCTION__ << endl; \\\n    cout << ""   ""; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << ""\\033[0m""; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss="""", const string se="""") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? """" : "", "") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << ""("" << pair.F << "", "" << pair.S << "")"";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), ""["", ""]"");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), ""{"", ""}"");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), ""|"", ""|"");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << ""{"";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?"""":"", "") << it->F << "":"" << it->S;\n    }\n    o << ""}"";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << ""Not lucky"" << endl;\n        exit(0);\n    }\n}\nusing ll = long long;\nvector<ll> fac, pf;\nint N;\nll K;\n\nconst int MV = 2e6;\nbool isp[MV];\nint wk[8888][100];\n\nll fm(ll x, ll y) {\n    \n    ll ans = 0, tp = x % K;\n    while (y) {\n        if (y & 1) {\n            ans += tp;\n            if (ans >= K) ans -= K;\n        }\n\n        tp += tp;\n        if (tp >= K) tp -= K;\n        y /= 2;\n    }\n    return ans;\n}\ninline int fid(ll x) {\n    return lower_bound(ALL(fac), x) - fac.begin();\n}\n\nstatic void pre() {\n    fill(isp, isp+MV, 1);\n    isp[0] = isp[1] = 0;\n    for (int i=2; i<MV; i++) {\n        if (isp[i]) {\n            for (int j=i+i; j<MV; j+=i) isp[j] = 0;\n        }\n    }\n\n    ll kk = K;\n    for (ll i=1; i*i<=K; i++) {\n        if (K % i == 0) {\n            ll t = K/i;\n            fac.PB(t);\n            if (t != i)\n                fac.PB(i);\n\n            if (isp[i]) {\n                pf.PB(i);\n                while (kk % i == 0) {\n                    kk /= i;\n                }\n            }\n        }\n    }\n    if (kk != 1) pf.PB(kk);\n    sort(ALL(fac));\n    sort(ALL(pf));\n    //cout << fac << \' \' << pf << endl;\n\n    for (int i=0; i<SZ(fac); i++) {\n        ll v = fac[i];\n        for (int j=0; j<SZ(pf); j++) {\n            ll u = pf[j];\n            ll z = __gcd(fm(v, u), K);\n            wk[i][j] = fid(z);\n            //cout << wk[i][j] << \' \';\n        }\n        //cout << endl;\n    }\n}\n\nconst int MN = 1111;\nconst int MF = 7777;\nconst ll INF = 1e18;\nconst int inf = 1e9;\nusing pii = pair<int, ll>;\npii dp[MN][MF];\nint bk[MN][MF];\n\n\n\npii operator + (const pii &p1, const pii &p2) {\n    return {p1.F+p2.F, p1.S+p2.S};\n}\n\nint32_t main() {\n    IOS;\n    lucky_test();\n    cin >> N >> K;\n    if (K == 1) {\n        ll mn = INF, mi;\n        for (int i=0; i<N; i++) {\n            ll x; cin >> x;\n            if (mn > x) {\n                mn = x;\n                mi = i;\n            }\n        }\n        cout << ""1\\n"" << mi+1 << endl;\n        return 0;\n    }\n    //cout << K << endl;\n    pre();\n    assert(fac[0] == 1);\n    assert(fac.back() == K);\n    for (int _=0; _<=N; _++) {\n        for (int i=0; i<SZ(fac)+5; i++) {\n            dp[_][i] = {inf, INF};\n            bk[_][i] = -1;\n        }\n    }\n    dp[0][0] = {0, 0};\n    \n    int Z = SZ(fac);\n    //cout << Z << endl;\n        //for (int j=0; j<Z; j++) {\n            //cout << dp[0][j] << \' \';\n        //}\n        //cout << endl;\n\n    for (int i=0; i<N; i++) {\n        ll x; cin >> x;\n        int he = i+1;\n        for (int j=0; j<Z; j++) {\n            if (dp[i][j] < dp[he][j]) {\n                dp[he][j] = dp[i][j];\n                bk[he][j] = j;\n                //if (he == N and j == Z-1) {\n                    //cout << i << \' \' << j << endl;\n                //}\n            }\n\n            int p = j;\n            ll y = x;\n            for (int q=0; q<SZ(pf); q++) {\n                ll pm = pf[q];\n                while (y % pm == 0) {\n                    //cout << p << \' \' << q << ""walk"" << endl;\n                    p = wk[p][q];\n                    //cout << p << endl;\n                    y /= pm;\n                }\n            }\n            //cout << j << \' \' << x << \' \' << p << endl;\n            if (dp[i][j] + pii(1, x) < dp[he][p]) {\n                dp[he][p] = dp[i][j] + pii(1, x);\n                bk[he][p] = j;\n                //if (he == N and p == Z-1) {\n                    //cout << i << \' \' << j << endl;\n                    //cout << dp[i][j] << endl;\n                //}\n            }\n\n        }\n\n        //for (int j=0; j<Z; j++) {\n            //cout << bk[he][j] << \' \';\n        //}\n        //cout << endl;\n    }\n\n    if (dp[N][Z-1].F >= inf) {\n        cout << -1 << endl;\n        return 0;\n    }\n    int bi = Z-1;\n    vector<int> ans;\n\n    int pos = N;\n    while (pos) {\n        int nx = bk[pos][bi];\n        if (nx != bi) {\n            ans.PB(pos);\n        }\n        bi = nx;\n        pos --;\n    }\n\n    reverse(ALL(ans));\n    cout << SZ(ans) << endl;\n    for (auto x: ans) cout << x << \' \';\n    cout << endl;\n\n    return 0;\n}\n\n']","['dp', 'number theory']",2600
https://codeforces.com//contest/1712/problem/C,C. Sort Zero,A Young BoyYou are given an array of n integers a 1 a 2 ldots a n In one operation you do the following Choose integer x For all i such that a i x do a i 0 assign 0 to a i Find the minimum number of operations required to sort the array in non decreasing order ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define int long long\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n\nint T,n,ans,i,j,k,a[N],c[N],pos[N],gg,tot; \nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tc[i]=0;pos[i]=0;\n\t\t}\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i],pos[a[i]]=max(i,pos[a[i]]);\n\t\t}\n\t\ta[0]=1e9;\n\t\tfor(i=n;~i;--i)if(a[i]<a[i-1]){gg=i-1;break;}\n\t\tif(gg==0){\n\t\t\tcout<<0<<""\\n"";\n\t\t}\n\t\telse{\n\t\t\ttot=0;\n\t\t\tfor(i=1;i<=n;++i){\n\t\t\t\tif(!c[a[i]])++tot,c[a[i]]=1,gg=max(gg,pos[a[i]]);\n\t\t\t\tif(i>=gg){cout<<tot<<""\\n"";break;}\n\t\t\t}\n\t\t}\n\t}\n}']","['greedy', 'sortings']",1100
https://codeforces.com//contest/1772/problem/A,A. A+B ,You are given an expression of the form a b where a and b are integers from 0 to 9 You have to evaluate it and print the result ,"['/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,a[N],k,res;\nvoid elixprep(){\n    \n}\nstring s;\nvoid elix()\n{\n    cin>>s;\n    cout<<s[0]+s[2]-96;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}\n//listen to trap music. it won\'t help']",['implementation'],800
https://codeforces.com//contest/1236/problem/A,A. Stones,Alice is playing with some stones Now there are three numbered heaps of stones The first of them contains a stones the second of them contains b stones and the third of them contains c stones Each time she can do one of two operations take one stone from the first heap and two stones from the second heap this operation can be done only if the first heap contains at least one stone and the second heap contains at least two stones take one stone from the second heap and two stones from the third heap this operation can be done only if the second heap contains at least one stone and the third heap contains at least two stones She wants to get the maximum number of stones but she doesn t know what to do Initially she has 0 stones Can you help her ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\ntypedef long long ll;\nint i;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int a,b,c;\n        cin >> a >> b >> c;\n        int res = 0;\n        for(int i = 0; i <= a && 2*i <= b; ++i) {\n            int newB = b-i-i;\n            int curr = 3*i;\n            curr +=3*min(newB, c/2);\n            res = max(res, curr);\n        }\n        cout << res << endl;\n    }\n}\n""]","['brute force', 'greedy', 'math']",800
https://codeforces.com//contest/1798/problem/F,F. Gifts from Grandfather Ahmed,Grandfather Ahmed s School has n 1 students The students are divided into k classes and s i students study in the i th class So s 1 s 2 ldots s k n 1 Due to the upcoming April Fools Day all students will receive gifts Grandfather Ahmed planned to order n 1 boxes of gifts Each box can contain one or more gifts He plans to distribute the boxes between classes so that the following conditions are satisfied Class number i receives s i boxes so that each student can open exactly one box The total number of gifts in the boxes received by the i th class should be a multiple of s i it should be possible to equally distribute the gifts among the s i students of this class Unfortunately Grandfather Ahmed ordered only n boxes with gifts the i th of which contains a i gifts Ahmed has to buy the missing gift box and the number of gifts in the box should be an integer between 1 and 10 6 Help Ahmed to determine how many gifts should the missing box contain and build a suitable distribution of boxes to classes or report that this is impossible ,"['#pragma GCC optimization(""O3"")\n#pragma GCC optimization(""Ofast,unroll-loops"")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline ""\\n""                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<"" ""; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<""{""; _print(p.first);cerr<<"",""; _print(p.second);cerr<<""}"";}\ntemplate<class T>void _print(vector<T> v) {cerr<<"" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(set<T> v) {cerr<<"" [ ""; for (T i:v){_print(i); cerr<<"" "";}cerr<<""]"";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< "" [ ""; for (T i:v){_print(i);cerr<<"" "";}cerr<<""]"";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<"" [ ""; for(auto i:v) {_print(i);cerr<<"" "";} cerr<<""]"";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n,k; cin>>n>>k;\n    vector<ll> a(n+5);\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    vector<ll> s(k+5,0);\n    for(ll i=1;i<=k;i++){\n        cin>>s[i];\n    }\n    vector<ll> skip(n+5,0);\n    vector<vector<ll>> ans;\n    ll already=0;\n    for(ll i=1;i<=k;i++){\n        ll len=s[i];\n        vector<vector<ll>> dp(len+5,vector<ll>(len+5,-1));\n        dp[0][0]=0;\n        for(ll pos=1;pos<=n;pos++){\n            if(skip[pos]){\n                continue;\n            }\n            for(ll freq=len-1;freq>=0;freq--){\n                for(ll rem=len-1;rem>=0;rem--){\n                    if(dp[freq][rem]==-1){\n                        continue; \n                    }\n                    if(dp[freq+1][(rem+a[pos])%len]!=-1){\n                        continue;\n                    }\n                    dp[freq+1][(rem+a[pos])%len]=pos; \n                }\n            }\n        }\n        vector<ll> now;\n        if(dp[len][0]!=-1){\n            ;\n        }\n        else{\n            assert(already==0); \n            for(ll rem=0;rem<len;rem++){\n                if(dp[len-1][rem]!=-1){\n                    dp[len][0]=n+1;\n                    a[n+1]=len-rem;\n                    break;  \n                }  \n            }\n            already=1;\n        }\n        ll rem=0;     \n        for(ll freq=len;freq>=1;freq--){\n            ll cur=dp[freq][rem];\n            now.push_back(a[cur]);\n            rem=(rem-a[cur])%len;\n            rem=(rem+len)%len;\n            skip[cur]=1;\n        }\n        ans.push_back(now);\n    }\n    cout<<a[n+1]<<nline;\n    for(auto it:ans){\n        for(auto i:it){\n            cout<<i<<"" "";\n        }\n        cout<<nline; \n    }\n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(""input.txt"", ""r"", stdin);                                              \n    freopen(""output.txt"", ""w"", stdout);  \n    freopen(""error.txt"", ""w"", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    //cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<""Time:""<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<""ms\\n""; \n}  ']","['dp', 'math', 'number theory']",2500
https://codeforces.com//contest/710/problem/F,F. String Set Queries,You should process queries over a set of strings Each query is one of three kinds Add a string to the set It is guaranteed that the string was not added before Delete a string from the set It is guaranteed that the string is in the set For the given string find the number of occurrences of the strings from the set If some string from has several occurrences in you should count all of them Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query of the third type Use functions in and in languages after each writing in your program ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300010;\n\nconst int MAGIC = 500;\n\nconst int LONGS = N / MAGIC + 10;\n\nchar foo[N];\n\nstring s[LONGS]; \nint cost[LONGS];\n\nint a[N][29];\nint value[N];\nint p[N];\n\nint main() {\n  int tt;\n  scanf(""%d"", &tt);\n  int n = 1;\n  int cnt = 0;\n  while (tt--) {\n    int type;\n    scanf(""%d %s"", &type, foo);\n    int len = strlen(foo);\n    if (type == 1 || type == 2) {\n      if (len <= MAGIC) {\n        int t = 1;\n        for (int j = 0; j < len; j++) {\n          int c = foo[j] - \'a\';\n          if (a[t][c] == 0) {\n            a[t][c] = ++n;\n          }\n          t = a[t][c];\n        }\n        value[t] += 3 - 2 * type;\n      } else {\n        s[cnt] = """";\n        for (int j = 0; j < len; j++) {\n          s[cnt] += foo[j];\n        }\n        s[cnt] += ""{"";\n        cost[cnt] = 3 - 2 * type;\n        cnt++;\n      }\n    } else {\n      long long ans = 0;\n      for (int j = 0; j < len; j++) {\n        int t = 1;\n        for (int k = j; k < len; k++) {\n          int c = foo[k] - \'a\';\n          if (a[t][c] == 0) {\n            break;\n          }\n          t = a[t][c];\n          ans += value[t];\n        }\n      }\n      for (int id = 0; id < cnt; id++) {\n        int long_len = s[id].length();\n        long_len--;\n        if (long_len > len) {\n          continue;\n        }\n        int k = 0;\n        p[1] = 0;\n        for (int i = 2; i <= long_len; i++) {\n          while (k > 0 && s[id][i - 1] != s[id][k]) {\n            k = p[k];\n          }\n          if (s[id][i - 1] == s[id][k]) {\n            k++;\n          }\n          p[i] = k;\n        }\n        k = 0;\n        for (int i = 1; i <= len; i++) {\n          while (k > 0 && foo[i - 1] != s[id][k]) {\n            k = p[k];\n          }\n          if (foo[i - 1] == s[id][k]) {\n            k++;\n          }\n          if (k == long_len) {\n            ans += cost[id];\n          }\n        }\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n']","['brute force', 'data structures', 'hashing', 'interactive', 'string suffix structures', 'strings']",2400
https://codeforces.com//contest/1249/problem/D1,D1. Too Many Segments  easy version , You are given n segments on the coordinate axis OX Segments can intersect lie inside each other and even coincide The i th segment is l i r i l i le r i and it covers all integer points j such that l i le j le r i The integer point is called if it is covered by than k segments Your task is to remove the minimum number of segments so that there are no points at all ,"['#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<\'0\'||c>\'9\');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>=\'0\'&&c<=\'9\');\n\treturn res;\n}\ntypedef pair<pair<int, int>, int> Point;\npriority_queue<Point> Q;\nPoint s[200010];\nvector<int> ans;\nint add[200010];\nint main() {\n\tint N=read(), K=read();\n\tfor(int i=1; i<=N; i++){\n\t\tint a=read(), b=read();\n\t\ts[i]=make_pair(make_pair(a, b), i);\n\t\tadd[a]++;\n\t\tadd[b+1]--;\n\t}\n\tsort(s+1, s+1+N);\n\tint now=0, ind=1;\n\tfor(int i=1; i<=200000; i++){\n\t\twhile(ind<=N && s[ind].first.first==i){\n\t\t\tint a = s[ind].first.first, b = s[ind].first.second;\n\t\t\tQ.push( make_pair(make_pair(b, a), s[ind].second) );\n\t\t\tind++;\n\t\t}\n\t\tnow+=add[i];\n\t\twhile(now>K){\n\t\t\tPoint t = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(t.first.first >= i){\n\t\t\t\tans.push_back(t.second);\n\t\t\t\tnow--;\n\t\t\t\tadd[t.first.first+1]++;\n\t\t\t}\n\t\t}\n\t\tif(ind==N+1)break;\n\t}\n\tprintf(""%d\\n"", ans.size());\n\tfor(auto a:ans){\n\t\tprintf(""%d "", a);\n\t}\n\treturn 0;\n}\n']",['greedy'],1800
https://codeforces.com//contest/869/problem/E,E. The Untended Antiquity,Koyomi is helping Oshino an acquaintance of his to take care of an open space around the abandoned Eikou Cram School building Oshino s makeshift residence The space is represented by a rectangular grid of cells arranged into rows and columns The th cell in the th row is denoted by Oshino places and removes barriers rectangular areas of cells Specifically an action denoted by means Oshino s placing barriers around a rectangle with two corners being and and sides parallel to squares sides Similarly means Oshino s removing barriers around the rectangle Sometimes Koyomi tries to walk from one cell to another carefully without striding over barriers in order to avoid damaging various items on the ground means that Koyomi tries to walk from to without crossing barriers And you re here to tell Koyomi the feasibility of each of his attempts ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nmap<pair<pair<int, int>, pair<int, int> >, int>g;\nint n, m, q;\nlong long c[2520][2520];\nvoid R(int x, int y, long long z) {\n\tfor (int i = x; i <= n; i += i & -i) {\n\t\tfor (int j = y; j <= m; j += j & -j) {\n\t\t\tc[i][j] += z;\n\t\t}\n\t}\n}\n\nlong long G(int x, int y) {\n\tlong long re = 0;\n\tfor (int i = x; i > 0; i -= i & -i) {\n\t\tfor (int j = y; j > 0; j -= j & -j) {\n\t\t\tre += c[i][j];\n\t\t}\n\t}\n\treturn re;\n}\n\nint rd() {\n\treturn rand() << 15 | rand();\n}\nint main() {\n\tscanf(""%d%d%d"", &n, &m, &q);\n\tsrand(time(0));\n\tfor (int i = 0; i < 011; i++) {\n\t\tsrand(rd());\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tint o, xa, xb, ya, yb;\n\t\tscanf(""%d%d%d%d%d"", &o, &xa, &ya, &xb, &yb);\n\t\tif (o == 1) {\n\t\t\tint u = rd();\n\t\t\tg[make_pair(make_pair(xa, ya), make_pair(xb, yb))] = u;\n\t\t\tR(xa, ya, u);\n\t\t\tR(xa, yb + 1, -u);\n\t\t\tR(xb + 1, ya, -u);\n\t\t\tR(xb + 1, yb + 1, u);\n\t\t} else if (o == 2) {\n\t\t\tint u = g[make_pair(make_pair(xa, ya), make_pair(xb, yb))];\n\t\t\tR(xa, ya, -u);\n\t\t\tR(xa, yb + 1, u);\n\t\t\tR(xb + 1, ya, u);\n\t\t\tR(xb + 1, yb + 1, -u);\n\t\t} else {\n\t\t\tlong long va = G(xa, ya);\n\t\t\tlong long vb = G(xb, yb);\n\t\t\tif (va == vb) {\n\t\t\t\tprintf(""Yes\\n"");\n\t\t\t} else {\n\t\t\t\tprintf(""No\\n"");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']","['data structures', 'hashing']",2400
https://codeforces.com//contest/975/problem/A,A. Aramic script,In Aramic language words can only represent objects Words in Aramic have special properties A word is a if it does not contain the same letter more than once A and all its permutations represent the same object The x of a word y is the word that contains all letters that appear in y in a way that each letter appears once For example the of is the of is Any word in Aramic represents the same object as its You have an ancient script in Aramic What is the number of mentioned in the script ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define fr(x, y, z) for(int x=y;x<z;x++)\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppl;\n\nset<int> s;\n\nint main(){\n    int n ;\n    cin>>n;\n    fr(i,0,n){\n        string ss;\n        cin>>ss;\n        int aa=0;\n        for(auto c:ss){\n            aa|=(1<<(c-'a'));\n        }\n        s.insert(aa);\n    }\n    cout<<s.size()<<endl;\n    \n}""]","['implementation', 'strings']",900
https://codeforces.com//contest/370/problem/E,E. Summer Reading,At school Vasya got an impressive list of summer reading books Unlike other modern schoolchildren Vasya loves reading so he read some book each day of the summer As Vasya was reading books he was making notes in the Reader s Diary Each day he wrote the orderal number of the book he was reading The books in the list are numbered starting from 1 and Vasya was reading them in the order they go in the list Vasya never reads a new book until he finishes reading the previous one Unfortunately Vasya wasn t accurate and some days he forgot to note the number of the book and the notes for those days remained empty As Vasya knows that the literature teacher will want to check the Reader s Diary so he needs to restore the lost records Help him do it and fill all the blanks Vasya is sure that he spends at least two and at most five days for each book Vasya finished reading all the books he had started Assume that the reading list contained many books So many in fact that it is impossible to read all of them in a summer If there are multiple valid ways to restore the diary records Vasya prefers the one that shows the maximum number of read books ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int N = 222222;\n\nint lower[N], upper[N];\nint n, a[N], le[N], ri[N];\n\nint main() {\n    \n    scanf(""%d"", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(""%d"", &a[i]);\n    }\n    lower[0] = upper[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        le[i] = n + 1;\n        ri[i] = -1;\n    }\n    \n    int maxNum = -1;\n    \n    for(int i = 1; i <= n; i++) \n        if (a[i]) {\n            if (a[i] < 1 || a[i] > n) {\n                printf(""-1\\n"");\n                return 0;\n            }\n            int x = a[i];\n            le[x] = min(le[x], i);\n            ri[x] = max(ri[x], i);\n            maxNum = max(maxNum, a[i]);\n        }\n    \n    if (maxNum == -1) {\n        if (n < 2) {\n            printf(""-1\\n"");\n        } else {\n            printf(""%d\\n"", n / 2);\n            for(int i = 1; i <= n / 2; i++) {\n                a[i * 2 - 1] = a[i * 2] = i;\n            }\n            if (n % 2 == 1)\n                a[n] = a[n - 1];\n            for(int i = 1; i <= n; i++) {\n                printf(""%d%c"", a[i], i == n ? \'\\n\' : \' \');\n            }\n        }\n        \n        return 0;\n    }\n    \n    for(int i = 1; i <= n; i++) {\n        if (ri[i] == -1) {\n            lower[i] = lower[i - 1] + 2;\n            upper[i] = upper[i - 1] + 5;\n        } else {\n            int tmp = ri[i] - le[i] + 1;\n            if (tmp > 5) {\n                printf(""-1\\n"");\n                return 0;\n            }\n            \n            if (lower[i - 1] >= le[i] || ri[i] - upper[i - 1] > 5) {\n                printf(""-1\\n"");\n                return 0;\n            }\n            \n            lower[i] = max(ri[i], lower[i - 1] + 2);\n            upper[i] = min(le[i] + 4, upper[i - 1] + 5);\n        }\n    }\n    \n    int ans = 0;\n    \n    for(int i = maxNum; i <= n; i++) {\n        if (lower[i] <= n && upper[i] >= n)\n            ans = i;\n    }\n    \n    if (ans == 0) {\n        printf(""-1\\n"");\n        return 0;\n    }\n    \n    printf(""%d\\n"", ans);\n    \n    int nn = n;\n    \n    for(int i = ans; i >= 1; i--) {\n        for(int j = 2; j <= 5; j++) {\n            if (ri[i] != -1 && le[i] < nn - j + 1)\n                continue;\n            int tmp = nn - j;\n            bool flag = true; \n            if (lower[i - 1] <= tmp && tmp <= upper[i - 1]) {\n                for(int k = tmp + 1; k <= nn; k++)\n                    if (a[k] && a[k] != i)\n                        flag = false;\n                if (!flag)\n                    continue;\n                for(int k = tmp + 1; k <= nn; k++)\n                    a[k] = i;\n                nn = tmp;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 1; i <= n; i++) {\n        printf(""%d%c"", a[i], i == n ? \'\\n\' : \' \');\n    }\n    \n    return 0;\n} ']","['dp', 'greedy']",2500
https://codeforces.com//contest/759/problem/D,D. Bacterial Melee,Julia is conducting an experiment in her lab She placed several luminescent bacterial colonies in a horizontal testtube Different types of bacteria can be distinguished by the color of light they emit Julia marks types of bacteria with small Latin letters The testtube is divided into consecutive regions Each region is occupied by a single colony of a certain bacteria type at any given moment Hence the population of the testtube at any moment can be described by a string of Latin characters Sometimes a colony can decide to conquer another colony in one of the adjacent regions When that happens the attacked colony is immediately eliminated and replaced by a colony of the same type as the attacking colony while the attacking colony keeps its type Note that a colony can only attack its neighbours within the boundaries of the testtube At any moment at most one attack can take place For example consider a testtube with population There are six options for an attack that may happen next the first colony attacks the second colony the resulting population is the result is the result is the result is note that the result is the same as the first option or the population does not change The pattern of attacks is rather unpredictable Julia is now wondering how many different configurations of bacteria in the testtube she can obtain after a sequence of attacks takes place it is possible that no attacks will happen at all Since this number can be large find it modulo ,"['#include <cstdio>\n\nconst int p = 1000000007;\n\nchar a[5005];\nint c[5005][26];\nint d[5005];\n\nint main() {\n\tint i, j, k, n;\n\tscanf(""%d%s"", &n, a + 1);\n\td[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tk = (d[j - 1] - c[j][a[i] - \'a\'] + p) % p;\n\t\t\tc[j][a[i] - \'a\'] = (c[j][a[i] - \'a\'] + k) % p;\n\t\t\td[j] = (d[j] + k) % p;\n\t\t}\n\t}\n\tprintf(""%d"", d[n]);\n}']",['dp'],2400
https://codeforces.com//contest/260/problem/D,D. Black and White Tree,The board has got a painted tree graph consisting of nodes Let us remind you that a non directed graph is called a tree if it is connected and doesn t contain any cycles Each node of the graph is painted black or white in such a manner that there aren t two nodes of the same color connected by an edge Each edge contains its value written on it as a non negative integer A bad boy Vasya came up to the board and wrote number near each node the sum of values of all edges that are incident to this node Then Vasya removed the edges and their values from the board Your task is to restore the original tree by the node colors and numbers ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <initializer_list>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#define DEBUG\n#endif\n\n#define oo 0x3F3F3F3F\n#ifdef DEBUG\n#define cvar(x) cerr << ""<"" << #x << "": "" << x << "">""\n#define evar(x) cvar (x) << endl\ntemplate<class T> void DISP(const char *s, T x, int n) {cerr << ""["" << s << "": ""; for (int i = 0; i < n; ++i) cerr << x[i] << "" ""; cerr << ""]"" << endl;}\n#define disp(x,n) DISP(#x "" to "" #n, x, n)\n#else\n#define cvar(...) ({})\n#define evar(...) ({})\n#define disp(...) ({})\n#endif\n#define fst first\n#define snd second\n#define PB push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef unsigned int uint;\ntypedef long long int64;\ntypedef unsigned long long uint64;\ntypedef long double real;\n\nint64 pow(int64 b, int64 e, int64 m) { int64 t = 1; for (; e; e >>= 1, b = b * b % m) e & 1 ? t = t * b % m : 0; return t; }\ntemplate<class T> inline bool chkmin(T &a, T b) {return a > b ? a = b, true : false;}\ntemplate<class T> inline bool chkmax(T &a, T b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline T sqr(T x) {return x * x;}\ntemplate <typename T> T gcd(T x, T y) {for (T t; x; t = x, x = y % x, y = t); return y; }\n\ntemplate<class edge> struct Graph\n{\n  vector<vector<edge> > adj;\n  Graph(int n) {adj.clear (); adj.resize (n + 5);}\n  Graph() {adj.clear (); }\n  void resize(int n) {adj.resize (n + 5); }\n  void add(int s, edge e){adj[s].push_back (e);}\n  void del(int s, edge e) {adj[s].erase (find (iter (adj[s]), e)); }\n  vector<edge>& operator [](int t) {return adj[t];}\n};\n\nset<pair<int, int>, greater<pair<int, int>>> W, B;\n\nint main ()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""D.in"" , ""r"", stdin);\n\tfreopen(""D.out"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio (false);\n\n\tint n;\n\t\n\tcin >> n;\n\tfor (int i = 1, c, s; i <= n; ++i) {\n\t\tcin >> c >> s;\n\t\tif (c == 0) W.insert(make_pair(s, i));\n\t\telse B.insert(make_pair(s, i));\n\t}\n\tvector<pair<pair<int, int>, int>> ans;\n\n\tpair<int, int> disX, disY;\n\tfor (; !W.empty() && !B.empty(); ) {\n\t\tpair<int, int> x = *W.begin(), y = *B.begin();\n\t\tW.erase(x), B.erase(y);\n\t\t\n\t\tint v = min(x.fst, y.fst);\n\t\tans.push_back(make_pair(make_pair(x.snd, y.snd), v));\n\t\tx.fst -= v, y.fst -= v;\n\t\tif (y.fst || (!x.fst && !y.fst && SZ(W) > SZ(B)))\n\t\t\tB.insert(y), disY = y;\n\t\telse\n\t\t\tW.insert(x), disX = x;\n\t}\n\tfor (auto x : ans)\n\t\tcout << x.fst.fst << "" "" << x.fst.snd << "" "" << x.snd << endl;\n\n\treturn 0; \n}\n']","['constructive algorithms', 'dsu', 'graphs', 'greedy', 'trees']",2100
https://codeforces.com//contest/1141/problem/F1,F1. Same Sum Blocks  Easy ,You are given an array of integers a 1 a 2 dots a n A is a sequence of contiguous consecutive elements a l a l 1 dots a r 1 le l le r le n Thus a block is defined by a pair of indices l r Find a set of blocks l 1 r 1 l 2 r 2 dots l k r k such that They do not intersect i e they are disjoint Formally for each pair of blocks l i r i and l j r j where i neq j either r i l j or r j l i For each block the sum of its elements is the same Formally a l 1 a l 1 1 dots a r 1 a l 2 a l 2 1 dots a r 2 dots a l k a l k 1 dots a r k The number of the blocks in the set is maximum Formally there does not exist a set of blocks l 1 r 1 l 2 r 2 dots l k r k satisfying the above two requirements with k k Write a program to find such a set of blocks ,"[""#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nconst ll MAXN = 2000;\n\nll n, a[MAXN], pr[MAXN];\nmap<ll, vector< pair<ll, ll> >  > mp;\n\nbool cmp(pair<ll, ll> a, pair<ll, ll> b){\n    return a.second < b.second;\n}\n\nvector<pair<ll, ll> > get_ans(vector<pair<ll, ll> > & v){\n    sort(v.begin(), v.end(), cmp);\n    vector<pair<ll, ll> > ans;\n    ll len = -20;\n\n    for(int i = 0; i < v.size(); ++i){\n        if(v[i].first > len){\n            len = v[i].second;\n            ans.pb(v[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n        pr[i] = pr[i-1] + a[i];\n    }\n\n    for(int i = 1; i <= n; ++i){\n        for(int j = i; j <= n; ++j){\n            mp[pr[j] - pr[i-1]].pb({i, j});\n        }\n    }\n\n    ll ans = 0;\n    vector<pair<ll, ll> > vans;\n\n    for(auto i : mp){\n        vector<pair<ll, ll> > v = (i).second;\n        vector<pair<ll, ll> > cur = get_ans(v);\n        if(cur.size() > ans){\n            ans = cur.size();\n            vans = cur;\n        }\n    }\n\n    cout << ans << '\\n';\n    for(auto i : vans){\n        cout << i.first << ' ' << i.second << '\\n';\n    }\n\n    return 0;\n}\n""]",['greedy'],1900
https://codeforces.com//contest/902/problem/A,A. Visiting a Friend,Pig is visiting a friend Pig s house is located at point and his friend s house is located at point on an axis Pig can use teleports to move along the axis To use a teleport Pig should come to a certain point where the teleport is located and choose where to move for each teleport there is the rightmost point it can move Pig to this point is known as the limit of the teleport Formally a teleport located at point with limit can move Pig from point to any point within the segment including the bounds Determine if Pig can visit the friend using teleports only or he should use his car ,"['#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\n\n\n\ntemplate <class T>\nvoid upd(T&a,T b) {\n    a = max(a,b);\n}\n\nint n,m;\nint dp[1001];\nint main() {\n    cin>>n>>m;\n    vector<PII>v;\n    REP(i,0,n){\n        int a,b;\n        cin>>a>>b;\n        v.PB(MP(a,b));\n    }\n    dp[0] = 1;\n    REP(i,0,n){\n        REP(j,0,n){\n            if(dp[v[j].fi]){\n                REP(k,v[j].fi,v[j].se+1){\n                    dp[k] = 1;\n                }\n            }\n        }\n    }\n    if(dp[m])cout<<""YES"";else cout<<""NO"";\n    return 0;\n}\n\n\n']","['greedy', 'implementation']",1100
https://codeforces.com//contest/707/problem/A,A. Brain s Photos,Small but very brave mouse Brain was not accepted to summer school of young villains He was upset and decided to postpone his plans of taking over the world but to become a photographer instead As you may know the coolest photos are on the film because you can specify the hashtag film for such Brain took a lot of colourful pictures on colored and black and white film Then he developed and translated it into a digital form But now color and black and white photos are in one folder and to sort them one needs to spend more than one hour As soon as Brain is a photographer not programmer now he asks you to help him determine for a photo whether it is colored or black and white Photo can be represented as a matrix sized and each element of the matrix stores a symbol indicating corresponding pixel color There are only colors C cyan M magenta Y yellow W white G grey B black The photo is considered black and white if it has only white black and grey pixels in it If there are any of cyan magenta or yellow pixels in the photo then it is considered colored ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\tint n,m;\n\tscanf(""%d%d"", &n, &m);\n\tbool color = 0;\n\tfor(int i = 1;i <= n;i ++)\n\t\tfor(int j = 1;j <= m;j ++)\n\t\t{\n\t\t\tchar c;\n\t\t\twhile (c = getchar(),c < \'A\' || c > \'Z\');\n\t\t\tif (c == \'C\' || c == \'Y\' || c == \'M\') color = 1;\n\t\t}\n\tif (color) printf(""#Color\\n""); else\n\t\tprintf(""#Black&White\\n"");\n}\n']",['implementation'],800
https://codeforces.com//contest/525/problem/A,A. Vitaliy and Pie,After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie But it s not that simple Vitaly is in the first room of the house with room located in a line and numbered starting from one from left to right You can go from the first room to the second room from the second room to the third room and so on you can go from the th room to the th room Thus you can go to room only from room The potato pie is located in the th room and Vitaly needs to go there Each pair of consecutive rooms has a door between them In order to go to room from room you need to open the door between the rooms with the corresponding key In total the house has several types of doors represented by uppercase Latin letters and several types of keys represented by lowercase Latin letters The key of type can open the door of type if and only if and are the same letter written in different cases For example key can open door Each of the first rooms contains exactly one key of some type that Vitaly can use to get to next rooms Once the door is open with some key Vitaly won t get the key from the keyhole but he will immediately run into the next room In other words each key can open no more than one door Vitaly realizes that he may end up in some room without the key that opens the door to the next room Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room Given the plan of the house Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room which has a delicious potato pie Write a program that will help Vitaly find out this number ,"['#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << "" = "" << ccc << endl;\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tn,s[500];\n\nint main(){\n\tcin >> n;\n\tint\tres = 0;\n\tFP( i,1,n-1 ){\n\t\tchar\ta,b;\n\t\tscanf("" %c %c"",&a,&b);\n\t\ts[a]++;\n\t\tif( s[b-\'A\'+\'a\']==0 )\tres++;\n\t\telse{\t\n\t\t\ts[b-\'A\'+\'a\']--;\n\t\t}\n\t}\n\tcout << res << endl;\n}\n']","['greedy', 'hashing', 'strings']",1100
https://codeforces.com//contest/1713/problem/D,D. Tournament Countdown,There was a tournament consisting of 2 n contestants The 1 st contestant competed with the 2 nd the 3 rd competed with the 4 th and so on After that the winner of the first match competed with the winner of second match etc The tournament ended when there was only one contestant left who was declared the winner of the tournament Such a tournament scheme is known as the single elimination tournament You don t know the results but you want to find the winner of the tournament In one query you select two integers a and b which are the indices of two contestants The jury will return 1 if a won more matches than b 2 if b won more matches than a or 0 if their number of wins was equal Find the winner in no more than left lceil frac 1 3 cdot 2 n 1 right rceil queries Here lceil x rceil denotes the value of x rounded up to the nearest integer Note that the tournament is long over meaning that the results are fixed and do not depend on your queries ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vi arr(1<<n);\n    iota(all(arr), 1);\n\n    while (sz(arr) > 2) {\n        vi next;\n\n        for (int i = 0; i < sz(arr); i += 4) {\n            cout << ""? "" << arr[i] << "" "" << arr[i+2] << endl;\n            int res;\n            cin >> res;\n\n            if (res == 0) {\n                next.pb(arr[i+1]);\n                next.pb(arr[i+3]);\n            }\n            else if (res == 1) {\n                next.pb(arr[i]);\n                next.pb(arr[i+3]);\n            }\n            else {\n                next.pb(arr[i+2]);\n                next.pb(arr[i+1]);\n            }\n        }\n        arr = next;\n    }\n    cout << ""? "" << arr[0] << \' \' << arr[1] << endl;\n    int res;\n    cin >> res;\n    if (res == 1) {\n        cout << ""! "" << arr[0] << endl;\n    }\n    else {\n        cout << ""! "" << arr[1] << endl;\n    }\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""input.in"", ""r"", stdin);\n    // freopen(""input.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}']","['constructive algorithms', 'greedy', 'interactive', 'number theory', 'probabilities']",1800
https://codeforces.com//contest/592/problem/D,D. Super M,Ari the monster is not an ordinary monster She is the hidden identity of Super M the Byteforces superhero Byteforces is a country that consists of cities connected by bidirectional roads Every road connects exactly two distinct cities and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads There are cities being attacked by humans So Ari we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans Super M can pass from one city to another only using the given roads Moreover passing through one road takes her exactly one kron the time unit used in Byteforces However Super M is not on Byteforces now she is attending a training camp located in a nearby country Codeforces Fortunately there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces The way back is too long so for the purpose of this problem teleportation is used exactly once You are to help Super M by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time measured in krons Also provide her with this time so she can plan her way back to Codeforces ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define sz(x) ((int) (x).size())\n#define X first\n#define Y second\n#define TRACE(x) cerr << #x << "" : "" << x << endl\n#define _ << "" "" <<\n\n#define MAX (123456 + 100)\nvector <int> adj[MAX];\nint N, M;\nbool mark[MAX];\nvector <int> goals;\n\nint DFS(int u, int par) {\n\tint ret = -1;\n\tif (mark[u]) ret = 0;\n\tfor (int v : adj[u]) if (v != par) {\n\t\tint child = DFS(v, u);\n\t\tif (child != -1) {\n\t\t\tif (ret == -1) ret = child + 2;\n\t\t\telse ret += child + 2;\n\t\t}\n\t}\n\treturn ret;\n}\n\npii getFar(int u, int par, int level) {\n\tpii ret = {-1, 0};\n\tif (mark[u]) ret = {u, level};\n\tfor (int v : adj[u]) if (v != par) {\n\t\tpii child = getFar(v, u, level + 1);\n\t\tif ((ret.X == -1) || (ret.Y < child.Y) || (ret.Y == child.Y && ret.X > child.X)) ret = child;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef _LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tcin >> N >> M;\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u; cin >> u;\n\t\tu--;\n\t\tmark[u] = true;\n\t\tgoals.push_back(u);\n\t}\n\n\tif (M == 1) cout << goals[0] + 1 << endl << 0 << endl;\n\telse {\n\t\tint s = DFS(goals[0], -1);\n\t\t// TRACE(s);\n\t\tpii far_away = getFar(goals[0], -1, 0);\n\t\t// TRACE(far_away.X _ far_away.Y);\n\t\tpii far_far_away = getFar(far_away.X, -1, 0);\n\t\t// TRACE(far_far_away.X _ far_far_away.Y);\n\t\tcout << min(far_away.X, far_far_away.X) + 1 << endl;\n\t\tcout << s - far_far_away.Y << endl;\n\t}\n\n\n\n\treturn 0;\n}\n']","['dfs and similar', 'dp', 'graphs', 'trees']",2200
https://codeforces.com//contest/892/problem/B,B. Wrath,There are guilty people in a line the th of them holds a claw with length The bell rings and every person kills some of people in front of him All people kill others at the same time Namely the th person kills the th person if and only if and You are given lengths of the claws You need to find the total number of alive people after the bell rings ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint a[1000005];\n\nint main(void) {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> a[i], a[i] = min(a[i] + 1, i);\n    int ans = 0, cur_alive = n;\n    for (int i = n; i >= 1; --i) {\n        if (cur_alive >= i) ++ans;\n        cur_alive = min(cur_alive, i - a[i]);\n    }\n    cout << ans << endl;\n}\n']","['greedy', 'implementation', 'two pointers']",1200
https://codeforces.com//contest/1244/problem/G,G. Running in Pairs,Demonstrative competitions will be held in the run up to the 20NN Berlatov Olympic Games Today is the day for the running competition Berlatov team consists of 2n runners which are placed on two running tracks n runners are placed on each track The runners are numbered from 1 to n on each track The runner with number i runs through the entire track in i seconds The competition is held as follows first runners on both tracks start running at the same time when the slower of them arrives at the end of the track second runners on both tracks start running and everyone waits until the slower of them finishes running and so on until all n pairs run through the track The organizers want the run to be as long as possible but if it lasts for more than k seconds the crowd will get bored As the coach of the team you may choose any order in which the runners are arranged on each track but you can t change the number of runners on each track or swap runners between different tracks You have to choose the order of runners on each track so that the duration of the competition is as long as possible but does not exceed k seconds Formally you want to find two permutations p and q both consisting of n elements such that sum sum limits i 1 n max p i q i is maximum possible but does not exceed k If there is no such pair report about it ,"['#include <bits/stdc++.h>\nusing namespace std;\nint ans[1000010], n;\nlong long k;\nint main() {\n    cin >> n >> k;\n    if(1ll * n * (n + 1) / 2 > k) return puts(""-1""), 0;\n    long long _max = 0;\n    for(int i = 1; i <= n; i++) _max += max(i, n - i + 1);\n    if(_max < k) k = _max;\n    cout << k << endl;\n    for(int i = 1; i <= n; i++) ans[i] = i, printf(""%d%c"", i, "" \\n""[i == n]);\n    k -= 1ll * n * (n + 1) / 2;\n    for(int i = 1; ; i++) {\n        int now = n - 2 * i + 1;\n        if(k <= now || k == 0) {\n            swap(ans[i], ans[i + k]);\n            for(int i = 1; i <= n; i++) printf(""%d%c"", ans[i], "" \\n""[i == n]);\n            return 0;\n        }\n        else k -= now, swap(ans[i], ans[n - i + 1]);\n    }\n}']","['constructive algorithms', 'greedy', 'math']",2400
https://codeforces.com//contest/1405/problem/B,B. Array Cancellation,You re given an array a of n integers such that a 1 a 2 cdots a n 0 In one operation you can choose two indices i and j 1 le i j le n decrement a i by one and increment a j by one If i j this operation is free otherwise it costs one coin How many coins do you have to spend in order to make all elements equal to 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define fef(i,a,b) for(ll i=a;i<=b;i++)\n#define rer(i,a,b) for(ll i=b;i>=a;i--)\n#define wew while(true)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n#define fio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define nfio cin.tie(0);cout.tie(0)\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define ord(a,b,c) ((a>=b)and(b>=c))\n#define MOD (ll(1000000007))\n#define MAX 300001\n#define mag 320\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define X first\n#define Y second\n#define pow2(x) (ll(1)<<x)\n#define pii pair<int,int>\n#define piii pair<int,pii>\n#define For(i,__,___) for(int i=__;i<=___;i++)\n#define Rep(i,__,___) for(int i=__;i>=___;i--)\n#define ordered_set tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update>\n#define endl ""\\n""\n#define bi BigInt\ntypedef long long ll;\n//---------END-------//\nconst int maxn = 1e5 + 17;\n\nint a[maxn];\n\nint main(){\n    fio;\n    int t;\n    cin >> t;\n    while (t--){\n        int n;\n        cin >> n;\n        For(i, 1, n){\n            cin >> a[i];\n        }\n        long long ans = 0, sum = 0;\n        For(i, 1, n){\n            sum += a[i];\n            ans = min(ans, sum);\n        }\n        cout << -ans << endl;\n    }\n}']","['constructive algorithms', 'implementation']",1000
https://codeforces.com//contest/27/problem/E,E. Number With The Given Amount Of Divisors,Given the number find the smallest positive integer which has exactly divisors It is guaranteed that for the given the answer will not exceed ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<list>\n#include<set>\n#include<queue>\n#include<cassert>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define LET(x,a) \t__typeof(a) x(a)\n#define IFOR(i,a,b) \tfor(LET(i,a);i!=(b);++i)\n#define EACH(it,v)  \tIFOR(it,v.begin(),v.end())\n#define FOR(i,a,b)  \tfor(int i=(int)(a) ; i < (int)(b);++i)\n#define REP(i,n) \tFOR(i,0,n)\n#define PB\t\tpush_back\n#define MP \t\tmake_pair\n#define EPS\t\t1e-9\n#define INF 2000000000\n\ntypedef vector<int>\tVI;\ntypedef long long\tLL;\ntypedef pair<int,int>\tPI;\n\nLL min1;\nLL primes[]={2,3,5,7,11,13,17,19,23,29,31,37};\nvector<LL> factors;\n\nvoid solve(int n,int lastIndex,LL cur,int index){\n\tif(cur>min1||cur<0)return;\n\tif(n==1){\n\t\tmin1 = cur;\n\t\treturn;\n\t}\n\tLL curPrime = primes[index];\n\tfor(int i = lastIndex;i>=0;i--){\n\t\tif(n%factors[i]==0){\n\t\t\tLL newCur = cur;\t\n\t\t\tREP(j,factors[i]-1){\n\t\t\t\tnewCur*=curPrime;\n\t\t\t\tif(newCur>min1)break;\n\t\t\t}\n\t\t\tsolve(n/factors[i],i,newCur,index+1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tLL n;cin>>n;\n\tmin1 = 1;\n\tLL tmp = n;\n\tVI div;\n\tfor(int i=2;i<=tmp;i++){\n\t\twhile(tmp%i==0){\n\t\t\ttmp/=i;\n\t\t\tdiv.PB(i);\n\t\t}\n\t}\n\tfor(int i = div.size()-1;i>=0;i--){\n\t\tint  p = div[i];\n\t\tLL mul = primes[div.size()-1-i],cur=1;\n\t\tREP(j,p-1)cur*=mul;\n\t\tmin1*=cur;\n\t}\n\tfactors.clear();\n\tFOR(i,2,64)if(n%i==0){\n\t\tfactors.PB(i);\n\t}\n\tsolve(n,factors.size()-1,1,0);\n\tcout<<min1<<endl;\n\treturn 0;\n}\n']","['brute force', 'dp', 'number theory']",2000
https://codeforces.com//contest/899/problem/F,F. Letters Removing,Petya has a string of length consisting of small and large English letters and digits He performs operations Each operation is described with two integers and and a character Petya removes from the string all characters on positions between and inclusive It s obvious that the length of the string remains the same or decreases after each operation Find how the string will look like after Petya performs all operations ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int M=(int)2e5+5;\nset<int>st[128];\nset<int>::iterator it,it1;\nchar S[M],A[5];\nint n,m;\nint mark[M];\nint val[M*4];\nvoid build(int L,int R,int p){\n\tval[p]=R-L+1;\n\tif(L==R)return;\n\tint mid=(L+R)>>1;\n\tbuild(L,mid,p<<1),build(mid+1,R,p<<1|1);\n}\nvoid update(int L,int R,int p,int x){\n\tval[p]--;\n\tif(L==R)return;\n\tint mid=(L+R)>>1;\n\tif(mid>=x)update(L,mid,p<<1,x);\n\telse update(mid+1,R,p<<1|1,x);\n}\nint query(int L,int R,int p,int v){\n\tif(L==R)return L;\n\tint mid=(L+R)>>1;\n\tif(val[p<<1]>=v)return query(L,mid,p<<1,v);\n\telse return query(mid+1,R,p<<1|1,v-val[p<<1]);\n}\nint main(){\n\tscanf(""%d %d"",&n,&m);\n\tbuild(1,n,1);\n\tscanf(""%s"",S+1);\n\tfor(int i=1;i<=n;i++)st[(int)S[i]].insert(i);\n\tfor(int i=1,l,r,x;i<=m;i++){\n\t\tscanf(""%d %d"",&l,&r);\n\t\tl=query(1,n,1,l);\n\t\tr=query(1,n,1,r);\n\t\tscanf(""%s"",A);\n\t\tx=A[0];\n\t\tfor(it=st[x].lower_bound(l);it!=st[x].end()&&(*it)<=r;){\n\t\t\tit1=it;\n\t\t\tupdate(1,n,1,(*it1));\n\t\t\tit++;\n\t\t\tst[x].erase(it1);\n\t\t}\n\t}\n\tfor(int i=0;i<128;i++)\n\t\tfor(it=st[i].begin();it!=st[i].end();it++)\n\t\t\tmark[(*it)]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(mark[i])\n\t\t\tputchar(S[i]);\n\tputchar(\'\\n\');\n\treturn 0;\n}\n']","['data structures', 'strings']",2100
https://codeforces.com//contest/1256/problem/E,E. Yet Another Division Into Teams,There are n students at your university The programming skill of the i th student is a i As a coach you want to divide them into teams to prepare them for the upcoming ICPC finals Just imagine how good this university is if it has 2 cdot 10 5 students ready for the finals Each team should consist of Each student should belong to The of a team is the difference between the programming skill of some student that belongs to this team and the programming skill of some student that belongs to this team in other words if the team consists of k students with programming skills a i 1 a i 2 dots a i k then the of this team is max limits j 1 k a i j min limits j 1 k a i j The total is the sum of of all teams formed Your task is to minimize the total of the division of students and find the optimal way to divide the students ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXA=3e5;\nint n,N,b[MAXA],c[MAXA];\nlong long f[MAXA],a[MAXA];\nint mysort(int x,int y){\n    return a[x]<a[y];\n}\nint main(){\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++) scanf(""%lld"",&a[i]),c[i]=i;\n    sort(c+1,c+n+1,mysort);\n    for(int i=1;i<=n;i++){\n\tf[i]=1e18;\n\tfor(int j=3;j<=min(6,i);j++){\n\t    f[i]=min(f[i],f[i-j]+a[c[i]]-a[c[i-j+1]]);\n\t}\n    }\n    for(int i=n;i;){\n\tfor(int j=3;j<=min(6,i);j++)\n\t    if(f[i]==f[i-j]+a[c[i]]-a[c[i-j+1]]){\n\t\t++N;\n\t\tfor(int k=1;k<=j;k++) b[c[i-k+1]]=N;\n\t\ti=i-j;\n\t\tbreak;\n\t    }\n    }\n    printf(""%lld %d\\n"",f[n],N);\n    for(int i=1;i<=n;i++) printf(""%d "",b[i]);\n}']","['dp', 'greedy', 'sortings']",2000
https://codeforces.com//contest/1749/problem/F,F. Distance to the Path,You are given a tree consisting of n vertices Initially each vertex has a value 0 You need to perform m queries of two types You are given a vertex index v Print the value of the vertex v You are given two vertex indices u and v and values k and d d le 20 You need to add k to the value of each vertex such that the distance from that vertex to the path from u to v is less than or equal to d The between two vertices x and y is equal to the number of on the path from x to y For example the distance from x to x itself is equal to 0 The distance from the vertex v to some path from x to y is equal to the minimum among distances from v to any vertex on the path from x to y ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\ntemplate<typename T>\nstruct HLD{\n  using D=long long;\n  int n;\n  vector<int>sz;//部分木サイズ\n  vector<D>dep;\n  vector<int>par;\n  vector<int>head;\n  Graph<T> &g;//隣接リスト\n  vector<edge<T>>edges;//データ構造に乗せるedge列\n  vector<int>in,out;//[in,out)で部分木、[ina,inb]でa~bのパス(aが上)\n  vector<int>comp;//連結成分の根\n  //inは頂点のindexを表す。また、edge列の下側の頂点である\n  HLD(Graph<T> &g,int r=-1):g(g),n(g.size()){\n    hld_build(r);\n  }\n  void hld_build(int root = -1){\n    in.assign(n,-1);out.assign(n,-1);dep.assign(n,0);\n    par.assign(n,-1);head.assign(n,-1);sz.assign(n,-1);comp.assign(n,-1);\n    edges.assign(n,edge<T>());\n    if(root == -1){//根がどこでも良い場合(森でも可)\n      for(int i=0;i<n;i++){\n        if(sz[i] == -1){\n          head[i] = i;\n          dfs_sz(i, 0, i);\n          dfs_hld(i);\n        }\n      }\n    }\n    else{\n      head[root] = root;\n      dfs_sz(root, 0, root);\n      dfs_hld(root);\n    }\n  }\n  void dfs_sz(int k, D d,int r){\n    sz[k] = 1;\n    comp[k] = r;\n\tdep[k] = d;\n    for(auto &e: g[k]){\n      if(e.to == par[k])continue;\n      par[e.to] = k;\n      dfs_sz(e.to, d+e.cost, r);\n      sz[k] += sz[e.to];\n      if(sz[e.to] > sz[g[k][0].to])swap(e, g[k][0]);\n    }\n  }\n  int time = 0;\n  void dfs_hld(int k){\n    in[k] = time++;\n    for(auto e:g[k]){\n      if(e.to == par[k])continue;\n      head[e.to] = (e.to == g[k][0].to ? head[k]: e.to);\n      edges[time] = e;\n      dfs_hld(e.to);\n    }\n    out[k] = time;\n  }\n  int lca(int p,int q){\n    while(1){\n      if(in[p] < in[q])swap(p,q);\n      if(head[p] == head[q])return q;\n      p = par[head[p]];\n    }\n  }\n  vector<pair<int,int>>query_path(int p,int q,bool isEdge){\n    int r=lca(p,q);\n    vector<pair<int,int>>ret;\n    for(int i=0;i<2;i++){\n      if(i == 1)swap(p,q);\n      while(1){\n        if(isEdge&&p==r)break;\n        if(head[p]==head[r]){\n          ret.emplace_back(in[r]+(isEdge?1:i),in[p]+1);\n          break;\n        }\n        ret.emplace_back(in[head[p]],in[p]+1);\n        p = par[head[p]];\n      }\n    }\n    return ret;\n  }\n  vector<vector<pair<int,int>>>query_order_path(int p,int q,bool isEdge){\n\t//非可換クエリ用、配列0を順番を反転したデータ構造に、配列1を通常のデータ構造に\n    vector<vector<pair<int,int>>>ret(2);\n    int r=lca(p,q);\n    for(int i=0;i<2;i++){\n      if(i == 1)swap(p,q);\n      while(1){\n        if(isEdge&&p==r)break;\n        if(head[p]==head[r]){\n          if(i==0) ret[i].emplace_back(n-(in[p]+1),n-(in[r]+(isEdge?1:i)));\n          else ret[i].emplace_back(in[r]+(isEdge?1:i),in[p]+1);\n          break;\n        }\n        if(i==0) ret[i].emplace_back(n-(in[p]+1),n-(in[head[p]]));\n        else ret[i].emplace_back(in[head[p]],in[p]+1);\n        p = par[head[p]];\n      }\n    }\n    reverse(ret[1].begin(), ret[1].end());\n    return ret;\n  }\n  pair<int,int>query_subtree(int p,bool isEdge){\n    return make_pair(in[p]+isEdge,out[p]);\n  }\n  //uのv方向の子 子孫関係は前もって確認すること(in,outを見る)\n  int child(int u,int v){\n    while(1){\n      if(head[u]==head[v]){\n        v=g[u][0].to;\n        break;\n      }\n      v=head[v];\n      if(par[v]==u)break;\n      v=par[v];\n    }\n    return v;\n  }\n  //uをv方向に一つ進めた頂点\n  int move(int u,int v){\n    assert(u!=v);\n    if(in[u]<in[v]&&in[v]<out[u])return child(u,v);\n    else return par[u];\n  }\n  D dist(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n  vector<int>rev_in;\n  int climb(int u,int k){\n    if(rev_in.empty()){\n      rev_in.resize(n);\n      for(int i=0;i<n;i++)rev_in[in[i]]=i;\n    }\n    int nd=max<int>(dep[u]-k, 0);\n    while(dep[u]>nd){\n      if(dep[head[u]]>nd){\n        u=par[head[u]];\n      }\n      else{\n        u=rev_in[in[head[u]]+nd-dep[head[u]]];\n      }\n    }\n    return u;\n  }\n  int jump(int from,int to, int k){\n    int r = lca(from, to);\n    int d1 = dep[from] - dep[r];\n    int d2 = dep[to] - dep[r];\n    if(d1 + d2 < k)return -1;\n    else if(k <= d1)return climb(from, k);\n    else return climb(to, d1 + d2 - k); \n  }\n  template<typename I>\n  Graph<T>lca_tree(vector<I>&v){\n    auto compare=[&](int x,int y){return in[x]<in[y];};\n    sort(v.begin(),v.end(),compare);\n    int sz1=v.size();\n    for(int i=0;i<sz1-1;i++)v.push_back(lca(v[i],v[i+1]));\n    sort(v.begin(),v.end(),compare);\n    v.erase(unique(v.begin(),v.end()),v.end());\n    int sz2=v.size();\n    Graph<T>ret(sz2);\n    stack<int>st;\n    for(int i=0;i<sz2;i++){\n      while(!st.empty()&&out[v[st.top()]]<=in[v[i]])st.pop();\n      if(!st.empty()){\n        ret[st.top()].emplace_back(i,dep[v[i]]-dep[v[st.top()]]);\n        ret[i].emplace_back(st.top(),dep[v[i]]-dep[v[st.top()]]);\n      }\n      st.push(i);\n    }\n    return ret;\n  }\n};\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    n++;\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  //[l,r)\n  void add(ll l,ll r,T w){\n\tif(l>=r)return;\n    add(l,w);add(r,-w);\n  }\n  T sum(ll a){//[0,a)\n\t  if(a<=0)return 0;\n    T ret = 0;\n    for(ll i=a;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  //[a,b)\n  T sum(ll a,ll b){return a>=b?0:sum(b)-sum(a);}\n  T operator[](ll pos){\n    return sum(0,pos+1);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n-1;i++){\n      if(i!=0)cout<<"" "";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  int n;cin>>n;\n  int sz=20;\n  vector<BIT<ll>>bit(sz+1,BIT<ll>(n+1));\n  auto g=readGraph<int>(n,n-1);\n  HLD hld(g);\n  auto s=vec(sz+1,n,0LL);\n  int q;cin>>q;\n  while(q--){\n    int type;cin>>type;\n    if(type==1){\n      int v;cin>>v;v--;\n      int cl=0;\n      ll ret=0;\n      while(v!=-1&&cl<=sz){\n        if(v==0){\n          rep(i,cl,sz+1){\n            ret+=bit[i][hld.in[0]];\n            //cout<<i spa bit[i][hld.in[0]] spa ""bit""<<endl;\n            ret+=s[i][0];\n          }\n        }\n        else{\n          ret+=bit[cl][hld.in[v]];\n          ret+=s[cl][v];\n          if(cl+1<=sz)ret+=s[cl+1][v];\n        }\n        cl++;\n        v=hld.par[v];\n      }\n      cout<<ret<<endl;\n    }\n    else{\n      int u,v,k,d;cin>>u>>v>>k>>d;u--;v--;\n      int r=hld.lca(u,v);\n      for(auto z:{u,v}){\n        if(z!=r){\n          auto tmp=hld.query_path(hld.move(r,z),z,false);\n          //cout<<z spa r spa hld.move(r,z)<<endl;\n          for(auto z:tmp){\n            //cout<<""hld"" spa z.fi spa z.se<<endl;\n            bit[d].add(z.fi,z.se,k);\n          }\n        }\n      }\n      while(r!=-1&&d>=0){\n        s[d][r]+=k;\n        d--;\n        r=hld.par[r];\n      }\n    }\n  }\n  return 0;\n}']","['data structures', 'dfs and similar', 'trees']",2800
https://codeforces.com//contest/455/problem/C,C. Civilization,Andrew plays a game called Civilization Dima helps him The game has cities and bidirectional roads The cities are numbered from to Between any pair of cities there either is a single unique path or there is no path at all A path is such a sequence of distinct cities that there is a road between any contiguous cities and The length of the described path equals to We assume that two cities lie in the same region if and only if there is a path connecting these two cities During the game events of two types take place Andrew asks Dima about the length of the longest path in the region where city lies Andrew asks Dima to merge the region where city lies with the region where city lies If the cities lie in the same region then no merging is needed Otherwise you need to merge the regions as follows choose a city from the first region a city from the second region and connect them by a road so as to minimize the length of the longest path in the resulting region If there are multiple ways to do so you are allowed to choose any of them Dima finds it hard to execute Andrew s queries so he asks you to help him Help Dima ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 600010;\n\nint ROOT, MAX, CITY;\n\nint p[N], was[N];\n\nvector <int> g[N];\n\nvoid dfs(int v, int d, int mark) {\n  p[v] = ROOT;\n  if (d > MAX) {\n    MAX = d;\n    CITY = v;\n  }\n  was[v] = mark + 1;\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j];\n    if (was[u] > mark) {\n      continue;\n    }\n    dfs(u, d + 1, mark);\n  }\n}\n\nint diam[N];\n\nint find_set(int x) {\n  if (x != p[x]) {\n    p[x] = find_set(p[x]);\n  }\n  return p[x];\n}\n\nint main() {\n  int n, m, q;\n  scanf(""%d %d %d"", &n, &m, &q);\n  for (int i = 1; i <= n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; i++) {\n    int foo, bar;\n    scanf(""%d %d"", &foo, &bar);\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  for (int i = 1; i <= n; i++) {\n    was[i] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (was[i] == 0) {\n      ROOT = i;\n      MAX = -1; CITY = 0;\n      dfs(i, 0, 0);\n      int to = CITY;\n      MAX = -1; CITY = 0;\n      dfs(to, 0, 1);\n      diam[i] = MAX;\n    }\n  }\n  while (q--) {\n    int com;\n    scanf(""%d"", &com);\n    if (com == 1) {\n      int x;\n      scanf(""%d"", &x);\n      printf(""%d\\n"", diam[find_set(x)]);\n    } else {\n      int x, y;\n      scanf(""%d %d"", &x, &y);\n      if (q % 7 <= 4) {\n        swap(x, y);\n      }\n      x = find_set(x);\n      y = find_set(y);\n      if (x == y) {\n        continue;\n      }\n      p[x] = y;\n      int old = (diam[x] > diam[y]) ? diam[x] : diam[y];\n      diam[y] = ((diam[y] + 1) / 2) + 1 + ((diam[x] + 1) / 2);\n      if (old > diam[y]) {\n        diam[y] = old;\n      }\n    }\n  }\n  return 0;\n}\n']","['dfs and similar', 'dp', 'dsu', 'ternary search', 'trees']",2100
https://codeforces.com//contest/911/problem/E,E. Stack Sorting,Let s suppose you have an array a stack initially empty and an array also initially empty You may perform the following operations until both and are empty Take the first element of push it into and remove it from if is not empty Take the top element from append it to the end of array and remove it from if is not empty You can perform these operations in arbitrary order If there exists a way to perform the operations such that array is sorted in non descending order in the end then array is called For example is because will be sorted if we perform the following operations Remove from and push it into Remove from and push it into Remove from and append it to the end of Remove from and push it into Remove from and append it to the end of Remove from and append it to the end of After all these operations so is is not You are given first elements of some permutation of size recall that a permutation of size is an array of size where each integer from to occurs exactly once You have to restore the remaining elements of this permutation so it is If there are multiple answers choose the answer such that is lexicographically maximal an array is lexicographically greater than an array iff there exists some integer such that for every and Print the lexicographically maximal permutation you can obtain If there exists no answer then output ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic void no()\n{\n    cout << ""-1\\n"";\n    exit(0);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, K;\n    cin >> N >> K;\n    vi a(N);\n    int out = 0;\n    set<int> miss;\n    for (int i = 0; i < N; i++)\n        miss.insert(i);\n    for (int i = 0; i < K; i++)\n    {\n        cin >> a[i];\n        a[i]--;\n        miss.erase(a[i]);\n    }\n    stack<int> s;\n    for (int i = 0; i < K; i++)\n    {\n        while (!s.empty() && s.top() < a[i])\n        {\n            if (s.top() != out)\n                no();\n            s.pop();\n            out++;\n        }\n        s.push(a[i]);\n    }\n\n    for (int i = K; i < N; i++)\n    {\n        while (!s.empty() && s.top() == out)\n        {\n            s.pop();\n            out++;\n        }\n        int limit = s.empty() ? INT_MAX / 2 : s.top();\n        auto it = prev(miss.lower_bound(limit));\n        s.push(*it);\n        a[i] = *it;\n        miss.erase(it);\n    }\n\n    for (int i = 0; i < N; i++)\n        cout << a[i] + 1 << \' \';\n    cout << \'\\n\';\n\n    return 0;\n}\n']","['constructive algorithms', 'data structures', 'greedy', 'implementation']",2000
https://codeforces.com//contest/1419/problem/D1,D1. Sage s Birthday  easy version ,Today is Sage s birthday and she will go shopping to buy ice spheres All n ice spheres are placed in a row and they are numbered from 1 to n from left to right Each ice sphere has a positive integer price In this version all prices are different An ice sphere is cheap if it costs strictly less than two neighboring ice spheres the nearest to the left and the nearest to the right The leftmost and the rightmost ice spheres are not cheap Sage will choose all cheap ice spheres and then buy only them You can visit the shop before Sage and reorder the ice spheres as you wish Find out the maximum number of ice spheres that Sage can buy and show how the ice spheres should be reordered ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint n, a[MAXN], v, ans[MAXN];\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    cin >> n;\n\tFor(i, 1, n) scanf(""%d"", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tcout << (n - 1) / 2 << endl;\n\tFor(i, 1, n / 2)\n\t\tans[i * 2] = a[i];\n\tFor(i, n / 2 + 1, n)\n\t\tans[(i - n / 2) * 2 - 1] = a[i];\n\tFor(i, 1, n) {\n\t\tprintf(""%d "", ans[i]);\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']","['binary search', 'constructive algorithms', 'greedy', 'sortings']",1000
https://codeforces.com//contest/1659/problem/C,C. Line Empire,Consider a number axis The capital of your empire is initially at 0 There are n unconquered kingdoms at positions 0 x 1 x 2 ldots x n You want to conquer all other kingdoms There are two actions available to you You can change the location of your capital let its current position be c 1 to any other kingdom let its position be c 2 at a cost of a cdot c 1 c 2 From the current capital let its current position be c 1 you can conquer an unconquered kingdom let its position be c 2 at a cost of b cdot c 1 c 2 You conquer a kingdom if there is an unconquered kingdom between the target and your capital Note that you place the capital at a point without a kingdom In other words at any point your capital can only be at 0 or one of x 1 x 2 ldots x n Also note that conquering a kingdom does not change the position of your capital Find the minimum total cost to conquer all kingdoms Your capital can be anywhere at the end ,"['#include<iostream>\nusing namespace std;\nint a[200010];\nlong long sum[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t\tsum[i]=sum[i-1]+a[i];\n\t\t}\n\t\tlong long ans=1e18,s=0;\n\t\tfor(int i=0; i<=n; i++) {\n\t\t\tif(i) {\n\t\t\t\ts+=a[i]-a[i-1];\n\t\t\t}\n\t\t\tans=min(ans,(long long)x*a[i]+y*(sum[n]-sum[i]-(long long)a[i]*(n-i)+s));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n']","['binary search', 'brute force', 'dp', 'greedy', 'implementation', 'math']",1500
https://codeforces.com//contest/1729/problem/A,A. Two Elevators,Vlad went into his appartment house entrance now he is on the 1 th floor He was going to call the elevator to go up to his apartment There are only two elevators in his house Vlad knows for sure that the first elevator is currently on the floor a it is currently motionless the second elevator is located on floor b and goes to floor c b ne c Please note if b 1 then the elevator is already leaving the floor 1 and Vlad does not have time to enter it If you call the first elevator it will immediately start to go to the floor 1 If you call the second one then first it will reach the floor c and only then it will go to the floor 1 It takes x y seconds for each elevator to move from floor x to floor y Vlad wants to call an elevator that will come to him faster Help him choose such an elevator ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    int a, b, c;\n    cin >> a >> b >> c;\n\n    int t1 = a - 1;\n    int t2 = abs(b - c) + c - 1;\n\n\n    if(t1 < t2)\n        done(1);\n\n    if(t1 > t2)\n        done(2);\n\n    done(3);\n\n\n    \n    \n\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']",['math'],800
https://codeforces.com//contest/156/problem/C,C. Cipher,Sherlock Holmes found a mysterious correspondence of two VIPs and made up his mind to read it But there is a problem The correspondence turned out to be encrypted The detective tried really hard to decipher the correspondence but he couldn t understand anything At last after some thought he thought of something Let s say there is a word consisting of lowercase Latin letters Then for one you can choose a certain position and perform one of the following actions either replace letter with the one that alphabetically it and replace letter with the one that alphabetically it or replace letter with the one that alphabetically it and replace letter with the one that alphabetically it Let us note that letter doesn t have a defined following letter and letter doesn t have a defined preceding letter That s why the corresponding changes are not acceptable If the operation requires performing at least one unacceptable change then such operation cannot be performed Two words iff one of them can be transformed into the other one as a result of zero or more operations Sherlock Holmes needs to learn to quickly determine the following for each word how many words can exist that coincide in their meaning with the given word but differs from the given word in at least one character Count this number for him modulo ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1e9 + 7;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\n\nconst int MAXL = 110;\nchar s[MAXL + 1];\n\nconst int MAXV = 25;\nconst int MAXS = MAXL * MAXV;\n\nint d[MAXL + 1][MAXS + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(""std.in"", ""r"", stdin);\n  freopen(""std.out"", ""w"", stdout);\n  #endif\n\n  memset(d, 0, sizeof d);\n  d[0][0] = 1;\n  for (int l = 0; l < MAXL; l++)\n  for (int ps = 0; ps <= MAXS; ps++)\n    for (int nv = 0; nv <= MAXV && ps + nv <= MAXS; nv++)\n      add(d[l + 1][ps + nv], d[l][ps]);\n\n  int TC;\n  assert(scanf(""%d"", &TC) >= 1);\n  while (TC --> 0) {\n    scanf(""%s"", s);\n    int l = strlen(s), sum = 0;\n    for (int i = 0; i < l; i++)\n      sum += s[i] - \'a\';\n    int res = d[l][sum];\n    add(res, MOD - 1);\n    printf(""%d\\n"", res);\n  }\n  return 0;\n}\n']","['combinatorics', 'dp']",2000
https://codeforces.com//contest/978/problem/B,B. File Name,You can not just take the file and send it When Polycarp trying to send a file in the social network Codehorses he encountered an unexpected problem If the name of the file contains three or more lowercase Latin letters in a row the system considers that the file content does not correspond to the social network topic In this case the file is not sent and an error message is displayed Determine the minimum number of characters to remove from the file name so after that the name does not contain as a substring Print if the file name does not initially contain a forbidden substring You can delete characters in arbitrary positions not necessarily consecutive If you delete a character then the length of a string is reduced by 1 For example if you delete the character in the position 2 from the string then the resulting string is ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,c;\nstring s;\nvector<long long> vec;\n\nint main()\n{\n    cin>>n>>s;\n    for(int i = 0; i<n;++i)\n    {\n        //cout<<c<<' ';\n        if(s[i] == 'x') c++;\n        else\n        {\n            vec.push_back(c);//cout<<c<<' ';\n            c = 0;\n        }\n    }\n    vec.push_back(c);\n    long long res = 0;\n    for(auto i:vec)\n        if(i>=3)\n        res+=i - 2;\n\n    cout<<res;\n    return 0;\n}\n""]","['greedy', 'strings']",800
https://codeforces.com//contest/1837/problem/C,C. Best Binary String,You are given a string s consisting of the characters and or Let s call it a Let s say that the binary string a string where each character is either or the if you can replace each character with or for each character the choice is independent so that the strings become equal For example matches but doesn t match or Let s define the of the binary string as the minimum number of operations of the form reverse an arbitrary contiguous substring of the string required to sort the string in non descending order You have to find a binary string with the minimum possible cost among those that match the given pattern If there are multiple answers print any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    string s;\n    cin >> s;\n    int N = s.size();\n    s = ""0"" + s + ""1"";\n    vector<int> p;\n    for (int j = 1; j < N + 2; j++){\n      if (s[j] == \'?\'){\n        s[j] = s[j - 1];\n      }\n    }\n    for (int j = 1; j <= N; j++){\n      cout << s[j];\n    }\n    cout << endl;\n  }\n}']","['constructive algorithms', 'greedy']",1000
https://codeforces.com//contest/1821/problem/E,E. Rearrange Brackets,A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not You are given a regular bracket sequence In one move you can remove a pair of brackets such that the left one is an opening bracket and the right one is a closing bracket Then concatenate the resulting parts without changing the order The cost of this move is the number of brackets to the right of the right bracket of this pair The of the regular bracket sequence is the smallest total cost of the moves required to make the sequence empty Actually you are not removing any brackets Instead you are given a regular bracket sequence and an integer k You can perform the following operation extract some bracket from the sequence and insert it back at any position between any two brackets at the start or at the end possibly at the same place it was before After all operations are performed the bracket sequence has to be regular What is the smallest possible of the resulting regular bracket sequence ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[2][7][7][7];\nll rui[MAX];\n\nint main(){\n    \n    std::ifstream in(""text.txt"");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        int K;cin>>K;\n        string S;cin>>S;\n        int N=si(S);\n        for(int i=0;i<=N;i++){\n            rui[i]=0;\n        }\n        \n        for(int s=0;s<2;s++) for(int j=0;j<=K;j++) for(int k=0;k<=K;k++) for(int l=0;l<=K;l++) dp[s][j][k][l]=INF;\n        \n        for(int i=1;i<=N;i++){\n            rui[i]=rui[i-1];\n            if(S[i-1]==\'(\') rui[i]++;\n            if(S[i-1]==\')\') rui[i]--;\n        }\n        \n        dp[0][0][0][0]=0;\n        \n        for(int i=0;i<=N;i++){\n            int s=i&1,t=s^1;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        if(dp[s][al][a][b]==INF) continue;\n                        ll d=rui[i]-a+b;\n                        if(i<N){\n                            chmin(dp[t][al+1][a+(S[i]==\'(\')][b+(S[i]==\')\')],dp[s][al][a][b]);\n                            if(S[i]==\'(\'){\n                                chmin(dp[t][al][a][b],dp[s][al][a][b]+d);\n                            }\n                            if(S[i]==\')\'){\n                                if(d>=1) chmin(dp[t][al][a][b],dp[s][al][a][b]);\n                            }\n                        }\n                        \n                        if(a){\n                            chmin(dp[s][al][a-1][b],dp[s][al][a][b]+d);\n                        }\n                        if(b&&d>=1){\n                            chmin(dp[s][al][a][b-1],dp[s][al][a][b]);\n                        }\n                    }\n                }\n            }\n            if(i==N) break;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        dp[s][al][a][b]=INF;\n                    }\n                }\n            }\n        }\n        \n        ll ans=INF;\n        \n        for(int al=0;al<=K;al++){\n            chmin(ans,dp[N&1][al][0][0]);\n        }\n        \n        cout<<ans<<""\\n"";\n    }\n}\n']","['brute force', 'dp', 'greedy', 'sortings', 'strings']",2100
https://codeforces.com//contest/1658/problem/D2,D2. 388535  Hard Version ,Marin and Gojou are playing hide and seek with an array Gojou initially perform the following steps First Gojou chooses 2 integers l and r such that l leq r Then Gojou will make an array a of length r l 1 which is a permutation of the array l l 1 ldots r Finally Gojou chooses a secret integer x and sets a i to a i oplus x for all i where oplus denotes the bitwise XOR operation Marin is then given the values of l r and the final array a She needs to find the secret integer x to win Can you help her Note that there may be multiple possible x that Gojou could have chosen Marin can find any possible x that could have resulted in the final value of a ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint a[500005],c[500005];\nset <int> s;\ninline void cov(int l,int r)\n{\n\twhile(s.lower_bound(l)!=s.end()&&*s.lower_bound(l)<=r)\n\t\ts.erase(s.lower_bound(l));\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tint n=r-l+1;\n\t\ts.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\ts.insert(a[i]^l);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint now=0;\n\t\t\tfor(int j=16;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(r&(1<<j))\n\t\t\t\t{\n\t\t\t\t\tif(a[i]&(1<<j));\n\t\t\t\t\telse now^=(1<<j);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(a[i]&(1<<j)) cov(now,now+(1<<j)-1),now+=(1<<j);\n\t\t\t\telse cov(now+(1<<j),now+(2<<j)-1);\n\t\t\t}\n\t\t\tnow=0;\n\t\t\tfor(int j=16;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(!(l&(1<<j)))\n\t\t\t\t{\n\t\t\t\t\tif(a[i]&(1<<j)) now^=(1<<j);\n\t\t\t\t\telse ;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(a[i]&(1<<j)) cov(now+(1<<j),now+(2<<j)-1);\n\t\t\t\telse cov(now,now+(1<<j)-1),now+=(1<<j);\n\t\t\t}\n\t\t}\n\t\tcout << *s.begin() << ""\\n"";\n\t}\n\treturn 0;\n}']","['bitmasks', 'brute force', 'data structures', 'math']",2300
https://codeforces.com//contest/814/problem/D,D. An overnight dance in discotheque,The crowdedness of the discotheque would never stop our friends from having fun but a bit more spaciousness won t hurt will it The discotheque can be seen as an infinite plane in which there are a total of dancers Once someone starts moving around they will move only inside their own movement range which is a circular area described by a center and a radius that is for every pair either ranges and are disjoint or one of them is a subset of the other Note that it s possible that two ranges borders share a single common point but no two dancers have exactly the same ranges Tsukihi being one of them defines the to be An example is shown below with shaded regions representing the if everyone moves at the same time But no one keeps moving for the whole night after all so the whole night s time is divided into two halves before midnight and after midnight Every dancer moves around in one half while sitting down with friends in the other The of two halves are calculated separately and their sum should of course be as large as possible The following figure shows an optimal solution to the example above By different plans of who dances in the first half and who does in the other different sums of over two halves are achieved You are to find the largest achievable value of this sum ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst ld PI = atan2(0, -1);\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint p[maxn];\n\nvector<int> e[maxn];\n\nint n;\n\npair<ll, pair<ll, ll> > a[maxn];\n\nll dist(pair<ll, ll> x, pair<ll, ll> y){\n    return sqr(x.first - y.first) + sqr(x.second - y.second);\n}\n\nbool vis[maxn];\n\nld answer;\n\nll fun(int h){\n    if (h < 2 || (h & 1) == 1)\n        return 1;\n    return -1;\n}\n\nvoid dfs(int v, int h){\n    vis[v] = 1;\n    answer += PI * a[v].first * a[v].first * fun(h);\n    for (int i = 0; i < e[v].size(); i++)\n        dfs(e[v][i], h + 1);\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i].second.first >> a[i].second.second >> a[i].first, p[i] = -1;\n    sort(a, a + n);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < i; j++)\n            if (dist(a[i].second, a[j].second) <= a[i].first * a[i].first && p[j] == -1)\n                e[i].push_back(j), p[j] = i;\n    for (int i = n - 1; i >= 0; i--)\n        if (!vis[i])\n            dfs(i, 0);\n    cout << fixed << setprecision(20) << answer;\n}\n']","['dfs and similar', 'dp', 'geometry', 'greedy', 'trees']",2000
https://codeforces.com//contest/1783/problem/E,E. Game of the Year,Monocarp and Polycarp are playing a computer game This game features n bosses for the playing to kill numbered from 1 to n They will fight boss the following way Monocarp makes k attempts to kill the boss Polycarp makes k attempts to kill the boss Monocarp makes k attempts to kill the boss Polycarp makes k attempts to kill the boss Monocarp kills the i th boss on a i th attempt Polycarp kills the i th boss on b i th attempt After one of them kills the i th boss they move on to the i 1 st boss The attempt counters reset for both of them Once one of them kills the n th boss the game ends Find all values of k from 1 to n such that Monocarp kills ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    std::vector<int> d(n + 1);\n    for (int i = 0; i < n; i++) {\n        if (a[i] > b[i]) {\n            d[b[i]]++;\n            d[a[i]]--;\n        }\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n    }\n    \n    std::vector<int> ans;\n    for (int k = 1; k <= n; k++) {\n        int ok = 1;\n        for (int i = k; i <= n; i += k) {\n            if (d[i]) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok) ans.push_back(k);\n    }\n    \n    std::cout << ans.size() << ""\\n"";\n    for (auto x : ans) {\n        std::cout << x << "" \\n""[x == ans.back()];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['brute force', 'data structures', 'math', 'number theory']",2300
https://codeforces.com//contest/1106/problem/E,E. Lunar New Year and Red Envelopes,But collecting money from red envelopes is a time consuming process itself Let s describe this problem in a mathematical way Consider a timeline from time 1 to n The i th red envelope will be available from time s i to t i inclusive and contain w i coins If Bob chooses to collect the coins in the i th red envelope he can do it only in an point of time between s i and t i inclusive and he can t collect any more envelopes until time d i inclusive after that Here s i leq t i leq d i holds Bob is a greedy man he collects coins greedily whenever he can collect coins at some integer time x he collects the available red envelope with the maximum number of coins If there are multiple envelopes with the same maximum number of coins Bob would choose the one whose parameter d is the If there are still multiple choices Bob will choose one from them randomly However Alice his daughter doesn t want her father to get too many coins She could disturb Bob at no more than m integer time moments If Alice decides to disturb Bob at time x he could not do anything at time x and resumes his usual strategy at the time x 1 inclusive which may lead to missing some red envelopes Calculate the minimum number of coins Bob would get if Alice disturbs him optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nconst int M = 220;\n\nlong long dp[N][M];\nmultiset<pair<int, int> > S;\nvector<pair<int, int> > vec[N], era[N];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint n, m, k; cin >> n >> m >> k;\n\tfor (int i = 1; i <= k; i++) {\n\t\tint s, t, d, w; cin >> s >> t >> d >> w;\n\t\tvec[t].push_back(make_pair(-w, -d));\n\t\tera[s].push_back(make_pair(-w, -d));\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (auto e : vec[i]) S.insert(e);\n\t\tpair<int, int> ma = make_pair(0, 0);\n\t\tif (!S.empty()) ma = *S.begin();\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tdp[i][j] = dp[ma.first ? -(ma.second) + 1 : i + 1][j] - ma.first;\n\t\t\tif (j) dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);\n\t\t}\n\t\tfor (auto e : era[i]) S.erase(S.lower_bound(e));\n\t}\n\tcout << dp[1][m] << endl;\n\treturn 0;\n}']","['data structures', 'dp']",2100
https://codeforces.com//contest/296/problem/A,A. Yaroslav and Permutations,Yaroslav has an array that consists of integers In one second Yaroslav can swap two neighboring array elements Now Yaroslav is wondering if he can obtain an array where any two neighboring elements would be distinct in a finite time Help Yaroslav ,"['#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#pragma comment(linker, ""/STACK:256000000"")\n\nusing namespace std;\n\nconst int maxN = 200;\nint a[maxN];\n\nint main() {\n  //freopen(""input.txt"", ""r"", stdin);\n  //freopen(""output.txt"", ""w"", stdout);\n\n  int n;\n  scanf(""%d"", &n);\n\n  map<int, int> res;\n\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    ++res[x];\n  }\n\n  for (map<int, int>::iterator it = res.begin(); it != res.end(); ++it) {\n    if (it->second > (n + 1) / 2) {\n      cout << ""NO"" << endl;\n      return 0;\n    }\n  }\n\n  cout << ""YES"" << endl;\n\n  return 0;\n}\n']","['greedy', 'math']",1100
https://codeforces.com//contest/216/problem/E,E. Martian Luck,You know that the Martians use a number system with base Digit is considered as the first contact between the Martians and the Earthlings occurred in year by Martian chronology A of number is a number that consists of a single digit resulting after cascading summing of all digits of number Word cascading means that if the first summing gives us a number that consists of several digits then we sum up all digits again and again until we get a one digit number For example In this sample the calculations are performed in the 7 base notation If a number s digital root equals the Martians also call this number lucky You have string which consists of digits in the base notation system Your task is to find how many distinct substrings of the given string are lucky numbers Leading zeroes are permitted in the numbers Note that substring of the string is the string Two substrings and of the string are different if either or ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint a[110000];\nmap<int,int> mp;\n\nint main()\n{\n  _int64 ans;\n  int i,j,k,b,n,tot,tmp,z;\n  scanf(""%d%d%d"",&k,&b,&n);\n  for (i=0;i<n;i++)\n  {\n    scanf(""%d"",&a[i]);\n  }\n  mp.clear();\n  mp[0]++;\n  tot=0;\n  ans=0;\n  z=0;\n  for (i=0;i<n;i++)\n  {\n    tot+=a[i];\n    tot%=(k-1);\n    if (a[i]==0) z++;\n    else z=0;\n    tmp=(tot+(k-1)-b)%(k-1);\n    if ((b==(k-1))||(b==0))\n    {\n      if (b==0) ans+=z;\n      else ans+=(mp[tmp]-z);\n    }\n    else\n    {\n      ans+=mp[tmp];\n    }\n    mp[tot]++;\n  }\n  printf(""%I64d\\n"",ans);\n}\n']","['math', 'number theory']",2000
https://codeforces.com//contest/1638/problem/D,D. Big Brush,You found a painting on a canvas of size n times m The canvas can be represented as a grid with n rows and m columns Each cell has some color Cell i j has color c i j Near the painting you also found a brush in the shape of a 2 times 2 square so the canvas was surely painted in the following way initially no cell was painted Then the following painting operation has been performed some number of times Choose two integers i and j 1 le i n 1 le j m and some color k 1 le k le nm Paint cells i j i 1 j i j 1 i 1 j 1 in color k All cells must be painted at least once A cell can be painted multiple times In this case its final color will be the last one Find any sequence of at most nm operations that could have led to the painting you found or state that it s impossible ,"['// Author: wlzhouzhuan\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\n#define free freee\n\nqueue<array<int,3>> q;\nbool vis[1005][1005];\nbool free[1005][1005];\nint a[1005][1005];\nint n,m;\n\nconst int dx[]={-1,-1,-1,0,0,0,1,1,1};\nconst int dy[]={-1,0,1,-1,0,1,-1,0,1};\n\nvector<array<int,3>> ans;\n\nint check(int x,int y){\n\tint las=-1;\n\tfor(int i=x;i<=x+1;i++){\n\t\tfor(int j=y;j<=y+1;j++){\n\t\t\tif(free[i][j])continue;\n\t\t\tif(!~las)las=a[i][j];\n\t\t\telse if(a[i][j]!=las)return -1;\n\t\t}\n\t}\n\treturn ~las?las:1;\n}\n\nint main(){\n\tn=read(),m=read();\n\trep(i,1,n)rep(j,1,m)a[i][j]=read();\n\trep(i,1,n-1)rep(j,1,m-1){\n\t\tif(check(i,j)!=-1)vis[i][j]=1,q.push({i,j,a[i][j]});\n\t}\n\twhile(!q.empty()){\n\t\tauto [x,y,_]=q.front();q.pop();\n\t\tans.pb({x,y,_});\n\t\tfree[x][y]=free[x][y+1]=free[x+1][y]=free[x+1][y+1]=1;\n\t\tfor(int d=0;d<9;d++){\n\t\t\tint fx=x+dx[d],fy=y+dy[d];\n\t\t\tif(fx>=1&&fx<n&&fy>=1&&fy<m&&!vis[fx][fy]){\n\t\t\t\tint t=check(fx,fy);\n\t\t\t\tif(t!=-1){\n\t\t\t\t\tvis[fx][fy]=1;\n\t\t\t\t\tq.push({fx,fy,t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(SZ(ans)!=(n-1)*(m-1)){\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\tprint(SZ(ans),\'\\n\');\n\treverse(ans.begin(),ans.end());\n\tfor(auto [x,y,c]:ans){\n\t\tprintf(""%d %d %d\\n"",x,y,c);\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'data structures', 'greedy', 'implementation']",2000
https://codeforces.com//contest/702/problem/A,A. Maximum Increase,You are given array consisting of integers Your task is to find the maximum length of an increasing subarray of the given array A subarray is the sequence of consecutive elements of the array Subarray is called increasing if each element of this subarray than previous ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\n\nvoid solve() {\n\tint i,j,k,l,r,y; string s;\n\t\n\tint ma=1,x=0,cur=0;\n\tcin>>N;\n\twhile(N--) {\n\t\tcin>>y;\n\t\tif(y>x) ma=max(ma,++cur);\n\t\telse cur=1;\n\t\tx = y;\n\t}\n\tcout<<ma<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n""]","['dp', 'greedy', 'implementation']",800
https://codeforces.com//contest/786/problem/A,A. Berzerk,Rick and Morty are playing their own version of Berzerk which has nothing in common with the famous Berzerk game This game needs a huge space so they play it with a computer In this game there are objects numbered from to arranged in a circle in clockwise order Object number is a black hole and the others are planets There s a monster in one of the planet Rick and Morty don t know on which one yet only that he s not initially in the black hole but Unity will inform them before the game starts But for now they want to be prepared for every possible scenario Each one of them has a set of numbers between and inclusive Rick s set is with elements and Morty s is with elements One of them goes first and the player changes alternatively In each player s turn he should choose an arbitrary number like from his set and the monster will move to his th next object from its current position clockwise If after his move the monster gets to the black hole he wins Your task is that for each of monster s initial positions and who plays first determine if the starter wins loses or the game will stuck in an infinite loop In case when player can lose or make game infinity it more profitable to choose infinity game ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=7010;\nint k[3],a[3][N],dp[3][N],wn[3][N];\nPII q[N*2];\nint n;\nint main() {\n\tscanf(""%d"",&n);\n\tscanf(""%d"",&k[0]); rep(i,0,k[0]) scanf(""%d"",&a[0][i]);\n\tscanf(""%d"",&k[1]); rep(i,0,k[1]) scanf(""%d"",&a[1][i]);\n\trep(i,1,n) wn[0][i]=k[0],wn[1][i]=k[1];\n\tmemset(dp,-1,sizeof(dp));\n\tq[0]=mp(0,0);\n\tq[1]=mp(1,0);\n\tint t=2;\n\tdp[0][0]=dp[1][0]=0;\n\trep(i,0,t) {\n\t\tint u=q[i].fi,v=q[i].se;\n//\t\tprintf(""%d %d %d\\n"",u,v,dp[u][v]);\n\t\tif (dp[u][v]==0) {\n\t\t\trep(j,0,k[u^1]) {\n\t\t\t\tint uu=u^1,vv=(v+n-a[uu][j])%n;\n\t\t\t\tif (dp[uu][vv]==-1) {\n\t\t\t\t\tdp[uu][vv]=1;\n\t\t\t\t\tq[t++]=mp(uu,vv);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(j,0,k[u^1]) {\n\t\t\t\tint uu=u^1,vv=(v+n-a[uu][j])%n;\n\t\t\t\t--wn[uu][vv];\n\t\t\t\tif (dp[uu][vv]==-1&&wn[uu][vv]==0) {\n\t\t\t\t\tdp[uu][vv]=0;\n\t\t\t\t\tq[t++]=mp(uu,vv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\trep(j,0,2) {\n\t\trep(i,1,n) {\n\t\t\tif (dp[j][i]==-1) printf(""Loop ""); else if (dp[j][i]==0) printf(""Lose ""); else printf(""Win "");\n\t\t}\n\t\tputs("""");\n\t}\n}\n']","['dfs and similar', 'dp', 'games']",2000
https://codeforces.com//contest/1430/problem/D,D. String Deletion,You have a string s consisting of n characters Each character is either or You can perform operations on the string Each operation consists of two steps select an integer i from 1 to the length of the string s then delete the character s i the string length gets reduced by 1 the indices of characters to the right of the deleted one also get reduced by 1 if the string s is not empty delete the maximum length prefix consisting of the same characters the indices of the remaining characters and the string length get reduced by the length of the deleted prefix Note that both steps are mandatory in each operation and their order cannot be changed For example if you have a string s the first operation can be one of the following select i 1 we ll get rightarrow rightarrow select i 2 we ll get rightarrow rightarrow select i 3 we ll get rightarrow rightarrow select i 4 we ll get rightarrow rightarrow select i 5 we ll get rightarrow rightarrow select i 6 we ll get rightarrow rightarrow You finish performing operations when the string s becomes empty What is the maximum number of operations you can perform ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nchar s[200005];\nint q[200005],n;\nint rem[200005];\nbool check(int v){\n\tint p=1;\n\tFor(i,1,*q) rem[i]=q[i]-(i<=v);\n\tFor(i,1,v-1){\n\t\tp=max(p,i);\n\t\tfor (;p<=*q&&!rem[p];++p);\n\t\tif (p>*q) return 0;\n\t\t--rem[p];\n\t}\n\treturn 1;\n}\nvoid solve(){\n\tscanf(""%d\\n%s"",&n,s+1);\n\t//n=strlen(s+1);\n\tq[0]=1; q[1]=1;\n\tFor(i,2,n)\n\t\tif (s[i]==s[i-1])\n\t\t\t++q[*q];\n\t\telse q[++*q]=1;\n\t//For(i,1,*q) cout<<q[i]<<endl;\n\tint l=1,r=*q,ans=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(mid))\n\t\t\tans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']","['binary search', 'data structures', 'greedy', 'two pointers']",1700
https://codeforces.com//contest/587/problem/F,F. Duff is Mad,Duff is mad at her friends That s why she sometimes makes Malek to take candy from one of her friends for no reason She has friends Her th friend s name is their names are not necessarily unique times she asks Malek to take candy from her friends She s angry but also she acts with rules When she wants to ask Malek to take candy from one of her friends like she chooses two numbers and and tells Malek to take exactly candies from him her where is the number of occurrences of string in Malek is not able to calculate how many candies to take in each request from Duff That s why she asked for your help Please tell him how many candies to take in each request ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int ,int> PII;\ntypedef pair< int , PII> pii;\n\nconst int INF = ~0U>>1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1, a = 1ll * a * a % Mod)\n        if (x & 1) ret = 1ll * ret * a % Mod;\n    return ret; \n}\n\nconst int N=201000;\n\nint tot,rk[N*4],sa[N];\npair<PII,int> pos[N];\nchar s[N];\nint p[N];\nvoid init() {\n\tfor (int i=1;i<=tot;i++) rk[i]=p[i];\n\tfor (int j=0;j<19;j++) {\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tpos[i]=mp(mp(rk[i],rk[i+two(j)]),i);\n\t\tsort(pos+1,pos+tot+1);\n\t\tint cnt=0;\n\t\tfor (int i=1;i<=tot;i++) {\n\t\t\trk[pos[i].se]=cnt;\n\t\t\tcnt+=(pos[i].fi!=pos[i+1].fi);\n\t\t}\n\t\tif (cnt==tot) break;\n\t}\n\tfor (int i=1;i<=tot;i++) rk[i]++;\n\tfor (int i=1;i<=tot;i++) sa[rk[i]]=i;\n}\nint query(int l,int r,int c,int len) {\n\t++r; --l;\n\twhile (l+1<r) {\n\t\tint md=(l+r)>>1;\n\t\tif (p[sa[md]+len-1]>=c) r=md; else l=md;\n\t}\n\treturn r;\n}\n\nint n,q,l[N],r[N],c[N],ocr[N],sl[N],sr[N];\nint bigv[N],bigid[N],bigcnt;\nll ret[N],ans[N];\nvector<PII> ql[N],qr[N];\nvector<pair<PII,int> > Qr[N];\n\nvoid modify(int x,int s) { for (;x<=tot;x+=x&-x) c[x]+=s;}\nint query(int x) { int s=0; for (;x;x-=x&-x) s+=c[x]; return s;}\n\nconst int R=200;\nint main() {\n//\tfreopen(""in"",""r"",stdin);\n\tscanf(""%d%d"",&n,&q);\n\trep(i,1,n+1) {\n\t\tscanf(""%s"",s);\n\t\tint len=strlen(s);\n\t\tl[i]=tot+1;\n\t\trep(j,0,len)\n\t\t\tp[++tot]=s[j]-\'a\'+1;\n\t\tp[++tot]=29+i;\n\t\tr[i]=tot;\n\t\tif (len>R) {\n\t\t\tbigid[i]=++bigcnt;\n\t\t\tbigv[bigcnt]=i;\n\t\t}\n\t}\n\tinit();\n\trep(i,1,n+1) {\n\t\tint pl=1,pr=tot;\n\t\trep(j,l[i],r[i]) {\n\t\t\tint ql=query(pl,pr,p[j],j-l[i]+1);\n\t\t\tint qr=query(pl,pr,p[j]+1,j-l[i]+1)-1;\n\t\t\tpl=ql;\n\t\t\tpr=qr;\n\t\t}\n\t\tsl[i]=pl,sr[i]=pr;\n\t}\n\n\trep(i,1,q+1) {\n\t\tint l,r,k;\n\t\tscanf(""%d%d%d"",&l,&r,&k);\n\t\tif (bigid[k]) {\n\t\t\tQr[k].pb(mp(mp(l,r),i));\n\t\t} else {\n\t\t\tqr[r].pb(mp(k,i));\n\t\t\tqr[l-1].pb(mp(k,-i));\n\t\t}\n\t}\n\trep(i,1,bigcnt+1) {\n\t\tint v=bigv[i];\n\t\tfor (int j=1;j<=tot;j++) ocr[j]=0;\n\t\tfor (int j=l[v];j<r[v];j++) {\n\t\t\tocr[rk[j]]++;\n\t\t}\n\t\tfor (int j=1;j<=tot;j++) ocr[j]+=ocr[j-1];\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tret[j]=ret[j-1]+ocr[sr[j]]-ocr[sl[j]-1];\n\t\t}\n\t\tfor (auto que:Qr[v]) {\n\t\t\tint l=que.fi.fi,r=que.fi.se,id=que.se;\n\t\t\tans[id]=ret[r]-ret[l-1];\n\t\t}\n\t}\n\trep(i,1,n+1) {\n\t\tmodify(sl[i],1);\n\t\tmodify(sr[i]+1,-1);\n\t\tfor (auto p:qr[i]) {\n\t\t\tint id=p.se,w=1,v=p.fi;\n\t\t\tif (id<0) w=-1,id*=-1;\n\t\t\trep(j,l[v],r[v]) {\n\t\t\t\tans[id]+=w*query(rk[j]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,q+1) printf(""%lld\\n"",ans[i]);\n}']","['data structures', 'strings']",3000
https://codeforces.com//contest/404/problem/D,D. Minesweeper 1D,Game Minesweeper 1D is played on a line of squares the line s height is 1 square the line s width is squares Some of the squares contain bombs If a square doesn t contain a bomb then it contains a number from 0 to 2 the total number of bombs in adjacent squares For example the correct field to play looks like that The cells that are marked with contain bombs Note that on the correct field the numbers represent the number of bombs in adjacent cells For example field is not correct because cell with value 2 must have two adjacent cells with bombs Valera wants to make a correct field to play Minesweeper 1D He has already painted a squared field with width of cells put several bombs on the field and wrote numbers into some cells Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end ,"['#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define lx x + x\n#define rx lx + 1\n#define ly y + y\n#define ry ly + 1\ntypedef long long LL;\n\nconst int N = 1000005;\nconst int M = 1005;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\ntypedef double DB;\n\nLL f[N][3];\nchar s[N];\nint main(){\n    scanf(""%s"", s + 1);\n    int n = strlen(s + 1);\n    s[0] = \'0\';\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        if (s[i] == \'0\'){\n            f[i][0] += f[i - 1][0];\n        }else if (s[i] == \'1\'){\n            f[i][1] += f[i - 1][0];\n            f[i][0] += f[i - 1][2];\n        }else if (s[i] == \'2\'){\n            f[i][1] += f[i - 1][2];\n        }else if (s[i] == \'*\'){\n            if (i == 1) f[i][2] = 1;\n            else{\n                f[i][2] += f[i - 1][1];\n                f[i][2] += f[i - 1][2];\n            }\n        }else{\n            //0\n            f[i][0] += f[i - 1][0];\n\n            //1\n            f[i][1] += f[i - 1][0];\n            f[i][0] += f[i - 1][2];\n            //2\n            f[i][1] += f[i - 1][2];\n            //*\n            if (i == 1) f[i][2] = 1;\n            else{\n                f[i][2] += f[i - 1][1];\n                f[i][2] += f[i - 1][2];\n            }\n        }\n        for (int j = 0; j < 3; j++) f[i][j] %= MOD;\n    }\n    cout << (f[n][0] + f[n][2]) % MOD << endl;\n}\n']","['dp', 'implementation']",1900
https://codeforces.com//contest/1592/problem/A,A. Gamer Hemose,There is an Agent in Valorant and he has n weapons The i th weapon has a damage value a i and the Agent will face an enemy whose health value is H The Agent will perform one or more moves until the enemy dies In one move he will choose a weapon and decrease the enemy s health by its damage value The enemy will die when his health will become less than or equal to 0 However not everything is so easy What is the minimum number of times that the Agent will need to use the weapons to kill the enemy ,"['#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,h,a[1005];\nvoid solve()\n{\n\tcin>>n>>h;\n\trep(i,n)cin>>a[i];\n\tsort(a+1,a+n+1);\n\tint t=h/(a[n-1]+a[n]);\n\th-=t*(a[n-1]+a[n]);\n\tt*=2;\n\tif(h>0) h-=a[n],t++;\n\tif(h>0) h-=a[n-1],t++;\n\tcout<<t<<endl;\n}\nint main()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}']","['binary search', 'greedy', 'math', 'sortings']",800
https://codeforces.com//contest/1111/problem/E,E. Tree,You are given a tree with n nodes and q queries Every query starts with three integers k m and r followed by k nodes of the tree a 1 a 2 ldots a k To answer a query assume that the tree is rooted at r We want to divide the k given nodes into m groups such that the following conditions are met Each node should be in exactly one group and each group should have at least one node In any group there should be no two distinct nodes such that one node is an ancestor direct or indirect of the other You need to output the number of ways modulo 10 9 7 for every query ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+7,mod=1e9+7;\nint n,q,k,m,r,cnt,a[N],b[N],v[N],nxt[N],hd[N],sz[N],dep[N],fa[N],pos[N],son[N],top[N],d[N],f[365];\nvoid add(int x,int y){v[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;}\nvoid dfs1(int u)\n{\n\tsz[u]=1,dep[u]=dep[fa[u]]+1;\n\tfor(int i=hd[u];i;i=nxt[i])\n\tif(v[i]!=fa[u])\n\t{\n\t\tfa[v[i]]=u,dfs1(v[i]),sz[u]+=sz[v[i]];\n\t\tif(sz[v[i]]>sz[son[u]])son[u]=v[i];\n\t}\n}\nvoid dfs2(int u,int tp)\n{\n\ttop[u]=tp,pos[u]=++cnt;\n\tif(son[u])dfs2(son[u],tp);\n\tfor(int i=hd[u];i;i=nxt[i])if(v[i]!=fa[u]&&v[i]!=son[u])dfs2(v[i],v[i]);\n}\nint lca(int x,int y)\n{\n\twhile(top[x]!=top[y])(dep[top[x]]>dep[top[y]])?x=fa[top[x]]:y=fa[top[y]];\n\treturn dep[x]<dep[y]?x:y;\n}\nvoid update(int x,int v){while(x<=n)d[x]+=v,x+=x&-x;}\nint query(int x){int ret=0;while(x)ret+=d[x],x-=x&-x;return ret;}\nint query(int l,int r){return query(r)-query(l-1);}\nint ask(int x,int y)\n{\n\tint ret=0;\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tret+=query(pos[top[x]],pos[x]);\n\t\tx=fa[top[x]];\n\t}\n\tret+=query(min(pos[x],pos[y]),max(pos[x],pos[y]));\n\treturn ret;\n}\nint main()\n{\n\tscanf(""%d%d"",&n,&q);\n\tfor(int i=1,x,y;i<n;i++)scanf(""%d%d"",&x,&y),add(x,y),add(y,x);\n\tdfs1(1),cnt=0,dfs2(1,1);\n\twhile(q--)\n\t{\n\t\tscanf(""%d%d%d"",&k,&m,&r);\n\t\tfor(int i=1;i<=k;i++)scanf(""%d"",&b[i]),update(pos[b[i]],1);\n\t\tfor(int i=1;i<=k;i++)a[i]=ask(b[i],r)-1;\n\t\tsort(a+1,a+k+1);\n\t\tint flag=0;\n\t\tfor(int i=1;!flag&&i<=k;i++)\n\t\tif(a[i]>=m)flag=1;\n\t\tif(flag)\n\t\t{\n\t\t\tputs(""0"");for(int i=1;i<=k;i++)update(pos[b[i]],-1);\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(f,0,sizeof f);\n\t\tf[0]=1;\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=min(i,m);~j;j--)\n\t\tif(j<=a[i])f[j]=0;else f[j]=(1ll*f[j]*(j-a[i])%mod+f[j-1])%mod;\n\t\tint ans=0;\n\t\tfor(int i=0;i<=m;i++)ans=(ans+f[i])%mod;\n\t\tprintf(""%d\\n"",ans);\n\t\tfor(int i=1;i<=k;i++)update(pos[b[i]],-1);\n\t}\n}']","['data structures', 'dfs and similar', 'dp', 'graphs', 'trees']",2500
https://codeforces.com//contest/1500/problem/A,A. Going Home,It was the third month of remote learning Nastya got sick of staying at dormitory so she decided to return to her hometown In order to make her trip more entertaining one of Nastya s friend presented her an integer array a Several hours after starting her journey home Nastya remembered about the present To entertain herself she decided to check are there four indices x y z w such that a x a y a z a w Her train has already arrived the destination but she still hasn t found the answer Can you help her unravel the mystery ,"['/**\n *    author:  tourist\n *    created: 13.03.2021 12:04:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  int mx = *max_element(a.begin(), a.end()) + 1;\n  vector<int> p1(mx, -1);\n  vector<int> p2(mx, -1);\n  vector<int> p3(mx, -1);\n  for (int i = 0; i < n; i++) {\n    if (p1[a[i]] == -1) {\n      p1[a[i]] = i;\n      continue;\n    }\n    if (p2[a[i]] == -1) {\n      p2[a[i]] = i;\n      continue;\n    }\n    if (p3[a[i]] == -1) {\n      p3[a[i]] = i;\n      continue;\n    }\n    cout << ""YES"" << \'\\n\';\n    cout << p1[a[i]] + 1 << "" "" << p2[a[i]] + 1 << "" "" << p3[a[i]] + 1 << "" "" << i + 1 << \'\\n\';\n    return 0;\n  }\n  vector<int> ind;\n  int two = -1;\n  for (int i = 0; i < mx; i++) {\n    if (p1[i] == -1) {\n      continue;\n    }\n    ind.push_back(p1[i]);\n    if (p2[i] == -1) {\n      continue;\n    }\n    if (two != -1) {\n      cout << ""YES"" << \'\\n\';\n      cout << p1[two] + 1 << "" "" << p1[i] + 1 << "" "" << p2[two] + 1 << "" "" << p2[i] + 1 << \'\\n\';\n      return 0;\n    }\n    two = i;\n  }\n  vector<pair<int, int>> met(2 * mx, make_pair(-1, -1));\n  sort(ind.begin(), ind.end());\n  if (two != -1) {\n    met[two + two] = make_pair(p1[two], p2[two]);\n  }\n  for (int i = 0; i < (int) ind.size(); i++) {\n    for (int j = i + 1; j < (int) ind.size(); j++) {\n      int sum = a[ind[i]] + a[ind[j]];\n      if (met[sum].first != -1) {\n        cout << ""YES"" << \'\\n\';\n        cout << met[sum].first + 1 << "" "" << met[sum].second + 1 << "" "" << ind[i] + 1 << "" "" << ind[j] + 1 << \'\\n\';\n        return 0;\n      }\n      met[sum] = make_pair(ind[i], ind[j]);\n    }\n  }\n  cout << ""NO"" << \'\\n\';\n  return 0;\n}\n']","['brute force', 'hashing', 'implementation', 'math']",1800
https://codeforces.com//contest/1078/problem/C,C. Vasya and Maximum Matching,Vasya has got a tree consisting of n vertices He wants to delete some possibly zero edges in this tree such that the maximum matching in the resulting graph is unique He asks you to calculate the number of ways to choose a set of edges to remove A matching in the graph is a subset of its edges such that there is no vertex incident to two or more edges from the subset A maximum matching is a matching such that the number of edges in the subset is maximum possible among all matchings in this graph Since the answer may be large output it modulo 998244353 ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nvector<vector<int> > edges;\nconst LL MOD = 998244353;\nstruct dp {\n\tint a, b, c;\n};\ndp solve(int v, int p){\n\tvector<LL> matched;\n\tvector<LL> unmatched;\n\tvector<LL> unused;\n\tfor(int a : edges[v]){\n\t\tif(a == p) continue;\n\t\tdp x = solve(a, v);\n\t\tmatched.push_back(x.a);\n\t\tunmatched.push_back(x.b);\n\t\tunused.push_back(x.c);\n\t}\n\tint k = matched.size();\n\tdp x;\n\tx.a = 1;\n\tx.b = 0;\n\tx.c = 1;\n\tif(k == 0) return x;\n\tfor(int i = 0; i < k; i++){\n\t\tx.a = (x.a * (unmatched[i] + unused[i])) % MOD;\n\t}\n\tfor(int i = 0; i < k; i++){\n\t\tx.c = (x.c * (unused[i])) % MOD;\n\t}\n\tvector<LL> left_prod(k);\n\tvector<LL> right_prod(k);\n\tleft_prod[0] = 1;\n\tright_prod[k-1] = 1;\n\tfor(int i = 1; i < k; i++){\n\t\tleft_prod[i] = (left_prod[i-1] * (unmatched[i-1] + unused[i-1])) % MOD;\n\t}\n\tfor(int i = k-2; i >= 0; i--){\n\t\tright_prod[i] = (right_prod[i+1] * (unmatched[i+1] + unused[i+1])) % MOD;\n\t}\n\tfor(int i = 0; i < k; i++){\n\t\tLL z = left_prod[i] * right_prod[i];\n\t\tz %= MOD;\n\t\tz = (z * matched[i]) % MOD;\n\t\tx.b = (x.b + z) % MOD;\n\t}\n\tx.c = (x.c + x.b) % MOD;\n\treturn x;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tedges.resize(n);\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--; \n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tLL ans = solve(0, -1).c;\n\tans %= MOD;\n\tif(ans < 0) ans += MOD;\n\tcout << ans << '\\n';\n}""]","['combinatorics', 'dp', 'trees']",2400
https://codeforces.com//contest/1373/problem/A,A. Donut Shops,There are two rival donut shops The first shop sells donuts at retail each donut costs a dollars The second shop sells donuts only in bulk box of b donuts costs c dollars So if you want to buy x donuts from this shop then you have to buy the smallest number of boxes such that the total number of donuts in them is greater or equal to x You want to determine two values how many donuts can you buy so that they are strictly cheaper in the first shop than in the second shop how many donuts can you buy so that they are strictly cheaper in the second shop than in the first shop If any of these values doesn t exist then that value should be equal to 1 If there are multiple possible answers then print any of them ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        ll A, B, C; cin >> A >> B >> C;\n\n        if (A < C) {\n            cout << 1 << "" ""; \n        } else {\n            cout << ""-1 "";\n        }\n\n        if (C < A*B) {\n            cout << B;\n        } else cout << -1;\n        cout << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['greedy', 'implementation', 'math']",1000
https://codeforces.com//contest/1669/problem/C,C. Odd Even Increments,Given an array a a 1 a 2 dots a n of n positive integers you can do operations of two types on it Add 1 to element with an index In other words change the array as follows a 1 a 1 1 a 3 a 3 1 a 5 a 5 1 dots Add 1 to element with an index In other words change the array as follows a 2 a 2 1 a 4 a 4 1 a 6 a 6 1 dots Determine if after any number of operations it is possible to make the final array contain only even numbers or only odd numbers In other words determine if you can make all elements of the array have the same parity after any number of operations Note that you can do operations of both types any number of times even none Operations of different types can be performed a different number of times ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n;\n  cin >> n;\n  int a[n];\n  bool bad = 0;\n  rep(i, n){\n    cin >> a[i];\n    if(i >= 2){\n      if(a[i] % 2 != a[i - 2] % 2) bad = 1;\n    }\n  }\n  cout << (bad ? ""NO"" : ""YES"") << \'\\n\';\n}\n\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << ""Case #"" << i << "": "";\n      solve();\n    }\n    return 0;\n}   ']","['greedy', 'greedy', 'implementation', 'math']",800
https://codeforces.com//contest/113/problem/C,C. Double Happiness,On the math lesson a teacher asked each pupil to come up with his own lucky numbers As a fan of number theory Peter chose prime numbers Bob was more original He said that number is his lucky number if it can be represented as where are arbitrary positive integers Now the boys decided to find out how many days of the interval are suitable for pair programming They decided that the day is suitable for pair programming if and only if the number is lucky for Peter and lucky for Bob at the same time Help the boys to find the number of such days ,"['//  Codeforces Beta Round #86\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << ""("" << i->first << "", "" << i->second << "") ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= \' \'; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\n\nconst int LIM = 20000;\nint isnp[20010];\nint psLen, ps[20010];\n\nconst int LIM2 = 300000000;\nconst int K = 1000000;\nint cnt[310];\n\nvoid prpr() {\n    int i, j;\n    for (i = 2; i * i < LIM; ++i) if (!isnp[i]) {\n        for (j = i * i; j < LIM; j += i) isnp[j] = 1;\n    }\n    for (i = 2; i < LIM; ++i) if (!isnp[i]) {\n        ps[psLen++] = i;\n    }\n}\nbool isLucky(int n) {\n    if (n < 2) return 0;\n    if (n != 2 && n % 4 != 1) return 0;\n    int i;\n    for (i = 0; i < psLen && ps[i] < n; ++i) if (n % ps[i] == 0) return 0;\n    return 1;\n}\n\n/*\nint main() {\n    int i;\n    \n    prpr();\n    \n    ++cnt[0];\n    for (i = 5; i < LIM2; i += 4) {\n        if (isLucky(i)) {\n            ++cnt[i / K];\n        }\n    }\n    for (i = 0; i < LIM2 / K; ++i) {\n        printf(""%d,"", cnt[i]);\n    }\n    puts("""");\n    \n    return 0;\n}\n//*/\n\n//*\nint prec[] = { \n39176,35241,33867,33219,32691,32139,31928,31499,31341,31080,30899,30913,30576,30405,30301,30139,30087,30002,29854,29814,29600,29719,29406,29422,29436,29274,29336,29150,29172,29094,29091,28875,28873,28902,28653,28729,28749,28687,28754,28595,28584,28417,28392,28489,28355,28315,28386,28313,28256,28258,28169,28080,28070,28052,28033,28035,27971,28017,27892,27899,27976,27713,27847,27868,27831,27821,27783,27794,27716,27699,27611,27660,27723,27534,27588,27680,27510,27458,27448,27443,27498,27578,27454,27448,27327,27347,27304,27472,27326,27266,27219,27227,27345,27189,27308,27228,27199,27167,27086,27143,27101,27097,27178,27021,27107,27013,26975,27086,27143,27133,26917,27074,26976,26792,26905,26928,26827,26892,26881,26925,26796,26823,26879,26934,26831,26788,26788,26857,26912,26781,26706,26816,26714,26709,26784,26590,26671,26605,26625,26836,26539,26668,26606,26717,26639,26632,26642,26559,26499,26563,26417,26555,26338,26617,26477,26456,26642,26415,26339,26483,26470,26399,26468,26593,26352,26354,26345,26398,26378,26469,26346,26372,26390,26434,26306,26359,26331,26390,26348,26469,26168,26342,26128,26258,26390,26251,26268,26241,26223,26395,25941,26110,26293,26226,26247,26183,26099,26034,26139,26190,26168,26268,26107,26223,26137,26001,26145,26052,25999,26168,26038,26225,26168,26057,26095,26173,26094,25948,25966,25999,25994,26045,26114,25971,26158,25913,26090,25813,25930,25903,25956,26020,26001,25825,25939,25950,26045,25925,26008,25808,26013,25938,25712,25883,25989,25900,25794,25760,25943,25783,25953,25667,25756,25915,25963,25824,25858,25833,25905,25729,25951,25770,25971,25767,25859,25928,25627,25767,25863,25623,25772,25706,25657,25806,25819,25724,25712,25735,25587,25726,25606,25780,25597,25743,25704,25615,25592,25770,25735,25588,25755,25680,25519,25692,25737,25552,25616,25639,25521,25530,\n};\n\nint A, B;\n\nint main() {\n    int i;\n    \n    prpr();\n    \n    for (; ~scanf(""%d%d"", &A, &B); ) {\n        int a = A, b = B;\n        int ans = 0;\n        for (; a <= b && a % K != 0; ++a) {\n            if (isLucky(a)) {\n                ++ans;\n            }\n        }\n        for (; a <= b && (b + 1) % K != 0; --b) {\n            if (isLucky(b)) {\n                ++ans;\n            }\n        }\n        if (a <= b) {\n            for (i = a / K; i <= b / K; ++i) {\n                ans += prec[i];\n            }\n        }\n        printf(""%d\\n"", ans);\n    }\n    \n    return 0;\n}\n//*/\n']","['brute force', 'math', 'number theory']",2200
https://codeforces.com//contest/869/problem/A,A. The Artful Expedient,After Karen have found the deterministic winning losing strategy for rock paper scissors her brother Koyomi comes up with a new game as a substitute The game works as follows A positive integer is decided first Both Koyomi and Karen independently choose distinct positive integers denoted by and respectively They reveal their sequences and repeat until which is the only final state to be kept and considered Then they count the number of ordered pairs such that the value equals to one of the integers Here means the bitwise exclusive or operation on two integers and is denoted by operators and or in most programming languages Karen claims a win if the number of such pairs is even and Koyomi does otherwise And you re here to help determine the winner of their latest game ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, a[2020], b[2020];\nint v[10000020];\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tv[a[i]] = 1;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &b[i]);\n\t\tv[b[i]] = 1;\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (v[a[i] ^ b[j]]) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(cnt % 2 ? ""Koyomi\\n"" : ""Karen\\n"");\n\treturn 0;\n}']","['brute force', 'implementation']",1100
https://codeforces.com//contest/1245/problem/E,E. Hyakugoku and Ladders,Hyakugoku has just retired from being the resident deity of the South Black Snail Temple in order to pursue her dream of becoming a cartoonist She spent six months in that temple just playing Cat s Cradle so now she wants to try a different game Snakes and Ladders Unfortunately she already killed all the snakes so there are only ladders left now The game is played on a 10 times 10 board as follows At the beginning of the game the player is at the bottom left square The objective of the game is for the player to reach the Goal the top left square by following the path and climbing vertical ladders Once the player reaches the Goal the game ends The path is as follows if a square is not the end of its row it leads to the square next to it along the direction of its row if a square is the end of its row it leads to the square above it The direction of a row is determined as follows the direction of the bottom row is to the right the direction of any other row is opposite the direction of the row below it See Notes section for visualization of path During each turn the player rolls a standard six sided dice Suppose that the number shown on the dice is r If the Goal is less than r squares away on the path the player doesn t move but the turn is performed Otherwise the player advances exactly r squares along the path and then stops If the player stops on a square with the bottom of a ladder the player that ladder If she chooses not to climb then she stays in that square for the beginning of the next turn Some squares have a ladder in them Ladders are only placed vertically each one leads to the same square of some of the upper rows In order for the player to climb up a ladder after rolling the dice she must stop at the square containing the bottom of the ladder After using the ladder the player will end up in the square containing the top of the ladder She cannot leave the ladder in the middle of climbing And if the square containing the top of the ladder also contains the bottom of another ladder she is not allowed to use that second ladder The numbers on the faces of the dice are 1 2 3 4 5 and 6 with each number having the same probability of being shown Please note that it is possible for ladders to overlap but the player cannot switch to the other ladder while in the middle of climbing the first one it is possible for ladders to go straight to the top row but not any higher it is possible for two ladders to lead to the same tile it is possible for a ladder to lead to a tile that also has a ladder but the player will not be able to use that second ladder if she uses the first one the player can only climb up ladders not climb down Hyakugoku wants to finish the game as soon as possible Thus on each turn she chooses whether to climb the ladder or not optimally Help her to determine the minimum expected number of turns the game will take ,"['#include<bits/stdc++.h>\nusing namespace std;\nint p2i(int x, int y)\n{\n    if(x%2 == 0) return x*10+y;\n    return x*10+9-y;\n}\nint arr[10][10];\nint flatten[100];\ndouble dp[100];\nint main()\n{\n    for(int i=0; i<10; ++i)\n        for(int j=0; j<10; ++j)\n        {\n            scanf(""%d"", &arr[i][j]);\n            int c = p2i(i, j);\n            flatten[c] = -1;\n            if(arr[i][j])\n            {\n                int ni = i-arr[i][j];\n                int nj = j;\n                flatten[c] = p2i(ni, nj);\n            }\n        }\n    dp[0] = 0;\n    for(int i=1; i<100; ++i)\n    {\n        double ans = 0;\n        int pass = 0;\n        for(int j=1; j<=6; ++j)\n        {\n            if(j>i)\n            {\n                ++pass; continue;\n            }\n            int dest = i-j;\n            double cost = dp[dest];\n            \n            if(flatten[dest] != -1)\n                cost = min(cost, dp[flatten[dest]]);\n            ans += cost;\n        }\n        dp[i] = (ans+6)/(6-pass);\n    }\n    printf(""%.12f\\n"", dp[99]);\n}']","['dp', 'probabilities', 'shortest paths']",2300
https://codeforces.com//contest/493/problem/B,B. Vasya and Wrestling,Vasya has become interested in wrestling In wrestling wrestlers use techniques for which they are awarded points by judges The wrestler who gets the most points wins When the numbers of points of both wrestlers are equal the wrestler whose sequence of points is wins If the sequences of the awarded points coincide the wrestler who performed the last technique wins Your task is to determine which wrestler won ,"['#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\nusing namespace std;\n\nlong long a[1000006], b[1000006];\nlong long acnt, bcnt;\nlong long atotal, btotal;\n\nint main()\n{\n    int n;\n    cin>>n;\n    acnt = bcnt = 0;\n    atotal = btotal = 0;\n    string ans;\n    \n    for(int i = 0; i < n; ++i)\n    {\n        int tmp;\n        cin>>tmp;\n        if(tmp > 0)\n        {\n            a[acnt++] = tmp;\n            atotal += tmp;\n            ans = ""first"";\n        }\n        else\n        {\n            tmp = -tmp;\n            b[bcnt++] = tmp;\n            btotal += tmp;\n            ans = ""second"";\n        }\n    }\n    \n    if(atotal > btotal)\n    {\n        cout<<""first""<<endl;\n        return 0;\n    }\n    \n    if(atotal < btotal)\n    {\n        cout<<""second""<<endl;\n        return 0;\n    }\n    \n    for(int i = 0; i < min(acnt, bcnt); ++i)\n    {\n        if(a[i] > b[i])\n        {\n            cout<<""first""<<endl;\n            return 0;\n        }\n        if(a[i] < b[i])\n        {\n            cout<<""second""<<endl;\n            return 0;\n        }\n    }\n    \n    if(acnt > bcnt)\n    {\n        cout<<""first""<<endl;\n        return 0;\n    }\n    if(acnt < bcnt)\n    {\n        cout<<""second""<<endl;\n        return 0;\n    }\n    \n    cout<<ans<<endl;\n    return 0;\n}']",['implementation'],1400
https://codeforces.com//contest/1744/problem/F,F. MEX vs MED,You are given a permutation p 1 p 2 ldots p n of length n of numbers 0 ldots n 1 Count the number of subsegments 1 leq l leq r leq n of this permutation such that mex p l p l 1 ldots p r med p l p l 1 ldots p r mex of S is the smallest non negative integer that does not occur in S For example mex 0 1 2 3 4 mex 0 4 1 3 2 mex 5 4 0 1 2 3med of the set S is the median of the set i e the element that after sorting the elements in non decreasing order will be at position number left lfloor frac S 1 2 right rfloor array elements are numbered starting from 1 and here left lfloor v right rfloor denotes rounding v down For example med 0 1 2 3 1 med 0 4 1 3 1 med 5 4 0 1 2 2A sequence of n numbers is called a permutation if it contains all the numbers from 0 to n 1 exactly once ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint t,n;\nint a[200007],pos[200007];\nint mins,maxs,curr;\n\nlong long ans;\n\nlong long calc(int l,int r,int len){\n    len-=(r-l+1);\n    long long lt=max(l-len,1),rt=min(n-len-(r-l+1)+1,l);\n    return rt-lt+1;\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>t;\n    for(int i=1;i<=t;i++){\n        cin>>n;\n        for(int f=1;f<=n;f++){\n            cin>>a[f];\n            pos[a[f]]=f;\n        }\n        curr=ans=0;\n        mins=n; maxs=-1;\n        for(int f=1;f<=n;f++){\n            if(f%2==1){\n                mins=min(mins,pos[curr]);\n                maxs=max(maxs,pos[curr]);\n                curr++;\n            }\n            if(maxs-mins+1>f)continue;\n            ans+=calc(mins,maxs,f);\n        }\n        cout<<ans<<""\\n"";\n    }\n\n    return 0;\n}\n']","['math', 'two pointers']",2000
https://codeforces.com//contest/1659/problem/D,D. Reverse Sort Sum,Suppose you had an array A of n elements each of which is 0 or 1 Let us define a function f k A which returns another array B the result of sorting the first k elements of A in non decreasing order For example f 4 0 1 1 0 0 1 0 0 0 1 1 0 1 0 Note that the first 4 elements were sorted Now consider the arrays B 1 B 2 ldots B n generated by f 1 A f 2 A ldots f n A Let C be the array obtained by taking the element wise sum of B 1 B 2 ldots B n For example let A 0 1 0 1 Then we have B 1 0 1 0 1 B 2 0 1 0 1 B 3 0 0 1 1 B 4 0 0 1 1 Then C B 1 B 2 B 3 B 4 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 1 0 2 2 4 You are given C Determine a binary array A that would give C when processed as above It is guaranteed that an array A exists for given C in the input ,"['#include<iostream>\nusing namespace std;\nint a[200010];\nbool ans[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint p=0;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tif(p<i) {\n\t\t\t\tif(a[i]==0) {\n\t\t\t\t\tans[i]=0,p=i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[i]=1,p=i;\n\t\t\t}\n\t\t\tif(ans[i]) {\n\t\t\t\ta[i]-=i-1;\n\t\t\t}\n\t\t\ta[i]-=p-i+1;\n\t\t\twhile(a[i]--) {\n\t\t\t\tans[++p]=1;\n\t\t\t}\n\t\t\tif(p<n) {\n\t\t\t\tans[++p]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcout<<ans[i]<<"" "";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'data structures', 'greedy', 'implementation', 'math', 'two pointers']",1900
https://codeforces.com//contest/1313/problem/A,A. Fast Food Restaurant,Tired of boring office work Denis decided to open a fast food restaurant On the first day he made a portions of dumplings b portions of cranberry juice and c pancakes with condensed milk The peculiarity of Denis s restaurant is the procedure of ordering food For each visitor Denis himself chooses a set of dishes that this visitor will receive When doing so Denis is guided by the following rules every visitor should receive at least one dish dumplings cranberry juice pancakes with condensed milk are all considered to be dishes each visitor should receive no more than one portion of dumplings no more than one portion of cranberry juice and no more than one pancake with condensed milk all visitors should receive different sets of dishes What is the maximum number of visitors Denis can feed ,"['#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-\'0\',ch=getchar();\n\treturn f?x:-x;\n}\nint C[][3]={\n\t{0,0,1},\n\t{0,1,0},\n\t{1,0,0},\n\t{0,1,1},\n\t{1,0,1},\n\t{1,1,0},\n\t{1,1,1}\n};\nint main(){\n#ifdef LOCAL\n\tfreopen(""in.in"",""r"",stdin);\n\t//freopen(""out.out"",""w"",stdout);\n#endif\n\tint T=gi();\n\twhile(T--){\n\t\tint a=gi(),b=gi(),c=gi(),ans=0;\n\t\tfor(int i=0;i<1<<7;++i){\n\t\t\tint sa=0,sb=0,sc=0;\n\t\t\tfor(int j=0;j<7;++j)if(i>>j&1)sa+=C[j][0],sb+=C[j][1],sc+=C[j][2];\n\t\t\tif(sa<=a&&sb<=b&&sc<=c)ans=std::max(ans,__builtin_popcount(i));\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}\n']","['brute force', 'greedy', 'implementation']",900
https://codeforces.com//contest/1214/problem/F,F. Employment,Two large companies Cecsi and Poca Pola are fighting against each other for a long time In order to overcome their competitor Poca Pola started a super secret project for which it has total n vacancies in all of their offices After many tests and interviews n candidates were selected and the only thing left was their employment Because all candidates have the same skills it doesn t matter where each of them will work That is why the company decided to distribute candidates between workplaces so that the total distance between home and workplace over all candidates is minimal It is well known that Earth is round so it can be described as a circle and all m cities on Earth can be described as points on this circle All cities are enumerated from 1 to m so that for each i 1 le i le m 1 cities with indexes i and i 1 are neighbors and cities with indexes 1 and m are neighbors as well People can move only along the circle The distance between any two cities equals to minimal number of transitions between neighboring cities you have to perform to get from one city to another In particular the distance between the city and itself equals 0 The Poca Pola vacancies are located at offices in cities a 1 a 2 ldots a n The candidates live in cities b 1 b 2 ldots b n It is possible that some vacancies are located in the same cities and some candidates live in the same cities The Poca Pola managers are too busy with super secret project so you were asked to help Poca Pola to distribute candidates between workplaces so that the sum of the distance between home and workplace over all candidates is minimum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nint m,n,mat[N];\nPII p[N],q[N];\nll cc[N];\n\nvoid add(PII *q,int i,int l,int r,int v,int ty=0) {\n\tint pl=lower_bound(q,q+n,mp(l,-1))-q;\n\tint pr=lower_bound(q,q+n,mp(r+1,-1))-q-1;\n//\tprintf(""gg %d %d\\n"",pl,pr);\n\tif (pl>pr) return;\n\tif (ty==0) {\n\t\tpl-=i; pr-=i; \n\t} else {\n\t\tswap(pl,pr); pl=i-pl; pr=i-pr;\n\t}\n//\tprintf(""add %d %d %d\\n"",pl,pr,v);\n\tif (pl>=0&&pr>=0) cc[pl]+=v,cc[pr+1]-=v;\n\telse if (pl<0&&pr<0) cc[pl+n]+=v,cc[pr+1+n]-=v;\n\telse {\n\t\tcc[pl+n]+=v; cc[n]-=v;\n\t\tcc[0]+=v; cc[pr+1]-=v;\n\t}\n}\n\nint main() {\n\tscanf(""%d%d"",&m,&n);\n\trep(i,0,n) scanf(""%d"",&p[i].fi),p[i].se=i;\n\trep(i,0,n) scanf(""%d"",&q[i].fi),q[i].se=i;\n\tsort(p,p+n); sort(q,q+n);\n\trep(i,0,n) {\n\t\tadd(q,i,p[i].fi-m,p[i].fi-m/2-1,m-p[i].fi);\n\t\tadd(q,i,p[i].fi-m/2,p[i].fi-1,p[i].fi);\n\t\tadd(q,i,p[i].fi,p[i].fi+m/2,-p[i].fi);\n\t\tadd(q,i,p[i].fi+m/2+1,p[i].fi+m,p[i].fi+m);\n\t}\n\trep(i,0,n) {\n\t\tadd(p,i,q[i].fi-m,q[i].fi-m/2-1,-q[i].fi,1);\n\t\tadd(p,i,q[i].fi-m/2,q[i].fi,q[i].fi,1);\n\t\tadd(p,i,q[i].fi+1,q[i].fi+m/2,-q[i].fi,1);\n\t\tadd(p,i,q[i].fi+m/2+1,q[i].fi+m,q[i].fi,1);\n\t}\n\trep(i,1,n+1) cc[i]+=cc[i-1];\n\tint md=min_element(cc,cc+n)-cc;\n\trep(i,0,n) mat[p[i].se]=q[(i+md)%n].se;\n\tprintf(""%lld\\n"",cc[md]);\n\trep(i,0,n) printf(""%d%c"",mat[i]+1,"" \\n""[i==n-1]);\n}\n']","['greedy', 'sortings']",2700
https://codeforces.com//contest/1554/problem/A,A. Cherry,You are given n integers a 1 a 2 ldots a n Find the maximum value of max a l a l 1 ldots a r cdot min a l a l 1 ldots a r over all pairs l r of integers for which 1 le l r le n ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint T,n,a[100010];\nint main(){\n    scanf(""%d"",&T);\n    while(T--){\n        scanf(""%d"",&n);\n        for(int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n        long long ans=0;\n        for(int i=1;i<n;i++){\n            ans=max(ans,1ll*a[i]*a[i+1]);\n        }\n        printf(""%lld\\n"",ans);\n    }\n    return 0;\n}']",['greedy'],800
https://codeforces.com//contest/1307/problem/C,C. Cow and Message,Bessie the cow has just intercepted a text that Farmer John sent to Burger Queen However Bessie is sure that there is a secret message hidden inside The text is a string s of lowercase Latin letters She considers a string t as hidden in string s if t exists as a subsequence of s whose indices form an arithmetic progression For example the string is hidden in string because it occurs at indices 1 3 and 5 which form an arithmetic progression with a common difference of 2 Bessie thinks that any hidden string that occurs the most times is the secret message Two occurrences of a subsequence of S are distinct if the sets of indices are different Help her find the number of occurrences of the secret message For example in the string is hidden 3 times is hidden 2 times is hidden 6 times is hidden 3 times is hidden 1 time is hidden 2 times is hidden 1 time is hidden 1 time is hidden 1 time is hidden 1 time and is hidden 1 time The number of occurrences of the secret message is 6 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nchar s[N];\nll cnt[40][40],cc[40],ans;\nint main() {\n\tscanf(""%s"",s);\n\tint n=strlen(s);\n\trep(i,0,n) {\n\t\tint w=s[i]-\'a\';\n\t\trep(j,0,26) cnt[w][j]+=cc[j];\n\t\tcc[w]++;\n\t}\n\trep(i,0,26) rep(j,0,26) ans=max(ans,cnt[i][j]);\n\trep(i,0,26) ans=max(ans,cc[i]);\n\tprintf(""%lld\\n"",ans);\n}\n']","['brute force', 'dp', 'math', 'strings']",1500
https://codeforces.com//contest/798/problem/E,E. Mike and code of a permutation,Mike has discovered a new way to encode permutations If he has a permutation he will encode it in the following way Denote by a sequence of length which will represent the code of the permutation For each from to sequentially he will choose the smallest unmarked such that and will assign to the number in other words he performs and will mark If there is no such he ll assign to the number he performs Mike forgot his original permutation but he remembers its code Your task is simple find permutation such that its code is the same as the code of Mike s original permutation You may assume that there will always be at least one valid permutation ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pr;\nconst double pi=acos(-1);\n#define rep(i,a,n) for(int i=a;i<=n;i++)\n#define per(i,n,a) for(int i=n;i>=a;i--)\n#define Rep(i,u) for(int i=head[u];i;i=Next[i])\n#define clr(a) memset(a,0,sizeof a)\n#define pb push_back\n#define mp make_pair\n#define putk() putchar(\' \')\nld eps=1e-9;\nll pp=1000000007;\nll mo(ll a,ll pp){if(a>=0 && a<pp)return a;a%=pp;if(a<0)a+=pp;return a;}\nll powmod(ll a,ll b,ll pp){ll ans=1;for(;b;b>>=1,a=mo(a*a,pp))if(b&1)ans=mo(ans*a,pp);return ans;}\nll gcd(ll a,ll b){return (!b)?a:gcd(b,a%b);}\nll read(){\n\tll ans=0;\n\tchar last=\' \',ch=getchar();\n\twhile(ch<\'0\' || ch>\'9\')last=ch,ch=getchar();\n\twhile(ch>=\'0\' && ch<=\'9\')ans=ans*10+ch-\'0\',ch=getchar();\n\tif(last==\'-\')ans=-ans;\n\treturn ans;\n}\nvoid put(ll a){\n\tif(a<0)putchar(\'-\'),a=-a;\n\tint top=0,q[20];\n\twhile(a)q[++top]=a%10,a/=10;\n\ttop=max(top,1);\n\twhile(top--)putchar(\'0\'+q[top+1]);\n}\n//head\n#define N 10000005\nint n,head[N],v[N*4],next[N*4],lson[N],rson[N],du[N],num,nn,a[N/10],root;\nbool b[N/10];\nvoid add(int x,int y){\n\tif(!x || !y)return;\n//\tcout<<x<<"" ""<<y<<endl;\n\tv[++num]=y;next[num]=head[x];head[x]=num;du[y]++;\n}\nvoid build(int &u,int v,int l,int r,int x){\n\tif(l==r){\n\t\tu=l;\n\t\treturn;\n\t}\n\tu=++nn;\n\tlson[u]=lson[v];\n\trson[u]=rson[v];\n\tint mid=(l+r)/2;\n\tif(x<=mid)build(lson[u],lson[v],l,mid,x);\n\telse build(rson[u],rson[v],mid+1,r,x);\n\tadd(lson[u],u);\n\tadd(rson[u],u);\n}\nvoid work(int u,int l,int r,int x,int y,int t){\n\tif(x<=l && y>=r){\n\t\tadd(u,t);\n\t\treturn;\n\t}\n\tif(x>r || y<l || u==0)return;\n\tint mid=(l+r)/2;\n\twork(lson[u],l,mid,x,y,t);\n\twork(rson[u],mid+1,r,x,y,t);\n}\nvoid work(int x,int y,int t){\n\tif(t<=y && t>=x){\n\t\tif(x<t)work(root,1,n,x,t-1,t);\n\t\tif(t<y)work(root,1,n,t+1,y,t);\n\t}\n\telse work(root,1,n,x,y,t);\n}\nint main(){\n//\tfreopen(""1.in"",""r"",stdin);\n\tn=read();\n\tnn=n;\n\trep(i,1,n){\n\t\ta[i]=read();\n\t\tif(a[i]!=-1)b[a[i]]=1;\n\t}\n\troot=0;\n\trep(i,1,n)\n\t\tif(b[i]==0)build(root,root,1,n,i);\n\tper(i,n,1){\n\t\tif(a[i]==-1)work(1,n,i);\n\t\telse work(1,a[i],i);\n\t\tif(a[i]!=-1){\n\t\t\tbuild(root,root,1,n,a[i]);\n\t\t\tadd(i,a[i]);\n\t\t}\n\t}\n\tint t=0,w=0;\n\trep(i,1,nn)\n\t\tif(du[i]==0)lson[++w]=i;\n\twhile(t<w){\n\t\tint u=lson[++t];\n\t\tfor(int i=head[u];i;i=next[i]){\n\t\t\tint t=v[i];\n\t\t\tdu[t]--;\n\t\t\tif(!du[t])lson[++w]=v[i];\n\t\t}\n\t}\n\tt=0;\n\trep(i,1,w)\n\t\tif(lson[i]<=n)rson[lson[i]]=++t;\n\trep(i,1,n-1)printf(""%d "",rson[i]);\n\tprintf(""%d\\n"",rson[n]);\n\treturn 0;\n}']","['constructive algorithms', 'data structures', 'graphs', 'sortings']",3000
https://codeforces.com//contest/1037/problem/F,F. Maximum Reduction,Given an array a of n integers and an integer k 2 le k le n where each element of the array is denoted by a i 0 le i n Perform the operation z given below on a and print the value of z a k modulo 10 9 7 function z array a integer k if length a k return 0 else b empty array ans 0 for i 0 length a k temp a i for j i i k 1 temp max temp a j append temp to the end of b ans ans temp return ans z b k ,"[""/**\n *    author:  tourist\n *    created: 02.09.2018 17:54:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int INV2 = inv(2);\n\ninline int sum_positive(int start, int finish, int step) {\n  if (start <= 0) {\n    return 0;\n  }\n  if (finish < 0) {\n    finish += abs(finish) / step * step;\n  }\n  while (finish < 0) {\n    finish += step;\n  }\n  int cnt = (start - finish) / step + 1;\n  int value = mul(mul(start + finish, cnt), INV2);\n  return value;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<pair<int,int>> e(n);\n  for (int i = 0; i < n; i++) {\n    cin >> e[i].first;\n    e[i].second = i;\n  }\n  sort(e.begin(), e.end());\n  vector<int> pr(n), ne(n);\n  for (int i = 0; i < n; i++) {\n    pr[i] = i - 1;\n    ne[i] = i + 1;\n  }\n  const int step = k - 1;\n  int ans = 0;\n  for (auto &pp : e) {\n    int i = pp.second;\n    int L = pr[i] + 1;\n    int R = ne[i] - 1;\n    int len = (R - L + 1);\n    if (len >= k) {\n      int pos = i - L;\n      int xstart = k;\n      int xfinish = k + (len - k) / step * step;\n      int xcnt = (xfinish - xstart) / step + 1;\n      {\n        int value = sum_positive(pos + 1 - xstart, pos + 1 - xfinish, step);\n        sub(ans, mul(value, pp.first));\n      }\n      {\n        add(ans, mul(mul(pos, xcnt), pp.first));\n        int value = sum_positive(xfinish + pos - len, xstart + pos - len, step);\n        sub(ans, mul(value, pp.first));\n      }\n      add(ans, mul(xcnt, pp.first));\n    }\n    if (pr[i] != -1) {\n      ne[pr[i]] = ne[i];\n    }\n    if (ne[i] != n) {\n      pr[ne[i]] = pr[i];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","['combinatorics', 'data structures', 'math']",2500
https://codeforces.com//contest/610/problem/B,B. Vika and Squares,Vika has jars with paints of distinct colors All the jars are numbered from to and the th jar contains liters of paint of color Vika also has an infinitely long rectangular piece of paper of width consisting of squares of size Squares are numbered and so on Vika decided that she will start painting squares one by one from left to right starting from the square number and some arbitrary color If the square was painted in color then the next square will be painted in color In case of next square is painted in color If there is no more paint of the color Vika wants to use now then she stops Square is always painted in only one color and it takes exactly liter of paint Your task is to calculate the maximum number of squares that might be painted if Vika chooses right color to paint the first square ,"[""#include<cstdio>\n#include<cassert>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\n\n\nint n;\nint a[422222];\nint main()\n{\n    gn(n);\n    int mi=inf;\n    for (int i=1;i<=n;i++){\n        gn(a[i]);\n        mi=min(mi,a[i]);\n    }\n    for (int i=n+1;i<=2*n;i++)a[i]=a[i-n];\n    int ma=0;\n    for (int i=1;i<=2*n;i++)if(a[i]>=mi+1 && a[i-1]<mi+1){\n        int j=i;\n        for (;j<=2*n && a[j]>=mi+1;j++);\n        ma=max(ma,j-i);\n    }\n    cout<<1ll*mi*n+ma<<endl;\n    return 0;\n}\n""]","['constructive algorithms', 'implementation']",1300
https://codeforces.com//contest/1695/problem/C,C. Zero Path,You are given a grid with n rows and m columns We denote the square on the i th 1 le i le n row and j th 1 le j le m column by i j and the number there by a ij All numbers are equal to 1 or to 1 You start from the square 1 1 and can move one square down or one square to the right at a time In the end you want to end up at the square n m Is it possible to move in such a way so that the sum of the values written in all the visited cells including a 11 and a nm is 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n, m;\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        vector<vector<int>> a(n, vector<int>(m, 0)), l(n, vector<int>(m, 0)), r(n, vector<int>(m, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> a[i][j];\n                if (i == 0 && j == 0) {\n                    l[i][j] = r[i][j] = 0;\n                } else if (i == 0) {\n                    l[i][j] = l[i][j - 1];\n                    r[i][j] = r[i][j - 1];\n                } else if (j == 0) {\n                    l[i][j] = l[i - 1][j];\n                    r[i][j] = r[i - 1][j];\n                } else {\n                    l[i][j] = min(l[i - 1][j], l[i][j - 1]);\n                    r[i][j] = max(r[i - 1][j], r[i][j - 1]);\n                }\n                l[i][j] += a[i][j]; r[i][j] += a[i][j];\n            }\n        }\n        if ((n + m - 1) % 2 == 1) {\n            cout << ""NO"" << endl;\n            continue;\n        }\n        if (l[n - 1][m - 1] <= 0 && 0 <= r[n - 1][m - 1]) cout << ""YES"" << endl;\n        else cout << ""NO"" << endl;\n    }\n    return 0;\n}']","['brute force', 'data structures', 'dp', 'graphs', 'greedy', 'shortest paths']",1700
https://codeforces.com//contest/243/problem/C,C. Colorado Potato Beetle,Old MacDonald has a farm and a large potato field square meters in size The field is divided into square garden beds each bed takes up one square meter Old McDonald knows that the Colorado potato beetle is about to invade his farm and can destroy the entire harvest To fight the insects Old McDonald wants to spray some beds with insecticides So Old McDonald went to the field stood at the center of the central field bed and sprayed this bed with insecticides Now he s going to make a series of movements and spray a few more beds During each movement Old McDonald moves left right up or down the field some integer number of meters As Old McDonald moves he sprays all the beds he steps on In other words the beds that have any intersection at all with Old McDonald s trajectory are sprayed with insecticides When Old McDonald finished spraying he wrote out all his movements on a piece of paper Now he wants to know how many beds won t be infected after the invasion of the Colorado beetles It is known that the invasion of the Colorado beetles goes as follows First some bed on the field border gets infected Than any bed that hasn t been infected hasn t been sprayed with insecticides and has a common side with an infected bed gets infected as well Help Old McDonald and determine the number of beds that won t be infected by the Colorado potato beetle ,"['#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <sstream>\n#define zero(a) (abs(a)<eps)\n#define lowbit(a) ((a)&(-(a)))\n#define abs(a) ((a)>0?(a):(-(a)))\n#define dj(x1,y1,x2,y2) ((x1)*(x2)+(y1)*(y2))\n#define cj(x1,y1,x2,y2) ((x1)*(y2)-(x2)*(y1))\n#define dis(x1,y1,x2,y2) (((x2)-(x1))*((x2)-(x1))+((y2)-(y1))*((y2)-(y1)))\nconst double eps = 1e-9;\nconst double pi = acos(-1);\nconst int oo = 1000000000;\nconst int mod = 1000000009;\nconst double E = 2.7182818284590452353602874713527;\nusing namespace std;\n\nstruct case1\n{\n   bool flag;\n   int x,y1,y2;\n}rec[3001];\nbool mark[3005][3005];\nint rx[3005],ry[3005],l[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\nint ox=1,oy=1;\nlong long ans=2000000010LL*2000000010LL;\n   \nvoid dfs(int x,int y)\n{\n   mark[x][y]=1;\n   ans-=1LL*(rx[x+1]-rx[x])*(ry[y+1]-ry[y]);\n   for (int i=0;i<4;i++)\n   {\n      int xx=x+l[i][0],yy=y+l[i][1];\n      if (xx&&yy&&xx<ox&&yy<oy&&!mark[xx][yy])\n         dfs(xx,yy);\n   }\n}\n\nint main()\n{\n   int n,o=0,x=1000000005,y=1000000005;\n   cin>>n;\n   rx[++ox]=2000000010;\n   ry[++oy]=2000000010;\n   for (int i=1;i<=n;i++)\n   {\n      char c,t[5];\n      int l;\n      scanf(""%s%d"",t,&l);\n      c=t[0];\n      if (c==\'L\')\n      {\n         rec[++o]=(case1){0,y,x-l,x+1};\n         rx[++ox]=x-l;\n         rx[++ox]=x+1;\n         ry[++oy]=y;\n         ry[++oy]=y+1;\n         x-=l;\n      }\n      else if (c==\'R\')\n      {\n         rec[++o]=(case1){0,y,x,x+l+1};\n         rx[++ox]=x+l+1;\n         rx[++ox]=x;\n         ry[++oy]=y;\n         ry[++oy]=y+1;\n         x+=l;\n      }\n      else if (c==\'D\')\n      {\n         rec[++o]=(case1){1,x,y-l,y+1};\n         rx[++ox]=x;\n         rx[++ox]=x+1;\n         ry[++oy]=y-l;\n         ry[++oy]=y+1;\n         y-=l;\n      }\n      else\n      {\n         rec[++o]=(case1){1,x,y,y+l+1};\n         rx[++ox]=x;\n         rx[++ox]=x+1;\n         ry[++oy]=y+l+1;\n         ry[++oy]=y;\n         y+=l;\n      }\n   }\n   sort(rx+1,rx+ox+1);\n   ox=unique(rx+1,rx+ox+1)-rx-1;\n   sort(ry+1,ry+oy+1);\n   oy=unique(ry+1,ry+oy+1)-ry-1;\n   for (int i=1;i<=o;i++)\n      if (rec[i].flag==0)\n      {\n         int y;\n         for (y=1;ry[y]<rec[i].x;y++);\n         for (int j=1;j<ox;j++)\n            if (rx[j]>=rec[i].y1&&rx[j+1]<=rec[i].y2)\n               mark[j][y]=1;\n      }\n      else\n      {\n         int x;\n         for (x=1;rx[x]<rec[i].x;x++);\n         for (int j=1;j<oy;j++)\n            if (ry[j]>=rec[i].y1&&ry[j+1]<=rec[i].y2)\n               mark[x][j]=1;\n      }\n   for (int i=1;i<ox;i++)\n   {\n      if (!mark[i][1])\n         dfs(i,1);\n      if (!mark[i][oy-1])\n         dfs(i,oy-1);\n   }\n   for (int i=1;i<oy;i++)\n   {\n      if (!mark[1][i])\n         dfs(1,i);\n      if (!mark[ox-1][i])\n         dfs(ox-1,i);\n   }\n   cout<<ans<<endl;\n   return 0;\n}\n']","['dfs and similar', 'implementation']",2200
https://codeforces.com//contest/1475/problem/B,B. New Year's Number,Polycarp remembered the 2020 th year and he is happy with the arrival of the new 2021 th year To remember such a wonderful moment Polycarp wants to represent the number n as the sum of a certain number of 2020 and a certain number of 2021 For example if n 4041 then the number n can be represented as the sum 2020 2021 n 4042 then the number n can be represented as the sum 2021 2021 n 8081 then the number n can be represented as the sum 2020 2020 2020 2021 n 8079 then the number n cannot be represented as the sum of the numbers 2020 and 2021 Help Polycarp to find out whether the number n can be represented as the sum of a certain number of numbers 2020 and a certain number of numbers 2021 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        bool ok = false;\n        for (int i = 0 ; i <= 1000; i++) {\n            int m = n - 2020 * i;\n            if (m >= 0 && m%2021 == 0) {\n                ok = true;\n                break;\n            }\n        }\n        ps(ok ? ""YES"" : ""NO"");\n    }\n    return 0;\n}']","['brute force', 'dp', 'math']",900
https://codeforces.com//contest/1627/problem/B,B. Not Sitting,Rahul and Tina are looking forward to starting their new year at college As they enter their new classroom they observe the seats of students are arranged in a n times m grid The seat in row r and column c is denoted by r c and the distance between two seats a b and c d is a c b d As the class president Tina has access to k buckets of pink paint The following process occurs First Tina chooses exactly k seats in the classroom to paint with pink paint One bucket of paint can paint exactly one seat After Tina has painted k seats in the previous step Rahul chooses where he sits He will not choose a seat that has been painted pink due to his hatred of the colour pink After Rahul has chosen his seat Tina chooses a seat for herself She can choose any of the seats painted or not other than the one chosen by Rahul Rahul wants to choose a seat such that he sits as close to Tina as possible However Tina wants to sit as far away from Rahul as possible due to some complicated relationship history that we couldn t fit into the statement Now Rahul wonders for k 0 1 dots n cdot m 1 if Tina has k buckets of paint how close can Rahul sit to Tina if both Rahul and Tina are aware of each other s intentions and they both act as strategically as possible Please help satisfy Rahul s curiosity ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nint T;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tint n,m;\n\t\tscanf(""%d%d"",&n,&m);\n\t\tvector<tuple<int,int,int> >v;\n\t\trep(i,0,n-1)rep(j,0,m-1){\n\t\t\tv.eb(max({i+j,n-1-i+m-1-j,n-1-i+j,i+m-1-j}),i,j);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\teach(x,v)printf(""%d "",get<0>(x));\n\t\tputs("""");\n\t}\n\treturn 0;\n}']","['games', 'greedy', 'sortings']",1300
https://codeforces.com//contest/63/problem/A,A. Sinking Ship,The ship crashed into a reef and is sinking Now the entire crew must be evacuated All crew members have already lined up in a row for convenience let s label them all from left to right with positive integers from 1 to and await further instructions However one should evacuate the crew properly in a strict order Specifically The first crew members to leave the ship are rats Then women and children both groups have the same priority leave the ship After that all men are evacuated from the ship The captain leaves the sinking ship last If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph then the one who stands to the left in the line leaves the ship first or in other words the one whose number in the line is less For each crew member we know his status as a crew member and also his name All crew members have different names Determine the order in which to evacuate the crew ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nmap <string, int> r;\n\nchar s[105], t[105];\n\nvector <pair <int, string> > v;\n\nint main (void)\n{\n  r[""rat""] = 1, r[""woman""] = 2, r[""child""] = 2, r[""man""]=3, r[""captain""]=4;\n\n  int n;\n  scanf(""%d"", &n);\n  for (int i=0; i<n; i++) {\n    scanf(""%s%s"", s, t);\n    v.push_back(make_pair(r[t] * 10000 + i, s));\n  }\n\n  sort(v.begin(), v.end());\n\n  for (int i=0; i<n; i++)\n    puts(v[i].second.c_str());\n\n  return 0;\n}']","['implementation', 'sortings', 'strings']",900
https://codeforces.com//contest/1742/problem/E,E. Scuza,Timur has a stairway with n steps The i th step is a i meters higher than its predecessor The first step is a 1 meters higher than the ground and the ground starts at 0 meters Timur has q questions each denoted by an integer k 1 dots k q For each question k i you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length k i Timur can only climb the j th step if his legs are of length at least a j In other words k i geq a j for each step j climbed Note that you should answer each question independently ,"['#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\n#define vi vector<int>\n\nvoid solve()\n{\n\tint n,q;\n\tcin>>n>>q;\n\n\tvi v(n);\n\tfor(int i=0;i<n;i++)\n\t\t cin>>v[i];\n\n\t\tvi dp(n);\n\t\tdp[0]=v[0];\n\n\t\tfor(int i=1;i<n;i++)\n\t\t\t dp[i]=max(v[i],dp[i-1]);\n\n\t\tvi pre(n,0);\n\t\tpre[0]=v[0];\n\n\t\tfor(int i=1;i<n;i++)\n\t\t\t pre[i]=pre[i-1]+v[i];\n\n\t\twhile(q--)\n\t\t{\n\t\t\t int a;\n\t\t\t cin>>a;\n\n\t\t\t int index=upper_bound(dp.begin(),dp.end(),a)-dp.begin();\n\n\t\t\t index--;\n\t\t\t if(index<0)\n\t\t\t \t cout<<""0""<<"" "";\n\t\t\t else\n\t\t\t \tcout<<pre[index]<<"" "";\n\t\t}\n\n\t\tcout<<endl;\n}\n\nint32_t main()\n{\n\t int t=1;\n\n\t cin>>t;\n\n\t while(t--)\n\t {\n\t \t solve();\n\t }\n\t return 0;\n}                                    ']","['binary search', 'greedy', 'math']",1200
https://codeforces.com//contest/1463/problem/C,C. Busy Robot,You have a robot that can move along a number line At time moment 0 it stands at point 0 You give n commands to the robot at time t i seconds you command the robot to go to point x i Whenever the robot receives a command it starts moving towards the point x i with the speed of 1 unit per second and he stops when he reaches that point However while the robot is moving it all the other commands that you give him For example suppose you give three commands to the robot at time 1 move to point 5 at time 3 move to point 0 and at time 6 move to point 4 Then the robot stands at 0 until time 1 then starts moving towards 5 ignores the second command reaches 5 at time 6 and immediately starts moving to 4 to execute the third command At time 7 it reaches 4 and stops there You call the command i successful if there is a time moment in the range t i t i 1 i e after you give this command and before you give another one both bounds inclusive we consider t n 1 infty when the robot is at point x i Count the number of successful commands Note that it is possible that an ignored command is successful ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tint cur = 0;\n\tvector<ll> t(n);\n\tvector<ll> x(n);\n\trep(i, n)cin >> t[i] >> x[i];\n\tint ans = 0;\n\trep(i, n) {\n\t\t//cur->x[i] at time t[i]\n\t\tll dif = abs(cur - x[i]);\n\t\tint nex = i + 1;\n\t\twhile (nex < n && t[nex] < t[i] + dif)nex++;\n\t\tll nexdif = INF;\n\t\tif (i + 1 < n)nexdif = t[i + 1] - t[i];\n\t\tif (dif <= nexdif)ans++;\n\t\tfor (int j = i + 1; j < nex; j++) {\n\t\t\tll tdif = t[j] - t[i];\n\t\t\tll tdif2 = INF;\n\t\t\tif (j + 1 < n)tdif2 = t[j + 1] - t[i];\n\t\t\tll le, ri;\n\t\t\tif (cur <= x[i]) {\n\t\t\t\tle = min(cur + tdif, x[i]);\n\t\t\t\tri = min(cur + tdif2, x[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tle = max(cur - tdif2, x[i]);\n\t\t\t\tri = max(cur - tdif, x[i]);\n\t\t\t}\n\t\t\tif (le <= x[j] && x[j] <= ri)ans++;\n\t\t}\n\t\tcur = x[i];\n\t\ti = nex - 1;\n\t}\n\t//cout << ""ans is "";\n\tcout << ans << ""\\n"";\n}\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']",['implementation'],1800
https://codeforces.com//contest/1185/problem/B,B. Email from Polycarp,Methodius received an email from his friend Polycarp However Polycarp s keyboard is broken so pressing a key on it once may cause the corresponding symbol to appear more than once if you press a key on a regular keyboard it prints exactly one symbol For example as a result of typing the word the following words be printed but the following be printed Note that when you press a key the corresponding symbol must appear possibly more than once The keyboard is broken in a random manner it means that pressing the same key you can get the different number of letters in the result For each word in the letter Methodius has guessed what word Polycarp actually wanted to write but he is not sure about it so he asks you to help him You are given a list of pairs of words For each pair determine if the second word could be printed by typing the first one on Polycarp s keyboard ,"['///Mn kotr el labawy mb2t4 nawy\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main(){\n  ios_base::sync_with_stdio(0);cin.tie(0);\n  int t;  cin >> t;\n\n  while(t--){\n\n      string s1, s2;  cin >> s1 >> s2;\n      vector<pair<char, int>> a1, a2;\n      for(auto c : s1){\n        if(a1.empty()||a1.back().first!=c)a1.push_back({c,0});\n        a1.back().second++;\n      }\n      for(auto c : s2){\n        if(a2.empty()||a2.back().first!=c)a2.push_back({c,0});\n        a2.back().second++;\n      }\n      if(a1.size()!=a2.size())cout << ""NO\\n"";\n      else {\n        bool ok = true;\n        for(int i = 0; i < a1.size(); i++){\n          ok &= (a1[i].first == a2[i].first);\n          ok &= (a1[i].second <= a2[i].second);\n        }\n        if(ok)cout<<""YES\\n"";\n        else cout << ""NO\\n"";\n      }\n  }\n  return 0;\n}\n']","['implementation', 'strings']",1200
https://codeforces.com//contest/1603/problem/A,A. Di-visible Confusion,YouKn0wWho has an integer sequence a 1 a 2 ldots a n He will perform the following operation until the sequence becomes empty select an index i such that 1 le i le a and a i is divisible by i 1 and erase this element from the sequence Here a is the length of sequence a at the moment of operation Note that the sequence a changes and the next operation is performed on this changed sequence For example if a 3 5 4 5 then he can select i 2 because a 2 5 is not divisible by i 1 3 After this operation the sequence is 3 4 5 Help YouKn0wWho determine if it is possible to erase the whole sequence using the aforementioned operation ,"['/**\n *    author:  tourist\n *    created: 30.10.2021 17:35:01       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    while (n > 0) {\n      int i = n - 1;\n      while (i >= 0 && a[i] % (i + 2) == 0) {\n        i -= 1;\n      }\n      if (i < 0) {\n        break;\n      }\n      a.erase(a.begin() + i);\n      n -= 1;\n    }\n    cout << (n == 0 ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","['constructive algorithms', 'math', 'number theory']",1300
https://codeforces.com//contest/1017/problem/A,A. The Rank,John Smith knows that his son Thomas Smith is among the best students in his class and even in his school After the students of the school took the exams in English German Math and History a table of results was formed There are n students each of them has a id from 1 to n Thomas s id is 1 Every student has four scores correspond to his or her English German Math and History scores The students are given in order of increasing of their ids In the table the students will be sorted by the sum of their scores So a student with the largest sum will get the first place If two or more students have the same sum these students will be sorted by their ids Please help John find out the rank of his son ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n; cin >> n;\n    int z;\n    vi v;\n    F0R(i,n) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        v.pb(a+b+c+d);\n        if (i == 0) z = a+b+c+d;\n    }\n    sort(v.rbegin(),v.rend());\n    F0R(i,sz(v)) if (v[i] == z) {\n        cout << i+1;\n        exit(0);\n    }\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']",['implementation'],800
https://codeforces.com//contest/959/problem/A,A. Mahmoud and Ehab and the even-odd game,Mahmoud and Ehab play a game called the even odd game Ehab chooses his favorite integer and then they take turns starting from Mahmoud In each player s turn he has to choose an integer and subtract it from such that If it s Mahmoud s turn has to be even but if it s Ehab s turn has to be odd If the current player can t choose any number satisfying the conditions he loses Can you determine the winner if they both play optimally ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; cin >> n;\n\tcout << (n&1?""Ehab"": ""Mahmoud"") << endl;\n\treturn 0;\n}\n']","['games', 'math']",800
https://codeforces.com//contest/1065/problem/A,A. Vasya and Chocolate,There is a special offer in Vasya s favourite supermarket if the customer buys a chocolate bars he or she may take b additional bars for free This special offer can be used any number of times Vasya currently has s roubles and he wants to get as many chocolate bars for free Each chocolate bar costs c roubles Help Vasya to calculate the maximum possible number of chocolate bars he can get ,"['/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << "" is "" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(""%d"", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return (\'a\' <= x && x <= \'z\'); }\ninline bool is_upper(char x) { return (\'A\' <= x && x <= \'Z\'); }\ninline bool is_digit(char x) { return (\'0\' <= x && x <= \'9\'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 1e4 + 239;\n\nvoid solve()\n{\n    ll s, a, b, c;\n    cin >> s >> a >> b >> c;\n    ll k = (s / c);\n    ll ans = k;\n    ans += (k / a) * b;\n    cout << ans << ""\\n"";\n}\n\nint main()\n{\n    #ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    int T;\n    cin >> T;\n    for (int i = 0; i < T; i++) solve();\n    return 0;\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/314/problem/C,C. Sereja and Subsequences,Sereja has a sequence that consists of positive integers First Sereja took a piece of squared paper and wrote all non empty non decreasing subsequences of sequence Then for each sequence written on the squared paper Sereja wrote on a piece of lines paper all sequences that it A sequence of positive integers doesn t exceed a sequence of positive integers if the following inequation holds Now Sereja wonders how many sequences are written on the lines piece of paper Help Sereja find the required quantity modulo ,"['#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MOD = 1000000007;\nconst int M = 1<<18;\nint T[2 * M];\n\nvoid add(int v, LL k) {\n    v += M;\n    while (v) {\n        T[v] = (T[v] + k) % MOD;\n        v /= 2;\n    }\n}\n\nLL get(int a, int b) {\n    LL result = 0;\n    a += M, b += M;\n    if (a == b) return T[a];\n    \n    result = T[a] + T[b];\n    while (a / 2 != b / 2) {\n        if (a%2 == 0) result += T[a+1];\n        if (b%2 == 1) result += T[b-1];\n        \n        a /= 2;\n        b /= 2;\n    }\n\n    return result % MOD;\n}\n\nPII A[200000];\nint prev[200000];\n\nint main() {\n    int N;\n    scanf(""%d"",&N);\n    REP(i,N) scanf(""%d"",&A[i].st);\n    REP(i,N) A[i].nd = i;\n    map<int,int> Ma;\n    REP(i,N) {\n        prev[i] = Ma[A[i].st] - 1;\n        Ma[A[i].st] = i + 1;\n    }\n    sort(A,A+N);\n    \n    LL result = 0;\n    REP(i,N) {\n        int a = A[i].st;\n        int p = prev[A[i].nd];\n        LL tmp = get(max(p,0), A[i].nd);\n        if (p == -1) tmp += 1;\n        \n        tmp *= a;        \n        tmp %= MOD;\n        add(A[i].nd,tmp);\n        result += tmp;        \n    }\n    \n    printf(""%d\\n"", (int)(result % MOD));\n}    ']","['data structures', 'dp']",2000
https://codeforces.com//contest/853/problem/E,E. Lada Malina,After long term research and lots of experiments leading Megapolian automobile manufacturer AutoVoz released a brand new car model named Lada Malina One of the most impressive features of Lada Malina is its highly efficient environment friendly engines Consider car as a point in plane Car is equipped with engines numbered from to Each engine is defined by its velocity vector whose coordinates are measured in distance units per day An engine may be turned on at any level that is a real number between and inclusive that result in a term of in the final car velocity Namely the final car velocity is equal to Formally if car moves with constant values of during the whole day then its coordinate will change by the first component of an expression above and its coordinate will change by the second component of an expression above For example if all are equal to zero the car won t move and if all are equal to zero except then car will move with the velocity of the first engine There are factories in Megapolia th of them is located in On the th factory there are cars Lada Malina that are ready for operation As an attempt to increase sales of a new car AutoVoz is going to hold an international exposition of cars There are options of exposition location and time in the th of them exposition will happen in a point with coordinates in days Of course at the AutoVoz is going to bring as much new cars from factories as possible to the place of exposition Cars are going to be moved by enabling their engines on some certain levels such that at the beginning of an exposition car gets exactly to the exposition location However for some of the options it may be impossible to bring cars from some of the factories to the exposition location by the moment of an exposition Your task is to determine for each of the options of exposition location and time how many cars will be able to get there by the beginning of an exposition ,"['#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<map>\n#define MN 200000\n#define N 262144\n#define INF 2000000000\n#define eps 1e-7\n#define pa pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\ndouble L[MN+5];map<pa,long long> num;\nint K,n,m,totx=0,toty=0,fx[MN+5],fy[MN+5],A[MN+5];\nlong long Ans[MN+5],T[N*2+5];\nstruct vec{int x,y;double slop;}s[25];\nbool cmps(const vec&a,const vec&b){return a.slop<b.slop;}\nstruct ques{int kind,x;double y;int id,ad,t;};\nvector<ques> v[11];\ninline double GetSlop(int y,int x){if(!x)return INF;else return (double)y/x;}\nbool cmp(const ques&a,const ques&b){return a.x==b.x?a.kind>b.kind:a.x<b.x;}\nvoid Renew(int x,int y){for(T[x+=N]+=y,x>>=1;x;x>>=1) T[x]=T[x<<1]+T[x<<1|1];}\nlong long Query(int l,int r)\n{\n\tlong long sum=0;\n\tfor(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1)\n\t{\n\t\tif(~l&1) sum+=T[l+1];\n\t\tif( r&1) sum+=T[r-1];\n\t}\n\treturn sum;\n}\n\nint Find(int r,double y)\n{\n\tint l=1,res=r+1,mid;\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;\t\n\t\tif(L[mid]>y) res=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn res-1;\n}\n\nvoid Solve(vector<ques> q,int ky,int kx)\n{\n//\tcout<<""Solve""<<k<<endl;\n\tint cnt=0;memset(T,0,sizeof(T));\n\tfor(int i=1;i<=n;++i) \n\t\tif(!kx) q.push_back((ques){1,fx[i],fy[i],A[i],0,0}),L[++cnt]=fy[i];\n\t\telse \n\t\t{\n\t\t\tdouble c=(double)fy[i]-(double)fx[i]*ky/kx;L[++cnt]=c;\n\t\t\tq.push_back((ques){1,fx[i],c,A[i],0,0});\n\t\t}\n\tsort(q.begin(),q.end(),cmp);\n//\tfor(int i=0;i<q.size();++i) printf(""%d %.8lf %.8lf %d %d\\n"",q[i].kind,q[i].x,q[i].y,q[i].id,q[i].ad);\n\tsort(L+1,L+cnt+1);\n\tfor(int i=0;i<q.size();++i)\n\t\tif(q[i].kind)\n\t\t{\n\t\t\tint p=lower_bound(L+1,L+cnt+1,q[i].y)-L;\n\t\t\tRenew(p,q[i].id);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tint p=upper_bound(L+1,L+cnt+1,q[i].y)-L-1;\n\t\t\twhile(p>0&&q[i].t&&q[i].y==L[p]) --p;\n\t\t\tif(p>0) Ans[q[i].id]+=q[i].ad*Query(1,p); \n\t\t}\n}\n\nint main()\n{\n\tK=read();n=read();m=read();\n\tfor(int i=1;i<=K;++i) \n\t{\n\t\ts[i].x=read(),s[i].y=read();\n\t\tif(s[i].x<0) s[i].x=-s[i].x,s[i].y=-s[i].y;\n\t\tif(s[i].x==0&&s[i].y<0) s[i].y=-s[i].y;\n\t\ttotx+=s[i].x,toty+=s[i].y,s[i].x<<=1,s[i].y<<=1;\n\t}\n\tfor(int i=1;i<=K;++i) s[i].slop=atan2(s[i].y,s[i].x);\n\tsort(s+1,s+K+1,cmps);\n\tfor(int i=1;i<=K;++i) s[i+K].x=-s[i].x,s[i+K].y=-s[i].y;K<<=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfx[i]=read(),fy[i]=read(),A[i]=read(),num[make_pair(fx[i],fy[i])]+=A[i];\n\tfor(int i=1;i<=m;++i) \n\t{\n\t\tint x=read(),y=read(),t=read(),id;\n\t\tx-=t*totx;y-=t*toty;Ans[i]+=num[make_pair(x,y)];\n\t\tfor(int j=1,id=1;j<=K;x+=s[j].x*t,y+=s[j].y*t,++j,id=(j-1)%(K>>1)+1) \n\t\tif(!s[j].x)\n\t\t{\n\t\t\tif(s[j].y<0)\n\t\t\t{\n\t\t\t\tv[id].push_back((ques){0,x,y,i,1,0});\n\t\t\t\tv[id].push_back((ques){0,x,y+s[j].y*t,i,-1,0});\n\t\t\t\tv[id].push_back((ques){0,x-1,y,i,-1,0});\n\t\t\t\tv[id].push_back((ques){0,x-1,y+s[j].y*t,i,1,0});\n\t\t\t}\n\t\t}\n\t\telse if(s[j].x<0)\n\t\t{\n\t\t\tdouble c=y-(double)x*s[j].y/s[j].x;\n\t\t\tv[id].push_back((ques){0,x,c,i,1,0});\n\t\t\tv[id].push_back((ques){0,x+s[j].x*t,c,i,-1,0});\n\t\t}\n\t\telse \n\t\t{\n\t\t\tdouble c=y-(double)x*s[j].y/s[j].x;\n\t\t\tv[id].push_back((ques){0,x+s[j].x*t,c,i,-1,1});\n\t\t\tv[id].push_back((ques){0,x,c,i,1,1});\n\t\t}\n\t}\n\tfor(int i=1;i<=K>>1;++i) Solve(v[i],s[i].y,s[i].x);\n\tfor(int i=1;i<=m;++i) printf(""%lld\\n"",Ans[i]); \n\treturn 0;\n}']","['data structures', 'geometry']",3400
https://codeforces.com//contest/1530/problem/C,C. Pursuit,You and your friend Ilya are participating in an individual programming contest consisting of multiple stages A contestant can get between 0 and 100 points inclusive for each stage independently of other contestants Points received by contestants in different stages are used for forming overall contest results Suppose that k stages of the contest are completed For each contestant k lfloor frac k 4 rfloor stages with the highest scores are selected and these scores are added up This sum is the overall result of the contestant Here lfloor t rfloor denotes rounding t down For example suppose 9 stages are completed and your scores are 50 30 50 50 100 10 30 100 50 First 7 stages with the highest scores are chosen for example all stages except for the 2 nd and the 6 th can be chosen Then your overall result is equal to 50 50 50 100 30 100 50 430 As of now n stages are completed and you know the points you and Ilya got for these stages However it is unknown how many more stages will be held You wonder what the smallest number of additional stages is after which your result might become greater than or equal to Ilya s result at least in theory Find this number ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        std::vector<int> a(n), b(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n        for (int i = 0; i < n; i++) {\n            std::cin >> b[i];\n        }\n        std::sort(a.begin(), a.end(), std::greater<>());\n        std::sort(b.begin(), b.end(), std::greater<>());\n        \n        std::vector<i64> sa(n + 1), sb(n + 1);\n        for (int i = 0; i < n; i++) {\n            sa[i + 1] = sa[i] + a[i];\n            sb[i + 1] = sb[i] + b[i];\n        }\n        \n        int lo = 0, hi = 1e7;\n        while (lo < hi) {\n            int k = (lo + hi) / 2;\n            \n            int m = (n + k) - (n + k) / 4;\n            int ca, cb;\n            if (m <= k) {\n                ca = 100 * m;\n            } else {\n                ca = 100 * k + sa[m - k];\n            }\n            cb = sb[std::min(n, m)];\n            \n            if (ca >= cb) {\n                hi = k;\n            } else {\n                lo = k + 1;\n            }\n        }\n        \n        std::cout << lo << ""\\n"";\n    }\n    \n    return 0;\n}']","['binary search', 'brute force', 'greedy', 'sortings']",1200
https://codeforces.com//contest/1887/problem/D,D. Split,Let s call an array b 1 b 2 ldots b m m ge 2 if it can be split into two parts such that all elements in the left part are strictly smaller than all elements in the right part In other words there must exist an index 1 le i m such that every element from b 1 ldots b i is strictly smaller than every element from b i 1 ldots b m Given an array a 1 a 2 ldots a n consisting of integers from 1 to n There are q queries Each query consists of two numbers l and r For each query determine whether the array a l a l 1 ldots a r is good ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate <typename T>\nstruct Fenwick {\n    int n;\n    std::vector<T> a;\n    \n    Fenwick(int n_ = 0) {\n        init(n_);\n    }\n    \n    void init(int n_) {\n        n = n_;\n        a.assign(n, T{});\n    }\n    \n    void add(int x, const T &v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] = a[i - 1] + v;\n        }\n    }\n    \n    T sum(int x) {\n        T ans{};\n        for (int i = x; i > 0; i -= i & -i) {\n            ans = ans + a[i - 1];\n        }\n        return ans;\n    }\n    \n    T rangeSum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n    \n    int select(const T &k) {\n        int x = 0;\n        T cur{};\n        for (int i = 1 << std::__lg(n); i; i /= 2) {\n            if (x + i <= n && cur + a[x + i - 1] <= k) {\n                x += i;\n                cur = cur + a[x - 1];\n            }\n        }\n        return x;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), inva(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        inva[a[i]] = i;\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    std::vector<int> ans(q);\n    std::vector<std::vector<std::pair<int, int>>> qry(n);\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        std::cin >> l >> r;\n        l--, r--;\n        qry[l].emplace_back(r, i);\n    }\n    \n    std::vector<int> L(n), R(n), RR(n);\n    std::set<int> s{-1, n};\n    for (int i = n - 1; i >= 0; i--) {\n        int x = inva[i];\n        int l = *std::prev(s.lower_bound(x));\n        int r = *s.lower_bound(x);\n        s.insert(x);\n        L[x] = l, R[x] = r;\n    }\n    s = {-1, n};\n    for (int i = 0; i < n; i++) {\n        int x = inva[i];\n        if (R[x] < n) {\n            RR[x] = *s.lower_bound(R[x]);\n        }\n        s.insert(x);\n    }\n    std::vector<std::vector<std::pair<int, int>>> add(n);\n    for (int i = 0; i < n; i++) {\n        if (R[i] < n) {\n            add[L[i] + 1].emplace_back(R[i], 1);\n            add[L[i] + 1].emplace_back(RR[i], -1);\n            add[i + 1].emplace_back(R[i], -1);\n            add[i + 1].emplace_back(RR[i], 1);\n        }\n    }\n    Fenwick<int> fen(n);\n    for (int i = 0; i < n; i++) {\n        for (auto [x, y] : add[i]) {\n            fen.add(x, y);\n        }\n        for (auto [r, j] : qry[i]) {\n            if (fen.sum(r + 1) > 0) {\n                ans[j] = 1;\n            }\n        }\n    }\n    \n    for (int i = 0; i < q; i++) {\n        std::cout << (ans[i] ? ""Yes"" : ""No"") << ""\\n"";\n    }\n    \n    return 0;\n}\n']","['binary search', 'data structures', 'divide and conquer', 'dsu', 'math', 'trees', 'two pointers']",2700
https://codeforces.com//contest/1557/problem/C,C. Moamen and XOR,Moamen and Ezzat are playing a game They create an array a of n non negative integers where every element is less than 2 k Moamen wins if a 1 a 2 a 3 ldots a n ge a 1 oplus a 2 oplus a 3 oplus ldots oplus a n Here denotes the bitwise AND operation and oplus denotes the bitwise XOR operation Please calculate the number of winning for Moamen arrays a As the result may be very large print the value modulo 1 000 000 007 10 9 7 ,"[""#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nint Power(int x,int y){\n\tint r=1;\n\twhile(y){\n\t\tif(y&1)r=1ll*r*x%mod;\n\t\tx=1ll*x*x%mod,y>>=1;\n\t}\n\treturn r;\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tint prod=1,ans=0;\n\t\tfor(int i=k-1;i>=0;i--){\n\t\t\tif(n%2==0)ans=(ans+1ll*prod*Power(Power(2,i),n))%mod;\n\t\t\tint u=0;\n\t\t\tu=Power(2,n-1);\n\t\t\tif(n%2==0)u=(u-1+mod)%mod;\n\t\t\tif(n&1)u=(u+1)%mod;\n\t\t\tprod=1ll*prod*u%mod;\n\t\t}\n\t\tans=(ans+prod)%mod;\n\t\tcout<<ans<<'\\n';\n\t}\n}""]","['bitmasks', 'combinatorics', 'dp', 'math', 'matrices']",1700
https://codeforces.com//contest/1579/problem/B,B. Shifting Sort,The new generation external memory contains an array of integers a 1 ldots n a 1 a 2 ldots a n This type of memory does not support changing the value of an arbitrary element Instead it allows you to cut out any segment of the given array rotate it by any offset and insert it back into the same place Technically each cyclic shift consists of two consecutive actions You may select arbitrary indices l and r 1 le l r le n as the boundaries of the segment Then you replace the segment a l ldots r with it s to the by an arbitrary offset d The concept of a can be also explained by following relations the sequence 1 4 1 3 is a cyclic shift of the sequence 3 1 4 1 to the left by the offset 1 and the sequence 4 1 3 1 is a cyclic shift of the sequence 3 1 4 1 to the left by the offset 2 For example if a 1 color blue 3 2 8 5 then choosing l 2 r 4 and d 2 yields a segment a 2 ldots 4 3 2 8 This segment is then shifted by the offset d 2 to the and you get a segment 8 3 2 which then takes the place of of the original elements of the segment In the end you get a 1 color blue 8 3 2 5 Sort the given array a using no more than n cyclic shifts of any of its segments Note that you don t need to minimize the number of cyclic shifts Any method that requires n or less cyclic shifts will be accepted ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"")\n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[55];\nint n;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) cin >> a[i];\n        vector <pi> ans;\n        for(int i = 1;i <= n;i++) {\n            int idx = i;\n            for(int j = i+1;j <= n;j++) {\n                if(a[j] < a[idx]) idx = j;\n            }\n            if(idx == i) continue;\n            ans.pb({i,idx});\n            for(int j = idx-1;j >= i;j--) a[j+1] = a[j];\n        }\n        cout << ans.size() << \'\\n\';\n        for(auto i : ans) {\n            cout << i.x << \' \' << i.y << \' \' << i.y-i.x << \'\\n\';\n        }\n    }\n}\n']","['implementation', 'sortings']",1100
https://codeforces.com//contest/165/problem/B,B. Burning Midnight Oil,One day a highly important task was commissioned to Vasya writing a program in a night The program consists of lines of code Vasya is already exhausted so he works like that first he writes lines of code drinks a cup of tea then he writes as much as lines drinks another cup of tea then he writes lines and so on The expression is regarded as the integral part from dividing number by number The moment the current value equals 0 Vasya immediately falls asleep and he wakes up only in the morning when the program should already be finished Vasya is wondering what minimum allowable value can take to let him write than lines of code before he falls asleep ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nint main(){\n\tint n, k;\n\twhile( cin>>n>>k ){\n\t\tint l=0, r=n;\n\t\twhile( l+1<r ){\n\t\t\tint mid=(l+r)/2;\n\t\t\tLL sum=0, M=1;\n\t\t\twhile( true ){\n\t\t\t\tsum+=mid/M;\n\t\t\t\tif( mid/M==0 ) break;\n\t\t\t\tM*=k;\n\t\t\t}\n\t\t\tif( sum>=n ) r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tcout<<r<<endl;\n\t}\n}\n\n\n\n\n']","['binary search', 'implementation']",1500
https://codeforces.com//contest/1343/problem/F,F. Restore the Permutation by Sorted Segments,We guessed a permutation p consisting of n integers The permutation of length n is the array of length n where each element from 1 to n appears exactly once This permutation is a secret for you For each position r from 2 to n we chose some other index l l r and gave you the segment p l p l 1 dots p r in order i e we rearranged the elements of this segment in a way that the elements of this segment are sorted Thus you are given exactly n 1 segments of the initial permutation but elements inside each segment are sorted The segments are given to you in random order For example if the secret permutation is p 3 1 4 6 2 5 then the possible given set of segments can be 2 5 6 4 6 1 3 4 1 3 1 2 4 6 Your task is to find suitable permutation i e any permutation corresponding to the given input data It is guaranteed that the input data corresponds to some permutation i e such permutation exists You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; //\ntypedef string str; //\n//\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; //\ntypedef pair<db,db> pd; //\n//\ntypedef vector<int> vi; \ntypedef vector<ll> vl; //\ntypedef vector<db> vd; //\ntypedef vector<str> vs; //\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; //\ntypedef vector<pd> vpd; //\n \ntypedef tree<pi, null_type, less<pi>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n \n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() //\n#define rsz resize\n#define ins insert //\n#define ft front() //\n#define bk back()\n#define pf push_front //\n#define pb push_back\n#define eb emplace_back //\n#define lb lower_bound //\n#define ub upper_bound //\n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; //\nconst ll INF = 1e18; //\nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; //\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); //\n//\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { //\n\treturn a < b ? a = b, 1 : 0; } //\nconstexpr int pct(int x) { return __builtin_popcount(x); } //\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) //\nconstexpr int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 //\n// IGNORE\nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n \n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n// IGNORE\n//\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint t;\n\tcin >> t;\n\tF0R(i, t){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> lists[n - 1];\n\t\tF0R(a, n - 1){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tF0R(b, k){\n\t\t\t\tint temp;\n\t\t\t\tcin >> temp;\n\t\t\t\ttemp--;\n\t\t\t\tlists[a].pb(temp);\n\t\t\t}\n\t\t}\n\t\tF0R(a, n){\n\t\t\tbool bad = false;\n\t\t\tvector<int> ans;\n\t\t\tset<int> l[n - 1];\n\t\t\tF0R(b, n - 1)\n\t\t\t\ttrav(c, lists[b])\n\t\t\t\t\tl[b].insert(c);\n\t\t\tans.pb(a);\n\t\t\tF0R(b, n - 1){\n\t\t\t\tint last = ans[sz(ans) - 1];\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tc.erase(last);\n\t\t\t\tint cnt = 0;\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tcnt += (c.size() == 1);\n\t\t\t\tif(cnt != 1){\n\t\t\t\t\tbad = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tif(c.size() == 1)\n\t\t\t\t\t\tans.pb(*c.begin());\n\t\t\t}\n\t\t\tif(!bad){\n\t\t\t\ttrav(b, lists){\n\t\t\t\t\tF0R(c, n){\n\t\t\t\t\t\tauto temp = lb(all(b), ans[c]);\n\t\t\t\t\t\tif(temp != b.end() && *temp == ans[c]){\n\t\t\t\t\t\t\tif(c + sz(b) > n){\n\t\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tset<int> test;\n\t\t\t\t\t\t\ttest.insert(ans[c]);\n\t\t\t\t\t\t\tFOR(d, c + 1, c + sz(b))\n\t\t\t\t\t\t\t\ttest.insert(ans[d]);\n\t\t\t\t\t\t\tF0R(d, sz(b))\n\t\t\t\t\t\t\t\ttest.erase(b[d]);\n\t\t\t\t\t\t\tif(sz(test) != 0){\n\t\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(bad)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(bad)\n\t\t\t\t\tcontinue;\n\t\t\t\ttrav(b, ans)\n\t\t\t\t\tcout << b + 1 << "" "";\n\t\t\t\tcout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n']","['brute force', 'constructive algorithms', 'data structures', 'greedy', 'implementation']",2400
https://codeforces.com//contest/416/problem/B,B. Art Union,A well known art union called Kalevich is Alive manufactures objects d art pictures The union consists of painters who decided to organize their work as follows Each painter uses only the color that was assigned to him The colors are distinct for all painters Let s assume that the first painter uses color 1 the second one uses color 2 and so on Each picture will contain all these colors Adding the th color to the th picture takes the th painter units of time Order is important everywhere so the painters work is ordered by the following rules Each picture is first painted by the first painter then by the second one and so on That is after the th painter finishes working on the picture it must go to the th painter if each painter works on the pictures in some order first he paints the first picture then he paints the second picture and so on each painter can simultaneously work on at most one picture However the painters don t need any time to have a rest as soon as the th painter finishes his part of working on the picture the picture immediately becomes available to the next painter Given that the painters start working at time 0 find for each picture the time when it is ready for sale ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 100000;\n\nint n, m;\nint f[N][10];\nint g[N][10];\n\nvoid solve()\n{\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; ++ i) {\n\t\tfor(int j = 0; j < n; ++ j) {\n\t\t\tscanf(""%d"", &f[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++ i) {\n\t\tg[i + 1][0] = g[i][0] + f[i][0];\n\n\t\tfor(int j = 1; j < n; ++ j) {\n\t\t\tg[i + 1][j] = max(g[i + 1][j - 1] + f[i][j], g[i][j] + f[i][j]);\n\t\t}\n\n\t\tprintf(""%d "", g[i + 1][n - 1]);\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n']","['brute force', 'dp', 'implementation']",1300
https://codeforces.com//contest/737/problem/E,E. Tanya is 5 ,Tanya is now five so all her friends gathered together to celebrate her birthday There are children on the celebration including Tanya The celebration is close to its end and the last planned attraction is gaming machines There are machines in the hall they are numbered through Each of the children has a list of machines he wants to play on Moreover for each of the machines he knows the exact time he wants to play on it For every machine no more than one child can play on this machine at the same time It is evening already so every adult wants to go home To speed up the process you can additionally rent second copies of each of the machines To rent the second copy of the th machine you have to pay burles After you rent a machine you can use it for as long as you want How long it will take to make every child play according to his plan if you have a budget of burles for renting additional machines There is only one copy of each machine so it s impossible to rent a third machine of the same type The children can interrupt the game in any moment and continue it later If the th child wants to play on the th machine it is allowed after you rent the copy of the th machine that this child would play some part of the time on the th machine and some part of the time on its copy each of these parts could be empty The interruptions and changes take no time and can be performed in any integer moment of time Of course a child can t play on more than one machine at the same time Remember that it is not needed to save money no one saves money at the expense of children happiness it is needed to minimize the latest moment of time some child ends his game ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 45;\nint n, m, b;\nint c[maxn];\nint w[maxn][maxn];\n\nint read() {\n  if (scanf(""%d%d%d"", &n, &m, &b) < 3) {\n    return false;\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(""%d"", &c[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2 * m; j++) {\n      w[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(""%d"", &k);\n    for (int j = 0; j < k; j++) {\n      int id, t;\n      scanf(""%d%d"", &id, &t);\n      id--;\n      w[i][2 * id] = t;\n    }\n  }\n  return true;\n}\n\nint maxdeg;\nint take[maxn];\nvector< pair<pair<int, int>, pair<int, int> > > ans;\nvector<int> g[2][maxn];\nint p[2][maxn];\nint deg[2][maxn];\nint used[maxn];\n\nbool dfs(int t, int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[t][v]); i++) {\n    int u = g[t][v][i];\n    if (p[!t][u] == -1 || deg[t][p[!t][u]] < maxdeg) {\n      if (p[!t][u] != -1) {\n        p[t][p[!t][u]] = -1;\n      }\n      p[!t][u] = v;\n      p[t][v] = u;\n      return true;\n    }\n  }\n  for (int i = 0; i < sz(g[t][v]); i++) {\n    int u = g[t][v][i];\n    if (!used[p[!t][u]] && dfs(t, p[!t][u])) {\n      p[!t][u] = v;\n      p[t][v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve() {\n  for (int i = 0; i < m; i++) {\n    take[i] = false;\n  }\n  while (true) {\n    bool change = false;\n    int t = 0;\n    for (int i = 0; i < n; i++) {\n      int cur = 0;\n      for (int j = 0; j < 2 * m; j++) {\n        cur += w[i][j];\n      }\n      t = max(t, cur);\n    }\n    for (int i = 0; i < 2 * m; i++) {\n      int cur = 0;\n      for (int j = 0; j < n; j++) {\n        cur += w[j][i];\n      }\n      t = max(t, cur);\n    }\n    for (int i = 0; i < m; i++) {\n      if (take[i] || c[i] > b) {\n        continue;\n      }\n      int cur = 0;\n      for (int j = 0; j < n; j++) {\n        cur += w[j][2 * i];\n      }\n      if (cur < t) {\n        continue;\n      }\n      int tomove = t / 2;\n      for (int j = 0; j < n; j++) {\n        int x = min(tomove, w[j][2 * i]);\n        w[j][2 * i] -= x;\n        w[j][2 * i + 1] += x;\n        tomove -= x;\n      }\n      take[i] = true;\n      b -= c[i];\n      change = true;\n    }\n    if (!change) {\n      break;\n    }\n  }\n  ans.clear();\n  int t = 0;\n  while (true) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < max(n, 2 * m); j++) {\n        g[i][j].clear();\n        p[i][j] = -1;\n        deg[i][j] = 0;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 2 * m; j++) {\n        deg[0][i] += w[i][j];\n        deg[1][j] += w[i][j];\n        if (w[i][j]) {\n          g[0][i].push_back(j);\n          g[1][j].push_back(i);\n        }\n      }\n    }\n    maxdeg = 0;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < max(n, 2 * m); j++) {\n        maxdeg = max(maxdeg, deg[i][j]);\n      }\n    }\n    if (!maxdeg) {\n      break;\n    }\n    for (int i = 0; i < 2; i++) {\n      int vs = (i ? 2 * m : n);\n      for (int j = 0; j < vs; j++) {\n        if (deg[i][j] == maxdeg && p[i][j] == -1) {\n          for (int k = 0; k < vs; k++) {\n            used[k] = false;\n          }\n          dfs(i, j);\n        }\n      }\n    }\n    int ndeg = 0;\n    for (int i = 0; i < 2; i++) {\n      int vs = (i ? 2 * m : n);\n      for (int j = 0; j < vs; j++) {\n        if (p[i][j] == -1) {\n          ndeg = max(ndeg, deg[i][j]);\n        }\n      }\n    }\n    int minw = inf;\n    for (int i = 0; i < n; i++) {\n      if (p[0][i] != -1) {\n        minw = min(minw, w[i][p[0][i]]);\n      }\n    }\n    int curt = min(minw, maxdeg - ndeg);\n    for (int i = 0; i < n; i++) {\n      if (p[0][i] != -1) {\n        ans.push_back(make_pair(make_pair(i + 1, p[0][i] / 2 + 1), make_pair(t, curt)));\n        w[i][p[0][i]] -= curt;\n      }\n    }\n    t += curt;\n  }\n  printf(""%d\\n"", t);\n  for (int i = 0; i < m; i++) {\n    printf(""%d"", take[i]);\n  }\n  printf(""\\n%d\\n"", sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(""%d %d %d %d\\n"", ans[i].first.first, ans[i].first.second, ans[i].second.first, ans[i].second.second);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK "".in"", ""r"", stdin));\n  assert(freopen(TASK "".out"", ""w"", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""Time %.2f\\n"", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n\n']","['graph matchings', 'graphs', 'greedy', 'schedules']",3300
https://codeforces.com//contest/776/problem/A,A. A Serial Killer,Our beloved detective Sherlock is currently trying to catch a serial killer who kills a person each day Using his powers of deduction he came to know that the killer has a strategy for selecting his next victim The killer starts with two potential victims on his first day selects one of these two kills selected victim and replaces him with a new person He repeats this procedure each day This way each day he has two potential victims to choose from Sherlock knows the initial two potential victims Also he knows the murder that happened on a particular day and the new person who replaced this victim You need to help him get all the pairs of potential victims at each day so that Sherlock can observe some pattern ,"['#include<cstdio>\n#include<algorithm>\n#include<string>\nusing namespace std;\nchar p[101000], q[101000];\nint n;\nstring AA, BB, CC, DD;\nint main(){\n    int i;\n    scanf(""%s%s"",p,q);\n    AA = p, BB = q;\n    scanf(""%d"",&n);\n    printf(""%s %s\\n"",p,q);\n    for(i=0;i<n;i++){\n        scanf(""%s%s"",p,q);\n        CC = p, DD = q;\n        if(AA == CC) AA = DD;\n        else BB = DD;\n        printf(""%s %s\\n"",AA.c_str(), BB.c_str());\n    }\n}']","['brute force', 'implementation', 'strings']",900
https://codeforces.com//contest/732/problem/B,B. Cormen — The Best Friend Of a Man,Recently a dog was bought for Polycarp The dog s name is Cormen Now Polycarp has a lot of troubles For example Cormen likes going for a walk Empirically Polycarp learned that the dog needs at least walks for any two consecutive days in order to feel good For example if and yesterday Polycarp went for a walk with Cormen times today he has to go for a walk at least times Polycarp analysed all his affairs over the next days and made a sequence of integers where is the number of times Polycarp will walk with the dog on the th day while doing all his affairs for example he has to go to a shop throw out the trash etc Help Polycarp determine the minimum number of walks he needs to do additionaly in the next days so that Cormen will feel good during all the days You can assume that on the day before the first day and on the day after the th day Polycarp will go for a walk with Cormen exactly times Write a program that will find the minumum number of additional walks and the appropriate schedule the sequence of integers where means the total number of walks with the dog on the th day ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nint n , K , a[505] , b[505];\n\nint main(){\n    cin >> n >> K;\n    rep(i,0,n) cin >> a[i];\n    int add = 0;\n    rep(i,1,n){\n        int sum = a[i-1] + a[i];\n        if(sum < K) a[i] += K - sum , add += K - sum;\n    }\n    cout << add << endl;\n    rep(i,0,n) cout << a[i] << "" \\n""[i+1==n];\n    return 0;\n}\n']","['dp', 'greedy']",1000
https://codeforces.com//contest/809/problem/C,C. Find a car,After a wonderful evening in the restaurant the time to go home came Leha as a true gentlemen suggested Noora to give her a lift Certainly the girl agreed with pleasure Suddenly one problem appeared Leha cannot find his car on a huge parking near the restaurant So he decided to turn to the watchman for help Formally the parking can be represented as a matrix There is exactly one car in every cell of the matrix All cars have their own machine numbers represented as a positive integer Let s index the columns of the matrix by integers from to from left to right and the rows by integers from to from top to bottom By coincidence it turned out that for every cell the number of the car which stands in this cell is equal to the minimum positive integer which can t be found in the cells and Leha wants to ask the watchman requests which can help him to find his car Every request is represented as five integers The watchman have to consider all cells of the matrix such that and and if the number of the car in cell does not exceed increase the answer to the request by the number of the car in cell For each request Leha asks the watchman to tell him the resulting sum Due to the fact that the sum can turn out to be quite large hacker asks to calculate it modulo However the requests seem to be impracticable for the watchman Help the watchman to answer all Leha s requests ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst long long mod=1000*1000*1000+7;\n\nmap < pair < pair <int,int> , int> , pair <long long, long long> > mapa;\n\ninline void dziel(long long &v)\n{\n\tif(v&1)\n\t\tv+=mod;\n\tv/=2;\n}\n\ninline int naj(int v)\n{\n\tint r=1;\n\twhile(r*2<v)\n\t\tr*=2;\n\treturn r;\n}\n\ninline pair <long long,long long> dod(pair <long long,long long> a, pair <long long,long long> b)\n{\n\ta.first+=b.first;\n\ta.second+=b.second;\n\treturn a;\n}\n\npair <long long,long long> licz(int a, int b, int k)\n{\n\tif (a>b)\n\t\tswap(a, b);\n\tint r=naj(b);\n\tk=min(k, 2*r);\n\tif (a<=0 || b<=0 || k<=0)\n\t\treturn {0, 0};\n\tpair <long long,long long> ret={0, 0};\n\tif (a==b && __builtin_popcount(a)==1)//kwadrat\n\t{\n\t\tk=min(k, a);\n\t\tret.first=a;\n\t\tret.first*=k;\n\t\tret.first%=mod;\n\t\tret.first*=(k+1);\n\t\tret.first%=mod;\n\t\tdziel(ret.first);\n\t\t\n\t\tret.second=a;\n\t\tret.second*=k;\n\t\tret.second%=mod;\n\t\treturn ret;\n\t}\n\tif (mapa.count({{a, b}, k}))\n\t\treturn mapa[{{a, b}, k}];\n\t\n\t\n\tret=dod(licz(min(a, r), min(b, r), k), licz(a-r, b-r, k));\n\t\n\tauto ret2=dod(licz(min(a, r), b-r, k-r), licz(a-r, min(b, r), k-r));\n\t\n\tret2.first+=ret2.second*r;\n\tret2.first%=mod;\n\t\n\tret=dod(ret, ret2);\n\t\n\tret.first%=mod;\n\tret.second%=mod;\n\t\n\tmapa[{{a, b}, k}]=ret;\n\treturn ret;\n}\n\nint main()\n{\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--)\n\t{\n\t\tmapa.clear();\n\t\tint a, b, x, y, k;\n\t\tscanf(""%d%d%d%d%d"", &a, &b, &x, &y, &k);\n\t\tlong long wyn=licz(x, y, k).first-licz(x, b-1, k).first-licz(a-1, y, k).first+licz(a-1, b-1, k).first;\n\t\twyn%=mod;\n\t\twyn+=mod;\n\t\twyn%=mod;\n\t\tprintf(""%lld\\n"", wyn);\n\t}\n\treturn 0;\n}\n']","['combinatorics', 'divide and conquer', 'dp']",2600
https://codeforces.com//contest/1215/problem/A,A. Yellow Cards,The final match of the Berland Football Cup has been held recently The referee has shown n yellow cards throughout the match At the beginning of the match there were a 1 players in the first team and a 2 players in the second team The rules of sending players off the game are a bit different in Berland football If a player from the first team receives k 1 yellow cards throughout the match he can no longer participate in the match he s sent off And if a player from the second team receives k 2 yellow cards he s sent off After a player leaves the match he can no longer receive any yellow cards Each of n yellow cards was shown to exactly one player Even if all players from one team or even from both teams leave the match the game still continues The referee has lost his records on who has received each yellow card Help him to determine the minimum and the maximum number of players that could have been thrown out of the game ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint a1,a2,k1,k2,n;\nint main(){\n\tscanf(""%d%d%d%d%d"",&a1,&a2,&k1,&k2,&n);\n\tint low=a1*(k1-1)+a2*(k2-1);\n\tprintf(""%d "",max(n-low,0));\n\tif (k1>k2) swap(k1,k2),swap(a1,a2);\n\tint T1=min(n/k1,a1); a1-=k1; n-=T1*k1;\n\tprintf(""%d"",T1+n/k2);\n}']","['greedy', 'implementation', 'math']",1000
https://codeforces.com//contest/217/problem/D,D. Bitonix  Patrol,Byteland is trying to send a space mission onto the Bit X planet Their task is complicated by the fact that the orbit of the planet is regularly patrolled by Captain Bitonix the leader of the space forces of Bit X There are stations around Bit X numbered clockwise from 1 to The stations are evenly placed on a circular orbit so the stations number and and the stations number 1 and are neighboring The distance between every pair of adjacent stations is equal to space miles To go on a patrol Captain Bitonix jumps in his rocket at one of the stations and flies in a circle covering a distance of at least one space mile before finishing in some perhaps the starting station Bitonix rocket moves by burning fuel tanks After Bitonix attaches an liter fuel tank and chooses the direction clockwise or counter clockwise the rocket flies exactly space miles along a circular orbit in the chosen direction Note that the rocket has no brakes it is not possible for the rocket to stop before depleting a fuel tank For example assume that and and Bitonix has fuel tanks with volumes of 10 60 90 and 100 liters If Bitonix starts from station 1 uses the 100 liter fuel tank to go clockwise then uses the 90 liter fuel tank to go clockwise and then uses the 10 liter fuel tank to go counterclockwise he will finish back at station 1 This constitutes a valid patrol Note that Bitonix does not have to use all available fuel tanks Another valid option for Bitonix in this example would be to simply use the 60 liter fuel tank to fly to either station 2 or 3 However if was equal to 3 was equal to 60 and the only fuel tanks available to Bitonix were one 10 liter tank and one 100 liter tank he would have no way of completing a valid patrol he wouldn t be able to finish any patrol exactly at the station The Byteland space agency wants to destroy some of Captain Bitonix fuel tanks so that he cannot to complete any valid patrol Find how many different subsets of the tanks the agency can destroy to prevent Captain Bitonix from completing a patrol and output the answer modulo ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007\n\nint M;\nint cnt[130];\n// int CNT;\n\nint x[10];\nbool can[10][130];\nint mod[10000];\n\nint prod(int pos){ // cout << pos << endl;\n    ll ans = 1;\n    int i;\n    REP(i,pos) ans = ans * cnt[x[i]] % MOD;\n    return (int)ans;\n}\n\nint dfs(int pos, int last){ // cout << pos << endl;\n    int i,j;\n    \n//  CNT++;\n//  REP(i,pos) cout << x[i] << \' \';\n//  cout << endl;\n\n    int ans = prod(pos);\n    \n    if(pos < 6) for(i=last+1;i<=M/2;i++) if(!can[pos][i]){\n        x[pos] = i;\n        if(pos < 5){\n            REP(j,M) can[pos+1][j] = false;\n            REP(j,M) if(can[pos][j]) can[pos+1][j] = can[pos+1][mod[j+i]] = can[pos+1][mod[j-i+M]] = true;\n        }\n        int tmp = dfs(pos+1, i);\n        ans += tmp;\n        if(ans >= MOD) ans -= MOD;\n    }\n    \n    return ans;\n}\n\nint main(void){\n    int N,T,x,i;\n    \n    scanf(""%d%d%d"",&N,&M,&T);\n    REP(i,T){\n        scanf(""%d"",&x);\n        x %= M;\n        if(x != 0) cnt[min(x,M-x)]++;\n    }\n    \n    REP(i,10000) mod[i] = i % M;\n    can[0][0] = true;\n    int ans = dfs(0, 0);\n    printf(""%d\\n"", ans);\n//  cout << CNT << endl;\n    \n    return 0;\n}\n']","['bitmasks', 'brute force', 'combinatorics', 'dfs and similar', 'math']",2900
https://codeforces.com//contest/1681/problem/E,E. Labyrinth Adventures,You found a map of a weirdly shaped labyrinth The map is a grid consisting of n rows and n columns The rows of the grid are numbered from 1 to n from bottom to top The columns of the grid are numbered from 1 to n from left to right The labyrinth has n layers The first layer is the bottom left corner cell 1 1 The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner And so on The labyrinth with 5 layers for example is shaped as follows The layers are separated from one another with walls However there are doors in these walls Each layer except for layer n has exactly two doors to the next layer One door is placed on the top wall of the layer and another door is placed on the right wall of the layer For each layer from 1 to n 1 you are given positions of these two doors The doors can be passed in both directions either from layer i to layer i 1 or from layer i 1 to layer i If you are standing in some cell you can move to an adjacent by a side cell if a wall doesn t block your move e g you can t move to a cell in another layer if there is no door between the cells Now you have m queries of sort what s the minimum number of moves one has to make to go from cell x 1 y 1 to cell x 2 y 2 ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:54:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nvector<array<array<int, 2>, 2>> dist;\n\nclass segtree {\n public:\n  struct node {\n    array<long long, 4> a;\n    int L;\n    int R;\n\n    void apply(int l, int r, array<long long, 4> v) {\n      a = v;\n      L = l;\n      R = r;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.L = a.L;\n    res.R = b.R;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        long long best = (long long) 1e18;\n        for (int k = 0; k < 2; k++) {\n          for (int t = 0; t < 2; t++) {\n            long long cur = a.a[i * 2 + k] + b.a[t * 2 + j];\n            cur += dist[b.L][k][t];\n            best = min(best, cur);\n          }\n        }\n        res.a[i * 2 + j] = best;\n      }\n    }\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<pair<int, int>> bot(n - 1);\n  vector<pair<int, int>> lft(n - 1);\n  vector<pair<int, int>> top(n - 1);\n  vector<pair<int, int>> rgt(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> bot[i].first >> bot[i].second >> lft[i].first >> lft[i].second;\n    top[i] = bot[i];\n    top[i].first += 1;\n    rgt[i] = lft[i];\n    rgt[i].second += 1;\n  }\n  vector<array<long long, 4>> p(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    int d = abs(bot[i].first - lft[i].first) + abs(bot[i].second - lft[i].second);\n    p[i] = {1, d + 1, d + 1, 1};\n  }\n  dist.resize(n - 1);\n  for (int q = 1; q < n - 1; q++) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        auto ga = (i == 0 ? top[q - 1] : rgt[q - 1]);\n        auto gb = (j == 0 ? bot[q] : lft[q]);\n        dist[q][i][j] = abs(ga.first - gb.first) + abs(ga.second - gb.second);\n      }\n    }\n  }\n  segtree st(p);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int ia = max(xa, ya) - 1;\n    int ib = max(xb, yb) - 1;\n    if (ia > ib) {\n      swap(xa, xb);\n      swap(ya, yb);\n      swap(ia, ib);\n    }\n    if (ia == ib) {\n      cout << abs(xa - xb) + abs(ya - yb) << \'\\n\';\n      continue;\n    }\n    auto nd = st.get(ia, ib - 1);\n    long long ans = (long long) 1e18;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        auto ga = (i == 0 ? bot[ia] : lft[ia]);\n        int da = abs(ga.first - xa) + abs(ga.second - ya);\n        auto gb = (j == 0 ? top[ib - 1] : rgt[ib - 1]);\n        int db = abs(gb.first - xb) + abs(gb.second - yb);\n        ans = min(ans, da + db + nd.a[i * 2 + j]);\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","['data structures', 'dp', 'matrices', 'shortest paths']",2600
https://codeforces.com//contest/1182/problem/E,E. Product Oriented Recurrence,Let f x c 2x 6 cdot f x 1 cdot f x 2 cdot f x 3 for x ge 4 You have given integers n f 1 f 2 f 3 and c Find f n bmod 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nconst int Ha=1000000007;\nconst int phi=1000000006;\nstruct matrix\n{\n\tint a[5][5];\n\tmatrix(){memset(a,0,sizeof(a));}\n}t;\ninline matrix operator*(const matrix&a,const matrix&b)\n{\n\tmatrix c;\n\tfor(int i=0;i<5;++i)\n\t\tfor(int j=0;j<5;++j)\n\t\t\tfor(int k=0;k<5;++k)\n\t\t\t\tc.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j])%phi;\n\treturn c;\n}\ninline matrix fp(matrix b,long long e)\n{\n\tmatrix r;\n\tfor(int i=0;i<5;++i)r.a[i][i]=1;\n\tfor(;e;e>>=1,b=b*b)if(e&1)r=r*b;\n\treturn r;\n}\nmap<int,int>mp;\nint B=1;\nint fp(int b,int e)\n{\n\tint r=1;\n\tfor(;e;e>>=1,b=1ll*b*b%Ha)if(e&1)r=1ll*r*b%Ha;\n\treturn r;\n}\nint dlog(int x)\n{\n\tint now=1;\n\tint res;\n\tfor(int i=0;;++i)\n\t{\n\t\tint y=1ll*x*now%Ha;\n\t\tif(mp.count(y))\n\t\t{\n\t\t\tres=mp[y]-i*33333;\n\t\t\tbreak;\n\t\t}\n\t\tnow=1ll*now*B%Ha;\n\t}\n\tres=(res+phi)%phi;\n\tres=(res+phi)%phi;\n\tres=(res+phi)%phi;\n\tassert(fp(5,res)==x);\n\treturn res;\n}\nint z[5];\nint main()\n{\n\tfor(int i=0;i<33333;++i)\n\t{\n\t\tmp[B]=i;\n\t\tB=5ll*B%Ha;\n\t}\n\tlong long n;\n\tint f1,f2,f3,c;\n\tscanf(""%lld%d%d%d%d"",&n,&f1,&f2,&f3,&c);\n\tc=dlog(c);\n\tf1=dlog(f1);\n\tf2=dlog(f2);\n\tf3=dlog(f3);\n\tt.a[0][1]=1;\n\tt.a[1][2]=1;\n\tt.a[1][0]=1;\n\tt.a[0][0]=1;\n\tt.a[1][0]=1;\n\tt.a[2][0]=1;\n\tt.a[3][3]=1;\n\tt.a[3][0]=(phi-6ll*c%phi)%phi;\n\tt.a[4][0]=2ll*c%phi;\n\tt.a[3][4]=1;\n\tt.a[4][4]=1;\n\tz[0]=f3;\n\tz[1]=f2;\n\tz[2]=f1;\n\tz[3]=1;\n\tz[4]=4;\n\tt=fp(t,n-3);\n\tint res=0;\n\tfor(int i=0;i<5;++i)res=(res+1ll*z[i]*t.a[i][0])%phi;\n\tprintf(""%d\\n"",fp(5,res));\n\treturn 0;\n}']","['dp', 'math', 'matrices', 'number theory']",2300
https://codeforces.com//contest/1149/problem/C,C. Tree Generator™,Owl Pacino has always been into trees unweighted rooted trees in particular He loves determining the of every tree he sees that is the maximum length of any simple path in the tree Owl Pacino s owl friends decided to present him the Tree Generator a powerful machine creating rooted trees from their An n vertex rooted tree can be by a bracket sequence of length 2 n 1 in the following way find any walk starting and finishing in the root that traverses each edge exactly twice once down the tree and later up the tree Then follow the path and write down an opening parenthesis if an edge is followed down the tree and a closing parenthesis otherwise The following figure shows sample rooted trees and their descriptions Owl wrote down the description of an n vertex rooted tree Then he rewrote the description q times However each time he wrote a new description he picked two different characters in the description he wrote the last time swapped them and wrote down the resulting string He always made sure that each written string was the description of a rooted tree Pacino then used Tree Generator for each description he wrote down What is the diameter of each constructed tree ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1 << 18;\nstruct Node {\n\tint l, r;\n\tint toAdd;\n\tint minAll, maxAll;\n\tint toLeft, toRight;\n\tint ans;\n\n\tNode() : l(-1), r(-1), toAdd(0), minAll(N), maxAll(0), toLeft(-N), toRight(-N), ans(0) {}\n\tNode(int _l, int _r) : l(_l), r(_r), toAdd(0), minAll(0), maxAll(0), toLeft(0), toRight(0), ans(0) {}\n\n\tvoid add(int x) {\n\t\ttoAdd += x;\n\t\tminAll += x;\n\t\tmaxAll += x;\n\t\ttoLeft -= x;\n\t\ttoRight -= x;\n\t}\n};\nNode tree[2 * N + 5];\n\nvoid build() {\n\tfor (int i = 0; i < N; i++)\n\t\ttree[N + i] = Node(i, i + 1);\n\tfor (int i = N - 1; i > 0; i--)\n\t\ttree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n}\nNode merge(Node L, Node R) {\n\tif (L.l == -1) return R;\n\tif (R.l == -1) return L;\n\tNode A = Node(L.l, R.r);\n\tA.minAll = min(L.minAll, R.minAll);\n\tA.maxAll = max(L.maxAll, R.maxAll);\n\tA.toLeft = max(max(L.toLeft, R.toLeft), R.maxAll - 2 * L.minAll);\n\tA.toRight = max(max(L.toRight, R.toRight), L.maxAll - 2 * R.minAll);\n\tA.ans = max(max(L.ans, R.ans), max(L.toRight + R.maxAll, L.maxAll + R.toLeft));\n\treturn A;\n}\nvoid push(int v) {\n\tif (v >= N) throw;\n\tif (tree[v].toAdd == 0) return;\n\tfor (int u = 2 * v; u < 2 * v + 2; u++) {\n\t\ttree[u].add(tree[v].toAdd);\n\t}\n\ttree[v].toAdd = 0;\n}\n\nvoid addOnSegm(int v, int l, int r, int x) {\n\tif (l <= tree[v].l && tree[v].r <= r) {\n\t\ttree[v].add(x);\n\t\treturn;\n\t}\n\tif (l >= tree[v].r || tree[v].l >= r) return;\n\tpush(v);\n\tfor (int u = 2 * v; u < 2 * v + 2; u++)\n\t\taddOnSegm(u, l, r, x);\n\ttree[v] = merge(tree[2 * v], tree[2 * v + 1]);\n}\nNode get(int v, int l, int r) {\n\tif (l <= tree[v].l && tree[v].r <= r) return tree[v];\n\tif (l >= tree[v].r || tree[v].l >= r) return Node();\n\tpush(v);\n\treturn merge(get(2 * v, l, r), get(2 * v + 1, l, r));\n}\n\nchar s[N + 5];\nint n, q;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tbuild();\n\tscanf(""%d%d"", &n, &q);\n\tn = 2 * (n - 1) + 1;\n\tscanf(""%s"", s);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\taddOnSegm(1, i + 1, n, (s[i] == \'(\' ? 1 : -1));\n\t}\n\tprintf(""%d\\n"", get(1, 0, n).ans);\n\twhile(q--) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;y--;\n\t\tif (s[x] == \')\') swap(x, y);\n\t\tif (s[x] != s[y]) {\n\t\t\taddOnSegm(1, x + 1, n, -2);\n\t\t\taddOnSegm(1, y + 1, n, 2);\n\t\t}\n\t\tswap(s[x], s[y]);\n\t\tprintf(""%d\\n"", get(1, 0, n).ans);\n\t}\n\n\treturn 0;\n}\n']","['data structures', 'implementation', 'trees']",2700
https://codeforces.com//contest/1157/problem/B,B. Long Number,You are given a long decimal number a consisting of n digits from 1 to 9 You also have a function f that maps every digit from 1 to 9 to some possibly the same digit from 1 to 9 You can perform the following operation choose a non empty of digits in a and replace each digit x from this segment with f x For example if a 1337 f 1 1 f 3 5 f 7 3 and you choose the segment consisting of three rightmost digits you get 1553 as the result What is the maximum possible number you can obtain applying this operation no more than once ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <numeric>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+"".in"").c_str());\n\t\tFout((pname+"".out"").c_str());\n\t#else\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 200010\n\nint n;\nint a[MAXN];\nint to[MAXN];\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) a[i] = In.Readnum()-\'0\';\n\tFor(i,9) Read(to[i]);\n\n\tint flag = 0;\n\tFor(i,n){\n\t\tif( flag == 1 ){\n\t\t\tif( to[a[i]] >= a[i] ) a[i] = to[a[i]];\n\t\t\telse flag = 2;\n\t\t}\n\t\tif( flag == 0 ){\n\t\t\tif( to[a[i]] > a[i] ){\n\t\t\t\ta[i] = to[a[i]];\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\t;\n\t}else{\n\t\t/*\n\t\tbool eq = 0;\n\t\tFor(i,n){\n\t\t\tif( a[i] == to[a[i]] ) eq = 1;\n\t\t}\n\t\tif(!eq) a[n] = to[a[n]];\n\t\t*/\n\t}\n\tFor(i,n)\n\t\tputchar(a[i]+\'0\');\n\tputchar(10);\n\n\tEND();\n}\n']",['greedy'],1300
https://codeforces.com//contest/182/problem/A,A. Battlefield,Vasya lagged behind at the University and got to the battlefield Just joking He s simply playing some computer game The field is a flat platform with trenches dug on it The trenches are segments on a plane parallel to the coordinate axes No two trenches intersect There is a huge enemy laser far away from Vasya The laser charges for seconds and then shoots continuously for seconds Then it charges for seconds again Then it shoots continuously for seconds again and so on Vasya knows numbers and He also knows that while the laser is shooting Vasya must be in the trench but while the laser is charging Vasya can safely move around the field The main thing is to have time to hide in the trench before the shot If Vasya reaches the trench exactly at the moment when the laser starts shooting we believe that Vasya managed to hide Coincidentally of any trench in meters numerically Initially Vasya is at point He needs to get to point Vasya moves at speed 1 meter per second in either direction You can get in or out of the trench at any its point Getting in or out of the trench takes no time It is also possible to move in the trench without leaving it What is the minimum time Vasya needs to get from point to point if at the initial time the laser has just started charging If Vasya cannot get from point to point print 1 If Vasya reaches point at the moment when the laser begins to shoot it is believed that Vasya managed to reach point ,"['#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\ndouble a[1024][4];\nint aa, bb;\n\ndouble getTime(int i1, int i2)\n{\n    double ret = 1000000000;\n\n    double x11, y11, x12, y12, x21, y21, x22, y22;\n    x11 = a[i1][0]; y11 = a[i1][1]; x12 = a[i1][2]; y12 = a[i1][3];\n    x21 = a[i2][0]; y21 = a[i2][1]; x22 = a[i2][2]; y22 = a[i2][3];\n\n    if (x11 != x12)\n        {\n            swap(x11, y11);\n            swap(x12, y12);\n            swap(x21, y21);\n            swap(x22, y22);\n        }\n\n    ret = min(ret, hypot(x11 - x21, y11 - y21) );\n    ret = min(ret, hypot(x11 - x22, y11 - y22) );\n    ret = min(ret, hypot(x12 - x21, y12 - y21) );\n    ret = min(ret, hypot(x12 - x22, y12 - y22) );\n\n    //cout << x11 << "" "" << y11 << "" "" << x12 << "" "" << y12 << endl;    \n    //cout << x21 << "" "" << y21 << "" "" << x22 << "" "" << y22 << endl;\n    \n    if (x21 != x22)\n        {\n            if (y21 >= min(y11, y12) && y21 <= max(y11, y12))\n                {\n                    ret = min(ret, abs(x11 - x21) );\n                    ret = min(ret, abs(x11 - x22) );\n                }\n            if (x11 >= min(x21, x22) && x11 <= max(x21, x22))\n                {\n                    ret = min(ret, abs(y11 - y21) );\n                    ret = min(ret, abs(y12 - y21) );\n                }\n           }\n    if (x21 == x22 && max(y11, y12) >= min(y21, y22) && max(y21, y22) >= min(y11, y12))\n        {\n            ret = min(ret, abs(x11 - x21));\n        }\n    if (ret <= aa)\n        return ret;\n    return -1;\n}\n\nint main(void)\n{\n    int n, i;\n    double x1, y1, x2, y2;\n    \n    cin >> aa >> bb;\n    cin >> x1 >> y1 >> x2 >> y2;\n    cin >> n;\n    fo(i,n)\n        {\n            cin >> a[i+1][0] >> a[i+1][1] >> a[i+1][2] >> a[i+1][3];\n        }\n    a[0][0] = a[0][2] = x1;\n    a[0][1] = a[0][3] = y1;\n    a[n+1][0] = a[n+1][2] = x2;\n    a[n+1][1] = a[n+1][3] = y2;\n    n += 2;\n\n    //cout << getTime(3,4) << endl;\n    //return 0;\n    \n    double mnTime[1024];\n    double goOut[1024];\n    fo(i,n) mnTime[i] = 1000000000;\n    mnTime[0] = goOut[0] = 0;\n    bool vis[1024];\n    memset(vis, 0, sizeof(vis));\n    priority_queue < pair < double, int > > q;\n    q.push( mp(0, 0) );\n    while(!q.empty())\n        {\n            int ind = q.top().second;\n            q.pop();\n            if (vis[ind]) continue;\n            vis[ind] = true;\n\n            fo(i,n) if (!vis[i])\n                {\n                    double gtm = getTime(ind, i);\n                    //cout << ind << "" "" << i << "" "" << gtm << endl;\n                    if (gtm == -1) continue;                     \n                    if (goOut[ind] + gtm < mnTime[i])\n                        {\n                            mnTime[i] = goOut[ind] + gtm;\n                            goOut[i] = goOut[ind] + (aa + bb);                            \n                            //cout << ind << "" "" << i << "" "" << mnTime[i] << "" "" << goOut[i] <<  endl;\n                            q.push( mp(-mnTime[i], i) );\n                        }\n                }\n        }\n\n    if (mnTime[n-1] == 1000000000)\n        cout << -1 << endl;\n    else\n        printf(""%.10lf\\n"", mnTime[n-1]);\n}\n']","['geometry', 'graphs', 'implementation', 'shortest paths']",2200
https://codeforces.com//contest/918/problem/B,B. Radio Station,As the guys fried the radio station facilities the school principal gave them tasks as a punishment Dustin s task was to add comments to nginx configuration for school s website The school has servers Each server has a name and an ip names aren t necessarily unique but ips are Dustin knows the ip and name of each server For simplicity we ll assume that an nginx command is of form where is a string consisting of English lowercase letter only and is the ip of one of school servers Each ip is of form where and are non negative integers less than or equal to with no leading zeros The nginx configuration file Dustin has to add comments to has commands Nobody ever memorizes the ips of servers so to understand the configuration better Dustin has to comment the name of server that the ip belongs to at the end of each line after each command More formally if a line is Dustin has to replace it with where is the name of the server with ip equal to Dustin doesn t know anything about nginx so he panicked again and his friends asked you to do his task for him ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nmap<string, string> mp;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\twhile (n--) {\n\t\tstring a, b;\n\t\tcin >> a >> b;\n\t\tmp[b] = a;\n\t}\n\twhile (m--){\n\t\tstring a, b; cin >> a >> b;\n\t\tstring c = b;\n\t\tc.pop_back();\n\t\tcout << a << "" "" << b << "" #"" << mp[c] << ""\\n"";\n\t}\n\treturn 0;\n}\n']","['implementation', 'strings']",900
https://codeforces.com//contest/1280/problem/B,B. Beingawesomeism,You are an all powerful being and you have created a rectangular world In fact your world is so bland that it could be represented by a r times c grid Each cell on the grid represents a country Each country has a dominant religion There are only two religions in your world One of the religions is called Beingawesomeism who do good for the sake of being good The other religion is called Pushingittoofarism who do murders for the sake of being bad Oh and you are actually not really all powerful You just have one power which you can use infinitely many times Your power involves When a missionary group of a certain country say a passes by another country b they change the dominant religion of country b to the dominant religion of country a In particular a single use of your power is this You choose a horizontal 1 times x subgrid or a vertical x times 1 subgrid That value of x is up to you You choose a direction d If you chose a horizontal subgrid your choices will either be NORTH or SOUTH If you choose a vertical subgrid your choices will either be EAST or WEST You choose the number s of steps You command each country in the subgrid to send a missionary group that will travel s steps towards direction d In each step they will visit and in effect convert the dominant religion of all s countries they pass through as detailed above The parameters x d s must be chosen in such a way that any of the missionary groups won t leave the grid The following image illustrates one possible single usage of your power Here represents a country with dominant religion Beingawesomeism and represents a country with dominant religion Pushingittoofarism Here we ve chosen a 1 times 4 subgrid the direction NORTH and s 2 steps You are a being which believes in free will for the most part However you just really want to stop receiving murders that are attributed to your name Hence you decide to use your powers and try to make Beingawesomeism the dominant religion in every country What is the minimum number of usages of your power needed to convert everyone to Beingawesomeism With god nothing is impossible But maybe you re not god If it is impossible to make Beingawesomeism the dominant religion in all countries you must also admit your mortality and say so ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tbool is0 = false;\n\tbool is1 = false;\n\tbool is2 = false;\n\tbool is3 = false;\n\tbool is4 = false;\n\tis0 = true;\n\n\tbool f1 = true, f2 = true, f3 = true, f4 = true;\n\tfor(int i = 0; i < n; i++){\n\t\tbool row_works = true;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'P\') row_works = false;\n\t\t}\n\t\tif(row_works) is2 = true;\n\t}\n\tfor(int j = 0; j < m; j++){\n\t\tbool col_works = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s[i][j] == \'P\') col_works = false;\n\t\t}\n\t\tif(col_works) is2 = true;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'P\'){\n\t\t\t\tis0 = false;\n\t\t\t\tif(i == 0) f1 = false;\n\t\t\t\tif(i == n-1) f2 = false;\n\t\t\t\tif(j == 0) f3 = false;\n\t\t\t\tif(j == m-1) f4 = false;\n\t\t\t} else {\n\t\t\t\tif((i == 0 || i == n-1) && (j == 0 || j == m-1)){\n\t\t\t\t\tis2 = true;\n\t\t\t\t}\n\t\t\t\tif((i == 0 || i == n-1) || (j == 0 || j == m-1)){\n\t\t\t\t\tis3 = true;\n\t\t\t\t}\n\t\t\t\tis4 = true;\n\t\t\t}\n\t\t}\n\t}\n\tis1 = f1 | f2 | f3 | f4;\n\tif(is0){\n\t\tcout << 0 << \'\\n\';\n\t} else if(is1){\n\t\tcout << 1 << \'\\n\';\n\t} else if(is2){\n\t\tcout << 2 << \'\\n\';\n\t} else if(is3){\n\t\tcout << 3 << \'\\n\';\n\t} else if(is4){\n\t\tcout << 4 << \'\\n\';\n\t} else {\n\t\tcout << ""MORTAL"" << \'\\n\';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","['implementation', 'math']",1800
https://codeforces.com//contest/609/problem/D,D. Gadgets for dollars and pounds,Nura wants to buy gadgets She has only burles for that She can buy each gadget for dollars or for pounds So each gadget is selling only for some type of currency The type of currency and the cost in that currency are not changing Nura can buy gadgets for days For each day you know the exchange rates of dollar and pound so you know the cost of conversion burles to dollars or to pounds Each day from to Nura can buy some gadgets by current exchange rate Each day she can buy any gadgets she wants but each gadget can be bought no more than once during days Help Nura to find the minimum day index when she will have gadgets Nura always pays with burles which are converted according to the exchange rate of the purchase day Nura can t buy dollars or pounds she always stores only burles Gadgets are numbered with integers from to in order of their appearing in input ,"['/*\nThe basement incinerator\nIs where they\'ll put the head\nHose the floor and clean the room\nAnywhere they bled\n\nInto boxes go the bags\nFill the space with rocks\nIn the dark of night\nHe throws them off the docks\n\nRotting in the river\nNever to be found\nUnder tons of concrete\nDeep beneath the ground\n\nFrom behind, he grabs his mouth\nThe blade goes to his neck\nBulging veins pumping blood\nHe struggles to protect\n\nIf you don\'t cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nGrab the neck, slit the throat, take the life\nHang the corpse, prepare to drain the blood\nBone saw, meat cleaver, filleting knife\nCarve the corpse, dissect him in the tub\n\nSmash the teeth, slice off scars, crush the bones\nWith a crowbar scrape off all tattoos\n\nIf you don\'t cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nChunks of a skull\nSawn in half bones\nBody is found\nKiller unknown\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nvector < pair<long long, pair<int, int> > >v;\nint l, r;\nint cheap1, cheap2;\nint a[N], b[N];\nint tp[N];\nint c[N];\nint n, m, k, s;\n\nbool good(int l)\n{\n\tv.clear();\n\n\tcheap1 = 1;\n\tcheap2 = 1;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tif (a[i] < a[cheap1])\n\t\t\tcheap1 = i;\n\t\tif (b[i] < b[cheap2])\n\t\t\tcheap2 = i;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (tp[i] == 1)\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * a[cheap1] * c[i], make_pair(i, cheap1)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * b[cheap2] * c[i], make_pair(i, cheap2)));\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tlong long need = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tneed += v[i].first;\n\treturn (need <= s);\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m >> k >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> b[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> tp[i] >> c[i];\n\t}\n\n\tl = 1;\n\tr = n + 1;\n\twhile (l < r)\n\t{\n\t\tint mid = l + r;\n\t\tmid /= 2;\n\t\tif (good(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid+1;\n\t}\n\n\tif (l == n + 1)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tcout << l << endl;\n\n\tgood(l);\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tcout << v[i].second.first << "" "" << v[i].second.second << ""\\n"";\n\t}\n\n\tcin.get();\n\treturn 0;\n}']","['binary search', 'greedy', 'two pointers']",2000
https://codeforces.com//contest/1114/problem/A,A. Got Any Grapes ,The Duck songFor simplicity we ll assume that there are only three types of grapes green grapes purple grapes and black grapes Andrew Dmitry and Michal are all grapes lovers however their preferences of grapes are different To make all of them happy the following should happen Andrew Dmitry and Michal should eat at least x y and z grapes respectively Andrew has an extreme affinity for green grapes thus he will eat green grapes and green grapes only On the other hand Dmitry is not a fan of black grapes any types of grapes except black would do for him In other words Dmitry can eat green and purple grapes Michal has a common taste he enjoys grapes in general and will be pleased with any types of grapes as long as the quantity is sufficient Knowing that his friends are so fond of grapes Aki decided to host a grape party with them He has prepared a box with a green grapes b purple grapes and c black grapes However Aki isn t sure if the box he prepared contains enough grapes to make everyone happy Can you please find out whether it s possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes It is not required to distribute all the grapes so it s possible that some of them will remain unused ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 1000500;\nconst int MOD = 1000000007;\n\nvoid bad() {\n  cout << ""No"" << endl;\n  exit(0);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int x, y, z;\n  cin >> x >> y >> z;\n  int a, b, c;\n  cin >> a >> b >> c;\n  if (a < x) bad();\n  a -= x;\n  if (a + b < y) bad();\n  int tot = a + b + c - y;\n  if (tot < z) bad();\n  cout << ""Yes"" << endl;\n  return 0;\n}']","['brute force', 'greedy', 'implementation']",800
https://codeforces.com//contest/1455/problem/F,F. String and Operations,You are given a string s consisting of n characters These characters are among the first k lowercase letters of the Latin alphabet You have to perform n operations with the string During the i th operation you take the character that the i th position and perform of the following actions with it swap it with the previous character in the string if it exists This operation is represented as swap it with the next character in the string if it exists This operation is represented as cyclically change it to the previous character in the alphabet becomes becomes and so on becomes the k th letter of the Latin alphabet This operation is represented as cyclically change it to the next character in the alphabet becomes becomes and so on the k th letter of the Latin alphabet becomes This operation is represented as do nothing This operation is represented as For example suppose the initial string is k 20 and the sequence of operations is Then the string is transformed as follows the first operation is so we change the underlined letter in to the next one in the first 20 Latin letters which is The string is now the second operation is so we swap the underlined letter with the next one in the string The string is now the third operation is so we swap the underlined letter with the previous one in the string note that this is now the 2 nd character of the string but it was initially the 3 rd one so the 3 rd operation is performed to it The resulting string is the fourth operation is so we change the underlined letter in to the previous one in the first 20 Latin letters which is The string is now The result of performing the sequence of operations is Given the string s and the value of k find the lexicographically smallest string that can be obtained after applying a sequence of operations to s ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N, K;\n    string S;\n    cin >> N >> K >> S;\n\n    auto down = [&](char ch) -> char {\n        return ch == \'a\' ? char(\'a\' + K - 1) : char(ch - 1);\n    };\n\n    auto up = [&](char ch) -> char {\n        return ch == char(\'a\' + K - 1) ? \'a\' : char(ch + 1);\n    };\n\n    string dp, dp_gap;\n\n    for (int i = 0; i < N; i++) {\n        // Transitions from dp[i]\n        string next_dp = dp + min({S[i], down(S[i]), up(S[i])});\n        string next_dp_gap = dp + S[i];\n\n        if (i >= 1)\n            next_dp = min(next_dp, dp.substr(0, i - 1) + S[i] + dp.back());\n\n        // Transitions from dp_gap[i]\n        if (i >= 1)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 1) + min({S[i], down(S[i]), up(S[i])}) + dp_gap.back());\n\n        if (i >= 2)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 2) + S[i] + dp_gap.substr(i - 2));\n\n        next_dp = min(next_dp, dp_gap + S[i]);\n        swap(dp, next_dp);\n        swap(dp_gap, next_dp_gap);\n    }\n\n    cout << dp << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","['dp', 'greedy']",2800
https://codeforces.com//contest/1104/problem/B,B. Game with string,Two people are playing a game with a string s consisting of lowercase latin letters On a player s turn he should choose two consecutive equal letters in the string and delete them For example if the string is equal to than there is only one possible turn delete so the string will become A player not able to make a turn loses Your task is to determine which player will win if both play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef __LOCAL_DEBUG__\n# define _debug(fmt, ...) fprintf(stderr, ""\\033[94m%s: "" fmt ""\\n\\033[0m"", \\\n    __func__, ##__VA_ARGS__)\n#else \n# define _debug(...) ((void) 0)\n#endif\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define Rep(i, n) for (int i=1; i<=(n); i++)\n#define range(x) begin(x), end(x)\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nint main() {\n    int cnt = 0;\n    stack<char> stk;\n    string str; cin >> str;\n    for (char ch : str) {\n        if (stk.size() and stk.top() == ch) {\n            stk.pop();\n            cnt++;\n        } else {\n            stk.push(ch);\n        }\n    }\n    if (cnt & 1) puts(""YES""); else puts(""NO"");\n    return 0;\n}\n']","['data structures', 'implementation', 'math']",1200
https://codeforces.com//contest/1620/problem/G,G. Subsequences Galore,For a sequence of strings t 1 t 2 dots t m let s define the function f t 1 t 2 dots t m as the number of different strings that are subsequences of string t i f 0 i e the number of such strings for an empty sequence is 0 You are given a sequence of strings s 1 s 2 dots s n Every string in this sequence consists of lowercase Latin letters and is i e each string begins with several maybe zero characters then several maybe zero characters ends with several maybe zero characters For each of 2 n subsequences of s 1 s 2 dots s n calculate the value of the function f modulo 998244353 ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    static const int SAVE_INV = int(1e6) + 5;\n    static _m_int save_inv[SAVE_INV];\n\n    static void prepare_inv() {\n        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.\n        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)\n            assert(MOD % p != 0);\n\n        save_inv[0] = 0;\n        save_inv[1] = 1;\n\n        for (int i = 2; i < SAVE_INV; i++)\n            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);\n    }\n\n    _m_int inv() const {\n        if (save_inv[1] == 0)\n            prepare_inv();\n\n        if (val < SAVE_INV)\n            return save_inv[val];\n\n        _m_int product = 1;\n        int v = val;\n\n        do {\n            product *= MOD - MOD / v;\n            v = MOD % v;\n        } while (v >= SAVE_INV);\n\n        return product * save_inv[v];\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\ntemplate<const int &MOD> _m_int<MOD> _m_int<MOD>::save_inv[_m_int<MOD>::SAVE_INV];\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n// Does the inverse of `submask_sums`; returns the input that produces the given output.\ntemplate<typename T_out, typename T_in>\nvoid mobius_transform(int n, vector<T_in> &values) {\n    assert(int(values.size()) == 1 << n);\n\n    for (int i = 0; i < n; i++)\n        for (int base = 0; base < 1 << n; base += 1 << (i + 1))\n            for (int mask = base; mask < base + (1 << i); mask++)\n                values[mask + (1 << i)] -= values[mask];\n}\n\n\nconst int ALPHABET = 26;\nconst char MIN_CHAR = \'a\';\nconst int S_MAX = 20005;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N;\n    cin >> N;\n    vector<vector<uint16_t>> S(ALPHABET, vector<uint16_t>(N, 0));\n\n    for (int i = 0; i < N; i++) {\n        string str;\n        cin >> str;\n\n        for (auto &ch : str)\n            S[ch - MIN_CHAR][i]++;\n    }\n\n    vector<mod_int> dp(1 << N, 1);\n    dp[0] = 0;\n\n    for (int c = 0; c < ALPHABET; c++) {\n        vector<uint16_t> mins(1 << N, S_MAX);\n\n        for (int mask = 1; mask < 1 << N; mask++) {\n            int low = __builtin_ctz(mask);\n            mins[mask] = min(mins[mask ^ 1 << low], S[c][low]);\n            dp[mask] *= mins[mask] + 1;\n        }\n    }\n\n    mobius_transform<mod_int>(N, dp);\n\n    for (int mask = 1; mask < 1 << N; mask++)\n        if (__builtin_popcount(mask) % 2 == 0)\n            dp[mask] = -dp[mask];\n\n    vector<uint8_t> sums(1 << N, 0);\n    int64_t ans = 0;\n\n    for (int mask = 1; mask < 1 << N; mask++) {\n        int low = __builtin_ctz(mask);\n        sums[mask] = uint8_t(sums[mask ^ 1 << low] + low);\n        int k = __builtin_popcount(mask);\n        ans ^= int64_t(dp[mask]) * k * (k + sums[mask]);\n    }\n\n    cout << ans << \'\\n\';\n}\n']","['bitmasks', 'combinatorics', 'dp']",2400
https://codeforces.com//contest/1009/problem/D,D. Relatively Prime Graph,Let s call an undirected graph G V E if and only if for each edge v u in E GCD v u 1 the greatest common divisor of v and u is 1 If there is no edge between some pair of vertices v and u then the value of GCD v u doesn t matter The vertices are numbered from 1 to V Construct a graph with n vertices and m edges such that it is connected and it contains neither self loops nor multiple edges If there exists no valid graph with the given number of vertices and edges then output If there are multiple answers then print any of them ,"['//nie, 3 cze 2018, 13:38:19 CEST\n//Konrad Paluszek, University of Warsaw (former XIV LO Staszic)\n# include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst bool local = \n#ifdef LOCAL\ntrue;\n#else\nfalse;\n#endif\n#define f first\n#define s second\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define bvt(s, f) int s(int x){return f(x);}int s(UI x){return f(x);}int s(LL x){return f##ll(x);}int s(ULL x){return f##ll(x);}\n#define FORBITS(i,m)  for(decltype(m)lP6N4Slr=(m),i=lP6N4Slr?ctz(lP6N4Slr):0;lP6N4Slr;lP6N4Slr^=((decltype(m))1<<i),i=ctz(lP6N4Slr))\n#define FORDBITS(i,m) for(decltype(m)_6Im=(m),i=_6Im?8*sizeof(m)-clz(_6Im)-1:0;_6Im;_6Im^=((decltype(m))1<<i),i=8*sizeof(m)-clz(_6Im)-1)\n#define SUBS(i, mask) for(decltype(mask)i = (mask),NFR9xNQCJZTrYQ=1;NFR9xNQCJZTrYQ;NFR9xNQCJZTrYQ=i,i=(i-1)&(mask))\n#define PB push_back\n#define MP make_pair\n#define MT(a, b, c) MP(MP(a, b), c)\n#define MQ(a, b, c, d) MP(MP(a, b), MP(c, d))\n#define tri(a, b, c) pair <pair <a, b>, c>\n#define quadr(a, b, c, d) pair <pair <a, b>, pair <c, d> >\n#define EB emplace_back\n# define jvx(...)\n# define fkz(...) __VA_ARGS__ jvx()\n# define cxo(...) __VA_ARGS__\n#define uuu_id() uuu\nusing LL=long long;using PII=pair<int,int>;using VI=vector<int>;using SI=set<int>;\nusing MII=map<int,int>;using UMII=unordered_map<int, int>;using LD=long double;using TII=\npair<PII,int>;using QII=pair<PII,PII>;using UI=unsigned int;using ULL=unsigned long long;\n#define uuu(prev, t) using S##t=set<t>; using V##t=vector<t>; using M##t=map<t,t>;\\\n\tusing MI##t=map<int,t>;using US##t=unordered_set<t>; prev(S##t) prev(V##t)\n#define uuu_() uuu\n#define ymd(t) \n#define ymd2(t) fkz(uuu_)()(ymd, t)\n#define ymd3(t) cxo(cxo(cxo(fkz(uuu_)()(ymd2, t))))\n#define ymd4(t) using P##t = pair<t,t>; using T##t=tri(t,t,t); using Q##t=quadr(t,t,t,t); \\\n\tymd3(P##t) ymd3(T##t) ymd3(Q##t) ymd3(t)\nymd4(LL) ymd4(LD) ymd3(PII) ymd3(TII) ymd3(QII) ymd4(VI) ymd4(SI) ymd4(UI) ymd4(ULL)\nbvt(popc,__builtin_popcount)bvt(ctz,__builtin_ctz)bvt(clz,__builtin_clz)bvt(bit_parity,__builtin_parity)\n#define siz(r) ((int)r.size())\n#define ALL(r) r.begin(), r.end()\n#define sim template <class T\n#define ros return o\nsim,class N>bool mini(T&o,N h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(T&o,N h){if(o<h)ros=h,1;return 0;}\n#define oor >ostream &operator<<(ostream &o,\n#define urs(r) typename pta<typename remove_reference<decltype(r)>::type>::t\n#define bnt ;}sim> struct\nsim,class N oor pair<T,N>u){ros<<""<""<<u.f<<"", ""<<u.s<<"">"" bnt pta{using t=T;};sim,int N>struct pta<T[N]>{using t=T*;};\nsim,typename=typename enable_if<!is_same<T,string>::value,urs(T().end())>::type oor\nT u){int c=0;o<<""{"";for(auto e:u)o<<"", ""+2*!c++<<e;ros<<""}"";}\nint mpow(int b, int e) {int o = 1; while (e) {if (e & 1)o = o * 1ll * b % MOD;b = b * 1ll * b % MOD;e /= 2;}ros;}\nvoid dor(){cerr<<dec<<""\\033[0m""<<endl;}sim,class...N>void dor(T x,N...y){cerr<<boolalpha<<x<<""; "";dor(y...);} const bool deb =\n#define acv(N,O) sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(N o, T x) {ros O N(x);} \\\n  sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(T o, N x) {return N(o) O x;} \\\n  sim> typename enable_if<is_arithmetic<T>::value || is_same<T,N>::value, N&>::type operator O##=(N &o, T x) {ros = o O N(x);}\n#ifdef DEB\ntrue;\n#define debug(c...)cerr<<""\\033[1;""<<30+__LINE__%8<<""m[""<<__FUNCTION__<<""#""<<__LINE__<<""] \\033[""<<30+(__LINE__/8+__LINE__*3)%8<<""m"",::dor(c)\n#define rcu m);}g(+) g(-) g(*) g(/) g(%) g(<<) g(>>) g(^) g(|) g(&) g(>=) g(<=) g(>) g(<) g(!=) g(==)\n#define zub(h,t,n...) class N> auto operator h(n u)->nep<urs(t)> {return ngy(t,\nsim>string bte(T u){stringstream o;o<<u;ros.str()bnt nep;sim>T yyo(nep<T>);sim>nep<T>ngy(T v,string c,int m=0);sim>T yyo(T o){ros bnt\nnep{T v;string c;int m; nep<T>mask(){return ngy(v,c,1);}\n#define g(o) template<zub(o, v o u, N) ""("" + bte(*this) + "") "" #o "" ("" + bte(u) + "")"", m);}\ntemplate<zub([],v[yyo(u)],N)c+""[""+bte(u)+""]"",rcu};sim>nep<T>ngy(T v,string c,int m){return nep<T>{v,c,m};}\nsim>T yyo(nep<T> o){ros.v;}sim>int uhn(T){return 0;}sim>int uhn(nep<T>o){ros.m;}\n#define ccy(c, y) sim> class enable_if<c is_arithmetic<T>::value,string>::type ema(T u){return bte(y);}\nccy(,bitset<8*sizeof(T)>(u))ccy(!,u)sim,class N> string ema(pair<T,N> o) {return ""<"" + ema(o.f) + "", "" + ema(o.s) + "">"";}\n#define g(o) sim, zub(o, yyo(p) o u.v, T p, nep<N>) ""("" + bte(p) + "") "" #o "" ("" + bte(u) + "")"", uhn(p) + u.m);}\nsim>string bte(nep<T>o){ros.c+"" = ""+(o.m?ema(o.v):bte(o.v));}sim oor nep<T>m){ros<<bte(rcu sim>nep<T>ngy(nep<T>o,string c="""",int m=0){ros;}\n#undef g\n#define imie(a...) ngy(a, #a)\n#define imask(a...) ngy(a, #a, 1)\n#define range(u, g, c) ngy(list<urs(u[0])>(&u[yyo(g)], &u[yyo(c)] + 1), #u ""["" + bte(g) + ""..."" + bte(c) + ""]"")\n#define arr(a, i) imie(a)[imie(i)]\n#define arr2(a, i, j) imie(a)[imie(i)][imie(j)]\n#define arr3(a, i, j, k) imie(a)[imie(i)][imie(j)][imie(k)]\n#define arr4(a, i, j, k, q) imie(a)[imie(i)][imie(j)][imie(k)][imie(q)]\nvector <stringstream> lif;struct prux {prux() {lif.EB();}~prux() {lif.pop_back();}};\n#define mark_stack(c...) udz(__LINE__,c)\n#define udz(a,b...) erf(a, b)\n#define erf(l,c...) prux _4IJ1MYUxZy2p_Q##l;lif.back()<<""\\033[1;""<<30+l%8<<""m[""<<__FUNCTION__<<\\\n  ""#""<<l<<""] \\033[""<<30+(l/8+l*3)%8<<""m"";siw(c)\nvoid siw(){};sim, class...N> void siw(T x, N...y) {lif.back() << x << ""; "";siw(y...);}\n#define print_stack() cerr << ""STACK_TRACE_FROM:"" << __FUNCTION__ << ""#"" << __LINE__<<endl,nfl()\n#define ckx(o) template<zub(o, o yyo(u), nep<N>) #o ""("" + bte(u) + "")"", u.m);}\nsim> struct tqaz{T a;int u,d,l,r;};sim> tqaz<T> zaqt(T a,int u,int d,int l,int r){return tqaz<T>{a,u,d,l,r};}\n#define matr(a,u,d,l,r) ngy(zaqt(a,yyo(u),yyo(d),yyo(l),yyo(r)), #a""[""+bte(u)+""...""+bte(d)+""][""+bte(l)+""...""+bte(r)+""]"")\n#define avc(f) sim>string f(tqaz<T> x){vector<vector<string>> t;FOR(i,x.u,x.d){t.EB();FOR(j,x.l,x.r)t.back().PB(f(x.a[i][j]));}\\\nstringstream o;VI M;FOR(j,x.l,x.r){int m=0;FOR(i,x.u,x.d)maxi(m, siz(t[i-x.u][j-x.l]));M.PB(m);}FOR(i,x.u,x.d){o<<""\\n\\t[""<<i<<""] "";\\\nFOR(j,x.l,x.r){REP(_, M[j-x.l]-siz(t[i-x.u][j-x.l]))o<<"" "";o<<t[i-x.u][j-x.l]<<((j+1)%5?"", "":""; "");}}ros.str() + ""\\n"";}\nvoid nfl() {for (auto &s : lif)cerr << ""  "" << s.str() << ""\\033[m"" << endl;} ckx(+) ckx(-) ckx(!) ckx(~) avc(bte) avc(ema)\nstruct zet_p {int o;LD v;zet_p(LL x=0):o(x%MOD),v(x){} zet_p(LL x, LD y):o(x%MOD),v(y){} int get(){ros>=0?o:o+MOD;}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o,v+a.v);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o,v-a.v);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o,v*a.v);}\n  zet_p operator/(zet_p a) {assert(a.o != 0); return zet_p(o*1ll*mpow(a.o, MOD-2),v/a.v);}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nostream&operator<<(ostream &o, zet_p u) {ros<<""[""<<u.o<<"" @ ""<<u.v<<""]"";}using frac_mod = zet_p;\n#else\nfalse;\nstruct zet_p {int o;int get(){ros>=0?o:o+MOD;}zet_p(LL x=0):o(x%MOD){}zet_p(int x):o(x%MOD){}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o);}\n  zet_p operator/(zet_p a) {return zet_p(o*1ll*mpow(a.o, MOD - 2));}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nstruct frac_mod {int o,m;int get(){return (o*1ll*mpow(m,MOD-2)%MOD+MOD)%MOD;}frac_mod(int x=0):o(x%MOD),m(1){}frac_mod(LL x):o(x%MOD),m(1){}\n  frac_mod(LL a,LL b):o(a),m(b){}\n  frac_mod operator+(frac_mod a){return frac_mod(o*1ll*a.m+m*1ll*a.o,m*a.m);}\n  frac_mod operator-(frac_mod a){return frac_mod(o*1ll*a.m-m*1ll*a.o,m*a.m);}\n  frac_mod operator*(frac_mod a){return frac_mod(o*1ll*a.o,m*1ll*a.m);}\n  frac_mod operator/(frac_mod a){return frac_mod(o*1ll*a.m,m*1ll*a.o);}\n  bool operator==(frac_mod a) {return (o * 1ll * a.m - m * 1ll * a.o) % MOD == 0;}};\nacv(frac_mod, +) acv(frac_mod, -) acv(frac_mod, *) acv(frac_mod, /)\n#define debug(...)\n#define mark_stack(...)\n#define print_stack(...)\n#endif\nacv(zet_p, +) acv(zet_p, -) acv(zet_p, *) acv(zet_p, /)\n#define nok(o,c,r,l...) auto operator o(c p, r y)-> decltype(MP(l)) {return MP(l);}\n#define pcg(o) sim, class S, class N, class H> nok(o, pair<S u T>, pair<H u N>, p.f o y.f, p.s o y.s)\\\nsim,class S,class N,class=typename enable_if<!is_base_of<ios_base,typename remove_reference<T>::type>::value>::type>nok\\\n(o,T,pair<S u N>, p o y.f, p o y.s) sim, class S, class N> nok(o, pair<S u N>, T, p.f o y, p.s o y)\n#define clp(r) pcg(r) sim, class S, class N, class H> \\\n\tpair <T,S> & operator r##=(pair <T,S> &p, pair<N,H> y) {p.f r##= y.f; p.s r##= y.s; return p;}\\\n\tsim, class S, class N> pair <T,S> &operator r##=(pair<T,S> &p, N y) {p.f r##= y; p.s r##= y; return p;}\n#define u ,\n#define syd(o) sim, class N> auto operator o(pair<T,N> e) -> decltype(MP(o e.f, o e.s)) {return MP(o e.f, o e.s);}\nclp(+) clp(-) clp(*) clp(/) clp(%) clp(^) clp(|) clp(>>) clp(<<) clp(&) pcg(&&) pcg(||) syd(-) syd(+) syd(~) syd(!)\n#undef u\nsim> int dud(T &, T&);sim> char dud(T x, ...);\n#define muf(c...) {\\\n\tsim, class N> static T c get1(pair <T, N> c o){ros.f;}\\\n\tsim, class N> static N c get2(pair <T, N> c o){ros.s;}\\\n\tsim, class N, class S> static T c get1(tri(T, N, S) c o){ros.f.f;}\\\n\tsim, class N, class S> static N c get2(tri(T, N, S) c o){ros.f.s;}\\\n\tsim, class N, class S> static S c get3(tri(T, N, S) c o){ros.s;}\\\n\tsim, class N, class S, class H> static S c get3(quadr(T, N, S, H) c o){ros.s.f;}\\\n\tsim, class N, class S, class H> static H c get4(quadr(T, N, S, H) c o){ros.s.s;}\\\n};\ntemplate <class X> struct qul muf()\ntemplate <> struct qul <int> muf(&)\n#define get1(o) qul<decltype(dud(o, o))>::get1(o)\n#define get2(o) qul<decltype(dud(o, o))>::get2(o)\n#define get3(o) qul<decltype(dud(o, o))>::get3(o)\n#define get4(o) qul<decltype(dud(o, o))>::get4(o)\nsim, class N> using gyv = T;\nnamespace std {sim, class N> struct hash<pair<T,N>>{size_t operator()(const pair<T,N>&u)const {\n      return hash<T>()(u.f) * 440624741ULL ^ hash<N>()(u.s);}};\n  sim> struct hash<gyv<T, decltype(((T*)0)->end())>> {size_t operator()(const T& u) const {size_t o = 505347433;\nfor (auto e : u)o = hash<urs(e)>()(e) ^ o * 277953755ULL;ros;}};}\n\nconst int MN = 1e6 + 44;\nvoid PdAYB7V() {\n\tprint_stack();\n\tdebug(imie(MN) * 1ll * imie(MOD), ""make sure it is right!!!!"");\n\tdebug(""make sure m, n aren\'t misused"");\n\tdebug(""long longs!!!!!!!!!!!!!!!!!!!"");\n\tdebug(""run with m, n = 1"");\n\tdebug(""make sure bounds on values aren\'t misused"");\n\tdebug(""Check time/memory limit"");\n\twhile (getchar() != EOF);\n\texit(0);\n}\nvoid err() {\n\tprintf(""Impossible\\n"");\n\texit(0);\n}\nint main() {\n\t#ifdef DEB\n\tatexit(PdAYB7V);\n\t#endif\n\tint n, m;\n\tscanf(""%d%d"", &n, &m);\n\tif (m < n - 1)\n\t\terr();\n\tVPII ans;\n\tFOR(i, 1, n) {\n\t\tFOR(j, i + 1, n)\n\t\t\tif (__gcd(i, j) == 1) {\n\t\t\t\tans.EB(i, j);\n\t\t\t\tif ((int)ans.size() == m) {\n\t\t\t\t\tprintf(""Possible\\n"");\n\t\t\t\t\tfor (auto x : ans)\n\t\t\t\t\t\tprintf(""%d %d\\n"", x.f, x.s);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\t}\n\terr();\n}\n\n\n']","['brute force', 'constructive algorithms', 'graphs', 'greedy', 'math']",1700
https://codeforces.com//contest/1730/problem/F,F. Almost Sorted,You are given a permutation p of length n and a positive integer k Consider a permutation q of length n such that for any integers i and j where 1 le i j le n we have p q i le p q j k Find the minimum possible number of inversions in a permutation q A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array An inversion in a permutation a is a pair of indices i and j 1 le i j le n such that i j but a i a j ,"['#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"")//Optimization flags\n#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"")//Enable AVX\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2"")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1e9+7;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...)0\n#else\n#define eprintf(...)fprintf(stderr,__VA_ARGS__)\n#endif\ninline string getstr(string&s,int l,int r){string ret="""";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint n,k,p[5555],dp[2][22][555],la,nw,suf[5005][5005],pos[5005],cc,cur;\nint in[22],cnt,nmsk,nj,np;\nvoid upd(int&x,int y){\n\tif(x > y)x=y;\n}\nint main(){\n\tscanf(""%d%d"",&n,&k);\n\tfor(int i=1; i<=n; i++)scanf(""%d"",&p[i]);\n\tnw=1;\n\tfor(int i=0; i<2; i++){\n\t\tfor(int j=0; j<=2*k+2; j++){\n\t\t\tfor(int h=0; h<(1<<k); h++)\n\t\t\t\t\t\tdp[i][j][h]=inf;\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)pos[p[i]]=i;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<=n; j++)suf[i][j]=suf[i-1][j];\n\t\tfor(int j=1; j<=pos[i]; j++)suf[i][j]++;\n\t}\n\tdp[0][k+2][0]=0;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=0; j<=2*k+2; j++){\n\t\t\tfor(int h=0; h<(1<<k); h++)\n\t\t\t\t\t\tdp[nw][j][h]=inf;\n\t\t}\n\t\tfor(int j=0; j<=2*k+2; j++){\n\t\t\tfor(int h=0; h<(1<<k); h++){\n\t\t\t\tif(dp[la][j][h] > 1e8)continue;\n\t\t\t\tcc=i+j-k-2;\n\t\t\t\tcnt=0;\n\t\t\t\tfor(int p=0; p<8; p++){\n\t\t\t\t\tif(h&(1<<p))in[++cnt]=pos[cc+p+1];\n\t\t\t\t}\n\t\t\t\tfor(int p=0; p<8&& cc+p+1<=n; p++){\n\t\t\t\t\tif(h&(1<<p))continue;\n\t\t\t\t\tcur=suf[cc-1][pos[cc+p+1]];\n\t\t\t\t\tfor(int t=1; t<=cnt; t++)cur+=(pos[cc+p+1]<in[t]);\n\t\t\t\t\tif(j)upd(dp[nw][j-1][h |(1<<p)],dp[la][j][h]+cur);\n\t\t\t\t}\n\t\t\t\tcur=suf[cc-1][pos[cc]];\n\t\t\t\tfor(int t=1; t<=cnt;t++)cur+=(pos[cc]<in[t]);\n\t\t\t\tif(h==(1<<k)-1)np=k;else np=__builtin_ctz(~h);\n\t\t\t\tnj=j+np;\n\t\t\t\tif(nj<=(k<<1)+2){\n\t\t\t\t\tupd(dp[nw][nj][h >>(np+1)],dp[la][j][h]+cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tla^=1;\n\t\tnw^=1;\n\t}\n\tprintf(""%d\\n"",dp[la][k+2][0]);\n\treturn 0;\n}']","['bitmasks', 'data structures', 'dp']",2700
https://codeforces.com//contest/1299/problem/D,D. Around the World,You are given a simple weighted undirected connected graph with n vertexes and m edges with the following restriction there isn t any simple cycle i e a cycle which doesn t pass through any vertex more than once of length greater than 3 which passes through the vertex 1 The cost of a path not necessarily simple in this graph is defined as the XOR of weights of all edges in that path with each edge being counted as many times as the path passes through it You may choose any subset of edges incident to the vertex 1 and remove them How many are there such subsets that when removed there is not any nontrivial cycle with the cost equal to 0 which passes through the vertex 1 in the resulting graph A cycle is called if it passes through some edge odd number of times As the answer can be very big output it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\n#define bit(x) (1ll<<(x))\n\nconst int N=101000;\nbool vis[N],br[N];\nint val[N],wt[N];\nll ps,st[N];\nmap<pair<ll,ll>,ll> hs;\nvector<PII> e[N];\nint n,m,mm,a,b,w,mat[N],pe[N];\narray<int,3> p[N];\nVI pd;\nvoid add(ll &s,int x) {\n\tif (s==-1) return;\n\tif (s&bit(x)) s=-1;\n\tll t=s;\n\trep(i,0,32) if (s&bit(i)) t|=bit(i^x);\n\ts=t;\n}\n\nll merge(ll s,ll t) {\n\tif (s==-1||t==-1) return -1;\n\tif ((s&t)!=1) return -1;\n\tif (hs.count(mp(s,t))) return hs[mp(s,t)];\n\tll ns=0;\n\trep(i,0,32) if (s&bit(i)) rep(j,0,32) if (t&bit(j)) ns^=bit(i^j);\n\treturn hs[mp(s,t)]=ns;\n}\n\nset<PII> ue;\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (!vis[v]) {\n\t\t\tval[v]=val[u]^p.se;\n\t\t\tue.insert(mp(u,v));\n\t\t\tdfs(v);\n\t\t} else {\n\t\t\tif (!ue.count(mp(u,v))&&!ue.count(mp(v,u)))\n\t\t\t\tadd(ps,val[u]^val[v]^p.se);\n\t\t\tue.insert(mp(u,v));\n\t\t}\n\t}\n}\n\nvoid upd(int &a,int b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\n\nint mid[410][410],fst[N],dp[5][410],pp[5][410];\nll lab[410];\nmap<ll,int> gid;\n\nint main() {\n\n\tset<ll> pst;\n\tpst.insert(1);\n\trep(i,0,32) {\n\t\tset<ll> qst=pst;\n\t\tfor (auto x:qst) {\n\t\t\tll y=x;\n\t\t\tadd(y,i);\n\t\t\tpst.insert(y);\n\t\t}\n\t\t//printf(""%d %d\\n"",i,SZ(pst));\n\t}\n\tfor (auto x:pst) {\n\t\tlab[m]=x;\n\t\tgid[x]=m;\n\t\t++m;\n\t}\n\trep(i,0,m) rep(j,0,m) {\n\t\tll z=merge(lab[i],lab[j]);\n\t\tassert(gid.count(z));\n\t\tmid[i][j]=gid[z];\n\t}\n\n\tscanf(""%d%d"",&n,&mm);\n\trep(i,0,mm) {\n\t\tscanf(""%d%d%d"",&a,&b,&w);\n\t\tif (a>b) swap(a,b);\n\t\tp[i]={a,b,w};\n\t\tif (a==1) br[b]=1,wt[b]=w;\n\t}\n\trep(i,0,mm) {\n\t\ta=p[i][0]; b=p[i][1]; w=p[i][2];\n\t\tif (a==1) continue;\n\t\tif (br[a]&&br[b]) {\n\t\t\tmat[a]=1; mat[b]=2;\n\t\t\tpe[b]=w^wt[a]^wt[b];\n\t\t\tpd.pb(a); pd.pb(b);\n\t\t} else {\n\t\t\te[a].pb(mp(b,w));\n\t\t\te[b].pb(mp(a,w));\n\t\t}\n\t}\n\trep(i,1,n+1) if (br[i]&&!mat[i]) {\n\t\tpd.pb(i);\n\t}\n\trep(i,0,SZ(pd)) {\n\t\tps=1;\n\t\tdfs(pd[i]);\n\t\tst[i]=ps;\n\t}\n\tdp[0][1]=1;\n\trep(i,0,SZ(pd)) {\n\t\tint u=pd[i];\n\t\tif (mat[u]==2) {\n\t\t\tst[i]=st[i-1]=merge(st[i],st[i-1]);\n\t\t}\n\t}\n\n//printf(""%d\\n"",m);\n\trep(i,0,SZ(pd)) {\n\t\tfst[i]=gid[st[i]];\n\t//\tprintf(""%d %d\\n"",i,fst[i]);\n\t}\n\n\tassert(gid[-1]==0);\n\tdp[0][gid[1]]=1;\n\trep(i,0,SZ(pd)) {\n\t\trep(j,0,2) rep(k,0,m) pp[j][k]=dp[j][k],dp[j][k]=0;\n\t\tint gd=gid[bit(0)|bit(pe[pd[i]])];\n\t\trep(j,0,2) rep(k,0,m) if (pp[j][k]) {\n\t\t\tint ck=k;\n\t\t\tif (mat[pd[i]]!=2||j==0) ck=mid[ck][fst[i]];\n\t\t\tint dk=ck;\n\t\t\tif (mat[pd[i]]==2) {\n\t\t\t\tif (pe[pd[i]]==0) dk=0; else dk=mid[dk][gd];\n\t\t\t}\n\t\t\t//printf(""%d %d %d\\n"",k,fst[i],ck);\n\t\t\tll val=pp[j][k];\n\t\t\trep(w,0,2) {\n\t\t\t\tif (w==1&&j==1) upd(dp[w][dk],val);\n\t\t\t\telse if (w==1) upd(dp[w][ck],val);\n\t\t\t\telse upd(dp[w][k],val);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\trep(j,0,2) rep(k,1,m) upd(ans,dp[j][k]);\n\tprintf(""%d\\n"",ans);\n}\n']","['bitmasks', 'combinatorics', 'dfs and similar', 'dp', 'graphs', 'graphs', 'math', 'trees']",3000
https://codeforces.com//contest/1923/problem/D,D. Slimes,There are n slimes placed in a line The slimes are numbered from 1 to n in order from left to right The size of the i th slime is a i Every second the following happens slime eats one of its neighbors and increases its size by the eaten neighbor s size A slime can eat its neighbor only if it is strictly bigger than this neighbor If there is no slime which is strictly bigger than one of its neighbors the process ends For example suppose n 5 a 2 2 3 1 4 The process can go as follows first the 3 rd slime eats the 2 nd slime The size of the 3 rd slime becomes 5 the 2 nd slime is eaten then the 3 rd slime eats the 1 st slime they are neighbors since the 2 nd slime is already eaten The size of the 3 rd slime becomes 7 the 1 st slime is eaten then the 5 th slime eats the 4 th slime The size of the 5 th slime becomes 5 the 4 th slime is eaten then the 3 rd slime eats the 5 th slime they are neighbors since the 4 th slime is already eaten The size of the 3 rd slime becomes 12 the 5 th slime is eaten For each slime calculate the minimum number of seconds it takes for this slime to be eaten by another slime among all possible ways the process can go or report that it is impossible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    auto work = [&]() {\n        std::vector<i64> s(n + 1);\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = s[i] + a[i];\n        }\n        \n        std::vector<int> ans(n, n + 1);\n        for (int i = 0, k = 1; i < n - 1; i++) {\n            while (k < n && a[i + 1] == a[k]) {\n                k++;\n            }\n            \n            int r = *std::ranges::partition_point(std::ranges::iota_view(i + 2, n + 1),\n                [&](int v) {\n                    return s[v] - s[i + 1] <= a[i];\n                });\n            r = std::max(r, k + 1);\n            if (r <= n) {\n                ans[i] = r - (i + 1);\n            }\n            if (a[i + 1] > a[i]) {\n                ans[i] = 1;\n            }\n        }\n        return ans;\n    };\n    \n    auto ans1 = work();\n    std::reverse(a.begin(), a.end());\n    auto ans2 = work();\n    for (int i = 0; i < n; i++) {\n        int res = std::min(ans1[i], ans2[n - 1 - i]);\n        if (res > n) {\n            res = -1;\n        }\n        std::cout << res << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['binary search', 'constructive algorithms', 'data structures', 'greedy', 'two pointers']",1800
https://codeforces.com//contest/1296/problem/E1,E1. String Coloring  easy version , You are given a string s consisting of n lowercase Latin letters You have to color its characters each character to exactly one color the same letters can be colored the same or different colors i e you can choose exactly one color for each index in s After coloring you can swap two neighboring characters of the string that are colored colors You can perform such an operation arbitrary possibly zero number of times The goal is to make the string sorted i e all characters should be in alphabetical order Your task is to say if it is possible to color the given string so that after coloring it can become sorted by sequence of swaps Note that you have to restore only coloring not the sequence of swaps ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;\nchar a[N];\nint s[N];\nint main()\n{\n    cin>>n;\n    scanf(""%s"",a+1);\n    s[1]=0;\n    for(int i=2;i<=n;i++){\n        s[i]=-1;\n        for(int j=1;j<i;j++){\n            if(a[j]>a[i]){\n                if(s[i]==s[j]){\n                    cout<<""NO""<<endl;\n                    return 0;\n                }\n                s[i]=!s[j];\n            }\n        }\n        if(s[i]==-1)s[i]=0;\n    }\n    cout<<""YES""<<endl;\n    for(int i=1;i<=n;i++)printf(""%d"",s[i]);\n    return 0;\n}\n/*\n*/\n']","['constructive algorithms', 'dp', 'graphs', 'greedy', 'sortings']",1800
https://codeforces.com//contest/1677/problem/E,E. Tokitsukaze and Beautiful Subsegments,Tokitsukaze has a permutation p of length n Let s call a segment l r beautiful if there exist i and j satisfying p i cdot p j max p l p l 1 ldots p r where l leq i j leq r Now Tokitsukaze has q queries in the i th query she wants to know how many beautiful subsegments x y there are in the segment l i r i i e l i leq x leq y leq r i ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//atcoder-library をまあまあコピーして使っている\n\n//N() が単位元\n\n//merge で片方が inactive のときはもう片方をそのまま返す，\n//といったときに，lazy の情報までコピーして渡さないようにする\n\n//get の最後の引数は単位元と口では言いつつ・・・？\n//たとえば min で最後の引数を 0 にしても 1 とかが返ってくることはある（一敗）\n\n//VERIFY:\n//https://atcoder.jp/contests/practice2/tasks/practice2_k\ntemplate<class N>\nstruct seglazy{\n\tvc<N> x;\n\tint L,s;\n\tseglazy(){}\n\ttemplate<class T>\n\tseglazy(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tseglazy(int n){\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.assign(s*2,N());\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif(l==r)return N();\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml,smr;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = N::merge(sml, x[l++]);\n\t\t\tif (r & 1) smr = N::merge(x[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\n\t\treturn N::merge(sml, smr);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r, F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t//(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[0][cnt[0]++]=l++;\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t//(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[1][cnt[1]++]=--r;\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\t\trep(i,cnt[0])(x[buf[0][i]].*f)(forward<Args>(args)...);\n\t\tper(i,cnt[1])(x[buf[1][i]].*f)(forward<Args>(args)...);\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\t//XXI Opencup Krakow M\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\tassert(0<=r&&r<=s);\n        if(r==0)return mp(0,N());\n        r+=s;\n        for (int i = L; i >= 1; i--) push((r - 1) >> i);\n        N sm;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    push(r);\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\nusing A=array<int,2>;\n\n//Range add,sum\nstruct N{\n\tint len;\n\tA sum,lz;\n\tN(int z=0):len(z),sum{},lz{}{}\n\tvoid add(const A&v){\n\t\trep(k,2){\n\t\t\tsum[k]+=v[k]*len;\n\t\t\tlz[k]+=v[k];\n\t\t}\n\t\treturn;\n\t}\n\tvoid push(N&x,N&y){\n\t\tx.add(lz);\n\t\ty.add(lz);\n\t\trep(k,2)lz[k]=0;\n\t}\n\tstatic N merge(const N&x,const N&y){\n\t\tN res(x.len+y.len);\n\t\trep(k,2)res.sum[k]=x.sum[k]+y.sum[k];\n\t\treturn res;\n\t}\n};\n\n//max cartesian tree\nvi cartesiantree(const vi&a){\n\tint n=si(a);\n\tvi par(n,-1);\n\tvi s;\n\trep(i,n){\n\t\tint last=-1;\n\t\twhile(si(s)&&a[s.back()]<=a[i]){\n\t\t\tlast=s.back();\n\t\t\ts.pop_back();\n\t\t}\n\t\tif(last!=-1)par[last]=i;\n\t\tif(si(s))par[i]=s.back();\n\t\ts.pb(i);\n\t}\n\treturn par;\n}\n\nbool inc(pi a,pi b){\n\treturn a.a<=b.a&&b.b<=a.b;\n}\n\nvoid reduce(vc<pi>&lr){\n\tsort(all(lr));\n\tint s=0;\n\trep(i,si(lr)){\n\t\twhile(s>0&&inc(lr[s-1],lr[i]))s--;\n\t\tif(s==0||lr[s-1].a<lr[i].a)lr[s++]=lr[i];\n\t}\n\tlr.resize(s);\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tvi a=readvi(n);\n\tvc<A> t(n,A{-1,-1});\n\tvi par=cartesiantree(a);\n\tint root=-1;\n\trep(i,n)if(par[i]==-1)root=i;\n\telse t[par[i]][par[i]<i]=i;\n\n\tvc<pi> cap(n);\n\t{\n\t\tauto rec=[&](auto self,int v,int l,int r)->void{\n\t\t\tif(v==-1)return;\n\t\t\tcap[v]=pi(l,r);\n\t\t\tself(self,t[v][0],l,v-1);\n\t\t\tself(self,t[v][1],v+1,r);\n\t\t};\n\t\trec(rec,root,0,n-1);\n\t}\n\n\tvvc<pi> ls(n+1);\n\tvi inv(n+1);\n\trep(i,n)inv[a[i]]=i;\n\trng(x,1,n+1)for(int y=x+1;x*y<=n;y++){\n\t\tint v=x*y;\n\t\tpi z=minmax(inv[x],inv[y]);\n\t\tif(inc(cap[inv[v]],z)){\n\t\t\tchmin(z.a,inv[v]);\n\t\t\tchmax(z.b,inv[v]);\n\t\t\tls[v].pb(z);\n\t\t}\n\t}\n\t\n\tvvc<pi> add(n);\n\trng(v,1,n+1){\n\t\treduce(ls[v]);\n\t\tdmp2(v,ls[v]);\n\t\tif(si(ls[v])){\n\t\t\tauto [c,d]=cap[inv[v]];\n\t\t\tint prel=c-1;\n\t\t\tfor(auto [l,r]:ls[v]){\n\t\t\t\tadd[l].eb(r,1);\n\t\t\t\tif(prel>=0)add[prel].eb(r,-1);\n\t\t\t\tprel=l;\n\t\t\t}\n\t\t\tadd[prel].eb(d+1,-1);\n\t\t\tif(c>0){\n\t\t\t\tadd[c-1].eb(d+1,1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvvc<pi> ask(n);\n\trep(i,q){\n\t\tint l,r;cin>>l>>r;\n\t\tl--;\n\t\task[l].eb(r,i);\n\t}\n\t\n\tvi ans(q);\n\tseglazy<N> seg(vi(n,1));\n\tper(i,n){\n\t\tfor(auto [r,w]:add[i]){\n\t\t\tdmp2(i,r,w);\n\t\t\tseg.ch(r,seg.s,&N::add,A{-w,(i+1)*w});\n\t\t}\n\t\tfor(auto [r,dst]:ask[i]){\n\t\t\tauto w=seg.composite(0,r).sum;\n\t\t\tdmp(w);\n\t\t\tans[dst]=w[0]*i+w[1];\n\t\t}\n\t}\n\t\n\trep(i,q)print(ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']",['data structures'],2900
https://codeforces.com//contest/1020/problem/A,A. New Building for SIS,You are looking at the floor plan of the Summer Informatics School s new building You were tasked with SIS logistics so you really care about travel time between different locations it is important to know how long it would take to get from the lecture room to the canteen or from the gym to the server room The building consists of towers floors each where the towers are labeled from to the floors are labeled from to There is a passage between any two adjacent towers two towers and for all on every floor where It takes exactly one minute to walk between any two adjacent floors of a tower as well as between any two adjacent towers provided that there is a passage on that floor It is not permitted to leave the building You have given pairs of locations floor of tower and floor of tower For each pair you need to determine the minimum walking time between these locations ,"['#include <bits/stdc++.h>\n#define sz(x) ((int)x.size())\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint n, h, a, b, Q;\nint main() {\n\tscanf(""%d%d%d%d%d"",&n,&h,&a,&b,&Q);\n\twhile(Q--) {\n\t\tint x1,y1,x2,y2;\n\t\tscanf(""%d%d%d%d"",&x1,&y1,&x2,&y2);\n\t\tif(x1 == x2) printf(""%d\\n"",abs(y1-y2));\n\t\telse {\n\t\t\tint d1;\n\t\t\tif(a<=y1 && y1<=b) d1 = y1;\n\t\t\telse if(y1 > b) d1 = b;\n\t\t\telse d1 = a;\n\t\t\tprintf(""%d\\n"",abs(d1-y1)+abs(x1-x2)+abs(d1-y2));\n\t\t}\n\t}\n\treturn 0;\n}']",['math'],1000
https://codeforces.com//contest/552/problem/D,D. Vanya and Triangles,Vanya got bored and he painted distinct points on the plane After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points He asks you to count the number of the formed triangles with the area ,"['#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nll N, A, T;\npair<ll, ll> pts[2048];\n\nll gcd(ll a, ll b){\n    if(!b) return a;\n    return gcd(b, a%b);\n}\n\nint main(){\n    setup();\n    cin >> N;\n    for(int i=0; i<N; i++)\n        cin >> pts[i].first >> pts[i].second;\n\n    for(int c=0; c<N; c++){\n        vector<pair<ll, ll> > off;\n        for(int i=0; i<N; i++){\n            if(i==c) continue;\n            pair<ll, ll> val = {pts[i].first - pts[c].first,\n                                  pts[i].second - pts[c].second};\n            ll g = gcd(abs(val.first), abs(val.second));\n            val.first /= g;\n            val.second /= g;\n            off.push_back(val);\n        }\n\n        sort(off.begin(), off.end());\n\n        for(int i=0; i<off.size(); ){\n            int j = i+1;\n            while(j<off.size() && off[j] == off[i]) j++;\n            T += (j-i) * (j-i-1) / 2;\n            i = j;\n        }\n    }\n\n    A = N * (N - 1) * (N - 2) / 6;\n    A -= T/2;\n    cout << A << endl;\n}\n']","['brute force', 'combinatorics', 'data structures', 'geometry', 'math', 'sortings']",1900
https://codeforces.com//contest/1848/problem/B,B. Vika and the Bridge,In the summer Vika likes to visit her country house There is everything for relaxation comfortable swings bicycles and a river There is a wooden bridge over the river consisting of n planks It is quite old and unattractive so Vika decided to paint it And in the shed they just found cans of paint of k colors After painting each plank in one of k colors Vika was about to go swinging to take a break from work However she realized that the house was on the other side of the river and the paint had not yet completely dried so she could not walk on the bridge yet In order not to spoil the appearance of the bridge Vika decided that she would still walk on it but only stepping on planks of the same color Otherwise a small layer of paint on her sole will spoil the plank of another color Vika also has a little paint left but it will only be enough to repaint plank of the bridge Now Vika is standing on the ground in front of the first plank To walk across the bridge she will choose some planks of the same color after repainting which have numbers 1 le i 1 i 2 ldots i m le n planks are numbered from 1 from left to right Then Vika will have to cross i 1 1 i 2 i 1 1 i 3 i 2 1 ldots i m i m 1 1 n i m planks as a result of each of m 1 steps Since Vika is afraid of falling she does not want to take too long steps Help her and tell her the minimum possible maximum number of planks she will have to cross if she can repaint one plank a different color while crossing the bridge ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int mod = 998244353, N = 200005;\nint n, k, a[N];\nvector<int> vec[N];\n \nvoid frank() {\n    cin >> n >> k;\n    for (int i = 0; i < k; ++i) vec[i].clear(), vec[i].pb(-1);\n    for (int i = 0; i < n; ++i) cin >> a[i], a[i]--, vec[a[i]].pb(i);\n    for (int i = 0; i < k; ++i) vec[i].pb(n);\n    int res = (n + 2) / 2;\n    for (int i = 0; i < k; ++i) if(sz(vec[i]) > 2) {\n        vector<int> vec1;\n        for (int j = 0; j < sz(vec[i]) - 1; ++j) vec1.pb(vec[i][j + 1] - vec[i][j]);\n        sort(all(vec1), greater<int>());\n        res = min(res, max(vec1[1], (vec1[0] + 1) / 2));\n    }\n    cout << res - 1 << ""\\n"";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        frank();\n    }\n}']","['binary search', 'data structures', 'greedy', 'implementation', 'math', 'sortings']",1200
https://codeforces.com//contest/1934/problem/D2,D2. XOR Break — Game Version,Alice and Bob are playing a game The game starts with a positive integer n with players taking turns On each turn of the game the following sequence of events takes place The player having the integer p breaks it into two integers p 1 and p 2 where 0 lt p 1 lt p 0 lt p 2 lt p and p 1 oplus p 2 p If no such p 1 p 2 exist the player loses Otherwise the opponent does either select the integer p 1 or p 2 The game continues with the selected integer The opponent will try to break it As Alice your goal is to win You can execute a maximum of 63 break operations You have the choice to play first or second The system will act for Bob Here oplus denotes the bitwise XOR operation ,"['#include <bits/stdc++.h>\nusing namespace std;\n//#define endl \'\\n\'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    //IOS;\n\n\n\n    int T; cin >> T;\n    while(T--){\n        int n; cin >> n;\n        \n        if(__builtin_popcountll(n) % 2){\n            cout << ""second"" << endl;\n            while(1){\n                int ret1, ret2; cin >> ret1 >> ret2;\n                if(ret1 <= 0 && ret2 <= 0) break;\n                int cnt1 = __builtin_popcountll(ret1);\n                int cnt2 = __builtin_popcountll(ret2);\n                if(cnt1 % 2) swap(ret1, ret2);\n                int first = 63 - __builtin_clzll(ret1);\n                cout << (1ll << first) << \' \' << ret1 - (1ll << first) << endl;\n            }\n        }   \n        else{\n            cout << ""first"" << endl;\n            int ffirst = 63 - __builtin_clzll(n);\n            cout << (1ll << ffirst) << \' \' << n - (1ll << ffirst) << endl;\n            while(1){\n                int ret1, ret2; cin >> ret1 >> ret2;\n                if(ret1 <= 0 && ret2 <= 0) break;\n                int cnt1 = __builtin_popcountll(ret1);\n                int cnt2 = __builtin_popcountll(ret2);\n                if(cnt1 % 2) swap(ret1, ret2);\n                int first = 63 - __builtin_clzll(ret1);\n                cout << (1ll << first) << \' \' << ret1 - (1ll << first) << endl;\n            }\n        }\n    }\n}']","['bitmasks', 'games', 'greedy', 'interactive']",2400
https://codeforces.com//contest/427/problem/A,A. Police Recruits,The police department of your city has just started its journey Initially they don t have any manpower So they started hiring new recruits in groups Meanwhile crimes keeps occurring within the city One member of the police force can investigate only one crime during his her lifetime If there is no police officer free isn t busy with crime during the occurrence of a crime it will go untreated Given the chronological order of crime occurrences and recruit hirings find the number of crimes which will go untreated ,"['#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n  //freopen(""input.txt"", ""rt"", stdin);\n  //freopen(""output.txt"", ""wt"", stdout);\n\n  int n;\n  int cur = 0;\n  int res = 0;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n; i++)\n  {\n    int v;\n    scanf(""%d"", &v);\n    cur += v;\n    if (cur < 0)\n    {\n      res++;\n      cur = 0;\n    }\n  }\n\n  printf(""%d"", res);\n\n  return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/988/problem/E,E. Divisibility by 25,You are given an integer n from 1 to 10 18 without leading zeroes In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes In other words the number you have cannot contain any leading zeroes What is the minimum number of moves you have to make to obtain a number that is divisible by 25 Print if it is impossible to obtain a number that is divisible by 25 ,"['/// In The Name Of God\n\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl \'\\n\'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)5e5 + 7;\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint n;\nint ans = inf;\nchar s[N], t[N];\nint last[10];\n\nvoid go(char x, char y) {\n\tif (!min(last[x], last[y])) return;\n\tint cnt = 0;\n\trep(i, 1, n) t[i] = s[i];\n\tx += \'0\', y += \'0\';\n\tper(i, n, 1) {\n\t\tif (t[i] == y) {\n\t\t\twhile (i < n) swap(t[i], t[i + 1]), ++cnt, ++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tper(i, n, 1) {\n\t\tif (t[i] == x) {\n\t\t\twhile (i < (n - 1)) swap(t[i], t[i + 1]), ++cnt, ++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (t[1] == \'0\') {\n\t\trep(i, 2, n - 2) {\n\t\t\tif (t[i] != \'0\') {\n\t\t\t\tans = min(ans, cnt + i - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tans = min(ans, cnt);\n}\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (""in.txt"", ""r"", stdin);\n\t#endif\n\tcin >> (s + 1);\n\tn = strlen(s + 1);\n\tint cnt = 0, cur = 0;\n\tper(i, n, 1) {\n\t\tif (s[i] == \'0\' && cnt < 2) {\n\t\t\tcur += (n - cnt) - i;\n\t\t\t++cnt;\n\t\t}\n\t\tint x = s[i] - \'0\';\n\t\tif (!last[x]) last[x] = i;\n\t}\n\tif (cnt == 2) ans = min(ans, cur);\n\t/*\n\tif (last[2] && last[5]) ans = min(ans, (n - last[5]) + (n - 1 - last[2]));\n\tif (last[7] && last[5]) ans = min(ans, (n - last[5]) + (n - 1 - last[7]));*/\n\tgo(2, 5);\n\tgo(5, 0);\n\tgo(7, 5);\n\n\tif (ans == inf) ans = -1;\n\tcout << ans;\n\tioi\n}\n']","['brute force', 'greedy']",2100
https://codeforces.com//contest/680/problem/A,A. Bear and Five Cards,A little bear Limak plays a game He has five cards There is one number written on each card Each number is a positive integer Limak can discard throw out some cards His goal is to minimize the sum of numbers written on remaining not discarded cards He is allowed to discard two or three cards with the same number Of course he won t discard cards if it s impossible to choose two or three cards with the same number Given five numbers written on cards cay you find the minimum sum of numbers on remaining cards ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint sum[110] , x;\nint main(){\n    int all = 0;\n    rep(i,0,5) cin >> x , sum[x]++ , all += x;\n    int Max = 0;\n    rep(x,1,101) if(sum[x] >= 2) Max = max(Max , min(3 ,sum[x]) * x);\n    cout << all - Max << endl;\n    return 0;\n}\n']","['constructive algorithms', 'implementation']",800
https://codeforces.com//contest/165/problem/E,E. Compatible Numbers,Two integers and are if the result of their bitwise AND equals zero that is For example numbers and are compatible as and numbers and are not compatible as You are given an array of integers Your task is to find the following for each array element is this element compatible with some other element from the given array If the answer to this question is positive then you also should find any suitable element ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\nint val[1<<22];\nint a[1<<22];\n\nint main(){\n\tint n;\n\twhile( scanf(""%d"", &n)!=EOF ){\n\t\tclr(val, -1);\n\t\trep(i, 0, n){\n\t\t\tscanf(""%d"", a+i);\n\t\t\tval[a[i]]=a[i];\n\t\t}\n\t\trep(s, 0, two(22) ) if( val[s]>=0 ){\n\t\t\trep(i, 0, 22) if( !test(s, i) ){\n\t\t\t\tval[ s|(1<<i) ]=val[s];\n\t\t\t}\n\t\t}\n\t\trep(i, 0, n){\n\t\t\tint t=(two(22)-1)&(~a[i]);\n\t\t\tif( i ) putchar(\' \');\n\t\t\tprintf(""%d"", val[t]);\n\t\t}\n\t\tputs("""");\n\t}\n}\n\n\n\n\n']","['bitmasks', 'brute force', 'dfs and similar', 'dp']",2200
https://codeforces.com//contest/1943/problem/A,A. MEX Game 1,Alice and Bob play yet another game on an array a of size n Alice starts with an empty array c Both players take turns playing with Alice starting first On Alice s turn she picks one element from a appends that element to c and then deletes it from a On Bob s turn he picks one element from a and then deletes it from a The game ends when the array a is empty Game s score is defined to be the MEX dagger of c Alice wants to maximize the score while Bob wants to minimize it Find game s final score if both players play optimally dagger The operatorname MEX minimum excludant of an array of integers is defined as the smallest non negative integer which does not occur in the array For example The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"['/**\n *    author:  tourist\n *    created: 16.03.2024 10:34:30\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> cnt(n + 3);\n    for (int i = 0; i < n; i++) {\n      cnt[a[i]] += 1;\n    }\n    bool met = false;\n    for (int i = 0; i < int(cnt.size()); i++) {\n      if (cnt[i] == 0 || (cnt[i] == 1 && met)) {\n        cout << i << \'\\n\';\n        break;\n      }\n      met |= (cnt[i] == 1);\n    }\n  }\n  return 0;\n}\n']","['games', 'greedy']",1300
https://codeforces.com//contest/1451/problem/E1,E1. Bitwise Queries  Easy Version ,Ridbit has a hidden array a of n integers which he wants Ashish to guess Note that n is a Ashish is allowed to ask three different types of queries They are of the form i j ask for the bitwise AND of elements a i and a j 1 leq i j le n i neq j i j ask for the bitwise OR of elements a i and a j 1 leq i j le n i neq j i j ask for the bitwise XOR of elements a i and a j 1 leq i j le n i neq j Can you help Ashish guess the elements of the array ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nint a[(1<<17)+1];\n\nint xr(int i, int j)\n{\n\ti++; j++;\n\tcout<<""XOR ""<<i<<\' \'<<j<<\'\\n\';\n\tfflush(stdout);\n\tint x; cin>>x; \n\tif(x==-1) exit(0);\n\treturn x;\n}\n\nint ad(int i, int j)\n{\n\ti++; j++;\n\tcout<<""AND ""<<i<<\' \'<<j<<\'\\n\';\n\tfflush(stdout);\n\tint x; cin>>x;\n\tif(x==-1) exit(0);\n\treturn x;\n}\n\nint o(int i, int j)\n{\n\ti++; j++;\n\tcout<<""OR ""<<i<<\' \'<<j<<\'\\n\';\n\tfflush(stdout);\n\tint x; cin>>x; \n\tif(x==-1) exit(0);\n\treturn x;\n}\n\nint O[5][5];\n\nint main()\n{\n\tint n; cin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\ta[i]=xr(0,i);\n\t}\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tfor(int j=i+1;j<3;j++)\n\t\t{\n\t\t\tO[i][j]=O[j][i]=o(i,j);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) //try all possibilties\n\t{\n\t\tint b[3] = {};\n\t\tb[0]=i;\n\t\tb[1]=a[1]^b[0];\n\t\tb[2]=a[2]^b[0];\n\t\tint pos=1;\n\t\tfor(int j=0;j<3;j++)\n\t\t{\n\t\t\tfor(int k=j+1;k<3;k++)\n\t\t\t{\n\t\t\t\tif((b[j]|b[k])!=O[j][k])\n\t\t\t\t{\n\t\t\t\t\tpos=0; break;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tif(!pos) break;\n\t\t}\n\t\tif(pos)\n\t\t{\n\t\t\tcout<<""! "";\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcout<<(a[j]^i);\n\t\t\t\tif(j+1<n) cout<<\' \';\n\t\t\t}\n\t\t\tcout<<\'\\n\'; fflush(stdout); return 0;\n\t\t}\n\t}\n}\n']","['bitmasks', 'constructive algorithms', 'interactive', 'math']",2000
https://codeforces.com//contest/1388/problem/B,B. Captain Flint and a Long Voyage,In the beginning uncle Bogdan wrote on a board a positive integer x consisting of n digits After that he wiped out x and wrote integer k instead which was the concatenation of binary representations of digits x consists of without leading zeroes For example let x 729 then k 111101001 since 7 111 2 10 9 1001 After some time uncle Bogdan understood that he doesn t know what to do with k and asked Denis to help Denis decided to wipe last n digits of k and named the new number as r As a result Denis proposed to find such integer x of length n that r as number is maximum possible If there are multiple valid x then Denis is interested in the minimum one All crew members including captain Flint himself easily solved the task All except cabin boy Kostya who was too drunk to think straight But what about you Note in this task we compare integers x or k as numbers despite what representations they are written in so 729 1999 or 111 1000 ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main() {\n\tint a[N];\n\tf(i, N)a[i] = 0;\n\tint n, k, t;\n\tint x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(""%d"", &t);\n\tf(tt, t) {\n\t\tscanf(""%d"", &n);\n\t\tk = (n + 3) / 4;\n\t\tf(i, n - k)printf(""9"");\n\t\tf(i, k)printf(""8"");\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}']","['greedy', 'math']",1000
https://codeforces.com//contest/1430/problem/G,G. Yet Another DAG Problem,You are given a directed acyclic graph a directed graph that does not contain cycles of n vertices and m arcs The i th arc leads from the vertex x i to the vertex y i and has the weight w i Your task is to select an integer a v for each vertex v and then write a number b i on each arcs i such that b i a x i a y i You must select the numbers so that all b i are positive the value of the expression sum limits i 1 m w i b i is the lowest possible It can be shown that for any directed acyclic graph with non negative w i such a way to choose numbers exists ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=20;\nint n,m,S,ind[N];\nint e[1<<18|5];\nint f[1<<18|5];\nint fr[1<<18|5];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tFor(i,1,m){\n\t\tint x,y,w;\n\t\tscanf(""%d%d%d"",&x,&y,&w);\n\t\t--x; --y;\n\t\tind[y]|=1<<x;\n\t\te[(1<<x)|(1<<y)]=w;\n\t\tS+=w;\n\t}\n\tFor(i,0,n-1)\n\t\tFor(S,0,(1<<n)-1)\n\t\t\tif (S&(1<<i))\n\t\t\t\te[S]+=e[S^(1<<i)];\n\tmemset(f,30,sizeof(f));\n\tf[0]=0;\n\tFor(i,0,(1<<n)-1){\n\t\t//cerr<<i<<endl;\n\t\tf[i]+=S-e[i]-e[(1<<n)-1-i];\n\t\tint SS=0;\n\t\tFor(j,0,n-1) if (!(i&(1<<j)))\n\t\t\tif ((ind[j]&i)==ind[j])\n\t\t\t\tSS|=1<<j;\n\t\tfor (int j=SS;j;j=(j-1)&SS)\n\t\t\tif (f[i|j]>f[i]) f[i|j]=f[i],fr[i|j]=j;\n\t}\n\tint res[20];\n\tFor(i,0,n-1) res[i]=0;\n\tint S=(1<<n)-1;\n\tfor (;S;S-=fr[S]){\n\t\t//cout<<S<<\' \'<<fr[S]<<endl;\n\t\tFor(i,0,n-1) if (S&(1<<i)) ++res[i];\n\t}\n\tFor(i,0,n-1) cout<<res[i]<<\' \';\n}']","['bitmasks', 'dfs and similar', 'dp', 'flows', 'graphs', 'math']",2600
https://codeforces.com//contest/1800/problem/E2,E2. Unforgivable Curse  hard version ,The chief wizard of the Wizengamot once caught the evil wizard Drahyrt but the evil wizard has returned and wants revenge on the chief wizard So he stole s from his student Harry The is a n length string of lowercase Latin letters Drahyrt wants to replace with an unforgivable curse string t Dragirt using ancient magic can swap letters at a distance k or k 1 in as many times as he wants In other words Drahyrt can change letters in positions i and j in s if i j k or i j k 1 For example if k 3 s and t Drahyrt can act as follows swap the letters at positions 1 and 4 to get swap the letters at positions 2 and 6 to get You are given s and t Can Drahyrt change s to t ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lo; \ntypedef pair< lo,lo > PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define endl ""\\n""\n#define pb push_back\n#define fio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define FOR for(int i=1;i<=n;i++)\n#define mid ((start+end)/2)\n#define ort ((bas+son)/2)\n\nconst lo inf = 1000000000000000000;\nconst lo KOK = 100000;\nconst lo LOG = 30;\nconst lo li = 200002;\nconst lo mod = 1000000007;\n\nint n,m,k,flag,t,mpp[26][li],git[26][li];\nint cev;\nchar s[li],ss[li];\n\ninline int in(){\n    int x;\n    scanf(""%d"",&x);\n    return x;\n}\n\nint main(void){\n    t=in();\n    while(t--){\n        n=in();\n        k=in();\n        scanf(""%s %s"",(s+1),(ss+1));\n        for(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<min(n+1,k);j++){\n\t\t\t\tmpp[i][j]=0;\n\t\t\t\tgit[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tflag=0;\n        FOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[s[i]-\'a\'][i%k]++;\n\t\t}\n\t\tFOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[ss[i]-\'a\'][i%k]--;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<min(n+1,k);j++){\n\t\t\t\tmpp[i][j]+=git[i][j];\n\t\t\t\tif(j!=k-1 && n!=k+1){\n\t\t\t\t\tgit[i][j+1]+=mpp[i][j];\n\t\t\t\t\tmpp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(mpp[i][j]){flag=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(flag){printf(""NO\\n"");}\n\t\telse printf(""YES\\n"");\n    }\n    return 0;\n}\n']","['brute force', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'strings']",1500
https://codeforces.com//contest/659/problem/F,F. Polycarp and Hay,The farmer Polycarp has a warehouse with hay which can be represented as an rectangular table where is the number of rows and is the number of columns in the table Each cell of the table contains a haystack The height in meters of the hay located in the th row and the th column is equal to an integer and coincides with the number of cubic meters of hay in the haystack because all cells have the size of the base Polycarp has decided to tidy up in the warehouse by removing an arbitrary integer amount of cubic meters of hay from the top of each stack You can take different amounts of hay from different haystacks Besides it is allowed not to touch a stack at all or on the contrary to remove it completely If a stack is completely removed the corresponding cell becomes empty and no longer contains the stack Polycarp wants the following requirements to hold after the reorganization the total amount of hay remaining in the warehouse must be to the heights of all stacks i e cells containing a non zero amount of hay should be the same the height of at least one stack must remain the same as it was for the stability of the remaining structure all the stacks should form one connected region The two stacks are considered adjacent if they share a side in the table The area is called connected if from any of the stack in the area you can get to any other stack in this area moving only to adjacent stacks In this case two adjacent stacks necessarily belong to the same area Help Polycarp complete this challenging task or inform that it is impossible ,"['#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#define X first\n#define Y second\n\nconst int maxn = 1005;\nconst int maxs = 1e6 + 5;\nconst int move[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint n, m;\nlong long K;\n\nint a[maxn][maxn], b[maxn][maxn], fa[maxs], size[maxs];\nstd::pair<int, std::pair<int,int> > t[maxs];\nint tot, lim;\n\nint find(int x)\n{\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nvoid merge(int a,int b)\n{\n\ta = find(a), b = find(b);\n\t\n\tif(a != b)\n\t{\n\t\tsize[a] += size[b];\n\t\tsize[b] = 0, fa[b] = a;\n\t}\n}\nvoid dfs(int x,int y)\n{\n\tif(!(x >= 0 && x < n && y >= 0 && y < m)) return;\n\tif(a[x][y] < lim || b[x][y] || !tot) return; \n\t\n\tb[x][y] = lim, tot--;\n\t\n\tdfs(x + 1, y);\n\tdfs(x - 1, y);\n\tdfs(x, y - 1);\n\tdfs(x, y + 1);\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"",""r"",stdin);\n\tfreopen(""output.txt"",""w"",stdout);\n#endif\n\n\tscanf(""%d%d"", &n, &m);\n\tstd::cin >> K;\n\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tscanf(""%d"", &a[i][j]);\n\t\t\tt[i * m + j] = std::make_pair(a[i][j], std::make_pair(i, j));\n\t\t}\n\t\t\n\tstd::sort(t, t + n * m);\n\tstd::reverse(t, t + n * m);\n\n\tfor(int i = 0; i < n * m; i++) fa[i] = i, size[i] = 1;\n\t\n\tint ans = -1;\n\t\n\tfor(int i = 0, j = 0; i < n * m; i = j)\n\t{\n\t\twhile(j < n * m && t[j].X == t[i].X)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint ox = t[j].Y.X;\n\t\t\t\tint oy = t[j].Y.Y;\n\t\t\t\tint x = move[k][0] + ox;\n\t\t\t\tint y = move[k][1] + oy;\n\t\t\t\t\n\t\t\t\tif(x >= 0 && x < n && y >= 0 && y < m)\n\t\t\t\t\tif(a[x][y] >= t[i].X) merge(x * m + y, ox * m + oy);\n\t\t\t}\n\t\t\t\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tif(t[i].X && K % t[i].X == 0)\n\t\t{\n\t\t\tfor(int k = i; k < j; k++)\n\t\t\t{\n\t\t\t\tint x = t[k].Y.X, y = t[k].Y.Y;\n\t\t\t\t\t\n\t\t\t\tif(size[find(x * m + y)] >= K / t[i].X)\n\t\t\t\t\t{ ans = x * m + y; break; }\n\t\t\t}\n\t\t\n\t\t\tif(ans != -1) break;\n\t\t}\n\t}\n\t\n\tif(ans == -1) puts(""NO"");\n\telse\n\t{\n\t\tlim = a[ans / m][ans % m];\n\t\ttot = K / lim;\n\t\t\n\t\tdfs(ans / m, ans % m);\n\t\t\n\t\tputs(""YES"");\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tprintf(""%d "", b[i][j]);\n\t\t\tputs("""");\n\t\t}\n\t}\n\t\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);\n\tfclose(stdout);\n#endif\n\treturn 0;\n}']","['dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']",2000
https://codeforces.com//contest/1154/problem/E,E. Two Teams,There are n students standing in a row Two coaches are forming two teams the first coach chooses the first team and the second coach chooses the second team The i th student has integer programming skill a i All programming skills are and between 1 and n inclusive Firstly the first coach will choose the student with maximum programming skill among all students not taken into any team k closest students to the left of him and k closest students to the right of him if there are less than k students to the left or to the right all of them will be chosen All students that are chosen leave the row and join the first team Secondly the second coach will make the same move but all students chosen by him join the second team Then again the first coach will make such move and so on This repeats until the row becomes empty i e the process ends when each student becomes to some team Your problem is to determine which students will be taken into the first team and which students will be taken into the second team ,"['// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n    assert(~c);\n  }\n  if (c == \'-\') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  set<pair<int, int> > s;\n  set<int> pos;\n  int n = read(), k = read();\n  vector<int> arr(n), ans(n);\n  for (int i = 0; i < n; ++i) {\n    s.emplace(arr[i] = read(), i);\n    pos.emplace(i);\n  }\n  while (!s.empty()) {\n    static int cur = 2;\n    if (cur & 1) ++cur; else --cur;\n    int id = s.rbegin()->second;\n    auto it = pos.find(id);\n    /* get left */ {\n      if (it != pos.begin()) {\n        auto jt = it; --jt;\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          if (jt == pos.begin()) {\n            pos.erase(jt); break;\n          }\n          auto kt = jt; --jt;\n          pos.erase(kt);\n        }\n      }\n    } /* get right */ {\n      auto jt = it; ++jt;\n      if (jt != pos.end()) {\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          auto kt = jt; ++jt; pos.erase(kt);\n          if (jt == pos.end()) break;\n        }\n      }\n    }\n    ans[*it] = cur;\n    s.erase({arr[*it], *it});\n    pos.erase(it);\n  }\n  for (int i = 0; i < n; ++i) {\n    printf(""%d"", ans[i]);\n  }\n  return 0;\n}\n']","['data structures', 'implementation', 'sortings']",1800
https://codeforces.com//contest/1238/problem/A,A. Prime Subtraction,You are given two integers x and y it is guaranteed that x y You may choose any integer p and subtract it any number of times from x Is it possible to make x equal to y Recall that a number is a positive integer that has exactly two positive divisors 1 and this integer itself The sequence of prime numbers starts with 2 3 5 7 11 Your program should solve t independent test cases ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint main(){\n\tint q; cin>>q;\n\twhile(q--){\n\t\tll x,y; cin >> x >> y; x -= y;\n\t\tif(x == 1) puts(""NO"");\n\t\telse puts(""YES"");\n\t}\n}']","['math', 'number theory']",900
https://codeforces.com//contest/1151/problem/F,F. Sonya and Informatics,A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland The teacher of computer science Sonya s favorite subject invented a task for her Given an array a of length n and the number k the following happens Two numbers i and j are chosen equiprobable such that 1 leq i j leq n The numbers in the i and j positions are swapped Sonya s task is to find the probability that after all the operations are completed the a array will be She turned to you for help Help Sonya solve this problem It can be shown that the desired probability is either 0 or it can be represented as dfrac P Q where P and Q are coprime integers and Q not equiv 0 pmod 10 9 7 ,"['#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nusing modulo = modint<mod>;\nint N, K, A[109]; modulo ans[55][55], mat[55][55], tmp[55][55];\nint main() {\n\tcin >> N >> K;\n\tint zeros = 0, ones = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t\tif (A[i] == 0) ++zeros;\n\t\telse ++ones;\n\t}\n\tint inidiff = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] == 0 && i >= zeros) ++inidiff;\n\t}\n\tmodulo allposs = modulo(N * (N - 1) / 2);\n\tint md = min(zeros, ones);\n\tfor (int i = 0; i <= md; ++i) {\n\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\tif (i - j == 1) {\n\t\t\t\tmat[i][j] = modulo(i * i) * allposs.inv();\n\t\t\t}\n\t\t\tif (i - j == 0) {\n\t\t\t\tmat[i][j] = modulo(allposs - i * i - (zeros - i) * (ones - i)) * allposs.inv();\n\t\t\t}\n\t\t\tif (i - j == -1) {\n\t\t\t\tmat[i][j] = modulo((zeros - i) * (ones - i)) * allposs.inv();\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= md; ++i) {\n\t\tans[i][i] = modulo(1);\n\t}\n\twhile (K > 0) {\n\t\tif (K & 1) {\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\ttmp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\tfor (int k = 0; k <= md; ++k) {\n\t\t\t\t\t\ttmp[i][j] += ans[i][k] * mat[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\tans[i][j] = tmp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\ttmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\tfor (int k = 0; k <= md; ++k) {\n\t\t\t\t\ttmp[i][j] += mat[i][k] * mat[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\tmat[i][j] = tmp[i][j];\n\t\t\t}\n\t\t}\n\t\tK >>= 1;\n\t}\n\tcout << ans[inidiff][0].get() << endl;\n\treturn 0;\n}']","['combinatorics', 'dp', 'matrices', 'probabilities']",2300
https://codeforces.com//contest/1082/problem/F,F. Speed Dial,Polycarp s phone book contains n phone numbers each of them is described by s i the number itself and m i the number of times Polycarp dials it in daily Polycarp has just bought a brand new phone with an amazing feature More precisely k buttons on it can have a number assigned to it not necessary from the phone book To enter some number Polycarp can press one of these k buttons and then finish the number using usual digit buttons entering a number with only digit buttons is also possible button can only be used when no digits are entered No button can have its number reassigned What is the minimal total number of Polycarp can achieve after he assigns numbers to buttons and enters each of the numbers from his phone book the given number of times in an optimal way ,"['/*\nShe came from the past\nShe was never meant to last\nHer destiny was fatal\nFrom the start\nA messenger from hell\nShe cast a deadly spell\nOn all of those who dare\nTo cross her heart\nAin\'t no use in you trying to run\nFate has taken it\'s toll\nJust one look and the damage is done\nBurn your eyes\nTurn your heart into stone\nHistory foretold of a circle\nCast in gold\nAn evil seed of power\nSealed within\nBut fate has lent a hand\nDestroyed the golden band\nAnd freed her soul\nTo wash the land with sin\nAin\'t no use in you trying to run\nFate has taken it\'s toll\nJust one look and the damage is done\nBurn your eyes\nTurn your heart into stone\nShe cast a deadly spell\nShe put a spell on you\nShe\'s got evil in her heart\nTurn your heart into stone\nTurn your heart into stone\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n,k;\nstring st;\nint am;\nint total_size;\n\nint done[531][531][11],knap[531][531][11];\nvector<int> g[531];\nint memo[531][531][11];\nint subsize[N];\n\nint have[531][11];\nint C;\nint dep[N];\n\nint solve(int v,int dep_above,int to_put){\n\n\t//cout<<v<<"" ""<<dep_above<<"" ""<<to_put<<endl;\n\n\tif (done[v][dep_above][to_put])\n\t\treturn memo[v][dep_above][to_put];\n\tdone[v][dep_above][to_put]=1;\n\n\tfor (int i=0;i<=g[v].size();i++){\n\t\tfor (int j=0;j<=to_put;j++){\n\t\t\tknap[v][i][j]=-1e9;\n\t\t}\n\t}\n\tknap[v][0][0]=0;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i];\n\t\tfor (int already=0;already<=to_put;already++){\n\t\t\tfor (int here=0;here+already<=to_put;here++){\n\t\t\t\tfor (int in_root=0;in_root<=1;in_root++){\n\t\t\t\t\tint saved=knap[v][i][already];\n\t\t\t\t\tif (in_root)\n\t\t\t\t\t\tsaved+=subsize[to]*(dep[to]-dep_above);\n\t\t\t\t\tif (in_root==1&&here==0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (in_root==1)\n\t\t\t\t\t\tsaved+=solve(to,dep[to],here-1);\n\t\t\t\t\telse\n\t\t\t\t\t\tsaved+=solve(to,dep_above,here);\n\t\t\t\t\tknap[v][i+1][already+here]=max(knap[v][i+1][already+here],saved);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0;i<=to_put;i++)\n\t\tmemo[v][dep_above][to_put]=max(memo[v][dep_above][to_put],knap[v][g[v].size()][i]);\n\treturn memo[v][dep_above][to_put];\n}\n\nvoid add(string st,int am){\n\tint ptr=0;\n\tfor (int i=0;i<st.size();i++){\n\t\tint here=st[i]-\'0\';\n\t\tif (have[ptr][here]==0){\n\t\t\t++C;\n\t\t\thave[ptr][here]=C;\n\t\t\tg[ptr].push_back(C);\n\t\t\tdep[C]=dep[ptr]+1;\n\t\t}\n\t\tptr=have[ptr][here];\n\t\tsubsize[ptr]+=am;\n\t}\n}\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>k;\n\n\tfor (int i=1;i<=n;i++){\n\t\tcin>>st;\n\t\tcin>>am;\n\t\tadd(st,am);\n\t\ttotal_size+=st.size()*am;\n\t}\n\n\tint res=solve(0,0,k);\n\tcout<<total_size-res<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']","['dp', 'strings', 'trees']",2800
https://codeforces.com//contest/1082/problem/C,C. Multi-Subject Competition,A multi subject competition is coming The competition has m different subjects participants can choose from That s why Alex the coach should form a competition delegation among his students He has n candidates For the i th person he knows subject s i the candidate specializes in and r i a skill level in his specialization this level can be negative The rules of the competition require each delegation to choose some subset of subjects they will participate in The only restriction is that the participating in each of the subjects should be the Alex decided that each candidate would participate only in the subject he specializes in Now Alex wonders whom he has to choose to maximize the total sum of skill levels of all delegates or just skip the competition this year if every valid non empty delegation has negative sum Of course Alex doesn t have any spare money so each delegate he chooses must participate in the competition ,"['/*\nI am Iron Man\n\nHas he lost his mind?\nCan he see or is he blind?\nCan he walk at all\nOr if he moves will he fall?\n\nIs he alive or dead?\nHas he thoughts within his head?\nWe\'ll just pass him there\nWhy should we even care?\n\nHe was turned to steel\nIn the great magnetic field\nWhen he traveled time\nFor the future of mankind\n\nNobody wants him\nHe just stares at the world\nPlanning his vengeance\nThat he will soon unfurl\n\nNow the time is here\nFor Iron Man to spread fear\nVengeance from the grave\nKills the people he once saved\n\nNobody wants him\nThey just turn their heads\nNobody helps him\nNow he has his revenge\n\nHeavy boots of lead\nFill his victims full of dread\nRunning as fast as they can\nIron Man lives again!\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 200031;\n\nint n,m;\nvector<int> v[N];\nlong long C[N],ans;\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++){\n\t\tint id,val;\n\t\tcin>>id>>val;\n\t\tv[id].push_back(val);\n\t}\n\n\tfor (int i=1;i<=m;i++){\n\t\tsort(v[i].begin(),v[i].end());\n\t\treverse(v[i].begin(),v[i].end());\n\t\tlong long s=0;\n\t\tfor (int j=0;j<v[i].size();j++){\n\t\t\ts+=v[i][j];\n\t\t\tif (s>0)\n\t\t\t\tC[j+1]+=s;\n\t\t}\n\t}\n\n\tfor (int i=1;i<=n;i++){\n\t\tans=max(ans,C[i]);\n\t}\n\n\tcout<<ans<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']","['greedy', 'sortings']",1600
https://codeforces.com//contest/893/problem/A,A. Chess For Three,Alex Bob and Carl will soon participate in a team chess tournament Since they are all in the same team they have decided to practise really hard before the tournament But it s a bit difficult for them because chess is a game for two players not three So they play with each other according to following rules Alex and Bob play the first game and Carl is spectating When the game ends the one who lost the game becomes the spectator in the next game and the one who was spectating plays against the winner Alex Bob and Carl play in such a way that there are no draws Today they have played games and for each of these games they remember who was the winner They decided to make up a log of games describing who won each game But now they doubt if the information in the log is correct and they want to know if the situation described in the log they made up was possible that is no game is won by someone who is spectating if Alex Bob and Carl play according to the rules Help them to check it ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tint spec = 3;\n\tfor (int x : a) {\n\t\tif (x == spec) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t\tspec = 6 - x - spec;\n\t}\n\tputs(""YES"");\n\n\treturn 0;\n}\n']",['implementation'],900
https://codeforces.com//contest/1722/problem/C,C. Word Game,Three guys play a game first each person writes down n distinct words of length 3 Then they total up the number of points as follows if a word was written by one person that person gets 3 points if a word was written by two people each of the two gets 1 point if a word was written by all nobody gets any points In the end how many points does each player have ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint t,n,a[200005];\nstring s[4][200005];\nsigned main()\n{\n\tcin>>t;\n\tmap<string,int>cnt;\n\twhile(t--)\n\t{\n\t\tcnt.clear();\n\t\tcin>>n;\n\t\tfor(int i=1;i<=3;i++)for(int j=1;j<=n;j++)cin>>s[i][j],cnt[s[i][j]]++;\n\t\tfor(int i=1;i<=3;i++)\n\t\t{\n\t\t\tint ans=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint x=cnt[s[i][j]];\n\t\t\t\tif(x==1)ans+=3;\n\t\t\t\telse if(x==2)ans++;\n\t\t\t\telse ;\n\t\t\t}\n\t\t\tprintf(""%d "",ans);\n\t\t}\n\t\tprintf(""\\n"");\n\t}\n \treturn 0;\n}']","['data structures', 'implementation']",800
https://codeforces.com//contest/1436/problem/A,A. Reorder,For a given array a consisting of n integers and a given integer m find if it is possible to reorder elements of the array a in such a way that sum i 1 n sum j i n frac a j j equals m It is forbidden to delete elements as well as insert new elements Please note that no rounding occurs during division for example frac 5 2 2 5 ,"['//#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\n#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include ""debug-template.hpp""\n#endif\n\nusing namespace std;\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint ncase;\n\tfor (cin >> ncase; ncase--; ) {\n\t\tint n, m; cin >> n >> m;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x; cin >> x;\n\t\t\tm -= x;\n\t\t}\n\t\tcout << (m == 0 ? ""YES"" : ""NO"") << \'\\n\';\n\t}\n\treturn 0;\n}\n']",['math'],800
https://codeforces.com//contest/1516/problem/C,C. Baby Ehab Partitions Again,Baby Ehab was toying around with arrays He has an array a of length n He defines an array to be good if there s no way to partition it into 2 subsequences such that the sum of the elements in the first is equal to the sum of the elements in the second Now he wants to remove the minimum number of elements in a so that it becomes a good array Can you help him A sequence b is a subsequence of an array a if b can be obtained from a by deleting some possibly zero or all elements A partitioning of an array is a way to divide it into 2 subsequences such that every element belongs to exactly one subsequence so you must use all the elements and you can t share any elements ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,a[2002],sum,G;\nbitset<200002>B;\nint main(){\n\tn=read(),B[0]=1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=read(),sum+=a[i];\n\t\tB|=(B<<a[i]);\n\t}\n\tif((sum&1)||(!B[sum>>1]))return puts(""0""),0;\n\tG=a[1];\n\tfor(re int i=2;i<=n;++i)G=__gcd(G,a[i]);\n\tfor(re int i=1;i<=n;++i)a[i]/=G;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]&1){\n\t\t\tprintf(""1\\n%d"",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n']","['bitmasks', 'constructive algorithms', 'dp', 'math']",1700
https://codeforces.com//contest/1083/problem/A,A. The Fair Nut and the Best Path,The Fair Nut is going to travel to the Tree Country in which there are n cities Most of the land of this country is covered by forest Furthermore the local road system forms a tree connected graph without cycles Nut wants to rent a car in the city u and go by a simple path to city v He hasn t determined the path so it s time to do it Note that chosen path can consist of only one vertex A filling station is located in every city Because of strange law Nut can buy only w i liters of gasoline in the i th city We can assume that he has Each road has a length and as soon as Nut drives through this road the amount of gasoline decreases by length Of course Nut can t choose a path which consists of roads where he runs out of gasoline He can buy gasoline in visited city even in and He also wants to find the maximum amount of gasoline that he can have at the end of the path Help him count it ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nvector <pair <int,ll> > graf[nax];\n\nll dfs(int v, int oj)\n{\n\tll ret=tab[v];\n\twyn=max(wyn, tab[v]);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tll w=dfs(i.first, v)-i.second;\n\t\twyn=max(wyn, ret+w);\n\t\tret=max(ret, w+tab[v]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c);\n\t\tgraf[a].push_back({b, c});\n\t\tgraf[b].push_back({a, c});\n\t}\n\tdfs(1, 0);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['data structures', 'dp', 'trees']",1800
https://codeforces.com//contest/1260/problem/F,F. Colored Tree,You re given a tree with n vertices The color of the i th vertex is h i The value of the tree is defined as sum limits h i h j 1 le i j le n dis i j where dis i j is the number of edges on the shortest path between i and j The color of each vertex is lost you only remember that h i can be any integer from l i r i inclusive You want to calculate the sum of values of all trees meeting these conditions modulo 10 9 7 the set of edges is fixed but each color is unknown so there are prod limits i 1 n r i l i 1 different trees ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nint n;\nint C[100005];\nvector<int> A[100005];\nvector<int> E[100005];\n\nll pw(ll x, ll p) {\n    if (p == 0) return 1;\n    if (p == 1) return x;\n    ll v = pw(x, p / 2);\n    v = v * v % mod;\n    if (p % 2 != 0) v = v * x % mod;\n    return v;\n}\n\nint sz[100005];\nint de[100005];\n\nvoid dfs1(int x, int p) {\n    sz[x] = 1;\n    for (int i : E[x]) {\n        if (i == p || de[i]) continue;\n        dfs1(i, x);\n        sz[x] += sz[i];\n    }\n}\n\nint dfs2(int x, int p, int n) {\n    for (int i : E[x]) {\n        if (i == p || de[i]) continue;\n        if (sz[i] > n / 2) return dfs2(i, x, n);\n    }\n    return x;\n}\n\nint D[100005][20];\nint G[100005][20];\n\nvoid dfs3(int x, int p, int s, int d, int g) {\n    D[x][d] = s;\n    G[x][d] = g;\n    for (int i : E[x]) {\n        if (i == p || de[i]) continue;\n        dfs3(i, x, s + 1, d, g);\n    }\n}\n\nint P[100005];\nint L[100005];\nll csum[100005];\nvector<ll> cisum[100005];\nll dsum[100005];\nvector<ll> disum[100005];\nint cent_decomp(int x, int d) {\n    dfs1(x, 0);\n    x = dfs2(x, 0, sz[x]);\n    L[x] = d;\n    D[x][d] = 0;\n    G[x][d] = 0;\n    cisum[x].push_back(0);\n    disum[x].push_back(0);\n    for (int i : E[x]) {\n        if (de[i]) continue;\n        dfs3(i, x, 1, d, cisum[x].size());\n        cisum[x].push_back(0);\n        disum[x].push_back(0);\n    }\n    de[x] = 1;\n    for (int i : E[x]) {\n        if (de[i]) continue;\n        P[cent_decomp(i, d + 1)] = x;\n    }\n    return x;\n}\n\nll query(int x, int t) {\n    ll ans = 0;\n    for (int c = x; c; c = P[c]) {\n        int d = L[c];\n        ll add = (ll)t * D[x][d] % mod;\n        ans += (csum[c] + mod - cisum[c][G[x][d]]) * add % mod;\n        ans += (dsum[c] + mod - disum[c][G[x][d]]) * t % mod;\n        csum[c] = (csum[c] + t) % mod;\n        cisum[c][G[x][d]] = (cisum[c][G[x][d]] + t) % mod;\n        dsum[c] = (dsum[c] + add) % mod;\n        disum[c][G[x][d]] = (disum[c][G[x][d]] + add) % mod;\n    }\n    return ans % mod;\n}\n\nint main() {\n    scanf(""%d"", &n);\n    ll all = 1;\n    for (int i = 1; i <= n; i++) {\n        int l, r;\n        scanf(""%d %d"", &l, &r);\n        A[l].push_back(i);\n        A[r + 1].push_back(-i);\n        all = all * (r - l + 1) % mod;\n        C[i] = pw(r - l + 1, mod - 2);\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(""%d %d"", &u, &v);\n        E[u].push_back(v);\n        E[v].push_back(u);\n    }\n    cent_decomp(1, 0);\n    ll ans = 0, sum = 0;\n    for (int i = 1; i <= 100000; i++) {\n        for (int j : A[i]) {\n            if (j < 0) {\n                sum += query(-j, mod - C[-j]);\n            }\n            else {\n                sum += query(j, C[j]);\n            }\n        }\n        sum %= mod;\n        ans += sum;\n        ans %= mod;\n    }\n    printf(""%lld\\n"", ans * all % mod);\n}']","['data structures', 'trees']",2700
https://codeforces.com//contest/280/problem/C,C. Game on Tree,Momiji has got a rooted tree consisting of nodes The tree nodes are numbered by integers from to The root has number Momiji decided to play a game on this tree The game consists of several steps On each step Momiji chooses one of the remaining tree nodes let s denote it by and removes all the subtree nodes with the root in node from the tree Node gets deleted as well The game finishes when the tree has no nodes left In other words the game finishes after the step that chooses the node number Each time Momiji chooses a new node uniformly among all the remaining nodes Your task is to find the expectation of the number of steps in the described game ,"['/*\nAuthor: elfness@UESTC\n*/\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long LL;\nconst int V=100100;\nstruct Edge{int num,ne;}e[V*2];\nint p[V],K;\nvoid add(int x,int y)\n{\n    e[K].num=y;e[K].ne=p[x];p[x]=K++;\n}\nint d[V];\nvoid dfs(int u,int fa)\n{\n    for(int i=p[u];i!=-1;i=e[i].ne)\n    {\n        int v=e[i].num;\n        if(v==fa)continue;\n        d[v]=d[u]+1;dfs(v,u);\n    }\n}\nint n;\nint main()\n{\n    while(~scanf(""%d"",&n))\n    {\n        for(int i=1;i<=n;i++)p[i]=-1;\n        for(int i=1;i<n;i++)\n        {\n            int x,y;\n            scanf(""%d%d"",&x,&y);\n            add(x,y);add(y,x);\n        }\n        d[1]=0;\n        dfs(1,-1);\n        double ret=0.0;\n        for(int i=1;i<=n;i++)ret+=1.0/(d[i]+1);\n        printf(""%.12f\\n"",ret);\n    }\n}\n']","['implementation', 'math', 'probabilities', 'trees']",2200
https://codeforces.com//contest/282/problem/D,D. Yet Another Number Game,Since most contestants do not read this part I have to repeat that Bitlandians are quite weird They have their own jobs their own working method their own lives their own sausages and their own games Since you are so curious about Bitland I ll give you the chance of peeking at one of these games BitLGM and BitAryo are playing yet another of their crazy looking genius needed Bitlandish games They ve got a sequence of non negative integers The players make moves in turns BitLGM moves first Each player can and must do one of the two following actions in his turn Take one of the integers we ll denote it as Choose integer And then decrease by that is apply assignment Choose integer And then decrease all by that is apply assignment for all The player who cannot make a move loses You re given the initial sequence Determine who wins if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define LL long long\n#define maxn 3010100\n#define maxe 210000\n\ndouble sq5 = sqrt(5.0);\n\nint match(int a, int b){\n\tint j = b - a;\n\tint aj = floor(j * (sq5 + 1.0)/2.0);\n\tif(aj == a)\n\t\treturn 1;\n\t// printf(""j = %d, aj = %d\\n"", j, aj);\n\treturn 0;\n}\nint sheng[301][301][301];\nint main()\n{\n\tint i,j,k,cnt=0;\n\tfor(i=0;i<301;i++)\n\t\tfor(j=0;j<301;j++)\n\t\t{\n\t\t\tfor(k=0;k<301;k++)if(!sheng[i][j][k])\n\t\t\t{\n\t\t\t\tint M=min(i,min(j,k));\n\t\t\t\tfor(int t=1;t+M<301;t++)\n\t\t\t\t{\n\t\t\t\t\tif(t+i<301)\n\t\t\t\t\t\tsheng[t+i][j][k]=1;\n\t\t\t\t\tif(t+j<301)\n\t\t\t\t\t\tsheng[i][j+t][k]=1;\n\t\t\t\t\tif(t+k<301)\n\t\t\t\t\t\tsheng[i][j][k+t]=1;\n\t\t\t\t\tif(t+j<301&&t+k<301&&t+i<301)\n\t\t\t\t\t\tsheng[i+t][j+t][k+t]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tscanf(""%d"",&n);\n\t\tif(n==1)\n\t\t{\n\t\t\tscanf(""%d"",&i);\n\t\t\tif(i)\n\t\t\t\tputs(""BitLGM"");\n\t\t\telse\n\t\t\t\tputs(""BitAryo"");\n\t\t}\n\t\telse if(n==2)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(""%d%d"",&a,&b);\n\t\t\tif(a > b)\n\t\t\tswap(a, b);\n\t\tif(match(a, b)){\n\t\t\tprintf(""BitAryo\\n"");\n\t\t}else{\n\t\t\tprintf(""BitLGM\\n"");\n\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(""%d%d%d"",&i,&j,&k);\n\t\t\tint ii,jj,kk;\n\t\t\tii=min(min(i,j),k);\n\t\t\tkk=max(max(i,j),k);\n\t\t\tjj=i+j+k-ii-kk;\n\t\t\ti=ii,j=jj,k=kk;\n\n\t\t\tif(sheng[i][j][k])\n\t\t\t\tputs(""BitLGM"");\n\t\t\telse\n\t\t\t\tputs(""BitAryo"");\n\t\t}\n\t\t//printf(""%d\\n"",cnt);\n}']","['dp', 'games']",2100
https://codeforces.com//contest/496/problem/B,B. Secret Combination,You got a box with a combination lock The lock has a display showing digits There are two buttons on the box each button changes digits on the display You have quickly discovered that the first button adds 1 to all the digits all digits 9 become digits 0 and the second button shifts all the digits on the display one position to the right the last digit becomes the first one For example if the display is currently showing number then if we push the first button the display will show and if after that we push the second button the display will show You know that the lock will open if the display is showing the smallest possible number that can be obtained by pushing the buttons in some order The leading zeros are ignored while comparing numbers Now your task is to find the desired number ,"['#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nset <string> ans;\n\nint main()\n{\n    //freopen(""in.txt"", ""r"", stdin);\n    //freopen(""a.txt"", ""w"", stdout);\n    int n;\n    cin >> n;\n    string tmp;\n    cin >> tmp;\n    for (int i = 0; i < tmp.size(); i++)\n    {\n        int u = tmp[i] - \'0\';\n        u = 10 - u;\n        string tmp2 = tmp;\n        for (int j = 0; j < tmp2.size(); j++)\n        {\n            tmp2[j] += u;\n            if (tmp2[j] - \'0\' >= 10) tmp2[j] -= 10;\n        }\n        string tmp3 = tmp2.substr(i) + tmp2.substr(0, i);\n        ans.insert(tmp3);\n    }\n    tmp = *ans.begin();\n    cout << tmp << endl;\n    //system(""pause"");\n    return 0;\n}']","['brute force', 'constructive algorithms', 'implementation']",1500
https://codeforces.com//contest/1918/problem/C,C. XOR-distance,You are given integers a b r Find the smallest value of a oplus x b oplus x among all 0 leq x leq r oplus is the operation of bitwise XOR and y is absolute value of y ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace SOL {\n\nusing i64 = long long;\nvoid debug(const char *msg, ...) {\n#ifdef CLESIP\n    va_list arg;\n    static char pbString[512];\n    va_start(arg,msg);\n    vsprintf(pbString,msg,arg);\n    cerr << ""[DEBUG] "" << pbString << ""\\n"";\n    va_end(arg);\n#endif    \n}\ntemplate<typename T, typename L>\nbool chkmax(T &x, L y) { if (x < y) return x = y, true; return false; }\ntemplate<typename T, typename L>\nbool chkmin(T &x, L y) { if (y < x) return x = y, true; return false; }\n\nconst i64 inf = 1e18;\n\nvoid solve() {\n\ti64 a, b, r; cin >> a >> b >> r;\n\n\ti64 ans = 0;\n\tbool flag = false;\n\n\tif (a < b)\n\t\tswap(a, b);\n\n\tfor (int i = 59; i >= 0; i --) {\n\t\tint x = (a >> i & 1);\n\t\tint y = (b >> i & 1);\n\t\ti64 pw = (1LL << i);\n\n\t\tif (x != y) {\n\t\t\tif (pw <= r && flag && x == 1) {\n\t\t\t\tans -= pw;\n\t\t\t\tr -= pw;\n\t\t\t} else {\n\t\t\t\tflag = true;\n\t\t\t\tans += pw * (x - y);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << ""\\n"";\n}\n\n}\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint tt; cin >> tt;\n\twhile (tt --)\n\t\tSOL::solve();\n\treturn 0;\n}']","['bitmasks', 'greedy', 'implementation', 'math']",1400
https://codeforces.com//contest/1288/problem/B,B. Yet Another Meme Problem,You are given two integers A and B calculate the number of pairs a b such that 1 le a le A 1 le b le B and the equation a cdot b a b conc a b is true conc a b is the concatenation of a and b for example conc 12 23 1223 conc 100 11 10011 ,"['//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 _y0\n#define kill _kill\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll btc = 30;\nconst ld eps = 1e-10;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 998244353; //(int)(1e9 + 7); //998244353;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n//constants\nconst int M = (int)(2e5 + 239);\nconst int N = (int)(2e3 + 239);\nconst int L = 20;\nconst int T = (1 << 20);\nconst int B = 500;\nconst int X = 1e4 + 239;\n\nvoid solve()\n{\n    int a, b;\n    cin >> a >> b;\n    ll pr = 10;\n    ll ans = 0;\n    while (pr - 1 <= b) {\n        ans += a;\n        pr *= 10;\n    }\n    cout << ans << ""\\n"";\n}\n\nint32_t main()\n{\n#ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}']",['math'],1100
https://codeforces.com//contest/356/problem/C,C. Compartments,A team of students from the city S is sent to the All Berland Olympiad in Informatics Traditionally they go on the train All students have bought tickets in one carriage consisting of compartments each compartment has exactly four people We know that if one compartment contain one or two students then they get bored and if one compartment contain three or four students then the compartment has fun throughout the entire trip The students want to swap with other people so that no compartment with students had bored students To swap places with another person you need to convince him that it is really necessary The students can not independently find the necessary arguments so they asked a sympathetic conductor for help The conductor can use her life experience to persuade any passenger to switch places with some student However the conductor does not want to waste time persuading the wrong people so she wants to know what is the minimum number of people necessary to persuade her to change places with the students Your task is to find the number After all the swaps each compartment should either have no student left or have a company of three or four students ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nint start[42], finish[42];\nint dstart[42], dfinish[42];\nint c[42], d[42];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i <= 4; i++) c[i] = 0;\n  int tot = 0;\n  for (int i = 0; i < n; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    c[foo]++;\n    tot += foo;\n  }\n  int sum = 0;\n  for (int i = 4; i >= 0; i--) {\n    start[i] = sum + 1;\n    finish[i] = sum + c[i];\n    sum += c[i];\n  }\n  int ans = inf;\n  for (int k4 = 0; 4 * k4 <= tot; k4++) {\n    int k3 = (tot - 4 * k4);\n    if (k3 % 3 != 0) continue;\n    k3 /= 3;\n    if (k4 + k3 > n) continue;\n    for (int i = 0; i <= 4; i++) d[i] = 0;\n    d[4] = k4;\n    d[3] = k3;\n    d[0] = n - k4 - k3;\n    int sum = 0;\n    for (int i = 4; i >= 0; i--) {\n      dstart[i] = sum + 1;\n      dfinish[i] = sum + d[i];\n      sum += d[i];\n    }\n    int cur = 0;\n    for (int i = 0; i <= 4; i++)\n      for (int j = 0; j <= 4; j++) {\n        int low = start[i];\n        if (dstart[j] > low) low = dstart[j];\n        int high = finish[i];\n        if (dfinish[j] < high) high = dfinish[j];\n        if (low <= high) {\n          int diff = i - j;\n          if (diff < 0) diff = -diff;\n          cur += (high - low + 1) * diff;\n        }\n      }\n    cur /= 2;\n    if (cur < ans) ans = cur;\n  }\n  printf(""%d\\n"", ans == inf ? -1 : ans);\n  return 0;\n}\n']","['combinatorics', 'constructive algorithms', 'greedy', 'implementation']",2100
https://codeforces.com//contest/1499/problem/B,B. Binary Removals,You are given a string s consisting only of characters or Let s be the length of s You are asked to choose some integer k k 0 and find a sequence a of length k such that 1 le a 1 a 2 dots a k le s a i 1 1 a i for all i from 2 to k The characters at positions a 1 a 2 dots a k are removed the remaining characters are concatenated without changing the order So in other words the positions in the sequence a should not be adjacent Let the resulting string be s s is called sorted if for all i from 2 to s s i 1 le s i Does there exist such a sequence a that the resulting string s is sorted ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nchar A[105];\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%s"", A + 1);\n\t\tN = strlen(A + 1);\n\t\tint L, R;\n\t\tfor(L = 2; L <= N; L++) {\n\t\t\tif(A[L] == \'1\' && A[L - 1] == \'1\') {\n\t\t\t\tL--; break;\n\t\t\t}\n\t\t}\n\n\t\tfor(R = N - 1; R >= 1; R--) {\n\t\t\tif(A[R] == \'0\' && A[R + 1] == \'0\') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(L < R) puts(""NO"");\n\t\telse puts(""YES"");\n\t}\n\treturn 0;\n}']","['brute force', 'dp', 'greedy', 'implementation']",1000
https://codeforces.com//contest/1216/problem/C,C. White Sheet,There is a white sheet of paper lying on a rectangle table The sheet is a rectangle with its sides parallel to the sides of the table If you will take a look from above and assume that the bottom left corner of the table has coordinates 0 0 and coordinate axes are left and bottom sides of the table then the bottom left corner of the white sheet has coordinates x 1 y 1 and the top right x 2 y 2 After that two black sheets of paper are placed on the table Sides of both black sheets are also parallel to the sides of the table Coordinates of the bottom left corner of the first black sheet are x 3 y 3 and the top right x 4 y 4 Coordinates of the bottom left corner of the second black sheet are x 5 y 5 and the top right x 6 y 6 Determine if some part of the white sheet can be seen from the above after the two black sheets are placed The part of the white sheet can be seen if there is at least one point lying the white sheet and of both black sheets ,"['#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\nconst int N=500010;\nconst int M=1000010;\nusing namespace std;\n\nstruct nn{\n\tint xa,xb,ya,yb;\n\tvoid READ(){\n\t\tscanf(""%d%d%d%d"",&xa,&ya,&xb,&yb);\n\t}\n}a[5];\n\nint CV(nn A,nn B){\n\tif(A.xa==B.xa&&A.ya==B.ya&&A.xb==B.xb&&A.yb==B.yb)return 1;\n\treturn 0;\n}\n\nvoid INIT(int i){\n\ta[i].xa=max(a[i].xa,a[1].xa);\n\ta[i].ya=max(a[i].ya,a[1].ya);\n\ta[i].xb=min(a[i].xb,a[1].xb);\n\ta[i].yb=min(a[i].yb,a[1].yb);\n}\n\nint CHK(nn A,nn B){\n\tif(A.xa==B.xa&&A.xb==B.xb)return 1;\n\tif(A.ya==B.ya&&A.yb==B.yb)return 2;\n\treturn 0;\n}\n\nint SOLVE(){\n\tif(CV(a[2],a[1])||CV(a[3],a[1]))return 1;\n\tint na=CHK(a[2],a[1]),nb=CHK(a[3],a[1]);\n\tif(na+nb==0)return 0;\n\tif(na!=nb)return 0;\n\tif(na==2){\n\t\tif(a[2].xa>a[3].xa)swap(a[2],a[3]);\n\t\tif(a[2].xa>a[1].xa||a[3].xb<a[1].xb)return 0;\n\t\tif(a[2].xb>=a[3].xa)return 1;\n\t\treturn 0;\n\t}\n\telse{\n\t\tif(a[2].ya>a[3].ya)swap(a[2],a[3]);\n\t\tif(a[2].ya>a[1].ya||a[3].yb<a[1].yb)return 0;\n\t\tif(a[2].yb>=a[3].ya)return 1;\n\t\treturn 0;\t\n\t}\n}\n\nint main(){\n\trep(i,1,3)a[i].READ();\n\tINIT(2);INIT(3);\n\tif(SOLVE())printf(""NO\\n"");\n\telse printf(""YES\\n"");\n\treturn 0;\n}\n']","['geometry', 'math']",1700
https://codeforces.com//contest/987/problem/C,C. Three displays,It is the middle of 2018 and Maria Stepanovna who lives outside Krasnokamensk a town in Zabaikalsky region wants to rent three displays to highlight an important problem There are n displays placed along a road and the i th of them can display a text with font size s i only Maria Stepanovna wants to rent such three displays with indices i j k that the font size increases if you move along the road in a particular direction Namely the condition s i s j s k should be held The rent cost is for the i th display is c i Please determine the smallest cost Maria Stepanovna should pay ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint s[3005], c[3005];\n\nint dp[4][3005];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> s[i];\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> c[i];\n\n\tfor (int i=1; i<=n; i++) {\n\t\tdp[1][i] = c[i];\n\t\tfor (int j=2; j<=3; j++) {\n\n\t\t\tdp[j][i] = 1123123123;\n\n\t\t\tfor (int k=1; k<i; k++)\n\t\t\t\tif (s[k] < s[i])\n\t\t\t\t\tdp[j][i] = min(dp[j][i], dp[j-1][k] + c[i]);\n\t\t}\n\t}\n\n\tint x=  *min_element(dp[3]+1, dp[3]+n+1);\n\tif (x == 1123123123)\n\t\tx = -1;\n\tcout << x;\n}']","['brute force', 'dp', 'implementation']",1400
https://codeforces.com//contest/61/problem/D,D. Eternal Victory,Valerian was captured by Shapur The victory was such a great one that Shapur decided to carve a scene of Valerian s defeat on a mountain So he had to find the best place to make his victory eternal He decided to visit all cities of Persia to find the best available mountain but after the recent war he was too tired and didn t want to traverse a lot So he wanted to visit each of these cities at least once with smallest possible traverse Persian cities are connected with bidirectional roads You can go from any city to any other one using these roads and there is a unique path between each two cities All cities are numbered to Shapur is currently in the city and he wants to visit all other cities with minimum possible traverse He can finish his travels in any city Help Shapur find how much He should travel ,"['# include <cstdio>\n# include <vector>\n# include <algorithm>\n# include <iostream>\n\nusing namespace std;\n\nstruct two\n{\n    int vert,weight;\n};\n\nvector<two>adjlist [100000];\n\nint maxdepth=0;\n\nvoid dfs(int vertex,int parent,int depth)\n{\n    if(depth>maxdepth)maxdepth=depth;\n    for(int i=0;i<adjlist[vertex].size();i++)\n    {\n        int v=adjlist[vertex][i].vert;\n        if(v!=parent)dfs(v,vertex,depth+adjlist[vertex][i].weight);\n    }\n}\n\nint main()\n{\n    int N;\n    scanf(""%d"",&N);\n    \n    long long ret=0ll;\n    for(int i=1;i<N;i++)\n    {\n        int a;\n        two temp;\n        scanf(""%d%d%d"",&a,&temp.vert,&temp.weight);\n        --a;--temp.vert;\n        adjlist[a].push_back(temp);\n        swap(a,temp.vert);\n        adjlist[a].push_back(temp);\n        ret+=temp.weight;\n    }\n    ret<<=1;\n    \n    dfs(0,-1,0);\n    cout<<ret-maxdepth<<""\\n"";\n    \n    return 0;\n}\n']","['dfs and similar', 'graphs', 'greedy', 'shortest paths', 'trees']",1800
https://codeforces.com//contest/1731/problem/D,D. Valiant s New Map,Game studio DbZ Games wants to introduce another map in their popular game Valiant This time the map named Panvel will be based on the city of Mumbai Mumbai can be represented as n times m cellular grid Each cell i j 1 le i le n 1 le j le m of the grid is occupied by a cuboid building of height a i j This time DbZ Games want to make a map that has perfect vertical gameplay That s why they want to choose an l times l square inside Mumbai such that each building inside the square has a height of at least l Can you help DbZ Games find such a square of the maximum possible size l ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n>>m;\n\t\tvector a(n,vector(m,0));\n\t\tcin>>a;\n\t\tint l=0,r=n;\n\t\twhile (l<r)\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tauto ck=[&](int mid)\n\t\t\t{\n\t\t\t\tint i,j;\n\t\t\t\tvector s(n+1,vector(m+1,0));\n\t\t\t\tfor (i=0; i<n; i++) for (j=0; j<m; j++) s[i+1][j+1]=s[i][j+1]+s[i+1][j]-s[i][j]+(a[i][j]>=mid);\n\t\t\t\tfor (i=mid; i<=n; i++) for (j=mid; j<=m; j++) if (s[i][j]+s[i-mid][j-mid]-s[i][j-mid]-s[i-mid][j]==mid*mid) return 1;\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\tif (ck(mid)) l=mid; else r=mid-1;\n\t\t}\n\t\tcout<<l<<\'\\n\';\n\t}\n}\n']","['binary search', 'brute force', 'data structures', 'dp', 'two pointers']",1700
https://codeforces.com//contest/1792/problem/C,C. Min Max Sort,You are given a permutation p of length n a permutation of length n is an array of length n in which each integer from 1 to n occurs exactly once You can perform the following operation any number of times possibly zero choose two different elements x and y and erase them from the permutation insert the minimum of x and y into the permutation in such a way that it becomes the first element insert the maximum of x and y into the permutation in such a way that it becomes the last element For example if p 1 5 4 2 3 and we want to apply the operation to the elements 3 and 5 then after the first step of the operation the permutation becomes p 1 4 2 and after we insert the elements it becomes p 3 1 4 2 5 Your task is to calculate the minimum number of operations described above to sort the permutation p in ascending order i e transform p so that p 1 p 2 dots p n ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005],pos[500005];\nsigned main()\n{\n\tint t,n,ans;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),pos[a[i]]=i;\n\t\tif(n%2==1)ans=1;\n\t\telse ans=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint x,y;\n\t\t\tif(n%2==1)\n\t\t\t{\n\t\t\t\tx=(n+1)/2-(ans+1)/2;\n\t\t\t\ty=(n+1)/2+(ans+1)/2;\n\t\t\t\tif(x<1||y>n||pos[y]-pos[y-1]<0||pos[x+1]-pos[x]<0)break;\n\t\t\t\tans+=2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx=n/2-ans/2;\n\t\t\t\ty=n/2+1+ans/2;\n\t\t\t\tif(x<1||y>n||pos[y]-pos[y-1]<0||pos[x+1]-pos[x]<0)break;\n\t\t\t\tans+=2;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",(n-ans)/2);\n\t}\n\treturn 0;\n}']","['binary search', 'brute force', 'greedy', 'math', 'two pointers']",1500
https://codeforces.com//contest/1523/problem/G,G. Try Booking,William owns a flat in central London He decided to rent his flat out for the next n days to earn some money Since his flat is in the center of the city he instantly got m offers in the form l i r i which means that someone wants to book the flat from day l i until day r i inclusive To avoid spending a lot of time figuring out whether it s profitable for him to accept an offer William decided to develop an algorithm The algorithm processes all offers as they arrive and will only accept offer i if the following two conditions are satisfied r i l i 1 ge x None of the days between l i and r i are occupied by a previously accepted offer William isn t sure what value x should have and he asks you for help For all x from 1 to n he wants you to calculate the total number of days for which the flat would be occupied if the corresponding value will be assigned to x ,"[""/**\n *    author:  tourist\n *    created: 30.05.2021 18:27:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1 << 17;\n\nstruct segtree {\n\n  set<pair<int, int>> tree[2 * MAX];\n\n  segtree() {\n  }\n\n  bool is_good(int v, int x, int y) {\n    auto it = tree[v].lower_bound(make_pair(x, -1));\n    return (it != tree[v].end() && it->second <= y);\n  }\n\n  int find_first(int x, int y) {\n    int v = 1;\n    if (!is_good(v, x, y)) {\n      return -1;\n    }\n    while (v < MAX) {\n      if (is_good(2 * v, x, y)) {\n        v = 2 * v;\n      } else {\n//        assert(is_good(2 * v + 1, x, y));\n        v = 2 * v + 1;\n      }\n    }\n    return v - MAX;\n  }\n\n  void add(int v, int x, int y) {\n    v += MAX;\n    while (v > 0) {\n      auto it = tree[v].lower_bound(make_pair(x + 1, -1));\n      if (it != tree[v].end() && it->second <= y) {\n        // pass\n      } else {\n        while (it != tree[v].begin()) {\n          --it;\n          if (it->second < y) {\n            break;\n          }\n          it = tree[v].erase(it);\n        }\n        tree[v].emplace(x, y);\n      }\n      v /= 2;\n    }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> l(m), r(m);\n  vector<vector<int>> by_len(n + 1);\n  for (int i = 0; i < m; i++) {\n    cin >> l[i] >> r[i];\n    --l[i]; --r[i];\n    by_len[r[i] - l[i] + 1].push_back(i);\n  }\n  segtree st;\n  vector<int> res(n + 1);\n  for (int x = n; x >= 1; x--) {\n    for (int i : by_len[x]) {\n      st.add(i, l[i], r[i]);\n    }\n    function<void(int, int)> Solve = [&](int from, int to) {\n      if (to - from + 1 < x) {\n        return;\n      }\n      int u = st.find_first(from, to);\n      if (u == -1) {\n        return;\n      }\n      res[x] += r[u] - l[u] + 1;\n      Solve(from, l[u] - 1);\n      Solve(r[u] + 1, to);\n    };\n    Solve(0, n - 1);\n  }\n  for (int x = 1; x <= n; x++) {\n    cout << res[x] << '\\n';\n  }\n  return 0;\n}\n""]","['data structures', 'divide and conquer']",3200
https://codeforces.com//contest/462/problem/B,B. Appleman and Card Game,Appleman has cards Each card has an uppercase letter written on it Toastman must choose cards from Appleman s cards Then Appleman should give Toastman some coins depending on the chosen cards Formally for each Toastman s card you should calculate how much Toastman s cards have the letter equal to letter on th then sum up all these quantities such a number of coins Appleman should give to Toastman Given the description of Appleman s cards What is the maximum number of coins Toastman can get ,"['#include <algorithm>\n#include <cstdio>\n#include <functional>\n#ifdef _WIN32\n#define LLFORMAT ""%I64""\n#else\n#define LLFORMAT ""%ll""\n#endif\nconst int MAXN=100005;\nint n,k;\nint s[26];\nvoid init()\n{\n\tstatic char a[MAXN];\n\tscanf(""%d%d%s"",&n,&k,a);\n\tfor (int i=0;i<n;++i) ++s[a[i]-\'A\'];\n}\nvoid solve()\n{\n\tlong long ans=0;\n\tstd::sort(s,s+26,std::greater<int>());\n\tfor (int i=0;i<26;++i)\n\t\tif (k>s[i])\n\t\t{\n\t\t\tans+=(long long)s[i]*s[i];\n\t\t\tk-=s[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=(long long)k*k;\n\t\t\tbreak;\n\t\t}\n\tprintf(LLFORMAT""d\\n"",ans);\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""B.in"",""r"",stdin);\n\tfreopen(""B.out"",""w"",stdout);\n#endif\n\tinit();\n\tsolve();\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);fclose(stdout);\n#endif\n\treturn 0;\n}\n']",['greedy'],1300
https://codeforces.com//contest/1567/problem/A,A. Domino Disaster,Alice has a grid with 2 rows and n columns She fully covers the grid using n dominoes of size 1 times 2 Alice may place them vertically or horizontally and each cell should be covered by exactly one domino Now she decided to show one row of the grid to Bob Help Bob and figure out what the other row of the grid looks like ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar s[111];\nvoid solve() {\n\tscanf(""%d"", &n);\n\tscanf(""%s"", s);\n\tfor (int i = 0; i < n; i++)\n\t\t\tif (s[i] == \'U\') s[i] = \'D\'; else if (s[i] == \'D\') s[i] = \'U\';\n\tputs(s);\n}\n\nint main() {\n\tint T;\n\tscanf(""%d"", &T);\n\tfor (int i = 0; i < T; i++) solve();\n}']","['implementation', 'strings']",800
https://codeforces.com//contest/317/problem/D,D. Game with Powers,Vasya and Petya wrote down all integers from to to play the powers game can be quite large however Vasya and Petya are not confused by this fact Players choose numbers in turn Vasya chooses first If some number is chosen at the current turn it is forbidden to choose or all of its other positive integer powers that is at the next turns For instance if the number is chosen at the first turn one cannot choose or later while it is still allowed to choose or The one who cannot make a move loses Who wins if both Vasya and Petya play optimally ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nbool taken[40005];\n\nint val[] = {\n        0,\n        1,\n        2,\n        1,\n        4,\n        3,\n        2,\n        1,\n        5,\n        6,\n        2,\n        1,\n        8,\n        7,\n        5,\n        9,\n        8,\n        7,\n        3,\n        4,\n        7,\n        4,\n        2,\n        1,\n        10,\n        9,\n        3,\n        6,\n        11,\n        12\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    int res = 0;\n    int rem = n;\n    for (int i = 2; i * i <= n; ++i) {\n        if (taken[i]) {\n            continue;\n        }\n        int sz = 1;\n        int a = i;\n        taken[a] = true;\n        while (a * (LL) i <= n) {\n            a *= i;\n            ++sz;\n            if (a * (LL) a <= n) {\n                taken[a] = true;\n            }\n        }\n        rem -= sz;\n        res ^= val[sz];\n    }\n    res ^= (rem % 2);\n    cout << (res ? ""Vasya"" : ""Petya"") << endl;\n}\n']","['dp', 'games']",2300
https://codeforces.com//contest/358/problem/E,E. Dima and Kicks,Dima is a good person In fact he s great But all good things come to an end Seryozha is going to kick Dima just few times For this reason he divides the room into unit squares Now the room is a rectangle consisting of unit squares For the beginning Seryozha put Dima in a center of some square Then he started to kick Dima it is known that he kicks Dima at least once Each time when Dima is kicked he flyes up and moves into one of four directions up left right down On each move Dima passes unit of the length in the corresponding direction Seryozha is really kind so he kicks Dima in such way that Dima never meets the walls in other words Dima never leave the room s space Seryozha is also dynamic character so Dima never flies above the same segment connecting a pair of adjacent squares twice Seryozha kicks Dima for a long time but Dima is not vindictive Dima writes Dima marked all squares in which he was staying or above which he was flying Thanks to kicks Dima does not remember the value so he asks you to find all possible values which matches to the Dima s records ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define FI first\n#define SE second\n#define MP make_pair\n#define PII pair<int,int>\n#define flt double\n#define INF (0x3f3f3f3f)\n#define MaxN 1020300\n#define MaxNode 1020304\n#define MD 1000000007\n#define UPD(a,b) { a = max(a,(b)); }\n\nconst int pi[] = {0,1,0,-1};\nconst int pj[] = {1,0,-1,0};\n\nint n,m,A[1111][1111],u[1111][1111],l[1111][1111],vis[1111][1111];\nint can[6];\nPII q[MaxN];\n\nint main() {\n\t//freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);\n\tcin >> n >> m;\n\tFill(A,0);\n\tFor(i,1,n) For(j,1,m) scanf(""%d"",&A[i][j]);\n\tFill(vis,0); int cnt = 0; \n\tFor(i,1,n) For(j,1,m) if (!vis[i][j] && A[i][j] == 1) {\n\t\t++cnt;\n\t\tint hd = 0, tl = 1;\n\t\tvis[i][j] = true; q[1] = MP(i,j);\n\t\twhile (hd < tl) {\n\t\t\tPII vex = q[++hd];\n\t\t\tFor(p,0,3) {\n\t\t\t\tint ni = vex.FI + pi[p], nj = vex.SE + pj[p];\n\t\t\t\tif (!vis[ni][nj] && ni && nj && ni <= n && nj <= m && A[ni][nj] == 1) {\n\t\t\t\t\tvis[ni][nj] = true;\n\t\t\t\t\tq[++tl] = MP(ni,nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt > 1) {\n\t\tputs(""-1""); return 0;\n\t}\n\tint odd = 0,GCD = 0;\n\tFor(i,1,n) For(j,1,m) {\n\t\tif (!A[i][j]) {\n\t\t\tl[i][j] = u[i][j] = 0; continue ;\n\t\t}\n\t\tl[i][j] = l[i][j - 1] + 1;\n\t\tu[i][j] = u[i - 1][j] + 1;\n\t\tFill(can,0);\n\t\tint sm = 0;\n\t\tFor(p,0,3) {\n\t\t\tint ni = i + pi[p], nj = j + pj[p];\n\t\t\tif (A[ni][nj]) can[p] = true;\n\t\t\tsm += can[p];\n\t\t}\n\t\tif (sm == 2 && ((can[0] && can[2]) || (can[1] && can[3]))) continue ;\n\t\todd += sm & 1;\n\t\tGCD = __gcd(GCD,l[i][j] - 1);\n\t\tGCD = __gcd(GCD,u[i][j] - 1);\n\t}\n\tif (GCD <= 1 || (odd != 0 && odd != 2)) {\n\t\tputs(""-1""); return 0;\n\t}\n\tFor(i,2,max(n,m)) if (GCD % i == 0) printf(""%d "",i); puts("""");\n\treturn 0;\n}\n']","['brute force', 'dsu', 'graphs', 'implementation']",2300
https://codeforces.com//contest/1543/problem/A,A. Exciting Bets,Welcome to Rockport City It is time for your first ever race in the game against Ronnie To make the race interesting you have bet a dollars and Ronnie has bet b dollars But the fans seem to be disappointed The excitement of the fans is given by gcd a b where gcd x y denotes the greatest common divisor GCD of integers x and y To make the race more exciting you can perform two types of operations Increase both a and b by 1 Decrease both a and b by 1 This operation can only be performed if both a and b are greater than 0 In one move you can perform any one of these operations You can perform arbitrary possibly zero number of moves Determine the maximum excitement the fans can get and the minimum number of moves required to achieve it Note that gcd x 0 x for any x ge 0 ,"['// Problem: A. Exciting Bets\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/A\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),m=read();\n\t\tif(n==m) puts(""0 0"");\n\t\telse\n\t\t{\n\t\t\tint x=abs(n-m);\n\t\t\tprintf(""%lld "",abs(n-m));\n\t\t\tprintf(""%lld\\n"",min(n%x,(x-(n%x))%x));\n\t\t}\n\t}\n\treturn 0;\n}']","['greedy', 'math', 'number theory']",900
https://codeforces.com//contest/22/problem/B,B. Bargaining Table,Bob wants to put a new bargaining table in his office To do so he measured the office room thoroughly and drew its plan Bob s office room is a rectangular room meters Each square meter of the room is either occupied by some furniture or free A bargaining table is rectangular and should be placed so that its sides are parallel to the office walls Bob doesn t want to change or rearrange anything that s why all the squares that will be occupied by the table should be initially free Bob wants the new table to sit as many people as possible thus its perimeter should be maximal Help Bob find out the maximum possible perimeter of a bargaining table for his office ,"[""#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main(){\n   \n    int n,m;\n    cin>>n>>m;\n    int a[50][50];\n    int b[50][50];\n    char ch;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            cin>>ch;\n            a[i][j]=ch-'0';\n            b[i][j]=a[i][j];\n        }\n    }\n    for(int i=1; i<m; i++){\n        b[0][i]+=b[0][i-1];\n    }\n    for(int i=1; i<n; i++){\n        b[i][0]+=b[i-1][0];\n    }\n    for(int i=1; i<n; i++){\n        for(int j=1; j<m; j++){\n            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n        }\n    }\n    int mx=0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            for(int x=i; x<n; x++){\n                for(int y=j; y<m; y++){\n                    int t=b[x][y];\n                    if(i-1>=0){\n                        t-=b[i-1][y];\n                    }\n                    if(j-1>=0){\n                        t-=b[x][j-1];\n                    }\n                    if(i-1>=0 && j-1>=0){\n                        t+=b[i-1][j-1];\n                    }\n                    if(t==0){\n                        mx=max(mx,2*(x-i+1+y-j+1));\n                    }\n                }\n            }\n        }\n    }\n    cout<<mx;\n    return 0;\n}""]","['brute force', 'dp']",1500
https://codeforces.com//contest/713/problem/D,D. Animals and Puzzle,Owl Sonya gave a huge lake puzzle of size to hedgehog Filya as a birthday present Friends immediately started to assemble the puzzle but some parts of it turned out to be empty there was no picture on them Parts with picture on it are denoted by while empty parts are denoted by Rows of the puzzle are numbered from top to bottom with integers from to while columns are numbered from left to right with integers from to Animals decided to complete the picture and play with it as it might be even more fun Owl and hedgehog ask each other some queries Each query is provided by four integers which define the rectangle where stands for the coordinates of the up left cell of the rectangle while stands for the coordinates of the bottom right cell The answer to the query is the size of the maximum consisting of picture parts only only parts denoted by and located fully inside the query rectangle Help Sonya and Filya answer queries ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, Q, lg[1009];\nchar sir[3009];\nshort dp[1002][1002][10][10];\n\nint get_ma (int a1, int b1, int a2, int b2)\n{\n    int p = lg[a2 - a1 + 1], q = lg[b2 - b1 + 1], x = a2 - (1 << p) + 1, y = b2 - (1 << q) + 1;\n    return max (dp[a1][b1][p][q], max (dp[a1][y][p][q], max (dp[x][b1][p][q], dp[x][y][p][q])));\n}\n\nint main ()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nscanf (""%d %d\\n"", &N, &M);\nfor (int i=1; i<=N; i++)\n{\n    gets (sir + 1);\n    for (int j=1; j<=M; j++)\n    {\n        bool curr = sir[2 * j - 1] - \'0\';\n        if (curr) dp[i][j][0][0] = 1 + min (dp[i - 1][j][0][0], min (dp[i - 1][j - 1][0][0], dp[i][j - 1][0][0]));\n        else dp[i][j][0][0] = 0;\n    }\n}\nfor (int i=2; i<=N || i<=M; i++)\n    lg[i] = lg[i >> 1] + 1;\nfor (int i=0; (1 << i) <= N; i++)\n    for (int j=0; (1 << j) <= M; j++)\n        if (i + j > 0)\n        {\n            if (i > 0)\n            {\n                for (int x=1; x + (1 << i) - 1 <= N; x ++)\n                    for (int y=1; y + (1 << j) - 1 <= M; y++)\n                        dp[x][y][i][j] = max (dp[x][y][i - 1][j], dp[x + (1 << (i - 1))][y][i - 1][j]);\n            }\n            else\n            {\n                for (int x=1; x + (1 << i) - 1 <= N; x ++)\n                    for (int y=1; y + (1 << j) - 1 <= M; y++)\n                        dp[x][y][i][j] = max (dp[x][y][i][j - 1], dp[x][y + (1 << (j - 1))][i][j - 1]);\n            }\n        }\nscanf (""%d"", &Q);\nwhile (Q --)\n{\n    int a1, b1, a2, b2, p = 1, u, ras = 0;\n    scanf (""%d %d %d %d"", &a1, &b1, &a2, &b2), u = min (a2 - a1 + 1, b2 - b1 + 1);\n    while (p <= u)\n    {\n        int mij = (p + u) >> 1;\n        if (get_ma (a1 + mij - 1, b1 + mij - 1, a2, b2) >= mij) ras = mij, p = mij + 1;\n        else u = mij - 1;\n    }\n    printf (""%d\\n"", ras);\n}\nreturn 0;\n}\n']","['binary search', 'data structures']",2700
https://codeforces.com//contest/1677/problem/C,C. Tokitsukaze and Two Colorful Tapes,Tokitsukaze has two colorful tapes There are n distinct colors numbered 1 through n and each color appears exactly once on each of the two tapes Denote the color of the i th position of the first tape as ca i and the color of the i th position of the second tape as cb i Now Tokitsukaze wants to select each color an integer value from 1 to n distinct for all the colors After that she will put down the color values in each colored position on the tapes Denote the number of the i th position of the first tape as numa i and the number of the i th position of the second tape as numb i For example for the above picture assuming that the color red has value x 1 leq x leq n it appears at the 1 st position of the first tape and the 3 rd position of the second tape so numa 1 numb 3 x Note that each color i from 1 to n should have a value and the same color which appears in both tapes has the same value After labeling each color the beauty of the two tapes is calculated as sum i 1 n numa i numb i Please help Tokitsukaze to find the highest possible beauty ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi p=readvi(n,-1);\n\tvi q=readvi(n,-1);\n\tunionfind uf(n);\n\trep(i,n)uf.unite(p[i],q[i]);\n\tint odd=0;\n\tvi ls;\n\trep(i,n)if(uf.find(i)==i){\n\t\tint v=uf.sz(i);\n\t\todd+=v%2;\n\t\tls.pb(v/2);\n\t}\n\tint rem=(n-odd)/2;\n\tint ans=0;\n\trep(i,rem){\n\t\tans+=(n-1-i*2)*2;\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']",1900
https://codeforces.com//contest/1703/problem/A,A. YES or YES ,There is a string s of length 3 consisting of uppercase and lowercase English letters Check if it is equal to without quotes where each letter can be in any case For example are all allowable ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""./debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""./input.txt""); ofstream cout(""output.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n    fstart;\n\n    int T; cin >> T;\n    while (T--) {\n        string s; cin >> s;\n        char ok = (s[0] == \'Y\' || s[0] == \'y\');\n        ok &= (s[1] == \'E\' || s[1] == \'e\');\n        ok &= (s[2] == \'s\' || s[2] == \'S\');\n        cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n\n\n    }\n\n    finish;\n}\n']","['brute force', 'implementation', 'strings']",800
https://codeforces.com//contest/1879/problem/E,E. Interactive Game with Coloring,You may use in C in Java in Python or in Pascal to flush the output If you use some other programming language consult its documentation You may also refer to the guide on interactive problems https codeforces com blog entry 45307 You are given a tree on n vertices vertex 1 is the root of the tree For every i in 2 n the parent of the i th vertex is p i and p i i You have to color all edges of the tree using the such that you can win the game on that tree every edge should be painted into exactly one color The game we re going to play will be conducted as follows After you paint the edges and print their colors the jury will place a chip into one of the vertices of the tree except for the root Your goal is to move this chip to the root in exactly d moves where d is the distance from the root to that vertex the distance is equal to the number of edges on the path If the chip reaches the root in d moves you win Otherwise you lose The jury won t tell you where the chip is located You won t even know the value of d in advance However at the start of each move you will be told how many edges of each color are incident to the current vertex this includes both the edge leading up the tree and the edges leading away from the root You have to choose one of these colors and the chip will be moved along the edge of the chosen color if there are multiple edges with that color incident to the current vertex the jury gets to choose one of them After the chip is moved you will be told the same information about the current vertex again and the game continues until you either reach the root or you make d moves without reaching the root It means that both the starting vertex and the current vertex are and may change on the run depending on the output of your program However the state of the game will always be consistent with the information you are given ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    int dep[N]; F0R(i, N) dep[i] = 0;\n    int deg[N]; F0R(i, N) deg[i] = 0;\n    int rt[N]; F0R(i, N) rt[i] = 0;\n    int cap = 0;\n    FOR(i, 1, N) {\n        int X; cin >> X; X--;\n        dep[i] = dep[X] + 1;\n        deg[i]++; deg[X]++;\n        ckmax(cap, dep[i]);\n        if (X == 0) {\n            rt[i] = i;\n        } else rt[i] = rt[X];\n    }\n    if (cap == 1) {\n        cout << 1 << endl;\n        FOR(i, 1, N) {\n            cout << 1 << "" "";\n        }\n        cout << endl;\n        while (true) {\n            int X; cin >> X;\n            if (X != 0) return;\n            cin >> X;\n            cout << 1 << endl;\n        }\n    }\n    map<int, int> pa;\n    bool ok = true;\n    FOR(i, 1, N) {\n        if (deg[i] == 2) {\n            if (!pa.count(rt[i])) pa[rt[i]] = dep[i]%2;\n            if (pa[rt[i]] != dep[i]%2) ok = false;\n        }\n    }\n    if (ok) {\n        cout << 2 << endl;\n        FOR(i, 1, N) {\n            int val = dep[i] % 2;\n            if (val == 0) val = 2;\n            if (pa[rt[i]] == 0) val = 3 - val;\n            cout << val << "" "";\n        }\n        cout << endl;\n        while (true) {\n            int X; cin >> X;\n            if (X != 0) return;\n            int A, B; cin >> A >> B;\n            if (A == 1) {\n                cout << 1 << endl;\n            } else {\n                cout << 2 << endl;\n            }\n        }\n    }\n    cout << 3 << endl;\n    FOR(i, 1, N) {\n        int val = dep[i] % 3;\n        if (val == 0) val = 3;\n        cout << val << "" "";\n    }\n    cout << endl;\n    assert(cap >= 3);\n    while (true) {\n        int X; cin >> X;\n        if (X != 0) return;\n        int A[3]; F0R(i, 3) A[i] = 0;\n        F0R(i, min(cap, 3)) cin >> A[i];\n        int cnt = 0;\n        F0R(i, min(cap, 3)) cnt += A[i];\n        F0R(i, 3) {\n            if (A[i] == cnt) {\n                cout << i+1 << endl;\n                goto done;\n            }\n        }\n        F0R(i, 3) {\n            if (A[i] == 0) {\n                cout << (i+1)%3 + 1 << endl;\n                goto done;\n            }\n        }\n        done:\n        ;\n    }\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']","['brute force', 'constructive algorithms', 'dfs and similar', 'graphs', 'implementation', 'interactive', 'trees']",2400
https://codeforces.com//contest/1687/problem/D,D. Cute number,Ran is especially skilled in computation and mathematics It is said that she can do unimaginable calculation work in an instant Ran Yakumo is a cute girl who loves creating cute Maths problems Let f x be the minimal square number greater than x and g x be the maximal square number less than or equal to x For example f 1 f 2 g 4 g 8 4 A positive integer x is if x g x f x x For example 1 5 11 are cute integers while 3 8 15 are not Ran gives you an array a of length n She wants you to find the smallest non negative integer k such that a i k is a cute number for any element of a ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint a[N];\nint n;\nint jmp[N];\n\nint myJump(int v, int x) {\n\tif (jmp[v] != v) return jmp[v] = myJump(jmp[v], x);\n\tif (v == n - 1 || a[v + 1] - a[v] > x) return v;\n\treturn jmp[v] = myJump(v + 1, x);\n}\n\nll mySqrt(ll x) {\n\tll y = (ll)sqrt(x);\n\twhile(y * y < x) y++;\n\twhile(y * y > x) y--;\n\treturn y;\n}\nvoid solve(ll x, ll y, ll &L, ll &R) {\n\tll z = x + L;\n\tll k = mySqrt(z);\n\tif (k * k + k < z) k++;\n\tL = max(L, k * k - x);\n\tR = min(R, k * k + k - y);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tjmp[i] = i;\n\t}\n\tfor (ll k = 1;; k++) {\n\t\tll L = k * k - a[0], R = k * k + k - a[0];\n\t\tif (R < 0) continue;\n\t\tif (L < 0) L = 0;\n\t\tint v = 0;\n\t\twhile(L <= R && v < n) {\n\t\t\tint u = myJump(v, k);\n\t\t\tsolve(a[v], a[u], L, R);\n\t\t\tv = u + 1;\n\t\t}\n\t\tif (L <= R) {\n\t\t\tprintf(""%lld\\n"", L);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","['binary search', 'brute force', 'data structures', 'dsu', 'implementation', 'math']",2900
https://codeforces.com//contest/447/problem/B,B. DZY Loves Strings,DZY loves collecting special strings which only contain lowercase letters For each lowercase letter DZY knows its value For each special string is the length of the string he represents its value with a function where Now DZY has a string He wants to insert lowercase letters into this string in order to get the largest possible value of the resulting string Can you help him calculate the largest possible value he could get ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar ch;\n\nvoid read(int &x)\n{\n\tx=0;\n\tch=getchar();\n\twhile (ch<=32) ch=getchar();\n\twhile (ch>32) x=x*10+ch-48,ch=getchar();\n}\n\nchar a[1005];\nint w[30];\n\nlong long getsum(int l,int r)\n{\n\treturn 1LL*(r-l+1)*(l+r)/2LL;\n}\n\nint main()\n{\n\tscanf(""%s"",a+1);\n\tint n=strlen(a+1);\n\tint k;\n\tread(k);\n\tint i;\n\tint ma=0;\n\tfor (i=1;i<=26;i++) {\n\t\tread(w[i]);\n\t\tif (w[i]>ma) ma=w[i];\n\t}\n\tlong long sum=0;\n\tlong long ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tsum+=1LL*i*w[a[i]-\'a\'+1];\n\t}\n\tans=sum+getsum(n+1,n+k)*ma;\n\tprintf(""%I64d\\n"",ans);\n}']","['greedy', 'implementation']",1000
https://codeforces.com//contest/155/problem/B,B. Combination,Ilya plays a card game by the following rules A player has several cards Each card contains two non negative integers inscribed one at the top of the card and one at the bottom At the beginning of the round the player chooses one of his cards to play it If the top of the card contains number and the bottom contains number then when the player is playing the card he gets points and also gets the opportunity to play additional cards After the playing the card is discarded More formally let s say that there is a counter of the cards that can be played At the beginning of the round the counter equals one When a card is played the counter decreases by one for the played card and increases by the number which is written at the bottom of the card Then the played card is discarded If after that the counter is not equal to zero the player gets the opportunity to play another card from the remaining cards The round ends when the counter reaches zero or the player runs out of cards Of course Ilya wants to get as many points as possible Can you determine the maximum number of points he can score provided that you know his cards ,"['#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    vector<pair<int, int> > v;\n    for (int i=0; i < n; i++) {\n        int a, b; cin >> a >> b;\n        v.push_back(make_pair(b, a));\n    }\n    sort(v.rbegin(), v.rend());\n    int pt = 0, count = 1;\n    for (int i=0; i < n; i++) {\n        int b = v[i].first, a = v[i].second;\n        pt += a;\n        count += b-1;\n        if (count == 0) break;\n    }\n    cout << pt << endl;\n\treturn 0;\n}\n']","['greedy', 'sortings']",1100
https://codeforces.com//contest/1766/problem/D,D. Lucky Chains,Let s name a pair of positive integers x y if the greatest common divisor of them is equal to 1 gcd x y 1 Let s define a induced by x y as a sequence of pairs x y x 1 y 1 x 2 y 2 dots x k y k for some integer k ge 0 The of the chain is the number of pairs it consists of or k 1 Let s name such chain if all pairs in the chain are lucky You are given n pairs x i y i Calculate for each pair the length of the longest lucky chain induced by this pair Note that if x i y i is not lucky itself the chain will have the length 0 ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 10000000;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  vector<int> p(MAX, -1);\n  for (int i = 2; i < MAX; i++){\n    if (p[i] == -1){\n      for (int j = i * 2; j < MAX; j += i){\n        p[j] = i;\n      }\n    }\n  }\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    int x, y;\n    cin >> x >> y;\n    if (gcd(x, y) > 1){\n      cout << 0 << endl;\n    } else if (y == x + 1){\n      cout << -1 << endl;\n    } else {\n      int d = y - x;\n      vector<int> f;\n      while (p[d] != -1){\n        f.push_back(p[d]);\n        d /= p[d];\n      }\n      if (d > 1){\n        f.push_back(d);\n      }\n      sort(f.begin(), f.end());\n      f.erase(unique(f.begin(), f.end()), f.end());\n      int ans = MAX;\n      for (int a : f){\n        ans = min(ans, a - x % a);\n      }\n      cout << ans << ""\\n"";\n    }\n  }\n}']","['math', 'number theory']",1600
https://codeforces.com//contest/353/problem/B,B. Two Heaps,Valera has cubes each cube contains an integer from to He arbitrarily chooses cubes and puts them in the first heap The remaining cubes form the second heap Valera decided to play with cubes During the game he takes a cube from the first heap and writes down the number it has Then he takes a cube from the second heap and write out its two digits near two digits he had written to the right of them In the end he obtained a single fourdigit integer the first two digits of it is written on the cube from the first heap and the second two digits of it is written on the second cube from the second heap Valera knows arithmetic very well So he can easily count the number of distinct fourdigit numbers he can get in the game The other question is how to split cubes into two heaps so that this number the number of distinct fourdigit integers Valera can get will be as large as possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nint poc[100];\n\nint main() {\n    cin.sync_with_stdio(0);\n    int N,a;\n    cin >> N;\n    vector<int> V(2*N);\n    vector< vector<int> > pos(100);\n    for(int i =0; i < 2*N; i++) {\n        cin >> a;\n        V[i] =a;\n        pos[a].push_back(i);\n        poc[a]++;}\n    \n    int ansA =0, ansB =0;\n    vector<int> S(2*N);\n    for(int i =0; i < 100; i++) if(poc[i] > 1) {\n        ansA++, ansB++;\n        S[pos[i][0]] =0;\n        S[pos[i][1]] =1;}\n    for(int i =0; i < 100; i++) if(poc[i] == 1) {\n        if(ansA < ansB) {ansA++; S[pos[i][0]] =0;}\n        else {ansB++; S[pos[i][0]] =1;}}\n    cout << ansA*ansB << ""\\n"";\n\n    for(int i =0; i < 100; i++) for(int j =2; j < poc[i]; j++) {\n        if(ansA < N) {ansA++; S[pos[i][j]] =0;}\n        else {ansB++; S[pos[i][j]] =1;}}\n    for(int i =0; i < 2*N; i++) cout << S[i]+1 << ((i == 2*N-1)?""\\n"":"" "");\n    return 0;}\n']","['combinatorics', 'constructive algorithms', 'greedy', 'implementation', 'math', 'sortings']",1900
https://codeforces.com//contest/914/problem/G,G. Sum the Fibonacci,You are given an array of non negative integers A 5 tuple of integers is said to be valid if it satisfies the following conditions for some integer Here is the bitwise OR is the bitwise AND and is the bitwise XOR operation Find the sum of over all valid 5 tuples where is the th Fibonnaci number Since answer can be is huge output it modulo ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int P=1000000007;\ninline int Pow(int a,int b){\n\tint c=1;\n\tfor(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;\n\treturn c;\n}\ninline void FWT(int *A,int f,int N){\n    int p2=Pow(2,P-2);\n    for(int i=1;i<N;i<<=1)\n    for(int j=0;j<N;j+=(i<<1))\n    for(int k=0;k<i;k++){\n        int x0=A[j+k];int x1=A[i+j+k];\n        if(f==0){\n            A[j+k]=(x0-x1+P)%P;\n            A[i+j+k]=(x0+x1)%P;\n        }\n        else{\n            A[j+k]=(x0+x1)*1ll*p2%P;\n            A[i+j+k]=(x1-x0)*1ll*p2%P;\n            if(A[i+j+k]<0)A[i+j+k]+=P;\n        }\n    }\n}\nconst int N=1<<17;\nint cnt[N];\nint ss;\nint n=17;\nint f[N][18];\nint bit[N];\nint gt[18];\nint p1[N];\nint p2[N];\n\nint p3[N];\n\nint fib[N];\nvoid tr(int *a){\n\trep(i,0,n-1)per(S,(1<<n)-1,0)if(!(S&(1<<i)))a[S]=(a[S]+a[S^(1<<i)])%P;\n}\nvoid ntr(int *a){\n\tper(i,n-1,0)rep(S,0,(1<<n)-1)if(!(S&(1<<i)))a[S]=(a[S]+P-a[S^(1<<i)])%P;\n}\nint main(){\n\tscanf(""%d"",&ss);\n\trep(i,1,(1<<n)-1)bit[i]=bit[i>>1]+(i&1);\n\tfib[0]=0;fib[1]=1;\n\trep(i,2,(1<<n)-1)fib[i]=(fib[i-1]+fib[i-2])%P;\n\twhile(ss--){\n\t\tint x;scanf(""%d"",&x);\n\t\tcnt[x]++;\n\t}\n\trep(i,0,(1<<n)-1){\n\t\tf[i][bit[i]]=cnt[i];\n\t}\n\trep(i,0,n-1)rep(S,0,(1<<n)-1)if(S&(1<<i))rep(j,0,n)f[S][j]=(f[S][j]+f[S^(1<<i)][j])%P;\n\trep(S,0,(1<<n)-1){\n\t\tmemset(gt,0,sizeof gt);\n\t\trep(i,0,n)rep(j,0,n-i)gt[i+j]=(gt[i+j]+f[S][i]*1ll*f[S][j])%P;\n\t\trep(i,0,n)f[S][i]=gt[i];\n\t}\n\tper(i,n-1,0)per(S,(1<<n)-1,0)if(S&(1<<i))rep(j,0,n)f[S][j]=(f[S][j]+P-f[S^(1<<i)][j])%P;\n\trep(S,0,(1<<n)-1)p1[S]=f[S][bit[S]]*1ll*fib[S]%P;\n\trep(S,0,(1<<n)-1)p2[S]=cnt[S]*1ll*fib[S]%P;\n\n\trep(S,0,(1<<n)-1)p3[S]=cnt[S];\n\n\tFWT(p3,0,1<<n);\n\trep(S,0,(1<<n)-1)p3[S]=p3[S]*1ll*p3[S]%P;\n\tFWT(p3,1,1<<n);\n\trep(S,0,(1<<n)-1)p3[S]=p3[S]*1ll*fib[S]%P;\n\n\ttr(p1);tr(p2);tr(p3);\n\trep(i,0,(1<<n)-1)p1[i]=(p1[i]*1ll*p2[i]%P)*1ll*p3[i]%P;\n\tntr(p1);\n\tint ans=0;\n\trep(i,0,n-1)ans=(ans+p1[1<<i])%P;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n\n\n\n\n']","['bitmasks', 'divide and conquer', 'dp', 'fft', 'math']",2600
https://codeforces.com//contest/219/problem/E,E. Parking Lot,A parking lot in the City consists of parking spaces standing in a line The parking spaces are numbered from 1 to from left to right When a car arrives at the lot the operator determines an empty parking space for it For the safety s sake the chosen place should be located as far from the already occupied places as possible That is the closest occupied parking space must be as far away as possible If there are several such places then the operator chooses the place with the minimum index from them If all parking lot places are empty then the car gets place number We consider the distance between the th and the th parking spaces equal to meters You are given the parking lot records of arriving and departing cars in the chronological order For each record of an arriving car print the number of the parking lot that was given to this car ,"['#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nconst int maxn  =   200005;\nconst int maxid =   1000005;\n\nstruct node\n{\n    int maxlen;\n    int sl,sr,len;\n}tree[maxn*4];\nint position[maxid],n,m;\n\ninline node merge(const node &a,const node &b)\n{\n    node ret;\n    ret.maxlen=max(a.maxlen,b.maxlen);\n    ret.maxlen=max(ret.maxlen,a.sr+b.sl);\n    ret.sl=a.sl;\n    if (a.sl==a.len) ret.sl+=b.sl;\n    ret.sr=b.sr;\n    if (b.sr==b.len) ret.sr+=a.sr;\n    ret.len=a.len+b.len;\n    return ret;\n}\n\ninline void build(int num,int l,int r)\n{\n    tree[num].maxlen=tree[num].sl=tree[num].sr=tree[num].len=r-l+1;\n    if (l==r) return;\n    int mid=(l+r)/2;\n    build(num*2,l,mid);\n    build(num*2+1,mid+1,r);\n}\n\ninline void insert(int num,int l,int r,int pos,int delta)\n{\n    if (l==r){\n        if (delta==1){\n            tree[num].maxlen=tree[num].sl=tree[num].sr=0;\n        }else{\n            tree[num].maxlen=tree[num].sl=tree[num].sr=1;\n        }\n        return;\n    }\n    int mid=(l+r)/2;\n    if (pos<=mid) insert(num*2,l,mid,pos,delta);\n    else insert(num*2+1,mid+1,r,pos,delta);\n    tree[num]=merge(tree[num*2],tree[num*2+1]);\n}\n\ninline int query(int num,int l,int r,int tar)\n{\n    if (l==r){\n        return l;\n    }\n    if (l==1 && tree[num].sl>=tar) return 1;\n    int mid=(l+r)/2;\n    if ((tree[num*2].maxlen+1)>=tar*2){\n        return query(num*2,l,mid,tar);\n    }\n    if ((tree[num*2].sr+tree[num*2+1].sl)+1>=tar*2){\n        return (mid-tree[num*2].sr+tar);\n    }\n    return query(num*2+1,mid+1,r,tar);\n}\n\nint main()\n{\n    scanf(""%d%d"",&n,&m);\n    build(1,1,n);\n    for (int i=0;i<m;++i){\n        int t,id;\n        scanf(""%d%d"",&t,&id);\n        if (t==1){\n            int len=(tree[1].maxlen+1)/2;\n            len=max(tree[1].sl,len);\n            len=max(tree[1].sr,len);\n            \n            int pos=query(1,1,n,len);\n            position[id]=pos;\n            insert(1,1,n,pos,1);\n            printf(""%d\\n"",pos);\n        }else{\n            int pos=position[id];\n            insert(1,1,n,pos,-1);\n        }\n    }\n    \n    return 0;\n}\n']",['data structures'],2200
https://codeforces.com//contest/492/problem/D,D. Vanya and Computer Game,Vanya and his friend Vova play a computer game where they need to destroy monsters to pass a level Vanya s character performs attack with frequency hits per second and Vova s character performs attack with frequency hits per second Each character spends fixed time to raise a weapon and then he hits the time to raise the weapon is seconds for the first character and seconds for the second one The th monster dies after he receives hits Vanya and Vova wonder who makes the last hit on each monster If Vanya and Vova make the last hit at the same time we assume that both of them have made the last hit ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nvoid print(int x){\n\tif(x==0)\n\t\tcout << ""Vanya"" << endl;\n\telse if(x==1)\n\t\tcout << ""Both"" << endl;\n\telse\n\t\tcout << ""Vova"" << endl;\n}\nint main(){\n\tll n, x, y, sum = 0;\n\tcin >> n >> x >> y;\n\tll dx = 1, dy = 1;\n\tvector<int> v;\n\twhile(dx <= x && dy <= y){\n\t\tif(dx * y < dy * x){\n\t\t\tv.push_back(0);\n\t\t\tdx++;\n\t\t} else if(dx * y == dy * x){\n\t\t\tv.push_back(1);\n\t\t\tv.push_back(1);\n\t\t\tdx++, dy++;\n\t\t} else {\n\t\t\tv.push_back(2);\n\t\t\tdy++;\n\t\t}\n\t}\n\twhile(dx <= x){\n\t\tdx++, v.push_back(0);\n\t}\n\twhile(dy <= y){\n\t\tdy++, v.push_back(2);\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tll q;\n\t\tcin >> q;\n\t\tq %= v.size();\n\t\tif(q == 0)\n\t\t\tprint(v.back());\n\t\telse\n\t\t\tprint(v[q-1]);\n\t}\n\treturn 0;\n}']","['binary search', 'implementation', 'math', 'sortings']",1800
https://codeforces.com//contest/1279/problem/E,E. New Year Permutations, A permutation of length n is an array of n integers such that every integer from 1 to n appears in it exactly once An element y of permutation p is reachable from element x if x y or p x y or p p x y and so on The of a permutation p is defined as follows firstly we have a permutation p all elements of which are and an empty list l Then we do the following while there is at least one element in p we find the leftmost such element list all elements that are reachable from it mark all of these elements then cyclically shift the list of those elements so that the maximum appears at the first position and add this list of l After all elements are marked l is the result of this decomposition For example if we want to build a decomposition of p 5 4 2 3 1 7 8 6 we do the following initially p 5 4 2 3 1 7 8 6 bold elements are marked l the leftmost unmarked element is 5 5 and 1 are reachable from it so the list we want to shift is 5 1 there is no need to shift it since maximum is already the first element p textbf 5 4 2 3 textbf 1 7 8 6 l 5 1 the leftmost unmarked element is 4 the list of reachable elements is 4 2 3 the maximum is already the first element so there s no need to shift it p textbf 5 textbf 4 textbf 2 textbf 3 textbf 1 7 8 6 l 5 1 4 2 3 the leftmost unmarked element is 7 the list of reachable elements is 7 8 6 we have to shift it so it becomes 8 6 7 p textbf 5 textbf 4 textbf 2 textbf 3 textbf 1 textbf 7 textbf 8 textbf 6 l 5 1 4 2 3 8 6 7 all elements are marked so 5 1 4 2 3 8 6 7 is the result The of a permutation is defined as follows we build the decomposition of this permutation then we sort all lists in decomposition in ascending order of the first elements we don t swap the elements in these lists only the lists themselves then we concatenate the lists into one list which becomes a new permutation For example the of p 5 4 2 3 1 7 8 6 is built as follows the decomposition is 5 1 4 2 3 8 6 7 after sorting the decomposition it becomes 4 2 3 5 1 8 6 7 4 2 3 5 1 8 6 7 is the result of the transformation We call a permutation if the result of its transformation is the same as the permutation itself For example 4 3 1 2 8 5 6 7 is a good permutation and 5 4 2 3 1 7 8 6 is bad since the result of transformation is 4 2 3 5 1 8 6 7 Your task is the following given n and k find the k th lexicographically good permutation of length n ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n \nconst int N =50;\nint dsu[N];\n \nint get(int v) {\n  if (v == dsu[v]) {\n    return v;\n  } else {\n    return dsu[v] = get(dsu[v]);\n  }\n}\n \nvoid uni(int u, int v) {\n  dsu[get(u)] = get(v);\n}\n \nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  auto solve = [&] () {\n    int n;\n    ll k;\n    cin >> n >> k;\n    vector <ll> fact(n + 1);\n    fact[0] = 1;\n    ll lim = k + (ll) (1e18);\n    auto mul = [&] (ll a, ll b) {\n      if (a * (long double) b <= lim)\n        return a * b;\n      else\n        return lim;\n    };\n    for (int i = 1; i <= n; i++) {\n      fact[i] = mul(fact[i - 1], i);\n    }\n    vector <ll> decomps(n + 1);\n    vector <ll> values(n + 1);\n    for (int i = 1; i <= n; i++) {\n      if (i == 1) {\n        values[i] = 1;\n      } else {\n        values[i] = fact[i - 2];\n      }\n    }\n    decomps[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j < i; j++) {\n        decomps[i] += mul(decomps[j], values[i - j]);\n        decomps[i] = min(decomps[i], lim);\n      }\n    }\n    k--;\n    if (decomps[n] <= k) {\n      cout << -1 << \'\\n\';\n      return;\n    }\n    auto gen_cyclic = [&] (int len, ll id, int shift) {\n      for (int i = 0; i < len; i++) {\n        dsu[i] = i;\n      }\n      set <int> q;\n      int pths = len - 1;\n      vector <int> ans;\n      for (int i = 0; i < len; i++) {\n        if (i == 0) {\n          q.insert(len - 1);\n          uni(i, len - 1);\n          ans.push_back(len - 1);\n        } else {\n          for (int j = 0; j < len; j++) {\n            if (!q.count(j) && (get(i) != get(j) || i == len - 1)) {\n              int go = pths;\n              if (values[go] <= id) {\n                id -= values[go];\n              } else {\n                pths--;\n                ans.push_back(j);\n                q.insert(j);\n                uni(i, j);\n                break;\n              }\n            }\n          }\n        }\n      }\n      for (int x : ans) {\n        cout << shift + x + 1 << \' \';\n      }\n    };\n    int x = 0;\n    while (x < n) {\n      for (int len = 1; len <= n - x; len++) {\n        ll value = mul(values[len], decomps[n - x - len]);\n        if (value <= k) {\n          k -= value;\n        } else {\n          ll go = k / decomps[n - x - len];\n          gen_cyclic(len, go, x);\n          k %= decomps[n - x - len];\n          x += len;\n          break;\n        }\n      }\n    }\n    cout << \'\\n\';\n  };\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n']","['combinatorics', 'dp']",2700
https://codeforces.com//contest/1882/problem/B,B. Sets and Union,You have n sets of integers S 1 S 2 ldots S n We call a set S if it is possible to choose some possibly none of the sets S 1 S 2 ldots S n so that S is equal to their union dagger If you choose none of S 1 S 2 ldots S n their union is an empty set Find the maximum number of elements in an attainable S such that S neq S 1 cup S 2 cup ldots cup S n dagger The union of sets A 1 A 2 ldots A k is defined as the set of elements present in at least one of these sets It is denoted by A 1 cup A 2 cup ldots cup A k For example 2 4 6 cup 2 3 cup 3 6 7 2 3 4 6 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=505;\nint n,m,T,ans,flg;\nint a[maxn],vis[maxn][maxn],hav[maxn],tmp[maxn];\nstring s;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n),ans=0;\n\t\tfor(int i=1,k,x;i<=n;i++){\n\t\t\tscanf(""%d"",&k);\n\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\tscanf(""%d"",&x),vis[i][x]=1,hav[x]=1;\n\t\t}\n\t\tfor(int v=1;v<=50;v++)\n\t\t\tif(hav[v]){\n\t\t\t\tfor(int i=1;i<=50;i++)\n\t\t\t\t\ttmp[i]=0;\n\t\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\t\tif(vis[i][v]==0)\n\t\t\t\t\t\tfor(int j=1;j<=50;j++)\n\t\t\t\t\t\t\ttmp[j]|=vis[i][j];\n\t\t\t\tint res=0;\n\t\t\t\tfor(int j=1;j<=50;j++)\n\t\t\t\t\tres+=tmp[j];\n\t\t\t\tans=max(ans,res);\n\t\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=50;j++)\n\t\t\t\tvis[i][j]=0;\n\t\tfor(int i=1;i<=50;i++)\n\t\t\thav[i]=0;\n\t}\n\treturn 0;\n}\n']","['bitmasks', 'brute force', 'constructive algorithms', 'greedy']",1300
https://codeforces.com//contest/1934/problem/C,C. Find a Mine,You are given a grid with n rows and m columns The coordinates x y represent the cell on the grid where x 1 leq x leq n is the row number counting from the top and y 1 leq y leq m is the column number counting from the left It is guaranteed that there are exactly 2 mines in the grid at cells denoted as x 1 y 1 and x 2 y 2 You are allowed to make no more than 4 queries to the interactor and after these queries you need to provide the location of In each query you can choose any grid cell x y and in return you will receive the minimum Manhattan distance from both the mines to the chosen cell i e you will receive the value min x x 1 y y 1 x x 2 y y 2 Your task is to determine the location of one of the mines after making the queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n//#define endl \'\\n\'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nint query(int x, int y){\n    cout << ""? "" << x << \' \' << y << endl;\n    int ret; cin >> ret;\n    return ret;\n}\n\nsigned main(){\n    //IOS;\n\n    int T; cin >> T;\n    while(T--){\n        int n, m; cin >> n >> m;\n\n        int ret1, ret2, ret3, ret4, x1, y1, x2, y2;\n        ret1 = query(1, 1);\n        if(ret1 + 1 <= m) ret2 = query(1, ret1 + 1), x1 = 1 + ret2 / 2, y1 = ret1 + 1 - ret2 / 2;\n        else ret2 = query(ret1 + 2 - m, m), x1 = ret1 + 2 - m + ret2 / 2, y1 = m - ret2 / 2;\n        if(ret1 + 1 <= n) ret3 = query(ret1 + 1, 1), x2 = ret1 + 1 - ret3 / 2, y2 = 1 + ret3 / 2;\n        else ret3 = query(n, ret1 + 2 - n), x2 = n - ret3 / 2, y2 = ret1 + 2 - n + ret3 / 2;\n\n        if(x1 <= 0 || y1 <= 0 || x1 > n || y1 > m || query(x1, y1) != 0) cout << ""! "" << x2 << \' \' << y2 << endl;\n        else cout << ""! "" << x1 << \' \' << y1 << endl;\n        \n    }\n\n}']","['binary search', 'constructive algorithms', 'geometry', 'greedy', 'interactive', 'math']",1700
https://codeforces.com//contest/1601/problem/A,A. Array Elimination,You are given array a 1 a 2 ldots a n consisting of non negative integers Let s define operation of elimination with integer parameter k 1 leq k leq n as follows Choose k distinct array indices 1 leq i 1 i 2 ldots i k le n Calculate x a i 1 a i 2 ldots a i k where denotes the bitwise AND operation notes section contains formal definition Subtract x from each of a i 1 a i 2 ldots a i k all other elements remain untouched Find all possible values of k such that it s possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k It can be proven that exists at least one possible k for any array a Note that you ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[200005], c[35];\nint gcd(int x, int y)\n{\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nvoid solve()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%d"", &a[i]);\n\tmemset(c, 0, sizeof(c));\n\trep(i, n) rep(j, 30) if(a[i] >> j & 1) c[j] ++;\n\tint r = 0;\n\trep(i, 30) r = gcd(r, c[i]);\n\trep1(i, n) if(r % i == 0) printf(""%d "", i); printf(""\\n"");\n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']","['bitmasks', 'greedy', 'math', 'number theory']",1300
https://codeforces.com//contest/1761/problem/E,E. Make It Connected,You are given a simple undirected graph consisting of n vertices The graph doesn t contain self loops there is at most one edge between each pair of vertices Your task is simple make the graph connected You can do the following operation any number of times possibly zero Choose a vertex u arbitrarily For each vertex v satisfying v ne u in the graph individually if v is adjacent to u remove the edge between u and v otherwise add an edge between u and v Find the minimum number of operations required to make the graph connected Also find any sequence of operations with the minimum length that makes the graph connected ,"['/**\n *    author:  tourist\n *    created: 20.11.2022 19:01:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    vector<int> deg(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n      for (int j = 0; j < n; j++) {\n        if (s[i][j] == \'1\') {\n          deg[i] += 1;\n        }\n      }\n    }\n    vector<bool> was(n, false);\n    vector<vector<int>> all;\n    for (int st = 0; st < n; st++) {\n      if (was[st]) {\n        continue;\n      }\n      vector<int> que(1, st);\n      was[st] = true;\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int i = 0; i < n; i++) {\n          if (!was[i] && s[que[b]][i] == \'1\') {\n            was[i] = true;\n            que.push_back(i);\n          }\n        }\n      }\n      all.push_back(que);\n    }\n    if (all.size() == 1) {\n      cout << 0 << \'\\n\';\n      continue;\n    }\n    int one = -1;\n    for (auto& v : all) {\n      int sz = (int) v.size();\n      if (sz == 1) {\n        one = v[0];\n        break;\n      }\n      int cnt = 0;\n      for (int x : v) {\n        if (deg[x] == sz - 1) {\n          cnt += 1;\n        }\n      }\n      if (cnt == sz) {\n        continue;\n      }\n      if (cnt == 0) {\n        one = v.back();\n        break;\n      }\n      for (int x : v) {\n        if (deg[x] < sz - 1) {\n          one = x;\n          break;\n        }\n      }\n      break;\n    }\n    if (one != -1) {\n      cout << 1 << \'\\n\';\n      cout << one + 1 << \'\\n\';\n      continue;\n    }\n    if (all.size() > 2) {\n      cout << 2 << \'\\n\';\n      cout << all[0][0] + 1 << "" "" << all[1][0] + 1 << \'\\n\';\n      continue;\n    }\n    auto& v = (all[0].size() < all[1].size() ? all[0] : all[1]);\n    cout << v.size() << \'\\n\';\n    for (int i = 0; i < (int) v.size(); i++) {\n      cout << v[i] + 1 << "" \\n""[i == (int) v.size() - 1];\n    }\n  }\n  return 0;\n}\n']","['binary search', 'brute force', 'constructive algorithms', 'dsu', 'graphs', 'greedy', 'matrices', 'trees', 'two pointers']",2400
https://codeforces.com//contest/1398/problem/A,A. Bad Triangle,You are given an array a 1 a 2 dots a n which is sorted in non decreasing order a i le a i 1 Find three indices i j k such that 1 le i j k le n and it is to construct a non degenerate triangle a triangle with nonzero area having sides equal to a i a j and a k for example it is possible to construct a non degenerate triangle with sides 3 4 and 5 but impossible with sides 3 4 and 7 If it is impossible to find such triple report it ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nll a[N];\nint n;\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tif (a[0] + a[1] <= a[n - 1])\n\t\tprintf(""1 2 %d\\n"", n);\n\telse\n\t\tprintf(""-1\\n"");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['geometry', 'math']",800
https://codeforces.com//contest/1285/problem/C,C. Fadi and LCM,Today Osama gave Fadi an integer X and Fadi was wondering about the minimum possible value of max a b such that LCM a b equals X Both a and b should be positive integers LCM a b is the smallest positive integer that is divisible by both a and b For example LCM 6 8 24 LCM 4 12 12 LCM 2 3 6 Of course Fadi immediately knew the answer Can you be just like Fadi and find any such pair ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long x; cin >> x;\n\tvector<long long> all;\n\tfor(long long i = 2; i * i <= x; i++){\n\t\tif(x % i == 0){\n\t\t\tlong long cup = 1;\n\t\t\twhile(x % i == 0) x /= i, cup *= i;\n\t\t\tall.push_back(cup);\n\t\t}\n\t}\n\tif(x != 1) all.push_back(x);\n\tint len = all.size();\n\tlong long ans = 1ll<<60, A, B;\n\tfor(int i = 0; i < 1<<len; i++){\n\t\tlong long a = 1, b = 1;\n\t\tfor(int j = 0; j < len; j++){\n\t\t\tif((i>>j)&1) a *= all[j];\n\t\t\telse b *= all[j];\n\t\t}\n\t\tif(ans > max(a, b)) A = a, B = b;\n\t\tans = min(ans, max(a, b));\n\t}\n\tcout << A << ' ' << B << endl;\n\treturn 0;\n}\n""]","['brute force', 'math', 'number theory']",1400
https://codeforces.com//contest/202/problem/A,A. LLPS,You are given string consisting of lowercase English letters only Find its lexicographically largest palindromic subsequence We ll call a non empty string a of string where is the length of string For example strings and are subsequences of string String is than string if either and or there exists such number that and Characters in the strings are compared according to their ASCII codes For example string is lexicographically larger than string and string is lexicographically larger than string String is a if it matches string In other words a string is a palindrome if it reads the same way from left to right and from right to left For example palindromic strings are and ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#ifndef LEEWINGS_DEBUG\n#define LEEWINGS_DEBUG 0\n#endif\n\n#define debug(x) if (LEEWINGS_DEBUG) cerr << #x << "" = "" << (x) << endl\n\n#define debug_line(a, n) do {                                                \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << ""["" << #n << ""]:"" << endl;                             \\\n        for (int i = 0; i < (n); i++) cerr << (a)[i] << "" "";                 \\\n        cerr << endl;                                                        \\\n    }                                                                        \\\n} while (0)\n\n#define debug_mat(a, n, m) do {                                              \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << ""["" << #n << ""]["" << #m ""]:"" << endl;                  \\\n        for (int i = 0; i < (n); i++) {                                      \\\n            for (int j = 0; j < (m); j++) cerr << (a)[i][j] << "" "";          \\\n            cerr << endl;                                                    \\\n        }                                                                    \\\n    }                                                                        \\\n} while(0)\n\ntypedef pair<int, int> pii;\ntypedef vector<int>::const_iterator vci;\ntypedef map<int, int>::const_iterator mci;\n\nconst int INF = 0x3f3f3f3f;\nconst long long LLINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1.0/0.0f;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n\ninline int LC(int x) { return x << 1; }\ninline int RC(int x) { return (x << 1) | 1; }\ninline bool eq0(double x) { return fabs(x) < eps; }\ninline bool eq(double x, double y) { return fabs(x - y) < eps; }\ninline bool ls(double x, double y) { return x + eps < y; }\ninline bool gr(double x, double y) { return x - eps > y; }\ninline bool greq(double x, double y) { return x + eps >= y; }\ninline bool lseq(double x, double y) { return x - eps <= y; }\ninline double fmax(double x, double y) { return gr(x, y) ? x : y; }\ninline double fmin(double x, double y) { return ls(x, y) ? x : y; }\n\ntemplate<class T> inline T sqr(T x) { return x * x; }\n\nint main()\n{\n    string s;\n    cin >> s;\n    char c = *max_element(s.begin(), s.end());\n    int cnt = count(s.begin(), s.end(), c);\n    while (cnt--) cout << c;\n    cout << endl;\n\n    return 0;\n}\n\n']","['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']",800
https://codeforces.com//contest/608/problem/A,A. Saitama Destroys Hotel,Saitama accidentally destroyed a hotel again To repay the hotel company Genos has volunteered to operate an elevator in one of its other hotels The elevator is special it starts on the top floor can only move down and has infinite capacity Floors are numbered from to and elevator initially starts on floor at time The elevator takes exactly second to move down exactly floor and negligible time to pick up passengers Genos is given a list detailing when and on which floor passengers arrive Please determine how long in seconds it will take Genos to bring all passengers to floor ,"['#include <iostream>\nusing namespace std;\n\nint n, s;\n\nint main(){\n  cin >> n >> s;\n  \n  int ans=s;\n  for (int i=0; i<n; ++i){\n    int f, t;\n    cin >> f >> t;\n    ans=max(ans, f+t);\n  }\n  cout << ans << endl;\n}']","['implementation', 'math']",1000
https://codeforces.com//contest/1736/problem/B,B. Playing with GCD,You are given an integer array a of length n Does there exist an array b consisting of n 1 positive integers such that a i gcd b i b i 1 for all i 1 leq i leq n Note that gcd x y denotes the greatest common divisor GCD of integers x and y ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector<int> a(n);\n\t\tcin>>a;\n\t\tfor (i=2; i<n; i++) if (a[i-1]%gcd(a[i],a[i-2])) break;\n\t\tif (i<n) cout<<""NO\\n""; else cout<<""YES\\n"";\n\t}\n}\n']","['math', 'number theory']",1200
https://codeforces.com//contest/1547/problem/C,C. Pair Programming,Monocarp and Polycarp are learning new programming techniques Now they decided to try pair programming It s known that they have worked together on the same file for n m minutes Every minute exactly one of them made one change to the file Before they started there were already k lines written in the file Every minute exactly one of them does one of two actions adds a new line to the end of the file or changes one of its lines Monocarp worked in total for n minutes and performed the sequence of actions a 1 a 2 dots a n If a i 0 then he adds a new line to the end of the file If a i 0 then he changes the line with the number a i Monocarp performed actions strictly in this order a 1 then a 2 a n Polycarp worked in total for m minutes and performed the sequence of actions b 1 b 2 dots b m If b j 0 then he adds a new line to the end of the file If b j 0 then he changes the line with the number b j Polycarp performed actions strictly in this order b 1 then b 2 b m Restore their common sequence of actions of length n m such that all actions would be correct there should be no changes to lines that do not yet exist Keep in mind that in the common sequence Monocarp s actions should form the subsequence a 1 a 2 dots a n and Polycarp s subsequence b 1 b 2 dots b m They can replace each other at the computer any number of times Let s look at an example Suppose k 3 Monocarp first changed the line with the number 2 and then added a new line thus n 2 a 2 0 Polycarp first added a new line and then changed the line with the number 5 thus m 2 b 0 5 Since the initial length of the file was 3 in order for Polycarp to change line number 5 two new lines must be added beforehand Examples of correct sequences of changes in this case would be 0 2 0 5 and 2 0 0 5 Changes 0 0 5 2 wrong order of actions and 0 5 2 0 line 5 cannot be edited yet are not correct ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int k, n, m;\n        cin >> k >> n >> m;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        int x = 0, y = 0;\n        vector<int> ans;\n        for (int z = 0; z < n + m; z++) {\n            if (x < n && a[x] == 0) {\n                ans.push_back(0);\n                x++;\n                k++;\n            } else if (y < m && b[y] == 0) {\n                ans.push_back(0);\n                y++;\n                k++;\n            } else if (y == m || (x < n && a[x] < b[y])) {\n                if (a[x] > k) {\n                    cout << ""-1\\n"";\n                    return;\n                }\n                ans.push_back(a[x++]);\n            } else {\n                if (b[y] > k) {\n                    cout << ""-1\\n"";\n                    return;\n                }\n                ans.push_back(b[y++]);\n            }\n        }\n        for (int i : ans) {\n            cout << i << "" "";\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']","['greedy', 'two pointers']",1100
https://codeforces.com//contest/269/problem/C,C. Flawed Flow,Emuskald considers himself a master of flow algorithms Now he has completed his most ingenious program yet it calculates the maximum flow in an undirected graph The graph consists of vertices and edges Vertices are numbered from 1 to Vertices and being the source and the sink respectively However his max flow algorithm seems to have a little flaw it only finds the flow volume for each edge but not its direction Help him find for each edge the direction of the flow through this edges Note that the resulting flow should be correct maximum flow More formally You are given an undirected graph For each it s undirected edge you are given the flow volume You should direct all edges in such way that the following conditions hold for each vertex sum of of incoming edges is equal to the sum of of outcoming edges vertex with number has no incoming edges the obtained directed graph ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""C""\n\ntypedef long long ll;\ntypedef long double ld;\n\nvector<int> g[210000];\nvector<int> w[210000];\nvector<int> id[210000];\nint n,m;\n\nint in[210000];\nint ans[210000];\nset<pair<int,int> > s;\n\nint main(){\n  #ifdef LOCAL\n    freopen(TASKNAME"".in"",""r"",stdin);\n    freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n    scanf(""%d %d"",&n,&m);\n    for (int i = 0; i < m; i++){\n        int a,b,c;\n        scanf(""%d %d %d"",&a,&b,&c);\n        --a,--b;\n        in[a] += c;\n        in[b] += c;\n        g[a].pb(b);\n        g[b].pb(a);\n        w[a].pb(c);\n        w[b].pb(c);\n        id[a].pb(i+1);\n        id[b].pb(-i-1);\n    }\n\n    in[0] = 0;\n    in[n-1] = 2100000000;\n\n    memset(ans,-1,sizeof(ans));\n\n    for (int i = 0; i < n; i++){\n        assert(in[i] % 2 == 0);\n        s.insert(mp(in[i]/=2,i));\n    }\n\n    while (s.size() != 1){\n//      cerr << in[0] <<"" ""<<in[1] << "" ""<<in[2] << endl;\n        assert(s.begin()->first == 0);\n        int v = s.begin()->second;\n        s.erase(s.begin());\n        for (int i = 0; i< (int)g[v].size(); i++){\n            if (ans[abs(id[v][i])-1] == -1){\n                if (id[v][i] < 0)\n                    ans[abs(id[v][i])-1] = 1;\n                else\n                    ans[abs(id[v][i])-1] = 0;\n                s.erase(mp(in[g[v][i]],g[v][i]));\n                in[g[v][i]] -= w[v][i];\n                s.insert(mp(in[g[v][i]],g[v][i]));\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++)\n        printf(""%d\\n"",ans[i]);\n        \n\n      \n  return 0;\n}']","['constructive algorithms', 'flows', 'graphs', 'greedy']",2100
https://codeforces.com//contest/376/problem/B,B. I.O.U.,Imagine that there is a group of three friends A B and A owes B 20 rubles and B owes C 20 rubles The total sum of the debts is 40 rubles You can see that the debts are not organized in a very optimal manner Let s rearrange them like that assume that A owes C 20 rubles and B doesn t owe anything to anybody The debts still mean the same but the total sum of the debts now equals 20 rubles This task is a generalisation of a described example Imagine that your group of friends has people and you know the debts between the people Optimize the given debts without changing their meaning In other words finally for each friend the difference between the total money he should give and the total money he should take must be the same Print the minimum sum of all debts in the optimal rearrangement of the debts See the notes to the test samples to better understand the problem ,"['#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint a[1000];\n\nint main() {\n    int n, m, x, y, c;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        cin >> x >> y >> c;\n        a[x] += c;\n        a[y] -= c;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        ans += abs(a[i]);\n    }\n    cout << ans / 2 << endl;\n    return 0;\n}\n']",['implementation'],1300
https://codeforces.com//contest/14/problem/A,A. Letter,A boy Bob likes to draw Not long ago he bought a rectangular graph checked sheet with rows and columns Bob shaded some of the squares on the sheet Having seen his masterpiece he decided to share it with his elder brother who lives in Flatland Now Bob has to send his picture by post but because of the world economic crisis and high oil prices he wants to send his creation but to spend as little money as possible For each sent square of paper no matter whether it is shaded or not Bob has to pay 3 14 burles Please help Bob cut out of his masterpiece a rectangle of the minimum cost that will contain all the shaded squares The rectangle s sides should be parallel to the sheet s sides ,"['#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint n , m;\nint lef , rig , a , b;\nstring s[51];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(cin>>n>>m)\n    {\n        lef = 100 , rig = -1 , a = 100 , b = -1;\n        for(int i = 1 ; i <= n ; i++)\n        {\n            cin>>s[i];\n            s[i] = "" "" + s[i];\n            for(int j = 1 ; j <= m ; j++)\n                if(s[i][j] == \'*\')\n                {\n                    lef = min(lef , j);\n                    rig = max(rig , j);\n                    a = min(a , i);\n                    b = max(b , i);\n                }\n        }\n        for(int i = a ; i <= b ; i++)\n        {\n            for(int j = lef ; j <= rig ; j++)\n                cout<<s[i][j];\n            cout<<endl;\n        }\n        \n    }\n    return 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1296/problem/D,D. Fight with Monsters,There are n monsters standing in a row numbered from 1 to n The i th monster has h i health points hp You have your attack power equal to a hp and your opponent has his attack power equal to b hp You and your opponent are fighting these monsters Firstly you and your opponent go to the first monster and fight it till his death then you and your opponent go the second monster and fight it till his death and so on A monster is considered dead if its hp is less than or equal to 0 The fight with a monster happens in turns You hit the monster by a hp If it is dead after your hit and you both proceed to the next monster Your opponent hits the monster by b hp If it is dead after his hit and you both proceed to the next monster You have some secret technique to force your opponent to skip his turn You can use this technique at most k times for example if there are two monsters and k 4 then you can use the technique 2 times on the first monster and 1 time on the second monster but not 2 times on the first monster and 3 times on the second monster Your task is to determine the maximum number of points you can gain if you use the secret technique optimally ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nLL n,a,b,k;\nLL ans[N];\nint main()\n{\n    cin>>n>>a>>b>>k;\n    for(int i=1;i<=n;i++){\n        LL x;\n        scanf(""%lld"",&x);\n        x%=(a+b);\n        if(x==0)x=a+b;\n        if(x<=a){\n            ans[i]=0;\n            continue;\n        }\n        x-=a;\n        ans[i]=x/a+(x%a>0);\n    }\n    sort(ans+1,ans+1+n);\n    int as=0;\n    for(int i=1;i<=n;i++){\n        if(k>=ans[i]){\n            k-=ans[i];\n            as++;\n        }\n    }\n    cout<<as;\n    return 0;\n}\n/*\n*/\n']","['greedy', 'sortings']",1500
https://codeforces.com//contest/1862/problem/C,C. Flower City Fence,Anya lives in the Flower City By order of the city mayor she has to build a fence for herself The fence consists of n planks each with a height of a i meters According to the order the heights of the planks must In other words it is true that a i ge a j for all i j Anya became curious whether her fence is with respect to the diagonal In other words will she get the same fence if she lays all the planks horizontally in the same order For example for n 5 a 5 4 3 2 1 the fence is Because if all the planks are laid horizontally the fence will be 5 4 3 2 1 as shown in the diagram But for n 3 a 4 2 1 the fence is not Because if all the planks are laid horizontally the fence will be 3 2 1 1 as shown in the diagram Help Anya and determine whether her fence is ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY int\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e9)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,a[MAXN],tmp[MAXN],cnt[MAXN];\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tn=qr();For(i,1,n)a[i]=qr();\n\t\tFor(i,1,n+1)cnt[i]=0;\n\t\tif(a[1]!=n)ws(""No\\n"");\n\t\telse{\n\t\t\tFor(i,1,n)++cnt[a[i]];\n\t\t\tRof(i,n,1)cnt[i]+=cnt[i+1];\n\t\t\tbool vis=1;\n\t\t\tFor(i,1,n)vis&=(cnt[n-i+1]==a[n-i+1]);\n\t\t\tws(vis?""Yes\\n"":""No\\n"");\n\t\t}\n\t}\n    return 0;\n}']","['binary search', 'data structures', 'implementation', 'sortings']",1100
https://codeforces.com//contest/471/problem/C,C. MUH and House of Cards,Polar bears Menshykov and Uslada from the zoo of St Petersburg and elephant Horace from the zoo of Kiev decided to build a house of cards For that they ve already found a hefty deck of playing cards Let s describe the house they want to make The house consists of some non zero number of floors Each floor consists of a non zero number of rooms and the ceiling A room is two cards that are leaned towards each other The rooms are made in a row each two adjoining rooms share a ceiling made by another card Each floor besides for the lowest one should contain less rooms than the floor below Please note that the house may end by the floor with more than one room and in this case they also must be covered by the ceiling Also the number of rooms on the adjoining floors doesn t have to differ by one the difference may be more While bears are practicing to put cards Horace tries to figure out how many floors their house should consist of The height of the house is the number of floors in it It is possible that you can make a lot of different houses of different heights out of cards It seems that the elephant cannot solve this problem and he asks you to count the number of the distinct heights of the houses that they can make using cards ,"['#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int maxn=2e6+5;\n\nlong long n,sum;\n\nint main(){\n    cin>>n;\n    sum=0;\n    int ans=0;\n    for(int i=1;i<maxn;i++){\n        sum+=3LL*i-1;\n        if(sum>n)break;\n        if((n-sum)%3==0)ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n']","['binary search', 'brute force', 'greedy', 'math']",1700
https://codeforces.com//contest/1131/problem/C,C. Birthday,Cowboy Vlad has a birthday today There are n children who came to the celebration In order to greet Vlad the children decided to form a circle around him Among the children who came there are both tall and low so if they stand in a circle arbitrarily it may turn out that there is a tall and low child standing next to each other and it will be difficult for them to hold hands Therefore children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible Formally let s number children from 1 to n in a circle order that is for every i child with number i will stand next to the child with number i 1 also the child with number 1 stands next to the child with number n Then we will call the discomfort of the circle the maximum absolute difference of heights of the children who stand next to each other Please help children to find out how they should reorder themselves so that the resulting discomfort is smallest possible ,"['/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,""r"",stdin);\n#define fpo(x) freopen(x,""w"",stdout);\n#define fprio fpi(""in.txt"");fpo(""out.txt"");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==\' \');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes("""");}\ninline void writei(int x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(""-funsafe-loop-optimizations"")\n#pragma GCC optimize(""-funroll-loops"")\n#pragma GCC optimize(""-fwhole-program"")\n#pragma GCC optimize(""Ofast,no-stack-protector"")\n#pragma GCC optimize(""-fthread-jumps"")\n#pragma GCC optimize(""-falign-functions"")\n#pragma GCC optimize(""-falign-jumps"")\n#pragma GCC optimize(""-falign-loops"")\n#pragma GCC optimize(""-falign-labels"")\n#pragma GCC optimize(""-fcaller-saves"")\n#pragma GCC optimize(""-fcrossjumping"")\n#pragma GCC optimize(""-fcse-follow-jumps"")\n#pragma GCC optimize(""-fcse-skip-blocks"")\n#pragma GCC optimize(""-fdelete-null-pointer-checks"")\n#pragma GCC optimize(""-fdevirtualize"")\n#pragma GCC optimize(""-fexpensive-optimizations"")\n#pragma GCC optimize(""-fgcse"")\n#pragma GCC optimize(""-fgcse-lm"")\n#pragma GCC optimize(""-fhoist-adjacent-loads"")\n#pragma GCC optimize(""-finline-small-functions"")\n#pragma GCC optimize(""-findirect-inlining"")\n#pragma GCC optimize(""-fipa-sra"")\n#pragma GCC optimize(""-foptimize-sibling-calls"")\n#pragma GCC optimize(""-fpartial-inlining"")\n#pragma GCC optimize(""-fpeephole2"")\n#pragma GCC optimize(""-freorder-blocks"")\n#pragma GCC optimize(""-freorder-functions"")\n#pragma GCC optimize(""-frerun-cse-after-loop"")\n#pragma GCC optimize(""-fsched-interblock"")\n#pragma GCC optimize(""-fsched-spec"")\n#pragma GCC optimize(""-fschedule-insns"")\n#pragma GCC optimize(""-fschedule-insns2"")\n#pragma GCC optimize(""-fstrict-aliasing"")\n#pragma GCC optimize(""-fstrict-overflow"")\n#pragma GCC optimize(""-ftree-switch-conversion"")\n#pragma GCC optimize(""-ftree-tail-merge"")\n#pragma GCC optimize(""-ftree-pre"")\n#pragma GCC optimize(""-ftree-vrp"")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<""NO"";return 0;}\n#define YES {cout<<""YES"";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nll n,m,i,j,k,a[100005],b[100005];\nstring st;\nint main()\n{\n\tread(n);\n\trep(i,n) read(a[i]);\n\tsort(a+1,a+n+1);\n\tj=1;k=n;\n\trep(i,n)\n\t{\n\t\tif (i&1) b[j++]=a[i]; else b[k--]=a[i];\n\t}\n\trep(i,n) printf(""%I64d "",b[i]); \n\treturn 0;\n}']","['binary search', 'greedy', 'sortings']",1200
https://codeforces.com//contest/43/problem/D,D. Journey,The territory of Berland is represented by a rectangular field in size The king of Berland lives in the capital located on the upper left square The lower right square has coordinates One day the king decided to travel through the whole country and return back to the capital having visited every square except the capital exactly one time The king must visit the capital exactly two times at the very beginning and at the very end of his journey The king can only move to the side neighboring squares However the royal advise said that the King possibly will not be able to do it But there is a way out one can build the system of one way teleporters between some squares so that the king could fulfill his plan No more than one teleporter can be installed on one square every teleporter can be used any number of times however every time it is used it transports to the same given for any single teleporter square When the king reaches a square with an installed teleporter he chooses himself whether he is or is not going to use the teleport What minimum number of teleporters should be installed for the king to complete the journey You should also compose the journey path route for the king ,"['#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std; \n\n#define DEBUG(x) cout << \'>\' << #x << \':\' << x << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FOR2(i, a, b) for (int i = (a); i > (b); --i)\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\nconst int INF = 1<<29;\ntypedef long long ll;\n\ninline int two(int n) { return 1 << n; }\ninline int test(int n, int b) { return n & two(b); }\ninline void set_bit(int & n, int b) { n |= two(b); }\ninline void unset_bit(int & n, int b) { n &= ~two(b); }\ninline int last_bit(int n) { return n & (-n); }\ninline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; }\n\ntemplate<class T> void chmax(T & a, const T & b) { a = max(a, b); }\ntemplate<class T> void chmin(T & a, const T & b) { a = min(a, b); }\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main()\n{\n\tint R, C;\n\tcin >> R >> C;\n\n\tif (R % 2 && C % 2)\n\t{\n\t\tcout << 1 << endl;\n\t\tcout << R << "" "" << C << "" "" << 1 << "" "" << 1 << endl;\n\t\tFOR(i, 0, R)\n\t\t\tFOR(j, 0, C)\n\t\t\tcout << i+1 << "" "" << (i%2==0?j+1:C-j) << endl;\n\t\tcout << 1 << "" "" << 1 << endl;\n\t}\n\telse if (R == 1 || C == 1)\n\t{\n\t\tbool swapped = false;\n\t\tif (C == 1)\n\t\t{\n\t\t\tswap(R, C);\n\t\t\tswapped = true;\n\t\t}\n\n\t\tif (C == 2)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 1 << "" "" << 1 << endl;\n\t\t\tif (swapped) cout << 2 << "" "" << 1 << endl;\n\t\t\telse cout << 1 << "" "" << 2 << endl;\n\t\t\tcout << 1 << "" "" << 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 1 << endl;\n\t\t\tif (swapped) cout << C << "" "" << R << "" "" << 1 << "" "" << 1 << endl;\n\t\t\telse cout << R << "" "" << C << "" "" << 1 << "" "" << 1 << endl;\n\t\t\tFOR(i, 0, C)\n\t\t\t{\n\t\t\t\tif (swapped) cout << i+1 << "" "" << 1 << endl;\n\t\t\t\telse cout << 1 << "" "" << i+1 << endl;\n\t\t\t}\n\t\t\tcout << 1 << "" "" << 1 << endl;\n\t\t}\n\t}\n\telse\n\t{\n\t\tcout << 0 << endl;\n\n\t\tbool swapped = false;\n\t\tif (R % 2)\n\t\t{\n\t\t\tswap(R, C);\n\t\t\tswapped = true;\n\t\t}\n\n\t\tcout << 1 << "" "" << 1 << endl;\n\t\tFOR(i, 0, R)\n\t\t\tFOR(j, 0, C-1)\n\t\t{\n\t\t\tif (swapped) cout << (i%2==0?j+2:C-j) << "" "" << i+1 << endl;\n\t\t\telse cout << i+1 << "" "" << (i%2==0?j+2:C-j) << endl;\n\t\t}\n\t\tFOR2(i, R, 0)\n\t\t{\n\t\t\tif (swapped) cout << 1 << "" "" << i << endl;\n\t\t\telse cout << i << "" "" << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}']","['brute force', 'constructive algorithms', 'implementation']",2000
https://codeforces.com//contest/145/problem/A,A. Lucky Conversion,Petya has two strings and of the same length The strings consist only of lucky digits Petya can perform of two types replace any one digit from string by its opposite i e replace by and by swap any pair of digits in string Petya is interested in the minimum number of operations that are needed to make string equal to string Help him with the task ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\nint n;\nchar a[1024000];\nchar b[1024000];\n\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tgets(a);\n\tgets(b);\n\tn=strlen(a);\n\tint x=0,y=0;\n\tREP(i,n) if (a[i]!=b[i])\n\t\tif (a[i]==\'4\')\n\t\t\t++x;\n\t\telse\n\t\t\t++y;\n\tprintf(""%d\\n"",max(x,y));\n\treturn 0;\n}']","['greedy', 'implementation']",1200
https://codeforces.com//contest/587/problem/E,E. Duff as a Queen,Duff is the queen of her country Andarz Gu She s a competitive programming fan That s why when he saw her minister Malek free she gave her a sequence consisting of non negative integers and asked him to perform queries for her on this sequence There are two types of queries given numbers and Malek should perform for each bitwise exclusive OR of numbers and given numbers and Malek should tell her the score of sequence Score of a sequence is the number of its different Kheshtaks A non negative integer is a Kheshtak of this sequence if and only if there exists a subsequence of let s denote it as possibly empty such that If this subsequence is empty then Unlike Duff Malek is not a programmer That s why he asked for your help Please help him perform these queries ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int ,int> PII;\ntypedef pair< int , PII> pii;\n\nconst int INF = ~0U>>1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1, a = 1ll * a * a % Mod)\n        if (x & 1) ret = 1ll * ret * a % Mod;\n    return ret; \n}\n\nconst int N=201000;\nint a[N],c[N],n,q,ty,l,r,k;\nstruct guass {\n\tint c[32],cnt;\n\tvoid clear() {\n\t\tcnt=0;\n\t\trep(i,0,31) c[i]=0;\n\t}\n\tvoid add(int x,int p=30) {\n\t\tfor (int i=p;i>=0&&x;i--) {\n\t\t\tx=min(x,x^c[i]);\n\t\t\tif (x&two(i)) { c[i]=x; cnt++; break;}\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor (int i=30;i>=0;i--) printf(""%d "",c[i]); puts("""");\n\t}\n}nd[4*N],ret;\nvoid Modify(int x,int p) { for (;x<=n;x+=x&-x) c[x]^=p;}\nint Query(int x) { int p=0; for (;x;x-=x&-x) p^=c[x]; return p; }\nvoid merge(int p) {\n\tnd[p].clear();\n\tfor (int i=30;i>=0;i--) nd[p].c[i]=nd[p+p].c[i];\n\tfor (int i=30;i>=0;i--) nd[p].add(nd[p+p+1].c[i],i);\n}\nvoid build(int p,int l,int r) {\n\tif (l==r) {\n\t\tnd[p].add(a[l]);\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tbuild(p+p,l,mid);\n\t\tbuild(p+p+1,mid+1,r);\n\t\tmerge(p);\n\t}\n}\nvoid modify(int p,int l,int r,int x,int v) {\n\tif (l==r) {\n\t\tnd[p].clear();\n\t\ta[l]^=v;\n\t\tnd[p].add(a[l]);\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tif (x<=mid) modify(p+p,l,mid,x,v);\n\t\telse modify(p+p+1,mid+1,r,x,v);\n\t\tmerge(p);\n\t}\n}\nvoid query(int p,int l,int r,int tl,int tr) {\n\tif (l==tl&&r==tr) {\n\t\tfor (int i=30;i>=0;i--) ret.add(nd[p].c[i],i);\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tif (tr<=mid) query(p+p,l,mid,tl,tr);\n\t\telse if (tl>mid) query(p+p+1,mid+1,r,tl,tr);\n\t\telse query(p+p,l,mid,tl,mid),query(p+p+1,mid+1,r,mid+1,tr);\n\t}\n}\nint main() {\n//\tfreopen(""in"",""r"",stdin);\n\tscanf(""%d%d"",&n,&q);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\tfor (int i=n;i>=1;i--) a[i]^=a[i-1];\n\trep(i,1,n+1) Modify(i,a[i]);\n\tbuild(1,1,n);\n\trep(i,0,q) {\n\t\tscanf(""%d%d%d"",&ty,&l,&r);\n\t\tif (ty==1) {\n\t\t\tscanf(""%d"",&k);\n\t\t\tmodify(1,1,n,l,k),Modify(l,k);\n\t\t\tif (r+1<=n) modify(1,1,n,r+1,k),Modify(r+1,k);\n\t\t} else {\n\t\t\tret.clear();\n\t\t\tif (l+1<=r) query(1,1,n,l+1,r);\n\t\t\tret.add(Query(l));\n\t\t\tprintf(""%d\\n"",two(ret.cnt));\n\t\t}\n\t}\n}']",['data structures'],2900
https://codeforces.com//contest/1548/problem/D1,D1. Gregor and the Odd Cows  Easy ,There are n fence posts at distinct coordinates on a plane It is guaranteed that no three fence posts lie on the same line There are an infinite number of cows on the plane one at every point with integer coordinates Gregor is a member of the Illuminati and wants to build a triangular fence connecting 3 distinct existing fence posts A cow inside the fence is said to be If there are an number of enclosed cows and the area of the fence is an the fence is said to be Find the number of interesting fences ,"['//别丢包了！\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 6005;\nint x[maxn], y[maxn];\nint main() {\n    int n;\n    cin >> n;\n    int cnt[4] = {0, 0, 0, 0};\n    for (int i = 1; i <= n; i++) {\n        scanf(""%d%d"", &x[i], &y[i]);\n        x[i] /= 2, y[i] /= 2;\n        cnt[2 * (x[i] % 2) + (y[i] % 2)] += 1;\n    }\n    ll ans = 1ll * n * (n - 1) * (n - 2) / 6;\n    for (int i = 0; i < 4; i++)\n        for (int j = i + 1; j < 4; j++)\n            for (int k = j + 1; k < 4; k++)\n                ans -= 1ll * cnt[i] * cnt[j] * cnt[k];\n    cout << ans << endl;\n    return (0-0); //<3\n}']","['bitmasks', 'geometry', 'math', 'number theory']",2300
https://codeforces.com//contest/1714/problem/F,F. Build a Tree and That Is It,A tree is a connected undirected graph without cycles Note that in this problem we are talking about not rooted trees You are given four positive integers n d 12 d 23 and d 31 Construct a tree such that it contains n vertices numbered from 1 to n the distance length of the shortest path from vertex 1 to vertex 2 is d 12 distance from vertex 2 to vertex 3 is d 23 the distance from vertex 3 to vertex 1 is d 31 Output any tree that satisfies all the requirements above or determine that no such tree exists ,"['/*\nDiv 3, I literally don\'t care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=2e5+5,mod=1e9+7;\nstring s[11],t;\nll n,d1,d2,d3;\nvoid solo()\n{\n   cin>>n>>d1>>d2>>d3;\n   if (d1>d2+d3 || d2>d3+d1 || d3>d1+d2){\n       cout<<""NO"";\n       return;\n   }\n   if (d2+d3==d1){\n       cout<<""YES\\n"";\n       ll l=4;\n       if (d3>1) \n       {\n        cout<<3<<"" ""<<l<<""\\n"",l++,d3--;\n       while (d3>1){\n           cout<<l-1<<"" ""<<l<<""\\n"",l++,d3--;\n       }\n       cout<<l-1<<"" ""<<1<<""\\n"";\n       }\n       else cout<<3<<"" ""<<1<<""\\n"";\n       if (d2>1) \n       {\n       cout<<3<<"" ""<<l<<""\\n"",l++,d2--;\n       while (d2>1){\n           cout<<l-1<<"" ""<<l<<""\\n"",l++,d2--;\n       }\n       cout<<l-1<<"" ""<<2<<""\\n"";\n       }\n       else cout<<3<<"" ""<<2<<""\\n"";\n       rep(i,l,n) cout<<1<<"" ""<<i<<""\\n"";\n       return;\n   }\n   if (d1+d2==d3){\n       cout<<""YES\\n"";\n       ll l=4;\n       if (d1>1) \n       {\n        cout<<2<<"" ""<<l<<""\\n"",l++,d1--;\n       while (d1>1){\n           cout<<l-1<<"" ""<<l<<""\\n"",l++,d1--;\n       }\n       cout<<l-1<<"" ""<<1<<""\\n"";\n       }\n       else cout<<2<<"" ""<<1<<""\\n"";\n       if (d2>1) \n       {\n        cout<<2<<"" ""<<l<<""\\n"",l++,d2--;\n       while (d2>1){\n           cout<<l-1<<"" ""<<l<<""\\n"",l++,d2--;\n       }\n       cout<<l-1<<"" ""<<3<<""\\n"";\n       }\n       else cout<<2<<"" ""<<3<<""\\n"";\n       rep(i,l,n) cout<<1<<"" ""<<i<<""\\n"";\n       return;\n   }\n   if (d3+d1==d2){\n       cout<<""YES\\n"";\n       ll l=4;\n       if (d3>1) \n       {\n        cout<<1<<"" ""<<l<<""\\n"",l++,d3--;\n       while (d3>1){\n           cout<<l-1<<"" ""<<l<<""\\n"",l++,d3--;\n       }\n       cout<<l-1<<"" ""<<3<<""\\n"";\n       }\n       else cout<<1<<"" ""<<3<<""\\n"";\n       if (d1>1) \n       {\n        cout<<1<<"" ""<<l<<""\\n"",l++,d1--;\n       while (d1>1){\n           cout<<l-1<<"" ""<<l<<""\\n"",l++,d1--;\n       }\n       cout<<l-1<<"" ""<<2<<""\\n"";\n       }\n       else cout<<1<<"" ""<<2<<""\\n"";\n       rep(i,l,n) cout<<1<<"" ""<<i<<""\\n"";\n       return;\n   }\n   rep(i,1,d1-1){\n       ll sl=i,sr=d1-i;\n       if (d3-sl==d2-sr && d3-sl>0 && (d1+1+d3-sl)<=n){\n           cout<<""YES\\n"";\n           ll l=4,pre=1;\n           rep(j,1,sl) cout<<pre<<"" ""<<l<<""\\n"",pre=l,l++;\n           rep(j,1,sl) d1--,d3--;\n           ll pos=pre;\n           rep(i,1,d3-1) cout<<pre<<"" ""<<l<<""\\n"",pre=l,l++;\n           cout<<pre<<"" ""<<3<<""\\n"";\n           pre=pos;\n           rep(i,1,d1-1) cout<<pre<<"" ""<<l<<""\\n"",pre=l,l++;\n           cout<<pre<<"" ""<<2<<""\\n"";\n           rep(i,l,n) cout<<1<<"" ""<<i<<""\\n"";\n           return;\n       }\n   }\n   cout<<""NO"";\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']","['constructive algorithms', 'implementation', 'trees']",1900
https://codeforces.com//contest/1767/problem/A,A. Cut the Triangle,You are given a non degenerate triangle a non degenerate triangle is a triangle with positive area The vertices of the triangle have coordinates x 1 y 1 x 2 y 2 and x 3 y 3 You want to draw a straight line to cut the triangle into Furthermore the line you draw should be Can you draw the line to meet all the constraints Here are some suitable ways to draw the line However these ways to draw the line are not suitable the first line cuts the triangle into a triangle and a quadrangle the second line doesn t cut the triangle at all the third line is neither horizontal nor vertical ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nint a[5], b[5];\n\nvoid solve() {\n\tfor (int i = 0; i < 3; i++)\n\t\tscanf(""%d%d"", &a[i], &b[i]);\n\tsort(a, a + 3);\n\tsort(b, b + 3);\n\tif ((a[0] != a[1] && a[1] != a[2]) || (b[0] != b[1] && b[1] != b[2]))\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/253/problem/A,A. Boys and Girls,There are boys and girls studying in the class They should stand in a line so that boys and girls alternated there as much as possible Let s assume that positions in the line are indexed from left to right by numbers from 1 to Then the number of integers such that positions with indexes and contain children of different genders position has a girl and position has a boy or vice versa must be as large as possible Help the children and tell them how to form the line ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(void)\n{\n    freopen(""input.txt"",""rt"",stdin);\n    freopen(""output.txt"",""wt"",stdout);\n    int n = 0;\n    int m = 0;\n    scanf(""%d %d"",&n,&m);\n    int all = n+m;\n    int l = 0;\n    if(m > n) l = 1;\n    for(int i = 0;i < all;i++)\n    {\n        if(l && m) { putchar(\'G\'); m--;}\n        else if(n) { putchar(\'B\');n--; }\n        else { putchar(\'G\'); m--; }\n        l ^= 1;\n    }\n    puts("""");\n    while(getchar() != EOF);\n    return 0;\n}\n']",['greedy'],1100
https://codeforces.com//contest/1373/problem/F,F. Network Coverage,The government of Berland decided to improve network coverage in his country Berland has a unique structure the capital in the center and n cities around the capital The capital already has a good network coverage so the government ignores it but the i th city contains a i households that require a connection The government designed a plan to build n network stations between all pairs of neighboring cities which will maintain connections only for these cities In other words the i th network station will provide service only for the i th and the i 1 th city the n th station is connected to the n th and the 1 st city All network stations have capacities the i th station can provide the connection to at most b i households Now the government asks you to check can the designed stations meet the needs of all cities or not that is is it possible to assign each household a network station so that each network station i provides the connection to at most b i households ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        int A[N], B[N]; F0R(i, N) cin >> A[i];\n        F0R(i, N) cin >> B[i];\n\n        int S = 0;\n        int last = B[0];\n        FOR(i, 1, 2*N+5) {\n            int cur = B[(i+N-1)%N] - last;\n            last = A[i%N] - cur;\n            ckmax(last, 0);\n//            cout << cur << "" "" << last << nl;\n            if (last > B[i%N]) {\n                S = i;\n                last = B[i%N];\n//                cout << ""S "" << S << nl;\n            }\n        }\n\n        if (S < N) {\n            cout << ""YES"" << nl;\n        } else {\n            cout << ""NO"" << nl;\n        }\n\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","['binary search', 'constructive algorithms', 'data structures', 'greedy']",2400
https://codeforces.com//contest/1909/problem/A,A. Distinct Buttons,You are located at the point 0 0 of an infinite Cartesian plane You have a controller with 4 buttons which can perform one of the following operations texttt U move from x y to x y 1 texttt R move from x y to x 1 y texttt D move from x y to x y 1 texttt L move from x y to x 1 y Unfortunately the controller is broken If you press all the 4 buttons in any order the controller stops working It means that during the whole trip you can only press at most 3 distinct buttons any number of times in any order There are n special points in the plane with integer coordinates x i y i Can you visit all the special points in any order without breaking the controller ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tint mn[2]{inf,inf},mx[2]{-inf,-inf};\n\trep(i,n){\n\t\trep(k,2){\n\t\t\tint v;cin>>v;\n\t\t\tchmin(mn[k],v);\n\t\t\tchmax(mx[k],v);\n\t\t}\n\t}\n\trep(k,2)if(mn[k]>=0)return Yes(0);\n\trep(k,2)if(mx[k]<=0)return Yes(0);\n\treturn No(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","['implementation', 'math']",800
https://codeforces.com//contest/1641/problem/C,C. Anonymity Is Important,In the work of a doctor it is important to maintain the anonymity of clients and the results of tests The test results are sent to everyone personally by email but people are very impatient and they want to know the results right away That s why in the testing lab De vitro doctors came up with an experimental way to report the results Let s assume that n people took the tests in the order of the queue Then the chief doctor Sam can make several statements in each telling if there is a sick person among the people in the queue from l th to r th inclusive for some values l and r During the process Sam will check how well this scheme works and will be interested in whether it is possible to find out the test result of i th person from the information he announced And if it can be done then is that patient sick or not Help Sam to test his scheme ,"['/**\n *    author:  tourist\n *    created: 23.02.2022 13:39:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  vector<pair<int, int>> qs;\n  set<int> s;\n  for (int i = 0; i < n; i++) {\n    s.insert(i);\n  }\n  for (int i = 0; i < tt; i++) {\n    int op;\n    cin >> op;\n    if (op == 1) {\n      int x;\n      cin >> x;\n      --x;\n      qs.emplace_back(x, -1);\n    } else {\n      int l, r, x;\n      cin >> l >> r >> x;\n      --l; --r;\n      if (x == 0) {\n        while (true) {\n          auto it = s.lower_bound(l);\n          if (it != s.end() && (*it) <= r) {\n            qs.emplace_back(*it, -2);\n            s.erase(it);\n          } else {\n            break;\n          }\n        }\n      } else {\n        qs.emplace_back(l, r);\n      }\n    }\n  }\n  tt = (int) qs.size();\n  vector<int> low(tt);\n  vector<int> high(tt);\n  for (int i = 0; i < tt; i++) {\n    if (qs[i].second >= 0) {\n      low[i] = i;\n      high[i] = tt;\n    }\n  }\n  vector<int> mid(tt);\n  while (true) {\n    vector<vector<int>> at(tt + 1);\n    bool any = false;\n    for (int i = 0; i < tt; i++) {\n      if (low[i] < high[i]) {\n        mid[i] = (low[i] + high[i]) >> 1;\n        at[mid[i]].push_back(i);\n        any = true;\n      }\n    }\n    if (!any) {\n      break;\n    }\n    fenwick<int> fenw(n);\n    for (int i = 0; i < tt; i++) {\n      if (qs[i].second == -2) {\n        fenw.modify(qs[i].first, +1);\n      }\n      for (int j : at[i]) {\n        int sum = fenw.get(qs[j].second) - fenw.get(qs[j].first - 1);\n        int len = qs[j].second - qs[j].first + 1;\n        assert(sum < len);\n        if (sum == len - 1) {\n          high[j] = mid[j];\n        } else {\n          low[j] = mid[j] + 1;\n        }\n      }\n    }\n  }\n  vector<vector<int>> at(tt + 1);\n  for (int i = 0; i < tt; i++) {\n    if (qs[i].second >= 0) {\n      at[low[i]].push_back(i);\n    }\n  }\n  fenwick<long long> fenw(n);\n  for (int i = 0; i < n; i++) {\n    fenw.modify(i, i);\n  }\n  vector<int> res(n, 0);\n  for (int i = 0; i < tt; i++) {\n    if (qs[i].second == -2) {\n      fenw.modify(qs[i].first, -qs[i].first);\n      res[qs[i].first] = -1;\n    }\n    if (qs[i].second == -1) {\n      int x = res[qs[i].first];\n      cout << (x == 0 ? ""N/A"" : (x == 1 ? ""YES"" : ""NO"")) << \'\\n\';\n    }\n    if (qs[i].second >= 0) {\n      // pass\n    }\n    for (int j : at[i]) {\n      long long sum = fenw.get(qs[j].second) - fenw.get(qs[j].first - 1);\n      assert(qs[j].first <= sum && sum <= qs[j].second);\n      res[sum] = 1;\n    }\n  }\n  return 0;\n}\n']","['binary search', 'brute force', 'data structures', 'dsu', 'greedy', 'sortings']",2200
https://codeforces.com//contest/480/problem/A,A. Exams,Student Valera is an undergraduate student at the University His end of term exams are approaching and he is to pass exactly exams Valera is a smart guy so he will be able to pass any exam he takes on his first try Besides he can take several exams on one day and in any order According to the schedule a student can take the exam for the th subject on the day number However Valera has made an arrangement with each teacher and the teacher of the th subject allowed him to take an exam before the schedule time on day Thus Valera can take an exam for the th subject either on day or on day All the teachers put the record of the exam in the student s record book on the day of the actual exam and write down the date of the mark as number Valera believes that it would be rather strange if the entries in the record book did not go in the order of non decreasing date Therefore Valera asks you to help him Find the minimum possible value of the day when Valera can take the final exam if he takes exams so that all the records in his record book go in the order of non decreasing date ,"['#include <bits/stdc++.h>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    int last = 0;\n    vector<pii> exams(N);\n    for (int i = 0; i < N; i++)\n        cin >> exams[i].first >> exams[i].second;\n    sort(RA(exams));\n    for (int i = 0; i < N; i++)\n    {\n        if (exams[i].second >= last)\n            last = exams[i].second;\n        else\n            last = exams[i].first;\n    }\n    cout << last << \'\\n\';\n\n    return 0;\n}\n']","['greedy', 'sortings']",1400
https://codeforces.com//contest/1884/problem/B,B. Haunted House,You are given a number in binary representation consisting of exactly n bits possibly with leading zeroes For example for n 5 the number 6 will be given as 00110 and for n 4 the number 9 will be given as 1001 Let s fix some integer i such that 1 le i le n In one operation you can swap any two adjacent bits in the binary representation Your goal is to find the smallest number of operations you are required to perform to make the number divisible by 2 i or say that it is impossible Please note that for each 1 le i le n you are solving the problem independently ,"['#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint N;char s[200005];\nint pcnt[200005],pos[200005],tot;ll res[200005];\nvoid solve(){\n\tscanf(""%d"",&N);scanf(""%s"",s+1);tot=0;reverse(s+1,s+N+1);\n\tfor(int i=1;i<=N;++i)if(s[i]==\'0\')pos[++tot]=i;\n\tfor(int i=1;i<=tot;++i)res[i]=res[i-1]+(ll)(pos[i]-i);\n\tpcnt[N+1]=0;for(int i=N;i>=1;--i)pcnt[i]=pcnt[i+1]+(s[i]==\'0\');\n\tfor(int i=1;i<=N;++i){\n\t\tif(i-(pcnt[1]-pcnt[i+1])>pcnt[i+1]){printf(""-1 "");continue;}\n\t\tprintf(""%lld "",res[i]);\n\t} puts("""");\n}\nint main(){\n\tint t;cin>>t;\n\twhile(t--)solve(); \n    return 0;\n}']","['binary search', 'greedy', 'math', 'two pointers']",1100
https://codeforces.com//contest/1556/problem/E,E. Equilibrium,William has two arrays a and b each consisting of n items For some segments l r of these arrays William wants to know if it is possible to equalize the values of items in these segments using a balancing operation Formally the values are equalized if for each i from l to r holds a i b i To perform a balancing operation an even number of indices must be selected such that l le pos 1 pos 2 dots pos k le r Next the items of at positions pos 1 pos 3 pos 5 dots get incremented by one and the items of at positions pos 2 pos 4 pos 6 dots get incremented by one William wants to find out if it is possible to equalize the values of elements in two arrays for each segment using some number of balancing operations and what is the minimal number of operations required for that Note that for each segment the operations are performed independently ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 100005;\nll mx[maxn][20];\nll mn[maxn][20];\nint mb[maxn];\nll qmx(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return max(mx[l][j], mx[r - (1 << j) + 1][j]);\n}\nll qmn(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return min(mn[l][j], mn[r - (1 << j) + 1][j]);\n}\nint a[maxn];\nint b[maxn];\nll s[maxn];\nint main() {\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) scanf(""%d"", &a[i]);\n    for (int i = 1; i <= n; i++) {\n        scanf(""%d"", &b[i]);\n        a[i] -= b[i];\n        s[i] = s[i - 1] + a[i];\n    } \n    for (int i = 0; i < maxn; i++)\n        for (int j = 0; j < 20; j++)\n            if ((1 << j) <= i) mb[i] = j;\n    \n    for (int i = 0; i < 20; i++)\n        for (int j = 1; j <= n - (1 << i) + 1; j++) {\n            if (i == 0) mx[j][i] = s[j];\n            else {\n                mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    \n    for (int i = 0; i < 20; i++)\n        for (int j = 1; j <= n - (1 << i) + 1; j++) {\n            if (i == 0) mn[j][i] = s[j];\n            else {\n                mn[j][i] = min(mn[j][i - 1], mn[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    for (int i = 1; i <= q; i++) {\n        int l, r;\n        scanf(""%d%d"", &l, &r);\n        ll ans = -(qmn(l, r) - s[l - 1]);\n        if (s[r] != s[l - 1]) ans = -1;\n        if (qmx(l, r) > s[l - 1]) ans = -1;\n        printf(""%lld\\n"", ans);\n    }\n    return (0-0); //<3\n}']","['data structures', 'dp', 'greedy']",2200
https://codeforces.com//contest/1814/problem/E,E. Chain Chips,You are given an undirected graph consisting of n vertices and n 1 edges The i th edge has weight a i it connects the vertices i and i 1 Initially each vertex contains a chip Each chip has an integer written on it the integer written on the chip in the i th vertex is i In one operation you can choose a chip if there are multiple chips in a single vertex you may choose any one of them and move it along one of the edges of the graph The cost of this operation is equal to the weight of the edge The of the graph is the minimum cost of a sequence of such operations that meets the following condition after all operations are performed each vertex contains exactly one chip and the integer on each chip is to the index of the vertex where that chip is located You are given q queries of the form k x change the weight of the k th edge the one which connects the vertices k and k 1 to x After each query print the of the graph Note that you don t actually move any chips when you compute the cost the chips are on their initial positions ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << "" ""; cout << v[i];\n\t}\n\tcout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\ntemplate<typename T>\nstruct SegT {\nprivate:\n\tint sz; vector<T> node;\n\tT init_c;\n\tfunction<T(T, T)> f;\npublic:\n\tSegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n\t\tinit_c = _init_c; f = _f;\n\t\tint n = v.size();\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t\trep(i, n) {\n\t\t\tnode[i + sz - 1] = v[i];\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tnode[i] = f(node[2 * i + 1], node[2 * i + 2]);\n\t\t}\n\t}\n\tSegT(int n, T _init_c, function<T(T, T)> _f) {\n\t\tinit_c = _init_c; f = _f;\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tvoid update(int k, T a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n\t//k以上でf(x,node[y+sz-1])をtrueにするような最小のy\n\tint searchloc(int le, T x, function<bool(T, T)> comp) {\n\t\tint  k = le + sz - 1;\n\t\tif (comp(x, node[k]))return le;\n\t\tx = f(x, node[k]);\n\t\twhile (k > 0) {\n\t\t\tint mem = k;\n\t\t\tk = (k - 1) / 2;\n\t\t\tif (2 * k + 1 == mem) {\n\t\t\t\tif (comp(x, node[2 * k + 2])) {\n\t\t\t\t\tk = 2 * k + 2; break;\n\t\t\t\t}\n\t\t\t\tx = f(x, node[2 * k + 2]);\n\t\t\t}\n\t\t}\n\t\tif (k == 0)return sz;\n\t\twhile (k < sz - 1) {\n\t\t\tif (comp(x, node[2 * k + 1])) {\n\t\t\t\tk = 2 * k + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = f(x, node[2 * k + 1]);\n\t\t\t\tk = 2 * k + 2;\n\t\t\t}\n\t\t}\n\t\treturn k - (sz - 1);\n\t}\n};\n\nusing ar = array<ll, 4>;\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> a(n);\n\trep(i, n-1)cin >> a[i];\n\tvector<ar> ori(n - 1);\n\trep(i, n - 1) {\n\t\trep(j, 4)ori[i][j] = INF;\n\t\tori[i][0] = 0;\n\t\tori[i][3] = a[i];\n\t}\n\tar e = { -1,-1,-1,-1 };\n\tauto f = [&](ar a, ar b) {\n\t\tif (a == e)return b;\n\t\tif (b == e)return a;\n\t\tar res; rep(i, 4)res[i] = INF;\n\t\trep(i, 4)rep(j, 4) {\n\t\t\tint br = i & 2;\n\t\t\tint bl = j & 1;\n\t\t\tif (!br && !bl)continue;\n\t\t\tint ni = 0;\n\t\t\tif (i & 1)ni |= 1;\n\t\t\tif (j & 2)ni |= 2;\n\t\t\tchmin(res[ni], a[i] + b[j]);\n\t\t}\n\t\treturn res;\n\t};\n\tSegT<ar> st(ori, e, f);\n\tint q; cin >> q;\n\trep(i, q) {\n\t\tint id, x; cin >> id >> x; id--;\n\t\tar cur; rep(j, 4)cur[j] = INF;\n\t\tcur[0] = 0;\n\t\tcur[3] = x;\n\t\tst.update(id, cur);\n\t\tar z = st.query(0, n - 1);\n\t\tll ans = 2 * z[3];\n\t\tcout << ans << ""\\n"";\n\t}\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}']","['data structures', 'dp', 'matrices']",2300
https://codeforces.com//contest/1215/problem/C,C. Swap Letters,Monocarp has got two strings s and t having equal length Both strings consist of lowercase Latin letters and Monocarp wants to make these two strings s and t equal to each other He can do the following operation any number of times choose an index pos 1 in the string s choose an index pos 2 in the string t and swap s pos 1 with t pos 2 You have to determine the minimum number of operations Monocarp has to perform to make s and t equal and print any optimal sequence of operations or say that it is impossible to make these strings equal ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nchar a[200005],b[200005];\nint n,q1[200005],q2[200005];\nint k,ans1[500005],ans2[500005];\nint main(){\n\tscanf(""%d%s%s"",&n,a+1,b+1);\n\tFor(i,1,n)\n\t\tif (a[i]==\'a\'&&b[i]==\'b\') q1[++*q1]=i;\n\t\telse if (a[i]==\'b\'&&b[i]==\'a\') q2[++*q2]=i;\n\tif (((*q1)+(*q2))%2==1) return puts(""-1""),0;\n\tfor (;*q1>=2;*q1-=2) ans1[++k]=q1[*q1],ans2[k]=q1[(*q1)-1];\n\tfor (;*q2>=2;*q2-=2) ans1[++k]=q2[*q2],ans2[k]=q2[(*q2)-1];\n\tif (*q1){\n\t\tans1[++k]=q1[1]; ans2[k]=q1[1];\n\t\tans1[++k]=q1[1]; ans2[k]=q2[1];\n\t}\n\tprintf(""%d\\n"",k);\n\tFor(i,1,k) printf(""%d %d\\n"",ans1[i],ans2[i]);\n}']","['constructive algorithms', 'greedy']",1500
https://codeforces.com//contest/1682/problem/C,C. LIS or Reverse LIS ,You are given an array a of n positive integers Let text LIS a denote the length of longest strictly increasing subsequence of a For example text LIS 2 underline 1 1 underline 3 2 text LIS underline 3 underline 5 underline 10 underline 20 4 text LIS 3 underline 1 underline 2 underline 4 3 We define array a as the array obtained after reversing the array a i e a a n a n 1 ldots a 1 The beauty of array a is defined as min text LIS a text LIS a Your task is to determine the maximum possible beauty of the array a if you can rearrange the array a arbitrarily ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint p[200005];\nint main()\n{\n\tint t,n,ans=0,ans1=0,tsl;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)p[i]=read();\n\t\tsort(p+1,p+n+1);\n\t\ttsl=1;\n\t\tans1=0;\n\t\tans=0; \n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(p[i]!=p[i-1])\n\t\t\t{\n\t\t\t\tif(tsl==1)ans1++;\n\t\t\t\telse ans++;\n\t\t\t\ttsl=1;\n\t\t\t}\n\t\t\telse tsl++;\n\t\t}\n\t\tif(tsl==1)ans1++;\n\t\telse ans++;\n\t\tif(ans1>=1)ans1--,ans++; \n\t\tprintf(""%d\\n"",ans+ans1/2);\n\t}\n\treturn 0;\n} ']","['constructive algorithms', 'greedy', 'implementation', 'math']",1400
https://codeforces.com//contest/1194/problem/G,G. Another Meme Problem,Let s call a fraction frac x y good if there exists at least one another fraction frac x y such that frac x y frac x y 1 le x y le 9 the digit denoting x is contained in the decimal representation of x and the digit denoting y is contained in the decimal representation of y For example frac 26 13 is a good fraction because frac 26 13 frac 2 1 You are given an integer number n Please calculate the number of good fractions frac x y such that 1 le x le n and 1 le y le n The answer may be really large so print it modulo 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>\n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\n// base and base_digits must be consistent\nconstexpr int base = 1000000000;\nconstexpr int base_digits = 9;\n\nstruct bigint {\n    // value == 0 is represented by empty z\n    vector<int> z; // digits\n\n    // sign == 1 <==> value >= 0\n    // sign == -1 <==> value < 0\n    int sign;\n\n    bigint() : sign(1) {}\n    bigint(long long v) { *this = v; }\n\n    bigint &operator=(long long v) {\n        sign = v < 0 ? -1 : 1; v *= sign;\n        z.clear(); for (; v > 0; v = v / base) z.push_back((int) (v % base));\n        return *this;\n    }\n\n    bigint(const string &s) { read(s); }\n\n    bigint &operator+=(const bigint &other) {\n        if (sign == other.sign) {\n            for (int i = 0, carry = 0; i < other.z.size() || carry; ++i) {\n                if (i == z.size())\n                    z.push_back(0);\n                z[i] += carry + (i < other.z.size() ? other.z[i] : 0);\n                carry = z[i] >= base;\n                if (carry)\n                    z[i] -= base;\n            }\n        } else if (other != 0 /* prevent infinite loop */) {\n            *this -= -other;\n        }\n        return *this;\n    }\n\n    friend bigint operator+(bigint a, const bigint &b) { return a += b; }\n\n    bigint &operator-=(const bigint &other) {\n        if (sign == other.sign) {\n            if (sign == 1 && *this >= other || sign == -1 && *this <= other) {\n                for (int i = 0, carry = 0; i < other.z.size() || carry; ++i) {\n                    z[i] -= carry + (i < other.z.size() ? other.z[i] : 0);\n                    carry = z[i] < 0;\n                    if (carry)\n                        z[i] += base;\n                }\n                trim();\n            } else {\n                *this = other - *this;\n                this->sign = -this->sign;\n            }\n        } else {\n            *this += -other;\n        }\n        return *this;\n    }\n\n    friend bigint operator-(bigint a, const bigint &b) { return a -= b; }\n\n    bigint &operator*=(int v) {\n        if (v < 0) sign = -sign, v = -v;\n        for (int i = 0, carry = 0; i < z.size() || carry; ++i) {\n            if (i == z.size())\n                z.push_back(0);\n            long long cur = (long long) z[i] * v + carry;\n            carry = (int) (cur / base);\n            z[i] = (int) (cur % base);\n        }\n        trim();\n        return *this;\n    }\n\n    bigint operator*(int v) const { return bigint(*this) *= v; }\n\n    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\n        int norm = base / (b1.z.back() + 1);\n        bigint a = a1.abs() * norm;\n        bigint b = b1.abs() * norm;\n        bigint q, r;\n        q.z.resize(a.z.size());\n\n        for (int i = (int) a.z.size() - 1; i >= 0; i--) {\n            r *= base;\n            r += a.z[i];\n            int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;\n            int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;\n            int d = (int) (((long long) s1 * base + s2) / b.z.back());\n            r -= b * d;\n            while (r < 0)\n                r += b, --d;\n            q.z[i] = d;\n        }\n\n        q.sign = a1.sign * b1.sign;\n        r.sign = a1.sign;\n        q.trim();\n        r.trim();\n        return {q, r / norm};\n    }\n\n    friend bigint sqrt(const bigint &a1) {\n        bigint a = a1;\n        while (a.z.empty() || a.z.size() % 2 == 1)\n            a.z.push_back(0);\n\n        int n = a.z.size();\n\n        int firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);\n        int norm = base / (firstDigit + 1);\n        a *= norm;\n        a *= norm;\n        while (a.z.empty() || a.z.size() % 2 == 1)\n            a.z.push_back(0);\n\n        bigint r = (long long) a.z[n - 1] * base + a.z[n - 2];\n        firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);\n        int q = firstDigit;\n        bigint res;\n\n        for (int j = n / 2 - 1; j >= 0; j--) {\n            for (;; --q) {\n                bigint r1 = (r - (res * 2 * base + q) * q) * base * base +\n                            (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);\n                if (r1 >= 0) {\n                    r = r1;\n                    break;\n                }\n            }\n            res *= base;\n            res += q;\n\n            if (j > 0) {\n                int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;\n                int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;\n                int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;\n                q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2));\n            }\n        }\n\n        res.trim();\n        return res / norm;\n    }\n\n    bigint operator/(const bigint &v) const { return divmod(*this, v).first; }\n\n    bigint operator%(const bigint &v) const { return divmod(*this, v).second; }\n\n    bigint &operator/=(int v) {\n        if (v < 0) sign = -sign, v = -v;\n        for (int i = (int) z.size() - 1, rem = 0; i >= 0; --i) {\n            long long cur = z[i] + rem * (long long) base;\n            z[i] = (int) (cur / v);\n            rem = (int) (cur % v);\n        }\n        trim();\n        return *this;\n    }\n\n    bigint operator/(int v) const { return bigint(*this) /= v; }\n\n    int operator%(int v) const {\n        if (v < 0) v = -v;\n        int m = 0;\n        for (int i = (int) z.size() - 1; i >= 0; --i)\n            m = (int) ((z[i] + m * (long long) base) % v);\n        return m * sign;\n    }\n\n    bigint &operator*=(const bigint &v) { return *this = *this * v; }\n    bigint &operator/=(const bigint &v) { return *this = *this / v; }\n\n    bool operator<(const bigint &v) const {\n        if (sign != v.sign)\n            return sign < v.sign;\n        if (z.size() != v.z.size())\n            return z.size() * sign < v.z.size() * v.sign;\n        for (int i = (int) z.size() - 1; i >= 0; i--)\n            if (z[i] != v.z[i])\n                return z[i] * sign < v.z[i] * sign;\n        return false;\n    }\n\n    bool operator>(const bigint &v) const { return v < *this; }\n    bool operator<=(const bigint &v) const { return !(v < *this); }\n    bool operator>=(const bigint &v) const { return !(*this < v); }\n\n    bool operator==(const bigint &v) const { return !(*this < v) && !(v < *this); }\n\n    bool operator!=(const bigint &v) const { return *this < v || v < *this; }\n\n    void trim() {\n        while (!z.empty() && z.back() == 0) z.pop_back();\n        if (z.empty()) sign = 1;\n    }\n\n    bool isZero() const { return z.empty(); }\n\n    friend bigint operator-(bigint v) {\n        if (!v.z.empty()) v.sign = -v.sign;\n        return v;\n    }\n\n    bigint abs() const {\n        return sign == 1 ? *this : -*this;\n    }\n\n    long long longValue() const {\n        long long res = 0;\n        for (int i = (int) z.size() - 1; i >= 0; i--)\n            res = res * base + z[i];\n        return res * sign;\n    }\n\n    friend bigint gcd(const bigint &a, const bigint &b) {\n        return b.isZero() ? a : gcd(b, a % b);\n    }\n\n    friend bigint lcm(const bigint &a, const bigint &b) {\n        return a / gcd(a, b) * b;\n    }\n\n    void read(const string &s) {\n        sign = 1;\n        z.clear();\n        int pos = 0;\n        while (pos < s.size() && (s[pos] == \'-\' || s[pos] == \'+\')) {\n            if (s[pos] == \'-\')\n                sign = -sign;\n            ++pos;\n        }\n        for (int i = (int) s.size() - 1; i >= pos; i -= base_digits) {\n            int x = 0;\n            for (int j = max(pos, i - base_digits + 1); j <= i; j++)\n                x = x * 10 + s[j] - \'0\';\n            z.push_back(x);\n        }\n        trim();\n    }\n\n    friend istream &operator>>(istream &stream, bigint &v) {\n        string s; stream >> s;\n        v.read(s);\n        return stream;\n    }\n\n    friend ostream &operator<<(ostream &stream, const bigint &v) {\n        if (v.sign == -1)\n            stream << \'-\';\n        stream << (v.z.empty() ? 0 : v.z.back());\n        for (int i = (int) v.z.size() - 2; i >= 0; --i)\n            stream << setw(base_digits) << setfill(\'0\') << v.z[i];\n        return stream;\n    }\n\n    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n        vector<long long> p(max(old_digits, new_digits) + 1);\n        p[0] = 1;\n        for (int i = 1; i < p.size(); i++)\n            p[i] = p[i - 1] * 10;\n        vector<int> res;\n        long long cur = 0;\n        int cur_digits = 0;\n        for (int v : a) {\n            cur += v * p[cur_digits];\n            cur_digits += old_digits;\n            while (cur_digits >= new_digits) {\n                res.push_back(int(cur % p[new_digits]));\n                cur /= p[new_digits];\n                cur_digits -= new_digits;\n            }\n        }\n        res.push_back((int) cur);\n        while (!res.empty() && res.back() == 0)\n            res.pop_back();\n        return res;\n    }\n\n    typedef vector<long long> vll;\n\n    static vll karatsubaMultiply(const vll &a, const vll &b) {\n        int n = a.size();\n        vll res(n + n);\n        if (n <= 32) {\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    res[i + j] += a[i] * b[j];\n            return res;\n        }\n\n        int k = n >> 1;\n        vll a1(a.begin(), a.begin() + k);\n        vll a2(a.begin() + k, a.end());\n        vll b1(b.begin(), b.begin() + k);\n        vll b2(b.begin() + k, b.end());\n\n        vll a1b1 = karatsubaMultiply(a1, b1);\n        vll a2b2 = karatsubaMultiply(a2, b2);\n\n        for (int i = 0; i < k; i++)\n            a2[i] += a1[i];\n        for (int i = 0; i < k; i++)\n            b2[i] += b1[i];\n\n        vll r = karatsubaMultiply(a2, b2);\n        for (int i = 0; i < a1b1.size(); i++)\n            r[i] -= a1b1[i];\n        for (int i = 0; i < a2b2.size(); i++)\n            r[i] -= a2b2[i];\n\n        for (int i = 0; i < r.size(); i++)\n            res[i + k] += r[i];\n        for (int i = 0; i < a1b1.size(); i++)\n            res[i] += a1b1[i];\n        for (int i = 0; i < a2b2.size(); i++)\n            res[i + n] += a2b2[i];\n        return res;\n    }\n\n    bigint operator*(const bigint &v) const {\n        vector<int> a6 = convert_base(this->z, base_digits, 6);\n        vector<int> b6 = convert_base(v.z, base_digits, 6);\n        vll a(a6.begin(), a6.end());\n        vll b(b6.begin(), b6.end());\n        while (a.size() < b.size())\n            a.push_back(0);\n        while (b.size() < a.size())\n            b.push_back(0);\n        while (a.size() & (a.size() - 1))\n            a.push_back(0), b.push_back(0);\n        vll c = karatsubaMultiply(a, b);\n        bigint res;\n        res.sign = sign * v.sign;\n        for (int i = 0, carry = 0; i < c.size(); i++) {\n            long long cur = c[i] + carry;\n            res.z.push_back((int) (cur % 1000000));\n            carry = (int) (cur / 1000000);\n        }\n        res.z = convert_base(res.z, 6, base_digits);\n        res.trim();\n        return res;\n    }\n\n};\n\nbigint random_bigint(int n) {\n    string s;\n    for (int i = 0; i < n; i++) {\n        s += rand() % 10 + \'0\';\n    }\n    return bigint(s);\n}\n\n// random tests\nvoid bigintTest() {\n    bigint x = bigint(""120"");\n    bigint y = bigint(""5"");\n    cout << x / y << endl;\n\n    for (int i = 0; i < 1000; i++) {\n        int n = rand() % 100 + 1;\n        bigint a = random_bigint(n);\n        bigint res = sqrt(a);\n        bigint xx = res * res;\n        bigint yy = (res + 1) * (res + 1);\n\n        if (xx > a || yy <= a) {\n            cout << i << endl;\n            cout << a << "" "" << res << endl;\n            break;\n        }\n\n        int m = rand() % n + 1;\n        bigint b = random_bigint(m) + 1;\n        res = a / b;\n        xx = res * b;\n        yy = b * (res + 1);\n\n        if (xx > a || yy <= a) {\n            cout << i << endl;\n            cout << a << "" "" << b << "" "" << res << endl;\n            break;\n        }\n    }\n\n    bigint a = random_bigint(10000);\n    bigint b = random_bigint(2000);\n    clock_t start = clock();\n    bigint c = a / b;\n    printf(""time=%.3lfsec\\n"", (clock() - start) * 1. / CLOCKS_PER_SEC);\n}\n\nstring str(bigint b) {\n\tstringstream ss; ss << b;\n\tstring s; ss >> s;\n\treturn s;\n}\n\nstring n;\nbigint B;\n\nmi dp(string x, int a, int b, vpi v) {\n\t// ps(""WUT"",x,a,b,v);\n\tarray<map<pair<pi,int>,mi>,3> dp;\n\tdp[1][{{0,0},0}] = 1;\n\treverse(all(x)); x += \'0\';\n\tF0R(i,sz(x)) {\n\t\tarray<map<pair<pi,int>,mi>,3> DP;\n\t\tF0R(q,10) F0R(j,3) {\n\t\t\tint ind = MOD;\n\t\t\tif (q > x[i]-\'0\') ind = 2;\n\t\t\telse if (q == x[i]-\'0\') ind = j;\n\t\t\telse ind = 0;\n\t\t\ttrav(t,dp[j]) {\n\t\t\t\tint A = t.f.f.f+q*a;\n\t\t\t\tint B = t.f.f.s+q*b;\n\t\t\t\tint cur = t.f.s;\n\t\t\t\tF0R(z,sz(v)) {\n\t\t\t\t\tif (cur == -1) break;\n\t\t\t\t\tif (A%10 == v[z].f) cur |= 1<<(2*z);\n\t\t\t\t\tif (B%10 == v[z].s) cur |= 1<<(2*z+1);\n\t\t\t\t\tif (((cur>>(2*z))&3) == 3) cur = -1;\n\t\t\t\t}\n\t\t\t\tDP[ind][{{A/10,B/10},cur}] += t.s;\n\t\t\t}\n\t\t}\n\t\tswap(dp,DP);\n\t}\n\tmi ans = 0;\n\ttrav(t,dp[1]) {\n\t\tassert(t.f.f == mp(0,0));\n\t\tif (t.f.s == -1) ans += t.s;\n\t}\n\ttrav(t,dp[0]) {\n\t\tassert(t.f.f == mp(0,0));\n\t\tif (t.f.s == -1) ans += t.s;\n\t}\n\t// ps(""HA"",ans); exit(0);\n\treturn ans;\n}\n\nmi solve(int a, int b) {\n\tif (a == b) return B%MOD;\n\tvpi v;\n\tfor (int i = 1; i*b < 10; i++) v.pb({a*i,b*i});\n\tauto mx = B/b;\n\treturn dp(str(mx),a,b,v);\n}\n\nint main() {\n    setIO(); re(n); B = bigint(n);\n\tmi ans = 0;\n    FOR(i,1,10) FOR(j,i,10) if (__gcd(i,j) == 1) {\n    \t// ps(""??"",i,j);\n    \tmi z = solve(i,j);\n    \tif (i != j) ans += 2*z;\n    \telse ans += z;\n    \t// ps(""HUH"",i,j,ans);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/']",['dp'],2700
https://codeforces.com//contest/909/problem/B,B. Segments,You are given an integer Consider all possible segments on the coordinate axis with endpoints at integer points with coordinates between 0 and inclusive there will be of them You want to draw these segments in several layers so that in each layer the segments don t overlap they might touch at the endpoints though You move the segments to a different location on the coordinate axis Find the minimal number of layers you have to use for the given ,"[""#include<bits/stdc++.h>\nusing namespace std;\nnamespace FastIO\n{\n\tstatic char c;\n\tstatic int top,buf[22];\n\ttemplate<typename T>inline void read(T& x)\n\t{\n\t\tx=0,c=getchar();\n\t\twhile(!isdigit(c))c=getchar();\n\t\twhile(isdigit(c))x=x*10+c-'0',c=getchar();\n\t}\n\ttemplate<typename T>inline void write(T x)\n\t{\n\t\ttop=0;\n\t\tdo buf[++top]=x%10,x/=10;while(x);\n\t\twhile(top)putchar(buf[top--]+48);\n\t\tputchar('\\n');\n\t}\n}\nusing FastIO::read;\nusing FastIO::write;\ntypedef long long LL;\n\nint n,dp[105];\n\nint main()\n{\n\tread(n);\n\tdp[1]=1,dp[2]=2;\n\tfor(int i=3;i<=n;i++)dp[i]=i+dp[i-2];\n\twrite(dp[n]);\n\treturn 0;\n}""]","['constructive algorithms', 'math']",1300
https://codeforces.com//contest/937/problem/A,A. Olympiad,The recent All Berland Olympiad in Informatics featured participants with each scoring a certain amount of points As the head of the programming committee you are to determine the set of participants to be awarded with diplomas with respect to the following criteria At least one participant should get a diploma None of those with score equal to zero should get awarded When someone is awarded all participants with score than his score should also be awarded Determine the number of ways to choose a subset of participants that will receive the diplomas ,"['//\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define mp make_pair\n\nconst int mod = 1000000007;\nconst int INF = 1000000000;\n\nint n;\nset <int> s;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        int a;\n\n        cin >> a;\n\n        if (a)\n            s.insert(a);\n    }\n\n    cout << s.size() << endl;\n\n    return 0;\n}']","['implementation', 'sortings']",800
https://codeforces.com//contest/915/problem/A,A. Garden,Luba thinks about watering her garden The garden can be represented as a segment of length Luba has got buckets the th bucket allows her to water some continuous subsegment of garden of length each hour Luba has to choose of the buckets in order to water the garden as fast as possible as mentioned above each hour she will water some continuous subsegment of length if she chooses the th bucket Help her to determine the minimum number of hours she has to spend watering the garden It is guaranteed that Luba can always choose a bucket so it is possible water the garden See the examples for better understanding ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint ans = 1E9;\n\tint n, k; cin >> n >> k;\n\tfori(n) {\n\t\tint a; cin >> a;\n\t\tif (k%a != 0)continue;\n\t\tans = min(ans, k / a);\n\t}\n\tcout << ans;\n\treturn 0;\n}']",['implementation'],900
https://codeforces.com//contest/1607/problem/E,E. Robot on the Board 1,The robot is located on a checkered rectangular board of size n times m n rows m columns The rows in the board are numbered from 1 to n from top to bottom and the columns from 1 to m from left to right The robot is able to move from the current cell to one of the four cells adjacent by side The sequence of commands s executed by the robot is given Each command is denoted by one of the symbols or and triggers the movement to left right down or up respectively The robot can start its movement in cell The robot executes the commands starting from the first one strictly in the order in which they are listed in s If the robot moves beyond the edge of the board it falls and breaks A command that causes the robot to break is successfully executed The robot s task is to execute as many commands as possible without falling off the board For example on board 3 times 3 if the robot starts a sequence of actions s right right down left up up from the central cell the robot will perform one command then the next command will force him to cross the edge If the robot starts moving from the cell 2 1 second row first column then all commands will be executed successfully and the robot will stop at the cell 1 2 first row second column Determine the cell from which the robot should start its movement in order to execute as many commands as possible ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tstring s;\n\t\tcin >> n >> m >> s;\n\t\tint mnx=0,mxx=0,mny=0,mxy=0,x=0,y=0;\n\t\ts+=\'*\'; \n\t\tfor(auto t:s)\n\t\t{\n\t\t\tint l1=mxx,l2=mnx,l3=mxy,l4=mny;\n\t\t\tif(t==\'L\') --y;\n\t\t\telse if(t==\'R\') ++y;\n\t\t\telse if(t==\'U\') --x;\n\t\t\telse if(t==\'D\') ++x;\n\t\t\telse x=1e9;\n\t\t\tmnx=min(mnx,x); \n\t\t\tmny=min(mny,y); \n\t\t\tmxx=max(mxx,x);\n\t\t\tmxy=max(mxy,y);\n\t\t\tif(mxx-mnx+1>n||mxy-mny+1>m)\n\t\t\t{//\n\t\t\t\tmxx=l1,mnx=l2,mxy=l3,mny=l4;\n\t\t\t\tcout << 1-mnx << "" "" << 1-mny << ""\\n"";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",['implementation'],1600
https://codeforces.com//contest/370/problem/B,B. Berland Bingo,Lately a national version of a bingo game has become very popular in Berland There are players playing the game each player has a card with numbers The numbers on each card are distinct but distinct cards can have equal numbers The card of the th player contains numbers During the game the host takes numbered balls one by one from a bag He reads the number aloud in a high and clear voice and then puts the ball away All participants cross out the number if it occurs on their cards The person who crosses out all numbers from his card first wins If multiple people cross out all numbers from their cards at the same time there are no winners in the game At the beginning of the game the bag contains 100 balls numbered 1 through 100 the numbers of all balls are distinct You are given the cards for each player Write a program that determines whether a player can win the game at the most favorable for him scenario or not ,"['#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file """"\n#define N 100500\n\nint use[120];\n\nint m[120][120];\nint ml[120];    \nbool ans[120];\n       \nint main()\n{\n\n    int n;\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(""%d"", &ml[i]);\n        for (int j = 0; j < ml[i]; j++)\n            scanf(""%d"", &m[i][j]);\n        sort(m[i], m[i] + ml[i]);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j <= 100; j++) use[j] = 0;\n        for (int j = 0; j < ml[i]; j++) use[m[i][j]] = 1;\n        ans[i] = 1;\n        for (int j = 0; j < n; j++)\n            if (i != j)\n            {\n                bool f = 1;\n                for (int k = 0; k < ml[j] && f; k++)\n                    if (!use[m[j][k]])\n                    {\n                        f = 0;\n                        break;\n                    }\n                if (f)\n                {\n                    ans[i] = 0;\n                    break;\n                }\n            }\n    }\n    for (int i = 0; i < n; i++)\n        if (ans[i] == 1) printf(""YES\\n"");\n        else printf(""NO\\n"");\n\n    return 0;\n}']",['implementation'],1300
https://codeforces.com//contest/1635/problem/A,A. Min Or Sum,You are given an array a of size n You can perform the following operation on the array Choose two different integers i j 1 leq i j leq n replace a i with x and a j with y In order not to break the array a i a j x y must be held where denotes the bitwise OR operation Notice that x and y are non negative integers Please output the minimum sum of the array you can get after using the operation above any number of times ,"['// Problem: A. Min Or Sum\n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/A\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nint a[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),ans=0;\n\t\tfor(int i=1; i<=n; ++i) a[i]=read(),ans|=a[i];\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}']","['bitmasks', 'greedy']",800
https://codeforces.com//contest/414/problem/B,B. Mashmokh and ACM,A sequence of integers is called if each number divides without a remainder by the next number in the sequence More formally for all Given and find the number of good sequences of length As the answer can be rather large print it modulo ,"['#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define forint(i, a, b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define forintdown(i, a, b) for(int i=(int)(a); i>=(int)(b); --i)\n#define forn(i, n) forint(i, 0, (n)-1)\n#define forndown(i, n) forintdown(i, (n)-1, 0)\n#define fillchar(a, x) memset(a, x, sizeof(a))\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPI;\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n\nconst int MOD=int(1e9)+7;\nconst int MAXN=2020;\n\nint f[MAXN][MAXN];\nint n, k;\n\nvoid add(int &x, int y) {\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n}\n\nint main() {\n\tcin>>n>>k;\n\tfillchar(f, 0);\n\tforint(i, 1, n) f[1][i]=1;\n\tforint(i, 1, k-1) forint(j, 1, n) if(f[i][j]!=0)\n\t\tfor(int j2=j; j2<=n; j2+=j)\n\t\t\tadd(f[i+1][j2], f[i][j]);\n\tint ans=0;\n\tforint(j, 1, n) add(ans, f[k][j]);\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'number theory']",1400
https://codeforces.com//contest/1423/problem/J,J. Bubble Cup hypothesis,The Bubble Cup hypothesis stood unsolved for 130 years Who ever proves the hypothesis will be regarded as one of the greatest mathematicians of our time A famous mathematician Jerry Mao managed to reduce the hypothesis to this problem Given a number m how many polynomials P with coefficients in set 0 1 2 3 4 5 6 7 have P 2 m Help Jerry Mao solve the long standing problem ,"['/**\n *    author:  tourist\n *    created: 05.10.2020 16:10:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n\n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n\n  inline explicit operator bool() {\n    return cur != -1;\n  }\n\n  inline static bool is_blank(char c) {\n    return c <= \' \';\n  }\n\n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn\'t check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == \'-\') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - \'0\';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), ""%lf"", &n);\n    }\n    return *this;\n  }\n} fast_input;\n\n#define cin fast_input\n\nstatic struct FastOutput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t buf_pos = 0;\n  static constexpr int TMP_SIZE = 1 << 20;\n  char tmp[TMP_SIZE];\n  FILE *out = stdout;\n\n  inline void put_char(char c) {\n    buf[buf_pos++] = c;\n    if (buf_pos == BUF_SIZE) {\n      fwrite(buf, 1, buf_pos, out);\n      buf_pos = 0;\n    }\n  }\n\n  ~FastOutput() {\n    fwrite(buf, 1, buf_pos, out);\n  }\n\n  inline FastOutput& operator<<(char c) {\n    put_char(c);\n    return *this;\n  }\n\n  inline FastOutput& operator<<(const char* s) {\n    while (*s) {\n      put_char(*s++);\n    }\n    return *this;\n  }\n \n  inline FastOutput& operator<<(const string& s) {\n    for (int i = 0; i < (int) s.size(); i++) {\n      put_char(s[i]);\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline char* integer_to_string(T n) {\n    // beware of TMP_SIZE\n    char* p = tmp + TMP_SIZE - 1;\n    if (n == 0) {\n      *--p = \'0\';\n    } else {\n      bool is_negative = false;\n      if (n < 0) {\n        is_negative = true;\n        n = -n;\n      }\n      while (n > 0) {\n        *--p = (char) (\'0\' + n % 10);\n        n /= 10;\n      }\n      if (is_negative) {\n        *--p = \'-\';\n      }\n    }\n    return p;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {\n    return integer_to_string(n);\n  }\n\n  #if !defined(_WIN32) || defined(_WIN64)\n  inline char* stringify(__int128 n) {\n    return integer_to_string(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {\n    sprintf(tmp, ""%.17f"", n);\n    return tmp;\n  }\n\n  template <typename T>\n  inline FastOutput& operator<<(const T& n) {\n    auto p = stringify(n);\n    for (; *p != 0; p++) {\n      put_char(*p);\n    }\n    return *this;\n  }\n} fast_output;\n\n#define cout fast_output\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint d[123];\nMint dp[7];\nMint new_dp[7];\n\nint main() {\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long m;\n    cin >> m;\n    int len = 0;\n    while (m > 0) {\n      d[len++] = (m & 1);\n      m >>= 1;\n    }\n    for (int i = 0; i <= 6; i++) {\n      dp[i] = new_dp[i] = 0;\n    }\n    dp[0] = 1;\n    for (int it = len - 1; it >= 0; it--) {\n      if (d[it] == 0) {\n        // 0 -> 0..0\n        // 1 -> 0..2\n        // 2 -> 0..4\n        // 3 -> 0..6\n        // 4 -> 1..6\n        // 5 -> 3..6\n        // 6 -> 5..6\n        new_dp[0] = dp[0] + dp[1] + dp[2] + dp[3];\n        new_dp[1] = new_dp[2] = dp[1] + dp[2] + dp[3] + dp[4];\n        new_dp[3] = new_dp[4] = dp[2] + dp[3] + dp[4] + dp[5];\n        new_dp[5] = new_dp[6] = dp[3] + dp[4] + dp[5] + dp[6];\n      } else {\n        // 0 -> 0..1\n        // 1 -> 0..3\n        // 2 -> 0..5\n        // 3 -> 0..6\n        // 4 -> 2..6\n        // 5 -> 4..6\n        // 6 -> 6..6\n        new_dp[0] = new_dp[1] = dp[0] + dp[1] + dp[2] + dp[3];\n        new_dp[2] = new_dp[3] = dp[1] + dp[2] + dp[3] + dp[4];\n        new_dp[4] = new_dp[5] = dp[2] + dp[3] + dp[4] + dp[5];\n        new_dp[6] = dp[3] + dp[4] + dp[5] + dp[6];\n      }\n      swap(dp, new_dp);\n    }\n    cout << dp[0]() << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']","['bitmasks', 'constructive algorithms', 'dp', 'math']",2400
https://codeforces.com//contest/1608/problem/D,D. Dominoes,You are given n dominoes Each domino has a left and a right cell Each cell can be colored either black or white Some cells are already colored while some aren t yet The coloring is said to be if and only if it is possible to rearrange the dominoes in some order such that for each 1 le i le n the color of the right cell of the i th domino is different from the color of the left cell of the i bmod n 1 st domino Note that you can t rotate the dominoes so the left cell always remains the left cell and the right cell always remains the right cell Count the number of valid ways to color the yet uncolored cells of dominoes Two ways are considered different if there is a cell that is colored white in one way and black in the other In particular colorings and different and both invalid As this number can be very big output it modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nint getval(char c){\n\tif(c==\'W\')return 0;\n\telse if(c==\'B\')return 1;\n\telse return 2;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<array<int,2>> a(n);\n\trep(i,n){\n\t\tstring s;cin>>s;\n\t\trep(j,2)a[i][j]=getval(s[j]);\n\t}\n\tmint ans=0;\n\t{\n\t\tint cnt[3]{};\n\t\trep(i,n)rep(j,2)cnt[a[i][j]]++;\n\t\tif(cnt[0]<=n&&cnt[1]<=n){\n\t\t\tans=choose(cnt[2],n-cnt[0]);\n\t\t}\n\t}\n\t{\n\t\tmint w=1;\n\t\tbool allok[2]{true,true};\n\t\trep(i,n){\n\t\t\tint v=0;\n\t\t\trep(k,2){\n\t\t\t\tbool ok=true;\n\t\t\t\trep(j,2){\n\t\t\t\t\tif(a[i][j]==(((k+j)%2)^1))\n\t\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t\tif(ok)v++;\n\t\t\t\telse allok[k]=false;\n\t\t\t}\n\t\t\tw*=v;\n\t\t}\n\t\tans-=w;\n\t\trep(k,2)if(allok[k])ans+=1;\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['combinatorics', 'fft', 'graphs', 'math', 'number theory']",2400
https://codeforces.com//contest/107/problem/B,B. Basketball Team,As a German University in Cairo GUC student and a basketball player Herr Wafa was delighted once he heard the news GUC is finally participating in the Annual Basketball Competition ABC A team is to be formed of players all of which are GUC students However the team might have players belonging to different departments There are departments in GUC numbered from to Herr Wafa s department has number For each department Herr Wafa knows number how many students who play basketball belong to this department Herr Wafa was also able to guarantee a spot on the team using his special powers But since he hates floating point numbers he needs your help at finding the probability that he will have at least one teammate belonging to his department Note that every possible team containing Herr Wafa is equally probable Consider all the students different from each other ,"['/*\n * b.cpp\n *\n *  Created on: 2011-8-23\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 1000 + 10;\nint s[MAX_N];\n\nint main() {\n\tint n, m, h;\n\tint A = 0;\n\tcin >> n >> m >> h;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcin >> s[i];\n\t\tA += s[i];\n\t}\n\tint B = A - s[h];\n\t--A;\n\tint x = n - 1;\n\tdouble ans = 1;\n\tif (A < x) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif (B < x) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = B + 1; i <= A; ++i) {\n\t\tans /= i;\n\t}\n\tfor (int i = B - x + 1; i <= A - x; ++i) {\n\t\tans *= i;\n\t}\n\tprintf(""%0.10lf\\n"", 1 - ans);\n\treturn 0;\n}\n']","['combinatorics', 'dp', 'math', 'probabilities']",1600
https://codeforces.com//contest/1084/problem/A,A. The Fair Nut and Elevator,The Fair Nut lives in n story house a i people live on the i th floor of the house Every person uses elevator twice a day to get from the floor where he she lives to the ground first floor and to get from the first floor to the floor where he she lives when he she comes back home in the evening It was decided that elevator when it is not used will stay on the x th floor but x hasn t been chosen yet When a person needs to get from floor a to floor b elevator follows the simple algorithm Moves from the x th floor initially it stays on the x th floor to the a th and takes the passenger Moves from the a th floor to the b th floor and lets out the passenger if a equals b elevator just opens and closes the doors comes to the floor from the x th floor Moves from the b th floor back to the x th The elevator never transposes more than one person and always goes back to the floor x before transposing a next passenger The elevator spends one unit of electricity to move between neighboring floors So moving from the a th floor to the b th floor requires a b units of electricity Your task is to help Nut to find the minimum number of electricity units that it would be enough for one day by choosing an optimal the x th floor Don t forget than elevator initially stays on the x th floor ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int n; cin >> n;\n    int data[n]; F0R(i, n) cin >> data[i];\n\n    int best = 1000000000;\n    F0R(i, n) {\n        int curTotal = 0;\n        F0R(j, n) {\n            int perPerson = i + j + abs(i-j);\n            curTotal += perPerson * data[j] * 2;\n        }\n        best = min(best, curTotal);\n    }\n\n    cout << best << endl;\n\n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343']","['brute force', 'implementation']",1000
https://codeforces.com//contest/1759/problem/F,F. All Possible Digits,A positive number x of length n in base p 2 le p le 10 9 is written on the blackboard The number x is given as a sequence a 1 a 2 dots a n 0 le a i p the digits of x in order from left to right most significant to least significant Dmitry is very fond of all the digits of this number system so he wants to see each of them at least once In one operation he can take any number x written on the board increase it by 1 and write the new value x 1 on the board For example p 5 and x 234 5 Initially the board contains the digits 2 3 and 4 Dmitry increases the number 234 5 by 1 and writes down the number 240 5 On the board there are digits 0 2 3 4 Dmitry increases the number 240 5 by 1 and writes down the number 241 5 Now the board contains all the digits from 0 to 4 Your task is to determine the minimum number of operations required to make all the digits from 0 to p 1 appear on the board at least once ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nconst int N = 400400;\nint tree[N * 4];\n\nint get_min(int l, int r, int v, int tl, int tr) {\n    //вариант 1\n    if (l <= tl && tr <= r) {\n        return tree[v];\n    }\n\n    //вариант 2\n    if (tr < l || r < tl) {\n        return 0;\n    }\n\n    //вариант 3\n    int tm = (tl + tr) / 2;\n    return max(get_min(l, r, v * 2 + 1,     tl,     tm),    //минимум вместо суммы.\n               get_min(l, r, v * 2 + 2, tm + 1, tr));\n}\n\nvoid update(int idx, int val, int v, int tl, int tr) {\n    //вариант 1\n    if (idx <= tl && tr <= idx) {       //То же, что и idx == tl == tr\n        tree[v] = val;\n        return;\n    }\n    //вариант 2\n    if (tr < idx || idx < tl) {\n        return;\n    }\n\n    int tm = (tl + tr) / 2;\n    update(idx, val, v * 2 + 1,     tl,     tm);\n    update(idx, val, v * 2 + 2, tm + 1, tr);\n    tree[v] = max(tree[v * 2 + 1], tree[v * 2 + 2]);    //минимум вместо суммы.\n}\n\nint n, k;\nbool isJoined(vector<pii> p) {\n    int mx = -1;\n    sort(begin(p), end(p));\n//    if(p.empty() || p[0].F != 0) return false;\n    for(auto &i : p) {\n        if(i.F > mx + 1) return false;\n        mx = max(mx, i.S);\n    }\n    return mx == k - 1;\n}\nvoid solve(){\n    cin >> n >> k;\n    int a[n];\n    vector<pii> d;\n    for(int i = 0; i < n; ++i) cin >> a[i], d.pb({a[i], a[i]});\n    int l = 0, r = k - a[n - 1] - 1, ans = -1;\n    while(l <= r) {\n        int m = l + r >> 1;\n        d.pb({a[n - 1], a[n - 1] + m});\n        if(isJoined(d)) {\n            ans = m;\n            r = m - 1;\n        } else {\n            l = m + 1;\n        }\n        d.pop_back();\n    }\n    if(ans != -1) {\n        cout << ans << endl;\n        return;\n    }\n    int curAns = r + 1;\n    d.pb({0, 0});\n    int x = n - 2;\n    while(x >= 0) {\n        if(a[x] == k - 1) {\n            x--;\n        } else {\n            a[x]++;\n            d.pb({a[x], a[x]});\n            break;\n        }\n    }\n    d.pb({a[n - 1], k - 1});\n    if(x == -1) d.pb({1, 1});\n\n    l = 0, r = k - 1, ans = -1;\n    while(l <= r) {\n        int m = l + r >> 1;\n        d.pb({0, m});\n        if(isJoined(d)) {\n            ans = m;\n            r = m - 1;\n        } else {\n            l = m + 1;\n        }\n        d.pop_back();\n    }\n    cout << curAns + ans << endl;\n\n\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']","['binary search', 'data structures', 'greedy', 'math', 'number theory']",1800
https://codeforces.com//contest/914/problem/B,B. Conan and Agasa play a Card Game,Edogawa Conan got tired of solving cases and invited his friend Professor Agasa over They decided to play a game of cards Conan has cards and the th card has a number written on it They take turns playing starting with Conan In each turn the player chooses a card and removes it Also he removes all cards having a number strictly lesser than the number on the chosen card Formally if the player chooses the th card he removes that card and removes the th card for all such that A player loses if he cannot make a move on his turn that is he loses if there are no cards left Predict the outcome of the game assuming both players play optimally ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=110000;\nint a[N],n;\nint d[N],m;\nint main(){\n\tscanf(""%d"",&n);\n\trep(i,1,n)scanf(""%d"",&a[i]);\n\tsort(a+1,a+1+n);\n\trep(i,1,n){\n\t\tint j=i;\n\t\twhile(j<n&&a[j+1]==a[i])++j;\n\t\td[++m]=j-i+1;\n\t\ti=j;\n\t}\n\trep(i,1,m){\n\t\tif(d[i]%2==1){\n\t\t\tputs(""Conan"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""Agasa"");\n\treturn 0;\n}\n\n\n\n']","['games', 'greedy', 'implementation']",1200
https://codeforces.com//contest/776/problem/G,G. Sherlock and the Encrypted Data,Sherlock found a piece of encrypted data which he thinks will be useful to catch Moriarty The encrypted data consists of two integer and He noticed that these integers were in hexadecimal form He takes each of the integers from to and performs the following operations He lists the distinct digits present in the given number For example for he lists the digits as Then he sums respective powers of two for each digit listed in the step above Like in the above example He changes the initial number by applying bitwise of the initial number and the sum Example Note that is done in binary notation One more example for integer the sum is Letters denote hexadecimal digits respertively Sherlock wants to count the numbers in the range from to both inclusive which decrease on application of the above four steps He wants you to answer his queries for different and ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[20], n;\nlong long po[20];\nlong long Get(int a, int b){ // biggest : a, 2^b : 1\n    if(a==0)return 0;\n    if(4*n<=b)return 0;\n    int i, j, pp = 1 << (b%4), ccc = 0, ck = 0;\n    po[0] = 1;\n    for(i=1;i<n;i++){\n        po[i]=po[i-1] * (a+1);\n    }\n    for(i=0;i<=a;i++){\n        if(i&pp)ccc++;\n    }\n    long long res = 0;\n    for(i=n-1;i>=0;i--){\n        int ppp = 0;\n        if(i*4 <= b && b < (i+1)*4){\n            ppp = 1 << (b-i*4);\n            ck = 1;\n        }\n        for(j=0;j<=a;j++){\n            if(j >= w[i])continue;\n            if(ck==0){\n                res += po[i-1] * ccc;\n            }\n            if(ck==1){\n                if((j&ppp)!=ppp)continue;\n            }\n            if(ck){\n                res += po[i];\n            }\n        }\n        if(w[i] > a)break;\n        if(ck == 1 && (w[i] & ppp)!=ppp)break;\n        if(ck)ck = 2;\n    }\n    return res;\n}\nlong long Calc(long long a){\n    if(a < 1)a = 1;\n    n = 0;\n    while(a){\n        w[n++] = a%16;\n        a/=16;\n    }\n    long long s = 0;\n    int i;\n    for(i=1;i<=15;i++){\n        s += Get(i, i) - Get(i-1, i);\n    }\n    return s;\n}\nint main(){\n    int Q;\n    long long L, R;\n    scanf(""%d"",&Q);\n    while(Q--){\n        scanf(""%llx%llx"",&L,&R);\n        printf(""%lld\\n"",Calc(R+1) - Calc(L));\n    }\n}']","['bitmasks', 'combinatorics', 'dp']",2900
https://codeforces.com//contest/1690/problem/G,G. Count the Trains,There are n of independent carriages on the rails The carriages are numbered from left to right from 1 to n The carriages are not connected to each other The carriages move to the left so that the carriage with number 1 moves ahead of all of them The i th carriage has its own engine which can accelerate the carriage to a i km h but the carriage cannot go faster than the carriage in front of it See example for explanation All carriages start moving to the left at the same time and they naturally form We will call consecutive moving carriages having the same speed For example we have n 5 carriages and array a 10 13 5 2 6 Then the final speeds of the carriages will be 10 10 5 2 2 Respectively 3 of the train will be formed There are also messages saying that some engine has been corrupted message means that the speed of the k th carriage has decreased by d that is there has been a change in the maximum speed of the carriage a k a k d Messages arrive sequentially the processing of the next message takes into account the changes from all previous messages After each message determine the number of formed trains ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1\'000\'000\'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nstruct SegTree{\n    vector<int> tree;\n    int len;\n    vector<int> md;\n    void init(int n){\n        len = 1;\n        while (len < n){\n            len *= 2;\n        }\n        tree.assign(2 * len, 0);\n        md.assign(2 * len, -1);\n    }\n    void push(int v, int l, int r){\n        if (l + 1 == r){\n            return;\n        }\n        int m = (l + r) / 2;\n        if (md[v] != -1){\n            tree[2 * v] = (m - l) * md[v];\n            tree[2 * v + 1] = (r - m) * md[v];\n            md[2 * v] = md[2 * v + 1] = md[v];\n            md[v] = -1;\n        }\n    }\n    void update(int v, int l, int r, int ql, int qr, int d){\n        if (max(ql, l) >= min(qr, r)){\n            return;\n        }\n        if (ql <= l && r <= qr){\n            tree[v] = (r - l) * d;\n            md[v] = d;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(v, l, r);\n        update(2 * v, l, m, ql, qr, d), update(2 * v + 1, m, r, ql, qr, d);\n        tree[v] = tree[2 * v] + tree[2 * v + 1];\n    }\n    void update(int l, int r, int d){\n        update(1, 0, len, l, r + 1, d);\n    }\n    int get(int v, int l, int r, int ql, int qr){\n        if (max(ql, l) >= min(r, qr)){\n            return 0;\n        }\n        if (ql <= l && r <= qr){\n            return tree[v];\n        }\n        int m = (l + r) / 2;\n        push(v, l, r);\n        return get(2 * v, l, m, ql, qr) + get(2 * v + 1, m, r, ql, qr);\n    }\n    int get(int l, int r){\n        return get(1, 0, len, l, r + 1);\n    }\n};\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<int> p(n);\n    p[0] = a[0];\n    for (int i = 1; i < n; i++) p[i] = min(p[i - 1], a[i]);\n    vector<int> id(n);\n    id[0] = 1;\n    for (int i = 1; i < n; i++) id[i] = p[i] != p[i - 1];\n    SegTree stid, stp;\n    stid.init(n);\n    for (int i = 0; i < n; i++) stid.update(i, i, id[i]);\n    stp.init(n);\n    for (int i = 0; i < n; i++) stp.update(i, i, p[i]);\n    while (m--){\n        int k, d;\n        cin >> k >> d;\n        k--;\n        a[k] -= d;\n        if (a[k] < stp.get(k, k)){\n            int left = k, right = n;\n            while (right - left > 1) {\n                int mid = (left + right) / 2;\n                if (a[k] <= stp.get(mid, mid)) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n            stp.update(k, left, a[k]);\n            stid.update(k, left, 0);\n            stid.update(k, k, 1);\n        }\n        cout << stid.get(0, n - 1) << "" "";\n    }\n    cout << ""\\n"";\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}']","['binary search', 'data structures', 'greedy', 'sortings']",2000
https://codeforces.com//contest/220/problem/E,E. Little Elephant and Inversions,The Little Elephant has array consisting of positive integers indexed from 1 to Let s denote the number with index as The Little Elephant wants to count how many pairs of integers and are there such that and sequence has no more than inversions An in sequence is a pair of elements of the sequence that change their relative order after a stable sorting of the sequence In other words an inversion is a pair of integers and such that and where is the length of sequence and is its th element Help the Little Elephant and count the number of the described pairs ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint in[101000];\nint in2[101000];\nint n;\nlong long k;\nmap<int,int> xx;\nint tre[101000];\nint tb[101000];\nint xn;\ninline void add(int* tr,int x,int c=1){\n    for(;x<=xn;x+=x&-x)tr[x]+=c;\n}\ninline int que(int* tr,int x){\n    int r=0;\n    for(;x;x-=x&-x)r+=tr[x];\n    return r;\n}\ninline long long solve(){\n    long long ss=0;\n    int i,j;\n    for(j=n-1;j>=0;j--){\n        int x=que(tb,in[j]-1);\n        if(ss+x>k){\n            j++;\n            break;\n        }\n        ss+=x;\n        add(tb,in[j]);\n    }\n    if(j==-1)return n*(n-1ll)/2;\n    long long ret=0;\n    for(i=0;i<n;i++){\n        ss+=que(tre,xn+1-in[i]-1);\n        ss+=que(tb,in[i]-1);\n        add(tre,xn+1-in[i]);\n        for(;j<n;j++){\n            if(ss<=k)break;\n            ss-=que(tre,xn+1-in[j]-1);\n            ss-=que(tb,in[j]-1);\n            add(tb,in[j],-1);\n        }\n        if(j==n)break;\n        ret+=n-j;\n    }\n    return ret;\n}\nint main(){\n    int i,j;\n    scanf(""%d%I64d"",&n,&k);\n    for(i=0;i<n;i++){\n        scanf(""%d"",&in[i]);\n        in2[i]=in[i];\n    }\n    //lshua\n    sort(in2,in2+n);\n    xn=unique(in2,in2+n)-in2;\n    for(i=0;i<xn;i++)xx[in2[i]]=i;\n    for(i=0;i<n;i++)in[i]=xx[in[i]]+1;\n    printf(""%I64d\\n"",solve());\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","['data structures', 'two pointers']",2400
https://codeforces.com//contest/1463/problem/F,F. Max Correct Set,Let s call the set of positive integers S if the following two conditions are met S subseteq 1 2 dots n if a in S and b in S then a b neq x and a b neq y For the given values n x and y you have to find the maximum size of the set ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvoid expr() {\n\tint n, x, y; cin >> n >> x >> y;\n\tfor (x = 1; x <= 22; x++)for (y = 1; y <= 22; y++) {\n\t\tvector<bool> used(101);\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\tused[i] = true;\n\t\t\tif (i - x >= 0 && used[i - x])used[i] = false;\n\t\t\tif (i - y >= 0 && used[i - y])used[i] = false;\n\t\t}\n\t\tint cyc = x + y;\n\t\tint ans = 1;\n\t\trep1(i, cyc) {\n\t\t\tif (used[i] != used[i + cyc]) {\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t}\n\t\tcout << x << "" "" << y << "" "" << ans << ""\\n"";\n\t}\n}\nbool used[100];\nvoid solve() {\n\tint n, x, y; cin >> n >> x >> y;\n\tint d = x + y;\n\tint d1 = d / 2;\n\tint d2 = d - d1;\n\tint c = n / d;\n\tint r = n % d;\n\tvector<int> val(1 << d2,0);\n\trep(i, (1 << d2)) {\n\t\tbool valid = true;\n\t\trep(j, d2)used[j] = false;\n\t\trep(j, d2) {\n\t\t\tif (i & (1 << j))used[j] = true;\n\t\t}\n\t\trep(j, d2)if(used[j]) {\n\t\t\tif (j - x >= 0 && used[j - x])valid = false;\n\t\t\tif (j - y >= 0 && used[j - y])valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint num = 0;\n\t\trep(j, d2)if (used[j])num++;\n\t\tint sum = num * c;\n\t\trep(j, d2)if (j + d1 < r && used[j])sum++;\n\t\tval[i] = sum;\n\t}\n\trep(i, (1 << d2))rep(j, d2)if (i & (1 << j)) {\n\t\tval[i] = max(val[i], val[i ^ (1 << j)]);\n\t}\n\tint ans = 0;\n\trep(i, (1 << d1)) {\n\t\tbool valid = true;\n\t\trep(j, d1)used[j] = false;\n\t\trep(j, d1)if (i & (1 << j))used[j] = true;\n\t\trep(j, d1)if(used[j]) {\n\t\t\tif (j - x >= 0 && used[j - x])valid = false;\n\t\t\tif (j - y >= 0 && used[j - y])valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint ban = 0;\n\t\trep(j, d1)if (used[j]) {\n\t\t\tif (j + x >= d1&&j+x<d) {\n\t\t\t\tban |= (1 << j + x - d1);\n\t\t\t}\n\t\t\tif (j + y >= d1 && j + y < d) {\n\t\t\t\tban |= (1 << j + y - d1);\n\t\t\t}\n\t\t}\n\t\tban = (1 << d2) - 1 - ban;\n\n\t\tint num = 0; rep(j, d1)if (used[j])num++;\n\t\tint sum = num * c;\n\t\trep(j, d1)if (used[j])if (j < r)sum++;\n\t\t\n\t\tans = max(ans, sum + val[ban]);\n\t}\n\tcout << ans << ""\\n"";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']","['bitmasks', 'dp', 'math']",3100
https://codeforces.com//contest/1548/problem/E,E. Gregor and the Two Painters,Two painters Amin and Benj are repainting Gregor s living room ceiling The ceiling can be modeled as an n times m grid For each i between 1 and n inclusive painter Amin applies a i layers of paint to the entire i th row For each j between 1 and m inclusive painter Benj applies b j layers of paint to the entire j th column Therefore the cell i j ends up with a i b j layers of paint Gregor considers the cell i j to be if a i b j le x Define a to be a connected component of badly painted cells i e a connected component of badly painted cells such that all adjacent to the component cells are not badly painted Two cells are considered adjacent if they share a side Gregor is appalled by the state of the finished ceiling and wants to know the number of badly painted regions ,"['//别丢包了！\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nint d[maxn];\nint lb (int x) {\n    return x & -x;\n}\nvoid ins(int pl, int x) {\n    while (pl < maxn) {\n        d[pl] += x;\n        pl += lb(pl);\n    }\n}\nint q(int a) {\n    int ans = 0;\n    while (a) {\n        ans += d[a]; a -= lb(a);\n    }\n    return ans;\n}\nvi u, v;\nstruct rg {\n    int p;\n    int l, r; // l >= 1, r < maxn\n    rg() {}\n};\nvector<pi> act[maxn], ask[maxn];\nll wk(vector<rg> a, vector<rg> b) {\n    for (auto v : a)\n        act[v.p].pb(mp(v.l, v.r));\n    for (auto v : b) {\n        ask[v.l - 1].pb(mp(v.p, -1));\n        ask[v.r].pb(mp(v.p, 1));\n    }\n    ll ans = 0;\n    for (int i = 1; i < maxn; i++) {\n        for (auto v : act[i])\n            ins(v.fi, 1), ins(v.se + 1, -1);\n        for (auto v : ask[i])\n            ans += q(v.fi) * v.se;\n    }\n    return ans;\n}\nint mx[maxn][20];\nint mb[maxn];\nint qmx(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return max(mx[l][j], mx[r - (1 << j) + 1][j]);\n}\nint st[maxn], top = 0;\nint n, m, x;\nvector<rg> gt(vi a) {\n    #define ar3 array<int, 3>\n    int n = a.size();\n    vector<ar3> tot;\n    for (int i = 0; i < maxn; i++)\n        for (int j = 0; j < 20; j++)\n            if ((1 << j) <= i) mb[i] = j;\n    for (int i = 0; i < 20; i++)\n        for (int j = 0; j < n - (1 << i) + 1; j++) {\n            if (i == 0) mx[j][i] = a[j];\n            else {\n                mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    for (int s = 0; s < 2; s++) {\n        int top = 0;\n        for (int i = 0; i < n; i++) {\n            int cr = maxn;\n            while (top && a[st[top - 1]] > a[i]) \n                chkmin(cr, a[st[top - 1]]), top -= 1;\n            if (top) {\n                int fl = 1;\n                if (s == 1 && a[st[top - 1]] == a[i]) fl = 0;               \n                if (fl) {\n                    if (s == 0) tot.pb((ar3){st[top - 1], i, cr});\n                    else tot.pb((ar3){n - 1 - i, n - 1 - st[top - 1], cr});\n                }\n            }\n            st[top++] = i;\n        }\n        reverse(a.begin(), a.end());\n    }\n    vector<rg> res;\n    for (auto v : tot) {\n        int l = v[0], r = v[1], sc = v[2];\n        rg fn; fn.l = max(1, x + 1 - sc); fn.r = min(maxn - 1, x - max(a[l], a[r]));\n        fn.p = qmx(l, r);\n        if (fn.l > fn.r) continue;\n        res.pb(fn);\n    }\n    return res;\n}\nint fl[maxn];\nint sum = 0, s1 = 0;\nvoid inc(int x) {\n    fl[x] = 1;\n    if (fl[x - 1]) s1 += 1;\n    if (fl[x + 1]) s1 += 1;\n    sum += 1;\n}\nint main() {\n    cin >> n >> m >> x;\n    vi u[2];\n    vector<pi> s[2];\n    u[0].resize(n), u[1].resize(m);\n    for (int t = 0; t < 2; t++) {\n        for (int i = 0; i < u[t].size(); i++) {\n            scanf(""%d"", &u[t][i]);\n            s[t].pb(mp(u[t][i], i + 1));\n        }\n        sort(s[t].begin(), s[t].end());\n    }\n    /*\n    for (int i = 0; i < u[0].size(); i++) {\n        for (int j = 0; j < u[1].size(); j++) {\n            if (u[0][i] + u[1][j] <= x) cout << ""1 "";\n            else cout << ""0 "";\n        }\n        cout << endl;\n    }\n    */\n    ll ans = wk(gt(u[0]), gt(u[1]));\n    //cout << ans << endl;\n    int pl = 0;\n    for (int g = 0; g < 2; g++) {\n        sum = s1 = 0; memset(fl, 0, sizeof(fl));\n        int p = 0;\n        for (int i = s[0].size() - 1; i >= 0; i--) {\n            while (p < s[1].size() && s[1][p].fi + s[0][i].fi <= x) {\n                inc(s[1][p].se);\n                p += 1;\n            }\n            ans -= s1;\n            if (g == 0) ans += sum;\n        }\n        swap(s[0], s[1]);\n    }\n    cout << ans << endl;\n    return (0-0); //<3\n}']","['data structures', 'divide and conquer', 'graphs', 'greedy', 'math']",3400
https://codeforces.com//contest/809/problem/A,A. Do you want a date ,Leha decided to move to a quiet town Vi kopolis because he was tired by living in Bankopolis Upon arrival he immediately began to expand his network of hacked computers During the week Leha managed to get access to computers throughout the town Incidentally all the computers which were hacked by Leha lie on the same straight line due to the reason that there is the only one straight street in Vi kopolis Let s denote the coordinate system on this street Besides let s number all the hacked computers with integers from to So the th hacked computer is located at the point Moreover the coordinates of all computers are distinct Leha is determined to have a little rest after a hard week Therefore he is going to invite his friend Noora to a restaurant However the girl agrees to go on a date with the only one condition Leha have to solve a simple task Leha should calculate a sum of for all where is a non empty subset of the set that consists of all hacked computers Formally let s denote the set of all integers from to Noora asks the hacker to find value of the expression Here is calculated as the maximum among the distances between all pairs of computers from the set Formally Since the required sum can be quite large Noora asks to find it modulo Though Leha is too tired Consequently he is not able to solve this task Help the hacker to attend a date ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst long long mod=1000*1000*1000+7;\n\nint n;\nlong long tab[nax];\n\nlong long pot[nax];\n\nlong long wyn;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tsort(tab+1, tab+1+n);\n\tpot[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tpot[i]=(pot[i-1]*2)%mod;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twyn+=tab[i]*pot[i-1]-tab[i]*pot[n-i];\n\t\twyn%=mod;\n\t}\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['implementation', 'math', 'sortings']",1500
https://codeforces.com//contest/617/problem/E,E. XOR and Favorite Number,Bob has a favorite number and of length Now he asks you to answer queries Each query is given by a pair and and asks you to count the number of pairs of integers and such that and the xor of the numbers is equal to ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 2222222\n#define N 222222\n#define C 333\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\npair<pt, int> q[N];\nlong long ans[N];\nint a[N], b[N];\nint cnt[M];\n\nbool cmp(pair<pt, int> a, pair<pt, int> b) {\n    if (a.F.F / C != b.F.F / C) return a.F.F / C < b.F.F / C;\n    return a.F.S < b.F.S;\n}\n\nint main(){\n//  freopen(TASK"".in"",""r"",stdin);   \n//  freopen(TASK"".out"",""w"",stdout);\n    int n, m, k;\n    scanf(""%d%d%d"", &n, &m, &k);\n    for (int i = 0; i < n; i++) scanf(""%d"", a + i);\n    b[0] = 0;\n    for (int i = 1; i <= n; i++) b[i] = b[i - 1] ^ a[i - 1];\n    for (int i = 0; i < m; i++) {\n        scanf(""%d%d"", &q[i].F.F, &q[i].F.S);\n        --q[i].F.F;\n        q[i].S = i;\n    }\n    sort(q, q + m, cmp);\n    int l = 0;\n    int r = -1;\n    long long cur = 0;\n    for (int i = 0; i < m; i++) {\n        while (r < q[i].F.S) {\n            cur += cnt[b[++r] ^ k];\n            cnt[b[r]]++;\n        }\n        while (l > q[i].F.F) {\n            cur += cnt[b[--l] ^ k];\n            cnt[b[l]]++;\n        }\n        while (r > q[i].F.S) {\n            cnt[b[r]]--;\n            cur -= cnt[b[r--] ^ k];\n        }\n        while (l < q[i].F.F) {\n            cnt[b[l]]--;\n            cur -= cnt[b[l++] ^ k];\n        }\n        ans[q[i].S] = cur;\n    }\n    for (int i = 0; i < m; i++) printf(""%lld\\n"", ans[i]);\n}']",['data structures'],2200
https://codeforces.com//contest/1359/problem/F,F. RC Kaboom Show,You know it s hard to conduct a show with lots of participants and spectators at the same place nowadays Still you are not giving up on your dream to make a car crash showcase You decided to replace the real cars with remote controlled ones call the event Remote Control Kaboom Show and stream everything online For the preparation you arranged an arena an infinite 2D field You also bought n remote controlled cars and set them up on the arena Unfortunately the cars you bought can only go forward without turning left right or around So you additionally put the cars in the direction you want them to go To be formal for each car i 1 le i le n you chose its initial position x i y i and a direction vector dx i dy i Moreover each car has a constant speed s i units per second So after car i is launched it stars moving from x i y i in the direction dx i dy i with constant speed s i The goal of the show is to create a car collision as fast as possible You noted that launching every car at the beginning of the show often fails to produce any collisions at all Thus you plan to launch the i th car at some moment t i Note that it s not necessary for t i to be integer and t i is allowed to be equal to t j for any i j The show starts at time 0 The show ends when two cars i and j i ne j collide i e come to the same coordinate at the same time The duration of the show is the time between the start and the end What s the fastest crash you can arrange by choosing all t i If it s possible to arrange a crash then print the shortest possible duration of the show Otherwise report that it s impossible ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst ld EPS = 1E-12;\n\nconst int maxN = 25000 + 10;\nint x[maxN], y[maxN], dx[maxN], dy[maxN], ss[maxN];\nint n;\n\nstruct pt {\n    ld x, y;\n    pt(ld x, ld y) : x(x), y(y) {}\n};\n\nstruct seg {\n    pt p, q;\n    int id;\n    seg(pt& x, pt& y, int& id) : p(x), q(y), id(id) {}\n\n    double get_y (double x) const {\n        if (abs (p.x - q.x) < EPS)  return p.y;\n        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);\n    }\n};\n\n\ninline bool intersect1d (ld l1, ld r1, ld l2, ld r2) {\n    if (l1 > r1)  swap (l1, r1);\n    if (l2 > r2)  swap (l2, r2);\n    return max (l1, l2) <= min (r1, r2) + EPS;\n}\n\ninline int vec (const pt & a, const pt & b, const pt & c) {\n    ld s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    return abs(s)<EPS ? 0 : s>0 ? +1 : -1;\n}\n\nbool intersect (const seg & a, const seg & b) {\n    return intersect1d (a.p.x, a.q.x, b.p.x, b.q.x)\n           && intersect1d (a.p.y, a.q.y, b.p.y, b.q.y)\n           && vec (a.p, a.q, b.p) * vec (a.p, a.q, b.q) <= 0\n           && vec (b.p, b.q, a.p) * vec (b.p, b.q, a.q) <= 0;\n}\n\n\nbool operator< (const seg & a, const seg & b) {\n    double x = max (min (a.p.x, a.q.x), min (b.p.x, b.q.x));\n    return a.get_y(x) < b.get_y(x) - EPS;\n}\n\n\nstruct has_inter {\n\n    struct event {\n        ld x;\n        int tp, id;\n\n        event() {}\n\n        event(ld x, int tp, int id)\n            : x(x), tp(tp), id(id) {}\n\n        bool operator<(const event &e) const {\n            if (abs(x - e.x) > EPS) return x < e.x;\n            return tp > e.tp;\n        }\n    };\n\n    set<seg> s;\n    vector<set<seg>::iterator> where;\n\n    inline set<seg>::iterator prev(set<seg>::iterator it) {\n        return it == s.begin() ? s.end() : --it;\n    }\n\n    inline set<seg>::iterator next(set<seg>::iterator it) {\n        return ++it;\n    }\n\n    pair<int, int> solve(const vector<seg> &a) {\n        int n = (int) a.size();\n        vector<event> e;\n        for (int i = 0; i < n; ++i) {\n            e.push_back(event(min(a[i].p.x, a[i].q.x), +1, i));\n            e.push_back(event(max(a[i].p.x, a[i].q.x), -1, i));\n        }\n        sort(e.begin(), e.end());\n\n        s.clear();\n        where.resize(a.size());\n        for (size_t i = 0; i < e.size(); ++i) {\n            int id = e[i].id;\n            if (e[i].tp == +1) {\n                auto nxt = s.lower_bound(a[id]), prv = prev(nxt);\n                if (nxt != s.end() && intersect(*nxt, a[id]))\n                    return make_pair(nxt->id, id);\n                if (prv != s.end() && intersect(*prv, a[id]))\n                    return make_pair(prv->id, id);\n                where[id] = s.insert(nxt, a[id]);\n            } else {\n                auto nxt = next(where[id]), prv = prev(where[id]);\n                if (nxt != s.end() && prv != s.end() && intersect(*nxt, *prv))\n                    return make_pair(prv->id, nxt->id);\n                s.erase(where[id]);\n            }\n        }\n\n        return make_pair(-1, -1);\n    }\n};\nbool has(ld T) {\n    vector < seg > f;\n    for (int i = 1; i <= n; i++) {\n        pt c1{(ld)x[i], (ld)y[i]};\n        ld D = sqrt(dx[i] * dx[i] + dy[i] * dy[i]);\n        pt c2{x[i] + T * ss[i] * dx[i] / D, y[i] + T * ss[i] * dy[i] / D};\n        f.emplace_back(c1, c2, i);\n    }\n    has_inter Q;\n    return Q.solve(f).first != -1;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> dx[i] >> dy[i] >> ss[i];\n    }\n    ld l = 0;\n    ld r = 2e12;\n    if (!has(r)) {\n        cout << ""No show :("" << \'\\n\';\n    }\n    else {\n        for (int it = 0; it < 75; it++) {\n            ld mid = (l + r) / 2;\n            if (has(mid)) r = mid;\n            else l = mid;\n        }\n        cout << fixed << setprecision(12) << (l + r) / 2 << \'\\n\';\n    }\n    return 0;\n}']","['binary search', 'brute force', 'data structures', 'geometry', 'math']",2900
https://codeforces.com//contest/602/problem/B,B. Approximating a Constant Range,When Xellos was doing a practice course in university he once had to measure the intensity of an effect that slowly approached equilibrium A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average Of course with the usual sizes of data it s nothing challenging but why not make a similar programming contest problem while we re at it You re given a sequence of data points There aren t any big jumps between consecutive data points for each it s guaranteed that A range of data points is said to be if the difference between the largest and the smallest value in that range is at most Formally let be the maximum and the minimum value of for the range is almost constant if Find the length of the longest almost constant range ,"['#include <iostream>\n\nusing namespace std;\n\nint n;\nint a[110000];\nint last[110000];\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i <= 100000; i++)  {\n        last[i] = -1;\n    }\n    int l = 0;\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int x = -1;\n        if (a[i] + 2 <= 100000) {\n            x = max(x, last[a[i] + 2]);\n        }\n        if (a[i] - 2 >= 0) {\n            x = max(x, last[a[i] - 2]);\n        }\n        l = max(l, x + 1);\n        ans = max(ans, i - l + 1);\n\n        last[a[i]] = i;\n    }\n    cout << ans << endl;\n    return 0;\n}\n']","['dp', 'implementation', 'two pointers']",1400
https://codeforces.com//contest/1684/problem/C,C. Column Swapping,You are given a grid with n rows and m columns where each cell has a positive integer written on it Let s call a grid if in each row the sequence of numbers is sorted in a non decreasing order It means that for each 1 le i le n and 2 le j le m the following holds a i j ge a i j 1 You have to to do the following operation exactly once choose two columns with indexes i and j 1 le i j le m and swap them You are asked to determine whether it is possible to make the grid good after the swap and if it is find the columns that need to be swapped ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 18:38:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> a(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> a[i][j];\n      }\n    }\n    int x = -1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        if (a[i][j] > a[i][j + 1]) {\n          x = j;\n        }\n      }\n    }\n    if (x == -1) {\n      cout << ""1 1"" << endl;\n      continue;\n    }\n    auto Flag = [&](int i, int j) {\n      if (i >= 0 && j >= 0 && i < h && j < w - 1 && a[i][j] > a[i][j + 1]) {\n        return 1;\n      }\n      return 0;\n    };\n    vector<int> cnt(h);\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        cnt[i] += Flag(i, j);\n      }\n    }\n    int a0 = -1, a1 = -1;\n    for (int j0 = x; j0 <= x + 1; j0++) {\n      for (int j1 = 0; j1 < w; j1++) {\n        if (j0 == j1) {\n          continue;\n        }\n        bool inv = false;\n        if (j0 > j1) {\n          swap(j0, j1);\n          inv = true;\n        }\n        bool ok = true;\n        for (int i = 0; i < h; i++) {\n          int cc = cnt[i];\n          if (j0 + 1 == j1) {\n            cc -= Flag(i, j0 - 1);\n            cc -= Flag(i, j0);\n            cc -= Flag(i, j0 + 1);\n            swap(a[i][j0], a[i][j1]);\n            cc += Flag(i, j0 - 1);\n            cc += Flag(i, j0);\n            cc += Flag(i, j0 + 1);\n            swap(a[i][j0], a[i][j1]);\n          } else {\n            cc -= Flag(i, j0 - 1);\n            cc -= Flag(i, j0);\n            cc -= Flag(i, j1 - 1);\n            cc -= Flag(i, j1);\n            swap(a[i][j0], a[i][j1]);\n            cc += Flag(i, j0 - 1);\n            cc += Flag(i, j0);\n            cc += Flag(i, j1 - 1);\n            cc += Flag(i, j1);\n            swap(a[i][j0], a[i][j1]);\n          }\n          assert(cc >= 0);\n          if (cc > 0) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) {\n          a0 = j0;\n          a1 = j1;\n        }\n        if (inv) {\n          swap(j0, j1);\n        }\n      }\n    }\n    if (a0 == -1) {\n      cout << -1 << \'\\n\';\n    } else {\n      cout << a0 + 1 << "" "" << a1 + 1 << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","['brute force', 'constructive algorithms', 'greedy', 'implementation', 'sortings']",1400
https://codeforces.com//contest/1153/problem/B,B. Serval and Toy Bricks,Luckily Serval got onto the right bus and he came to the kindergarten on time After coming to kindergarten he found the toy bricks very funny He has a special interest to create difficult problems for others to solve This time with many 1 times 1 times 1 toy bricks he builds up a 3 dimensional object We can describe this object with a n times m matrix such that in each cell i j there are h i j bricks standing on the top of each other However Serval doesn t give you any h i j and just give you the front view left view and the top view of this object and he is now asking you to restore the object Note that in the front view there are m columns and in the i th of them the height is the maximum of h 1 i h 2 i dots h n i It is similar for the left view where there are n columns And in the top view there is an n times m matrix t i j where t i j is 0 or 1 If t i j equals 1 that means h i j 0 otherwise h i j 0 However Serval is very lonely because others are bored about his unsolvable problems before and refused to solve this one although this time he promises there will be at least one object satisfying all the views As his best friend can you have a try ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e2;\n\nint n, m, h, a[MAXN], b[MAXN], c[MAXN][MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n >> m >> h;\n\tfor(int i=0; i<m; ++i)\n\t\tcin >> a[i];\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> b[i];\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<m; ++j) {\n\t\t\tcin >> c[i][j];\n\t\t\tif(c[i][j])\n\t\t\t\tc[i][j]=min(a[j], b[i]);\n\t\t\tcout << c[i][j] << "" "";\n\t\t}\n\t\tcout << ""\\n"";\n\t}\n\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy']",1200
https://codeforces.com//contest/61/problem/C,C. Capture Valerian,It s now AD Shapur being extremely smart became the King of Persia He is now called Shapur His majesty King of kings of Iran and Aniran Recently the Romans declared war on Persia They dreamed to occupy Armenia In the recent war the Romans were badly defeated Now their senior army general Philip is captured by Shapur and Shapur is now going to capture Valerian the Roman emperor Being defeated the cowardly Valerian hid in a room at the top of one of his castles To capture him Shapur has to open many doors Fortunately Valerian was too scared to make impenetrable locks for the doors Each door has parts The first part is an integer number The second part is either an integer number or some really odd sign which looks like The third one is an integer and the fourth part is empty As if it was laid for writing something Being extremely gifted after opening the first few doors Shapur found out the secret behind the locks is an integer written in base to open the door we should write it in base The only bad news is that this is some sort of special numbering system that is used only in Roman empire so opening the doors is not just a piece of cake Here s an explanation of this really weird number system that even doesn t have zero Roman numerals are based on seven symbols a stroke identified with the letter for a unit a chevron identified with the letter for a five a cross stroke identified with the letter for a ten a identified as an abbreviation of Centum for a hundred etc Symbols are iterated to produce multiples of the decimal values with substituted for a multiple of five and the iteration continuing etc and the same for other bases etc At the fourth and ninth iteration a subtractive principle must be employed with the base placed before the higher base Also in bases greater than we use for for etc Help Shapur capture Valerian and bring peace back to Persia especially Armenia ,"['# include <cstdio>\n\nchar conv[]=""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"";\n\nvoid printroman(long long N)\n{\n    while(N>=1000)\n    {\n        printf(""M"");\n        N-=1000;\n    }\n    while(N>=900)\n    {\n        printf(""CM"");\n        N-=900;\n    }\n    while(N>=500)\n    {\n        printf(""D"");\n        N-=500;\n    }\n    while(N>=400)\n    {\n        printf(""CD"");\n        N-=400;\n    }\n    while(N>=100)\n    {\n        printf(""C"");\n        N-=100;\n    }\n    while(N>=90)\n    {\n        printf(""XC"");\n        N-=90;\n    }\n    while(N>=50)\n    {\n        printf(""L"");\n        N-=50;\n    }\n    while(N>=40)\n    {\n        printf(""XL"");\n        N-=40;\n    }\n    while(N>=10)\n    {\n        printf(""X"");\n        N-=10;\n    }\n    while(N>=9)\n    {\n        printf(""IX"");\n        N-=9;\n    }\n    while(N>=5)\n    {\n        printf(""V"");\n        N-=5;\n    }\n    while(N>=4)\n    {\n        printf(""IV"");\n        N-=4;\n    }\n    while(N>=1)\n    {\n        printf(""I"");\n        N-=1;\n    }\n}\n\nlong long toint(char *inp,int base)\n{\n    long long ret=0ll;\n    for(int i=0;inp[i];i++)\n        ret=ret*base+(inp[i]<\'A\'?inp[i]-\'0\':inp[i]-\'A\'+10);\n    return ret;\n}\n\nvoid printbase(long long N,int base)\n{\n    if(N>=base)printbase(N/base,base);\n    printf(""%c"",conv[N%base]);\n}\n\nint main()\n{\n    int A;\n    scanf(""%d"",&A);\n    \n    char B[3];\n    scanf(""%s"",B);\n    \n    int b;\n    if(B[0]!=\'R\')sscanf(B,""%d"",&b);\n    \n    char C[1001];\n    scanf(""%s"",C);\n    \n    long long I=toint(C,A);\n\n    if(B[0]==\'R\')\n        printroman(I);\n    else\n        printbase(I,b);\n    printf(""\\n"");\n    \n    return 0;\n}\n']",['math'],2000
https://codeforces.com//contest/1692/problem/H,H. Gambling,Marian is at a casino The game at the casino works like this Before each round the player selects a number between 1 and 10 9 After that a dice with 10 9 faces is rolled so that a random number between 1 and 10 9 appears If the player guesses the number correctly their total money is doubled else their total money is halved Marian predicted the future and knows all the numbers x 1 x 2 dots x n that the dice will show in the next n rounds He will pick three integers a l and r l leq r He will play r l 1 rounds rounds between l and r inclusive In each of these rounds he will guess the same number a At the start before the round l he has 1 dollar Marian asks you to determine the integers a l and r 1 leq a leq 10 9 1 leq l leq r leq n such that he makes the most money at the end Note that during halving and multiplying there is no rounding and there are no precision errors So for example during a game Marian could have money equal to dfrac 1 1024 dfrac 1 128 dfrac 1 2 1 2 4 etc any value of 2 t where t is an integer of any sign ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""H""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        cin >> a;\n        map<int, vector<int>> pos;\n        for(int i = 0; i < n; ++i)\n            pos[a[i]].push_back(i);\n        int bal = -n - 1, left = 0, right = 0, ans = 0;\n        for(auto [c, v] : pos) {\n            int cur = 0, mn = n + 1, mx = -n - 1, prev = 0, curl = 0, l = 0, r = 0;\n            for(auto i : v) {\n                cur += prev - i;\n                prev = i;\n                if (cur < mn) {\n                    mn = cur;\n                    curl = i;\n                }\n                cur++;\n                if (mx < cur - mn) {\n                    mx = cur - mn;\n                    l = curl;\n                    r = i;\n                }\n                prev = i + 1;\n            }\n            if (mx > bal) {\n                left = l;\n                right = r;\n                ans = c;\n                bal = mx;\n            }\n        }\n        cout << ans << \' \' << left + 1 << \' \' << right + 1 << endl;\n    }\n}']","['data structures', 'dp', 'greedy', 'math']",1700
https://codeforces.com//contest/1682/problem/E,E. Unordered Swaps,Alice had a permutation p of numbers from 1 to n Alice can swap a pair x y which means swapping elements at positions x and y in p i e swap p x and p y Alice recently learned her first sorting algorithm so she decided to sort her permutation in the number of swaps possible She wrote down all the swaps in the order in which she performed them to sort the permutation on a piece of paper For example 2 3 1 3 is a valid swap sequence by Alice for permutation p 3 1 2 whereas 1 3 2 3 is not because it doesn t sort the permutation Note that we cannot sort the permutation in less than 2 swaps 1 2 2 3 2 4 2 3 cannot be a sequence of swaps by Alice for p 2 1 4 3 even if it sorts the permutation because p can be sorted in 2 swaps for example using the sequence 4 3 1 2 Unfortunately Bob shuffled the sequence of swaps written by Alice You are given Alice s permutation p and the swaps performed by Alice in arbitrary order Can you restore the correct sequence of swaps that sorts the permutation p Since Alice wrote correct swaps before Bob shuffled them up it is guaranteed that there exists some order of swaps that sorts the permutation ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[200005];\nint hson[200005],fa[200005],dep[200005],sz[200005],top[200005],dfn[200005],fin[200005],dfc,rnk[200005];\n\nint hldprec(int x,int p,int d){\n    dep[x]=d;\n    sz[x]=1;\n    for(int& y:g[x])if(y!=p){\n        sz[x]+=hldprec(y,x,d+1);\n        fa[y]=x;\n        if(sz[y]>sz[hson[x]]){\n            hson[x]=y;\n        }\n    }\n    return sz[x];\n}\n\nvoid hlddec(int x,int head){\n    top[x]=head;\n    dfn[x]=++dfc;\n    rnk[dfc]=x;\n    if(hson[x]){\n        hlddec(hson[x],head);\n        for(int &y:g[x])if(y!=fa[x]&&y!=hson[x]){\n            hlddec(y,y);\n        }\n    }\n    fin[x]=dfc;\n}\n\nint lca(int u,int v){\n    while(top[u]!=top[v]){\n        if(dep[top[u]]>dep[top[v]]){\n            u=fa[top[u]];\n        }else{\n            v=fa[top[v]];\n        }\n    }\n    return dep[u]<dep[v]?u:v;\n}\n\nint n,m,p[200005],u[200005],v[200005];\nmap<pair<int,int>,int> id;\n\nint nxt(int u){\n    if(p[u]==u)return u;\n    else if(lca(p[u],u)!=u)return fa[u];\n    else{\n        int v=p[u];\n        while(true){\n            if(top[v]==top[u])return rnk[dfn[u]+1];\n            if(fa[top[v]]==u)return top[v];\n            v=fa[top[v]];\n        }\n    }\n}\n\nstruct UnionFind{\n    int n;\n    vector<int> fa;\n\n    UnionFind(int _n=0){\n        fa.resize((n=_n)+1);\n        iota(fa.begin(),fa.end(),0);\n    }\n\n    int find(int x){\n        return fa[x]==x?x:fa[x]=find(fa[x]);\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        fa[x]=y;\n    }\n};\n\nint main(){\n\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)cin>>p[i];\n    queue<int> q;\n    UnionFind uf(n);\n    for(int i=1;i<=m;i++){\n        cin>>u[i]>>v[i];\n        id[{u[i],v[i]}]=i;\n        id[{v[i],u[i]}]=i;\n        g[u[i]].emplace_back(v[i]);\n        g[v[i]].emplace_back(u[i]);\n        uf.unite(u[i],v[i]);\n    }\n    for(int i=1;i<=n;i++)if(uf.find(i)!=uf.find(1)){\n        g[i].emplace_back(1);\n        g[1].emplace_back(i);\n        uf.unite(1,i);\n    }\n    hldprec(1,-1,0);\n    hlddec(1,1);\n    for(int i=1;i<=m;i++){\n        if(nxt(u[i])==v[i]&&nxt(v[i])==u[i]){\n            q.emplace(i);\n        }\n    }\n    while(!q.empty()){\n        int i=q.front();\n        q.pop();\n        cout<<i<<' ';\n        swap(p[u[i]],p[v[i]]);\n        int nu=nxt(u[i]),nv=nxt(v[i]);\n        if(nu!=u[i]&&nxt(nu)==u[i]){\n            q.emplace(id[{nu,u[i]}]);\n        }\n        if(nv!=v[i]&&nxt(nv)==v[i]){\n            q.emplace(id[{nv,v[i]}]);\n        }\n    }\n    cout<<'\\n';\n\n    return 0;\n}\n""]","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'math', 'sortings', 'trees']",2700
https://codeforces.com//contest/1819/problem/F,"F. Willy-nilly, Crack, Into Release ",You have long dreamed of working in a large IT company and finally got a job there You have studied all existing modern technologies for a long time and are ready to apply all your knowledge in practice But then you sit down at your desk and see a sheet of paper with the company s motto printed in large letters The company s motto contains four main principles Willi Nilli Crack Release Therefore you consider strings of length n consisting of these four Latin letters pairs of letters and in this motto are adjacent so we will call such pairs of symbols So if you are given a string s of length n and it is known that the unordered pair of symbols x y is good then you can perform one of the following operations on the string if s n x then you are allowed to replace this symbol with y if there exists 1 le i n such that s i x and s i 1 ldots s n y then you are allowed to replace the i th symbol of the string with y and all subsequent symbols with x For example the string can be replaced with one of the strings or and the string can be replaced with or A non empty sequence of operations for the string s will be called if the following two conditions are met after performing all operations the string becomes s again no string except for s will occur more than once during the operations At the same time the string s can occur exactly twice before the start of the operations and after performing all operations Now we are ready to move on to the problem statement You have a set of strings that is initially empty Then each of q queries adds another string t i to the set or removes the string t i from the set After each query you need to output the minimum and maximum size of a correct sequence of operations in which each word occurs at least once The choice of the initial string s is up to you ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nstruct N{\n\tN*to[4];\n\tint cnt=0,mn[4][4],mx[4][4];\n\tN(){\n\t\trep(i,4)to[i]=0;\n\t\trep(i,4)rep(j,4)mn[i][j]=inf;\n\t\trep(i,4)rep(j,4)mx[i][j]=-inf;\n\t}\n\tint gmi(int x,int y){\n\t\treturn min(mn[x][y],mn[y][x]);\n\t}\n\tint gma(int x,int y){\n\t\treturn max(mx[x][y],mx[y][x]);\n\t}\n\tvoid upd(){\n\t\tcnt=0;\n\t\trep(i,4)cnt+=to[i]->cnt;\n\t\trep(i,4){\n\t\t\tint cs=0,mis=0,mas=0;\n\t\t\tint x=i,y=i;\n\t\t\trep(_,4){\n\t\t\t\tint z=(y+1);\n\t\t\t\tif(z==4)z=0;\n\t\t\t\t\n\t\t\t\tcs+=to[y]->cnt;\n\t\t\t\tif(cs==cnt){\n\t\t\t\t\tmn[i][y]=mis+to[y]->gmi(x,y);\n\t\t\t\t\tmx[i][y]=mas+to[y]->gma(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tmn[i][y]=inf;\n\t\t\t\t\tmx[i][y]=-inf;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmis+=to[y]->gmi(x,z);\n\t\t\t\tmas+=to[y]->gma(x,z);\n\t\t\t\tchmin(mis,inf);\n\t\t\t\tchmax(mas,-inf);\n\t\t\t\tx=y;y=z;\n\t\t\t}\n\t\t}\n\t\trep(i,4)rep(j,4)chmin(mn[i][j],inf);\n\t\trep(i,4)rep(j,4)chmax(mx[i][j],-inf);\n\t}\n};\nconst int nmax=20;\nconst int qmax=100010;\nconst int smax=(nmax+1)*qmax;\nN buf[smax];\nint bufused=0;\nN* nn(){\n\treturn buf+bufused++;\n}\n\nvoid add(N*&cur,int i,const string&s){\n\t{\n\t\tN*tmp=nn();\n\t\t*tmp=*cur;\n\t\tcur=tmp;\n\t}\n\tif(i==si(s)){\n\t\tcur->cnt^=1;\n\t}else{\n\t\tint k=s[i]-\'a\';\n\t\tadd(cur->to[k],i+1,s);\n\t\tcur->upd();\n\t}\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tN* root;\n\t{\n\t\tvc<N*> ls(n+1);\n\t\trep(i,n+1)ls[i]=nn();\n\t\trep(i,4)rep(j,4){\n\t\t\tls[n]->mn[i][j]=1;\n\t\t\tls[n]->mx[i][j]=1;\n\t\t}\n\t\tper(i,n){\n\t\t\trep(j,4)ls[i]->to[j]=ls[i+1];\n\t\t\tls[i]->upd();\n\t\t}\n\t\troot=ls[0];\n\t}\n\trep(_,q){\n\t\tadd(root,0,readString());\n\t\tint tot=root->cnt;\n\t\tint mn=inf,mx=-inf;\n\t\tN*cur=root;\n\t\trep(lv,n){\n\t\t\tassert(cur->cnt==tot);\n\t\t\t//0-1-2-3\n\t\t\t{\n\t\t\t\tint mis=0,mas=0;\n\t\t\t\trep(y,4){\n\t\t\t\t\tint x=(y+3)%4,z=(y+1)%4;\n\t\t\t\t\tmis+=cur->to[y]->gmi(x,z);\n\t\t\t\t\tmas+=cur->to[y]->gma(x,z);\n\t\t\t\t\tchmin(mis,inf);\n\t\t\t\t\tchmax(mas,-inf);\n\t\t\t\t}\n\t\t\t\tchmin(mn,mis);\n\t\t\t\tchmax(mx,mas);\n\t\t\t}\n\t\t\trep(y,4){\n\t\t\t\tint z=(y+1)%4;\n\t\t\t\tif(cur->to[y]->cnt+cur->to[z]->cnt==cur->cnt){\n\t\t\t\t\tchmin(mn,cur->to[y]->gmi(z,z)+cur->to[z]->gmi(y,y));\n\t\t\t\t\tchmax(mx,cur->to[y]->gma(z,z)+cur->to[z]->gma(y,y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool upd=false;\n\t\t\trep(y,4){\n\t\t\t\tif(cur->to[y]->cnt==cur->cnt){\n\t\t\t\t\tcur=cur->to[y];\n\t\t\t\t\tupd=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!upd)break;\n\t\t}\n\t\tif(mn<=mx)print(mn,mx);\n\t\telse print(-1);\n\t}\n\t/*{\n\t\tN* cur=root;\n\t\tcur=cur->to[0];\n\t\tdmp(cur->mx[3][1]);\n\t\tdmp(cur->mx[1][3]);\n\t\tdmp(cur->mn[3][1]);\n\t\tdmp(cur->mn[1][3]);\n\t\tdmp(cur->to[1]->mn[1][2]);\n\t\tdmp(cur->to[2]->mn[1][3]);\n\t\tdmp(cur->to[3]->mn[2][3]);\n\t}*/\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'dp']",3500
https://codeforces.com//contest/920/problem/C,C. Swap Adjacent Elements,You have an array consisting of integers Each integer from to appears exactly once in this array For some indices it is possible to swap th element with th for other indices it is not possible You may perform any number of swapping operations any order There is no limit on the number of times you swap th element with th if the position is not forbidden Can you make this array sorted in ascending order performing some sequence of swapping operations ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint mx[200050];\nint mn[200050];\nint in[200050];\nchar u[200050];\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in[i]);\n\tfor (i = 1; i <= N; i++) mx[i] = max(mx[i - 1], in[i]);\n\tmn[N + 1] = INF;\n\tfor (i = N; i >= 1; i--) mn[i] = min(mn[i + 1], in[i]);\n\n\tscanf(""%s"", u + 1);\n\tfor (i = 1; i < N; i++) {\n\t\tif (u[i] == \'1\') continue;\n\t\tif (mx[i] > mn[i + 1]) return !printf(""NO\\n"");\n\t}\n\treturn !printf(""YES\\n"");\n}\n//*/']","['dfs and similar', 'greedy', 'math', 'sortings', 'two pointers']",1400
https://codeforces.com//contest/1682/problem/F,F. MCMF ,You are given two integer arrays a and b b i neq 0 and b i leq 10 9 Array a is sorted in order The cost of a subarray a l r is defined as follows If sum limits j l r b j neq 0 then the cost is not defined Otherwise Construct a bipartite flow graph with r l 1 vertices labeled from l to r with all vertices having b i lt 0 on the left and those with b i gt 0 on right For each i j such that l le i j le r b i 0 and b j 0 draw an edge from i to j with infinite capacity and cost of unit flow as a i a j Add two more vertices source S and sink T For each i such that l le i le r and b i 0 add an edge from S to i with cost 0 and capacity b i For each i such that l le i le r and b i 0 add an edge from i to T with cost 0 and capacity b i The cost of the subarray is then defined as the minimum cost of maximum flow from S to T You are given q queries in the form of two integers l and r You have to compute the cost of subarray a l r for each query modulo 10 9 7 If you don t know what the minimum cost of maximum flow means read here ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector> \n#define int long long\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[200005],b[200005],ta[200005],qzh[200005];\nint f1[200005],f2[200005],n;\nvoid insert1(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf1[k]=(f1[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query1(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f1[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nvoid insert2(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf2[k]=(f2[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query2(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f2[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nint pos[200005];\nbool bi(int x,int y)\n{\n\treturn qzh[x]<qzh[y];\n}\nint ql[200005],qr[200005],qans[200005];\nvector<int>v[200005];\nsigned main()\n{\n\tint q;\n\tn=read();\n\tq=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=1;i<=n-1;i++)ta[i]=a[i+1]-a[i];\n\tta[n]=0;\n\tfor(int i=1;i<=n;i++)b[i]=read(),qzh[i]=qzh[i-1]+b[i],pos[i]=i;\n\tsort(pos+1,pos+n+1,bi);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tql[i]=read();\n\t\tqr[i]=read();\n\t\tv[qr[i]].push_back(i);\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t//printf(""vis:%lld %lld %lld\\n"",x,ta[x],(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\t//printf(""%lld %lld %lld %lld\\n"",v[x][j],((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod,((query1(qr[v[x][j]])-query1(ql[v[x][j]]-1))%mod+mod)%mod,qzh[ql[v[x][j]]-1]);\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+mod-1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\t//for(int i=1;i<=q;i++)printf(""%lld\\n"",qans[i]);\n\tfor(int i=1;i<=n;i++)f1[i]=f2[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+mod-((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++)printf(""%lld\\n"",qans[i]);\n\treturn 0;\n} ']","['data structures', 'flows', 'graphs', 'greedy', 'sortings', 'two pointers']",2700
https://codeforces.com//contest/899/problem/C,C. Dividing the numbers,Petya has integers He wants to split these integers in groups in such a way that the absolute difference of sums of integers in each group is as small as possible Help Petya to split the integers Each of integers should be exactly in one group ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,a[60005];\nint main(){\n\tscanf(""%d"",&n);\n\tif(n%4==1){\n\t\tprintf(""1\\n"");\n\t\tint sz=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i%4==1||i%4==2)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}else if(n%4==2){\n\t\tprintf(""1\\n"");\n\t\tint sz=0;\n\t\ta[sz++]=2;\n\t\tfor(int i=3;i<=n;i++)\n\t\t\tif(i%4==2||i%4==3)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}else if(n%4==3){\n\t\tprintf(""0\\n"");\n\t\tint sz=0;\n\t\ta[sz++]=3;\n\t\tfor(int i=4;i<=n;i++)\n\t\t\tif(i%4==1||i%4==2)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}else {\n\t\tprintf(""0\\n"");\n\t\tint sz=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i%4==2||i%4==3)a[sz++]=i;\n\t\tprintf(""%d "",sz);\n\t\tfor(int i=0;i<sz;i++)printf(""%d "",a[i]);putchar(\'\\n\');\n\t}\n\treturn 0;\n}\n']","['constructive algorithms', 'graphs', 'math']",1300
https://codeforces.com//contest/239/problem/D,D. Boring Partition,This problem is the most boring one you ve ever seen Given a sequence of integers and a non negative integer our goal is to partition the sequence into two subsequences not necessarily consist of continuous elements Each element of the original sequence should be contained in exactly one of the result subsequences Note that one of the result subsequences can be empty Let s define function on pairs of distinct elements that is in the original sequence If and are in the same subsequence in the current partition then otherwise Consider all possible values of the function for some partition We ll call the of this partiotion the difference between the maximum value of function and the minimum value of function Your task is to find a partition of the given sequence that have the minimal possible goodness among all possible partitions ,"['#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <stack>\n#include <list>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VP;\ntypedef vector<string> VS;\n\n#define FOR(i,a,b) for(i=(a);i<(b);i++)\n#define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ALL(x) x.begin(),x.end()\n#define CLR(x, v) memset((x),v,sizeof (x))\n#define gcd(a, b) __gcd(a, b)\n#define PB push_back \n#define MP make_pair\n#define INF 2000000007\n\nint toInt(string s){ istringstream sin(s); int t; sin>>t; return t; }\ntemplate<class T> string toString(T x){ ostringstream sout; sout<<x; return sout.str(); }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nint a[100010], h;\nVP vp;\nint solve(int x, int p[], int n)\n{\n\tif(n==1) return 0;\n\treturn max(p[n-1]+p[n-2],p[n-1]+x+h)-min(p[0]+p[1],p[0]+x+h);\n}\nint ans[100010];\nint main()\n{\n\tint n;\n\tint i;\n\tcin>>n>>h;\n\tFOR(i,0,n) {\n\t\tcin>>a[i];\n\t\tvp.PB(MP(a[i],i));\n\t}\n\tsort(ALL(vp));\n\tsort(a,a+n);\n\tint v0 = a[n-1]+a[n-2]-a[0]-a[1];\n\tint v1 = solve(a[0],a+1,n-1);\n\tswap(a[0],a[1]);\n\tint v2 = solve(a[0],a+1,n-1);\n\tint v = min(v0,min(v1,v2));\n\tif(v0==v) {\n\t} else if(v1==v) {\n\t\tans[vp[0].second]=1;\n\t} else if(v2==v) {\n\t\tswap(vp[0],vp[1]);\n\t\tans[vp[0].second]=1;\n\t}\n\tcout<<v<<endl;\n\tcout<<ans[0]+1;\n\tFOR(i,1,n) cout<<"" ""<<ans[i]+1;\n\tcout<<endl;\n\treturn 0;\n}\n']","['constructive algorithms', 'greedy', 'sortings']",1800
https://codeforces.com//contest/1823/problem/E,E. Removing Graph,Alice and Bob are playing a game on a graph They have an undirected graph without self loops and multiple edges All vertices of the graph have The graph may consist of several components Note that if such graph has n vertices it will have exactly n edges Alice and Bob take turn Alice goes first In each turn the player can choose k l le k le r l r vertices that form and erase these vertices from the graph including all incident edges The player who can t make a step loses For example suppose they are playing on the given graph with given l 2 and r 3 A valid vertex set for Alice to choose at the first move is one of the following 1 2 1 3 2 3 4 5 4 6 5 6 1 2 3 4 5 6 Suppose Alice chooses subgraph 4 6 Then a valid vertex set for Bob to choose at the first move is one of the following 1 2 1 3 2 3 1 2 3 Suppose Bob chooses subgraph 1 2 3 Alice can t make a move so she loses You are given a graph of size n and integers l and r Who will win if both Alice and Bob play optimally ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,mod=998244353;\nint add(int x, int y){x+=y; if(x>=mod) x-=mod; return x;}\nint sub(int x, int y){x-=y; if(x<0) x+=mod; return x;}\nint mul(int x, int y){return ((ll)x)*y%mod;}\nint Pow(int x, ll y=mod-2){int res=1; for(; y; x=mul(x,x),y>>=1) if(y&1) res=mul(res,x); return res;}\n\nint n,l,r;\nvector<int> adj[N];\nbool vis[N];\n\nint cnt;\nvoid dfs(int u){\n    cnt++;\n    vis[u]=1;\n    for(auto v: adj[u]) if(!vis[v]) dfs(v);\n}\n\nvoid ldc(){\n    cin >> n >> l >> r;\n    for(int i=0; i<n; ++i){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    int res=0;\n    for(int i=0; i<n; ++i) if(!vis[i]){\n        cnt=0;\n        dfs(i);\n        if(cnt<l+r) res^=cnt/l;\n    }\n    cout << (res?""Alice"":""Bob"") << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    t=1;\n    while(t--) ldc();\n}']","['brute force', 'dp', 'games', 'graphs', 'math']",2500
https://codeforces.com//contest/521/problem/D,D. Shop,Vasya plays one very well known and extremely popular MMORPG game His game character has skill currently the th of them equals to Also this game has a common rating table in which the participants are ranked according to the of all the skills of a hero in the descending order Vasya decided to upgrade his character via the game store This store offers possible ways to improve the hero s skills Each of these ways belongs to one of three types assign the th skill to add to the th skill multiply the th skill by Unfortunately a every improvement can only be used once b the money on Vasya s card is enough only to purchase not more than of the improvements Help Vasya to reach the highest ranking in the game To do this tell Vasya which of improvements he has to purchase and in what order he should use them to make his rating become as high as possible If there are several ways to achieve it print any of them ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define mp make_pair\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << ""("" << a.first << "", "" << a.second << "")""; };\ntemplate <typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate <typename T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <typename T> void chmax(T &t, const T &f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\nstruct Rat {\n\tInt p, q;\n\tRat() {}\n\tRat(Int p, Int q = 1) : p(p), q(q) { reduce(); }\n\tvoid reduce() { Int g = __gcd(p, q); p /= g; q /= g; if (q < 0 || (q == 0 && p < 0)) { p = -p; q = -q; } }\n\tRat operator+(const Rat &a) const { return Rat(p * a.q + q * a.p, q * a.q); }\n\tRat operator-(const Rat &a) const { return Rat(p * a.q - q * a.p, q * a.q); }\n\tRat operator*(const Rat &a) const { return Rat(p * a.p, q * a.q); }\n\tRat operator/(const Rat &a) const { return Rat(p * a.q, q * a.p); }\n\tRat &operator+=(const Rat &a) { return *this = *this + a; }\n\tRat &operator-=(const Rat &a) { return *this = *this - a; }\n\tRat &operator*=(const Rat &a) { return *this = *this * a; }\n\tRat &operator/=(const Rat &a) { return *this = *this / a; }\n\tRat operator+() const { return *this; }\n\tRat operator-() const { return Rat(-p, q); }\n\tbool operator< (const Rat &a) const { return (p * a.q <  q * a.p); }\n\tbool operator<=(const Rat &a) const { return (p * a.q <= q * a.p); }\n\tbool operator> (const Rat &a) const { return (p * a.q >  q * a.p); }\n\tbool operator>=(const Rat &a) const { return (p * a.q >= q * a.p); }\n\tbool operator==(const Rat &a) const { return  (p == a.p && q == a.q); }\n\tbool operator!=(const Rat &a) const { return !(p == a.p && q == a.q); }\n\texplicit operator double() const { return (double)p / (double)q; }\n\texplicit operator long double() const { return (long double)p / (long double)q; }\n\tfriend ostream &operator<<(ostream &os, const Rat &a) { os << a.p << ""/"" << a.q; return os; }\n};\n\nint K, N, M;\nInt A[100010];\nint T[100010], I[100010];\nInt B[100010];\n\nInt as[100010];\npair<Int, int> b1[100010];\nvector<pair<Int, int>> b2[100010];\nvector<pair<Int, int>> b3;\n\nmultiset<pair<Rat, int>> q;\n\nvoid addThem(int k) {\n\t/*\n\tif (b1[k].second != -1) {\n\t\tq.emplace(Rat(b1[k].first, as[k]), b1[k].second);\n\t}\n\t*/\n\tif (b2[k].back().second != -1) {\n\t\tq.emplace(Rat(as[k] + b2[k].back().first, as[k]), b2[k].back().second);\n\t}\n}\nvoid removeThem(int k) {\n\t/*\n\t{\n\t\tauto it = q.find(mp(Rat(b1[k].first, as[k]), b1[k].second));\n\t\tif (it != q.end()) {\n\t\t\tq.erase(it);\n\t\t}\n\t}\n\t*/\n\t{\n\t\tauto it = q.find(mp(Rat(as[k] + b2[k].back().first, as[k]), b2[k].back().second));\n\t\tif (it != q.end()) {\n\t\t\tq.erase(it);\n\t\t}\n\t}\n}\n\nint ansLen;\nint ans[100010];\nint ans1Len;\nint ans1[100010];\n\nint main() {\n\t\n\t\n\tfor (; ~scanf(""%d%d%d"", &K, &N, &M); ) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tA[k] = in();\n\t\t}\n\t\tfor (int n = 0; n < N; ++n) {\n\t\t\tT[n] = in();\n\t\t\tI[n] = in() - 1;\n\t\t\tB[n] = in();\n\t\t}\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tas[k] = A[k];\n\t\t\tb1[k] = mp(0, -1);\n\t\t\tb2[k] = { mp(0, -1) };\n\t\t}\n\t\tb3.clear();\n\t\tfor (int n = 0; n < N; ++n) {\n\t\t\tconst int k = I[n];\n\t\t\tswitch (T[n]) {\n\t\t\t\tcase 1: {\n\t\t\t\t\tchmax(b1[k], mp(B[n], n));\n\t\t\t\t} break;\n\t\t\t\tcase 2: {\n\t\t\t\t\tb2[k].emplace_back(B[n], n);\n\t\t\t\t} break;\n\t\t\t\tcase 3: {\n\t\t\t\t\tb3.emplace_back(B[n], n);\n\t\t\t\t} break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t}\n\t\tfor (; (int)b3.size() < N + 1; ) {\n\t\t\tb3.emplace_back(1, -1);\n\t\t}\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tif (b1[k].first > A[k]) {\n\t\t\t\tb2[k].emplace_back(b1[k].first - A[k], b1[k].second);\n\t\t\t}\n\t\t\tsort(b2[k].begin(), b2[k].end());\n\t\t}\n\t\tsort(b3.begin(), b3.end());\n/*\nfor(int k=0;k<K;++k){\n cout<<""b1[""<<k<<""] = ""<<b1[k]<<endl;\n cout<<""b2[""<<k<<""] : "";pv(b2[k].begin(),b2[k].end());\n}\ncout<<""b3 : "";pv(b3.begin(),b3.end());\n*/\n\t\tq = { mp(1, -1) };\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\taddThem(k);\n\t\t}\n\t\tansLen = 0;\n\t\tfor (int m = 0; m < M; ++m) {\n// cout<<""q : "";pv(q.begin(),q.end());\n\t\t\tauto best = --q.end();\n// cout<<""  ""<<*best<<"" vs ""<<b3[(int)b3.size() - (M - m)]<<endl;\n\t\t\tif (best->first > b3[(int)b3.size() - (M - m)].first) {\n\t\t\t\tconst int n = best->second;\n\t\t\t\tassert(n != -1);\n\t\t\t\tq.erase(best);\n\t\t\t\tans[ansLen++] = n;\n\t\t\t\tconst int k = I[n];\n\t\t\t\tremoveThem(k);\n\t\t\t\t/*\n\t\t\t\tswitch (T[n]) {\n\t\t\t\t\tcase 1: {\n\t\t\t\t\t\tassert(b1[k].second == n);\n\t\t\t\t\t\tb1[k] = mp(0, -1);\n\t\t\t\t\t\tas[k] = B[k];\n\t\t\t\t\t} break;\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tassert(b2[k].back().second == n);\n\t\t\t\t\t\tb2[k].pop_back();\n\t\t\t\t\t\tas[k] += B[k];\n\t\t\t\t\t} break;\n\t\t\t\t\tdefault: assert(false);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tassert(b2[k].back().second == n);\n\t\t\t\tas[k] += b2[k].back().first;\n\t\t\t\tb2[k].pop_back();\n\t\t\t\t\n\t\t\t\taddThem(k);\n\t\t\t} else {\n\t\t\t\tfor (; m < M; ++m) {\n\t\t\t\t\tconst int n = b3.back().second;\n\t\t\t\t\tif (n == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tb3.pop_back();\n\t\t\t\t\tans[ansLen++] = n;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans1Len = 0;\n\t\tfor (int i = 0; i < ansLen; ++i) {\n\t\t\tif (T[ans[i]] == 1) {\n\t\t\t\tans1[ans1Len++] = ans[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ansLen; ++i) {\n\t\t\tif (T[ans[i]] != 1) {\n\t\t\t\tans1[ans1Len++] = ans[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(""%d\\n"", ans1Len);\n\t\tfor (int i = 0; i < ans1Len; ++i) {\n\t\t\tif (i > 0) printf("" "");\n\t\t\tprintf(""%d"", ans1[i] + 1);\n\t\t}\n\t\tputs("""");\n\t}\n\t\n\treturn 0;\n}\n\n']",['greedy'],2800
https://codeforces.com//contest/1877/problem/C,C. Joyboard,Chaneka a gamer kid invented a new gaming controller called joyboard Interestingly the joyboard she invented can only be used to play one game The joyboard has a screen containing n 1 slots numbered from 1 to n 1 from left to right The n 1 slots are going to be filled with an array of non negative integers a 1 a 2 a 3 ldots a n 1 Chaneka as the player must assign a n 1 with an integer between 0 and m inclusive Then for each i from n to 1 the value of a i will be equal to the of dividing a i 1 the adjacent value to the right by i In other words a i a i 1 bmod i Chaneka wants it such that after every slot is assigned with an integer there are exactly k distinct values in the entire screen among all n 1 slots How many valid ways are there for assigning a non negative integer into slot n 1 ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int INF=1e6+5;\nint n,m,k;\nvoid solve(){\n\tcin>>n>>m>>k;\n\tif (k>3) {cout<<""0\\n"";return ;}\n\tif (k==3) {\n\t\t// 6 3 \n\t\t// \n\t\t// >n 不是 n 的倍数\n\t\tcout<<max(0ll,m-n-(m-n)/n)<<""\\n""; \n\t}\n\telse if (k==2) {\n\t\tif (n<=m) cout<<max(0ll,max(0ll,(m-n)/n)+n)<<""\\n"";\n\t\telse cout<<min(m,n)<<""\\n"";\n\t}\n\telse cout<<1<<""\\n"";\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tint t=0;cin>>t;\n\twhile (t--) solve();\n\treturn 0;\n}']","['math', 'number theory']",1200
https://codeforces.com//contest/821/problem/C,C. Okabe and Boxes,Okabe and Super Hacker Daru are stacking and removing boxes There are boxes numbered from to Initially there are no boxes on the stack Okabe being a control freak gives Daru commands of which are to add a box to the top of the stack and of which are to remove a box from the top of the stack and throw it in the trash Okabe wants Daru to throw away the boxes in the order from to Of course this means that it might be impossible for Daru to perform some of Okabe s commands because the required box is not on the top of the stack That s why Daru can decide to wait until Okabe looks away and then reorder the boxes in the stack in any way he wants He can do it at any point of time between Okabe s commands but he can t add or remove boxes while he does it Tell Daru the minimum number of times he needs to reorder the boxes so that he can successfully complete all of Okabe s commands It is guaranteed that every box is added before it is required to be removed ,"['#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 300010\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') ch = getchar();\n\twhile (ch >= \'0\' && ch <= \'9\')\n\t\tx = x * 10 + ch - \'0\', ch = getchar();\n}\nchar s[20];\nint n, sta[maxn], top, x, k, ans;\nint main() {\n\tgn(n);\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tscanf(""%s"", s + 1);\n\t\tif (s[1] == \'a\') {\n\t\t\tscanf(""%d"", &x);\n\t\t\tsta[++top] = x; \n\t\t} else {\n\t\t\t++k;\n\t\t\tif (top && sta[top] == k) {\n\t\t\t\t--top;\n\t\t\t} else {\n\t\t\t\tif (!top) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\t++ans; top = 0; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n\n\n']","['data structures', 'greedy', 'trees']",1500
https://codeforces.com//contest/900/problem/E,E. Maximum Questions,Vasya wrote down two strings of length and of length consisting of small English letters and What is more he knows that string has a form namely there are letters on odd positions and letters on even positions Suddenly in the morning Vasya found that somebody spoiled his string Some letters of the string were replaced by character Let s call a sequence of positions as of string in if and The boy defines the of the string as maximum number of disjoint occurrences of string in Vasya can replace some letters with or letters on different positions can be replaced with different letter Vasya wants to make some replacements in such a way that beauty of string is maximum possible From all such options he wants to choose one with the minimum number of replacements Find the number of replacements he should make ,"['#include<bits/stdc++.h>\n#define maxn 200050\n\nusing namespace std;\n\nchar s[maxn];\n\nint a[maxn][2],b[maxn][2],c[maxn],d[maxn],r[maxn],n,m,p,q,f;\n\nint main()\n{\n    scanf(""%d"",&n);scanf(""%s"",s);scanf(""%d"",&m);\n    p=(m+1)/2;q=m/2;\n    a[0][0]=a[0][1]=0;b[0][1]=0;c[0]=0;\n    for (int i=1;i<=n;i++)\n    {\n        a[i][0]=a[i-1][0];a[i][1]=a[i-1][1];\n        b[i][0]=b[i-1][0];b[i][1]=b[i-1][1];\n        c[i]=c[i-1];\n        if (s[i-1]==\'a\') a[i][i&1]++;\n        else if (s[i-1]==\'b\') b[i][i&1]++;\n        else a[i][i&1]++,b[i][i&1]++,c[i]++;\n    }\n    memset(d,0,sizeof(d));memset(r,0,sizeof(r));\n    for (int i=m;i<=n;i++)\n    {\n        d[i]=d[i-1]; r[i]=r[i-1];\n        f=(i-m+1)&1;\n        if (a[i][f]-a[i-m][f]==p&&b[i][f^1]-b[i-m][f^1]==q)\n        {\n            if (d[i]<d[i-m]+1||d[i]==d[i-m]+1&&r[i]>r[i-m]+c[i]-c[i-m])\n            {\n                d[i]=d[i-m]+1;\n                r[i]=r[i-m]+c[i]-c[i-m];\n            }\n        }\n    }\n    printf(""%d\\n"",r[n]);\n    return 0;\n}\n']","['data structures', 'dp', 'strings']",2100
https://codeforces.com//contest/490/problem/A,A. Team Olympiad,The School 0 of the capital of Berland has children studying in it All the children in this school are gifted some of them are good at programming some are good at maths others are good at PE Physical Education Hence for each child we know value if the th child is good at programming if the th child is good at maths if the th child is good at PE Each child happens to be good at exactly one of these three subjects The Team Scientific Decathlon Olympias requires teams of three students The school teachers decided that the teams will be composed of three children that are good at different subjects That is each team must have one mathematician one programmer and one sportsman Of course each child can be a member of no more than one team What is the maximum number of teams that the school will be able to present at the Olympiad How should the teams be formed for that ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector<int> a[4];\n\nint main(){\n     //freopen(""a.in"", ""r"", stdin);\n     //freopen(""a.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 0; i < 4; i++) a[i].clear();\n     for (int i = 1; i <= n; i++)\n     {\n          int x;\n          scanf(""%d"", &x);\n          a[x].push_back(i);\n     }\n     int m = min(min(a[1].size(), a[2].size()), a[3].size());\n     printf(""%d\\n"", m);\n     for (int i = 0; i < m; i++) printf(""%d %d %d\\n"", a[1][i], a[2][i], a[3][i]);\n}\n']","['greedy', 'implementation', 'sortings']",800
https://codeforces.com//contest/255/problem/A,A. Greg s Workout,Greg is a beginner bodybuilder Today the gym coach gave him the training plan All it had was integers These numbers mean that Greg needs to do exactly exercises today Besides Greg should repeat the th in order exercise times Greg now only does three types of exercises chest exercises biceps exercises and back exercises Besides his training is cyclic that is the first exercise he does is a chest one the second one is biceps the third one is back the fourth one is chest the fifth one is biceps and so on to the th exercise Now Greg wonders which muscle will get the most exercise during his training We know that the exercise Greg repeats the maximum number of times trains the corresponding muscle the most Help Greg determine which muscle will get the most training ,"['#include<cstdio>\n\nint n;\nint s[5];\n\nint main(){\n    s[0]=s[1]=s[2]=0;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++){\n        int v;\n        scanf(""%d"",&v);\n        s[i%3]+=v;\n    }\n    if(s[0]>=s[1]&&s[0]>=s[2])\n        printf(""chest\\n"");\n    else if(s[1]>=s[0]&&s[1]>=s[2])\n        printf(""biceps\\n"");\n    else\n        printf(""back\\n"");\n    \n    return 0;\n}']",['implementation'],800
https://codeforces.com//contest/1891/problem/C,C. Smilo and Monsters,A boy called Smilo is playing a new game In the game there are n hordes of monsters and the i th horde contains a i monsters The goal of the game is to destroy all the monsters To do this you have two types of attacks and a combo counter x initially set to 0 The first type you choose a number i from 1 to n such that there is at least one monster left in the horde with the number i Then you kill one monster from horde number i and the combo counter x increases by 1 The second type you choose a number i from 1 to n such that there are at least x monsters left in the horde with number i Then you use an ultimate attack and kill x monsters from the horde with number i After that x is reset to zero Your task is to destroy all of the monsters meaning that there should be no monsters left in any of the hordes Smilo wants to win as quickly as possible so he wants to the minimum number of attacks required to win the game ,"['#include<bits/stdc++.h>\n#define int long long\n#define N 200005\nusing namespace std;\nint read(){\n\tint w=0,h=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')h=-h;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){w=w*10+ch-\'0\';ch=getchar();}\n\treturn w*h;\n}\nint n,sum,ans,a[N];\nvoid solve(){\n\tn=read();sum=ans=0;\n\tfor(int i=1;i<=n;i++)sum+=(a[i]=read());\n\tsort(a+1,a+n+1);sum>>=1;\n\tfor(int i=n;i>=1;i--)\n\t\tif(sum>=a[i])sum-=a[i],a[i]=0,ans++;\n\t\telse if(sum)a[i]-=sum,sum=0,ans++;\n\tfor(int i=1;i<=n;i++)ans+=a[i];\n\tprintf(""%lld\\n"",ans);\n}\nsigned main(){\n\tint T=read();while(T--)solve();\n\treturn 0;\n}\n\n']","['binary search', 'constructive algorithms', 'greedy', 'sortings', 'two pointers']",1500
https://codeforces.com//contest/1473/problem/D,D. Program,You are given a program that consists of n instructions Initially a single variable x is assigned to 0 Afterwards the instructions are of two types increase x by 1 decrease x by 1 You are given m queries of the following format query l r how many distinct values is x assigned to if all the instructions between the l th one and the r th one inclusive are ignored and the rest are executed without changing the order ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nstruct Data {\n    int mx;\n    int mn;\n    int add;\n    Data(int mx = 0, int mn = 0, int add = 0) : mx(mx), mn(mn), add(add) {}\n};\nData operator+(const Data &a, const Data &b) {\n    return Data(std::max(a.mx, a.add + b.mx), std::min(a.mn, a.add + b.mn), a.add + b.add);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, m;\n        std::cin >> n >> m;\n        std::string s;\n        std::cin >> s;\n        std::vector<Data> a(n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == \'+\') {\n                a[i] = Data(1, 0, 1);\n            } else {\n                a[i] = Data(0, -1, -1);\n            }\n        }\n        std::vector<Data> pre(n + 1), suf(n + 1);\n        for (int i = 0; i < n; i++) {\n            pre[i + 1] = pre[i] + a[i];\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            suf[i] = a[i] + suf[i + 1];\n        }\n        while (m--) {\n            int l, r;\n            std::cin >> l >> r;\n            l--;\n            auto v = pre[l] + suf[r];\n            std::cout << v.mx - v.mn + 1 << ""\\n"";\n        }\n    }\n    return 0;\n}']","['data structures', 'dp', 'implementation', 'strings']",1700
https://codeforces.com//contest/1750/problem/B,B. Maximum Substring,A binary string is a string consisting only of the characters and You are given a binary string s For some non empty substring dagger t of string s containing x characters and y characters define its as x cdot y if x 0 and y 0 x 2 if x 0 and y 0 y 2 if x 0 and y 0 Given a binary string s of length n find the maximum cost across all its non empty substrings dagger A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don\'t erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = ""{"";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += ""}"";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return ""("" + ts(p.f) + "", "" + ts(p.s) + "")""; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = """";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn ""{"" + ts_sep(v, "", "") + ""}"";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += "","";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = "" "";\n\t\tif (i == 0) bef = ""{"";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += ""}"";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, """", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << ""\\n""; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, "" "", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, "" | "", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << ""Line("" << line << "") -> ["" << names << ""]: "";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t), ""\\n"") << ""\\n"" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don\'t actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out""); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tints(N);\n\tstr S;\n\tre(S);\n\tvl len;\n\tfor (int i = 0; i < sz(S);) {\n\t\tint j = i;\n\t\twhile (i < sz(S) && S.at(i) == S.at(j)) ++i;\n\t\tlen.pb(i - j);\n\t}\n\tll ans = 0;\n\teach(t, len) ckmax(ans, t * t);\n\tAR<ll, 2> tot{};\n\tF0R(i, sz(len)) { tot[i % 2] += len[i]; }\n\tckmax(ans, tot[0] * tot[1]);\n\t// F0R(i,sz(len)-1) ckmax(ans,(len[i]+len[i+2])*len[i])\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","['brute force', 'greedy', 'implementation']",800
https://codeforces.com//contest/1391/problem/A,A. Suborrays,A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array For a positive integer n we call a permutation p of length n if the following condition holds for every pair i and j 1 le i le j le n p i text OR p i 1 text OR ldots text OR p j 1 text OR p j ge j i 1 where text OR denotes the bitwise OR operation In other words a permutation p is if for every subarray of p the text OR of all elements in it is not less than the number of elements in that subarray Given a positive integer n output any permutation of length n We can show that for the given constraints such a permutation always exists ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n;\n        cin >> n;\n\n        for(int i = 1; i <= n; ++i)\n            cout << i << "" "";\n        cout << ""\\n"";\n    }\n}']","['constructive algorithms', 'math']",800
https://codeforces.com//contest/1363/problem/A,A. Odd Selection,Shubham has an array a of size n and wants to select exactly x elements from it such that their sum is odd These elements do not have to be consecutive The elements of the array are not guaranteed to be distinct Tell him whether he can do so ,"['#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << "" : "" << x << \'\\n\'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 2e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll cnt[2];\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll T;\n\tcin >> T;\n\tfor(int i = 0; i < T; i++){\n\t\tmemset(cnt, 0, sizeof cnt);\n\t\tll n, x, v;\n\t\tcin >> n >> x;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> v;\n\t\t\tcnt[v & 1] ++;\n\t\t}\n\t\tif(x == n) cout << (cnt[1] & 1 ? ""Yes"" : ""No"") << \'\\n\';\n\t\telse {\n\t\t\tif(min(cnt[0], cnt[1]) > 0) cout << ""Yes"" << \'\\n\';\n\t\t\telse if(cnt[0]) cout << ""No\\n"";\n\t\t\telse cout << (x & 1 ? ""Yes"" : ""No"") << \'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}\n']","['brute force', 'implementation', 'math']",1200
https://codeforces.com//contest/272/problem/C,C. Dima and Staircase,Dima s got a staircase that consists of stairs The first stair is at height the second one is at the last one is at Dima decided to play with the staircase so he is throwing rectangular boxes at the staircase from above The th box has width and height Dima throws each box vertically down on the first stairs of the staircase that is the box covers stairs with numbers Each thrown box flies vertically down until at least one of the two following events happen the bottom of the box touches the top of a stair the bottom of the box touches the top of a box thrown earlier We only consider touching of the horizontal sides of stairs and boxes at that touching with the corners isn t taken into consideration Specifically that implies that a box with width cannot touch the stair number You are given the description of the staircase and the sequence in which Dima threw the boxes at it For each box determine how high the bottom of the box after landing will be Consider a box to fall after the previous one lands ,"['#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,n,m) for(int i = (int)n; i <= (int)m; i++)\n#define FOD(i,n,m) for(int i = (int)n; i >= (int)m; i--)\n\ntypedef long long i64;\ntypedef pair<int, int> PI;\n\n#define sz(v) ((i64)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define bit(n) (1LL<<(i64)(n))\n#define each(i,v) for(__typeof((v).begin()) i = (v).begin(); i != (v).end(); i++)\n\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n\ntemplate<class T> void fmax(T &a, T b) { if (a < b) a = b; }\ntemplate<class T> void fmin(T &a, T b) { if (a > b) a = b; }\n\nint n, m;\nlong long a[100010];\n\nint main() {\n\tcin >> n;\n\tFOR(i,1,n) cin >> a[i];\n\tlong long now = 0, h;\n\tint w;\n\tcin >> m;\n\trep(i,m) {\n\t\tcin >> w >> h;\n\t\tnow = max(now, a[w]);\n\t\tcout << now << endl;\n\t\tnow += h;\n\t}\n}\n\n']","['data structures', 'implementation']",1500
https://codeforces.com//contest/75/problem/B,B. Facetook Priority Wall,Facetook is a well known social network website and it will launch a new feature called Facetook Priority Wall This feature will sort all posts from your friends according to the priority factor it will be described This priority factor will be affected by three types of actions 1 15 points 2 10 points 3 5 points and will be two distinct names And each action will increase the priority factor between and and vice versa by the above value of points the priority factor between and is the same as the priority factor between and You will be given actions with the above format without the action number and the number of points and you have to print all the distinct names in these actions sorted according to the priority factor with you ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <map>\n#include <iomanip>\n\n\nusing namespace std;\n\n\n\nint main() {\n  //freopen (""input.txt"", ""r"", stdin);\n  //freopen (""output.txt"", ""w"", stdout);\n  string name;\n  string spam;\n  int n;\n  getline(cin, name);\n  cin >> n;\n  getline(cin, spam);\n  int points;\n  vector <pair <string, int>> aa;\n  for (int i = 0; i < n; ++i) {\n    getline(cin, spam);\n    string s1 = """";\n    string s2 = """";\n    int l = 0;\n    while (spam[l] != \' \') {\n      s1 += spam[l];\n      ++l;\n    }\n    ++l;\n    int p = 0;\n    if (spam[l] == \'p\') {\n      points = 15;\n      while (spam[l] != \' \')\n       ++l;\n      ++l;\n      while (spam[l] != \' \')\n      ++l;\n      ++l;\n    } else\n      if (spam[l] == \'c\') {\n        points = 10;\n        while (spam[l] != \' \')\n          ++l;\n        ++l;\n        while (spam[l] != \' \')\n          ++l;\n        ++l;\n      }\n      else\n      if (spam[l] == \'l\') {\n        points = 5;\n        while (spam[l] != \' \')\n          ++l;\n        ++l;\n      }\n      while (spam[l] != \'\\\'\') {\n        s2 += spam[l];\n        ++l;\n      }\n      if (s1 == name) {\n        aa.push_back(make_pair(s2, points));\n      } else {\n        if (s2 == name)\n          aa.push_back(make_pair(s1, points));\n        else {\n          aa.push_back(make_pair(s1, 0));\n          aa.push_back(make_pair(s2, 0));\n        }\n      }\n  }\n  sort(aa.begin(), aa.end());\n  int l = 0;\n  vector <pair<int, string>> res;\n  while (l != aa.size()) {\n    string ss = aa[l].first;\n    int pt = 0;\n    int r = l;\n    while (r != aa.size() && aa[l].first == aa[r].first) {\n      pt += aa[r].second;\n      ++r;\n    }\n    res.push_back(make_pair(pt, ss));\n    l = r;\n  }\n  sort(res.begin(), res.end());\n  int i = res.size() - 1;\n  while (i >= 0) {\n    int l = i;\n    while (l >= 0  && res[i].first == res[l].first)\n    --l;\n    for (int j = l + 1; j <= i; ++j)\n    cout << res[j].second << endl;\n    i = l;\n  }\n  return 0;\n}']","['expression parsing', 'implementation', 'strings']",1500
https://codeforces.com//contest/1859/problem/A,A. United We Stand,Given an array a of length n containing integers And there are two initially empty arrays b and c You need to add each element of array a to of the arrays b or c in order to satisfy the following conditions Both arrays b and c are non empty More formally let l b be the length of array b and l c be the length of array c Then l b l c ge 1 For any two indices i and j 1 le i le l b 1 le j le l c c j a divisor of b i Output the arrays b and c that can be obtained or output 1 if they do not exist ,"['#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt"")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include""dbg.h""\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return\'\\n\';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between \'\\n\'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<\'0\'||c>\'9\'){if(c==\'-\')f*=-1;c=getchar();}x=0;while(c>=\'0\'&&c<=\'9\'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<\'0\'||c>\'9\')&&c!=\'-\'&&c!=\'.\'){if(c==\'-\')f*=-1;c=getchar();}while(c>=\'0\'&&c<=\'9\'&&c!=\'.\')x=x*10+(c^48),c=getchar();if(c==\'.\')c=getchar();else return x*=f,*this;while(c>=\'0\'&&c<=\'9\')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str[len++]=c,c=getchar();str[len]=\'\\0\';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl=\'\\n\';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<\'\\n\';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar(\'0\'),*this;if(x<0)putchar(\'-\'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar(\'-\'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;putchar(\'.\');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>a(n);\n\t\tcin>>a;\n\t\tsort(a.begin(),a.end());\n\t\tif(*a.begin()==*a.rbegin())cout<<-1<<endl;\n\t\telse{\n\t\t\tint cnt=0;\n\t\t\tfor(auto q:a)\n\t\t\t\tif(q!=*a.rbegin())cnt++;\n\t\t\tcout<<cnt<<\' \'<<n-cnt<<endl;\n\t\t\tfor(auto q:a)\n\t\t\t\tif(q!=*a.rbegin())cout<<q<<\' \';cout<<endl;\n\t\t\tfor(auto q:a)\n\t\t\t\tif(q==*a.rbegin())cout<<q<<\' \';cout<<endl;\n\t\t}\n\t}\n}']","['constructive algorithms', 'math', 'number theory']",800
https://codeforces.com//contest/1349/problem/E,E. Slime and Hats,Slime and Orac are holding a turn based game In a big room there are n players sitting on the chairs looking forward to a column and each of them is given a number player 1 sits in the front of the column player 2 sits directly behind him player 3 sits directly behind player 2 and so on player n sits directly behind player n 1 Each player wears a hat that is either black or white As each player faces forward player i knows the color of player j s hat if and only if i is larger than j At the start of each turn Orac will tell After Orac speaks if the player can uniquely identify the color of his hat he will put his hat on the chair stand up and leave the room All players are smart so if it is possible to understand the color of their hat using the obtained information during this and previous rounds they will understand it In each turn all players who know the color of their hats will leave at the same time in this turn which means a player can only leave in the next turn if he gets to know the color of his hat only after someone left the room at this turn Note that when the player needs to leave he will put the hat on the chair before leaving so the players ahead of him still cannot see his hat The i th player will know who exactly left the room among players 1 2 ldots i 1 and how many players among i 1 i 2 ldots n have left the room Slime stands outdoor He watches the players walking out and records the numbers of the players and the time they get out Unfortunately Slime is so careless that he has only recorded some of the data and this given data is in the format Slime asked you to tell him the color of each player s hat If there are multiple solutions you can find any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//[l,r)\nbool canmake(int l,int r,int tar){\n\tif(tar<0)return false;\n\tif(tar==0)return true;\n\tint lw=0,up=r-l+1;\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tint v=(r-mid+r-1)*mid/2;\n\t\tif(v>=tar)up=mid;\n\t\telse lw=mid;\n\t}\n\tif(up==r-l+1)return false;\n\tint v=(l+l+up-1)*up/2;\n\treturn v<=tar;\n}\n\nvi restore(int l,int r,int tar){\n\tif(tar<0)assert(0);\n\tif(tar==0)return {};\n\tint lw=0,up=r-l+1;\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tint v=(r-mid+r-1)*mid/2;\n\t\tif(v>=tar)up=mid;\n\t\telse lw=mid;\n\t}\n\tif(up==r-l+1)assert(0);\n\tint v=(l+l+up-1)*up/2;\n\tassert(v<=tar);\n\tvi res(up);\n\trep(i,up)res[i]=l+i;\n\tint dif=tar-v;\n\tper(i,up){\n\t\tint u=min(r-up+i-res[i],dif);\n\t\tres[i]+=u;\n\t\tdif-=u;\n\t}\n\tassert(dif==0);\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvi t=readvi(n);\n\tt.pb(0);\n\treverse(all(t));\n\tn++;\n\tfor(auto&v:t)if(v)v+=n;\n\tt.pb(n++);\n\tdmp(t);\n\t\n\tvi pre(n,-1);\n\tpre[n-1]=-2;\n\tvi mx(n,-1);\n\tvi left(n);\n\tvc<tuple<int,int,int>> buf(n);\n\tint fix=n-1;\n\tdeque<int> fr,bc;\n\tconst int B=5;\n\tper(i,n-1){\n\t\tauto waf=[&](int z,int tar){\n\t\t\tif(i==1&&z==5){\n\t\t\t\tdmp(tar);\n\t\t\t\tdmp(mx[z]);\n\t\t\t}\n\t\t\tif(pre[z]!=-1){\n\t\t\t\tint ad=tar-t[z];\n\t\t\t\tif(canmake(left[z],z,ad)){\n\t\t\t\t\tbuf[i]=mt(left[z],z,ad);\n\t\t\t\t\tpre[i]=z;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx[z]!=-1){\n\t\t\t\tint ad=tar-(t[z]-1);\n\t\t\t\tif(canmake(left[z],mx[z],ad)){\n\t\t\t\t\tbuf[i]=mt(left[z],mx[z],ad);\n\t\t\t\t\tpre[i]=mx[z];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(t[i]){\n\t\t\tfr.push_front(fix);\n\t\t\twhile(t[fr.front()]!=t[fr.back()]){\n\t\t\t\tbc.push_front(fr.back());\n\t\t\t\tfr.pop_back();\n\t\t\t}\n\t\t\tleft[fix]=i+1;\n\t\t\tfix=i;\n\t\t\tint tar=t[i]-i;\n\t\t\tdmp2(i,tar);\n\t\t\tif(i<B){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(auto z:fr){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[i]+1)ok=false;\n\t\t\t\t}\n\t\t\t\tfor(auto z:bc){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[i]+1)ok=false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(t[fr[0]]==t[i]+1){\n\t\t\t\t\tif(si(bc)){\n\t\t\t\t\t\twaf(bc[0],tar);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twaf(fr[0],tar);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(si(fr)){\n\t\t\tint tar=t[fix]-1-i;\n\t\t\tif(i<B){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(auto z:fr){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[fix])ok=false;\n\t\t\t\t}\n\t\t\t\tfor(auto z:bc){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[fix])ok=false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(t[fr[0]]==t[fix]){\n\t\t\t\t\tif(si(bc)){\n\t\t\t\t\t\twaf(bc[0],tar);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twaf(fr[0],tar);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre[i]!=-1&&mx[fix]==-1)mx[fix]=i;\n\t\t}\n\t}\n\tdmp(pre);\n\tdmp(buf);\n\tvi res(n);\n\tint cur;\n\trep(i,n)if(pre[i]!=-1){\n\t\tcur=i;\n\t\tbreak;\n\t}\n\twhile(1){\n\t\tres[cur]=1;\n\t\tif(pre[cur]==-2)break;\n\t\tint l,r,ad;\n\t\ttie(l,r,ad)=buf[cur];\n\t\t\n\t\tvi idx=restore(l,r,ad);\n\t\tfor(auto i:idx)res[i]=1;\n\t\t\n\t\tcur=pre[cur];\n\t}\n\tdmp(res);\n\tgnr(i,1,n-1)print(res[i],0);\n\tcout<<endl;\n}\n']","['constructive algorithms', 'dp', 'greedy']",3500
https://codeforces.com//contest/1245/problem/F,F. Daniel and Spring Cleaning,While doing some spring cleaning Daniel found an old calculator that he loves so much However it seems like it is broken When he tries to compute 1 3 using the calculator he gets 2 instead of 4 But when he tries computing 1 4 he gets the correct answer 5 Puzzled by this mystery he opened up his calculator and found the answer to the riddle the full adders became half adders So when he tries to compute the sum a b using the calculator he instead gets the xorsum a oplus b read the definition by the link https en wikipedia org wiki Exclusive or As he saw earlier the calculator sometimes gives the correct answer And so he wonders given integers l and r how many pairs of integers a b satisfy the following conditions a b a oplus b l leq a leq r l leq b leq rHowever Daniel the Barman is going to the bar and will return in two hours He tells you to solve the problem before he returns or else you will have to enjoy being blocked ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nmap<pair<int, int>, long long > M;\nlong long solve(int a, int b)\n{\n    if(a==-1 || b== -1) return 0LL;\n    if(a == 0 || b == 0) return a+b+1;\n    if(a>b) swap(a, b);\n    auto it = M.find(make_pair(a,b));\n    if(it!=M.end())\n    {\n        return it->second;\n    }\n    int lb = 0;\n    for(int i=30; i>=0; --i)\n    {\n        if( (a&(1<<i))||(b&(1<<i)) )\n        {\n            lb = i;\n            break;\n        }\n    }\n\n    long long ans = 0;\n    // both 0,\n    {\n        int na = min(a, (1<<lb)-1);\n        int nb = min(b, (1<<lb)-1);\n        ans += solve(na, nb);\n    }\n    //a: 1 b = 0;\n    if(a >= (1<<lb))\n    {\n        int na = a-(1<<lb);\n        int nb = min(b, (1<<lb)-1);\n        ans += solve(na, nb);\n    }\n    //a: 0 b = 1;\n    if(b >= (1<<lb))\n    {\n        int na = min(a, (1<<lb)-1);\n        int nb = b-(1<<lb);\n        ans += solve(na, nb);\n    }\n\n\n    return M[make_pair(a, b)] = ans;\n}\nint main()\n{\n    int T; scanf(""%d"", &T);\n    while(T--)\n    {\n        int a, b;\n        scanf(""%d%d"", &a, &b);\n        long long ans = solve(b, b) - 2*solve(b, a-1) + solve(a-1, a-1);\n        printf(""%lld\\n"", ans);\n    }\n}']","['bitmasks', 'brute force', 'combinatorics', 'dp']",2300
https://codeforces.com//contest/1483/problem/E,E. Vabank,Gustaw is the chief bank manager in a huge bank He has unlimited access to the database system of the bank in a few clicks he can move any amount of money from the bank s reserves to his own private account However the bank uses some fancy AI fraud detection system that makes stealing more difficult Gustaw knows that the anti fraud system just detects any operation that exceeds some fixed limit M euros and these operations are checked manually by a number of clerks Thus any fraud operation exceeding this limit is detected while any smaller operation gets unnoticed Gustaw doesn t know the limit M and wants to find it out In one operation he can choose some integer X and try to move X euros from the bank s reserves to his own account Then the following happens If X le M the operation is unnoticed and Gustaw s account balance raises by X euros Otherwise if X M the fraud is detected and cancelled Moreover Gustaw has to pay X euros from his own account as a fine If he has less than X euros on the account he is fired and taken to the police Initially Gustaw has 1 euro on his account Help him find the exact value of M in no more than 105 operations without getting him fired ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << endl; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n// ll M;\n// const int BIG = 3001;\n// ll dp[BIG][BIG];\n\n// const ll BIG = 1e14;\nconst ll BIG = 1e14;\n\nmt19937_64 RNG;\n// ll _M = RNG()%BIG+1;\n// ll _M = 8117031;\nint max_cnt;\n\nvoid solve(int tc) {\n\tll cur = 1;\n\tll L = 0, R = BIG;\n\tauto ad = [&](ll x) {\n\t\tassert(x <= cur);\n\t\tps(""?"",x);\n\t\tstr s; \n\t\t// if (x <= _M) s = ""Lucky"";\n\t\t// else s = ""F"";\n\t\tre(s);\n\t\tif (s[0] == \'L\') {\n\t\t\tckmax(L,x);\n\t\t\tcur += x;\n\t\t} else {\n\t\t\tckmin(R,x-1);\n\t\t\tcur -= x;\n\t\t}\n\t};\n\tauto eval = [&](ll cur, ll L, ll R) -> db {\n\t\tif (R-L == 0) return -INF;\n\t\treturn log(R)-log(min(100*R,cur))+log(R-L);\n\t};\n\tint cnt = 0;\n\twhile (L < R) {\n\t\t++cnt;\n\t\t// dbg(""HA"",cnt,cur,L,R);\n\t\tif (cur == 1 || cur <= L) {\n\t\t\tad(cur);\n\t\t\tcontinue;\n\t\t}\n\t\t// db mn = INF;\n\t\tll best_mov = -1;\n\t\tauto get_val = [&](ll i) {\n\t\t\tdb a = eval(cur+i,max(i,L),R);\n\t\t\tif (L < i) ckmax(a,eval(cur-i,L,i-1));\n\t\t\treturn a;\n\t\t};\n\t\tauto ternary = [&]() {\n\t\t\tll lo = 1, hi = min(cur-1,R);\n\t\t\twhile (lo < hi) {\n\t\t\t\tll mid = (lo+hi)/2;\n\t\t\t\tif (get_val(mid) < get_val(mid+1)) hi = mid;\n\t\t\t\telse lo = mid+1;\n\t\t\t}\n\t\t\tbest_mov = lo;\n\t\t};\n\t\t// auto ternary = [&]() {\n\t\t// \tfor (ll i = 1; i <= cur-1; ++i) if (cur+i <= R) \n\t\t// \t\tif (best_mov == -1 || get_val(i) < get_val(best_mov)) best_mov = i;\n\t\t// };\n\t\t\n\t\tternary();\n\t\t// dbg(""BEST MOV"",cur,L,R,best_mov);\n\t\t\n\t\t// FOR(i,1,cur) if (cur+i <= R) {\n\t\t// \tdb a = eval(cur+i,max(cur+i,L),R);\n\t\t// \tif (L < cur+i) ckmax(a,eval(cur-i,L,cur+i-1));\n\t\t// \tif (a < mn) {\n\t\t// \t\tmn = a;\n\t\t// \t\tbest_mov = i;\n\t\t// \t}\n\t\t// }\n\t\tad(best_mov);\n\t}\n\tckmax(max_cnt,cnt);\n\t// assert(L == _M);\n\tps(""!"",L);\n\t// re(M);\n\n\t// ll so_far = 0;\n\t// FOR(b,1,BIG) {\n\t// \tROF(a,1,b) { // somewhere in [a,b]\n\t// \t\tdp[a][b] = INF;\n\t// \t\tFOR(x,1,a) if (a+x <= b) {\n\t// \t\t\tll bes = dp[a+x][b]+1;\n\t// \t\t\tif (x > 1) {\n\t// \t\t\t\t// a to a+x-1\n\t// \t\t\t\t// a-x\n\t// \t\t\t\tll cur = a-x, ad = 1;\n\t// \t\t\t\twhile (2*cur < a) cur *= 2, ++ad;\n\t// \t\t\t\tckmax(bes,min(dp[cur][a+x-1]+ad,dp[a][a+x-1]+ad+1));\n\t// \t\t\t\t// ckmax(got,dp[a-x][a+x-1]);\n\t// \t\t\t\t// int ad = 1;\n\t// \t\t\t\t// int cur = a-x;\n\t// \t\t\t\t// while (2*cur < a) {\n\t// \t\t\t\t// \tcur *= 2;\n\t// \t\t\t\t// \t++ad;\n\t// \t\t\t\t// }\n\t// \t\t\t\t// ckmax(got,dp[cur][a+x-1]+ad);\n\t// \t\t\t\t// ckmax(got,dp[][])\n\t// \t\t\t}\n\t// \t\t\tckmin(dp[a][b],bes);\n\t// \t\t}\n\t// \t\tif (a == 1) ckmin(dp[a][b],dp[2*a][b]+1);\n\t// \t}\n\t// \tif (dp[1][b] > so_far) {\n\t// \t\tso_far = dp[1][b];\n\t// \t\tps(b,so_far);\n\t// \t}\n\t// \t// ps(b,dp[1][b]);\n\t// }\n\t// FOR(b,1,1001) {\n\t// \tll tmp = 0;\n\t// \tFOR(a,1,b+1) ckmax(tmp,dp[a][b]);\n\t// \tdbg(b,tmp);\n\t// }\n\n\t// ll a = 1, b = 1e14;\n\t// while (a < b) {\n\t// \t// a+x, b\n\t// \t// a-x, a+x-1\n\n\t// \t// a+1,b\n\t// \t// a-1,a\n\t// }\n}\n\nint main() {\n\tsetIO();\n\t// rep(10000) {\n\t// \t_M = rng()%BIG+1;\n\t// \tsolve(_);\n\t// \tdbg(max_cnt);\n\t// }\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","['binary search', 'dp', 'interactive']",3200
https://codeforces.com//contest/1842/problem/F,F. Tenzing and Tree,Tenzing has an undirected tree of n vertices Define the of a tree with black and white vertices in the following way The of an edge is the absolute difference between the number of black nodes in the two components of the tree after deleting the edge The value of the tree is the sum of values over all edges For all k such that 0 leq k leq n Tenzing wants to know the maximum value of the tree when k vertices are painted black and n k vertices are painted white ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:46:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> ans(n + 1, 0);\n  for (int ver = 0; ver < n; ver++) {\n    vector<int> dist(n, -1);\n    dist[ver] = 0;\n    vector<int> que(1, ver);\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int to : g[que[b]]) {\n        if (dist[to] == -1) {\n          que.push_back(to);\n          dist[to] = dist[que[b]] + 1;\n        }\n      }\n    }\n    vector<int> cnt(n, 0);\n    for (int i = 0; i < n; i++) {\n      cnt[dist[i]] += 1;\n    }\n    int sum = 0;\n    int cc = 0;\n    for (int d = 0; d < n; d++) {\n      for (int rep = 0; rep < cnt[d]; rep++) {\n        sum += d;\n        cc += 1;\n        ans[cc] = max(ans[cc], cc * (n - 1) - 2 * sum);\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    cout << ans[i] << "" \\n""[i == n];\n  }\n  return 0;\n}\n']","['dfs and similar', 'greedy', 'shortest paths', 'sortings', 'trees']",2500
https://codeforces.com//contest/1539/problem/A,A. Contest Start,There are n people participating in some contest they start participating in x minutes intervals That means the first participant starts at time 0 the second participant starts at time x the third at time 2 cdot x and so on Duration of contest is t minutes for each participant so the first participant finishes the contest at time t the second at time t x and so on When a participant finishes the contest their dissatisfaction equals to the number of participants that started the contest or starting it now but haven t yet finished it Determine the sum of dissatisfaction of all participants ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\n\nvoid solve()\n{\n\tll n,x,t;cin>>n>>t>>x;\n\tx/=t;\n\tif(x>n)cout<<n*(n-1)/2<<endl;\n\telse cout<<x*(n-x)+x*(x-1)/2<<endl;\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}\n']","['combinatorics', 'geometry', 'greedy', 'math']",1000
https://codeforces.com//contest/1497/problem/A,A. Meximization,You are given an integer n and an array a 1 a 2 ldots a n You should reorder the elements of the array a in such way that the sum of textbf MEX on prefixes i th prefix is a 1 a 2 ldots a i is maximized Formally you should find an array b 1 b 2 ldots b n such that the sets of elements of arrays a and b are equal it is equivalent to array b can be found as an array a with some reordering of its elements and sum limits i 1 n textbf MEX b 1 b 2 ldots b i is maximized textbf MEX of a set of nonnegative integers is the minimal nonnegative integer such that it is not in the set For example textbf MEX 1 2 3 0 textbf MEX 0 1 2 4 5 3 ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n;\n        cin >> n;\n        vector<ll> a(n);\n        for (int i = 0; i < n; ++i) cin >> a[i];\n        sort(all(a));\n        vector<ll> b = {a[0]};\n        for (int i = 1; i < n; ++i) if (a[i] != a[i - 1]) b.eb(a[i]);\n        for (int i = 1; i < n; ++i) if (a[i] == a[i - 1]) b.eb(a[i]);\n        ll sum = 0;\n        vector<int> g(n + 5);\n        int mex = 0;\n        for (int i = 0; i < n; ++i) {\n            if (b[i] < g.size()) ++g[b[i]];\n            while (g[mex]) ++mex;\n            sum += mex;\n        }\n        for (int i = 0; i < n; ++i) cout << b[i] << "" "";\n        cout << \'\\n\';\n    }\n}\n']","['brute force', 'data structures', 'greedy', 'sortings']",800
https://codeforces.com//contest/235/problem/B,B. Let s Play Osu ,You re playing a game called Osu Here s a simplified version of it There are clicks in a game For each click there are two outcomes correct or bad Let us denote correct as bad as then the whole play can be encoded as a sequence of characters and Using the play sequence you can calculate the score for the play as follows for every maximal consecutive s block add the square of its length the number of characters to the score For example if your play can be encoded as then there s three maximal consecutive s block so your score will be If there are no correct clicks in a play then the score for the play equals to You know that the probability to click the th click correctly is In other words the th character in the play sequence has probability to be to be You task is to calculate the expected score for your play ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ndouble p[100010];\n\nint main(void){\n    int N,i;\n    \n    scanf(""%d"",&N);\n    REP(i,N) scanf(""%lf"",&p[i]);\n    \n    double x = 0.0, ans = 0.0;\n    REP(i,N){\n        x = x * p[i] + p[i];\n        ans += 2.0 * x;\n        ans -= p[i];\n    }\n    \n    printf(""%.9f\\n"", ans);\n    \n    return 0;\n}\n']","['dp', 'math', 'probabilities']",2000
https://codeforces.com//contest/1108/problem/A,A. Two distinct points,You are given two segments l 1 r 1 and l 2 r 2 on the x axis It is guaranteed that l 1 r 1 and l 2 r 2 Segments Your problem is to find two a and b such that l 1 le a le r 1 l 2 le b le r 2 and a ne b In other words you have to choose two integer points in such a way that the first point belongs to the segment l 1 r 1 and the second one belongs to the segment l 2 r 2 It is guaranteed that If there are multiple answers you can print of them You have to answer q independent queries ,"['#include <bits/stdc++.h>\n\n#define fn ""test""\n#define fn1 """"\n\nusing namespace std;\n\nconst int mn = 1 * (int)(1e5) + 10;\nconst int mod = 1 * (int)(1e9) + 7;\nconst int mm = 1 * (int)(1e3) + 10;\nconst int base = 1 * (int)(1e9);\nconst bool aNs = 0;\n\nint tt, ntest = 1;\n\nvoid docfile()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    if (ifstream(fn"".inp""))\n    {\n        freopen(fn"".inp"", ""r"", stdin);\n        if (!aNs) freopen(fn"".out"", ""w"", stdout);\n\t\telse freopen (fn"".ans"", ""w"", stdout);\n    }else if (ifstream(fn1"".inp""))\n    {\n        freopen(fn1"".inp"", ""r"", stdin);\n        freopen(fn1"".out"", ""w"", stdout);\n    }\n}\n\ntemplate <typename T>\nvoid read(T& x)\n{\n    x = 0; T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = ch == \'-\' ? - f : f, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - \'0\', ch = getchar();\n    x *= f;\n}\n\ntemplate <typename T>\nvoid write (T a)\n{\n    if (a < 0)\n    {\n        putchar (\'-\');\n        write (-a);\n        return;\n    }\n    if (a < 10)\n    {\n        putchar (\'0\' + a);\n        return;\n    }\n    write (a / 10);\n    putchar ((char)(\'0\' + (a % 10)));\n}\n\nvoid enter()\n{\n    int l1, l2, r1, r2;\n    cin >> l1 >> r1 >> l2 >> r2;\n    if (l1 > l2 || (l1 == l2 && r1 > r2))\n    cout << r1 << "" "" << l2 << ""\\n"";\n    else\n    cout << l1 << "" "" << r2 << ""\\n"";\n}\n\nvoid solve()\n{\n\n}\n\nvoid print_result()\n{\n\n}\n\nint main()\n{\n    docfile();\n    cin>>ntest;\n    for (tt = 1; tt <= ntest; ++ tt)\n    {\n        enter();\n        solve();\n        print_result();\n    }\n}']",['implementation'],800
https://codeforces.com//contest/1506/problem/D,D. Epic Transformation,You are given an array a of length n consisting of integers You can apply the following operation consisting of several steps on the array a or more times you select two numbers in the array a i and a j you remove i th and j th elements from the array For example if n 6 and a 1 6 1 1 4 4 then you can perform the following sequence of operations select i 1 j 5 The array a becomes equal to 6 1 1 4 select i 1 j 2 The array a becomes equal to 1 4 What can be the minimum size of the array after applying some sequence of operations to it ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\nmap <int,int> mp;\nint main(int argc, char** argv) {\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,mx=0;\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tmx=max(mx,++mp[x]);\n\t\t}\n\t\tprintf(""%d\\n"",max(mx*2-n,n%2));\n\t\tmp.clear();\n\t}\n\treturn 0;\n}']","['constructive algorithms', 'data structures', 'greedy']",1400
https://codeforces.com//contest/1842/problem/I,I. Tenzing and Necklace,Tenzing has a beautiful necklace The necklace consists of n pearls numbered from 1 to n with a string connecting pearls i and i text mod n 1 for all 1 leq i leq n One day Tenzing wants to cut the necklace into several parts by cutting some strings But for each connected part of the necklace there should not be more than k pearls The time needed to cut each string may not be the same Tenzing needs to spend a i minutes cutting the string between pearls i and i text mod n 1 Tenzing wants to know the minimum time in minutes to cut the necklace such that each connected part will not have more than k pearls ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n//fast IO by yosupo\n//sc.read(string) だと append される\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = \'\\0\';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        ref.clear();\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();            \n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == \'-\') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - \'0\');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(vector<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(\' \');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single(\'\\n\');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single(\'0\');\n            return;\n        }\n        if (val < 0) {\n            write_single(\'-\');\n            val = -val;  // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(\'0\' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const vector<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(\' \');\n            write_single(val[i]);\n        }\n    }\n    void write_single(long double d){\n\t\t{\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n\t\twrite_single(\'.\');\n\t\tfor(int _=0;_<8;_++){\n\t\t\td*=10;\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n    }\n};\n\nScanner sc(stdin);\nPrinter pr(stdout);\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS getrev(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\n//f(a,b) が true なら a を削除する\n//less をわたすと slide max が取れる\ntemplate<class t,class u>\nstruct slide{\n\tvc<t> x;\n\tvi y;\n\tu f;\n\tint s,b,e,c,d;\n\tslide(u ff=u()):f(ff){init();}\n\tvoid init(){s=b=e=c=d=0;}\n\tvoid push(t a){\n\t\ts++;\n\t\twhile(b<e&&f(x[e-1],a))e--;\n\t\tif(e==(int)x.size()){\n\t\t\tx.eb();\n\t\t\ty.eb();\n\t\t}\n\t\tx[e]=a;\n\t\ty[e++]=c++;\n\t}\n\tvoid pop(){s--;if(y[b]==d)b++;d++;}\n\tt get(){assert(s);return x[b];}\n\tbool has(){return b<e;}\n\tint size(){return s;}\n};\n\n//use 0\npair<int,vi> sub(int n,int k,vi a){\n\tvc<pi> dp(n);\n\tslide<pi,greater<pi>> s;\n\trep(i,n){\n\t\tpi val=i==0?pi(0,-1):s.get();\n\t\tval.a+=a[i];\n\t\tdp[i]=val;\n\t\ts.push(pi(dp[i].a,i));\n\t\tif(i>=k)s.pop();\n\t}\n\tauto [cost,x]=s.get();\n\tvi pos;\n\twhile(x!=-1){\n\t\tpos.pb(x);\n\t\tx=dp[x].b;\n\t}\n\treverse(all(pos));\n\treturn mp(cost,pos);\n}\n\nint brute(int n,int k,vi a){\n\tint res=inf;\n\trep(i,n){\n\t\tchmin(res,sub(n,k,a).a);\n\t\trotate(a.bg,a.bg+1,a.ed);\n\t}\n\treturn res;\n}\n\nint work(int n,int k,vi a,vi pos,int over){\n\ta.pb(a[0]);\n\tpos.pb(n);\n\t\n\tvvc<int> cs(si(pos)-1);\n\trep(i,si(pos)-1){\n\t\trng(j,pos[i],pos[i+1]+1)\n\t\t\tcs[i].pb(a[j]);\n\t}\n\tint K=si(cs);\n\tvi common(K-1,1);\n\tif(over){\n\t\tvvc<int> ds(K-1);\n\t\trep(i,K-1){\n\t\t\tds[i]=cs[i];\n\t\t\tds[i].insert(ds[i].ed,1+all(cs[i+1]));\n\t\t}\n\t\tif(over==1){\n\t\t\tcommon.clear();\n\t\t\trng(i,1,K-1)common.pb(si(cs[i]));\n\t\t\tK--;\n\t\t}else if(over==2){\n\t\t\tds.insert(ds.bg,cs[0]);\n\t\t\tds.insert(ds.ed,cs[K-1]);\n\t\t\tcommon.clear();\n\t\t\trep(i,K)common.pb(si(cs[i]));\n\t\t\tK++;\n\t\t}\n\t\tcs.swap(ds);\n\t}\n\tcs.pb(cs[0]);\n\tK++;\n\tcommon.pb(1);\n\t\n\tdmp(cs);\n\tdmp(common);\n\n\tvvc<pi> dp(K);\n\trep(i,K)dp[i].resize(si(cs[i]));\n\tvvc<int> pre(K);\n\trep(i,K)pre[i].resize(si(cs[i]));\n\t\n\tint ans=inf;\n\n\tauto solve_single=[&](int ini,const vi&ls,const vi&rs)->vi{\n\t\tassert(inc(ls[0],ini,rs[0]));\n\t\tassert(inc(ls[K-1],ini,rs[K-1]));\n\t\trep(i,K){\n\t\t\trng(j,ls[i],rs[i]+1){\n\t\t\t\tdp[i][j]=pi(inf,-1);\n\t\t\t\tpre[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tdp[0][ini]=pi(0,ini);\n\t\trng(i,1,K){\n\t\t\tgnr(j,ls[i-1],rs[i-1]){\n\t\t\t\tchmin(dp[i-1][j],dp[i-1][j+1]);\n\t\t\t}\n\t\t\trng(j,ls[i],rs[i]+1){\n\t\t\t\tint x=si(cs[i-1])-common[i-1]+j-k;\n\t\t\t\tchmax(x,ls[i-1]);\n\t\t\t\tif(x<=rs[i-1]){\n\t\t\t\t\tdp[i][j]=pi(min(dp[i-1][x].a+cs[i][j],inf),j);\n\t\t\t\t\tpre[i][j]=dp[i-1][x].b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[K-1][ini].a>=inf){\n\t\t\tvi mid=rs;\n\t\t\tmid[0]=mid[K-1]=ini;\n\t\t\treturn mid;\n\t\t}\n\t\tchmin(ans,dp[K-1][ini].a);\n\t\tvi mid(K);\n\t\tint cur=ini;\n\t\tper(i,K){\n\t\t\tmid[i]=cur;\n\t\t\tcur=pre[i][cur];\n\t\t}\n\t\tassert(mid[0]==ini);\n\t\treturn mid;\n\t};\n\t\n\tauto rec=[&](auto self,const vi&ls,const vi&rs)->void{\n\t\tif(ls[0]>rs[0])return;\n\t\tint ini=(ls[0]+rs[0])/2;\n\t\t//dmp2(ls[0],rs[0],ini);\n\t\t\n\t\tvi mid=solve_single(ini,ls,rs);\n\t\tif(mid.empty())return;\n\t\t\n\t\tmid[0]--;\n\t\tself(self,ls,mid);\n\t\tmid[0]+=2;\n\t\tself(self,mid,rs);\n\t};\n\t\n\tvi ls,rs;\n\trep(i,K){\n\t\tls.pb(0);\n\t\trs.pb(si(cs[i])-1);\n\t}\n\trec(rec,ls,rs);\n\tdmp(ans);\n\t\n\treturn ans;\n}\n\nint fast(int n,int k,vi a){\n\trotate(a.bg,min_element(all(a)),a.ed);\n\tvi pos=sub(n,k,a).b;\n\t\n\tint ans=work(n,k,a,pos,0);\n\tif(si(pos)>2){\n\t\tchmin(ans,work(n,k,a,pos,1));\n\t}\n\tchmin(ans,work(n,k,a,pos,2));\n\treturn ans;\n}\n\nvoid slv(){\n\tint n,k;sc.read(n,k);\n\tvi a(n);rep(i,n)sc.read(a[i]);\n\tprint(fast(n,k,a));\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t/*auto test=[&](int n,int k,vi a){\n\t\tint god=brute(n,k,a);\n\t\tint ans=fast(n,k,a);\n\t\t\n\t\tif(god!=ans){\n\t\t\tcerr<<n<<"" ""<<k<<"" ""<<a<<endl;\n\t\t\tcerr<<god<<"" ""<<ans<<endl;\n\t\t}\n\t\tassert(god==ans);\n\t};\n\t\n\ttest(9,3,{1,1,3,2,1,1,2,3,1,});\n\ttest(3,1,{3,1,3,});\n\ttest(4,2,{2,1,3,1,});\n\ttest(4,2,{3,1,2,1,});\n\n\trng(n,3,20){\n\t\tcerr<<n<<endl;\n\t\trep(_,10000){\n\t\t\tvi a(n);\n\t\t\trep(i,n)a[i]=rand_int(1,20);\n\t\t\t\n\t\t\trng(k,1,n){\n\t\t\t\ttest(n,k,a);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\t/*{\n\t\tint n=5*ten(5);\n\t\tint k=1000;\n\t\tvi a(n);\n\t\trep(i,n)a[i]=rand_int(1,1);\n\t\t\n\t\tprint(fast(n,k,a));\n\t\t//test(n,k,a);\n\t\treturn 0;\n\t}*/\n\t\n\tint t;sc.read(t);rep(_,t)\n\tslv();\n}\n']","['divide and conquer', 'dp', 'greedy']",3500
https://codeforces.com//contest/911/problem/F,F. Tree Destruction,You are given an unweighted tree with vertices Then following operations are applied to the tree A single operation consists of the following steps choose two leaves add the length of the simple path between them to the answer remove one of the chosen leaves from the tree Initial answer before applying operations is Obviously after such operations the tree will consist of a single vertex Calculate the maximal possible answer you can achieve and construct a sequence of operations that allows you to achieve this answer ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic int N;\nstatic vector<vi> edges;\nstatic vi parent;\nstatic vi depth;\nstatic vector<pii> dist;\nstatic vector<bool> diam;\nstatic int D, root, bot;\nstatic vector<pii> cuts;\n\nstatic void dfs(int cur, int p, int d)\n{\n    parent[cur] = p;\n    depth[cur] = d;\n    for (int v : edges[cur])\n        if (v != p)\n            dfs(v, cur, d + 1);\n}\n\nstatic pii get_dist(int cur)\n{\n    if (dist[cur].first == -1)\n    {\n        if (diam[cur])\n        {\n            if (depth[cur] > D - depth[cur])\n                dist[cur] = pii(depth[cur], root);\n            else\n                dist[cur] = pii(D - depth[cur], bot);\n        }\n        else\n        {\n            auto sub = get_dist(parent[cur]);\n            sub.first++;\n            cuts.emplace_back(sub.second, cur);\n            dist[cur] = sub;\n        }\n    }\n    return dist[cur];\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    cin >> N;\n    edges.resize(N);\n    parent.resize(N);\n    depth.resize(N);\n    diam.resize(N);\n    dist.resize(N, pii(-1, -1));\n    for (int i = 0; i < N - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    dfs(0, -1, 0);\n    root = max_element(RA(depth)) - depth.begin();\n    dfs(root, -1, 0);\n    bot = max_element(RA(depth)) - depth.begin();\n    D = depth[bot];\n    for (int i = bot; i != -1; i = parent[i])\n        diam[i] = true;\n    ll score = ll(D) * ll(D + 1) / 2;\n    for (int i = 0; i < N; i++)\n        if (!diam[i])\n        {\n            auto sub = get_dist(i);\n            score += sub.first;\n        }\n    reverse(RA(cuts));\n    for (int i = bot; i != root; i = parent[i])\n        cuts.emplace_back(root, i);\n    cout << score << \'\\n\';\n    for (const auto &c : cuts)\n        cout << c.first + 1 << \' \' << c.second + 1 << \' \' << c.second + 1 << \'\\n\';\n\n    return 0;\n}\n']","['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",2400
https://codeforces.com//contest/1800/problem/G,G. Symmetree,Kid was gifted a tree of n vertices with the root in the vertex 1 Since he really like objects Kid wants to find out if this tree is Formally a tree is if there exists an order of children such that The subtree of the leftmost child of the root is a mirror image of the subtree of the rightmost child the subtree of the second left child of the root is a mirror image of the subtree of the second right child of the root if the number of children of the root is odd then the subtree of the middle child should be ,"['// I am teacher of MakaPakka\n// LOUGI_ID:643723\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(x,y) for(int x=0;x<(y);x++)\ninline int in(){\n  int x;\n  cin >> x;\n  return x;\n}\nconst int N=2e5;\nint n,dt[N+5],h_val[N+5];\nvector<int> g[N+5];\nvoid get_depth(int v,int p=-1){\n  for(int u:g[v])if(u!=p){\n    dt[u]=dt[v]+1;\n    get_depth(u,v);\n  }\n}\nint timer=0;\nmap<vector<int>,int> hsh;\nvoid get_hash(int v,int p=-1){\n  vector<int> c={dt[v]};\n  for(int u:g[v])if(u!=p){\n    get_hash(u,v);\n    c.push_back(h_val[u]);\n  }\n  if(int(c.size())>1)sort(c.begin()+1,c.end());\n  if(hsh.count(c))h_val[v]=hsh[c];\n  else{\n    hsh[c]=timer,h_val[v]=timer;\n    timer++;\n  }\n}\nbool test(int v,int p=-1){\n  vector<array<int,2>> c;\n  for(int u:g[v])if(u!=p){\n    c.pb({h_val[u],u});\n  }\n  sort(c.begin(), c.end());\n  for(int i=0;i+1<int(c.size());i++){\n    if(c[i][0]==c[i+1][0]){\n      c[i]=c[i+1]={-1,-1};\n      i++;continue;\n    }\n  }\n  int badcnt=0,bad=-1;\n  for(int i=0;i<int(c.size());i++){\n    if(c[i]!=array<int,2>({-1,-1}))badcnt++,bad=c[i][1];\n  }\n  if(badcnt>1)return false;\n  else if(badcnt==0)return true;\n  else return test(bad,v);\n  return true;\n}\nvoid solve(){\n  n=in();\n  timer=0,hsh.clear();\n  rep(i,n+5)g[i].clear(),h_val[i]=dt[i]=0;\n  rep(i,n-1){\n    int x=in()-1,y=in()-1;\n    g[x].pb(y),g[y].pb(x);\n  }\n  get_depth(0);\n  get_hash(0);\n  cout<<(test(0)?""YES\\n"":""NO\\n"");\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while(T--) solve();\n}']","['dfs and similar', 'hashing', 'implementation', 'trees']",2200
https://codeforces.com//contest/1063/problem/D,D. Candies for Children,At the children s festival children were dancing in a circle When music stopped playing the children were still standing in a circle Then Lena remembered that her parents gave her a candy box with exactly k candies Wilky May Lena is not a greedy person so she decided to present all her candies to her friends in the circle Lena knows that some of her friends have a sweet tooth and others do not Sweet tooth takes out of the box two candies if the box has at least two candies and otherwise takes one The rest of Lena s friends always take exactly one candy from the box Before starting to give candies Lena step out of the circle after that there were exactly n people remaining there Lena numbered her friends in a clockwise order with positive integers starting with 1 in such a way that index 1 was assigned to her best friend Roma Initially Lena gave the box to the friend with number l after that each friend starting from friend number l took candies from the box and passed the box to the next friend in clockwise order The process ended with the friend number r taking the last candy or two who knows and the empty box Please note that it is possible that some of Lena s friends took candy from the box several times that is the box could have gone several full circles before becoming empty Lena does not know which of her friends have a sweet tooth but she is interested in the maximum possible number of friends that can have a sweet tooth If the situation could not happen and Lena have been proved wrong in her observations please tell her about this ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nLL N, K, L, R;\nLL g1, d1, g2, d2;\nLL answer = -1;\n\nint CheckTotalG(LL total_g) {\n  if (total_g > N) { return 1; }\n  if (total_g < 0) { return -1; }\n  const LL div = N + total_g;\n  LL m = K % div;\n  if (m == 0) { m = div; }\n  const LL min_left = max<LL>(0, total_g - d2);\n  debug(N, total_g, min_left, m);\n  if (m < d1 + max<LL>(0, min_left - 1)) { return 1; }\n  if (m > d1 + min<LL>(d1, total_g)) { return -1; }\n  debug(""ok"");\n  maxi(answer, total_g);\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> L >> R >> K;\n\n  R = (R - L + N) % N;\n  L = 0;\n  debug(N, K, L, R);\n\n  d1 = R + 1;\n  d2 = N - d1;\n  debug(d1, d2);\n  // max_g = N;\n\n  // const LL max_iter_g = max_g;\n  const LL max_iter_g = min(N, (int)(sqrt(K) + 3));\n\n  for (LL tot_g = 0; tot_g <= max_iter_g; ++tot_g)\n    CheckTotalG(tot_g);\n\n  for (LL alpha = 0; alpha <= max_iter_g; ++alpha) {\n    if (K - alpha * N < 0) { break; }\n    LL max_g = alpha ? (K - alpha * N) / alpha : N;\n    LL min_g = (K - (alpha + 1) * N + alpha) / (alpha + 1);\n    maxi<LL>(min_g, 0);\n    mini<LL>(max_g, N);\n    if (max_g < min_g) { continue; }\n\n    debug(alpha, min_g, max_g);\n    ++max_g;\n\n    while (max_g - min_g > 1) {\n      const LL mid_g = (max_g + min_g) / 2;\n      if (CheckTotalG(mid_g) == 1)\n        max_g = mid_g;\n      else\n        min_g = mid_g;\n    }\n\n    CheckTotalG(max_g);\n    CheckTotalG(max_g - 1);\n    CheckTotalG(max_g - 2);\n\n  }\n\n  cout << answer << ""\\n"";\n}\n\n']","['brute force', 'math']",2600
https://codeforces.com//contest/1451/problem/D,D. Circle Game,Utkarsh is forced to play yet another one of Ashish s games The game progresses turn by turn and as usual Ashish moves Consider the 2D plane There is a token which is initially at In one move a player must increase either the x coordinate or the y coordinate of the token by k In doing so the player must ensure that the token stays within a Euclidean distance d from 0 0 In other words if after a move the coordinates of the token are p q then p 2 q 2 leq d 2 must hold The game ends when a player is unable to make a move It can be shown that the game will end in a finite number of moves If both players play optimally determine who will win ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nvoid solve(vi a)\n{\n\tint n=a.size();\n\tsort(a.rbegin(), a.rend());\n\tint k = 1;\n\twhile (k + 1 <= n && a[k] >= k + 1) {\n\t\tk += 1;\n\t}\n\tint up = a[k - 1] - k;\n\tint right = 0;\n\twhile (k + right < n && a[k + right] == k) {\n\t\t++right;\n\t}\n\tcout << (up % 2 == 0 && right % 2 == 0 ? ""Ashish"" : ""Utkarsh"") << \'\\n\';\n}\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tll d,k; cin>>d>>k;\n\t\tll bestr = (d*d)/(k*k);\n\t\tvi ans;\n\t\tll cur=0;\n\t\twhile(cur*cur<=bestr)\n\t\t{\n\t\t\tll rem = bestr-cur*cur;\n\t\t\tll ps = max(ll(floor(sqrt(double(rem))))-1,0LL);\n\t\t\twhile((ps+1)*(ps+1)<=rem) ps++;\n\t\t\t//cerr<<""CUR, PS = ""<<cur<<\' \'<<ps<<\'\\n\';\n\t\t\tans.pb(ps);\n\t\t\tcur++;\n\t\t}\n\t\t/*\n\t\tfor(int x:ans)\n\t\t{\n\t\t\tcout<<x<<\' \';\n\t\t}\n\t\tcout<<\'\\n\';\n\t\t*/\n\t\tsolve(ans);\n\t}\n}\n']","['games', 'geometry', 'math']",1700
https://codeforces.com//contest/629/problem/A,A. Far Relative’s Birthday Cake,Door s family is going celebrate Famil Doors s birthday party They love Famil Door so they are planning to make his birthday cake weird The cake is a square consisting of equal squares with side length Each square is either empty or consists of a single chocolate They bought the cake and randomly started to put the chocolates on the cake The value of Famil Door s happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake Famil Doors s family is wondering what is the amount of happiness of Famil going to be Please note that any pair can be counted no more than once as two different cells can t share both the same row and the same column ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define pll pair < ll, ll >\n#define all(s) s.begin(), s.end()\n#define sz(s) (int) s.size()\n#define vi vector < int >\n\nconst int inf = (int)1e9;\nconst int mod = (int) 1e9 + 7;\n\nint n;\nstring s[1111];\n\nint main () {\n    #ifdef LOCAL\n    freopen (""a.in"", ""r"", stdin);\n    freopen (""a.out"", ""w"", stdout);\n    #endif\n    cin >> n;\n    for(int i = 0; i < n; i++){\n    \tcin >> s[i];\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n    \tint cnt= 0;\n    \tfor(int j = 0; j < n; j++){\n    \t\tif(s[i][j] == \'C\') cnt++;\n    \t}\n    \tans += cnt * (cnt - 1)/2;\n    }\n    for(int i = 0; i < n; i++){\n    \tint cnt= 0;\n    \tfor(int j = 0; j < n; j++){\n    \t\tif(s[j][i] == \'C\') cnt++;\n    \t}\n    \tans += cnt * (cnt - 1)/2;\n    }\n    cout << ans << endl;\n    \n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n    #endif\n    return 0;\n}\n\n\n']","['brute force', 'combinatorics', 'constructive algorithms', 'implementation']",800
https://codeforces.com//contest/580/problem/D,D. Kefa and Dishes,When Kefa came to the restaurant and sat at a table the waiter immediately brought him the menu There were dishes Kefa knows that he needs exactly dishes But at that he doesn t want to order the same dish twice to taste as many dishes as possible Kefa knows that the th dish gives him units of satisfaction But some dishes do not go well together and some dishes go very well together Kefa set to himself rules of eating food of the following type if he eats dish exactly before dish there should be no other dishes between and then his satisfaction level raises by Of course our parrot wants to get some maximal possible satisfaction from going to the restaurant Help him in this hard task ,"['#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\n#include<bitset>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=18;\nint a[N],pp[N][N];\nlong long f[1<<18][N];\nint it_num(int x)\n{\n    int s=0;\n    while(x)\n    {\n        if (x % 2==1) s++;\n        x/=2;\n    }\n    return s;\n}\nint main() {\n    int n,m,k;\n    cin>>n>>m>>k;\n    memset(pp,0,sizeof(pp));\n    for(int i=0;i<n;i++) scanf(""%d"",&a[i]);\n    for(int i=1;i<=k;i++)\n    {\n        int p,q,t;\n        scanf(""%d%d%d"",&p,&q,&t);\n        p--;q--;\n        pp[p][q]=t;\n    }\n    long long ans=0;\n    memset(f,0,sizeof(f));\n    for(int i=0;i<n;i++) f[1<<i][i]=a[i];\n    for(int mask=0;mask<(1<<n);mask++)\n        for(int t=0;t<n;t++)\n            if((mask & (1<<t)) !=0)\n            {\n                for(int i=0;i<n;i++)\n                    if((mask & (1<<i)) == 0)\n                    {\n                        int tmp=mask+(1<<i);\n                        f[tmp][i]=max(f[tmp][i],f[mask][t]+(long long)a[i]+(long long)pp[t][i]);\n                    }\n                if(it_num(mask) == m) ans=max(ans,f[mask][t]);\n            }\n    cout<<ans<<endl;\n    return 0;\n}']","['bitmasks', 'dp']",1800
https://codeforces.com//contest/1921/problem/B,B. Arranging Cats,Scientists have n boxes in which cats may or may not sit Let the current state of the boxes be denoted by the sequence b 1 dots b n b i 1 if there is a cat in box number i and b i 0 otherwise Fortunately the unlimited production of cats has already been established so in one day the scientists can perform one of the following operations Take a new cat and place it in a box for some i such that b i 0 assign b i 1 Remove a cat from a box and send it into retirement for some i such that b i 1 assign b i 0 Move a cat from one box to another for some i j such that b i 1 b j 0 assign b i 0 b j 1 It has also been found that some boxes were immediately filled with cats Therefore the scientists know the initial position of the cats in the boxes s 1 dots s n and the desired position f 1 dots f n Due to the large amount of paperwork the scientists do not have time to solve this problem Help them for the sake of science and indicate the minimum number of days required to test the hypothesis ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,x=0,y=0,z=0;\n    cin>>n;\n    string a,b;\n    cin>>a>>b;\n    for(ll i=0;i<n;i++){\n        if(a[i]==\'1\') x++;\n        if(b[i]==\'1\') y++;\n        if(a[i]==\'1\'&&b[i]==\'1\') z++;\n    }\n    if(x>=y) cout<<x-z;\n    else cout<<y-z;\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","['greedy', 'implementation']",800
https://codeforces.com//contest/835/problem/B,B. The number on the board,Some natural number was written on the board Its sum of digits was not less than But you were distracted a bit and someone changed this number to replacing some digits with others It s known that the length of the number didn t change You have to find the minimum number of digits in which these two numbers can differ ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nchar s[1000010];\nint c[20];\nint main()\n{\n\tint k;\n\tscanf(""%d"",&k);\n\tscanf(""%s"",s+1);\n\tint n=strlen(s+1);\n\tint sum=0;\n\tint i;\n\tmemset(c,0,sizeof c);\n\tint ans=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tc[s[i]-\'0\']++;\n\t\tsum+=s[i]-\'0\';\n\t}\n\tsum=k-sum;\n\tfor(i=0;i<=9;i++)\n\t\twhile(sum>0&&c[i])\n\t\t{\n\t\t\tsum-=9-i;\n\t\t\tans++;\n\t\t\tc[i]--;\n\t\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']",['greedy'],1100
https://codeforces.com//contest/822/problem/C,"C. Hacker, pack your bags ",It s well known that the best way to distract from something is to do one s favourite thing Job is such a thing for Leha So the hacker began to work hard in order to get rid of boredom It means that Leha began to hack computers all over the world For such zeal boss gave the hacker a vacation of exactly days You know the majority of people prefer to go somewhere for a vacation so Leha immediately went to the travel agency There he found out that vouchers left th voucher is characterized by three integers day of departure from Vi kopolis day of arriving back in Vi kopolis and cost of the voucher correspondingly The duration of the th voucher is a value At the same time Leha wants to split his own vocation into two parts Besides he wants to spend as little money as possible Formally Leha wants to choose exactly two vouchers and so that they don t intersect sum of their durations is and their total cost is as minimal as possible Two vouchers and don t intersect if only at least one of the following conditions is fulfilled or Help Leha to choose the necessary vouchers ,"['#include <bits/stdc++.h>\n\nstd::vector <std::tuple <int, int, int>> op;\n\nint N, X;\nint L[210000], R[210000], cost[210000];\n\nint dp[210000];\nint ans = -1;\n\nint main () {\n\tscanf (""%d%d"", &N, &X);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf (""%d%d%d"", &L[i], &R[i], &cost[i]);\n\t\top.push_back (std::make_tuple (L[i], 0, i));\n\t\top.push_back (std::make_tuple (R[i], 1, i));\n\t}\n\tstd::sort (op.begin (), op.end ());\n\tfor (int i = 0; i < op.size (); ++i) {\n\t\tint o = std::get <1> (op[i]), ind = std::get <2> (op[i]);\n\t\tif (o == 0) {\n\t\t\tint dur = R[ind] - L[ind] + 1, nec = X - dur;\n\t\t\tif (nec < 0 || dp[nec] == 0) continue;\n\t\t\tif (ans == -1 || ans > dp[nec] + cost[ind]) ans = dp[nec] + cost[ind];\n\t\t} else {\n\t\t\tint dur = R[ind] - L[ind] + 1;\n\t\t\tif (dp[dur] == 0 || dp[dur] > cost[ind]) dp[dur] = cost[ind];\n\t\t}\n\t}\n\tprintf (""%d\\n"", ans);\n}\n\n']","['binary search', 'greedy', 'implementation', 'sortings']",1600
https://codeforces.com//contest/676/problem/A,A. Nicholas and Permutation,Nicholas has an array that contains integers from to In other words Nicholas has a permutation of size Nicholas want the minimum element integer and the maximum element integer to be as far as possible from each other He wants to perform exactly one swap in order to maximize the distance between the minimum and the maximum elements The distance between two elements is considered to be equal to the absolute difference between their positions ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin>>n;\n\tint x;\n\tint p1,p2;\n\tfor(int i=1;i<=n;++i) {\n\t\tcin>>x;\n\t\tif(x == 1) p1=i;\n\t\tif(x == n) p2=i;\n\t}\n\n\tif(p1 == 1 || p1 == n || p2 == 1 || p2 == n) {\n\t\tcout<<n-1<<""\\n"";\n\t}\n\telse {\n\t\tint a = max(p1-1, n-p1);\n\t\tint b = max(p2-1, n-p2);\n\t\tcout<<max(a,b)<<""\\n"";\n\t}\n\n\treturn 0;\n}\n']","['constructive algorithms', 'implementation']",800
https://codeforces.com//contest/1322/problem/A,A. Unusual Competitions,A bracketed sequence is called correct regular if by inserting and 1 you can get a well formed mathematical expression from it For example sequences and are correct while and are not The teacher gave Dmitry s class a very strange task she asked every student to come up with a sequence of arbitrary length consisting only of opening and closing brackets After that all the students took turns naming the sequences they had invented When Dima s turn came he suddenly realized that all his classmates got the correct bracketed sequence and whether he got the correct bracketed sequence he did not know Dima suspects now that he simply missed the word correct in the task statement so now he wants to save the situation by modifying his sequence slightly More precisely he can possibly zero perform the operation The reorder operation consists of choosing an arbitrary consecutive subsegment substring of the sequence and then reordering all the characters in it in an arbitrary way Such operation takes l nanoseconds where l is the length of the subsegment being reordered It s easy to see that reorder operation doesn t change the number of opening and closing brackets For example for he can choose the substring and do reorder this operation will take 2 nanoseconds Since Dima will soon have to answer he wants to make his sequence correct as fast as possible Help him to do this or determine that it s impossible ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nint n;\nchar s[1000005];\nint main(){\n\tscanf(""%d%s"",&n,s+1);\n\tint ss=0,sum=0;\n\tFor(i,1,n){\n\t\tint ns=(ss+(s[i]==\'(\'?1:-1));\n\t\tif (ns<0||ss<0) ++sum;\n\t\tss=ns;\n\t}\n\tif (ss) puts(""-1"");\n\telse printf(""%d\\n"",sum);\n} ']",['greedy'],1300
https://codeforces.com//contest/518/problem/D,D. Ilya and Escalator,Ilya got tired of sports programming left university and got a job in the subway He was given the task to determine the escalator load factor Let s assume that people stand in the queue for the escalator At each second one of the two following possibilities takes place either the first person in the queue enters the escalator with probability or the first person in the queue doesn t move with probability paralyzed by his fear of escalators and making the whole queue wait behind him Formally speaking the th person in the queue cannot enter the escalator until people with indices from to inclusive enter it In one second only one person can enter the escalator The escalator is infinite so if a person enters it he never leaves it that is he will be standing on the escalator at any following second Ilya needs to count the expected value of the number of people standing on the escalator after seconds Your task is to help him solve this complicated task ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\ndouble dp[2111][2111];//i-th day, j people\nint main()\n{\n\tint i,j,k;\n\tdp[0][0]=1;\n\tint n,t;\n\tdouble p;\n\tcin>>n>>p>>t;\n\tfor (i=0;i<=t;i++)\n\t{\n\t\tfor (j=0;j<=n;j++)\n\t\t{\n\t\t\tif (j==n)\n\t\t\t{\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i+1][j+1]+=dp[i][j]*p;\n\t\t\tdp[i+1][j]+=dp[i][j]*(1-p);\n\t\t}\n\t}\n\tdouble ans=0;\n\tfor (i=0;i<=n;i++)\n\t{\n\t\tans+=i*dp[t][i];\n\t}\n\tprintf(""%.10lf\\n"",ans);\n\treturn 0;\n}\n\t\t\t']","['combinatorics', 'dp', 'math', 'probabilities']",1700
https://codeforces.com//contest/1389/problem/C,C. Good String,Let s call of some string t 1 t 2 t 3 dots t n 1 t n as string t 2 t 3 dots t n 1 t n t 1 Analogically let s call of string t as string t n t 1 t 2 t 3 dots t n 1 Let s say string t is if its left cyclic shift is equal to its right cyclic shift You are given string s which consists of digits What is the minimum number of characters you need to erase from s to make it good ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int A = 10;\nchar s[N];\nint a[N];\nint ans;\nint n;\n\nint solveOne(int x) {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] == x)\n\t\t\tans++;\n\treturn ans;\n}\nint solveTwo(int x, int y) {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ans & 1) {\n\t\t\tif (a[i] == y)\n\t\t\t\tans++;\n\t\t} else {\n\t\t\tif (a[i] == x)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tans -= (ans & 1);\n\treturn ans;\n}\n\nvoid solve() {\n\tscanf(""%s"", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = (int)(s[i] - \'0\');\n\tans = 0;\n\tfor (int i = 0; i < A; i++)\n\t\tans = max(ans, solveOne(i));\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < A; j++)\n\t\t\tif (i != j)\n\t\t\t\tans = max(ans, solveTwo(i, j));\n\tprintf(""%d\\n"", n - ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","['brute force', 'dp', 'greedy', 'two pointers']",1500
https://codeforces.com//contest/546/problem/B,B. Soldier and Badges,Colonel has badges He wants to give one badge to every of his soldiers Each badge has a which shows how much it s owner reached Coolness factor can be increased by one for the cost of one coin For every pair of soldiers one of them should get a badge with strictly higher factor than the second one Exact values of their factors aren t important they just need to have distinct factors Colonel knows which soldier is supposed to get which badge initially but there is a problem Some of badges may have the same factor of coolness Help him and calculate how much money has to be paid for making all badges have different factors of coolness ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\nint main(){\n    int n;\n    int x[3005];\n    cin >> n;\n    rep2(i,n) cin >> x[i];\n    sort(x+1,x+n+1);\n    int prev = -1000,res = 0;\n    rep2(i,n){\n    \tif(prev+1 <= x[i]){\n    \t\tprev = x[i];\n    \t}\n    \telse{\n    \t\tres += prev+1-x[i];\n    \t\tprev++;\n    \t}\n    }\n    cout << res << endl;\n}']","['brute force', 'greedy', 'implementation', 'sortings']",1200
https://codeforces.com//contest/191/problem/E,E. Thwarting Demonstrations,It is dark times in Berland Berlyand opposition funded from a neighboring state has organized a demonstration in Berland capital Bertown Through the work of intelligence we know that the demonstrations are planned to last for days Fortunately Berland has a special police unit which can save the country It has exactly soldiers numbered from to Berland general the commander of the detachment must schedule the detachment s work in these difficult days In each of these days the general must send a certain number of police officers to disperse riots Since the detachment is large and the general is not very smart he can only select a set of all soldiers numbered from to inclusive where and are selected arbitrarily Now the general has exactly two problems First he cannot send the same group twice then soldiers get bored and they rebel Second not all soldiers are equally reliable Every soldier has a reliability of The reliability of the detachment is counted as the sum of reliabilities of soldiers in it The reliability of a single soldier can be negative then when you include him in the detachment he will only spoil things The general is distinguished by his great greed and shortsightedness so each day he sends to the dissolution the most reliable group of soldiers possible that is of all the groups that have not been sent yet The Berland Government has decided to know what would be the minimum reliability of the detachment sent to disperse the demonstrations during these days The general himself can not cope with such a difficult task Help him to not embarrass himself in front of his superiors ,"['#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME ""std""\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst ll INF = 1e18;\nclass segm_tree {\n  const vll &vals;\n  int off;\n  vi tr;\n  \n  public:\n  segm_tree(const vll &_vals) : vals(_vals) {\n    off = 1; while (off < sz(vals)) off <<= 1;\n    tr = vi(2 * off);\n  }\n  void add(ll x, int v) {\n    x = lower_bound(vals.begin(), vals.end(), x) - vals.begin();\n    for (x += off; x >= 1; x >>= 1)\n      tr[x] += v;\n  }\n  int getCnt(ll l, ll r) {\n    l = lower_bound(vals.begin(), vals.end(), l) - vals.begin();\n    r = upper_bound(vals.begin(), vals.end(), r) - vals.begin() - 1;\n    l += off; r += off;\n    int res = 0;\n    while (l <= r) {\n      if (l & 1) res += tr[l++];\n      if (!(r & 1)) res += tr[r--];\n      l >>= 1; r >>= 1;\n    }\n    return res;\n  }\n};\n\nint n;\nvll ss;\nvll vals;\n\nll getCnt(ll maxs) {\n  segm_tree tr(vals);\n  for (int i = 0; i <= n; i++)\n    tr.add(ss[i], 1);\n  \n  ll res = 0;\n  for (int l = 0; l <= n; l++) {\n    tr.add(ss[l], -1);\n    // x - ss[l] >= maxs\n    // x <= maxs + ss[l]\n    res += tr.getCnt(maxs + ss[l], INF);\n  }\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME "".in"", ""r"", stdin);\n  freopen(TASKNAME "".out"", ""w"", stdout);\n  #endif\n  \n  ll k;\n  while (scanf(""%d%I64d"", &n, &k) >= 2) {\n    vll as(n);\n    for (int i = 0; i < n; i++)\n      scanf(""%I64d"", &as[i]);\n      \n    ss = vll(n + 1);\n    for (int i = 0; i < n; i++)\n      ss[i + 1] = ss[i] + as[i];\n      \n    vals = ss;\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n      \n    ll L = -INF, R = INF;\n    assert(getCnt(L) >= k);\n    assert(getCnt(R) < k);\n    while (L + 1 < R) {\n      ll M = (L + R) / 2;\n      if (getCnt(M) >= k) L = M;\n      else R = M;\n    }\n    printf(""%I64d\\n"", L);\n  }\n  return 0;\n}\n']","['binary search', 'data structures', 'trees']",2200
https://codeforces.com//contest/223/problem/B,B. Two Strings,A of length of string where is the length of string is a string You ve got two strings and Let s consider all subsequences of string coinciding with string Is it true that each character of string occurs in at least one of these subsequences In other words is it true that for all there is such subsequence of string that and for some ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\nchar a[201000],b[201000];\nint next[201000][30];\nint lx[201000],rx[201000];\nint cnt[30][201000];\ninline bool solve(){\n    int al=strlen(a),bl=strlen(b);\n    if(al<bl)return 0;\n    int i,j;\n    for(i=0;i<26;i++)next[al][i]=al;\n    for(i=al-1;i>=0;i--){\n        for(j=0;j<26;j++){\n            next[i][j]=next[i+1][j];\n        }\n        next[i][a[i]-\'a\']=i;\n    }\n    if(a[0]!=b[0])return 0;\n    lx[0]=0;\n    for(i=1;i<bl;i++){\n        int s=next[lx[i-1]+1][b[i]-\'a\'];\n        if(s==al)return 0;\n        lx[i]=s;\n    }\n    for(i=0;i<26;i++)next[0][i]=0;\n    for(i=1;i<=al;i++){\n        for(j=0;j<26;j++){\n            next[i][j]=next[i-1][j];\n        }\n        next[i][a[i-1]-\'a\']=i;\n    }\n    if(a[al-1]!=b[bl-1])return 0;\n    rx[bl-1]=al-1;\n    for(i=bl-2;i>=0;i--){\n        int s=next[rx[i+1]][b[i]-\'a\'];\n        if(s==0)return 0;\n        rx[i]=s-1;\n    }\n    for(i=0;i<bl;i++){\n        cnt[b[i]-\'a\'][lx[i]]++;\n        cnt[b[i]-\'a\'][rx[i]+1]--;\n    }\n    for(j=0;j<26;j++){\n        for(i=1;i<al;i++){\n            cnt[j][i]+=cnt[j][i-1];\n        }\n    }\n    for(i=0;i<al;i++)if(cnt[a[i]-\'a\'][i]==0)return 0;\n    return 1;\n}\nint main(){\n    scanf(""%s%s"",&a,&b);\n    puts(solve()?""Yes"":""No"");\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","['data structures', 'dp', 'strings']",1900
https://codeforces.com//contest/765/problem/G,"G. Math, math everywhere",You are given a binary string and an integer Find the number of integers such that for all Print the answer modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  for (auto it = d.b; it != d.e; ++it) \n    *this << "", \\0["" + 3 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n\n#define imie(x) ""["" << #x "": "" << (x) << ""] ""\n\nconst int nax=500*1007;\nconst long long inf=(long long)1000*1000*1000*1000*1000*1000;\nconst long long mod=1000*1000*1000+7;\nconst long long jed=1;\n\nconst int vax=1007;\nconst int sax=43;\n\nint s;\nchar wcz[nax];\nint n;\n\nint g;\n\nlong long wej;\n\nvector < long long > dos[vax];\n\nlong long kom[vax][vax];\n\npair <long long, long long> tab[nax];\n\nlong long dp[nax][sax];\nlong long wez[sax];\n\nlong long wyn;\n\nlong long potuj(long long a, long long b)\n{\n\tlong long ret=1;\n\twhile(b)\n\t{\n\t\tif (b&1)\n\t\t{\n\t\t\tret*=a;\n\t\t\tret%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\n\ninline int test(const long long &a, const int &b)\n{\n\treturn (a&(jed<<b))>0;\n}\n\nvoid dodaj(long long &a, long long b)\n{\n\ta+=b;\n\tif (a>=mod)\n\t\ta-=mod;\n\tif (a>=mod)\n\t\ta%=mod;\n}\n\nmap <long long,long long> mapa[sax];\n\nlong long licz(int v, long long mas)\n{\n\tif (v==g)\n\t{\n\t\t//debug() << v << "" "" << mas << "" : "" << dp[v][];\n\t\treturn wez[__builtin_popcountll(mas^wej)];\n\t}\n\tif (mapa[v].count(mas))\n\t\treturn mapa[v][mas];\n\tlong long ret=0;\n\tfor (int i=0; i<dos[v].size(); i++)\n\t\tdodaj(ret, licz(v+1, mas|dos[v][i]));\n\tdebug() << v << "" "" << mas << "" : "" << ret;\n\tmapa[v][mas]=ret;\n\treturn ret;\n}\n\nint main()\n{\n\tfor (int i=0; i<vax; i++)\n\t{\n\t\tkom[i][0]=1;\n\t\tfor (int j=1; j<=i; j++)\n\t\t\tkom[i][j]=(kom[i-1][j]+kom[i-1][j-1])%mod;\n\t}\n\tscanf(""%s"", wcz);\n\ts=strlen(wcz);\n\tfor (int i=0; i<s; i++)\n\t\tif (wcz[i]==\'0\')\n\t\t\twej|=(jed<<i);\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld%lld"", &tab[i].first, &tab[i].second);\n\tsort(tab+1, tab+1+n);\n\tg=n+1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (tab[i].first>s)\n\t\t{\n\t\t\tg=min(g, i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j=0; j<tab[i].first; j++)\n\t\t{\n\t\t\tint ok=1;\n\t\t\tlong long daj=0;\n\t\t\tfor (int l=j; l<s; l+=tab[i].first)\n\t\t\t{\n\t\t\t\tif (!test(wej, l))\n\t\t\t\t\tok=0;\n\t\t\t\tdaj|=(jed<<l);\n\t\t\t}\n\t\t\tif (!ok)\n\t\t\t\tcontinue;\n\t\t\tdos[i].push_back(daj);\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tdebug() << i << "" "" << dos[i];\n\tdp[n+1][0]=1;\n\tfor (int i=n+1; i>g; i--)\n\t{\n\t\tfor (int j=0; j<=s; j++)\n\t\t{\n\t\t\tdodaj(dp[i-1][j+1], dp[i][j]);\n\t\t\tdodaj(dp[i-1][j], dp[i][j]*(tab[i-1].first-s+j));\n\t\t}\n\t\tdebug() << i << range(dp[i], dp[i]+1+s);\n\t}\n\tdebug() << g << range(dp[g], dp[g]+1+s);\n\t//for (int i=s; i; i--)\n\t//\tdodaj(dp[g][i], dp[g][i-1]);\n\tint og=__builtin_popcountll(wej);\n\tfor (int i=0; i<=og; i++)\n\t{\n\t\tfor (int j=i; j<=og; j++)\n\t\t{\n\t\t\tlong long x=1;\n\t\t\tfor (int l=1; l<=j; l++)\n\t\t\t\tx=(x*l)%mod;\n\t\t\tdodaj(wez[i], ((dp[g][j]*x)%mod)*kom[og-i][j-i]);\n\t\t}\n\t}\n\twyn=licz(1, 0);\n\tfor (int i=1; i<=n; i++)\n\t\twyn=(wyn*potuj(tab[i].first, tab[i].second-1))%mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","['brute force', 'dp', 'math', 'meet-in-the-middle', 'number theory']",3200
https://codeforces.com//contest/1804/problem/C,C. Pull Your Luck,While James is gone on business Vesper takes her time and explores what the legendary Casino Royale has to offer to people who are fond of competitive programming Her attention was grabbed by the very new Pull Your Luck roulette which functions in a pretty peculiar way The roulette s wheel consists of n sectors number from 0 to n 1 There is no ball and the winning sector is determined by a static arrow pointing to one of the sectors Sectors indexes go in the natural order and the wheel always spins in the direction of indexes increment That means that sector i 1 goes right after sector i for all i from 0 to n 2 and sector 0 goes right after sector n 1 After a bet is made the player is allowed to pull the triggering handle herself and cause the wheel to spin If the player s initial pull is made with the force equal to positive integer f the wheel will spin for f seconds During the first second it will advance f sectors the next second it will advance f 1 sectors then f 2 sectors and so on until it comes to a complete stop After the wheel comes to a complete stop the sector which the arrow is pointing to is the winning one The roulette s arrow currently points at sector x Vesper knows that she can pull the handle with any integer force from 1 to p inclusive Note that it is not allowed to pull the handle with force 0 i e not pull it all The biggest prize is awarded if the winning sector is 0 Now Vesper wonders if she can make sector 0 win by pulling the triggering handle exactly once ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, x, p;\n    std::cin >> n >> x >> p;\n    \n    for (int i = 1; i <= std::min(p, 2 * n); i++) {\n        if ((x + 1LL * i * (i + 1) / 2) % n == 0) {\n            std::cout << ""Yes\\n"";\n            return;\n        }\n    }\n    std::cout << ""No\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","['brute force', 'greedy', 'math', 'number theory']",1500
https://codeforces.com//contest/894/problem/E,E. Ralph and Mushrooms,Ralph is going to collect mushrooms in the Mushroom Forest There are directed paths connecting trees in the Mushroom Forest On each path grow some mushrooms When Ralph passes a path he collects all the mushrooms on the path The Mushroom Forest has a magical fertile ground where mushrooms grow at a fantastic speed New mushrooms regrow as soon as Ralph finishes mushroom collection on a path More specifically after Ralph passes a path the th time there regrow mushrooms less than there was before this pass That is if there is initially mushrooms on a path then Ralph will collect mushrooms for the first time mushrooms the second time mushrooms the third time and so on However the number of mushrooms can never be less than For example let there be mushrooms on a path initially The number of mushrooms that can be collected from the path is and when Ralph passes by from first to fourth time From the fifth time and later Ralph can t collect any mushrooms from the path but still can pass it Ralph decided to start from the tree How many mushrooms can he collect using only described paths ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 2333333\nEdgc int n,m;\nint st[SZ],sn=0,dfn[SZ],low[SZ],C=0,ins[SZ],Z=0,bl[SZ];\nvoid tj(int x)\n{\n\tdfn[x]=low[x]=++C; ins[x]=1; st[++sn]=x;\n\tfor esb(x,e,b)\n\t{\n\t\tif(!dfn[b]) tj(b),low[x]=min(low[x],low[b]);\n\t\telse if(ins[b]) low[x]=min(low[x],dfn[b]);\n\t}\n\tif(dfn[x]!=low[x]) return;\n\t++Z;\n\twhile(1)\n\t{\n\t\tint g=st[sn--];\n\t\tins[g]=0; bl[g]=Z;\n\t\tif(g==x) break;\n\t}\n}\nint X[SZ],Y[SZ],W[SZ];\nll vv[SZ],mx[SZ];\nbool vis[SZ];\nvoid dfs(int x)\n{\n\tvis[x]=1; mx[x]=0;\n\tfor esb(x,e,b)\n\t{\n\t\tif(!vis[b]) dfs(b);\n\t\tmx[x]=max(mx[x],mx[b]+vc[e]);\n\t}\n\tmx[x]+=vv[x];\n}\nll su[SZ];\nint main()\n{\n\tfor(int i=1;i<SZ;++i)\n\t\tsu[i]=su[i-1]+i*(ll)(i+1)/2;\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1,x,y,w;i<=m;++i)\n\t\tscanf(""%d%d%d"",&x,&y,&w),\n\t\tX[i]=x,Y[i]=y,W[i]=w,ad_de(x,y,w);\n\tint s; scanf(""%d"",&s);\n\tfor(int i=1;i<=n;++i)\n\t\tif(!dfn[i]) tj(i);\n\tM=0;\n\tfor(int i=1;i<=Z;++i) fst[i]=0;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=X[i],y=Y[i],w=W[i];\n\t\tif(bl[x]!=bl[y]) ad_de(bl[x],bl[y],w);\n\t\telse\n\t\t{\n\t\t\tll l=0,r=w;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tll g=(l+r+1)>>1;\n\t\t\t\tif(g*(g+1)/2<=w) l=g; else r=g-1;\n\t\t\t}\n\t\t\tll rr=w*(l+1)-su[l];\n\t\t\tvv[bl[x]]+=rr;\n\t\t}\n\t}\n\tdfs(bl[s]); printf(""%I64d\\n"",mx[bl[s]]);\n}\n']","['dp', 'graphs']",2100
https://codeforces.com//contest/1790/problem/D,D. Matryoshkas,is a wooden toy in the form of a painted doll inside which you can put a similar doll of a smaller size A set of nesting dolls contains one or more nesting dolls their sizes are consecutive positive integers Thus a set of nesting dolls is described by two numbers s the size of a smallest nesting doll in a set and m the number of dolls in a set In other words the set contains sizes of s s 1 dots s m 1 for some integer s and m s m 0 You had one or more sets of nesting dolls Recently you found that someone mixed all your sets in one and recorded a sequence of doll sizes integers a 1 a 2 dots a n You do not remember how many sets you had so you want to find the number of sets that you could initially have For example if a given sequence is a 2 2 3 4 3 1 Initially there could be 2 sets the first set consisting of 4 nesting dolls with sizes 1 2 3 4 a second set consisting of 2 nesting dolls with sizes 2 3 According to a given sequence of sizes of nesting dolls a 1 a 2 dots a n determine the minimum number of nesting dolls that can make this sequence Each set is completely used so all its nesting dolls are used Each element of a given sequence must correspond to exactly one doll from some set ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint t,a[200100];\nvoid solve(){\n        int n,i,ans=0,t=-1,p=0;cin>>n;\n        map<int,int>mp;\n        for(i=0;i<n;i++)cin>>a[i],mp[a[i]]++;\n        for(auto [f,s]:mp){\n                if(t!=f-1)p=0;\n                if(s>p)ans+=s-p;\n                t=f,p=s;\n        }\n        cout<<ans<<'\\n';\n}\nsigned main(){\n        ios::sync_with_stdio(false);cin.tie(nullptr);\n        cin>>t;\n        while(t--)solve();\n        return 0;\n}""]","['data structures', 'greedy', 'sortings']",1200
https://codeforces.com//contest/223/problem/C,C. Partial Sums,You ve got an array consisting of integers The array elements are indexed from 1 to Let s determine a two step operation like that First we build by the array an array of partial sums consisting of elements Element number of array equals The operation means that we take the remainder of the division of number by number Then we write the contents of the array to the array Element number of the array becomes the th element of the array You task is to find array after exactly described operations are applied ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint c[2010];\nconst int mod=(int)1e9+7;\ninline int add(int a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n    return a;\n}\ninline int mul(int a,int b){\n    return ((long long)a*(long long)b)%mod;\n}\nint in[2010];\ninline int rev(long long a,long long b){\n    if(a==1)return 1;\n    return (((1-rev(b%a,a)*b)/a)%b+b)%b;\n}\nint out[2010];\nint main(){\n    int n,k,i,j;\n    scanf(""%d%d"",&n,&k);\n    for(i=0;i<n;i++)scanf(""%d"",&in[i]);\n    if(k==0){\n        for(i=0;i<n;i++)out[i]=in[i];\n    }else{\n        k--;\n        c[0]=1;\n        for(i=1;i<n;i++){\n            c[i]=mul(mul(c[i-1],add(k,i)),rev(i,mod));\n        }\n        for(i=0;i<n;i++){\n            out[i]=0;\n            for(j=0;j<=i;j++)out[i]=add(out[i],mul(in[j],c[i-j]));\n        }\n    }\n    for(i=0;i<n;i++){\n        printf(""%d%c"",out[i],(i==n-1?\'\\n\':\' \'));\n    }\n\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","['combinatorics', 'math', 'number theory']",1900
https://codeforces.com//contest/83/problem/C,C. Track,You already know that Valery s favorite sport is biathlon Due to your help he learned to shoot without missing and his skills are unmatched at the shooting range But now a smaller task is to be performed he should learn to complete the path fastest The track s map is represented by a rectangle in size divided into squares Each square is marked with a lowercase Latin letter which means the type of the plot with the exception of the starting square it is marked with a capital Latin letters and the terminating square it is marked with a capital Latin letter The time of movement from one square to another is equal to minute The time of movement within the cell can be neglected We can move from the cell only to side adjacent ones but it is forbidden to go beyond the map edges Also the following restriction is imposed on the path it is not allowed to visit more than of squares squares of one type can be visited an infinite number of times Squares marked with and have no type so they are not counted But must be visited exactly once at the very beginning and must be visited exactly once at the very end Your task is to find the path from the square to the square that takes minimum time Among all shortest paths you should choose the one When comparing paths you should lexicographically represent them as a sequence of characters that is of plot types ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n, m, k;\nchar a[50][50];\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\nbool u[256];\nint d[50][50];\npii q[2500];\n\nstring bfs () {\n\tseta (d, 255);\n\tpii S, T;\n\tforn (i, n)\n\t\tforn (j, m) {\n\t\t\tif (a[i][j] == \'S\')\n\t\t\t\tS = mp (i, j);\n\t\t\tif (a[i][j] == \'T\')\n\t\t\t\tT = mp (i, j);\n\t\t}\n\td[T.fs][T.sc] = 0;\n\tint h, t;\n\th = t = 0;\n\tq[h] = T;\n\twhile (h <= t) {\n\t\tpii v = q[h];\n\t\th ++;\n\t\tforn (i, 4) {\n\t\t\tpii w = mp (v.fs + dx[i], v.sc + dy[i]);\n\t\t\tif (0 <= w.fs && w.fs < n && 0 <= w.sc && w.sc < m && d[w.fs][w.sc] == -1 && u[a[w.fs][w.sc]]) {\n\t\t\t\td[w.fs][w.sc] = d[v.fs][v.sc] + 1;\n\t\t\t\tt ++;\n\t\t\t\tq[t] = w;\n\t\t\t}\n\t\t}\n\t}\n\tif (d[S.fs][S.sc] == -1)\n\t\treturn ""S"";\n\tstring res = """";\n\tvector <pii> V, W;\n\tV.pb (S);\n\tint cd = d[S.fs][S.sc];\n\twhile (cd > 1) {\n\t\tchar c = \'z\';\n\t\tforn (i, V.size())\n\t\t\tforn (j, 4) {\n\t\t\t\tpii w = mp (V[i].fs + dx[j], V[i].sc + dy[j]);\n\t\t\t\tif (0 <= w.fs && w.fs < n && 0 <= w.sc && w.sc < m && cd - 1 == d[w.fs][w.sc])\n\t\t\t\t\tc = min (c, a[w.fs][w.sc]);\n\t\t\t}\n\t\tres += c;\n\t\tW.clear ();\n\t\tforn (i, V.size())\n\t\t\tforn (j, 4) {\n\t\t\t\tpii w = mp (V[i].fs + dx[j], V[i].sc + dy[j]);\n\t\t\t\tif (0 <= w.fs && w.fs < n && 0 <= w.sc && w.sc < m && cd - 1 == d[w.fs][w.sc] && a[w.fs][w.sc] == c)\n\t\t\t\t\tW.pb (w);\n\t\t\t}\n\t\tsort (all (W));\n\t\tW.resize (unique (all (W)) - W.begin());\n\t\tcd --;\n\t\tV = W;\n\t\tW.clear ();\n\t}\n\treturn res;\n}\n\nstring res;\n\nvoid calc (int cur, int la) {\n\tif (cur == 26) {\n\t\tstring tmp = bfs ();\n\t\tif (tmp == ""S"")\n\t\t\treturn;\n\t\tif (res == ""S"")\n\t\t\tres = tmp;\n\t\telse\n\t\tif (res.length() > tmp.length() || (res.length() == tmp.length() && res > tmp))\n\t\t\tres = tmp;\n\t\treturn;\n\t}\n\tcalc (cur+1, la);\n\tif (la == 0)\n\t\treturn;\n\tu[cur+\'a\'] = 1;\n\tcalc (cur+1, la-1);\n\tu[cur+\'a\'] = 0;\n}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tcin >> n >> m >> k;\n\tforn (i, n)\n\t\tforn (j, m)\n\t\t\tcin >> a[i][j];\n\tseta (u, 0);\n\tu[\'S\'] = 1;\n\tu[\'T\'] = 1;\n\tres = ""S"";\n\tcalc (0, k);\n\tif (res == ""S"")\n\t\tcout <<\t-1 << endl;\n\telse\n\t\tcout << res << endl;\n\treturn 0;\n}\n']","['graphs', 'greedy', 'shortest paths']",2400
https://codeforces.com//contest/1188/problem/C,C. Array Beauty,Let s call beauty of an array b 1 b 2 ldots b n n 1 min limits 1 leq i j leq n b i b j You re given an array a 1 a 2 ldots a n and a number k Calculate the sum of beauty over all subsequences of the array of length exactly k As this number can be very large output it modulo 998244353 A sequence a is a subsequence of an array b if a can be obtained from b by deletion of several possibly zero or all elements ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\n\nconst int N = 1010;\nint n, k, m;\nint a[N];\nint dp[N][N];\nint ANS;\n\nint solve(int d) {\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tdp[i][j] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[1][i] = i;\n\tfor (int t = 1; t < k; t++) {\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile(a[i] - a[p] >= d) p++;\n\t\t\tdp[t + 1][i + 1] = add(dp[t + 1][i], dp[t][p]);\n\t\t}\n\t}\n\treturn dp[k][n];\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tm = a[n - 1] - a[0];\n\tfor (int d = 1; d * (k - 1) <= m; d++)\n\t\tANS = add(ANS, solve(d));\n\tprintf(""%d\\n"", ANS);\n\n\treturn 0;\n}\n']",['dp'],2500
https://codeforces.com//contest/1829/problem/D,D. Gold Rush,Initially you have a single pile with n gold nuggets In an operation you can do the following Take any pile and split it into two piles so that one of the resulting piles has exactly twice as many gold nuggets as the other All piles should have an integer number of nuggets Can you make a pile with m gold nuggets using zero or more operations ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n#define fi first\n#define se second\n\nint n, m;\n\nvoid solve() {\n    cin >> n >> m;\n    queue<int> q;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        if (u == m) {\n            cout << ""YES\\n"";\n            return;\n        }\n        if (u % 3 == 0) {\n            q.push(u / 3);\n            q.push(2*(u / 3));\n        }\n    }\n    cout << ""NO\\n"";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","['brute force', 'dfs and similar', 'dp', 'implementation']",1000
https://codeforces.com//contest/1685/problem/C,C. Bring Balance,Alina has a bracket sequence s of length 2n consisting of n opening brackets and n closing brackets As she likes balance she wants to turn this bracket sequence into a balanced bracket sequence In one operation she can reverse any substring of s What s the smallest number of operations that she needs to turn s into a balanced bracket sequence It can be shown that it s always possible in at most n operations As a reminder a sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters and For example sequences and are balanced while and are not ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 500005;\nchar a[maxn];\n\nint s[maxn];\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        scanf(""%s"", a + 1);\n        int l = 2 * n;\n        int fs = l + 1, ls = 0, mpl = 0;\n        for (int i = 1; i <= l; i++) {\n            s[i] = s[i - 1];\n            if (a[i] == \'(\') s[i] += 1;\n            else s[i] -= 1;\n            if (s[i] < 0) chkmin(fs, i), chkmax(ls, i);\n            if (s[i] > s[mpl]) mpl = i;\n        }\n        if (fs > l) printf(""0\\n"");\n        else {\n            int fm = -1, fp = 0;\n            for (int x = 0; x < fs; x++)\n                if (chkmax(fm, s[x]))\n                    fp = x;\n            int em = -1, ep = 0;\n            for (int x = ls + 1; x <= l; x++)\n                if (chkmax(em, s[x]))\n                    ep = x;\n            fm += em;\n            int flag = 1;\n            for (int x = fs; x <= ls; x++)\n                if (s[x] > fm) flag = 0;\n            if (flag) {\n                printf(""1\\n"");\n                printf(""%d %d\\n"", fp + 1, ep);\n            }\n            else {\n                printf(""2\\n"");\n                printf(""%d %d\\n"", 1, mpl);\n                printf(""%d %d\\n"", mpl + 1, l);\n            }\n        }\n                \n    }\n    return (0-0); //<3\n}']","['brute force', 'constructive algorithms', 'greedy']",2600
https://codeforces.com//contest/1473/problem/A,A. Replacing Elements,You have an array a 1 a 2 dots a n All a i are positive integers In one step you can choose three distinct indices i j and k i neq j i neq k j neq k and assign the sum of a j and a k to a i i e make a i a j a k Can you make all a i lower or equal to d using the operation above any number of times possibly zero ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, d;\n        std::cin >> n >> d;\n        std::vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n        std::sort(a.begin(), a.end());\n        if (a[0] + a[1] <= d || a[n - 1] <= d) {\n            std::cout << ""YES\\n"";\n        } else {\n            std::cout << ""NO\\n"";\n        }\n    }\n    return 0;\n}']","['greedy', 'implementation', 'math', 'sortings']",800
https://codeforces.com//contest/1093/problem/C,C. Mishka and the Last Exam,Mishka is trying really hard to avoid being kicked out of the university In particular he was doing absolutely nothing for the whole semester miraculously passed some exams so that just one is left There were n classes of that subject during the semester and on i th class professor mentioned some non negative integer a i to the students It turned out the exam was to tell the whole sequence back to the professor Sounds easy enough for those who attended every class doesn t it Obviously Mishka didn t attend any classes However professor left some clues on the values of a to help out students like Mishka a was sorted in non decreasing order a 1 le a 2 le dots le a n n was even the following sequence b consisting of frac n 2 elements was formed and given out to students b i a i a n i 1 Professor also mentioned that any sequence a which produces sequence b with the presented technique will be acceptable Help Mishka to pass that last exam Restore any sorted sequence a of non negative integers which produces sequence b with the presented technique It is guaranteed that there exists at least one correct sequence a which produces the given sequence b ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nlong long b[maxn], a[maxn];\n\nint main() {\n    int n; scanf(""%d"", &n);\n    for (int i = 0; i < n / 2; ++i) scanf(""%lld"", &b[i]);\n    for (int i = 0, j = n - 1; i < n / 2; ++i, --j) {\n        long long x = max((i ? a[i - 1] : 0ll), (i ? b[i] - a[j + 1] : 0));\n        a[i] = x;\n        a[j] = b[i] - a[i];\n    }\n    for (int i = 0; i < n; ++i) printf(""%lld "", a[i]);\n    puts("""");\n    return 0;\n}\n']",['greedy'],1300
https://codeforces.com//contest/1477/problem/B,B. Nezzar and Binary String,Nezzar has a binary string s of length n that he wants to share with his best friend Nanako Nanako will spend q days inspecting the binary string At the same time Nezzar wants to change the string s into string f during these q days because it looks better It is known that Nanako loves consistency so much On the i th day Nanako will inspect a segment of string s from position l i to position r i inclusive If the segment contains both characters and Nanako becomes unhappy and throws away the string After this inspection at the i th night Nezzar can secretly change than half of the characters in the segment from l i to r i inclusive otherwise the change will be too obvious Now Nezzar wonders if it is possible to avoid Nanako being unhappy and at the same time have the string become equal to the string f at the end of these q days and nights ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//atcoder-library をまあまあコピーして使っている\n\n//N() が単位元\n\n//merge で片方が inactive のときはもう片方をそのまま返す，\n//といったときに，lazy の情報までコピーして渡さないようにする\n\n//get の最後の引数は単位元と口では言いつつ・・・？\n//たとえば min で最後の引数を 0 にしても 1 とかが返ってくることはある（一敗）\n\n//VERIFY:\n//https://atcoder.jp/contests/practice2/tasks/practice2_k\ntemplate<class N>\nstruct seglazy{\n\tvc<N> x;\n\tint L,s;\n\tseglazy(){}\n\ttemplate<class T>\n\tseglazy(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif(l==r)return N();\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml,smr;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = N::merge(sml, x[l++]);\n\t\t\tif (r & 1) smr = N::merge(x[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\n\t\treturn N::merge(sml, smr);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r, F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\nstruct N{\n\tint len,cnt[2],lz;\n\tN(int v=-1):len(v==-1?0:1),cnt{v==0,v==1},lz(-1){}\n\tvoid set_val(int v){\n\t\tassert(v==0||v==1);\n\t\tcnt[v]=len;\n\t\tcnt[v^1]=0;\n\t\tlz=v;\n\t}\n\tvoid push(N&x,N&y){\n\t\tif(lz!=-1){\n\t\t\tx.set_val(lz);\n\t\t\ty.set_val(lz);\n\t\t}\n\t\tlz=-1;\n\t}\n\tstatic N merge(N x,N y){\n\t\tN res;\n\t\tres.len=x.len+y.len;\n\t\trep(k,2)res.cnt[k]=x.cnt[k]+y.cnt[k];\n\t\tres.lz=-1;\n\t\treturn res;\n\t}\n};\n\nvi strvi(){\n\tstring s;cin>>s;\n\tvi res(si(s));\n\trep(i,si(s))res[i]=s[i]-\'0\';\n\treturn res;\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tvi tar=strvi();\n\tvi src=strvi();\n\tvc<pi> qs;\n\trep(i,q){\n\t\tint l,r;cin>>l>>r;\n\t\tl--;\n\t\tqs.eb(l,r);\n\t}\n\treverse(all(qs));\n\tseglazy<N> seg(src);\n\tfor(auto lr:qs){\n\t\tint l,r;tie(l,r)=lr;\n\t\tN cur=seg.composite(l,r);\n\t\tif(cur.cnt[0]==cur.cnt[1]){\n\t\t\treturn no(0);\n\t\t}\n\t\trep(k,2){\n\t\t\tif(cur.cnt[k]>cur.cnt[k^1]){\n\t\t\t\tseg.ch(l,r,&N::set_val,k);\n\t\t\t}\n\t\t}\n\t}\n\tvc<N> res;\n\tseg.enumerate(0,n,res);\n\trep(i,n){\n\t\tif(res[i].cnt[tar[i]]==0)return no(0);\n\t}\n\treturn yes(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","['data structures', 'greedy']",1900
https://codeforces.com//contest/1343/problem/A,A. Candies,Recently Vova found n candy wrappers He remembers that he bought x candies during the first day 2x candies during the second day 4x candies during the third day dots 2 k 1 x candies during the k th day But there is an issue Vova remembers neither x nor k but he is sure that x and k are positive integers and k 1 Vova will be satisfied if you tell him integer x so there is an integer k 1 that x 2x 4x dots 2 k 1 x n It is guaranteed that at least one solution exists You have to answer t independent test cases ,"['#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<\'0\') || (ch>\'9\')) {if (ch==\'-\') f=-1;ch=getchar();}\n    while ((ch>=\'0\') && (ch<=\'9\')) {x=x*10+(ch-\'0\');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tll n;scanf(""%lld"",&n);\n\t\tll k=3;\n\t\twhile (n>=k)\n\t\t{\n\t\t\tif (n%k==0)\n\t\t\t{\n\t\t\t\tprintf(""%lld\\n"",n/k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk=k*2+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n']","['brute force', 'math']",900
https://codeforces.com//contest/1833/problem/D,D. Flipper,You are given a permutation p of length n A permutation is an array consisting of n distinct integers from 1 to n in any order For example 2 3 1 5 4 is a permutation while 1 2 2 is not since 2 appears twice and 1 3 4 is also not a permutation as n 3 but the array contains 4 To the permutation p you need to apply the following operation First you choose a segment l r 1 le l le r le n a segment is a continuous sequence of numbers p l p l 1 ldots p r 1 p r and reverse it Reversing a segment means swapping pairs of numbers p l p r p l 1 p r 1 p l i p r i where l i le r i Then you swap the prefix and suffix r 1 n and 1 l 1 note that these segments may be empty For example given n 5 p 2 color blue 3 color blue 1 5 4 if you choose the segment l 2 r 3 after reversing the segment p color green 2 color blue 1 color blue 3 color green 5 color green 4 then you swap the segments 4 5 and 1 1 Thus p color green 5 color green 4 1 3 color green 2 It can be shown that this is the maximum possible result for the given permutation You need to output the lexicographically permutation that can be obtained by applying the operation described A permutation a is lexicographically greater than permutation b if there exists an i 1 le i le n such that a j b j for 1 le j i and a i b i ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        --a[i];\n    }\n    if (n == 1) {\n        std::cout << a[0] + 1 << ""\\n"";\n        return;\n    }\n    std::vector<int> res(n, -1);\n    auto try_ = [&](int l, int r) {\n        std::vector<int> b;\n        for (int i = r + 1; i < n; i++) {\n            b.emplace_back(a[i]);\n        }\n        for (int i = r; i >= l; i--) {\n            b.emplace_back(a[i]);\n        }\n        for (int i = 0; i < l; i++) {\n            b.emplace_back(a[i]);\n        }\n        if (b > res) {\n            res = b;\n        } \n    };\n    try_(0, 0);\n    if (a[0] == n - 1) {\n        for (int i = 1; i < n; i++) {\n            if (a[i] == n - 2) {\n                try_(i, i);\n                for (int j = 0; j < i; j++) {\n                    try_(j, i);\n                    try_(j, i - 1);\n                }\n                break;\n            }\n        }\n    } else {\n        for (int i = 1; i < n; i++) {\n            if (a[i] == n - 1) {\n                try_(i, i);\n                for (int j = 0; j < i; j++) {\n                    try_(j, i);\n                    try_(j, i - 1);\n                }\n                break;\n            }\n        }\n    }\n    for (auto x : res) {\n        std::cout << x + 1 << "" "";\n    }\n    std::cout << ""\\n"";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}']","['brute force', 'constructive algorithms', 'greedy']",1400
https://codeforces.com//contest/1638/problem/B,B. Odd Swap Sort,You are given an array a 1 a 2 dots a n You can perform operations on the array In each operation you can choose an integer i 1 le i n and swap elements a i and a i 1 of the array if a i a i 1 is odd Determine whether it can be sorted in non decreasing order using this operation any number of times ,"['// Author: wlzhouzhuan\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\nconst int N=1000005;\n\nint n;\n\nvoid solve(){\n\tn=read();\n\tvector<int> a,b;\n\trep(i,1,n){\n\t\tint x=read();\n\t\tif(x&1)a.pb(x);\n\t\telse b.pb(x);\n\t}\n\tputs(is_sorted(a.begin(),a.end())&&is_sorted(b.begin(),b.end())?""Yes"":""No"");\n}\n\nint main(){\n\tint T=read();\n\twhile(T--)solve();\n\treturn 0;\n}']","['data structures', 'math', 'sortings']",1100
https://codeforces.com//contest/341/problem/E,E. Candies Game,Iahub is playing an uncommon game Initially he has boxes numbered 1 2 3 Each box has some number of candies in it described by a sequence The number represents the number of candies in box The goal of the game is to move all candies into two boxes The rest of boxes must contain candies Iahub is allowed to do several possible zero moves At each move he chooses two different boxes and such that Then Iahub moves from box to box exactly candies Obviously when two boxes have equal number of candies box number becomes empty Your task is to give him a set of moves such as Iahub to archive the goal of the game If Iahub can t win the game for the given configuration of boxes output 1 Please note that in case there exist a solution you don t need to print the solution using minimal number of moves ,"['#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) cout << #x << "" = ""; cout << x << endl;\n#define PR(a,n) cout << #a << "" = ""; FOR(_,1,n) cout << a[_] << \' \'; cout << endl;\n#define PR0(a,n) cout << #a << "" = ""; REP(_,n) cout << a[_] << \' \'; cout << endl;\nusing namespace std;\n\n//Buffer reading\nint INP,AM,REACHEOF;\nconst int BUFSIZE = (1<<12) + 17;\nchar BUF[BUFSIZE+1], *inp=BUF;\n#define GETCHAR(INP) { \\\n    if(!*inp && !REACHEOF) { \\\n        memset(BUF,0,sizeof BUF);\\\n        int inpzzz = fread(BUF,1,BUFSIZE,stdin);\\\n        if (inpzzz != BUFSIZE) REACHEOF = true;\\\n        inp=BUF; \\\n    } \\\n    INP=*inp++; \\\n}\n#define DIG(a) (((a)>=\'0\')&&((a)<=\'9\'))\n#define GN(j) { \\\n    AM=0;\\\n    GETCHAR(INP); while(!DIG(INP) && INP!=\'-\') GETCHAR(INP);\\\n    if (INP==\'-\') {AM=1;GETCHAR(INP);} \\\n    j=INP-\'0\'; GETCHAR(INP); \\\n    while(DIG(INP)){j=10*j+(INP-\'0\');GETCHAR(INP);} \\\n    if (AM) j=-j;\\\n}\n//End of buffer reading\n\nconst int MN = 1011;\nint a[MN], n, x[11];\nvector< pair<int,int> > res;\n\nvoid solve(int x, int y, int z) {\n    if (a[y] < a[x]) swap(x, y);\n    if (a[z] < a[x]) swap(x, z);\n    if (a[z] < a[y]) swap(y, z);\n\n    if (a[x] == 0) return ;\n\n    int mv = a[y] / a[x];\n    REP(bit,30) {\n        if ((1<<bit) > mv) break;\n        if (mv & (1<<bit)) {\n            res.push_back(make_pair(x, y));\n            a[y] -= a[x];\n            a[x] += a[x];\n        }\n        else {\n            res.push_back(make_pair(x, z));\n            a[z] -= a[x];\n            a[x] += a[x];\n        }\n    }\n}\n\nint main() {\n    ios :: sync_with_stdio(false);\n    while (cin >> n) {\n        res.clear();\n        FOR(i,1,n) cin >> a[i];\n\n        int cnt = 0;\n        FOR(i,1,n) if (a[i]) {\n            ++cnt;\n            x[cnt] = i;\n            if (cnt == 3) break;\n        }\n        if (cnt < 2) {\n            puts(""-1\\n"");\n            continue;\n        }\n        while (cnt == 3) {\n            solve(x[1], x[2], x[3]);\n            cnt = 0;\n            FOR(i,1,n) if (a[i]) {\n                ++cnt;\n                x[cnt] = i;\n                if (cnt == 3) break;\n            }\n        }\n\n        printf(""%d\\n"", res.size());\n        REP(i,res.size()) printf(""%d %d\\n"", res[i].first, res[i].second);\n        puts("""");\n    }\n    return 0;\n}\n']","['constructive algorithms', 'greedy']",3000
https://codeforces.com//contest/1914/problem/E1,E1. Game with Marbles  Easy Version ,Recently Alice and Bob were given marbles of n different colors by their parents Alice has received a 1 marbles of color 1 a 2 marbles of color 2 a n marbles of color n Bob has received b 1 marbles of color 1 b 2 marbles of color 2 b n marbles of color n All a i and b i are between 1 and 10 9 After some discussion Alice and Bob came up with the following game players take turns starting with Alice On their turn a player chooses a color i such that players have at least one marble of that color The player then discards of color i and their opponent discards of color i The game ends when there is no color i such that both players have at least one marble of that color The score in the game is the difference between the number of remaining marbles that Alice has and the number of remaining marbles that Bob has at the end of the game In other words the score in the game is equal to A B where A is the number of marbles Alice has and B is the number of marbles Bob has at the end of the game Alice wants to maximize the score while Bob wants to minimize it Calculate the score at the end of the game if both players play optimally ,"['//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=2e5+5,mod=1e9+7;\nll n,k;\nii a[N];\nvoid prep(){\n}\nbool cmp (ii a, ii b){\n    return ((a.F+a.S)>(b.F+b.S));\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) cin>>a[i].F;\n    rep(i,1,n) cin>>a[i].S;\n    sort(a+1,a+n+1,cmp);\n    ll res=0;\n    rep(i,1,n) if (i%2==1) res+=a[i].F-1;\n    else res-=a[i].S-1;\n    cout<<res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']","['brute force', 'games', 'greedy', 'sortings']",1400
https://codeforces.com//contest/1607/problem/H,H. Banquet Preparations 2,The chef has cooked n dishes yet again the i th dish consists of a i grams of fish and b i grams of meat Banquet organizers consider two dishes i and j equal if a i a j and b i b j at the same time The banquet organizers estimate the of n dishes as follows The of a set of dishes is equal to the number of different dishes in it The is the In order to reduce the a taster was invited He will eat m i grams of food from each dish For each dish the taster determines separately how much fish and how much meat he will eat The only condition is that he will eat exactly m i grams of the i th dish in total Determine how much of what type of food the taster should eat from each dish so that the value of is the minimum possible If there are several correct answers you may output any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\nint a[200005],b[200005],l[200005],r[200005],sum[200005],m[200005],ans[200005];\nstruct qwq\n{\n\tint l,r,sum,id;\n}c[200005];\ninline bool cmp(qwq x,qwq y)\n{\n\treturn x.sum<y.sum||x.sum==y.sum&&x.r<y.r;\n}\ninline int solve(vector <qwq> v)\n{\n\tint rtn=0,nowr=-1e9;\n/*\tfor(auto t:v)\n\t{\n\t\tcout << t.l << ""**"" << t.r << ""*\\n"";\n\t}*/\n\tfor(auto t:v)\n\t{\n\t\tif(t.l>nowr)\n\t\t\tnowr=t.r,++rtn;\n\t\tans[t.id]=nowr;\n\t//\tcout << t.l << ""lll"" << "" "" << t.r << ""rrr"" << "" "" << ans[t.id] << ""**\\n""; \n\t}\n\treturn rtn;\n}\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin >> a[i] >> b[i] >> m[i];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=min(b[i],m[i]);\n\t\t\tr[i]=(a[i]-(m[i]-x))-(b[i]-x);\n\t\t\tx=min(a[i],m[i]);\n\t\t\tl[i]=(a[i]-x)-(b[i]-(m[i]-x));\n\t\t\tsum[i]=a[i]+b[i]-m[i];\n\t\t\tc[i]={l[i],r[i],sum[i],i};\n\t\t}\n\t\tsort(c+1,c+n+1,cmp);\n\t\tvector <qwq> v;\n\t\tc[n+1].sum=-1e9;\n\t\tint qaq=0;\n\t\tfor(int i=1;i<=n+1;i++)\n\t\t{\n\t//\t\tcout << c[i].l << "" "" << c[i].r << "" "" << c[i].sum << ""**\\n"";\n\t\t\tif(c[i].sum!=c[i-1].sum)\n\t\t\t\tqaq+=solve(v),v.clear();\n\t\t\tv.push_back(c[i]);\n\t\t}\n\t\tcout << qaq << ""\\n"";\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t//\t\tcout << l[i] << "" "" << r[i] << ""  ""<< ans[i] << ""()\\n"";\n\t\t\tint x=min(b[i],m[i]);\n\t\t\tint w=(a[i]-(m[i]-x))-(b[i]-x);\n\t\t\tint d=w-ans[i];\n\t\t\tx-=d/2;\n\t\t\tcout << m[i]-x << "" "" << x << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","['greedy', 'sortings', 'two pointers']",2200
https://codeforces.com//contest/1708/problem/A,A. Difference Operations,You are given an array a consisting of n positive integers You are allowed to perform this operation any number of times possibly zero choose an index i 2 le i le n and change a i to a i a i 1 Is it possible to make a i 0 for all 2 le i le n ,"['// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == \'-\') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, m;\nint a[N];\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\tW(T) {\n\t\tqread(n);\n\t\trep(i, 1, n) qread(a[i]);\n\t\tint f = 1;\n\t\trep(i, 1, n) if(a[i] % a[1]) f = 0;\n\t\tputs(f ? ""YES"" : ""NO"");\n\t}\n\treturn 0;\n}\n']","['greedy', 'math']",800
https://codeforces.com//contest/1101/problem/B,B. Accordion,An is a string yes in the real world accordions are musical instruments but let s forget about it for a while which can be represented as a concatenation of an opening bracket ASCII code 091 a colon ASCII code 058 some possibly zero vertical line characters ASCII code 124 another colon and a closing bracket ASCII code 093 The length of the accordion is the number of characters in it For example and are accordions having length 4 6 and 7 are not accordions You are given a string s You want to transform it into an accordion by removing some possibly zero characters from it Note that you may not insert new characters or reorder existing ones Is it possible to obtain an accordion by removing characters from s and if so what is the maximum possible length of the result ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXLEN=500000;\n\nchar s[MAXLEN+1]; int slen;\n\nint solve() {\n\tint l=0; while(l<slen&&s[l]!=\'[\') ++l; while(l<slen&&s[l]!=\':\') ++l; if(l>=slen) return -1;\n\tint r=slen-1; while(r>=0&&s[r]!=\']\') --r; while(r>=0&&s[r]!=\':\') --r; if(l>=r) return -1;\n\tint ret=4; FORE(i,l+1,r-1) if(s[i]==\'|\') ++ret; return ret;\n}\n\nvoid run() {\n\tscanf(""%s"",s); slen=strlen(s);\n\tprintf(""%d\\n"",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']","['greedy', 'implementation']",1300
https://codeforces.com//contest/1176/problem/A,A. Divide it ,You are given an integer n You can perform any of the following operations with this number an arbitrary possibly zero number of times Replace n with frac n 2 if n is divisible by 2 Replace n with frac 2n 3 if n is divisible by 3 Replace n with frac 4n 5 if n is divisible by 5 For example you can replace 30 with 15 using the first operation with 20 using the second operation or with 24 using the third operation Your task is to find the minimum number of moves required to obtain 1 from n or say that it is impossible to do it You have to answer q independent queries ,"['#include <bits/stdc++.h>\nusing namespace std;\nint T,ans;\nlong long n; \nint main()\n{\n\tscanf(""%d"",&T);\n\twhile(T--)\n\t{\n\t\tans=0;\n\t\tscanf(""%lld"",&n);\n\t\twhile(n%2==0) n/=2,ans++;\n\t\twhile(n%3==0) n/=3,ans+=2;\n\t\twhile(n%5==0) n/=5,ans+=3;\n\t\tif(n!=1) printf(""-1\\n"");\n\t\telse printf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}']","['brute force', 'greedy', 'implementation']",800
https://codeforces.com//contest/598/problem/E,E. Chocolate Bar,You have a rectangular chocolate bar consisting of single squares You want to eat squares so you may need to break the chocolate bar In one move you can break any single rectangular piece of chocolate in two rectangular pieces You can break only by lines between squares horizontally or vertically The cost of breaking is equal to square of the break length For example if you have a chocolate bar consisting of unit squares then you can break it horizontally and get two pieces the cost of such breaking is or you can break it vertically in two ways and get two pieces and the cost of such breaking is For several given values and find the minimum total cost of breaking You can eat exactly squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to squares The remaining squares are not necessarily form a single rectangular piece ,"[""//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n//#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\n\nint dp[32][32][52];\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    rep(i,0,32) rep(j,0,32) rep(k,0,52)\n\tdp[i][j][k] = mod;\n\n    rep(i,1,32) rep(j,1,32)\n    {\n\tif(i * j < 52) dp[i][j][i*j] = 0;\n\tdp[i][j][0] = 0;\n\n\tint x = min(52, i*j);\n\trep(k,1,x)\n\t{\n\t    rep(who,0,k+1)\n\t    {\n\t\trep(wh,1,j)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[i][wh][who] + dp[i][j-wh][k-who] + i * i);\n\t\trep(wh,1,i)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[wh][j][who] + dp[i-wh][j][k-who] + j * j);\n\t    }\n\t}\n    }\n\n    int q; cin >> q;\n    rep(i,0,q)\n    {\n\tint n, m, k; cin >> n >> m >> k;\n\tcout << dp[n][m][k] << endl;\n    }\n    return 0;    \n}\n""]","['brute force', 'dp']",2000
https://codeforces.com//contest/321/problem/E,E. Ciel and Gondolas,Fox Ciel is in the Amusement Park And now she is in a queue in front of the Ferris wheel There are people or foxes more precisely in the queue we use first people to refer one at the head of the queue and th people to refer the last one in the queue There will be gondolas and the way we allocate gondolas looks like this When the first gondolas come the people in head of the queue go into the gondolas Then when the second gondolas come the people in head of the remain queue go into the gondolas The remain people go into the last th gondolas Note that must be positive You can get from the statement that and You know people don t want to stay with strangers in the gondolas so your task is to find an optimal allocation way that is find an optimal sequence to make people happy For every pair of people and there exists a value denotes a level of unfamiliar You can assume for all and for all Then an unfamiliar value of a gondolas is the sum of the levels of unfamiliar between any pair of people that is into the gondolas A total unfamiliar value is the sum of unfamiliar values for all gondolas Help Fox Ciel to find the minimal possible total unfamiliar value for some optimal allocation ,"[""/*\n * e.cpp\n *\n *  Created on: 2013-6-29\n *      Author: ����\n */\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <deque>\nusing namespace std;\n\nconst int MAX_N = 4000 + 10, MAX_K = 800 + 10;\n\nint dp[MAX_K][MAX_N], n, k;\nint U[MAX_N][MAX_N];\n\nconst int INF = ~0U >> 3;\n\nstruct node {\n\tint l, r, ch;\n\tnode() {\n\t}\n\tnode(int _l, int _r, int _ch) :\n\t\t\tl(_l), r(_r), ch(_ch) {\n\t}\n};\n\nint Prev[MAX_N], Dp[MAX_N];\nint top = 0;\nint Cost(int l, int r) {\n\treturn U[l - 1][r - 1];\n}\n\nint Get(int i, int j) {\n\tif (j >= i)\n\t\treturn INF;\n\treturn Prev[j] + Cost(j + 1, i);\n}\nint binary(node t, int i) {\n\tint l = t.l, r = t.r;\n#define check(m) (Get(m,t.ch)<Get(m,i))\n\tif (check(r))\n\t\treturn r;\n\twhile (l + 1 < r) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(m))\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\treturn l;\n#undef check\n}\n\nvoid oneStep() {\n\tDp[0] = 0;\n\tdeque<node> D;\n\tD.push_back(node(1, n, 0));\n\tfor (int i = 1; i <= n; i++) {\n\t\tDp[i] = Get(i, D.front().ch);\n\t\tif (D.front().l < D.front().r)\n\t\t\tD.front().l++;\n\t\telse\n\t\t\tD.pop_front();\n\t\tnode t;\n\t\tint e;\n\t\twhile (D.size()) {\n\t\t\tt = D.back();\n\t\t\tif (Get(t.l, i) <= Get(t.l, t.ch)) {\n\t\t\t\tD.pop_back();\n\t\t\t} else {\n\t\t\t\te = binary(t, i);\n\t\t\t\tD.back().r = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (D.size() == 0)\n\t\t\tD.push_back(node(i + 1, n, i));\n\t\telse if (e < n)\n\t\t\tD.push_back(node(e + 1, n, i));\n\t}\n}\n\nint main() {\n\tcin >> n >> k;\n\tfor (int r = 0; r < n; ++r) {\n\t\tfor (int c = 0; c < n; ++c) {\n\t\t\tchar ch;\n\t\t\twhile (ch = getchar(), (ch < '0' || ch > '9'))\n\t\t\t\t;\n\t\t\tU[r][c] = ch - '0';\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfor (int j = i + 2; j < n; ++j) {\n\t\t\tU[i][j] += U[i + 1][j] + U[i][j - 1] - U[i + 1][j - 1];\n\t\t}\n\t}\n\n\t//k=1\n\tDp[0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tDp[i] = Cost(1, i);\n\t}\n\tmemcpy(Prev, Dp, sizeof(int) * (n + 1));\n\n\tfor (int i = 2; i <= k; ++i) {\n\t\toneStep();\n\t\tmemcpy(Prev, Dp, sizeof(int) * (n + 1));\n\t}\n\tcout << Dp[n] << endl;\n\treturn 0;\n}\n""]","['data structures', 'divide and conquer', 'dp']",2600
https://codeforces.com//contest/536/problem/D,D. Tavas in Kansas,Tavas lives in Kansas Kansas has cities numbered from 1 to connected with bidirectional roads We can travel from any city to any other city via these roads Kansas is as strange as Tavas So there may be a road between a city and itself or more than one road between two cities Tavas invented a game and called it Dashti He wants to play Dashti with his girlfriends Nafas In this game they assign an arbitrary integer value to each city of Kansas The value of th city equals to During the game Tavas is in city and Nafas is in city They play in turn and Tavas goes first A player in his her turn must choose a non negative integer and his her score increases by the sum of values of all cities with shortest distance no more than from his her city Each city may be used once or in the other words after first time a player gets score from a city city score becomes zero There is an additional rule the player must choose such that he she gets the point of at least one city that was not used before Note that city may initially have value 0 such city isn t considered as been used at the beginning of the game i e each player may use it to fullfill this rule The game ends when nobody can make a move A player s score is the sum of the points he she earned during the game The winner is the player with greater score or there is a draw if players score the same value Both players start game with zero points If Tavas wins he ll break his girlfriend s heart and if Nafas wins Tavas will cry But if their scores are equal they ll be happy and Tavas will give Nafas flowers They re not too emotional after all so they ll play optimally Your task is to tell Tavas what s going to happen after the game ends ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N,S,T;\nll graph[2010][2010];\nll p[2010];\nll dist[2010];\nbool used[2010];\nll dists[2010],distt[2010];\n\nvector <pair <ll, int> > vs,vt; // dist, id\nint ranks[2010],rankt[2010];\nll dps[2010][2010],dpt[2010][2010];\nbool new_s[2010][2010],new_t[2010][2010];\n\nll calc_s(int x, int y){\n    if(x == N) return 0;\n    if(!new_s[x][y]) return dps[x+1][y];\n    \n    ll next_cost = p[vs[x].second];\n    ll ans = next_cost + dps[x+1][y];\n    \n    for(int i=x+1;i<=N;i++){\n        ans = max(ans, next_cost - dpt[i][y]);\n        if(new_s[i][y]) break;\n    }\n    \n    return ans;\n}\n\nll calc_t(int x, int y){\n    if(y == N) return 0;\n    if(!new_t[x][y]) return dpt[x][y+1];\n    \n    ll next_cost = p[vt[y].second];\n    ll ans = next_cost + dpt[x][y+1];\n    \n    for(int i=y+1;i<=N;i++){\n        ans = max(ans, next_cost - dps[x][i]);\n        if(new_t[x][i]) break;\n    }\n    \n    return ans;\n}\n\nvoid main2(void){\n    int i,j;\n    \n    REP(i,N) REP(j,N+1) new_s[i][j] = (rankt[vs[i].second] >= j);\n    REP(i,N+1) REP(j,N) new_t[i][j] = (ranks[vt[j].second] >= i);\n    \n    for(i=N;i>=0;i--) for(j=N;j>=0;j--){\n        dps[i][j] = calc_s(i, j);\n        dpt[i][j] = calc_t(i, j);\n    }\n    \n    ll ans = dps[0][0];\n    if(ans > 0) cout << ""Break a heart"" << endl;\n    if(ans < 0) cout << ""Cry"" << endl;\n    if(ans == 0) cout << ""Flowers"" << endl;\n}\n\nvoid get_dist(int s){\n    int i,j;\n    \n    REP(i,N) dist[i] = INF;\n    REP(i,N) used[i] = false;\n    dist[s] = 0;\n    \n    REP(i,N){\n        int x = -1;\n        REP(j,N) if(!used[j] && (x == -1 || dist[j] < dist[x])) x = j;\n        used[x] = true;\n        REP(j,N) dist[j] = min(dist[j], dist[x] + graph[x][j]);\n    }\n}\n\nint main(void){\n    int M,i,j;\n    \n    cin >> N >> M >> S >> T;\n    S--; T--;\n    REP(i,N){\n        int tmp;\n        scanf(""%d"", &tmp);\n        p[i] = tmp;\n    }\n    REP(i,N) REP(j,N) if(i != j) graph[i][j] = INF;\n    REP(i,M){\n        int u,v,w;\n        scanf(""%d%d%d"", &u, &v, &w);\n        u--; v--;\n        graph[u][v] = min(graph[u][v], (ll)w);\n        graph[v][u] = min(graph[v][u], (ll)w);\n    }\n    \n    get_dist(S);\n    REP(i,N) dists[i] = dist[i];\n    get_dist(T);\n    REP(i,N) distt[i] = dist[i];\n    \n    REP(i,N) vs.push_back(make_pair(dists[i], i));\n    sort(vs.begin(),vs.end());\n    REP(i,N) vt.push_back(make_pair(distt[i], i));\n    sort(vt.begin(),vt.end());\n    \n    REP(i,N) ranks[vs[i].second] = i;\n    REP(i,N) rankt[vt[i].second] = i;\n    \n    main2();\n    \n    return 0;\n}\n']","['dp', 'games']",2900
https://codeforces.com//contest/1675/problem/E,"E. Replace With the Previous, Minimize",You are given a string s of lowercase Latin letters The following operation can be used select one character from to that occurs at least once in the string And replace all such characters in the string with the previous one in alphabetical order on the loop For example replace all with or replace all with And you are given the integer k the maximum number of operations that can be performed Find the minimum lexicographically possible string that can be obtained by performing no more than k operations The string a a 1a 2 dots a n is lexicographically smaller than the string b b 1b 2 dots b n if there exists an index k 1 le k le n such that a 1 b 1 a 2 b 2 a k 1 b k 1 but a k b k ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\ninline int reads(char* s){\n\tint t = 0;\n\tregister char c = getchar();\n\twhile (c < \'a\' || c > \'z\') c = getchar();\n\twhile (c >= \'a\' && c <= \'z\') s[++t] = c,c = getchar();\n\treturn t;\n}\n\nconst int N = 2e5 + 10;\nint T,n,k;\nchar inp[N + 1],s[N + 1];\nbool used[27];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = read(),k = read();\n\t\treads(s);\n\t\tfor (int i = 1;i <= n;i++) inp[i] = s[i];\n\t\tfor (int i = 1;i <= 26;i++) used[i] = 0;\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (k <= 0) break;\n\t\t\twhile (k >= 1 && s[i] != \'a\'){\n\t\t\t\tif (!used[s[i] - \'a\' + 1]) used[s[i] - \'a\' + 1] = 1,--k;\n\t\t\t\ts[i] = s[i] - 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\twhile (used[inp[i] - \'a\' + 1]){\n\t\t\t\tinp[i]--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i <= n;i++) putchar(inp[i]);\n\t\tputchar(\'\\n\');\n\t}\n\treturn 0;\n}']","['dsu', 'greedy', 'strings']",1500
https://codeforces.com//contest/1933/problem/F,F. Turtle Mission  Robot and the Earthquake,The world is a grid with n rows and m columns The rows are numbered 0 1 ldots n 1 while the columns are numbered 0 1 ldots m 1 In this world the columns are i e the top and the bottom cells in each column are adjacent The cell on the i th row and the j th column 0 le i n 0 le j m is denoted as i j the cell i j where 0 le i n 0 le j m contains either a or The state of cell i j can be described using the integer a i j If a i j 1 there is a rock at i j If a i j 0 there is nothing at i j As a result of aftershocks from the earthquake the columns follow tectonic plate movements each column moves cyclically at a velocity of 1 cell per unit of time Formally for some 0 le i n 0 le j m if i j contains a rock at the moment it will move from i j to i 1 j or to n 1 j if i 0 The robot called RT is initially positioned at 0 0 It has to go to n 1 m 1 to carry out an earthquake rescue operation to the bottom rightmost cell The earthquake doesn t change the position of the robot they only change the position of rocks in the world Let RT s current position be x y 0 le x n 0 le y m it can perform the following operations Go one cell cyclically upwards i e from x y to x n 1 bmod n y using 1 unit of time Go one cell cyclically downwards i e x y to x 1 bmod n y using 1 unit of time Go one cell to the right i e x y to x y 1 using 1 unit of time RT may perform this operation only if y m 1 Unfortunately RT will explode upon colliding with a rock As such when RT is at x y and there is a rock at x 1 bmod n y or x 2 bmod n y RT cannot move down or it will be hit by the rock Similarly if y 1 m and there is a rock at x 1 bmod n y 1 RT cannot move right or it will be hit by the rock However it is worth noting that if there is a rock at x bmod n y 1 and x 1 bmod n y RT can still move right safely Find the minimum amount of time RT needs to reach n 1 m 1 without colliding with any rocks If it is impossible to do so output 1 ,"['/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e3+10;\nint n,m;\nint a[N][N],dp[N][N];\nvoid leeminhduc2()\n{\n    cin >> n >> m;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<m;j++)\n            {\n                cin >> a[i][j];\n                dp[i][j]=-1;\n            }\n    dp[0][0]=0ll;\n    queue<ii> q;\n    q.push({0,0});\n    while (sz(q))\n    {\n        \n        auto [u,v]=q.front(); q.pop();\n        \n        if (dp[(u+2)%n][v]==-1&&a[(u+1)%n][v]==0&&a[(u+2)%n][v]==0)\n        {\n            dp[(u+2)%n][v]=dp[u][v]+1;\n            q.push({(u+2)%n,v});\n        }\n        if (v<m-1&&dp[(u+1)%n][(v+1)]==-1&&a[(u+1)%n][(v+1)]==0)\n        {\n            dp[(u+1)%n][(v+1)]=dp[u][v]+1;\n            q.push({(u+1)%n,(v+1)});\n        }\n    }\n    \n     \n    int res=1e9;\n    for (int i=0;i<n;i++) if (dp[i][m-1]!=-1)\n    {\n        int cur=(i-dp[i][m-1]%n+n)%n;\n       \n        if (cur==n-1) res=min(res,dp[i][m-1]);\n        else res=min(res,dp[i][m-1]+cur+1);\n    }\n    if (res==1e9) cout << ""-1\\n"";\n    else cout << res << ""\\n"";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n']","['dfs and similar', 'dp', 'graphs', 'shortest paths']",2100
https://codeforces.com//contest/1927/problem/G,G. Paint Charges,A horizontal grid strip of n cells is given In the i th cell there is a paint charge of size a i This charge can be either used to the left then all cells to the left at a distance less than a i from max i a i 1 1 to i inclusive will be painted or used to the right then all cells to the right at a distance less than a i from i to min i a i 1 n inclusive will be painted or not used at all Note that a charge can be used no more than once that is it be used simultaneously to the left and to the right It is allowed for a cell to be painted more than once What is the minimum number of times a charge needs to be used to paint all the cells of the strip ,"['// LUOGU_RID: 146673924\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint tt;\nint n,a[101];\nint f[2][105][105];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin>>tt;\n\twhile(tt--){\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\tf[0][i][j]=f[1][i][j]=n+1;\n\t\t\t}\n\t\t}\n\t\tf[0][0][1]=0;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\tint S=p&1,S_=S^1;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(f[S_][i][j]==n+1) continue;\n//\t\t\t\t\tcout<<i<<\' \'<<j<<\' \'<<p<<"" ""<<f[i][j]<<\':\'<<\'\\n\';\n\t\t\t\t\tint lim=max(p-a[p]+1,1ll);\n\t\t\t\t\tif(j>=lim) f[S][max(i,p)][max(i,p)+1]=min(f[S][max(i,p)][max(i,p)+1],f[S_][i][j]+1);\n//\t\t\t\t\tcout<<f[max(i,p)][p+1]<<\' \'<<max(i,p)<<\' \'<<p+1<<\'\\n\';\n\t\t\t\t\tlim=min(n,p+a[p]-1);\n\t\t\t\t\tint t=max(lim,i);\n\t\t\t\t\tif(j<p){\n\t\t\t\t\t\tf[S][t][j]=min(f[S][t][j],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<\'*\'<<f[t][j]<<\' \'<<t<<\' \'<<j<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tf[S][t][t+1]=min(f[S][t][t+1],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<f[t][t+1]<<\' \'<<t<<\' \'<<t+1<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tf[S][i][j]=min(f[S][i][j],f[S_][i][j]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif(p==6) cout<<f[S][10][1]<<\'\\n\';\n\t\t}\n\t\tcout<<min(f[0][n][n+1],f[1][n][n+1])<<\'\\n\';\n\t}\n}']","['data structures', 'dp', 'greedy', 'math']",2300
https://codeforces.com//contest/630/problem/Q,Q. Pyramids,IT City administration has no rest because of the fame of the Pyramids in Egypt There is a project of construction of pyramid complex near the city in the place called Emerald Walley The distinction of the complex is that its pyramids will be not only quadrangular as in Egypt but also triangular and pentagonal Of course the amount of the city budget funds for the construction depends on the pyramids volume Your task is to calculate the volume of the pilot project consisting of three pyramids one triangular one quadrangular and one pentagonal The first pyramid has equilateral triangle as its base and all 6 edges of the pyramid have equal length The second pyramid has a square as its base and all 8 edges of the pyramid have equal length The third pyramid has a regular pentagon as its base and all 10 edges of the pyramid have equal length ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 18:55:42       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\nconst dbl PI = acos(-1);\n\n\ndbl get(dbl l, int n)\n{\n    dbl alp = 2 * PI / n;\n    dbl bet = PI / 2 - alp / 2;\n    dbl x = sin(bet) / sin(alp) * l;\n    dbl S = x * x * sin(alp) / 2;\n    dbl h = sqrt(l * l - x * x);\n    dbl V = S * n * h / 3;\n    return V;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    dbl l3, l4, l5;\n    cin >> l3 >> l4 >> l5;\n    dbl res = get(l3, 3) + get(l4, 4) + get(l5, 5);\n    printf(""%.10f\\n"", res);    \n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","['geometry', 'math']",1700
https://codeforces.com//contest/388/problem/B,B. Fox and Minimal path,Fox Ciel wants to write a task for a programming contest The task is You are given a simple undirected graph with vertexes Each its edge has unit length You should calculate the number of shortest paths between vertex 1 and vertex 2 Same with some writers she wants to make an example with some certain output for example her birthday or the number of her boyfriend Can you help her to make a test case with answer equal exactly to ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nchar g[2010][2010];\n\nint main() {\n  int k;\n  scanf(""%d"", &k);\n  if (k == 1) {\n    puts(""2"");\n    puts(""NY"");\n    puts(""YN"");\n    return 0;\n  }\n  int mx = 0;\n  for (int j = 0; j < 30; j++)\n    if (k & (1 << j)) {\n      mx = j;\n    }\n  memset(g, \'N\', sizeof(g));\n  int n = 2;\n  int u = 1;\n  for (int j = 1; j <= mx; j++) {\n    n++;\n    g[u][n] = g[n][u] = \'Y\';\n    int x = n;\n    n++;\n    g[u][n] = g[n][u] = \'Y\';\n    int y = n;\n    int z;\n    if (j == mx) {\n      z = 2;\n    } else {\n      z = ++n;\n    }\n    g[x][z] = g[z][x] = \'Y\';\n    g[y][z] = g[z][y] = \'Y\';\n    u = z;\n  }\n  for (int j = mx - 1; j >= 0; j--) {\n    if (k & (1 << j)) {\n      int v = 3 * j + 2;\n      if (j == 0) v--;\n      int len = 2 * (mx - j);\n      for (int it = 0; it < len - 1; it++) {\n        n++;\n        g[v][n] = g[n][v] = \'Y\';\n        v = n;\n      }\n      g[v][2] = g[2][v] = \'Y\';\n    }\n  }\n  printf(""%d\\n"", n);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) putchar(g[i][j]);\n    putchar(\'\\n\');\n  }\n  return 0;\n}\n']","['bitmasks', 'constructive algorithms', 'graphs', 'implementation', 'math']",1900
https://codeforces.com//contest/150/problem/D,D. Mission Impassable,Market stalls now have the long awaited game The Colder Scrools V Nvodsk The game turned out to be difficult as hell and most students can t complete the last quest We don t go to Nvodsk That threatened winter exams The rector already started to wonder whether he should postpone the winter exams till April in fact he wanted to complete the quest himself But all of a sudden a stranger appeared at the door of his office Good afternoon My name is Chuck and I solve any problems he said And here they are sitting side by side but still they can t complete the mission The thing is to kill the final boss one should prove one s perfect skills in the art of managing letters One should be a real magician to do that And can you imagine what happens when magicians start competing But let s put it more formally you are given a string and a set of integers You are allowed to choose any substring that is a palindrome and delete it At that we receive some number of points equal to where is the length of the deleted palindrome For some 1 which means that deleting palindrome strings of such length is After a substring is deleted the remaining part shifts together that is at no moment of time the string has gaps The process is repeated while the string has at least one palindrome substring that can be deleted All gained points are summed up Determine what maximum number of points can be earned Oh said Chuck raising from the chair I used to love deleting palindromes just like you but one day I took an arrow in the Knee ,"['#pragma comment (linker, ""/STACK:200000000"")\n#define _SECURE_SCL 0\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int INF = (int) 1E8;\nconst int64 INF64 = (int64) 1E18;\nconst double EPS = 1E-9;\nconst double PI = acos((double)0) * 2;\n\n#define forn(i,n)  for (int i=0; i<int(n); ++i)\n#define ford(i,n)  for (int i=int(n)-1; i>=0; --i)\n#define fore(i,l,n)  for (int i=int(l); i<int(n); ++i)\n#define all(a)  a.begin(), a.end()\n#define fs  first\n#define sc  second\n#define pb  push_back\n#define mp  make_pair\n\n\nconst int MAXN = 160;\n\n\nint n, cost[MAXN];\nstring s;\n\n\nbool read() {\n\tif (! (cin >> n))\n\t\treturn false;\n\tforn(i,n) {\n\t\tcin >> cost[i+1];\n\t\tif (cost[i+1] == -1)\n\t\t\tcost[i+1] = -INF;\n\t}\n\tcin >> s;\n\treturn true;\n}\n\n\nint d[MAXN][MAXN][MAXN];\nbool u[MAXN][MAXN][MAXN];\n\nint get_d (int l, int r, int len) {\n\tif (l > r)  return cost[len];\n\tif (l == r)  return max (cost[len] + cost[1], cost[len+1]);\n\n\tint & my = d[l][r][len];\n\tbool & myu = u[l][r][len];\n\tif (myu)  return my;\n\tmyu = true;\n\tmy = -INF;\n\n\tif (len != 0)\n\t\tmy = max (my, cost[len] + get_d (l, r, 0));\n\tfore(i,l,r)\n\t\tmy = max (my, get_d (l, i, 0) + get_d (i+1, r, len));\n\tfore(i,l+1,r+1)\n\t\tmy = max (my, get_d (i, r, 0) + get_d (l, i-1, len));\n\tfore(i,l,r+1)\n\t\tmy = max (my, get_d (l, i-1, 0) + cost[len+1] + get_d (i+1, r, 0));\n\n\tif (s[l] == s[r])\n\t\tmy = max (my, get_d (l+1, r-1, len+2));\n\n\treturn my;\n}\n\nint d2[MAXN];\n\nvoid solve() {\n\tmemset (u, 0, sizeof u);\n\tint x = get_d (0, n-1, 0);\n\tforn(i,n) {\n\t\td2[i] = i ? d2[i-1] : 0;\n\t\tforn(j,i+1)\n\t\t\td2[i] = max (d2[i], get_d (j, i, 0) + (j ? d2[j-1] : 0));\n\t}\n\n\tcout << d2[n-1] << endl;\n}\n\n\nint main() {\n#ifdef SU2_PROJ\n\tfreopen (""input.txt"", ""rt"", stdin);\n\tfreopen (""output.txt"", ""wt"", stdout);\n\twhile (read())\n\t\tsolve();\n#else\n\tif (!read())  throw;\n\tsolve();\n#endif\n}']","['dp', 'strings']",2600
https://codeforces.com//contest/1699/problem/C,C. The Third Problem,You are given a permutation a 1 a 2 ldots a n of integers from 0 to n 1 Your task is to find how many permutations b 1 b 2 ldots b n are to permutation a Two permutations a and b of size n are considered if for all intervals l r 1 le l le r le n the following condition is satisfied operatorname MEX a l a l 1 ldots a r operatorname MEX b l b l 1 ldots b r where the operatorname MEX of a collection of integers c 1 c 2 ldots c k is defined as the smallest non negative integer x which does not occur in collection c For example operatorname MEX 1 2 3 4 5 0 and operatorname MEX 0 1 2 4 5 3 Since the total number of such permutations can be very large you will have to print its remainder modulo 10 9 7 In this problem a permutation of size n is an array consisting of n distinct integers from 0 to n 1 in arbitrary order For example 1 0 2 4 3 is a permutation while 0 1 1 is not since 1 appears twice in the array 0 1 3 is also not a permutation since n 3 and there is a 3 in the array ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint pos[100005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0); \n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tpos[x]=i;\n\t\t}\n\t\tint ans=1,L=n+1,R=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(pos[i]<L||pos[i]>R)\n\t\t\t{\n\t\t\t\tR=max(R,pos[i]);\n\t\t\t\tL=min(L,pos[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans=ans*(R-L+1-i)%mod;\n\t\t\t}\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","['combinatorics', 'constructive algorithms', 'math']",1700
https://codeforces.com//contest/200/problem/D,D. Programming Language,Recently Valery have come across an entirely new programming language Most of all the language attracted him with template functions and procedures Let us remind you that templates are tools of a language designed to encode generic algorithms without reference to some parameters e g data types buffer sizes default values Valery decided to examine template procedures in this language in more detail The description of a template procedure consists of the procedure name and the list of its parameter types The generic type parameters can be used as parameters of template procedures A procedure call consists of a procedure name and a list of variable parameters Let s call a procedure for this call if the following conditions are fulfilled its name equals to the name of the called procedure the number of its parameters equals to the number of parameters of the procedure call the types of variables in the procedure call match the corresponding types of its parameters The variable type matches the type of a parameter if the parameter has a generic type or the type of the variable and the parameter are the same You are given a description of some set of template procedures You are also given a list of variables used in the program as well as direct procedure calls that use the described variables For each call you need to count the number of procedures that are suitable for this call ,"['#include<stdio.h>\n#include<map>\n#include<vector>\n#include<string>\n#include<string.h>\n#include<utility>\nusing namespace std;\nmap<string,vector<vector<string> > > funcs;\nmap<string,string> type;\nchar s[1000];\nstring removeSp(char *s)\n{\n\tstring res;\n\tint l=strlen(s);\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(s[i]!=\' \')\n\t\t{\n\t\t\tres.push_back(s[i]);\n\t\t}\n\t}\n\treturn res;\n}\n\npair<string, vector<string> > parses(string s)\n{\n\tint idx=0;\n\tstring name="""";\n\tvector<string> types;\n\twhile(s[idx]!=\'(\')\n\t{\n\t\tname.push_back(s[idx]);\n\t\t++idx;\n\t}\n\t++idx;\n\twhile(s[idx]!=\')\')\n\t{\n\t\tstring type="""";\n\t\twhile(s[idx]!=\',\' && s[idx]!=\')\')\n\t\t{\n\t\t\ttype.push_back(s[idx]);\n\t\t\t++idx;\n\t\t}\n\t\ttypes.push_back(type);\n\t\tif(s[idx]!=\')\')++idx;\n\t}\n\treturn make_pair(name,types);\n}\n\nvoid parsetype(string s)\n{\n   string Type="""";\n   string var="""";\n   int idx=0;\n   int L=s.length();\n   while(s[idx]==\' \')++idx;\n   while(s[idx]!=\' \')\n   {\n\t   Type.push_back(s[idx]);\n\t   ++idx;\n   }\n   while(s[idx]==\' \')++idx;\n   while(idx!=L && s[idx]!=\' \')\n   {\n\t   var.push_back(s[idx]);\n\t   ++idx;\n   }\n   type[var]=Type;\n}\nbool match(string &s1,string &s2)\n{\n\treturn s1==s2 || s2==""T"";\n}\nbool matchV(vector<string> &V1,vector<string> &V2)\n{\n\tif(V1.size()!=V2.size())return false;\n\tfor(int i=0;i<V1.size();i++)\n\t{\n\t\tif(!match(type[V1[i]],V2[i]))return false;\n\t}\n\treturn true;\n}\nint calc (string name, vector<string> type)\n{\n\tvector<vector<string> > cur=funcs[name];\n\tint answ=0;\n\tfor(int i=0;i<cur.size();i++)\n\t{\n\t\tif(matchV(type,cur[i]))++answ;\n\t}\n\treturn answ;\n}\nint main()\n{\n  \n\tgets(s);\n\tint n;\n\tsscanf(s,""%d"",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tgets(s);\n\t\n\t\tstring rs=removeSp(s);\n\t\tpair<string,vector<string> > newt =parses(rs.substr(4));\n\t\tfuncs[newt.first].push_back(newt.second);\n\t}\n\n\tgets(s);\n\tint m;\n\tsscanf(s,""%d"",&m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tgets(s);\n\t\tparsetype(s);\n\t}\n\tint k;\n\tgets(s);\n\n\tsscanf(s,""%d"",&k);\n\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tgets(s);\n\t    string rs=removeSp(s);\n\t\tpair<string,vector<string> > newt =parses(rs);\n\t\tprintf(""%d\\n"",calc(newt.first,newt.second));\n\n\t}\n\n\n\n}']","['binary search', 'brute force', 'expression parsing', 'implementation']",1800
https://codeforces.com//contest/313/problem/E,E. Ilya and Two Numbers,Ilya has recently taken up archaeology He s recently found two numbers written in the based notation Each of the found numbers consisted of exactly digits Ilya immediately started looking for information about those numbers He learned that the numbers are part of a cyphered code and the one who can decypher it can get the greatest treasure After considerable research Ilya understood that to decypher the code he should do the following Rearrange digits in the first number in some manner Similarly rearrange digits in the second number in some manner As a result of this operation the numbers can get leading zeroes Add numbers digit by digit modulo In other words we need to get the third number of length each digit of the number is the sum of the respective numbers of the found numbers For example suppose there are two numbers recorded in the ternary notation 001210 and 012111 then if you add them to each other digit by digit modulo 3 you will get number 010021 The key to the code is the maximum possible number that can be obtained in the previous step Help Ilya find the key to the code ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nint a[111111], b[111111];\nint la[111111], ra[111111];\nint Next[111111], Prev[111111];\nbool ma[111111], mb[111111];\n\nstruct data {\n    int i, j;\n    data (int _i, int _j) {\n        i = _i; j = _j;\n    }\n    inline friend bool operator < (data x, data y) {\n        return (a[x.i] + b[x.j]) % m < (a[y.i] + b[y.j]) % m;\n    }\n};\n\npriority_queue<data> f;\nset<int> idx;\n\nint main() {\n    // freopen(""E.in"", ""r"", stdin);\n\n    scanf(""%d%d"", &n, &m);\n    for(int i = 1; i <= n; i++) scanf(""%d"", a+i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", b+i);\n\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+n);\n    b[n+1] = m;\n    for(int i = 1; i <= n; i++)\n        idx.insert(-i);\n\n    memset(ma, 0, sizeof ma);\n    memset(mb, 0, sizeof mb);\n\n    for(int i = 1; i <= n; i++) {\n        int need = m-a[i]-1;\n        int l = 1, r = n+1;\n        while (l < r) {\n            int mid = (l+r)/2;\n            if (b[mid] <= need) l = mid+1;\n            else r = mid;\n        }\n        l--;\n        if (l) f.push(data(i, l));\n        if (l < n) f.push(data(i, n));\n    }\n\n    while (!f.empty()) {\n        data t = f.top(); f.pop();\n        if (!ma[t.i]) {\n            if (!mb[t.j]) {\n                printf(""%d "", (a[t.i] + b[t.j]) % m);\n                ma[t.i] = 1;\n                mb[t.j] = 1;\n                idx.erase(-t.j);\n            }\n            else {\n                set<int>::iterator it = idx.lower_bound(-t.j);\n                if (it != idx.end()) {\n                    t.j = -(*it);\n                    f.push(t);  \n                }\n                \n            }\n        }\n    }\n    return 0;\n}\n']","['constructive algorithms', 'data structures', 'dsu', 'greedy']",2300
https://codeforces.com//contest/1530/problem/A,A. Binary Decimal,Let s call a number a if it s a positive integer and all digits in its decimal notation are either 0 or 1 For example 1 010 111 is a binary decimal while 10 201 and 787 788 are not Given a number n you are asked to represent n as a sum of some not necessarily distinct binary decimals Compute the smallest number of binary decimals required for that ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        auto s = std::to_string(n);\n        \n        std::cout << (*std::max_element(s.begin(), s.end()) - \'0\') << ""\\n"";\n    }\n    \n    return 0;\n}']","['greedy', 'math']",800
https://codeforces.com//contest/146/problem/A,A. Lucky Ticket,Petya loves tickets very much As we know each ticket has a number that is a positive integer Its length equals is always even Petya calls a ticket lucky if the ticket s number is a lucky number and the sum of digits in the first half the sum of the first digits equals the sum of digits in the second half the sum of the last digits Check if the given ticket is lucky ,"['#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int\tMAX_N\t= 100;\nint\t\t\tN;\nchar\t\ta\t\t[MAX_N];\n\nvoid Init()\n{\n\tscanf(""%d"", &N);\n\tscanf(""%s"", a);\n}\n\nint Solve()\n{\n\tint ans1 = 0, ans2 = 0;\n\tfor(int i = 0; i < N; ++ i)\n\t\tif (a[i] != \'4\' && a[i] != \'7\') return 0;\n\tfor(int i = 0; i < N / 2; ++ i) ans1 += a[i] - \'0\';\n\tfor(int i = N / 2; i < N; ++ i) ans2 += a[i] - \'0\';\n\treturn ans1 == ans2;\n}\n\nint main()\n{\n\tInit();\n\tif (Solve()) cout << ""YES"" << endl;\n\telse cout << ""NO"" << endl;\n\t//system(""pause"");\n\treturn 0;\n}\n']",['implementation'],800
https://codeforces.com//contest/1896/problem/C,C. Matching Arrays,You are given two arrays a and b of size n The of the arrays a and b is the number of indices i such that a i b i You are also given an integer x Determine whether it is possible to rearrange the elements of b such that the beauty of the arrays becomes x If it is possible output one valid rearrangement of b ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nint ta[nax];\nint tb[nax];\n\nint wyn[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &ta[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tb[i]);\n\tvector<pii> pos;\n\tfor (int i=1; i<=n; i++)\n\t\tpos.push_back({ta[i], i});\n\tsort(pos.begin(), pos.end());\n\tvi dwa;\n\tfor (int i=1; i<=n; i++)\n\t\tdwa.push_back(tb[i]);\n\tsort(dwa.begin(), dwa.end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\twyn[pos[i].second]=dwa[(i+k)%n];\n\t}\n\tint li=0;\n\tfor (int i=1; i<=n; i++)\n\t\tli+=(ta[i]>wyn[i]);\n\tif (li!=k)\n\t{\n\t\tans(0);\n\t}\n\telse\n\t{\n\t\tans(1);\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tprintf(""%d "", wyn[i]);\n\t\tprintf(""\\n"");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['binary search', 'constructive algorithms', 'greedy', 'sortings']",1400
https://codeforces.com//contest/1870/problem/B,B. Friendly Arrays,You are given two arrays of integers a 1 ldots a n of length n and b 1 ldots b m of length m You can choose any element b j from array b 1 leq j leq m and for 1 leq i leq n perform a i a i b j You can perform any number of such operations After all the operations the value of x a 1 oplus a 2 oplus ldots oplus a n will be calculated Find the minimum and maximum values of x that could be obtained after performing any set of operations Above is the bitwise OR operation and oplus is the bitwise XOR operation ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint a[N], b[N];\nint n, m;\nvoid Main() {\n\tcin >> m >> n;\n\tL(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tint op = 0;\n\tL(i, 1, m) {\n\t\top ^= b[i];\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tif(m & 1) {\n\t\tans1 = op;\n\t\tL(i, 1, n) {\n\t\t\top |= a[i];\n\t\t}\n\t\tans2 = op;\n\t} else {\n\t\tans2 = op;\n\t\tL(i, 1, n) {\n\t\t\top &= ~a[i];\n\t\t}\n\t\tans1 = op;\n\t}\n\tcout << ans1 << ' ' << ans2 << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]","['bitmasks', 'greedy', 'math']",1200
https://codeforces.com//contest/1693/problem/B,B. Fake Plastic Trees,We are given a rooted tree consisting of n vertices numbered from 1 to n The root of the tree is the vertex 1 and the parent of the vertex v is p v There is a number written on each vertex initially all numbers are equal to 0 Let s denote the number written on the vertex v as a v For each v we want a v to be between l v and r v l v leq a v leq r v In a single operation we do the following Choose some vertex v Let b 1 b 2 ldots b k be vertices on the path from the vertex 1 to vertex v meaning b 1 1 b k v and b i p b i 1 Choose a non decreasing array c of length k of nonnegative integers 0 leq c 1 leq c 2 leq ldots leq c k For each i 1 leq i leq k increase a b i by c i What s the minimum number of operations needed to achieve our goal ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint oj[nax];\nll dol[nax];\nll gor[nax];\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""Yes\\n"");\n\telse\n\t\tprintf(""No\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=0;\n\tfor (int i=2; i<=n; i++)\n\t\tscanf(""%d"", &oj[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld%lld"", &dol[i], &gor[i]);\n\tint wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]<dol[i])\n\t\t{\n\t\t\twyn++;\n\t\t\ttab[i]=gor[i];\n\t\t}\n\t\ttab[oj[i]]+=min(gor[i], tab[i]);\n\t}\n\tprintf(""%d\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","['dfs and similar', 'dp', 'greedy', 'trees']",1700
https://codeforces.com//contest/1219/problem/G,G. Harvester,It is Bubble Cup finals season and farmer Johnny Bubbles must harvest his bubbles The bubbles are in a rectangular bubblefield formed of N x M square parcels divided into N rows and M columns The parcel in i th row and j th column yields A i j bubbles Johnny Bubbles has available a very special self driving bubble harvester that once manually positioned at the beginning of a row or column automatically harvests all the bubbles in that row or column Once the harvester reaches the end of the row or column it stops and must be repositioned The harvester can pass through any parcel any number of times but it can collect bubbles from the parcel only once Johnny is very busy farmer so he is available to manually position the harvester at most four times per day Johnny is also impatient so he wants to harvest as many bubbles as possible on the first day Please help Johnny to calculate what is the maximum number of bubbles he can collect on the first day ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MIN = -1;\npair<ll,ll> getTwo(vector<ll> arr){\n    ll first, second; \n    first = second = MIN; \n    for (int i = 0; i < arr.size() ; i ++) \n    { \n        /* If current element is greater than first*/\n        if (arr[i] > first) \n        { \n            second = first; \n            first = arr[i]; \n        } \n   \n        /* If arr[i] is in between first and second then update second  */\n        else if (arr[i] > second) \n        { \n            second = arr[i]; \n        } \n    } \n    assert(first!=MIN);\n    assert(second!=MIN);\n    return {first, second};\n}\n// program it such that N < M\nint N,M;\nvector< vector<ll> > fields, tmp_fields;\nvector<ll> row_sum, col_sum;\nint main(void){\n    cin >> N >> M;\n    ll sum = 0;\n    for(int i=0;i<N;i++){\n        vector<ll> tmp;\n        for(int j=0;j<M;j++){\n            ll x;\n            cin >> x;\n            sum += x;\n            tmp.push_back(x);\n        }\n        tmp_fields.push_back(tmp);\n    }\n\n    // Finish all the read in\n    // If trivial case happens\n    // output the sum\n    if(N<=4 || M<=4){\n        cout << sum << endl;\n        return 0;\n    }\n\n    // transpose if N > M\n    if(N>=M){\n        for(int i=0;i<M;i++){\n            vector<ll> tmp;\n            for(int j=0;j<N;j++){\n                ll x = tmp_fields[j][i];\n                tmp.push_back(x);\n            }\n            fields.push_back(tmp);\n        }\n        ll tmp = N;\n        N = M;\n        M = tmp;\n    }else{\n        fields = tmp_fields;\n    }\n    // TODO: Verify transpose\n\n    // Compute row sum and col sum\n    row_sum.resize(N);\n    for(int i=0;i<N;i++){\n        row_sum[i] = 0;\n    }\n    col_sum.resize(M);\n    for(int i=0;i<M;i++){\n        col_sum[i] = 0;\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++){\n            row_sum[i] += fields[i][j];\n            col_sum[j] += fields[i][j];\n        }\n    }\n\n    // Write the toughest case\n    ll ans = 0;\n    for(int i=0;i<N;i++){\n        vector<ll> cand(M);\n        for(int j=0;j<M;j++){\n            cand[j] = col_sum[j] - fields[i][j];\n        }\n        for(int k=i+1;k<N;k++){\n            vector<ll> cand_(M);\n            for(int j=0;j<M;j++){\n                cand_[j] = cand[j] - fields[k][j];\n            }\n            pair<ll,ll> res = getTwo(cand_);\n            ans = max(ans, res.first + res.second + row_sum[i] + row_sum[k]);\n        }\n    }\n\n    // Write the 1-3 and 3-1 case\n    for(int i=0;i<N;i++){\n        // choose an arbitrary row\n        vector<ll> cand(M);\n        for(int j=0;j<M;j++){\n            cand[j] = col_sum[j] - fields[i][j];\n        }\n        sort(cand.begin(), cand.end());\n        ll three_sum = 0;\n        for(int j=M-1;j>=M-3;j--){\n            three_sum += cand[j];\n        }   \n        ans = max(ans, row_sum[i] + three_sum);\n    }\n    for(int j=0;j<M;j++){\n        // choose an arbitrary row\n        vector<ll> cand(N);\n        for(int i=0;i<N;i++){\n            cand[i] = row_sum[i] - fields[i][j];\n        }\n        sort(cand.begin(), cand.end());\n        ll three_sum = 0;\n        for(int i=N-1;i>=N-3;i--){\n            three_sum += cand[i];\n        }   \n        ans = max(ans, col_sum[j] + three_sum);\n    }\n    // Write the trivial case\n    sort(row_sum.begin(), row_sum.end());\n    ll four_sum = 0;\n    for(int i=N-1;i>=N-4;i--){\n        four_sum += row_sum[i];\n    }\n    ans = max(ans, four_sum);\n    sort(col_sum.begin(), col_sum.end());\n    four_sum = 0;\n    for(int j=M-1;j>=M-4;j--){\n        four_sum += col_sum[j];\n    }\n    ans = max(ans, four_sum);\n    cout << ans << endl;\n}']",['implementation'],2000
https://codeforces.com//contest/1687/problem/C,C. Sanae and Giant Robot,Is it really The robot only existing in my imagination The Colossal Walking Robot Kochiya Sanae Sanae made a giant robot Hisoutensoku but something is wrong with it To make matters worse Sanae can not figure out how to stop it and she is forced to fix it on the fly The state of a robot can be represented by an array of integers of length n Initially the robot is at state a She wishes to turn it into state b As a great programmer Sanae knows the art of copy and paste In one operation she can choose some segment from given segments copy the segment from b and paste it into of the robot replacing the original state there However she has to ensure that the sum of a after each copy operation in case the robot go haywire Formally Sanae can choose segment l r and assign a i b i l le i le r if sum limits i 1 n a i does not change after the operation Determine whether it is possible for Sanae to successfully turn the robot from the initial state a to the desired state b with any possibly zero operations ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nvector<int> g[N];\nint n;\nll a[N], b[N];\nset<int> setik;\nint q[N];\nint topQ;\n\nvoid fixSegm(int l, int r) {\n\tif (l > r) swap(l, r);\n\twhile(true) {\n\t\tauto it = setik.lower_bound(l);\n\t\tif (it == setik.end()) break;\n\t\tif (*it > r) break;\n\t\tint x = *it;\n\t\tsetik.erase(it);\n\t\tq[topQ++] = x;\n\t}\n}\n\nbool solve() {\n\tint m;\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i <= n; i++)\n\t\tg[i].clear();\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%lld"", &a[i + 1]);\n\t\ta[i + 1] += a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%lld"", &b[i + 1]);\n\t\tb[i + 1] += b[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tl--;\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\t}\n\tif (a[n] != b[n]) return false;\n\ttopQ = 0;\n\tsetik.clear();\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tq[topQ++] = i;\n\t\telse\n\t\t\tsetik.insert(i);\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (setik.count(u)) continue;\n\t\t\tfixSegm(v, u);\n\t\t}\n\t}\n\treturn setik.empty();\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) {\n\t\tif (solve()) {\n\t\t\tprintf(""Yes\\n"");\n\t\t} else {\n\t\t\tprintf(""No\\n"");\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","['binary search', 'brute force', 'data structures', 'dsu', 'greedy', 'sortings']",2500
https://codeforces.com//contest/1076/problem/F,F. Summer Practice Report,Vova has taken his summer practice this year and now he should write a report on how it went Vova has already drawn all the tables and wrote down all the formulas Moreover he has already decided that the report will consist of exactly n pages and the i th page will include x i tables and y i formulas The pages are numbered from 1 to n Vova fills the pages one after another he can t go filling page i 1 before finishing page i and he can t skip pages However if he draws than k tables in a row or writes than k formulas in a row then he will get bored Vova wants to rearrange tables and formulas in each page in such a way that he doesn t get bored in the process Vova can t move some table or some formula to another page Note that the count doesn t reset on the start of the new page For example if the page ends with 3 tables and the next page starts with 5 tables then it s counted as 8 tables in a row Help Vova to determine if he can rearrange tables and formulas on each page in such a way that there is no more than k tables in a row and no more than k formulas in a row ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 3e5 + 7;\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint n, k;\nint x[N], y[N];\nint dp[N][2];\n\nint get(int la, int lb, int ca, int cb){\n\tint ret = k + 1;\n\tif(la <= k){\n\t\tint need = (cb + k - 1) / k;\n\t\tLL maxPoss = 1LL * cb * k + k - la;\n\t\tif(need <= ca && ca <= maxPoss)\n\t\t\tret = min(1LL * ret, max(1LL, k - maxPoss + ca));\n\t}\n\t\n\tif(lb <= k){\n\t\tLL maxPoss = 1LL * (ca - 1) * k + k - lb;\n\t\tLL maxPoss2 = 1LL * (cb + 1) * k;\n\t\t\n\t\tif(cb <= maxPoss && ca <= maxPoss2)\n\t\t\tret = min(1LL * ret, max(1LL, k - maxPoss2 + ca));\n\t}\n\t\n\treturn ret;\n}\n\nint main(){\n//\tios_base::sync_with_stdio(false);\n//\tcin.tie(NULL);\n//\tcout.tie(NULL);\n\n\tscanf(""%d %d"", &n, &k);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(""%d"", &x[i]);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(""%d"", &y[i]);\n\t\n\tfor(int i = 1; i <= n; ++i){\n\t\tdp[i][0] = get(dp[i - 1][0], dp[i - 1][1], x[i], y[i]);\n\t\tdp[i][1] = get(dp[i - 1][1], dp[i - 1][0], y[i], x[i]);\n\t}\n\t\n\tputs((dp[n][0] <= k || dp[n][1] <= k) ? ""YES"" : ""NO"");\n\treturn 0;\n}\n']","['dp', 'greedy']",2500
https://codeforces.com//contest/1832/problem/C,C. Contrast Value,For an array of integers a 1 a 2 dots a n let s call the value a 1 a 2 a 2 a 3 cdots a n 1 a n the of the array Note that the contrast of an array of size 1 is equal to 0 You are given an array of integers a Your task is to build an array of b in such a way that all the following conditions are met b is not empty i e there is at least one element b is a subsequence of a i e b can be produced by deleting some elements from a maybe zero the contrast of b is equal to the contrast of a What is the minimum possible size of the array b ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    n = std::unique(a.begin(), a.end()) - a.begin();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (((i == 0 || a[i] > a[i - 1]) && (i == n - 1 || a[i] > a[i + 1]))\n            || ((i == 0 || a[i] < a[i - 1]) && (i == n - 1 || a[i] < a[i + 1]))) {\n            ans++;\n        }\n    }\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","['greedy', 'implementation']",1200
https://codeforces.com//contest/1051/problem/C,C. Vasya and Multisets,Vasya has a multiset s consisting of n integer numbers Vasya calls some number x nice if it appears in the multiset exactly once For example multiset 1 1 2 3 3 3 4 contains nice numbers 2 and 4 Vasya wants to split multiset s into two multisets a and b in such a way that the quantity of nice numbers in multiset a would be the same as the quantity of nice numbers in multiset b the quantity of numbers to appear exactly once in multiset a and the quantity of numbers to appear exactly once in multiset b ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101];\nint cnt[101];\nstring S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tcnt[A[i]]++;\n\t}\n\tint n1=0,n3=0;\n\tFOR(i,101) {\n\t\tif(A[i]==1) n1++;\n\t\tif(A[i]>=3) n3++;\n\t}\n\t\n\t\n\tS.resize(N);\n\tx=0;\n\tFOR(i,N) if(cnt[A[i]]==1) {\n\t\tS[i]=\'A\'+x;\n\t\tx^=1;\n\t}\n\t\n\tFOR(i,N) if(x==1 && cnt[A[i]]>=3) {\n\t\tS[i]=\'B\';\n\t\tx=0;\n\t}\n\tif(x) return _P(""NO\\n"");\n\tFOR(i,N) if(S[i]==0) S[i]=\'A\';\n\t\n\tcout<<""YES""<<endl;\n\tcout<<S<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']","['brute force', 'dp', 'greedy', 'implementation', 'math']",1500
https://codeforces.com//contest/149/problem/D,D. Coloring Brackets,Once Petya read a problem about a bracket sequence He gave it much thought but didn t find a solution Today you will face it You are given string It represents a correct bracket sequence A correct bracket sequence is the sequence of opening and closing brackets such that it is possible to obtain a correct mathematical expression from it inserting numbers and operators between the brackets For example such sequences as and are correct bracket sequences and such sequences as and are not In a correct bracket sequence each bracket corresponds to the matching bracket an opening bracket corresponds to the matching closing bracket and vice versa For example in a bracket sequence shown of the figure below the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled Each bracket is either not colored any color or is colored red or is colored blue For any pair of matching brackets exactly one of them is colored In other words for any bracket the following is true either it or the matching bracket that corresponds to it is colored No two neighboring colored brackets have the same color Find the number of different ways to color the bracket sequence The ways should meet the above given conditions Two ways of coloring are considered different if they differ in the color of at least one bracket As the result can be quite large print it modulo ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 768\n#define MOD 1000000007\n\nusing namespace std;\nFILE *in; FILE *out;\n\nint n;\nchar a[MAX];\nlong long dyn[MAX][MAX][3][3];\n\nlong long recurse(int left, int right, int colL, int colR)\n{\n\tif (left > right)\n\t\treturn 1;\n\tif (dyn[left][right][colL][colR] != -1)\n\t\treturn dyn[left][right][colL][colR];\n\t\n\tlong long ans = 0;\n\tint cnt = 1;\n\tint idx = left + 1;\n\twhile (idx <= right)\n\t{\n\t\tif (a[idx] == \'(\') cnt++;\n\t\telse cnt--;\n\t\tif (cnt == 0) break;\n\t\tidx++;\n\t}\n\t// Color left\n\tif (colL != 1)\n\t\tans += (recurse(left + 1, idx - 1, 1, 0) * recurse(idx + 1, right, 0, colR)) % MOD;\n\tif (colL != 2)\n\t\tans += (recurse(left + 1, idx - 1, 2, 0) * recurse(idx + 1, right, 0, colR)) % MOD;\n\t\n\t// Color right\n\tif (idx == right)\n\t{\n\t\tif (colR != 1)\n\t\t\tans += recurse(left + 1, idx - 1, 0, 1);\n\t\tif (colR != 2)\n\t\t\tans += recurse(left + 1, idx - 1, 0, 2);\n\t}\n\telse\n\t{\n\t\tans += (recurse(left + 1, idx - 1, 0, 1) * recurse(idx + 1, right, 1, colR)) % MOD;\n\t\tans += (recurse(left + 1, idx - 1, 0, 2) * recurse(idx + 1, right, 2, colR)) % MOD;\n\t}\n\treturn dyn[left][right][colL][colR] = ans % MOD;\n}\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(""D.in"", ""rt""); out = fopen(""D.out"", ""wt"");\n\t\n\tfscanf(in, ""%s"", a);\n\tn = (int)strlen(a);\n\tmemset(dyn, -1, sizeof(dyn));\n\tfprintf(out, ""%d\\n"", (int)recurse(0, n - 1, 0, 0));\n\t\n\treturn 0;\n}\n']",['dp'],1900
https://codeforces.com//contest/1220/problem/E,E. Tourism,Alex decided to go on a touristic trip over the country For simplicity let s assume that the country has n cities and m bidirectional roads connecting them Alex lives in city s and initially located in it To compare different cities Alex assigned each city a score w i which is as high as interesting city seems to Alex Alex believes that his trip will be interesting only if he will not use any road twice in a row That is if Alex came to city v from city u he may choose as the next city in the trip any city connected with v by the road except for the city u Your task is to help Alex plan his city in a way that maximizes total score over all cities he visited Note that for each city its score is counted at most once even if Alex been there several times during his trip ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#ifndef LOCAL\n#pragma GCC optimize(""O3"")\n#endif\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst int kMaxN = 3e5 + 100;\n\nll score[kMaxN];\nll ins[kMaxN];\nvi adj[kMaxN];\nint deg[kMaxN];\nint n, m, start;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> score[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tcin >> start;\n\t\n\tqueue<int> q;\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdeg[i] = SZ(adj[i]);\n\t\tif (deg[i] == 1 && i != start) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\t\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tdeg[v] = -1;\n\t\tfor (int s : adj[v]) {\n\t\t\tif (deg[s] < 0) { continue; }\n\t\t\t--deg[s];\n\t\t\tins[s] = max(ins[s], ins[v] + score[v]);\n\t\t\tif (deg[s] == 1 && s != start) {\n\t\t\t\tq.push(s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll totus = 0, totthem = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (deg[i] < 0) { continue; }\n\t\ttotus += score[i];\n\t\ttotthem = max(totthem, ins[i]);\n\t}\n\tcout << totus + totthem << ""\\n"";\n}\n']","['dfs and similar', 'dp', 'dsu', 'graphs', 'greedy', 'trees']",2200
https://codeforces.com//contest/1433/problem/F,F. Zero Remainder Sum ,You are given a matrix a of size n times m consisting of integers You can choose left lfloor frac m 2 right rfloor elements in Your task is to choose these elements in such a way that their sum is k and this sum is the In other words you can choose no more than a half rounded down of elements in each row you have to find the maximum sum of these elements divisible by k Note that you can choose zero elements and the sum of such set is 0 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint hmt() {int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c==\'-\');for(;isdigit(c);c=getchar()) x=x*10+c-\'0\';if(n) x=-x;return x;}\n#define in hmt()\n#define ins ({string x;char c=getchar();for(;c==\' \'||c==\'\\n\';c=getchar());for(;c!=\' \'&&c!=\'\\n\';c=getchar()) x+=c;x;})\n#define forinc(i,a,b) for(int i=a,_b=b;i<=_b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forb(i,BS) for(int i=BS._Find_first();i< BS.size();i = BS._Find_next(i))\n#define timer 1.0*clock()/CLOCKS_PER_SEC\n#define forv(a,b) for(auto &a:b)\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define reset(f,x) memset(f,x,sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define onbit(x,i) (x|(1<<(i-1)))\n#define offbit(x,i) (x&~(1<<(i-1)))\nconst int N=75;\nint m,n,k,a[N][N],f[N][N][N][N];\nvoid maxi(int &a,int b)\n{\n    a=max(a,b);\n}\nint main()\n{\n    //freopen(""1433F.inp"",""r"",stdin);\n    m=in,n=in,k=in;\n    forinc(i,1,m) forinc(j,1,n) a[i][j]=in;\n    reset(f,-1);\n    f[1][0][0][0]=0;\n    forinc(i,1,m)\n    {\n        forinc(j,1,n) forinc(t,0,min(j-1,n/2)) forinc(c,0,k-1) if(f[i][j-1][t][c]!=-1)\n        {\n            maxi(f[i][j][t][c],f[i][j-1][t][c]);\n            maxi(f[i][j][t+1][(c+a[i][j])%k],f[i][j-1][t][c]+a[i][j]);\n        }\n        forinc(t,0,n/2) forinc(c,0,k-1) maxi(f[i+1][0][0][c],f[i][n][t][c]);\n    }\n    cout<<f[m+1][0][0][0]<<""\\n"";\n}\n']",['dp'],2100
https://codeforces.com//contest/1709/problem/E,E. XOR Tree,You are given a tree consisting of n vertices A number is written on each vertex the number on vertex i is equal to a i Recall that a simple path is a path that visits each vertex at most once Let the of the path be the bitwise XOR of the values written on vertices it consists of Let s say that a tree is if no simple path has weight 0 You can apply the following operation any number of times possibly zero select a vertex of the tree and replace the value written on it with an arbitrary positive integer What is the minimum number of times you have to apply this operation in order to make the tree ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nint a[N];\nint ANS;\nset<int> setik[N];\nint id[N];\nint X[N];\n\nvoid dfs(int v, int par) {\n\tint big = -1;\n\tfor (int u : g[v]) if (u != par) {\n\t\tdfs(u, v);\n\t\tif (big == -1 || (int)setik[id[big]].size() < (int)setik[id[u]].size())\n\t\t\tbig = u;\n\t}\n\tif (big == -1) {\n\t\tid[v] = v;\n\t\tX[v] = 0;\n\t\tsetik[v].insert(a[v]);\n\t\treturn;\n\t}\n\tid[v] = id[big];\n\tbool bad = false;\n\tX[id[v]] ^= a[v];\n\tif (setik[id[v]].count(X[id[v]])) bad = true;\n\tsetik[id[v]].insert(X[id[v]] ^ a[v]);\n\tfor (int u : g[v]) if (u != par && u != big) {\n\t\tfor (int z : setik[id[u]]) {\n\t\t\tint w = z ^ X[id[u]] ^ X[id[v]];\n\t\t\tif (setik[id[v]].count(w)) bad = true;\n\t\t}\n\t\tfor (int z : setik[id[u]]) {\n\t\t\tint w = z ^ X[id[u]] ^ X[id[v]] ^ a[v];\n\t\t\tsetik[id[v]].insert(w);\n\t\t}\n\t}\n\tif (bad) {\n\t\tANS++;\n\t\tsetik[id[v]].clear();\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tprintf(""%d\\n"", ANS);\n\n\treturn 0;\n}\n']","['bitmasks', 'data structures', 'dfs and similar', 'dsu', 'greedy', 'trees']",2400
https://codeforces.com//contest/1648/problem/A,A. Weird Sum,Egor has a table of size n times m with lines numbered from 1 to n and columns numbered from 1 to m Each cell has a color that can be presented as an integer from 1 to 10 5 Let us denote the cell that lies in the intersection of the r th row and the c th column as r c We define the between two cells r 1 c 1 and r 2 c 2 as the length of a shortest path between them where each consecutive cells in the path must have a common side The path can go through cells of any color For example in the table 3 times 4 the manhattan distance between 1 2 and 3 3 is 3 one of the shortest paths is the following 1 2 to 2 2 to 2 3 to 3 3 Egor decided to calculate the sum of manhattan distances between each pair of cells of the same color Help him to calculate this sum ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::map<int, std::vector<int>> sx, sy;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int c;\n            std::cin >> c;\n            sx[c].push_back(i);\n            sy[c].push_back(j);\n        }\n    }\n    \n    auto solve = [&](auto s) {\n        i64 ans = 0;\n        for (auto [x, v] : s) {\n            std::sort(v.begin(), v.end());\n            i64 s = 0, c = 0;\n            for (auto i : v) {\n                ans += i * c - s;\n                s += i;\n                c++;\n            }\n        }\n        return ans;\n    };\n    \n    auto ans = solve(sx) + solve(sy);\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","['combinatorics', 'data structures', 'geometry', 'math', 'matrices', 'sortings']",1400
https://codeforces.com//contest/1542/problem/A,A. Odd Set,You are given a multiset i e a set that can contain multiple equal integers containing 2n integers Determine if you can split it into exactly n pairs i e each element should be in exactly one pair so that the sum of the two elements in each pair is i e when divided by 2 the remainder is 1 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=1000000007;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\nconst int MAXN=205;\n\nvoid solve()\n{\n\tint n,a,s[2]={0,0};readint(n);\n\tfor(int i=1;i<=2*n;++i)readint(a),s[a&1]++;\n\tprintf(s[0]==s[1]?""Yes\\n"":""No\\n"");\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}\n']",['math'],800
https://codeforces.com//contest/837/problem/B,B. Flag of Berland,The flag of Berland is such rectangular field that satisfies following conditions Flag consists of three colors which correspond to letters and Flag consists of three equal in width and height stripes parralel to each other and to sides of the flag Each stripe has Each color should be used in You are given a field consisting of characters and Output without quotes if this field corresponds to correct flag of Berland Otherwise print without quotes ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nchar in[105][105];\nchar u[105][105];\nbool isValid(int N, int M) {\n\tif (N % 3) return false;\n\n\tchar x[4] = ""BGR"";\n\tdo {\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < M; j++) u[i][j] = x[i / (N / 3)];\n\t\t\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tfor (j = 0; j < M; j++) if (in[i][j] != u[i][j]) break;\n\t\t\tif (j < M) break;\n\t\t}\n\t\tif (i >= N) return true;\n\t} while (next_permutation(x, x + 3));\n\treturn false;\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 0; i < N; i++) scanf(""%s"", in[i]);\n\n\tif (isValid(N, M)) return !printf(""YES\\n"");\n\tfor (i = 0; i < N; i++) for (j = 0; j < M; j++) u[j][i] = in[i][j];\n\tfor (i = 0; i < N; i++) for (j = 0; j < M; j++) in[j][i] = u[j][i];\n\tif (isValid(M, N)) return !printf(""YES\\n"");\n\treturn !printf(""NO\\n"");\n}']","['brute force', 'implementation']",1600
https://codeforces.com//contest/238/problem/C,C. World Eater Brothers,You must have heard of the two brothers dreaming of ruling the world With all their previous plans failed this time they decided to cooperate with each other in order to rule the world As you know there are countries in the world These countries are connected by directed roads If you don t consider direction of the roads there is a unique path between every pair of countries in the world passing through each road at most once Each of the brothers wants to establish his reign in some country then it s possible for him to control the countries that can be reached from his country using directed roads The brothers can rule the world if there exists at most two countries for brothers to choose and establish their reign in these countries so that any other country is under control of at least one of them In order to make this possible they want to change the direction of minimum number of roads Your task is to calculate this minimum number of roads ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 42424;\n\nint ss[N], ff[N], pred[N], last[N], was[N], sz[N];\nint n, m, ans, i, st;\n\nvoid dfs0(int v) {\n  was[v] = 1;\n  sz[v] = 0;\n  int j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      dfs0(ff[j]);\n      sz[v] += sz[ff[j]];\n      if (j > m) sz[v]++;\n    }\n    j = pred[j];\n  }\n}\n\nvoid dfs(int v, int w, int s, int mn, int p) {\n  was[v] = 1;\n  int cur = w;\n  int j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      cur += sz[ff[j]];\n      if (j > m) cur++;\n    }\n    j = pred[j];\n  }\n  if (cur+s+mn < ans) ans = cur+s+mn;\n  j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      int cc = cur-sz[ff[j]];\n      if (j > m) cc--;\n      int newp = p+1, news = s;\n      if (j <= m) news++;\n      int newmn = mn;\n      if (newp-2*news < newmn) newmn = newp-2*news;\n      dfs(ff[j], cc, news, newmn, newp);\n    }\n    j = pred[j];\n  }\n}\n\nint main() {\n//  freopen(""in"", ""r"", stdin);\n//  freopen(""out"", ""w"", stdout);\n  scanf(""%d"", &n);\n  m = n-1;\n  for (i=1;i<=m;i++) {\n    scanf(""%d %d"", ss+i, ff+i);\n    ss[i+m] = ff[i];\n    ff[i+m] = ss[i];\n  }\n  for (i=1;i<=n;i++) last[i] = 0;\n  for (i=1;i<=m+m;i++) {\n    pred[i] = last[ss[i]];\n    last[ss[i]] = i;\n  }\n  ans = 424242;\n  for (st=1;st<=n;st++) {\n    for (i=1;i<=n;i++) was[i] = 0;\n    dfs0(st);\n    for (i=1;i<=n;i++) was[i] = 0;\n    dfs(st, 0, 0, 0, 0);\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","['dfs and similar', 'dp', 'greedy', 'trees']",2100
https://codeforces.com//contest/660/problem/E,E. Different Subsets For All Tuples,For a sequence of integers between and inclusive denote as the number of distinct subsequences of including the empty subsequence You are given two positive integers and Let be the set of all sequences of length consisting of numbers from to Compute the sum over all in modulo ,"['# include <cstdio>\nconst int MOD = 1e9 + 7;\nlong long pow(int b, int e)\n{\n\tif (e == 0)\n\t\treturn 1;\n\telse if (e % 2)\n\t\treturn pow(b, e - 1) * b % MOD;\n\tlong long h = pow(b, e / 2);\n\treturn h * h % MOD;\n}\nconst int MN = 1e6 + 44;\nlong long f[MN], fin[MN];\nlong long bin(int a, int b)\n{\n\treturn f[a] * fin[b] % MOD * fin[a - b] % MOD;\n}\nint main()\n{\n\tf[0] = 1;\n\tfor (int i = 1; i < MN; ++i)\n\t\tf[i] = f[i - 1] * i % MOD;\n\tfin[MN - 1] = pow(f[MN - 1], MOD - 2);\n\tfor (int i = MN - 2; i >= 0; --i)\n\t\tfin[i] = fin[i + 1] * (i + 1) % MOD;\n// \tfor (int i = 0; i < 10; ++i)\n// \t{\n// \t\tfor (int k = 0; k <= i; ++k)\n// \t\t\tprintf(""%d "", bin(i, k));\n// \t\tprintf(""\\n"");\n// \t}\n\tint n, m;\n\tscanf(""%d%d"", &n, &m);\n\tlong long res = 0;\n\tlong long sum = 0;\n\tfor (int k = 0; k <= n; ++k)\n\t{\n// \t\tprintf(""k = %d sum = %lld\\n"", k, sum);\n\t\tres = (res + pow(m, k) * (pow (m, n) - sum)) % MOD;\n\t\tsum = (sum + bin(n, k) * pow(m - 1, n - k)) % MOD;\n\t}\n\tif (res < 0)\n\t\tres += MOD;\n\tprintf(""%d\\n"", (int) res);\n}']","['combinatorics', 'math']",2300
https://codeforces.com//contest/167/problem/B,B. Wizards and Huge Prize,One must train much to do well on wizardry contests So there are numerous wizardry schools and magic fees One of such magic schools consists of tours A winner of each tour gets a huge prize The school is organised quite far away so one will have to take all the prizes home in one go And the bags that you ve brought with you have space for no more than huge prizes Besides the fact that you want to take all the prizes home you also want to perform well You will consider your performance good if you win at least tours In fact years of organizing contests proved to the organizers that transporting huge prizes is an issue for the participants Alas no one has ever invented a spell that would shrink the prizes So here s the solution for some tours the winner gets a bag instead of a huge prize Each bag is characterized by number the number of huge prizes that will fit into it You already know the subject of all tours so you can estimate the probability of winning the th tour You cannot skip the tour under any circumstances Find the probability that you will perform well on the contest and will be able to take all won prizes home that is that you will be able to fit all the huge prizes that you won into the bags that you either won or brought from home ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ndouble p[210];\nint a[210];\ndouble dp[210][210][210]; // pos, won, cap\n\nint main(void){\n    int N,L,K,i,j,k;\n    \n    cin >> N >> L >> K;\n    REP(i,N) cin >> p[i];\n    REP(i,N) cin >> a[i];\n    REP(i,N) p[i] /= 100.0;\n    \n    dp[0][0][0] = 1.0;\n    \n    REP(i,N) REP(j,i+1) REP(k,N+1){\n        int c = a[i] + 1;\n        // win\n        dp[i+1][j+1][min(k+c,N)] += dp[i][j][k] * p[i];\n        // lose\n        dp[i+1][j][k] += dp[i][j][k] * (1.0 - p[i]);\n    }\n    \n    double ans = 0.0;\n    REP(i,N+1) REP(j,N+1) if(i >= L && K+j-i >= 0) ans += dp[N][i][j];\n    printf(""%.9f\\n"",ans);\n    \n    return 0;\n}\n']","['dp', 'math', 'probabilities']",1800
https://codeforces.com//contest/1389/problem/G,G. Directing Edges,You are given an undirected connected graph consisting of n vertices and m edges k vertices of this graph are special You have to direct each edge of this graph or leave it undirected If you leave the i th edge undirected you pay w i coins and if you direct it you don t have to pay for it Let s call a vertex if it is reachable from each special vertex along the edges of the graph if an edge is undirected it can be traversed in both directions After you direct the edges of the graph possibly leaving some of them undirected you receive c i coins for each saturated vertex i Thus your total profit can be calculated as sum limits i in S c i sum limits j in U w j where S is the set of saturated vertices and U is the set of edges you leave undirected For each vertex i calculate the maximum possible profit you can get if you have to make the vertex i saturated ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 300300;\nint n, m, k;\nvector<int> g[N];\nvector<pii> G[N];\nint cntSpec[N];\nll sumVal[N];\nint h[N];\nint minH[N];\nint root;\nint ed[N][3];\nbool isBridge[N];\nint myComp[N];\nll val[N];\nmap<pii, ll> dp;\nint deg[N];\nll ans[N];\nint q[2 * N];\nint topQ;\n\nint getOther(int id, int v) {\n\treturn ed[id][0] ^ ed[id][1] ^ v;\n}\n\nvoid dfs1(int v) {\n//\teprintf(""dfs1 %d %d\\n"", v, h[v]);\n\tminH[v] = h[v];\n\tfor (int id : g[v]) {\n\t\tint u = getOther(id, v);\n\t\tif (h[u] != -1) {\n\t\t\tif (h[u] != h[v] - 1)\n\t\t\t\tminH[v] = min(minH[v], h[u]);\n\t\t\tcontinue;\n\t\t}\n\t\th[u] = h[v] + 1;\n\t\tdfs1(u);\n\t\tcntSpec[v] += cntSpec[u];\n//\t\tsumVal[v] += sumVal[u];\n\t\tminH[v] = min(minH[v], minH[u]);\n\t\tif (minH[u] > h[v] && cntSpec[u] > 0) {\n\t\t\tisBridge[id] = 1;\n\t\t}\n\t}\n}\nvoid dfsComp(int v) {\n\tmyComp[v] = k;\n\tval[k] += sumVal[v];\n\tfor (int id : g[v]) {\n\t\tif (isBridge[id]) continue;\n\t\tint u = getOther(id, v);\n\t\tif (myComp[u] == -1)\n\t\t\tdfsComp(u);\n\t}\n}\n\nvoid solve(int v) {\n\tif (deg[v] == 1) {\n\t\tpii u = mp(-1, -1);\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(v, w))) {\n\t\t\t\tsum += dp[mp(v, w)];\n\t\t\t} else {\n\t\t\t\tu = e;\n\t\t\t}\n\t\t}\n\t\tif (u.first != -1) {\n\t\t\tint w = u.first;\n\t\t\tsum = max(0LL, sum - u.second);\n\t\t\tdp[mp(w, v)] = sum;\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else if (deg[v] == 0) {\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tsum += dp[mp(v, w)];\n\t\t}\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(w, v))) continue;\n\t\t\tdp[mp(w, v)] = max(0LL, sum - dp[mp(v, w)] - e.second);\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else throw;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx--;\n\t\troot = x;\n\t\tcntSpec[x]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &sumVal[i]);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(""%d"", &ed[i][2]);\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\tg[v].push_back(i);\n\t\tg[u].push_back(i);\n\t}\n\tk = 0;\n\tfor (int i = 0; i < n; i++)\n\t\th[i] = -1;\n\th[root] = 0;\n\tdfs1(root);\n\t/*\n\tfor (int i = 0; i < m; i++)\n\t\teprintf(""%d"", (int)isBridge[i]);\n\teprintf(""\\n"");\n\t*/\n\tfor (int v = 0; v < n; v++)\n\t\tmyComp[v] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (myComp[v] != -1) continue;\n\t\tdfsComp(v);\n\t\tk++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!isBridge[i]) continue;\n\t\tint v = myComp[ed[i][0]], u = myComp[ed[i][1]];\n\t\tassert(v != u);\n\t\tG[v].push_back(mp(u, ed[i][2]));\n\t\tG[u].push_back(mp(v, ed[i][2]));\n\t}\n\n\tif (k == 1) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(""%lld "", val[0]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tdeg[v] = (int)G[v].size();\n\t\tif (deg[v] <= 1) q[topQ++] = v;\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tsolve(q[i]);\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tans[v] = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint u = e.first;\n\t\t\tans[v] += dp[mp(v, u)];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%lld "", ans[myComp[i]]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']","['dfs and similar', 'dp', 'graphs', 'trees']",2800
https://codeforces.com//contest/124/problem/A,A. The number of positions,Petr stands in line of people but he doesn t know exactly which position he occupies He can say that there are no less than people standing in front of him and no more than people standing behind him Find the number of different positions Petr can occupy ,"['#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void) {\n  for (int n, a, b; cin >> n >> a >> b; ) {\n    cout << (min(b + 1, n - a)) << ""\\n"";\n  }\n  return 0;\n}\n']",['math'],1000
https://codeforces.com//contest/1671/problem/F,F. Permutation Counting,Calculate the number of permutations p of size n with exactly k inversions pairs of indices i j such that i j and p i p j and exactly x indices i such that p i p i 1 Yep that s the whole problem Good luck ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:46:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n\n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    for (int i = n - 1; i >= m - 1; i--) {\n      Mint c = a.back() / b.back();\n      for (int j = 0; j < m; j++) {\n        a[i - (m - 1) + j] -= b[j] * c;\n      }\n      a.pop_back();\n    }\n/*    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }*/\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<T> BM(vector<T> a) {\n  vector<T> p = {1};\n  vector<T> q = {1};\n  int l = 0;\n  for (int r = 1; r <= (int) a.size(); r++) {\n    T delta = 0;\n    for (int j = 0; j <= l; j++) {\n      delta += a[r - 1 - j] * p[j];\n    }\n    q.insert(q.begin(), 0);\n    if (delta != 0) {\n      vector<T> t = p;\n      if (q.size() > t.size()) {\n        t.resize(q.size());\n      }\n      for (int i = 0; i < (int) q.size(); i++) {\n        t[i] -= delta * q[i];\n      }\n      if (2 * l <= r - 1) {\n        q = p;\n        T od = 1 / delta;\n        for (T& x : q) {\n          x *= od;\n        }\n        l = r - l;\n      }\n      swap(p, t);\n    }\n  }\n  assert((int) p.size() == l + 1);\n//  assert(l * 2 + 30 < (int) a.size());\n  reverse(p.begin(), p.end());\n  return p;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = 111;\n  vector<vector<vector<vector<Mint>>>> f(N, vector<vector<vector<Mint>>>(N, vector<vector<Mint>>(12, vector<Mint>(12))));\n  f[1][0][0][0] = 1;\n  for (int n = 1; n < N - 1; n++) {\n    for (int p = 0; p < n; p++) {\n      for (int k = 0; k <= 11; k++) {\n        for (int x = 0; x <= 11; x++) {\n          for (int t = 0; t <= n; t++) {\n            int nk = k + (n - t);\n            int nx = x + (t <= p);\n            if (nk <= 11 && nx <= 11) {\n              f[n + 1][t][nk][nx] += f[n][p][k][x];\n            }\n          }\n        }\n      }\n    }\n  }\n  vector<vector<vector<Mint>>> r(12, vector<vector<Mint>>(12));\n  vector<vector<vector<Mint>>> vecs(12, vector<vector<Mint>>(12));\n  for (int k = 1; k <= 11; k++) {\n    for (int x = 1; x <= 11; x++) {\n      vector<Mint>& vec = vecs[k][x];\n      for (int n = 1; n < N; n++) {\n        Mint s = 0;\n        for (int p = 0; p < n; p++) {\n          s += f[n][p][k][x];\n        }\n        vec.push_back(s);\n      }\n      r[k][x] = BM(vec);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k, x;\n    cin >> n >> k >> x;\n    auto y = power(vector<Mint>{0, 1}, n - 1, r[k][x]);\n    Mint ans = 0;\n    for (int i = 0; i < (int) y.size(); i++) {\n      ans += y[i] * vecs[k][x][i];\n    }\n    cout << ans << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']","['brute force', 'combinatorics', 'dp', 'fft', 'math']",2700
https://codeforces.com//contest/1157/problem/F,F. Maximum Balanced Circle,There are n people in a row The height of the i th person is a i You can choose subset of these people and try to arrange them into a A is such an order of people that the difference between heights of any adjacent people is no more than 1 For example let heights of chosen people be a i 1 a i 2 dots a i k where k is the number of people you choose Then the condition a i j a i j 1 le 1 should be satisfied for all j from 1 to k 1 and the condition a i 1 a i k le 1 should be also satisfied x means the absolute value of x It is obvious that the circle consisting of one person is balanced Your task is to choose the maximum number of people and construct a consisting of all chosen people It is obvious that the circle consisting of one person is balanced so the answer always exists ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tprintf(""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n\n// Optimize\n#define abs(a) ((a)<0?(~(a)+1):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) {a=a^b;b=a^b;a=a^b;}\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define MOD 998244353\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 262144\n\nint n;\nint cnt[MAXN], sumcnt[MAXN];\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n){\n\t\tiRead(x);\n\t\t++cnt[x];\n\t}\n\tFor(i,200000) sumcnt[i] = sumcnt[i-1] + cnt[i];\n\n\tint ans = -INF, ans_l, ans_r;\n\tint r = 0;\n\tFor(l,200000){\n\t\tif(!cnt[l]) continue;\n\t\tMymax(r,l);\n\t\twhile( cnt[r+1] >= 1 and (cnt[r] >= 2||l==r) and r <= 200000 ){\n\t\t\t++r;\n\t\t}\n\t\tint tans = sumcnt[r] - sumcnt[l-1];\n\t\tif( ans < tans ){\n\t\t\tans = tans;\n\t\t\tans_l = l;\n\t\t\tans_r = r;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tForx(i,ans_l,ans_r){\n\t\t--cnt[i];\n\t\tcout << i << "" "";\n\t}\n\tfORx(i,ans_l,ans_r){\n\t\twhile(cnt[i]){\n\t\t\tcout << i << "" "";\n\t\t\t--cnt[i];\n\t\t}\n\t}\n\tcout << endl;\n\n\tEND();\n}\n']","['constructive algorithms', 'dp', 'greedy', 'two pointers']",2000
https://codeforces.com//contest/759/problem/B,B. Travel Card,A new innovative ticketing systems for public transport is introduced in Bytesburg Now there is a single travel card for all transport To make a trip a passenger scan his card and then he is charged according to the fare The fare is constructed in the following manner There are three types of tickets a ticket for one trip costs byteland rubles a ticket for minutes costs byteland rubles a ticket for one day minutes costs byteland rubles Note that a ticket for minutes activated at time can be used for trips started in time range from to inclusive Assume that all trips take exactly one minute To simplify the choice for the passenger the system automatically chooses the optimal tickets After each trip starts the system analyses all the previous trips and the current trip and chooses a set of tickets for these trips with a minimum total cost Let the minimum total cost of tickets to cover all trips from the first to the current is and the total sum charged before is Then the system charges the passenger the sum You have to write a program that for given trips made by a passenger calculates the sum the passenger is charged after each trip ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100001];\nint d[100001];\n\nint main() {\n\tint i, n;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\td[i] = min(min(d[i - 1] + 20, d[upper_bound(a, a + i, a[i] - 90) - a - 1] + 50), d[upper_bound(a, a + i, a[i] - 1440) - a - 1] + 120);\n\t\tprintf(""%d\\n"", d[i] - d[i - 1]);\n\t}\n}']","['binary search', 'dp', 'greedy', 'two pointers']",1600
https://codeforces.com//contest/1151/problem/C,C. Problem for Nazar,Nazar a student of the scientific lyceum of the Kingdom of Kremland is known for his outstanding mathematical abilities Today a math teacher gave him a Consider two infinite sets of numbers The first set consists of odd positive numbers 1 3 5 7 ldots and the second set consists of even positive numbers 2 4 6 8 ldots At the first stage the teacher writes the first number on the endless blackboard from the first set in the second stage the first two numbers from the second set on the third stage the next four numbers from the first set on the fourth the next eight numbers from the second set and so on In other words at each stage starting from the second he writes out numbers than at the previous one and also from which these numbers are written out The ten first written numbers 1 2 4 3 5 7 9 6 8 10 Let s number the numbers written starting The task is to find the sum of numbers with numbers from l to r for given integers l and r The answer may be big so you need to find the remainder of the division by 1000000007 10 9 7 Nazar thought about this problem for a long time but didn t come up with a solution Help him solve this problem ,"['#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nconst int inv2 = (mod + 1) / 2;\nint main() {\n\tlong long L, R;\n\tcin >> L >> R; ++R;\n\tlong long ans = 0, odd = 1, even = 2;\n\tfor (int i = 0; i <= 60; ++i) {\n\t\tlong long pl = (1LL << i), pr = (2LL << i);\n\t\tpl = max(pl, L);\n\t\tpr = min(pr, R);\n\t\tif (pl < pr) {\n\t\t\tlong long s = (i % 2 == 0 ? odd + (pl - (1LL << i)) * 2 : even + (pl - (1LL << i)) * 2);\n\t\t\tlong long g = s + (pr - pl - 1) * 2;\n\t\t\tans += ((s + g) % mod) * (((g - s) / 2 + 1) % mod) % mod * inv2 % mod;\n\t\t\tans %= mod;\n\t\t}\n\t\tif (i % 2 == 0) odd += 2LL << i;\n\t\telse even += 2LL << i;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']","['constructive algorithms', 'math']",1800
https://codeforces.com//contest/866/problem/B,B. Ordering Pizza,It s another Start c up finals and that means there is pizza to order for the onsite contestants There are only 2 types of pizza obviously not but let s just pretend for the sake of the problem and all pizzas contain exactly slices It is known that the th contestant will eat slices of pizza and gain happiness for each slice of type 1 pizza they eat and happiness for each slice of type 2 pizza they eat We can order any number of type 1 and type 2 pizzas but we want to buy the minimum possible number of pizzas for all of the contestants to be able to eat their required number of slices Given that restriction what is the maximum possible total happiness that can be achieved ,"['/**\n *    author:  tourist\n *    created: 30.09.2017 20:08:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint eat[N], a[N], b[N];\n\nint main() {\n  int n, s;\n  scanf(""%d %d"", &n, &s);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(""%d %d %d"", eat + i, a + i, b + i);\n    total += eat[i];\n  }\n  long long pizzas = (total + s - 1) / s;\n  eat[n] = s * pizzas - total;\n  a[n] = 0;\n  b[n] = 0;\n  n++;\n  vector< pair<long long, long long> > a_to_b, b_to_a;\n  long long ans = 0;\n  long long cnt_a = 0, cnt_b = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] > b[i]) {\n      ans += eat[i] * 1LL * a[i];\n      a_to_b.emplace_back(a[i] - b[i], eat[i]);\n      cnt_a += eat[i];\n    } else {\n      ans += eat[i] * 1LL * b[i];\n      b_to_a.emplace_back(b[i] - a[i], eat[i]);\n      cnt_b += eat[i];\n    }\n  }\n  long long best = (long long) 1e18;\n  {\n    long long extra = cnt_a % s;\n    sort(a_to_b.begin(), a_to_b.end());\n    long long cur = 0;\n    for (int i = 0; i < (int) a_to_b.size(); i++) {\n      auto &p = a_to_b[i];\n      long long take = min(p.second, extra);\n      cur += take * p.first;\n      extra -= take;\n    }\n    best = min(best, cur);\n  }\n  {\n    long long extra = cnt_b % s;\n    sort(b_to_a.begin(), b_to_a.end());\n    long long cur = 0;\n    for (int i = 0; i < (int) b_to_a.size(); i++) {\n      auto &p = b_to_a[i];\n      long long take = min(p.second, extra);\n      cur += take * p.first;\n      extra -= take;\n    }\n    best = min(best, cur);\n  }\n  cout << (ans - best) << endl;\n  return 0;\n}\n']","['greedy', 'implementation', 'sortings']",1900
