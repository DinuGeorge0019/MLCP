problem_link,problem_id,problem_idx,short_id,contest_number,problem_name,problem_statement,problem_solution,problem_input,problem_output,problem_tags,problem_dificulty,file_name,editorial_link,problem_editorial
https://codeforces.com//contest/1063/problem/E,236989,E,1063E,1063,E. Lasers and Mirrors,Oleg came to see the maze of mirrors The maze is a n by n room in which each cell is either empty or contains a mirror connecting opposite corners of this cell Mirrors in this maze reflect light in a perfect way which causes the interesting visual effects and contributes to the loss of orientation in the maze Oleg is a person of curious nature so he decided to install n lasers facing internal of the maze on the south wall of the maze On the north wall of the maze Oleg installed n receivers also facing internal of the maze Let s number lasers and receivers from west to east with distinct integers from 1 to n Each laser sends a beam of some specific kind and receiver with number a i should receive the beam sent from laser number i Since two lasers beams can t come to the same receiver these numbers form a each of the receiver numbers occurs exactly once You came to the maze together with Oleg Help him to place the mirrors in the initially empty maze so that the maximum number of lasers beams will come to the receivers they should There are no mirrors outside the maze so if the laser beam leaves the maze it will not be able to go back ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int MaxN = 1024;\n\nint N;\nint order[MaxN];\nint prev_order[MaxN];\nbool visited[MaxN];\n\nVI GetCycle(int x) {\n  assert(!visited[x]);\n  VI answer;\n  do {\n    visited[x] = true;\n    answer.push_back(x);\n    x = prev_order[x];\n  } while (x != answer[0]);\n  return answer;\n}\n\nvector<string> last_answer;\nvector<string> answer;\n\nvoid MoveRibbon(string &s, int from, int to) {\n  assert(from != to);\n  if (from < to) {\n    s[from] = s[to] = \'\\\\\';\n  } else {\n    s[from] = s[to] = \'/\';\n  }\n}\n\nvoid SolveFirst() {\n  auto cyc0 = GetCycle(0);\n  const int S = SZ(cyc0);\n\n  for (int i = S - 1; i > 0; --i) {\n    const int cur = cyc0[i];\n    const int nxt = cyc0[(i + 1) % S];\n    string line(N, \'.\');\n    MoveRibbon(line, cur, nxt);\n    last_answer.push_back(line);\n  }\n}\n\nvoid SolveOther(int base) {\n  if (visited[base]) { return; }\n  auto cycle = GetCycle(base);\n  const int S = SZ(cycle);\n  if (S == 1) { return; }\n\n  string first_line(N, \'.\');\n  MoveRibbon(first_line, base, 0);\n  MoveRibbon(first_line, cycle.back(), base);\n  answer.push_back(first_line);\n\n  cycle[0] = 0;\n\n  for (int d = S - 1; d > 0; --d) {\n    const int src = cycle[d - 1];\n    const int dest = cycle[d];\n    string line(N, \'.\');\n    MoveRibbon(line, src, dest);\n    answer.push_back(line);\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  int num_matching = 0;\n  for (int i = 0; i < N; ++i) {\n    cin >> order[i];\n    --order[i];\n    prev_order[order[i]] = i;\n    num_matching += order[i] == i;\n  }\n\n  if (num_matching == N) {\n    cout << N << ""\\n"";\n    for (int i = 0; i < N; ++i)\n      cout << string(N, \'.\') << ""\\n"";\n    return 0;\n  }\n\n  SolveFirst();\n  for (int fst = 1; fst < N; ++fst)\n    SolveOther(fst);\n\n  for (string s : last_answer)\n    answer.PB(s);\n\n  while ((int)answer.size() != N)\n    answer.push_back(string(N, \'.\'));\n\n  cout << N - 1 << ""\\n"";\n  for (auto &s : answer)\n    cout << s << ""\\n"";\n\n}\n\n']",,,"['constructive algorithms', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Lasers and Mirrors.json,https://codeforces.com/blog/entry/62455,The answer is always if the permutation is identity lasers or otherwise Clearly we can t have more than matching lasers if the permutation is not identity Consider just the very first line with mirrors If the first mirror in this line is then we miss the laser below this mirror if the very last mirror is we miss the laser below it Otherwise there are neighbouring and and we lost two lasers now The proof of is constructive one Ignore all fixed points in permutation all that Select arbitrary cycle and select one point in it as dead We can spend operations to fix all points in this cycle But we also need to fix all other cycles We can do it in operations move arbitrary beam to the wasted laser fix all other points and move that point back But this is a bit too much lines The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line if we select as the trash beam the rightmost point See the following picture for an example trash beam is the rightmost column 
https://codeforces.com//contest/1139/problem/D,317129,D,1139D,1139,D. Steps to One,Vivek initially has an empty array a and some integer constant m He performs the following algorithm Select a random integer x uniformly in range from 1 to m and append it to the end of a Compute the greatest common divisor of integers in a In case it equals to 1 break Otherwise return to step 1 Find the expected length of a It can be shown that it can be represented as frac P Q where P and Q are coprime integers and Q neq 0 pmod 10 9 7 Print the value of P cdot Q 1 pmod 10 9 7 ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long llong;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\n\nint pw(int x, int p) {\n    int r = 1;\n    while (p) {\n        if (p & 1) r = (llong)r * x % mod;\n        x = (llong)x * x % mod;\n        p >>= 1;\n    }\n    return r;\n}\n\nint popcount(int x) {\n    int ret = 0;\n    while (x) {\n        ret += x & 1;\n        x >>= 1;\n    }\n    return ret;\n}\n\nint m;\nint dp[100001];\nvector<int> di[100001];\nvector<pii> pr[100001];\nint prs[100001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> m;\n    if (m == 1) {\n        printf(""1\\n"");\n        return 0;\n    }\n    for (int i = 1; i <= m; ++i) {\n        for (int j = i; j <= m; j += i) di[j].push_back(i);\n        if (di[i].size() == 2) {\n            for (int j = i; j <= m; j += i) {\n                int k = j;\n                pr[j].emplace_back(i, 0);\n                while (k % i == 0) ++pr[j].back().second, k /= i;\n            }\n        }\n    }\n    dp[1] = 1;\n    for (int i = 2; i <= m; ++i) {\n        int ci, rhs = m;\n        for (int j : di[i]) {\n            for (pii k : pr[j]) prs[k.first] = k.second;\n            vector<int> ps;\n            int rm = m;\n            for (pii k : pr[i]) {\n                for (int l = prs[k.first]; l--; ) rm /= k.first;\n                if (prs[k.first] < k.second) ps.push_back(k.first);\n            }\n            for (pii k : pr[j]) prs[k.first] = 0;\n            int sum = 0;\n            for (int k = 0; k < (1 << ps.size()); ++k) {\n                int sign = popcount(k) & 1;\n                sign = 1 - sign - sign;\n                int nm = rm;\n                for (int l = 0; l < ps.size(); ++l) if ((k >> l) & 1) nm /= ps[l];\n                sum += sign * nm;\n            }\n            if (j == i) ci = m - sum;\n            else rhs += (llong)sum * dp[j] % mod, rhs %= mod;\n        }\n        dp[i] = (llong)rhs * pw(ci, mod - 2) % mod;\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; ++i) ans += dp[i], ans %= mod;\n    ans = (llong)ans * pw(m, mod - 2) % mod;\n    printf(""%d\\n"", ans);\n    return 0;\n}']",,,"['dp', 'math', 'number theory', 'probabilities']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Steps to One.json,https://codeforces.com//blog/entry/66101,Let be the expected number of additional steps to get a gcd of 1 if the gcd of the current array is Suppose the current gcd of the array is after the next iteration of the algorithm we would append some randomly chosen with a probability and move to state and since the length increases by on appending we will make steps for this So the recurrence is I recommend this Expectation tutorial to get more understanding of the basics We can group together all terms having the same move terms having to the left side of the equation and use that to calculate This is an solution Here we notice that is a factor of So the recurrence could be modified as where is the count of integers such that Lets express and where are positive integers So we want to find the number of s where such that i e we want to find number of where such that Lets find factorization of so must not be divisible by any of the prime factors of We can find number of such that it isn t divisible by some set of primes by inclusion exclusion Since there are at most primes we have complexity For an alternate solution using mobius function refer code 2 
https://codeforces.com//contest/1647/problem/A,1325135,A,1647A,1647,A. Madoka and Math Dad,Madoka finally found the administrator password for her computer Her father is a well known popularizer of mathematics so the password is the answer to the following problem Find the maximum decimal number without zeroes and with no equal digits in a row such that the sum of its digits is n Madoka is too tired of math to solve it herself so help her to solve this problem ,"['#include <bits/stdc++.h>\n\n#define f first\n#define s second\n//#define x first\n//#define y second\n//#define int li\n#define err if(debug_out)cout\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pld = pair<ld, ld>;\n\nconst int INF = 1e9 + 13;\nconst li INF64 = 1e18 + 13;\nconst int N = 3e5 + 13;\nconst int LOGN = 20;\nconst int K = 22;\nconst int M = 998244353;//1e9 + 7;\nconst int A = 26;\nconst ld eps = 1e-8;\n\nmt19937 rnd(45768);\n\n/*\n*/\n\nint sum(int a, int b) {\n    a += b;\n    return (a >= M ? a - M : a);\n}\n\nint mul(int a, int b) {\n    return a * 1ll * b % M;\n}\n\nint dif(int a, int b) {\n    return sum(a, M - b);\n}\n\nint pow2(int n, int k) {\n    if(k == 0)\n        return 1;\n\n    int pw = pow2(n, k / 2);\n    pw = mul(pw, pw);\n\n    return (k % 2 == 0 ? pw : mul(pw, n));\n}\n\n/*\n*/\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    if(n == 1) {\n        cout << 1 << endl;\n        return;\n    }\n\n    string s = """";\n    while(n > 0) {\n        if(s.empty()) {\n            s += \'2\';\n            n -= 2;\n        } else if(s.back() == \'1\') {\n            if(n == 1) {\n                cout << 1 << s << endl;\n                return;\n            } else {\n                s += \'2\';\n                n -= 2;\n            }\n        } else {\n            s += \'1\';\n            n--;\n        }\n    }\n\n    cout << s << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n}\n']",,,"['implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Madoka and Math Dad.json,https://codeforces.com//blog/entry/100780,Since we want to maximize the number we need we will first find the longest suitable number Obviously it is better to use only the numbers 1 and 2 for this Therefore the answer always looks like 2121 or 1212 The first option is optimal when n has a remainder of 2 or 0 modulo 3 otherwise the second option is optimal 
https://codeforces.com//contest/1348/problem/E,609092,E,1348E,1348,E. Phoenix and Berries,Phoenix is picking berries in his backyard There are n shrubs and each shrub has a i red berries and b i blue berries Each basket can contain k berries But Phoenix has decided that each basket may only contain berries from the same shrub or berries of the same color red or blue In other words all berries in a basket must be from the same shrub or and have the same color For example if there are two shrubs with 5 red and 2 blue berries in the first shrub and 2 red and 1 blue berries in the second shrub then Phoenix can fill 2 baskets of capacity 4 completely the first basket will contain 3 red and 1 blue berries from the first shrub the second basket will contain the 2 remaining red berries from the first shrub and 2 red berries from the second shrub Help Phoenix determine the maximum number of baskets he can ,"['#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=510;\nint n,k,a[MAXN],b[MAXN];\nll dp[2][MAXN],sum,ans;\nint main () {\n\tscanf(""%d%d"",&n,&k);\n\tfor (int i=0;i<k;i++) {dp[0][i]=-1e18;}\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=0;j<k;j++) {dp[i&1][j]=-1e18;}\n\t\tscanf(""%d%d"",&a[i],&b[i]);\n\t\tfor (int j=0;j<k;j++){ \n\t\t\tint tmp=(sum%k+k-j)%k;\n\t\t\tfor (int l=0;l<min(k,a[i]+1);l++) {\n\t\t\t\tint tmp2=((a[i]+b[i])%k+k-l)%k;\n\t\t\t\t//cout << i << ""    "" << j << ""  "" << tmp << ""    "" << l << ""  "" << tmp2 << ""    "" << dp[i&1][(j+l)%k] << ""    "";\n\t\t\t\tif (tmp2>b[i]) {continue;}\n\t\t\t\tdp[i&1][(j+l)%k]=max(dp[i&1][(j+l)%k],dp[(i&1)^1][j]+(j+l)/k+(tmp+tmp2)/k+(a[i]+b[i]-tmp2-l)/k);\n\t\t\t\t//cout << dp[i&1][(j+l)%k] << ""    "" << dp[(i&1)^1][j]+(j+l)/k+(tmp+tmp2)/k+(a[i]+b[i]-tmp2-l)/k << endl;\n\t\t\t}\n\t\t}\n\t\tsum+=a[i];\n\t\tsum+=b[i];\n\t}\n\tans=0;\n\tfor (int i=0;i<k;i++) {ans=max(ans,dp[n&1][i]);}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}\n']",,,"['brute force', 'dp', 'greedy', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Phoenix and Berries.json,https://codeforces.com//blog/entry/76555,There is no obvious greedy solution so we will try dynamic programming Let be a boolean array that denotes whether we can have extra red berries after considering the first shrubs A berry is extra if it is not placed into a full basket of any kind Note that if we know that there are extra red berries we can also easily calculate how many extra blue berries there are Note that we can choose to never have more than extra red berries because otherwise we can fill some number of baskets with them To transition from shrub to shrub we loop over all possible values from to and check whether or not we can leave extra red berries from the current shrub For some and we can leave extra red berries and put the remaining red berries in baskets possibly with blue berries from the same shrub if The reasoning for this is as follows First of all we are leaving red berries or at least trying to We show that from this shrub there will be at most one basket containing both red and blue berries all from this shrub To place the remaining red berries into full baskets the more blue berries we have the better It is optimal to place the remaining red berries into their own separate baskets first before merging with the blue berries this way requires fewest blue berries to satisfy the condition Then if is at least we can fill some basket with the remaining red berries and possibly some blue berries Remember that we do not care about how many extra blue berries we leave because that is uniquely determined by the number of extra red berries Also note that we can always leave extra red berries Denote the total number of berries as The answer will be maximum over all such that is true Time Complexity We use dynamic programming Let be true if after considering the first shrubs is the number of red berries in heterogenous baskets modulo Heterogenous baskets contain berries from the same shrub and homogenous baskets contain berries of the same type Suppose we know the number of red berries in heterogeneous baskets modulo This determines the number of blue berries in heterogeneous baskets modulo Since the number of red berries in homogeneous baskets is a multiple of it also determines the number of red berries not in any baskets we can safely assume this to be less than since otherwise we can form another basket Similarly we can determine the number of blue berries not in any basket and thus deduce the number of baskets To compute the possible numbers of red berries in heterogeneous baskets modulo it suffices to look at each shrub separately and determine the possible numbers of red berries modulo in heterogeneous baskets for that shrub If there is more than one heterogeneous basket for one shrub we can rearrange the berries to leave at most one heterogeneous Now we have two cases If there are no heterogeneous baskets the number of red berries in those baskets is obviously zero If there is one heterogeneous basket let be the number of red berries in it and be the number of blue berries in it Clearly and Rearranging we get These correspond to the transitions for our DP There exists faster solutions like can you find it 
https://codeforces.com//contest/903/problem/D,138453,D,903D,903,D. Almost Difference,Let s denote a function You are given an array consisting of integers You have to calculate the sum of over all pairs such that ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\nmap<ll, ll>totC, c;\nll a[210000];\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n; cin >> n;\n\tfori(n) {\n\t\tcin >> a[i];\n\t\ttotC[a[i]]++;\n\t}\n\tll answer = 0;\n\tunsigned long long pos, neg;\n\tpos = neg = 0;\n\tforj(n) {\n\t\tll i = a[j];\n\t\tll lf = c[i - 1] + c[i] + c[i + 1];\n\t\tll rg = totC[i - 1] + totC[i] + totC[i + 1] - 1 - lf;\n\t\tlf = j - lf;\n\t\trg = n - j - 1 - rg;\n\t\tpos += (unsigned long long)(i*lf);\n\t\tneg += (unsigned long long)(i*rg);\n\t\tc[i]++;\n\t}\n\tif (pos >= neg)cout << pos - neg;\n\telse cout << ""-"" << neg - pos;\n\treturn 0;\n}']",,,"['data structures', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Almost Difference.json,https://codeforces.com//blog/entry/56330,Starting pretty boring this came out as the most fun and controversial problem of the contest Well here is the basis of the solution You maintain some kind of map hashmap with amounts each number appeared in array so far Processing each number you subtract times indexed add prefix sum up to th number subtract and and add times Then update with And now we have to treat numbers greater than long long limits Obviously you can use built in bigints from java python ot write your own class with support of addition and printing of such numbers However numbers were up to by absolute value Then you can use long double its precision is enough for simple multiplication and addition You can also use unsigned long long numbers one for negative terms and the other one for positive terms in the end you should handle printing negative numbers Overall complexity 
https://codeforces.com//contest/1722/problem/D,1524436,D,1722D,1722,D. Line,There are n people in a horizontal line each looking either to the left or the right Each person counts the number of people in the direction they are looking The of the line is the sum of each person s count For example in the arrangement where stands for a person looking left and stands for a person looking right the counts for each person are 0 3 2 3 4 and the value is 0 3 2 3 4 12 You are given the initial arrangement of people in the line For each k from 1 to n determine the maximum value of the line if you can change the direction of k people ,"['#include<bits/stdc++.h>\n#define lowbit(x) x&(-x)\n#define int long long\nusing namespace std;\nconst int N=2e5+5;\nint n,m,q;\ninline int gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\nstruct data{\n\tint x,y;\n\tbool operator <(const data &t)const{\n\t\treturn x<t.x;\n\t}\n}d[N];\nnamespace BIT{\n\tint c[N];\n\tinline void add(int x,int y){\n\t\tfor(;x<=n;x+=lowbit(x))c[x]+=y;\n\t}\n\tinline int ask(int x){\n\t\tint ans=0;\n\t\tfor(;x;x-=lowbit(x))ans+=c[x];\n\t\treturn ans;\n\t}\n}\nnamespace Splay{\n\tint cnt,root;\n\tstruct tree{\n\t\tint f,val,siz,num;\n\t\tint son[2];\n\t}t[200005];\n\tinline void pushup(int x){\n\t\tt[x].siz=t[t[x].son[0]].siz+t[t[x].son[1]].siz+t[x].num;\n\t}\n\tinline void rot(int x){\n\t\tint prt=t[x].f,grf=t[prt].f,key=(t[prt].son[1]==x);\n\t\tt[grf].son[t[grf].son[1]==prt]=x;\n\t\tt[x].f=grf;\n\t\tt[prt].son[key]=t[x].son[!key];\n\t\tt[t[x].son[!key]].f=prt;\n\t\tt[x].son[!key]=prt;\n\t\tt[prt].f=x;\n\t\tpushup(prt),pushup(x);\n\t}\n\tinline void splay(int x,int goal){\n\t\twhile(t[x].f!=goal){\n\t\t\tint prt=t[x].f,grf=t[t[x].f].f;\n\t\t\tif(grf!=goal&&(t[grf].son[1]==prt)==(t[t[x].f].son[1]==x))rot(t[x].f);\n\t\t\trot(x);\n\t\t}\n\t\tif(!goal)root=x;\n\t}\n\tinline void insert(int x){\n\t\tint y=root,prt=0;\n\t\twhile(y&&t[y].val!=x)prt=y,y=t[y].son[x>t[y].val];\n\t\tif(y)++t[y].num;\n\t\telse{\n\t\t\ty=++cnt;\n\t\t\tif(prt)t[prt].son[x>t[prt].val]=y;\n\t\t\tt[y].son[0]=t[y].son[1]=0;\n\t\t\tt[y].val=x,t[y].f=prt,t[y].num=t[y].siz=1;\n\t\t}\n\t\tsplay(y,0);\n\t}\n\tinline void find(int x){\n\t\tif(!root)return;\n\t\tint y=root;\n\t\twhile(t[y].son[x>t[y].val]&&x!=t[y].val)y=t[y].son[x>t[y].val];\n\t\tsplay(y,0);\n\t}\n\tinline int fhd(int x,int key){\n\t\tfind(x);\n\t\tif(t[root].val>x&&key)return root;\n\t\tif(t[root].val<x&&!key)return root;\n\t\tint y=t[root].son[key];\n\t\tif(!y)return 0;\n\t\twhile(t[y].son[!key])y=t[y].son[!key];\n\t\treturn y;\n\t}\n\tinline void delt(int x){\n\t\tint fro=fhd(x,0),beh=fhd(x,1);\n\t\tsplay(fro,0),splay(beh,fro);\n\t\tint y=t[beh].son[0];\n\t\tif(t[y].num>1)--t[y].num,splay(y,0);\n\t\telse t[beh].son[0]=0,splay(beh,0);\n\t}\n\tinline int kth(int x){\n\t\tif(t[root].siz<x)return -1;\n\t\tint y=root;\n\t\twhile(1){\n\t\t\tint s=t[y].son[0];\n\t\t\tif(x<=t[s].siz)y=s;\n\t\t\telse if(x<=t[y].num+t[s].siz)return t[y].val;\n\t\t\telse x-=(t[s].siz+t[y].num),y=t[y].son[1];\n\t\t}\n\t}\n}\nstring s;\nint a[N],b[N];\nsigned main(){\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>s;\n\t\ts=\' \'+s;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(s[i]==\'L\')a[i]=i-1,b[i]=n-i-i+1;\n\t\t\telse a[i]=n-i,b[i]=i-1-n+i;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;++i)ans+=a[i];\n\t\tsort(b+1,b+n+1);reverse(b+1,b+n+1);\n\t\tfor(int i=1;i<=n;++i)cout<<(ans=max(ans,ans+b[i]))<<"" "";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}']",,,"['greedy', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Line.json,https://codeforces.com//blog/entry/106478,For each person let s calculate how much the value will change if they turn around For example in the line if the th person turns around then the value of the line will change by respectively For instance if the second person turns around they see people before and person after so the value of the line changes by if they turn around Now note that if a person turns around it doesn t affect anyone else s value So the solution is a greedy one let s sort the array of values in increasing order Afterwards we should go from the left to the right and see if the value will increase if this person turns around if it does we should add it to the current total and continue The time complexity of this solution is per testcase 
https://codeforces.com//contest/1878/problem/D,2229485,D,1878D,1878,D. Reverse Madness,You are given a string s of length n containing lowercase Latin letters Next you will be given a positive integer k and two arrays l and r of length k It is guaranteed that the following conditions hold for these 2 arrays l 1 1 r k n l i le r i for each positive integer i such that 1 le i le k l i r i 1 1 for each positive integer i such that 2 le i le k Now you will be given a positive integer q which represents the number of modifications you need to do on s Each modification is defined with one positive integer x Find an index i such that l i le x le r i notice that such i is unique Let a min x r i l i x and let b max x r i l i x Reverse the substring of s from index a to index b Reversing the substring a b of a string s means to make s equal to s 1 s 2 dots s a 1 s b s b 1 dots s a 1 s a s b 1 s b 2 dots s n 1 s n Print s after the last modification is finished ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200000], b[200000], d[200001];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, k, q;\n\t\tstring s;\n\t\tcin >> n >> k >> s;\n\t\tfor (int i = 0; i ^ k; ++i)\n\t\t\tcin >> a[i], --a[i];\n\t\tfor (int i = 0; i ^ k; ++i)\n\t\t\tcin >> b[i], --b[i];\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\td[i] = 0;\n\t\tcin >> q;\n\t\tfor (; q--;) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t--x;\n\t\t\tint p = upper_bound(a, a + k, x) - a - 1;\n\t\t\tint l = min(x, a[p] + b[p] - x);\n\t\t\tint r = max(x, a[p] + b[p] - x);\n\t\t\t++d[l], --d[r + 1];\n\t\t}\n\t\tint p = 0, cur = 0;\n\t\tfor (int i = 0; i ^ n; ++i) {\n\t\t\tcur += d[i];\n\t\t\tif (p < k && i > b[p])\n\t\t\t\t++p;\n\t\t\tif (cur & 1)\n\t\t\t\tcout << s[a[p] + b[p] - i];\n\t\t\telse\n\t\t\t\tcout << s[i];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]",,,"['data structures', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Reverse Madness.json,https://codeforces.com//blog/entry/120813,Observation 1 if we look at as subsegments for each notice that they are disjoint and that two modifications do not interfere with each other if they are from different subsegments Because of this observation we can basically treat subsegments as separate test cases Now without loss of generality because of the first observation we can consider the same problem but with and It is easy to see that the modifications and are equivalent because the first one will reverse the subsegment and the second one will do the same thing Using this we can consider without loss of generality for all modifications the following holds true Now try visualizing the modifications if then we reverse the whole string if then we reverse the whole string except the first and the last element if then we reverse the whole string except the first two and last two elements We can logically conclude that the modifications are symmetrical with respect to the middle of the string From this symmetry we can conclude that if a modification touches index it also touches index and also because of the symmetry will always be swapped with and no other index This means that the order of modifications doesn t matter because for each index it only matters how many modifications affect it Another thing to note is that for a given index all modifications such that affect this index This gives us the following solution Let s store the number of modifications for each index in an array and if then store it as Next we just iterate over the array while maintaining the sum of the number of operations and if it s odd we swap elements and else we just continue iterating 
https://codeforces.com//contest/1229/problem/B,419076,B,1229B,1229,B. Kamil and Making a Stream,Kamil likes streaming the competitive programming videos His MeTube channel has recently reached 100 million subscribers In order to celebrate this he posted a video with an interesting problem he couldn t solve yet Can you help him You re given a tree a connected undirected graph consisting of n vertices connected by n 1 edges The tree is rooted at vertex 1 A vertex u is called an of v if it lies on the shortest path between the root and v In particular a vertex is an ancestor of itself Each vertex v is assigned its x v a non negative integer not larger than 10 12 This allows us to define the beauty of a path Let u be an ancestor of v Then we define the beauty f u v as the greatest common divisor of the beauties of all vertices on the shortest path between u and v Formally if u t 1 t 2 t 3 dots t k v are the vertices on the shortest path between u and v then f u v gcd x t 1 x t 2 dots x t k Here gcd denotes the greatest common divisor of a set of numbers In particular f u u gcd x u x u Your task is to find the sum sum u text is an ancestor of v f u v As the result might be too large please output it modulo 10 9 7 Note that for each y gcd 0 y gcd y 0 y In particular gcd 0 0 0 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nconst int N = 100100;\nvector<int> g[N];\nvector<pli> a[N];\nint n;\nll x[N];\n\nvoid dfs(int v, int par) {\n\tif (par != -1) {\n\t\tfor (pli t : a[par]) {\n\t\t\tll y = gcd(t.first, x[v]);\n\t\t\tif (a[v].empty() || a[v].back().first != y) {\n\t\t\t\ta[v].push_back(mp(y, t.second));\n\t\t\t} else {\n\t\t\t\ta[v].back().second += t.second;\n\t\t\t}\n\t\t}\n\t}\n\tif (a[v].empty() || a[v].back().first != x[v]) {\n\t\ta[v].push_back(mp(x[v], 1));\n\t} else {\n\t\ta[v].back().second++;\n\t}\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tdfs(u, v);\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &x[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tll ans = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (pli t : a[v]) {\n\t\t\tans = (ans + t.first * t.second) % MOD;\n\t\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dp', 'graphs', 'math', 'number theory', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Kamil and Making a Stream.json,https://codeforces.com//blog/entry/70008,Let s prove the following observation To prove this observation consider the ancestors of in the order from the bottom most to top most Notice that Therefore each consecutive adds another value to the gcd of all numbers If a gcd of all numbers changes it must be a divisor of the previous gcd Therefore it s easy to see that it can change at most times We can now implement a depth first search If we invoke a recursive call in vertex we will receive the multiset of values We add all these values to the result and run the recursive calls in the children This is currently or but we can improve it by actually using a map from the distinct values in the multiset to the number of their occurrences Then each map will have no more than elements As we need to compute s throughout the algorithm this solution allows us to solve the problem in time and in memory It s also possible to solve the problem using jump pointers Each jump pointer will additionally hold the greatest common divisor of all the numbers we jump over when following the pointer 
https://codeforces.com//contest/200/problem/D,1453,D,200D,200,D. Programming Language,Recently Valery have come across an entirely new programming language Most of all the language attracted him with template functions and procedures Let us remind you that templates are tools of a language designed to encode generic algorithms without reference to some parameters e g data types buffer sizes default values Valery decided to examine template procedures in this language in more detail The description of a template procedure consists of the procedure name and the list of its parameter types The generic type parameters can be used as parameters of template procedures A procedure call consists of a procedure name and a list of variable parameters Let s call a procedure for this call if the following conditions are fulfilled its name equals to the name of the called procedure the number of its parameters equals to the number of parameters of the procedure call the types of variables in the procedure call match the corresponding types of its parameters The variable type matches the type of a parameter if the parameter has a generic type or the type of the variable and the parameter are the same You are given a description of some set of template procedures You are also given a list of variables used in the program as well as direct procedure calls that use the described variables For each call you need to count the number of procedures that are suitable for this call ,"['#include<stdio.h>\n#include<map>\n#include<vector>\n#include<string>\n#include<string.h>\n#include<utility>\nusing namespace std;\nmap<string,vector<vector<string> > > funcs;\nmap<string,string> type;\nchar s[1000];\nstring removeSp(char *s)\n{\n\tstring res;\n\tint l=strlen(s);\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(s[i]!=\' \')\n\t\t{\n\t\t\tres.push_back(s[i]);\n\t\t}\n\t}\n\treturn res;\n}\n\npair<string, vector<string> > parses(string s)\n{\n\tint idx=0;\n\tstring name="""";\n\tvector<string> types;\n\twhile(s[idx]!=\'(\')\n\t{\n\t\tname.push_back(s[idx]);\n\t\t++idx;\n\t}\n\t++idx;\n\twhile(s[idx]!=\')\')\n\t{\n\t\tstring type="""";\n\t\twhile(s[idx]!=\',\' && s[idx]!=\')\')\n\t\t{\n\t\t\ttype.push_back(s[idx]);\n\t\t\t++idx;\n\t\t}\n\t\ttypes.push_back(type);\n\t\tif(s[idx]!=\')\')++idx;\n\t}\n\treturn make_pair(name,types);\n}\n\nvoid parsetype(string s)\n{\n   string Type="""";\n   string var="""";\n   int idx=0;\n   int L=s.length();\n   while(s[idx]==\' \')++idx;\n   while(s[idx]!=\' \')\n   {\n\t   Type.push_back(s[idx]);\n\t   ++idx;\n   }\n   while(s[idx]==\' \')++idx;\n   while(idx!=L && s[idx]!=\' \')\n   {\n\t   var.push_back(s[idx]);\n\t   ++idx;\n   }\n   type[var]=Type;\n}\nbool match(string &s1,string &s2)\n{\n\treturn s1==s2 || s2==""T"";\n}\nbool matchV(vector<string> &V1,vector<string> &V2)\n{\n\tif(V1.size()!=V2.size())return false;\n\tfor(int i=0;i<V1.size();i++)\n\t{\n\t\tif(!match(type[V1[i]],V2[i]))return false;\n\t}\n\treturn true;\n}\nint calc (string name, vector<string> type)\n{\n\tvector<vector<string> > cur=funcs[name];\n\tint answ=0;\n\tfor(int i=0;i<cur.size();i++)\n\t{\n\t\tif(matchV(type,cur[i]))++answ;\n\t}\n\treturn answ;\n}\nint main()\n{\n  \n\tgets(s);\n\tint n;\n\tsscanf(s,""%d"",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tgets(s);\n\t\n\t\tstring rs=removeSp(s);\n\t\tpair<string,vector<string> > newt =parses(rs.substr(4));\n\t\tfuncs[newt.first].push_back(newt.second);\n\t}\n\n\tgets(s);\n\tint m;\n\tsscanf(s,""%d"",&m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tgets(s);\n\t\tparsetype(s);\n\t}\n\tint k;\n\tgets(s);\n\n\tsscanf(s,""%d"",&k);\n\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tgets(s);\n\t    string rs=removeSp(s);\n\t\tpair<string,vector<string> > newt =parses(rs);\n\t\tprintf(""%d\\n"",calc(newt.first,newt.second));\n\n\t}\n\n\n\n}']",,,"['binary search', 'brute force', 'expression parsing', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Programming Language.json,https://codeforces.com//blog/entry/4769,In this task were given the list of template functions Each function have its name and the list of types of arguments also it can be used universal type Also there were given set of variables and thier types and some queries Each query is function which has name and list of arguments For each query you had to find how many functions from the given list fit to the function from query There fit means that functions have the same name same number of arguments and types of all arguments also equal For solving this problem it is needed to implement comparing of functions Constrains gave the possibility to brute force function from the given list and check if the names and arguments of functions are equal 
https://codeforces.com//contest/459/problem/C,12586,C,459C,459,C. Pashmak and Buses,Recently Pashmak has been employed in a transportation company The company has buses and has a contract with a school which has students The school planned to take the students to different places for days each day in one place Each day the company provides all the buses for the trip Pashmak has to arrange the students in the buses He wants to arrange the students in a way that no two students become close friends In his ridiculous idea two students will become close friends if and only if they are in the same buses for all days Please help Pashmak with his weird idea Assume that each bus has an unlimited capacity ,"['#include<bits/stdc++.h>\n#define MAX   1111\n#define FOR(i,a,b) for (int i=(a);i<=(b);i=i+1)\n#define REP(i,n) for (int i=0;i<(n);i=i+1)\nint d,n,k;\nint res[MAX][MAX];\nint cur[MAX];\nvoid process(void) {\n    scanf(""%d%d%d"",&n,&k,&d);\n    FOR(i,1,d) cur[i]=1;\n    FOR(j,1,n) {\n        FOR(i,1,d) res[i][j]=cur[i];\n        if (j==n) break;\n        int t=d;\n        while (t>=1 && cur[t]==k) t--;\n        if (t<1) {\n            printf(""-1"");\n            return;\n        }\n        cur[t]++;\n        FOR(l,t+1,d) cur[l]=1;\n    }\n    FOR(i,1,d) FOR(j,1,n) {\n        printf(""%d"",res[i][j]);\n        if (j<n) printf("" ""); else printf(""\\n"");\n    }\n}\nint main(void) {\n    process();\n    return 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Pashmak and Buses.json,https://codeforces.com//blog/entry/13430,For each student consider a sequence of elements from to that shows the bus number which is taken by this student on each day Obviously there are different sequence at all so if pigeonhole principle indicates that at least two of this sequences will be equal so that two students will become close friends and no solutions exist But if then we can assign a unique sequence to each student and compute the answer For computing that we can find the first digits numbers in based numbers Total complexity Sample solutions 7495236 
https://codeforces.com//contest/1418/problem/D,727426,D,1418D,1418,D. Trash Problem,Vova decided to clean his room The room can be represented as the coordinate axis OX There are n piles of trash in the room coordinate of the i th pile is the integer p i All piles have coordinates Let s define a as the following process The goal of this process is to collect the piles in different x coordinates To achieve this goal Vova can do several possibly zero moves During one move he can choose some x and move from x to x 1 or x 1 using his broom Note that he can t choose how many piles he will move Also there are two types of queries 0 x remove a pile of trash from the coordinate x It is guaranteed that there is a pile in the coordinate x at this moment 1 x add a pile of trash to the coordinate x It is guaranteed that there is no pile in the coordinate x at this moment Note that it is possible that there are zero piles of trash in the room at some moment Vova wants to know the number of moves he can spend if he wants to do a before any queries He also wants to know this number of moves after applying each query Queries are applied in the given order Note that the doesn t actually happen and doesn t change the state of piles It is only used to calculate the number of moves For better understanding please read the section below to see an explanation for the first example ,"['#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar(\'-\'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nconst int N=100005;\nint n,q;\nset<int>S;\nmultiset<int>T;\nvoid insert(int x){\n\tauto it=S.insert(x).fi;\n\tauto pre=it,nxt=it;\n\tif(it!=S.begin())--pre;\n\tif(it!=--S.end())++nxt;\n\tif(it!=S.begin()){\n\t\tT.insert(*it-*pre);\n\t}\n\tif(it!=--S.end()){\n\t\tT.insert(*nxt-*it);\n\t}\n\tif(it!=S.begin()&&it!=--S.end()){\n\t\tT.erase(T.find(*nxt-*pre));\n\t}\n}\nvoid erase(int x){\n\tauto it=S.lower_bound(x);\n\tauto pre=it,nxt=it;\n\tif(it!=S.begin())--pre;\n\tif(it!=--S.end())++nxt;\n\tif(it!=S.begin()){\n\t\tT.erase(T.find(*it-*pre));\n\t}\n\tif(it!=--S.end()){\n\t\tT.erase(T.find(*nxt-*it));\n\t}\n\tif(it!=S.begin()&&it!=--S.end()){\n\t\tT.insert(*nxt-*pre);\n\t}\n\tS.erase(it);\n}\nsigned main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\trd(n),rd(q);\n\trep(i,1,n){\n\t\tint x;rd(x);\n\t\tinsert(x);\n\t}\n\trep(_,0,q){\n\t\tif(_){\n\t\t\tint o,x;rd(o),rd(x);\n\t\t\tif(o==0){\n\t\t\t\terase(x);\n\t\t\t}else{\n\t\t\t\tinsert(x);\n\t\t\t}\n\t\t}\n\t\tif(SZ(S)<=2){\n\t\t\tputs(""0"");\n\t\t}else{\n\t\t\tpt(*--S.end()-*S.begin()-*--T.end(),\'\\n\');\n\t\t}\n\t}\n\treturn 0;\n}\n\n']",,,"['data structures', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Trash Problem.json,https://codeforces.com//blog/entry/82673,First let s understand that if we choose some subset of points then it does not matter to which point we move it inside the segment because the minimum number of moves will always be the same and it is equal to Okay we need to split all points into two subsets and collect all points of the first subset in some point inside it and the same with the second subset What can we notice If we sort the points it s always optimal to choose these subsets as segments I e if the maximum point of the first subset is the minimum point of the second subset is and we can swap them and decrease answers for both subsets So we need to cover all the points with two segments with the minimum total length What is this length It is is the maximum distance between two consecutive points i e So we can solve the problem in without queries But how to deal with queries Let s maintain the set which contains all points and the multiset set with repetitions that maintains all gaps between two adjacent points So the answer is maximum in the set of points minus minimum in the set of points minus maximum in the multiset of lengths How do we recalculate these sets between queries If some point is removed let s find the maximum point less than let it be and the minimum point greater than let it be in the current set of points Both these points can be found in a logarithmic time Then we need to remove with from the multiset and add to the multiset and of course remove from the set If some point is added then we need to remove from the multiset and add with to the multiset and add to the set So we can process every query in time and the total time complexity is 
https://codeforces.com//contest/1332/problem/A,578661,A,1332A,1332,A. Exercising Walk,Alice has a cute cat To keep her cat fit Alice wants to design an exercising walk for her cat Initially Alice s cat is located in a cell x y of an infinite grid According to Alice s theory cat needs to move exactly a steps left from u v to u 1 v exactly b steps right from u v to u 1 v exactly c steps down from u v to u v 1 exactly d steps up from u v to u v 1 Note that the moves can be performed in an For example if the cat has to move 1 step left 3 steps right and 2 steps down then the walk right down left right right down is valid Alice however is worrying that her cat might get lost if it moves far away from her So she hopes that her cat is in the area x 1 x 2 times y 1 y 2 i e for every cat s position u v of a walk x 1 le u le x 2 and y 1 le v le y 2 holds Also note that the cat can visit the same cell multiple times Can you help Alice find out if there exists a walk satisfying her wishes Formally the walk should contain exactly a b c d unit moves a to the left b to the right c to the down d to the up Alice can do the moves in order Her current position u v should satisfy the constraints x 1 le u le x 2 y 1 le v le y 2 The staring point is x y You are required to answer t test cases ,"['#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < \'0\' || c > \'9\') && c != \'-\');\n\tif (c == \'-\') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= \'0\' && c <= \'9\')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\nint main()\n{\n\tint T; read(T);\n\twhile (T--)\n\t{\n\t\tint a, b, c, d, X, Y, xl, yl, xr, yr;\n\t\tread(a); read(b); read(c); read(d); read(X); read(Y); read(xl); read(yl);\n\t\tread(xr); read(yr);\n\t\tif (xl == xr && (a || b)) {puts(""no""); continue;}\n\t\tif (yl == yr && (c || d)) {puts(""no""); continue;}\n\t\tX += b - a; Y += d - c;\n\t\tputs(xl <= X && X <= xr && yl <= Y && Y <= yr ? ""yes"" : ""no"");\n\t}\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Exercising Walk.json,https://codeforces.com//blog/entry/75432,The key observation is x axis and y axis is independent in this task as the area is a rectangle Therefore we should only consider 1D case x axis for example The optimal path to choose alternates between right and left moves until only one type of move is possible And sometimes there is no place to make even one move which has to handled separately So the verdict is if and only if and or 
https://codeforces.com//contest/1716/problem/A,1494200,A,1716A,1716,A. 2-3 Moves,You are standing at the point 0 on a coordinate line Your goal is to reach the point n In one minute you can move by 2 or by 3 to the left or to the right i e if your current coordinate is x it can become x 3 x 2 x 2 or x 3 Note that the new coordinate can become negative Your task is to find the number of minutes required to get from the point 0 to the point n You have to answer t independent test cases ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tif (x == 1)\n\t\t\tprintf(""2\\n"");\n\t\telse\n\t\t\tprintf(""%d\\n"", (x + 2) / 3);\n\t}\n\n\treturn 0;\n}\n']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. 2-3 Moves.json,https://codeforces.com//blog/entry/105653,If the answer is we can t get so we can move by to the right and by to the left If or the answer is obviously Otherwise the answer is always We can t get the answer less than this value because we need at least moves to get to the point greater than or equal to and we can always get this answer by the recurrence 
https://codeforces.com//contest/1521/problem/D,977646,D,1521D,1521,D. Nastia Plays with a Tree,The girl will perform the following operation with her tree as long as she needs Remove any existing edge Add an edge between any pair of vertices What is the number of operations Nastia needs to get a bamboo from a tree A bamboo is a tree in which no node has a degree greater than 2 ,"['#include <bits/stdc++.h>\n \n#define int long long\n \n#define ext exit(0)\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define data data228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << "": "" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n \nconst int maxn = 3e5 + 7, mod = 1e9 + 7, MAXN = 2e6 + 7;\nconst double eps = 1e-9;                                        \nconst ll INF = 1e18, inf = 1e15;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());                       \nint n; \nvector<int> gr[maxn]; \nint dp[maxn][2]; \nint PR[maxn]; \n \nvoid dfs(int u, int pr) {\n    PR[u] = pr; \n    vector<int> vertex; \n    for (auto v : gr[u]) {\n        if (v == pr) continue; \n        dfs(v, u); \n        vertex.pb(v); \n    }\n    dp[u][0] = inf; \n    {\n        int cur = 0; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n        }\n        dp[u][0] = cur + 1; \n    }\n \n    {\n        int cur = 0; \n        vector<pii> type; \n        bool ok = false; \n        int mn = inf; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            if (dp[x][0] <= dp[x][1]) {\n                ok = true; \n            } else {\n                mn = min(mn, dp[x][0] - dp[x][1]); \n            }\n        }\n        if (ok) {\n            dp[u][0] = min(dp[u][0], cur); \n        } else {\n            dp[u][0] = min(dp[u][0], cur + mn); \n        }                      \n    }\n \n \n    dp[u][1] = inf; \n    if ((int)vertex.size() < 2) return; \n    {\n        int cur = 0; \n        vector<int> change; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            change.pb(max(0ll, dp[x][0] - dp[x][1])); \n        }\n        sort(all(change)); \n        cur += change[0]; \n        cur += change[1]; \n        dp[u][1] = cur - 1;             \n    }\n}\n \nint color[maxn]; \nint pt = 0; \n \nvoid solve(int u, int type, int cl) {\n    vector<int> vertex; \n    for (auto v : gr[u]) {\n        if (v == PR[u]) continue; \n        vertex.pb(v); \n    }\n    color[u] = cl; \n    if (type == 0) {\n        {\n \n        int cur = 0; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n        }\n        if (dp[u][0] == cur + 1) {\n            for (auto x : vertex) {\n                if (dp[x][0] < dp[x][1]) {\n                    ++pt; \n                    solve(x, 0, pt); \n                } else {\n                    ++pt; \n                    solve(x, 1, pt); \n                }\n            }                   \n            return; \n        }\n \n        }\n \n        /////////////////////////////////////////////////////////////////////////////////\n        {\n \n        int cur = 0; \n        vector<pii> type; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            type.pb({max(0ll, dp[x][0] - dp[x][1]), x}); \n        }\n        sort(all(type)); \n \n        solve(type[0].ss, 0, cl); \n        for (auto x : vertex) {\n            if (x == type[0].ss) continue;\n            if (dp[x][0] < dp[x][1]) {\n                ++pt; \n                solve(x, 0, pt); \n            } else {\n                ++pt; \n                solve(x, 1, pt); \n            }\n        }\n        return; \n        }\n        return;                    \n    }\n \n    int cur = 0; \n    vector<pii> change; \n    for (auto x : vertex) {\n        cur += min(dp[x][0], dp[x][1]); \n        change.pb({max(0ll, dp[x][0] - dp[x][1]), x}); \n    }\n    sort(all(change)); \n    int v1 = change[0].ss; \n    int v2 = change[1].ss; \n    solve(v1, 0, cl); \n    solve(v2, 0, cl); \n    for (auto x : vertex) {\n        if (x == v1 || x == v2) continue; \n        if (dp[x][0] > dp[x][1]) {  \n            ++pt; \n            solve(x, 1, pt); \n        } else {\n            ++pt; \n            solve(x, 0, pt); \n        }\n    }\n}\n \nvector<int> start[maxn]; \n \nvoid solve() {\n    cin >> n; \n    for (int i = 0; i < n; ++i) {\n        gr[i].clear(); \n        start[i].clear(); \n        PR[i] = -1; \n        dp[i][0] = dp[i][1] = inf; \n    }\n    vector<pii> e; \n    for (int i = 0; i < n - 1; ++i) {\n        int a, b; cin >> a >> b, --a, --b; \n        gr[a].pb(b); \n        gr[b].pb(a); \n        e.pb({a, b}); \n    }\n    dfs(0, 0); \n    cout << min(dp[0][0], dp[0][1]) - 1 << \'\\n\'; \n    pt = 0; \n    if (dp[0][0] < dp[0][1]) {\n        solve(0, 0, 0); \n    } else {\n        solve(0, 1, 0); \n    }\n    vector<pii> del; \n    for (auto v : e) {\n        if (color[v.ff] != color[v.ss]) {\n            del.pb(v); \n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        int bad = 0; \n        for (auto v : gr[i]) {\n            if (color[i] == color[v]) {\n                ++bad; \n            }\n        } \n        if (bad <= 1) {\n            start[color[i]].pb(i);                        \n        }\n    }\n    for (int i = 0; i <= pt; ++i) {\n        if (start[i].size() == 1) {\n            start[i].pb(start[i][0]);         \n        }                \n    }         \n    vector<pii> ms; \n    for (int i = 0; i <= pt; ++i) ms.pb({start[i][0], start[i][1]}); \n    int lst = ms[0].ss; \n    for (int i = 1; i < (int)ms.size(); ++i) {\n        pii x = del.back(); \n        del.pop_back(); \n        cout << x.ff + 1 << "" "" << x.ss + 1 << "" ""; \n        cout << lst + 1 << "" "" << ms[i].ff + 1 << \'\\n\'; \n        lst = ms[i].ss; \n    }\n}                                \n \nsigned main() {          \n#ifdef LOCAL\n    freopen(""TASK.in"", ""r"", stdin);\n    freopen(""TASK.out"", ""w"", stdout);\n#endif // LOCAL                                                                             \n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; cin >> t; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  ']",,,"['constructive algorithms', 'data structures', 'dfs and similar', 'dp', 'dsu', 'greedy', 'implementation', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Nastia Plays with a Tree.json,https://codeforces.com//blog/entry/90477,Let s define the variable as a minimum number of operations that we need to get bamboo from a tree Let s remove edges first and then add new ones to the graph Consider the structure of the graph after removing edges This is a with a connected components Easy to notice each of the connected components in the getting forest of trees to get the bamboo after adding new edges Thus we can get the bamboo from the forest of bamboo after removing edges by times adding the conjunction between leaves that are in the different components of connectivity of the forest So the task is to find the minimum number of the removing edges needs to get the forest of bamboos Here works the following greedy Let s define any vertice of the tree as a root We will solve the problem for each of the subtrees First solve the problem for all child vertices of Then define the value as the number of the children and the value as the ancestor for vertex There are cases If then we don t remove anything If then we remove the edge if exists If then we remove the edge if exists and any existing edges from to one of the children vertex Take a look at the picture 
https://codeforces.com//contest/1586/problem/G,1147387,G,1586G,1586,G. Omkar and Time Travel,Omkar is watching In Okabe Rintarou needs to complete n tasks 1 leq n leq 2 cdot 10 5 Unfortunately he doesn t know when he needs to complete the tasks Initially the time is 0 Time travel will now happen according to the following rules For each k 1 2 ldots n Okabe will realize at time b k that he was supposed to complete the k th task at time a k a k b k When he realizes this if k th task was already completed at time a k Okabe keeps the usual flow of time Otherwise he time travels to time a k then immediately completes the task If Okabe time travels to time a k all tasks completed after this time will become incomplete again That is for every j if a j a k the j th task will become incomplete if it was complete if it was incomplete nothing will change Okabe has bad memory so he can time travel to time a k getting to time b k and learning that he was supposed to complete the k th task at time a k That is even if Okabe already had to perform k th task before he wouldn t remember it before stumbling on the info about this task at time b k again Please refer to the notes for an example of time travelling There is a certain set s of tasks such that the first moment that all of the tasks in s are simultaneously completed regardless of whether any other tasks are currently completed a funny scene will take place Omkar loves this scene and wants to know how many times Okabe will time travel before this scene takes place Find this number modulo 10 9 7 It can be proven that eventually all n tasks will be completed and so the answer always exists ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nstruct fwt\n{\n\tint dat[400005];\n\tvoid add(int id, int val)\n\t{\n\t\tfor(; id > 0; id -= id & -id) dat[id] = (dat[id] + val) % MOD;\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\tfor(; id <= 400000; id += id & -id) ret = (ret + dat[id]) % MOD;\n\t\treturn ret;\n\t}\n}tre;\nint n, t, b[200005], dp[200005];\nPII dat[200005];\nbool nd[200005];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) {\n\t\tscanf(""%d%d"", &dat[i].second, &dat[i].first); b[i] = dat[i].first;\n\t}\n\tsort(dat, dat + n);\n\tscanf(""%d"", &t);\n\trep(i, t) {\n\t\tint x; scanf(""%d"", &x);\n\t\tnd[lower_bound(dat, dat + n, MP(b[x - 1], 0)) - dat] = true;\n\t}\n\t\n\ttre.add(2 * n, 1);\n\trep(i, n) {\n\t\tdp[i] = tre.query(dat[i].second);\n\t\ttre.add(dat[i].second, dp[i]);\n\t}\n\t\n\tint pv = 1, ans = 0;\n\tfor(int i = n - 1; i >= 0; i --) {\n\t\ttre.add(dat[i].second, (MOD - dp[i]) % MOD);\n\t\tif(nd[i] && dat[i].second >= pv) {\n\t\t\tans = (ans + tre.query(pv)) % MOD;\n\t\t\tpv = dat[i].second;\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']",,,"['data structures', 'dp', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Omkar and Time Travel.json,https://codeforces.com//blog/entry/96072,Each time travel that Okabe performs creates a new set of completed tasks We will take this as given but it can be proven using ideas from the rest of the proof It thus suffices to count the number of distinct sets of task that come before the first one that contains as a subset We should first figure out what kinds of sets will ever appear as a set of completed tasks at all we will call these sets valid We will represent tasks below as intervals First note that clearly not all sets are valid If you have the intervals and clearly the set is not a valid set You can actually see that the same is true for the intervals and is not a valid set by working through Okabe s activities This generalizes in a very important way if there are two intervals and with and then any valid set that contains must also contain This is because if is reached to complete the task then will already have been reached to complete the task since and any time travel that undoes must also undo since The above property is actually equivalent to being a valid set we have already seen that it is necessary and from the next part of the tutorial we will have way to prove that it is sufficient but you should have some intuition for why this is true In order to solve the problem we want to think about how to determine given two valid sets which one Okabe will encounter first First for any two valid sets consider their last interval i e interval with greatest value of If these are different then the one with largest interval having greater will come later This is because for any valid set the largest value of in any interval in that set is equal to the largest value of that Okabe has ever encountered You can see this by noticing that the only way to undo a task is to perform a task with greater value of any task with smaller is either contained inside the first task in which case it won t undo it or also has a smaller value of in which case by the above property of valid sets it must already be completed Since the maximum value of that Okabe has ever encountered will only get larger as his activities continue it follows that the valid set with larger maximum value of must occur later We can further see that for any two valid sets where the interval with largest is equal we can discard that interval and consider the next largest interval from both valid sets This gives us an ordering of the valid sets We can prove that the aformentioned property is sufficient for being a valid set by showing that at any valid set the next valid set encountered is the immediately next one in the ordering The details are left to the reader In order to use this to finally solve the problem it is useful to represent valid sets in a different way Specifically we can represent a valid set as the set of intervals that aren t implied to be in by any other element of By thinking about the above property you can see that is actually a set of recursively containing intervals i e it contains an interval then another interval inside that one then another interval inside one etc We will consider the above representation to be ordered so that the last interval is the one that contains all the others and the first interval is the one inside of all the others We can now solve the problem For the given set first determine its above representation this can be done easily using sorting discarding any redundant interval The valid sets also in their above representation that come before are thus the ones that excluding their common suffix with have a last interval whose is smaller than the for the last interval in excluding the common suffix We can therefore solve this as follows We will count the number of above sets for each possible common suffix For each suffix let the last interval in not included in the suffix be and let the first interval in the suffix be The amount of sets for this suffix is equal to the amount of recursively containing sets that have a largest interval that is contained in whose value of is less than the value of for We can compute this follows We will maintain a range sum query data structure such as binary index tree The data structure will have at each the number of recursively containing subsets whose largest interval is the one with that once that interval has been processed We will process the intervals in increasing order of For each interval to put it into the data structure we can simply perform a range query of literally the interval and add to the result That will be equal to the number of recursively containing sets with as the largest interval so we simply insert that into the data structure at the value of of Before putting into the data structure if it is in the representation of then we can find the answer for the suffix of that contains all intervals to the right of as follows Since the intervals currently in the data structure are precisely the ones with value of less than the answer for that suffix is simply the range query of where is the immediately next interval after in We therefore perform this range query then add it to our answer Note that all of this computation doesn t count itself but it does count the empty set which doesn t need to be counted so our answer is correct The runtime of this solution is 
https://codeforces.com//contest/2040/problem/F,3075500,F,2040F,2040,F. Number of Cubes,Consider a rectangular parallelepiped with sides a b and c that consists of unit cubes of k different colors We can apply cyclic shifts to the parallelepiped in any of the three directions any number of times text There are d i cubes of the i th color 1 le i le k How many different parallelepipeds with the given sides can be formed from these cubes no two of which can be made equal by some combination of cyclic shifts text On the image Top left shows the top view of the original parallelepiped Lower layers will shift in the same way as the top layer Top right shows the top view of a parallelepiped shifted to the right by 1 Bottom left shows the top view of a parallelepiped shifted down by 2 Bottom right shows the top view of a parallelepiped shifted to the right by 1 and down by 2 ,"['#include <bits/stdc++.h>using namespace std;\xa0using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>;\xa0constexpr int INF = 1000000000;constexpr ll LINF = 1000000000000000000LL;constexpr ld EPS = 1e-9;\xa0#ifdef MOD#undef MOD#endifconstexpr int MOD = 998244353;\xa0#define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define sz(x) ((int)(x).size())#define pb push_back#define fi first#define se second\xa0static const int MAXN = 3000000;static ll fact[MAXN+1], invfact[MAXN+1];static int phi_arr[MAXN+1];\xa0inline ll modexp(ll base, ll exp) {    ll res = 1 % MOD, cur = base % MOD;    while (exp > 0) {        if (exp & 1) res = (res * cur) % MOD;        cur = (cur * cur) % MOD;        exp >>= 1;    }    return res;}\xa0inline void precompute_factorials(int n) {    fact[0] = 1;    for (int i = 1; i <= n; i++) fact[i] = fact[i-1]*i % MOD;    invfact[n] = modexp(fact[n], MOD-2);    for (int i = n-1; i >= 0; i--) invfact[i] = invfact[i+1]*(i+1)%MOD;}\xa0inline void precompute_phi(int n) {    for (int i = 1; i <= n; i++) phi_arr[i] = i;    for (int i = 2; i <= n; i++) {        if (phi_arr[i] == i) {            for (int j = i; j <= n; j += i) {                phi_arr[j] -= phi_arr[j]/i;            }        }    }}\xa0inline ll ways_from_counts(const vi &counts) {    int M = 0; for (auto &x: counts) M += x;    ll ans = fact[M];    for (auto &x: counts) ans = (ans * invfact[x]) % MOD;    return ans;}\xa0inline vi get_divisors(int x) {    vi divs;    for (int i = 1; i*i <= x; i++) {        if (x % i == 0) {            divs.pb(i);            if (i*i != x) divs.pb(x/i);        }    }    return divs;}\xa0inline int lcm_int(int x, int y) {return (int)((ll)x / __gcd(x,y) * (ll)y);}\xa0void solve() {    int a,b,c,k; cin >> a >> b >> c >> k;    vi d(k);    for (int i = 0; i < k; i++) cin >> d[i];\xa0    ll abc = (ll)a*b*c;    vector<ll> countArr(abc+1, 0);\xa0    vi divA = get_divisors(a), divB = get_divisors(b), divC = get_divisors(c);\xa0    for (auto X: divA) {        int phiX = phi_arr[X];        for (auto Y: divB) {            int phiY = phi_arr[Y];            int L = lcm_int(X,Y);            for (auto Z: divC) {                int phiZ = phi_arr[Z];                int L2 = lcm_int(L,Z);                countArr[L2] += (ll)phiX * phiY * phiZ;            }        }    }\xa0    ll ans = 0;    for (int tt = 1; tt <= (int)abc; tt++) {        if (countArr[tt] == 0) continue;        bool divisible = true;        for (auto &x: d) {            if (x % tt != 0) { divisible = false; break; }        }        if (!divisible) continue;        int M = (int)(abc/tt);        vi div_counts(k);        for (int i = 0; i < k; i++) div_counts[i] = d[i]/tt;        ll w = ways_from_counts(div_counts);        ll addVal = (w * (countArr[tt] % MOD)) % MOD;        ans = (ans + addVal) % MOD;    }\xa0    ll inv_abc = modexp(abc, MOD-2);    ans = (ans * inv_abc) % MOD;\xa0    cout << ans << ""\\n"";}\xa0int main() {    fast_io();    int t; cin >> t;    precompute_factorials(MAXN);    precompute_phi(MAXN);    while (t--) solve();    return 0;}']",,,"['combinatorics', 'dp', 'math', 'number theory']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Number of Cubes.json,https://codeforces.com//blog/entry/137074,Recall Burnside s lemma the number of elements up to an action group is where if and if Let s try to iterate over the elements of the action group all triplets of numbers When applying a fixed action the element moves to this vector Let s choose a cell and add a vector to it until we reach it again We have drawn a cycle all cells on it must be of the same type An example of such a traversal for each different number in the table corresponds to a cycle 123123123456456456123123123456456456 You can count the cycles by traversal or you can derive formula the length of all cycles is the same and equals What s good about the equal lengths of the cycles Because the formula for calculating the number of stationary parallelepipeds is simple First all must be divisible by Then we distribute them among the cycles This is the multinomial coefficient for Current total time iterated over vector triplets calculated checked divisibility for all numbers and if successful calculated the multinomial coefficient of size Let s speed up the solution Let s calculate Since all are divisible by then is also divisible by There are no more different than the number of divisors of Let s calculate the number of triplets that give each value of and at the end we will calculate the multinomial coefficient for all identical values of at once The total time is where is the number of divisors of and appears due to the calculation of Let s continue to speed up the solution There are two solutions further Solution 1 Let s look again at the formula For convenience we will focus on the first element Let s say we want the first element to be Then is divisible by and is divisible by so is divisible by Then the possible are of the form where and the equality is exactly satisfied is coprime to otherwise the value of will be multiplied by their common divisor and the equality will be violated Therefore the number of suitable is equal to where Euler s function So let s enumerate triplets of divisors of and The number of ways to obtain a triple is equal to Let s calculate using the Sieve of Eratosthenes We get a solution in and for pre calculation Solution 2 Let s calculate the same using dynamic programming For convenience we denote the dimensions of and by the array Let be the number of ways having passed dimensions to obtain equal to The transitions will be as follows we will iterate over the pairs of the previous and the next divisor of the size of the next dimension Then the new will be equal to and we make the transition where the number of such that How to calculate the array We cannot calculate it trivially in since it is too long time For simplicity we calculate the array equal to the number of such that We iterate over the divisors of in ascending order Let the current divisor be Add to since that many will be divisible by Those that are divisible by but are not equal to it we will subtract later We iterate over the divisors of We subtract from since their is actually not but or a number that divides Let s calculate If we pre calculate the divisors of all numbers and compress their coordinates we get a solution in 
https://codeforces.com//contest/1333/problem/D,586756,D,1333D,1333,D. Challenges in school №41,There are n children who study at the school 41 It is well known that they are good mathematicians Once at a break they arranged a challenge for themselves All children arranged in a row and turned heads either to the left or to the right Children can do the following in one second several pairs of neighboring children who are can turn the head in the opposite direction For instance the one who was looking at the right neighbor turns left and vice versa for the second child Moreover every second pair of neighboring children performs such action They are going to finish when there is no pair of neighboring children who are looking at each other You are given the number n the initial arrangement of children and the number k You have to find a way for the children to act if they want to finish the process in exactly k seconds More formally for each of the k moves you need to output the numbers of the children who turn left during this move For instance for the configuration shown below and k 2 children can do the following steps At the beginning two pairs make move 1 2 and 3 4 After that we receive the following configuration At the second move pair 2 3 makes the move The final configuration is reached Good job It is guaranteed that if the solution exists it takes not more than n 2 headturns ,"['#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nusing ll = long long;\nint const nmax = 3000;\nchar v[1 + nmax];\n\nvector<int> processlevel(int n){\n  vector<int> sol;\n  for(int i = 1;i < n; i++)\n    if(v[i] == \'R\' && v[i + 1] == \'L\')\n      sol.push_back(i);\n  for(int i = 0; i < sol.size(); i++)\n    swap(v[sol[i]], v[sol[i] + 1]);\n  return sol;\n}\n\nint main()\n{\n  int n, k;\n  cin >> n >> k;\n  for(int i = 1;i <= n; i++)\n    cin >> v[i];\n  vector<vector<int>> solbig;\n  int movesmax = 0;\n  while(true){\n    vector<int> sol = processlevel(n);\n    if(sol.size() == 0)\n      break;\n    movesmax += sol.size();\n    solbig.push_back(sol);\n  }\n  if(k < solbig.size() || movesmax < k){\n    cout << -1;\n    return 0;\n  }\n  int ptr = 0, movesmin = solbig.size();\n\n  while(movesmin < k){\n    if(solbig[ptr].size() == 0) {\n      ptr++;\n      movesmin--;\n    }\n    cout << 1 << "" "" << solbig[ptr].back() << \'\\n\';\n    solbig[ptr].pop_back();\n    k--;\n    if(solbig[ptr].size() == 0) {\n      ptr++;\n      movesmin--;\n    }\n  }\n\n  for(int i = ptr; i < solbig.size(); i++){\n    cout << solbig[i].size() << "" "";\n    for(int j = 0; j < solbig[i].size(); j++)\n      cout << solbig[i][j] << "" "";\n    cout << \'\\n\';\n  }\n\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'games', 'graphs', 'greedy', 'implementation', 'sortings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Challenges in school №41.json,https://codeforces.com//blog/entry/75802,If solution exist let s count the minimum and maximum bounds for for initial arrangement of children A minimum achieved all possible pairs of children turn theirs heads at every step The maximum reached if only one of possible pairs of children turn theirs heads at every step This values is easy to count I ll leave it to you If from the statement not fit within our bounds then we need to print Otherwise solution exist and we need to construct them For each next move we can use all pairs of children to turn theirs heads decrease by 1 and recalculate maximum bound lets call it on just decrease them on the number of pairs used If after moving new value of fits in the bound then we proceed to the next iteration Otherwise we roll back to the previous iteration and use pairs in this move Number of remaining moves will be and upper bound will be And from that moment just use only one pair in one move to the end of the process to find one of the pair quickly we need to store them in the queue Final time complexity 
https://codeforces.com//contest/1739/problem/D,1559866,D,1739D,1739,D. Reset K Edges,You are given a rooted tree consisting of n vertices The vertices are numbered from 1 to n the root is the vertex 1 You can perform the following operation k times choose an edge v u of the tree such that v is a parent of u remove the edge v u add an edge 1 u i e make u with its subtree a child of the root of a tree is the maximum depth of its vertices and the depth of a vertex is the number of edges on the path from the root to it For example the depth of vertex 1 is 0 since it s the root and the depth of all its children is 1 What s the smallest height of the tree that can be achieved ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include ""library/debug.cpp""\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n, k;\n        cin >> n >> k;\n        vector<vector<int>> g(n);\n        for (int i = 1; i < n; i++) {\n            int j;\n            cin >> j;\n            j--;\n            g[j].emplace_back(i);\n        }\n        int low = 0, high = n;\n        while (high - low > 1) {\n            int mid = (high + low) >> 1;\n            int need = 0;\n            function<int(int, int)> Dfs = [&](int v, int p) {\n                int a = 0;\n                for (int to : g[v]) {\n                    a = max(a, Dfs(to, v));\n                }\n                a++;\n                if (v != 0 && p != 0 && a >= mid) {\n                    need++;\n                    return 0;\n                }\n                return a;\n            };\n            Dfs(0, -1);\n            if (need <= k) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        cout << high << \'\\n\';\n    }\n    return 0;\n}']",,,"['binary search', 'data structures', 'dfs and similar', 'graphs', 'greedy', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Reset K Edges.json,https://codeforces.com//blog/entry/107461,Start with the following Let s look at the input format and consider what the operation actually does to it Since it only changes the parent of some vertex it modifies only one value in it Moreover it just assigns it to Thus the goal is to assign at most values of parents to to minimize the resulting height of the tree In particular that implies that we can freely rearrange the operations since the assignments don t depend on each other One more conclusion Imagine we have already built some answer One by one we moved some subtrees to be children of the root It could happen that we first moved some subtree of a vertex and then applied the operation to an edge inside the subtree of Let s show that it s always possible to rearrange the operations in the answer to avoid that Just apply the operations in order of decreasing the depth of the vertex If we knew what height we want to get we could have been making sure that cut subtree has height at most since it gets increased by when glueing it to the root then pretending that that subtree doesn t exist anymore Moreover it s always required to cut subtrees with height at most If you cut a higher subtree then the answer can t be smaller than since we rearranged the operation to not touch that subtree anymore Well let s fix that height if we wanted that Let s try the solve the opposite problem How many operations will it require to make the tree height at most Obviously the values for this problem are non increasing the greater we allow the height to be the less operations it will require Thus we will be able to apply binary search to it to find the smallest height we can achieve with at most operations Now we want to be choosing the subtrees of height at most repeatedly and cutting them off until the height of the tree becomes at most Let s think greedily If the height of the tree is not at most yet then there exists a vertex with the depth greater than Let s look at the deepest of them That leaf has to be cut in some subtree Otherwise the tree won t become any less higher What subtree is the best for it What options do we have That vertex itself and all its parents up until above It s always optimal to cut the highest of them the st parent since it will remove at least all the vertices of any other cut and some other vertices along with them It s also always possible to remove the st parent since it will always have height exactly The vertex we are looking at is the deepest in the entire tree there are no deeper vertices in the subtree of the st parent Thus the strategy is to keep cutting the st parent of the deepest vertex until the tree becomes at most height Now about the implementation details First we can process the vertices from the deepest upwards in their order in the original tree The operation only removes some vertices but doesn t change the depth of the remaining ones For example you can do a bfs from the root to find the order Now the st parent Let s find it for each vertex before starting the process Run a dfs and maintain the stack of the ascendants When going down the child append it to the stack What exiting pop from the stack Now you can just look at the st element from the top of the stack To be able to do that simulate the stack with a vector C or a list Python Finally we would have to determine if the current vertex in the order is removed or not For that we could maintain a boolean array for the removed vertices Once you apply the operation run the dfs from the removed vertex and mark all the newly removed descendants of it in If you don t go into already marked vertices there will be no more than calls of the dfs The number of cut vertices is the answer for the fixed height Overall complexity per testcase 
https://codeforces.com//contest/1366/problem/A,646799,A,1366A,1366,A. Shovels and Swords,Polycarp plays a well known computer game we won t mention its name In this game he can craft tools of two types shovels and swords To craft a shovel Polycarp spends two sticks and one diamond to craft a sword Polycarp spends two diamonds and one stick Each tool can be sold for exactly one emerald How many emeralds can Polycarp earn if he has a sticks and b diamonds ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tlong long a, b;\n\tcin >> a >> b;\n\tlong long ans = (a + b) / 3;\n\tans = min(ans, min(a, b));\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]",,,"['binary search', 'greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Shovels and Swords.json,https://codeforces.com//blog/entry/78735,There are three constraints on the number of emeralds the number of emeralds can t be greater than the number of emeralds can t be greater than the number of emeralds can t be greater than So the answer is 
https://codeforces.com//contest/1370/problem/D,652386,D,1370D,1370,D. Odd-Even Subsequence,Ashish has an array a of size n A subsequence of a is defined as a sequence that can be obtained from a by deleting some elements possibly none without changing the order of the remaining elements Consider a subsequence s of a He defines the cost of s as the minimum between The maximum among all elements at odd indices of s The maximum among all elements at even indices of s Note that the index of an element is its index in s rather than its index in a The positions are numbered from 1 So the cost of s is equal to min max s 1 s 3 s 5 ldots max s 2 s 4 s 6 ldots For example the cost of 7 5 6 is min max 7 6 max 5 min 7 5 5 Help him find the minimum cost of a subsequence of size k ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint const maxn = 2e5 + 5;\nint a[maxn], good[maxn], pref[maxn], suff[maxn];\npair < int, int > b[maxn];\n\ninline int oks(int n, int k, int x) {\n    for (int i = 1; i <= n; ++i) good[i] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (b[i].first <= x) good[b[i].second] = 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        if (good[i]) {\n            pref[i] = max(pref[i], 1);\n            if (i >= 2) pref[i] = max(pref[i], pref[i - 2] + 2);\n        }\n    }\n    for (int i = n; i >= 1; --i) {\n        suff[i] = suff[i + 1];\n        if (good[i]) {\n            suff[i] = max(suff[i], 1);\n            if (i + 1 <= n) suff[i] = max(suff[i], suff[i + 2] + 2);\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] >= x) {\n            if (pref[i - 1] + 1 + suff[i + 1] >= k) return 1;\n        }\n    }\n    return 0;\n}\n\nmain() {\n    //freopen(""input.txt"", ""r"", stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) b[i] = {a[i], i};\n    sort(b + 1, b + n + 1);\n    set < int > Q;\n    for (int i = 1; i <= n; ++i) Q.insert(a[i]);\n    vector < int > t;\n    for (auto key : Q) t.push_back(key);\n    int lef = -1, righ = (int)t.size();\n    while (righ - lef > 1) {\n        int mid = (righ + lef) / 2;\n        if (oks(n, k, t[mid])) righ = mid;\n        else lef = mid;\n    }\n    cout << t[righ];\n    return 0;\n}\n\n\n']",,,"['binary search', 'dp', 'dsu', 'greedy', 'implementation']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Odd-Even Subsequence.json,https://codeforces.com//blog/entry/79107, Binary search over the answer and check if given it is possible to form a subsequence of length at least such that either all elements at odd indices or even indices are Let us binary search over the answer and fix if the answer comes from elements at odd or even indices in the subsequence Suppose we want to find if there exists a subsequence of length at least such that the elements at odd indices are We will construct the subsequence greedily Let s iterate on the array from left to right Suppose we are at index in the array and the current length of the subsequence formed is If is odd the next added element would be at an even index In this case we do not care about what this element is as we only want elements at odd indices to be So in this case we add to the subsequence If is even then the next added element would be at an odd index so it must be If we can add to the subsequence otherwise we do not add to the subsequence and continue to the next element in Note that we can do a similar greedy construction for elements at even indices If the length of the subsequence formed is either by construction from odd indices or even indices then the answer can be equal to and we can reduce the upper bound of the binary search otherwise we increase the lower bound Time Complexity or 
https://codeforces.com//contest/1924/problem/C,2447859,C,1924C,1924,C. Fractal Origami,You have a square piece of paper with a side length equal to 1 unit In one operation you fold each corner of the square to the center of the paper thus forming another square with a side length equal to dfrac 1 sqrt 2 units By taking this square as a new square you do the operation again and repeat this process a total of N times After performing the set of operations you open the paper with the same side up you started with and see some crease lines on it Every crease line is one of two types a mountain or a valley A mountain is when the paper folds outward and a valley is when the paper folds inward You calculate the sum of the length of all mountain crease lines on the paper and call it M Similarly you calculate for valley crease lines and call it V You want to find the value of dfrac M V It can be proved that this value can be represented in the form of A B sqrt 2 where A and B are rational numbers Let this B be represented as an irreducible fraction dfrac p q your task is to print p inv q modulo 999 999 893 where inv q is the modular inverse of q ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 999999893;\nusing Z = MInt<P>;\n\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    Z a = 0, b = 0;\n    a = power(Z(2), (n + 1) / 2);\n    b = power(Z(2), n / 2) - 1;\n    \n    Z c = a * a - b * b * 2;\n    Z ans = 2 * b / c;\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['geometry', 'math', 'matrices']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Fractal Origami.json,https://codeforces.com//blog/entry/125137,Tutorial Let there be an upside of the paper and a downside of the paper initially the upside of the paper is facing up With a little imagination we can see that the mountain crease lines on the upside of the paper will be valley crease lines on the downside of the paper and vice versa Grey is the upside and orange is the downsideAfter the first operation what once was a single layer of square paper turns into a square with two overlapping layers of paper The layer at the bottom has its upside facing up and the layer at the top has its downside facing up After this first operation whatever crease lines are formed on the upside of the bottom layer will be the same as the ones formed on the bottom layer of the top layer which means when the paper is unfolded and the upside of the entire paper is facing up the mountain crease lines and the valley crease lines created after the first operation will be equal Let be the length of mountain crease lines and be the length of valley crease lines after moves and the side of the square paper is Let Length of valley crease lines created in the first operation It is easy to calculate the total crease lines that are created mountain and valley in operations It is the sum of a GP Let Now to find we use the age old componendo and dividendo And then rationalize it to find the coefficient of 
https://codeforces.com//contest/1721/problem/A,1521724,A,1721A,1721,A. Image,You have an image file of size 2 times 2 consisting of 4 pixels Each pixel can have one of 26 different colors denoted by lowercase Latin letters You want to recolor some of the pixels of the image In one move you can choose pixels and paint them into some other color What is the minimum number of moves you have to make in order to fulfill your goal ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::set<char> s;\n    for (int i = 0; i < 4; i++) {\n        char c;\n        std::cin >> c;\n        s.insert(c);\n    }\n    std::cout << s.size() - 1 << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Image.json,https://codeforces.com//blog/entry/106416,There are some solutions based on case analysis but in my opinion the most elegant one is the following Let s pick a color with the maximum possible number of pixels and repaint all other pixels into it We will try to pick all pixels of some other color and repaint them in one operation and we can ignore the constraint that we can repaint no more than pixels since we will never need to repaint or pixels in one operation So the number of operations is just the number of colors other than the one we chosen or just where is the number of different colors in the image To calculate this we can use a set or an array of size where we mark which colors are present 
https://codeforces.com//contest/1361/problem/F,640973,F,1361F,1361,F. Johnny and New Toy,Johnny has a new toy As you may guess it is a little bit extraordinary The toy is a permutation P of numbers from 1 to n written in one row next to each other For each i from 1 to n 1 between P i and P i 1 there is a weight W i written and those weights form a permutation of numbers from 1 to n 1 There are also extra weights W 0 W n 0 The instruction defines subsegment L R as good if W L 1 W i and W R W i for any i in L L 1 ldots R 1 For such subsegment it also defines W M as minimum of set W L W L 1 ldots W R 1 Now the fun begins In one move the player can choose one of the good subsegments cut it into L M and M 1 R and swap the two parts More precisely before one move the chosen subsegment of our toy looks like W L 1 P L W L ldots W M 1 P M W M P M 1 W M 1 ldots W R 1 P R W R and afterwards it looks like this W L 1 P M 1 W M 1 ldots W R 1 P R W M P L W L ldots W M 1 P M W R Such a move can be performed multiple times possibly zero and the goal is to achieve the minimum number of inversions in P Johnny s younger sister Megan thinks that the rules are too complicated so she wants to test her brother by choosing some pair of indices X and Y and swapping P X and P Y X might be equal Y After each sister s swap Johnny wonders what is the minimal number of inversions that he can achieve starting with current P and making legal moves You can assume that the input is generated P and W were chosen independently and equiprobably over all permutations also Megan s requests were chosen independently and equiprobably over all pairs of indices ,"['/**\n *    author:  tourist\n *    created: 04.06.2020 18:55:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n\nusing namespace __gnu_pbds;\n\ntypedef int tp;\ntypedef tree<tp,null_type,less<tp>,rb_tree_tag,tree_order_statistics_node_update> pbds;\n// tp a;\n// T.insert(a), T.erase(a), T.size()\n// T.order_of_key(a) -- number of elements strictly less than a\n// *T.find_by_order(k) -- k-th element in increasing order\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstruct Node {\n  int parent;\n  int from;\n  int to;\n  int k;\n  long long inv;\n  long long pairs;\n  pbds L;\n  pbds R;\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> w(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> w[i];\n    --w[i];\n  }\n  vector<int> ids(n - 1);\n  iota(ids.begin(), ids.end(), 0);\n  SparseTable<int> st(ids, [&](int i, int j) { return (w[i] < w[j] ? i : j); });\n  vector<Node> nodes(n - 1);\n  {\n    Node& node = nodes[0];\n    node.parent = -1;\n    node.from = 0;\n    node.to = n - 1;\n    node.k = -1;\n    node.inv = 0;\n    node.pairs = 0;\n  }\n  vector<int> leaf(n);\n  long long ans = 0;\n  long long total = 0;\n  int ptr = 1;\n  for (int b = 0; b < n - 1; b++) {\n    Node& node = nodes[b];\n//    debug(b, node.from, node.to);\n    assert(node.from < node.to);\n    node.k = st.get(node.from, node.to - 1);\n    for (int i = node.k + 1; i <= node.to; i++) {\n      node.R.insert(p[i]);\n    }\n    for (int i = node.from; i <= node.k; i++) {\n      node.inv += node.R.order_of_key(p[i]);\n      node.L.insert(p[i]);\n    }\n    total += (int) node.L.size();\n    total += (int) node.R.size();\n    node.pairs = (long long) (node.to - node.k) * (node.k - node.from + 1);\n//    debug(node.from, node.to, node.k, node.inv, node.pairs);\n    ans += min(node.inv, node.pairs - node.inv);\n    if (node.from == node.k) {\n      leaf[node.from] = b;\n    } else {\n      Node& new_node = nodes[ptr];\n      ptr += 1;\n      new_node.parent = b;\n      new_node.from = node.from;\n      new_node.to = node.k;\n      new_node.k = -1;\n      new_node.inv = 0;\n      new_node.pairs = 0;\n    }\n    if (node.k + 1 == node.to) {\n      leaf[node.to] = b;\n    } else {\n      Node& new_node = nodes[ptr];\n      ptr += 1;\n      new_node.parent = b;\n      new_node.from = node.k + 1;\n      new_node.to = node.to;\n      new_node.k = -1;\n      new_node.inv = 0;\n      new_node.pairs = 0;\n    }\n  }\n//  debug(""done"");\n  debug(ans, clock(), nodes.size(), total);\n//  debug(leaf);\n  auto Modify = [&](int i, int val) {\n    int b = leaf[i];\n    while (b >= 0) {\n      Node& node = nodes[b];\n      ans -= min(node.inv, node.pairs - node.inv);\n      if (i <= node.k) {\n        node.inv -= node.R.order_of_key(p[i]);\n        node.inv += node.R.order_of_key(val);\n        node.L.erase(p[i]);\n        node.L.insert(val);\n      } else {\n        node.inv += node.L.order_of_key(p[i]);\n        node.inv -= node.L.order_of_key(val);\n        node.R.erase(p[i]);\n        node.R.insert(val);\n      }\n      ans += min(node.inv, node.pairs - node.inv);\n      b = node.parent;\n    }\n    p[i] = val;\n  };\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    int px = p[x];\n    int py = p[y];\n    Modify(x, -1);\n    Modify(y, px);\n    Modify(x, py);\n    cout << ans << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']",,,"['data structures', 'implementation', 'math']",3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Johnny and New Toy.json,https://codeforces.com//blog/entry/78355,Let us start with an analysis of good subsegments for the fixed permutation The whole permutation is a good subsegment itself as for any If we denote the minimal weight in as then we can notice that subsegments and contain all good subsegments except the whole permutation As a result we can recursively find all good subsegments by recursive calls in and We can view the structure of good subsegments as a binary tree Example structure of tree for and Now we want to analyze the possible moves for players It turns out that the player s move is equivalent to choosing a vertex of a tree and swapping its left and right subtree Notice that moves made in different vertices influence disjoint pairs of elements so in some sense these moves are independent if we are interested only in the number of inversions This observation allows us to find a simple method for calculating the result For each vertex calculate the number of inversions between the left and right subtree Using these numbers for each vertex we can find out whether we want to swap its subtrees or not so the result can be calculated by a simple loop over all vertices From randomness of the input we can deduce that the tree we built has height We can calculate the number of inversions easily if in each vertex we keep a structure with elements from permutation contained in that vertex Such structure must support querying the number of elements smaller than some The shortest implementation uses the ordered set but any BST can do it segment tree needs some squeezing to fit into ML The above solution works fast if there are no queries We can view each request as two removals and additions of elements If so we can notice that each query modifies the number of inversions in at most vertices So all we need to do is update the number of inversions in these vertices and recalculate the global result Building a tree and calculating initial number of inversions takes or answering each query cost so the final complexity is 
https://codeforces.com//contest/1244/problem/D,438883,D,1244D,1244,D. Paint the Tree,You are given a tree consisting of n vertices A tree is an undirected connected acyclic graph You have to paint each vertex into one of three colors For each vertex you know the cost of painting it in every color You have to paint the vertices so that any path consisting of exactly three distinct vertices does not contain any vertices with equal colors In other words let s consider all triples x y z such that x neq y y neq z x neq z x is connected by an edge with y and y is connected by an edge with z The colours of x y and z should be pairwise distinct Let s call a painting which meets this condition You have to calculate the minimum cost of a painting and find one of the optimal paintings If there is no painting report about it ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nvector<int> son[100010];\nll cost[3][100010];\nll p[3] = {0, 1, 2};\nll ans[3], _min = 1e18;\nll a[100010];\nint out[100010];\nint main() {\n    scanf(""%d"", &n);\n    for(int i = 1; i <= n; i++) scanf(""%d"", cost[0] + i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", cost[1] + i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", cost[2] + i);\n    for(int i = 1; i < n; i++) {\n        int u, v;\n        scanf(""%d%d"", &u, &v);\n        son[u].push_back(v), son[v].push_back(u);\n    }\n    for(int i = 1; i <= n; i++) {\n        if(son[i].size() == 1) a[1] = i;\n    }\n    for(int i = 1; i < n; i++) {\n        if(son[a[i]].size() > 2) return puts(""-1""), 0;\n        if(son[a[i]][0] != a[i - 1]) a[i + 1] = son[a[i]][0];\n        else a[i + 1] = son[a[i]][1];\n    }\n    do {\n        long long now = 0;\n        for(int i = 1; i <= n; i++) {\n            now += cost[p[i % 3]][a[i]];\n        }\n        if(now < _min) _min = now, memcpy(ans, p, sizeof p);\n    } while(next_permutation(p, p + 3));\n    cout << _min << endl;\n    for(int i = 1; i <= n; i++) out[a[i]] = ans[i % 3] + 1;\n    for(int i = 1; i <= n; i++) printf(""%d%c"", out[i], "" \\n""[i == n]);\n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'dp', 'graphs', 'implementation', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Paint the Tree.json,https://codeforces.com//blog/entry/70553,The key observation is that if we fix the colors of two adjacent vertices and then the color of any vertex adjacent to or to can be only So we can fix the colors of the endpoints of any edge there are possibilities to do that then do a traversal to color all other vertices then do another traversal to check that we got a good painting To avoid checking that the painting we got is good which can be tricky to code we can use the fact that for each vertex the colors of all its neighbours should be different from each other and from the color of the vertex we fixed So if some vertex has degree or greater then there is no good painting otherwise the painting we get is good since the graph is a chain 
https://codeforces.com//contest/1607/problem/E,1168762,E,1607E,1607,E. Robot on the Board 1,The robot is located on a checkered rectangular board of size n times m n rows m columns The rows in the board are numbered from 1 to n from top to bottom and the columns from 1 to m from left to right The robot is able to move from the current cell to one of the four cells adjacent by side The sequence of commands s executed by the robot is given Each command is denoted by one of the symbols or and triggers the movement to left right down or up respectively The robot can start its movement in cell The robot executes the commands starting from the first one strictly in the order in which they are listed in s If the robot moves beyond the edge of the board it falls and breaks A command that causes the robot to break is successfully executed The robot s task is to execute as many commands as possible without falling off the board For example on board 3 times 3 if the robot starts a sequence of actions s right right down left up up from the central cell the robot will perform one command then the next command will force him to cross the edge If the robot starts moving from the cell 2 1 second row first column then all commands will be executed successfully and the robot will stop at the cell 1 2 first row second column Determine the cell from which the robot should start its movement in order to execute as many commands as possible ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tstring s;\n\t\tcin >> n >> m >> s;\n\t\tint mnx=0,mxx=0,mny=0,mxy=0,x=0,y=0;\n\t\ts+=\'*\'; \n\t\tfor(auto t:s)\n\t\t{\n\t\t\tint l1=mxx,l2=mnx,l3=mxy,l4=mny;\n\t\t\tif(t==\'L\') --y;\n\t\t\telse if(t==\'R\') ++y;\n\t\t\telse if(t==\'U\') --x;\n\t\t\telse if(t==\'D\') ++x;\n\t\t\telse x=1e9;\n\t\t\tmnx=min(mnx,x); \n\t\t\tmny=min(mny,y); \n\t\t\tmxx=max(mxx,x);\n\t\t\tmxy=max(mxy,y);\n\t\t\tif(mxx-mnx+1>n||mxy-mny+1>m)\n\t\t\t{//\n\t\t\t\tmxx=l1,mnx=l2,mxy=l3,mny=l4;\n\t\t\t\tcout << 1-mnx << "" "" << 1-mny << ""\\n"";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",,,['implementation'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Robot on the Board 1.json,https://codeforces.com//blog/entry/96604,Let s look at the answer Let s see how many commands the robot can execute Since the robot breaks goes outside the field if any command causes it to break it either leads to its total shift relative to of exactly to the left or exactly to the right or similarly of exactly up or exactly down Denote by and the sum of the maximum positive right down and maximum negative left up shifts in the corresponding direction By adding up the above constraints we get the fact that the robot will not fall off the board only if and Note that the reverse is also true if both these conditions are satisfied then starting from the point where is the maximum shift along the direction the robot will not pass any of the board s edges Thus it is sufficient to find the number of commands which when executed hold the following invariant The horizontal shift can be calculated as the difference between the number of letters and the number of letters encountered Similarly the vertical shift as the difference of the numbers of and Let s iterate over the sequence of commands maintaining relevant values of for all After executing each command if the robot goes farther in some direction than ever before we update the corresponding Either we reach the end of or we meet a command after which either becomes equal to or becomes equal to and the robot breaks so the previous command was the last one successfully executed The possible answer is where the values are calculated one command before the robot broke 
https://codeforces.com//contest/1342/problem/D,604759,D,1342D,1342,D. Multiple Testcases,So you decided to hold a contest on Codeforces You prepared the problems statements solutions checkers validators tests Suddenly your coordinator asks you to change all your tests to multiple testcases in the easiest problem Initially each test in that problem is just an array The maximum size of an array is k For simplicity the contents of arrays don t matter You have n tests the i th test is an array of size m i 1 le m i le k Your coordinator asks you to distribute all of your arrays into multiple testcases Each testcase can include multiple arrays However each testcase should include no more than c 1 arrays of size ge 1 no more than c 2 arrays of size dots no more than c k arrays of size Also c 1 ge c 2 ge dots ge c k So now your goal is to create the new testcases in such a way that each of the initial arrays appears in testcase for each testcase the given conditions hold the number of testcases is minimum possible Print the minimum possible number of testcases you can achieve and the sizes of arrays included in each testcase ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n, m, a[200020], b[200020], c[200020];\nbool check(int k) {\n    for (int i = 1; i <= k; i++) {\n        int p = 0;\n        for (int j = i; j <= n; j += k)\n                    b[++p] = a[j];\n        for (int j = 1; j <= p; j++)\n                    if (p - j + 1 > c[b[j]])\n                        return false;\n    }\n    return true;\n}\nint find() {\n    int l = 0, r = n, mid;\n    while (l + 1 < r) {\n        mid = (l + r) >> 1;\n        if (check(mid)) r = mid; else            l = mid;\n    }\n    return r;\n}\nvoid print(int k) {\n    printf(""%d\\n"", k);\n    for (int i = 1; i <= k; i++) {\n        printf(""%d "", (n - i) / k + 1);\n        for (int j = i; j <= n; j += k)\n                    printf(""%d "", a[j]);\n        puts("""");\n    }\n}\nint main() {\n    scanf(""%d %d"", &n, &m);\n    for (int i = 1; i <= n; i++)\n            scanf(""%d"", &a[i]);\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= m; i++)\n            scanf(""%d"", &c[i]);\n    print(find());\n    return 0;\n}']",,,"['binary search', 'constructive algorithms', 'data structures', 'greedy', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Multiple Testcases.json,https://codeforces.com//blog/entry/76633,Let s estimate the smallest possible achievable answer Let the number of the arrays of size greater than or equal to be The answer is maximum over all from to You can prove that you can t fit arrays in less than testcases with the pigeonhole principle Let that be called Ok let s now construct the solution for that estimate Sort arrays in the increasing or decreasing order and assign the th array indexed in that order to the testcase It s easy to see that for any the number of arrays of size greater than or equal to is always restricted by Overall complexity or if you care enough to do counting sort 
https://codeforces.com//contest/1059/problem/E,231524,E,1059E,1059,E. Split the Tree,You are given a rooted tree on n vertices its root is the vertex number 1 The i th vertex contains a number w i Split it into the minimum possible number of vertical paths in such a way that each path contains no more than L vertices and the sum of integers w i on each path does not exceed S Each vertex should belong to exactly one path A vertical path is a sequence of vertices v 1 v 2 ldots v k where v i i ge 2 is the parent of v i 1 ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\ntemplate<int maxn,typename NUM>\nstruct BIT {\n    NUM s[maxn];\n    \n    void init() {\n        mst(s, 0);\n    }\n    BIT() {\n        init();\n    }\n    \n    void update(int a,NUM value) {\n        a++;\n        while(a<maxn) {\n            s[a]+=value;\n            a+=lowbit(a);\n        }\n    }\n    \n    NUM query(int a) {\n        NUM ans = 0;\n        a++;\n        while(a) {\n            ans+=s[a];\n            a-=lowbit(a);\n        }\n        return ans;\n    }\n    NUM query(int a,int b) {\n        if(b<a)return 0;\n        return query(b)-query(a-1);\n    }\n};\nll n,l,s;\nll weight[100010];\nll par[100010];\n\nBIT<200010, ll>tree;\nnamespace HLD {\n    //0不能被使用\n    struct edge {\n        int to;\n        edge(int x):to(x){}\n    };\n    \n    const int root = 1;\n    const int maxn = 200010;\n    vector<edge>adj[maxn];\n    int dfnToID[maxn],dfn[maxn],head[maxn],fa[maxn],dep[maxn],size[maxn],heavy[maxn],r[maxn],cnt = 1;\n    ll sum[maxn];\n    void firstDfs(int cur,int _fa) {\n        sum[cur] = weight[cur] + sum[_fa];\n        dep[cur] = dep[_fa]+1;\n        size[cur]=1;\n        fa[cur] = _fa;\n        for(auto e:adj[cur]) {\n            if(e.to!=_fa) {\n                firstDfs(e.to,cur);\n                size[cur]+=size[e.to];\n            }\n        }\n        int heavyChild = 0;\n        for(auto e:adj[cur]) {\n            if(e.to!=_fa) {\n                if(size[e.to]>size[heavyChild]) {\n                    heavyChild = e.to;\n                }\n            }\n        }\n        heavy[cur] = heavyChild;\n    }\n    \n    \n    void secondDfs(int cur,int _fa) {\n        if(cur!=heavy[_fa]) {\n            head[cur] = cur;\n        } else {\n            head[cur] = head[_fa];\n        }\n        dfn[cur] = cnt++;\n        r[cur] = dfn[cur];\n        dfnToID[dfn[cur]] = cur;\n        if(!heavy[cur])return;\n        secondDfs(heavy[cur],cur);\n        r[cur] = r[heavy[cur]];\n        for(auto e:adj[cur]) {\n            if(e.to==_fa||e.to==heavy[cur])continue;\n            secondDfs(e.to,cur);\n            r[cur] = r[e.to];\n        }\n    }\n    void init() {\n        firstDfs(root,0);\n        secondDfs(root,0);\n    }\n    \n    int kthFather(int k,int cur) {\n        while(k) {\n            if(head[cur] == cur) {\n                k--;\n                cur = fa[head[cur]];\n            } else {\n                if(dep[cur]-dep[head[cur]]<=k) {\n                    k-=dep[cur]-dep[head[cur]];\n                    cur = head[cur];\n                } else {\n                    return dfnToID[dfn[cur]-k];\n                }\n            }\n        }\n        return cur;\n    }\n    int LCA(int u,int v) {\n        while(head[u]!=head[v]) {\n            if(dep[head[u]]>dep[head[v]])swap(u,v);\n            v = fa[head[v]];\n        }\n        if(dep[u]<dep[v])return u;\n        return v;\n    }\n    \n    int dis(int u,int v){\n        return dep[u]+dep[v]-2*dep[LCA(u, v)];\n    }\n    void add(int low,int high){\n        while(head[low]!=head[high]){\n            tree.update(dfn[head[low]], 1);\n            tree.update(dfn[low]+1, -1);\n            low = fa[head[low]];\n        }\n        tree.update(dfn[high], 1);\n        tree.update(dfn[low]+1, -1);\n    }\n    \n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    in(n,l,s);\n    REP(i,1,n+1){in(weight[i]);if(weight[i]>s){\n        \n        cout<<-1;return 0;\n    }}\n    REP(i,2,n+1)in(par[i]);\n    REP(i,2,n+1){\n        HLD::adj[par[i]].push_back(HLD::edge(i));\n    }\n    HLD::init();\n    ll ans = 0;\n    RREP(i,n,1){\n        if(tree.query(HLD::dfn[i]) > 0)continue;\n        ans++;\n        int ll = 0,rr = l-1;\n        upmin(rr, HLD::dep[i]-1);\n//        dbg(rr);\n        while(ll<rr){\n            int mid = (ll+rr)/2+1;\n            int father = HLD::kthFather(mid, i);\n            if(HLD::sum[i]-HLD::sum[father]+weight[father] <= s){\n                ll = mid;\n            }else{\n                rr = mid-1;\n            }\n        }\n        int father = HLD::kthFather(ll, i);\n//        dbg(father);\n        HLD::add(i, father);\n    }\n    \n    \n    \n    \n    \n    \n    cout<<ans;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']",,,"['binary search', 'data structures', 'dp', 'greedy', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Split the Tree.json,https://codeforces.com//blog/entry/62238,There are two solutions Both of them find the answer for each subtree in dfs firstly for children then for the vertex itself In both solutions we firstly calculate for each vertex how far up a vertical path starting at this vertex may go It can be done with binary lifting in Now let s describe the first solution Let be the answer for the subtree of the th vertex Let be the sum of where is a child of Suppose we want to include the th vertex in the path starting at some vertex Let be the set of vertices on the path between and Then the answer for in this case equals if we assume that initially So we need to calculate the minimum such value for all in the subtree of for which we can create a path from to Let s build a segment tree over the Euler tour of the tree After processing vertex we add on the segment that corresponds to the subtree of If after processing the vertex there are some vertices in it s subtree for which there can be a vertical path to but there cannot be a vertical path to we set the value at the corresponding position in the Euler tour to The second solution is much simpler When calculating the answers in case of tie let s choose the answer where the path going through the root of the subtree may go further Then the answers can be updated greedily Both solutions work in 
https://codeforces.com//contest/1198/problem/B,380936,B,1198B,1198,B. Welfare State,There is a country with n citizens The i th of them initially has a i money The government strictly controls the wealth of its citizens Whenever a citizen makes a purchase or earns some money they must send a receipt to the social services mentioning the amount of money they currently have Sometimes the government makes payouts to the poor all citizens who have strictly less money than x are paid accordingly so that after the payout they have exactly x money In this case the citizens don t send a receipt You know the initial wealth of every citizen and the log of all events receipts and payouts Restore the amount of money each citizen has after all events ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\nint tab[nax];\n\nmap <int,vector<pii>> mapa;\n\npii wyn[nax];\n\nvoid przepisz(vector <pii> &a, vector <pii> &b)\n{\n\tif ((int)a.size()>(int)b.size())\n\t\ta.swap(b);\n\tfor (pii i : a)\n\t\tb.push_back(i);\n\ta.clear();\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &tab[i]);\n\t\tmapa[tab[i]].push_back({0, i});\n\t}\n\tscanf(""%d"", &q);\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tint typ;\n\t\tscanf(""%d"", &typ);\n\t\tif (typ==1)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(""%d%d"", &a, &b);\n\t\t\tmapa[b].push_back({i, a});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(""%d"", &a);\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tauto it=mapa.begin();\n\t\t\t\tif ((*it).first>=a)\n\t\t\t\t\tbreak;\n\t\t\t\tprzepisz((*it).second, mapa[a]);\n\t\t\t\tmapa.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : mapa)\n\t\tfor (pii j : i.second)\n\t\t\twyn[j.second]=max(wyn[j.second], {j.first, i.first});\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%d "", wyn[i].second);\n\tprintf(""\\n"");\n\treturn 0;\n}\n']",,,"['binary search', 'brute force', 'data structures', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Welfare State.json,https://codeforces.com/blog/entry/68812,For every citizen only the last query of type matters Moreover all queries before don t matter at all So the answer for each citizen is maximum of for last query of type for this citizen and maximum of all for queries of type after that We can calculate maximum for all suffices of queries of type and remember the last query of type for each citizen It can be implemented in time 
https://codeforces.com//contest/2033/problem/E,2975321,E,2033E,2033,"E. Sakurako, Kosuke, and the Permutation",Sakurako s exams are over and she did excellently As a reward she received a permutation p Kosuke was not entirely satisfied because he failed one exam and did not receive a gift He decided to sneak into her room thanks to the code for her lock and spoil the permutation so that it becomes A permutation p is considered if for every i 1 le i le n one of the following conditions holds p i i p p i i For example the permutations 1 2 3 4 5 2 4 3 1 and 2 1 are while 2 3 1 and 5 2 1 4 3 are not In one operation Kosuke can choose indices i j 1 le i j le n and swap the elements p i and p j Sakurako is about to return home Your task is to calculate the minimum number of operations that Kosuke needs to perform to make the permutation ,"['#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/rope>\xa0using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;\xa0// /*//                                                //////////**DEFINES - START**//////////\xa0#define ret return#define fi first#define se second#define mp make_pair#define all(x) x.begin(), x.end()#define be(x) x.begin()#define en(x) x.end()#define sz(x) ll(x.size())#define for0(i, n) for (ll   i = 0; i < (n); ++i)#define for1(i, n) for (ll   i = 1; i < (n); ++i)#define rfor0(i, n) for (ll   i = (n) - 1; i >= 0; --i)#define rfor1(i, n) for (ll   i = (n) - 1; i >= 1; --i)#define rep(i, a, n) for (ll   i = a; i < ll(n); ++i)#define rrep(i, a, n) for (ll   i = a - 1; i >= ll(n); --i)#define popcount __builtin_popcount#define popcountll __builtin_popcountll#define fastIO() ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);#define con continue#define pb push_back#define pob pop_back#define deb(x) cout << (#x) << "" is "" << (x) << endl#define ins insert#define len(s) (s).length()#define gi greater<int>()#define gll greater<ll  >()#define gstr greater<string>()#define gpll greater<pair<ll  , ll  >>()#define rast(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))#define rev reverse#define ub upper_bound#define lb lower_bound#define bs binary_search#define rs resize#define last(a) a.back()#define co count#define ba(a) a.back()#define um unordered_map#define rsun(a) a.resize(unique(a.begin(), a.end())-a.begin())#define endl \'\\n\'#ifdef OG_Matveychick1bool local = true;#elsebool local = false;#endif\xa0//                                                \\\\\\\\\\\\\\\\\\\\**DEFINES - END**\\\\\\\\\\\\\\\\\\\\// */\xa0// /*//                                                //////////**TYPEDEFS - START**//////////\xa0typedef vector<int> vi;typedef vector<vi> vvi;typedef vector<char> vc;typedef pair<int, int> pii;typedef vector<pii> vpii;typedef vector<string> vs;typedef long long ll;typedef unsigned long long ull;typedef vector<ull> vull;typedef pair<ll, ll> pll;typedef vector<ll> vll;typedef vector<pll> vpll;typedef pair<double, double> pdd;typedef double ld;typedef double D;typedef vector<ld> vld;typedef vector<pair<ld, ld>>        vpld;typedef string str;typedef set<ll> sll;typedef set<int> si;typedef set<str> ss;typedef set<pii> spii;typedef multiset<int> msi;typedef multiset<ll> msll;typedef multiset<str> mss;typedef multiset<pii> mspii;typedef multiset<pll> mspll;typedef map<str, str> mps;typedef map<int, int> mpi;typedef map<ll, ll> mpll;typedef map<int, vi> mpvi;typedef map<int, vll> mpvll;typedef map<char, int> mpci;typedef multimap<ll, ll> mmpll;typedef multimap<str, str> mmps;typedef multimap<int, int> mmpi;typedef vector<vector<int>> vvi;typedef vector<vector<ll>> vvll;typedef vector<vector<long double>> vvld;typedef vector<vvi> vvvi;typedef vector<vector<char>> vvc;typedef vector<vs> vvs;typedef vector<D> vD;typedef set<pair<ll, ll>>        spll;typedef pair<ull, ull> pull;typedef vector<pull> vpull;typedef vector<bool> vb;typedef vector<vb> vvb;typedef set<char> sc;typedef queue<int> qi;typedef queue<ll> qll;typedef queue<bool> qb;typedef vector<sll> vsll;typedef queue<pair<ll, ll>>        qpll;typedef vector<vector<pair<int, int>>>        vvpii;typedef vector<vector<pair<ll, ll>>>        vvpll;typedef vector<spll> vspll;typedef multiset<char> msc;typedef queue<str> qs;typedef vector<set<int>> vsi;typedef priority_queue<ll> pqll;typedef vector<vsll> vvsll;typedef pair<ld, ld> pld;typedef vector<vvll> vvvll;typedef set<ld> sld;typedef vector<vpld> vvpld;typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_set;typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_multiset;\xa0//                                                \\\\\\\\\\\\\\\\\\\\**TYPEDEFS - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// /*//                                                //////////**CONSTANTS - START**//////////\xa0constexpr long double pi = 3.141592653589793238462643383279;const ll mod1 = 1e9 + 7;const ll mod2 = 998244353;const ll MAXLL = 9223372036854775807;//const ll MAXINT = 2147483647;const long double eps = 1e-9;\xa0//                                                \\\\\\\\\\\\\\\\\\\\**CONSTANTS - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// /*//                                                //////////**TEMPLATES - START**//////////\xa0\xa0template<typename T>istream &operator>>(istream &in, vector<T> &a) {    for (T &i : a) in >> i;    return in;}\xa0template<typename T1, typename T2>istream &operator>>(istream &in, pair<T1, T2> &a) {    in >> a.fi >> a.se;    return in;}\xa0template<typename T1, typename T2>ostream &operator<<(ostream &out, pair<T1, T2> &a) {    out << a.fi << "" "" << a.se;    return out;}\xa0template<typename T1, typename T2>istream &operator>>(istream &in, vector<pair<T1, T2>>\xa0&a) {    for (        pair<T1, T2> &i            : a)        in >> i.fi >> i.                se;    return            in;}\xa0template<typename T>ostream &operator<<(ostream &out, const vector<T> &a) {    for (auto i : a) {        out << i << "" "";    }    return out;}\xa0template<typename T1, typename T2>ostream &operator<<(ostream &out, vector<pair<T1, T2>>\xa0&a) {    for (        pair<T1, T2> i            : a)        out << i.fi << "" "" << i.se <<            endl;    return            out;}\xa0template<typename T1>ostream &operator<<(ostream &out, vector<vector<T1>> &a) {    for (vector<T1> i : a) {        for (T1 j : i) out << j << "" "";        out << endl;    }    return out;}\xa0template<typename T1, typename T2>inline T1 min(T1 a, T2 b) {    b = (T1) b;    return a > b ? b : a;}\xa0template<typename T1, typename T2>inline T1 max(T1 a, T2 b) {    b = (T1) b;    return a > b ? a : b;}\xa0template<typename T1, typename T2>inline void amin(T1 &a, T2 b) {    a = min(a, b);}\xa0template<typename T1, typename T2>inline void amax(T1 &a, T2 b) {    a = max(a, b);}\xa0\xa0//                                                \\\\\\\\\\\\\\\\\\\\**TEMPLATES - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// This bear is a good alternative to duck!!!/*    ????      ??????  ??????????????????? ????????????????  ??????   ???????????  ??????  ???????????? ?? ??????????????????   ??????????????? ?   ?????????????????   ???????   ???    ??    ????  ??????????     ????     ?? ???   ???????????? ?????  ???????????????????? ????????   ??  ??????? ???????         ????? */\xa0\xa0double getTime() {    return clock() / (double) CLOCKS_PER_SEC;}\xa0\xa0mt19937_64 rn(chrono::steady_clock::now().time_since_epoch().count());//mt19937_64 rn(4);\xa0ll rnd(ll l, ll r) {    ll a = rn() % (r - l + 1) + l;    return a;}\xa0void solve();\xa0ll T = 1;\xa0signed main(int argc, char **argv) {    setlocale(LC_ALL, ""RUS"");    fastIO()    cout.precision(12);    cout << fixed;    if (local && argc == 1) {        freopen(""input.txt"", ""r"", stdin);//        freopen(""002.out"", ""w"", stdout);    }    cin >> T;    while (T--) {        solve();    }    if (local && argc == 1) {        cout << endl << fixed << ""time = "" << getTime();    }    return 0;}\xa0\xa0/*    ___        __              __   ______          __        _____ __             __          __  __   /   | _____/ /___  ______ _/ /  / ____/___  ____/ /__     / ___// /_____ ______/ /______   / / / /__  ________  / /| |/ ___/ __/ / / / __ `/ /  / /   / __ \\/ __  / _ \\    \\__ \\/ __/ __ `/ ___/ __/ ___/  / /_/ / _ \\/ ___/ _ \\ / ___ / /__/ /_/ /_/ / /_/ / /  / /___/ /_/ / /_/ /  __/   ___/ / /_/ /_/ / /  / /_(__  )  / __  /  __/ /  /  __//_/  |_\\___/\\__/\\__,_/\\__,_/_/   \\____/\\____/\\__,_/\\___/   /____/\\__/\\__,_/_/   \\__/____/  /_/ /_/\\___/_/   \\___/*/\xa0\xa0\xa0\xa0void solve() {    ll n;    cin >> n;    vll a(n);    cin >> a;    vll used(n);    for0(i, n) a[i]--;    ll ans = 0;    for0(i, n) {        if (used[i]) con;        used[i] = 1;        ll j = a[i];        ll c = 1;        while (j != i) {            c++;            used[j] = 1;            j = a[j];        }        ans += (c - 1) / 2;    }    cout << ans << endl;}']",,,"['brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'math']",1400,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Sakurako, Kosuke, and the Permutation.json",https://codeforces.com//blog/entry/135520,Lets make this the shortest editorial out of all Observation All permutations can be split into cycles All cycles of permutation can be traversed in time Observation When we are swapping elements that belong to one cycle we are splitting our cycle into parts If we rephrase our definition of simple permutation we can see that the permutation is called simple if every cycle in it has length not larger than Observation By splitting our initial cycle of length repeatedly we can achieve its division into cycles of length not larger than in swaps this is achieved by repeatedly decreasing size of the cycle by Observation All cycles are independent so the answer for the initial task is the sum of answers for every cycle Total time complexity is 
https://codeforces.com//contest/1684/problem/B,1404372,B,1684B,1684,B. Z mod X = C,You are given three positive integers a b c a b c You have to find three positive integers x y z such that x bmod y a y bmod z b z bmod x c Here p bmod q denotes the remainder from dividing p by q It is possible to show that for such constraints the answer always exists ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 18:36:27       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    cout << a + b * (long long) 1e9 << "" "" << b << "" "" << c << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Z mod X = C.json,https://codeforces.com//blog/entry/102995,In this problem it is enough to find a contstruction that works for all For example In this case since since since 
https://codeforces.com//contest/1380/problem/D,670986,D,1380D,1380,D. Berserk And Fireball,There are n warriors in a row The power of the i th warrior is a i All powers are pairwise distinct You have two types of spells which you may cast Fireball you spend x mana and destroy k consecutive warriors Berserk you spend y mana choose two consecutive warriors and the warrior with greater power destroys the warrior with smaller power For example let the powers of warriors be 2 3 7 8 11 5 4 and k 3 If you cast Berserk on warriors with powers 8 and 11 the resulting sequence of powers becomes 2 3 7 11 5 4 Then for example if you cast Fireball on consecutive warriors with powers 7 11 5 the resulting sequence of powers becomes 2 3 4 You want to turn the current sequence of warriors powers a 1 a 2 dots a n into b 1 b 2 dots b m Calculate the minimum amount of mana you need to spend on it ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N, M; cin >> N >> M;\n    ll X, K, Y; cin >> X >> K >> Y;\n    int A[N+1], B[M+1]; F0R(i, N) cin >> A[i];\n    F0R(i, M) cin >> B[i];\n    \n    int bp = 0;\n    int lv = -1;\n    int mx = 0;\n    int cnt = 0;\n    ll ans = 0;\n    A[N] = 0; B[M] = 0;\n    F0R(i, N+1) {\n        if (bp < M+1 && A[i] == B[bp]) {\n            ll res = 1e18;\n            if (mx < lv || mx < A[i]) {\n                res = Y * cnt;\n            }\n            for (int j = K; j <= cnt; j += K) {\n                ckmin(res, X * (j / K) + Y * (cnt - j));\n            }\n\n            if (res > 1e17) {\n                cout << -1 << nl; return 0;\n            }\n            ans += res;\n\n            bp++;\n            lv = A[i];\n            mx = 0;\n            cnt = 0;\n        } else {\n            ckmax(mx, A[i]);\n            cnt++;\n        }\n    }\n    if (bp != M+1) {\n        cout << -1 << nl; return 0;\n    }\n    cout << ans << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['constructive algorithms', 'greedy', 'implementation', 'math', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Berserk And Fireball.json,https://codeforces.com//blog/entry/80054,The first thing we need to do is to find the occurrences of in the sequence these are the monsters that have to remain Since both spells Fireball and Berserk affect consecutive monsters we should treat each subsegment of monsters we have to delete separately Consider a segment with monsters we have to delete such that the last monster before it has power the first monster after the segment has power and the strongest monster on the segment has power If then we have to use Berserk at least times Let s make the strongest monster on segment kill some other monster If then the strongest monster should also be killed by one of the monsters bounding the segment so if and there is no solution Okay now the number of monsters is divisible by If it is more profitable to use Fireball we use the required number of Fireballs to kill all of them Otherwise we have to kill the maximum possible number of monsters with Berserk and finish the remaining ones with Fireball If or then one of the monsters just outside the segment can kill all the monsters inside the segment otherwise the strongest monster should kill adjacent monsters until exactly remain and those monsters are finished with a single Fireball Now we know what we need to consider when processing a single segment all that s left is to sum the minimum required mana over all such segments Since the total length of these segments is at most and we can process each segment in linear time we have a solution with complexity 
https://codeforces.com//contest/1497/problem/B,925005,B,1497B,1497,B. M-arrays,You are given an array a 1 a 2 ldots a n consisting of n positive integers and a positive integer m You should divide elements of this array into some arrays You can order the elements in the new arrays as you want Let s call an array m divisible if for each two adjacent numbers in the array two numbers on the positions i and i 1 are called adjacent for each i their sum is divisible by m An array of one element is m divisible Find the smallest number of m divisible arrays that a 1 a 2 ldots a n is possible to divide into ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n, m;\n        cin >> n >> m;\n        vector<ll> a(n);\n        map<ll, ll> q;\n        ll ans = 0;\n        bool k = 0;\n        for (int i = 0; i < n; ++i) {\n            ll x;\n            cin >> x;\n            x %= m;\n            if (!x) {\n                k = 1;\n                continue;\n            }\n            ++q[x];\n            ++q[m - x];\n            --q[m - x];\n        }\n        if (k) ++ans;\n        for (auto &elem : q) {\n            ll c = m - elem.fi;\n            if (elem.fi <= c) {\n                if (elem.fi == c) ans += 1;\n                else ans += max(1ll, (max(elem.se, q[c]) - min(elem.se, q[c])));\n            }\n        }\n        cout << ans << \'\\n\';\n    }\n}\n']",,,"['constructive algorithms', 'greedy', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. M-arrays.json,https://codeforces.com//blog/entry/88677,Let s take each number modulo Now let be the amount of in array If then all should be put in a single array answer increases by For each number we put it in an array In this array the amount of and the amount of should differ not more than by that s why we need to make arrays containing a single number or that is more common 
https://codeforces.com//contest/1406/problem/B,725449,B,1406B,1406,B. Maximum Product,You are given an array of integers a 1 a 2 ldots a n Find the maximum possible value of a ia ja ka la t among all five indices i j k l t i j k l t ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl '\\n'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\nvoid solve(){\n  int n;\n  cin >> n;\n  vl a(n); \n  int pos = 0;\n  ll best = -1e18;\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    if(a[i] > 0)pos++;\n    if(a[i] == 0)best = 0;\n  }\n  sort(all(a),greater<int>());\n\n  for(int j = 0;j<=5;j++){\n    ll p = 1;\n\n    for(int i=0;i<j;i++){\n      p*= a[i];\n    }\n    int falta = 5 - j;\n    for(int i = 0;i<falta;i++){\n      p*=a[n-1-i];\n    }\n    best = max(best,p);\n  }\n\n  cout << best << endl;\n}\n\nint32_t main(){\n  FASTIO;\n  int t;\n  cin >> t;\n  while(t--){\n    solve();\n  }\n}""]",,,"['brute force', 'dp', 'greedy', 'implementation', 'sortings']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Maximum Product.json,https://codeforces.com//blog/entry/82560,First if all numbers are less than then you should print the product of the five biggest numbers of them Otherwise the maximum product must be non negative Sort the numbers by their absolute value from big to small If the first five numbers product is positive then print it Then we can always change one of the five to one of the other numbers to make this product positive Enumerate which one to replace and you can solve this problem in time 
https://codeforces.com//contest/1484/problem/B,931265,B,1484B,1484,B. Restore Modulo,For the first place at the competition Alex won many arrays of integers and was assured that these arrays are very expensive After the award ceremony Alex decided to sell them There is a rule in arrays pawnshop you can sell array only if it can be compressed to a generator This generator takes four non negative numbers n m c s n and m must be positive s non negative and for c it must be true that 0 leq c m The array a of length n is created according to the following rules a 1 s bmod m here x bmod y denotes remainder of the division of x by y a i a i 1 c bmod m for all i such that 1 i le n For example if n 5 m 7 c 4 and s 10 then a 3 0 4 1 5 Price of such an array is the value of m in this generator Alex has a question how much money he can get for each of the arrays Please help him to understand for every array whether there exist four numbers n m c s that generate this array If yes then maximize m ,"['#include<bits/stdc++.h>\n#define R register\n#define N 1000201\n\nint z,f,a[N],b[N];\n\ninline void solve(){\n\tz=-1,f=-1;\n\tR int n;\n\tscanf(""%d"",&n);\n\tfor(R int i=1;i<=n;++i) scanf(""%d"",&a[i]);\n\tfor(R int i=1;i<n;++i){\n\t\tR int qwq=a[i+1]-a[i];\n\t\tif(qwq>0){\n\t\t\tif(z==-1) z=qwq;\n\t\t\telse if(qwq!=z){\n\t\t\t\tprintf(""-1\\n"");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t} else{\n\t\t\tqwq=-qwq;\n\t\t\tif(f==-1) f=qwq;\n\t\t\telse if(qwq!=f){\n\t\t\t\tprintf(""-1\\n"");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif(f==-1||z==-1) return (void)printf(""0\\n"");\n\tR int m=z+f;\n\tb[1]=a[1];\n\tif(a[1]>=m){\n\t\tprintf(""-1\\n"");\n\t\treturn;\n\t}\n\tfor(R int i=2;i<=n;++i){\n\t\tb[i]=(b[i-1]+z)%m;\n\t\tif(b[i]!=a[i]){\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(""%d %d\\n"",m,z);\n\t\n}\n\nint main(){\n\tR int T;\n\tstd::cin>>T;\n\twhile(T--)\n\t\tsolve();\n}']",,,"['implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Restore Modulo.json,https://codeforces.com//blog/entry/88963,Handle the case of c 0 separately For this check whether for every i from 1 i n there holds an equality arr i arr i 1 or in other words all numbers are the same If this is true then the modulo can be arbitrarily large Otherwise if arr i arr i 1 holds for at least one i then c must equal zero but we already know that it s not the case so the answer is 1 Ok now c 0 and no two consecutive numbers coincide Note that x c modm is either x c or x m c So all positive differences between pairs of consecutive numbers must be the same as well as all negative differences Otherwise the answer is 1 If there is no positive difference or similarly if there is no negative difference then the modulo can be arbitrarily large Otherwise the modulo has to equal their sum c m c m After we find out m and c it only remains to check if they in fact generate our sequence 
https://codeforces.com//contest/1862/problem/F,2177633,F,1862F,1862,F. Magic Will Save the World,A portal of dark forces has opened at the border of worlds and now the whole world is under a terrible threat To close the portal and save the world you need to defeat n monsters that emerge from the portal one after another Only the sorceress Vika can handle this She possesses two magical powers water magic and fire magic In one second Vika can generate w units of water mana and f units of fire mana She will need mana to cast spells Initially Vika have 0 units of water mana and 0 units of fire mana Each of the n monsters that emerge from the portal has its own strength expressed as a positive integer To defeat the i th monster with strength s i Vika needs to cast a water spell or a fire spell of at least the same strength In other words Vika can spend at least s i units of water mana on a water spell or at least s i units of fire mana on a fire spell Vika can create and cast spells instantly Vika can cast an unlimited number of spells every second as long she has enough mana for that The sorceress wants to save the world as quickly as possible so tell her how much time she will need ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY int\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e9)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,A,B,a[MAXN];\nbool vis[1000005];\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tTY ans=INF,sum=0;\n\t\tA=qr();B=qr();n=qr();\n\t\tFor(i,1,n)a[i]=qr(),sum+=a[i];\n\t\tFor(i,0,n*10000)vis[i]=0;vis[0]=1;\n\t\tFor(i,1,n)Rof(j,n*10000,a[i])vis[j]|=vis[j-a[i]];\n\t\tFor(i,0,n*10000)if(vis[i])ans=min(ans,max(i==0?0:Ceil(i,A),sum-i==0?0:Ceil(sum-i,B)));\n\t\tqw(ans,\'\\n\');\n\t}\n    return 0;\n}']",,,"['binary search', 'bitmasks', 'brute force', 'dp']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Magic Will Save the World.json,https://codeforces.com//blog/entry/119715,First let s note that Vika can defeat all the monsters at once in the last second There is no point in spending mana gradually Now let s say we know how many seconds Vika will accumulate mana before spending it Then we also know how much mana she will have accumulated by that time How should she spend it Note that the total strength of the monsters is given to us Therefore it is enough for us to spend as much of the available water mana as possible so that there is enough fire mana left for the remaining monsters This is a well known knapsack problem Finally let s note that we don t need to iterate over the number of seconds and build the knapsack each time It is enough to build it initially and then iterate over how much water mana we will spend and whether we will have enough fire mana left for the rest 
https://codeforces.com//contest/1132/problem/G,307701,G,1132G,1132,G. Greedy Subsequences,For some array c let s denote a as a sequence of indices p 1 p 2 p l such that 1 le p 1 p 2 dots p l le c and for each i in 1 l 1 p i 1 is the minimum number such that p i 1 p i and c p i 1 c p i You are given an array a 1 a 2 dots a n For each its subsegment of length k calculate the length of its longest greedy subsequence ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 1000 * 1000 + 7;\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nint t[4 * MX];\nint md[4 * MX];\n\nvoid push(int v) {\n    md[v + v] += md[v];\n    md[v + v + 1] += md[v];\n    md[v] = 0;\n}\n\nint gv(int v) {\n    return t[v] + md[v];\n}\n\nvoid pop(int v) {\n    t[v] = max(gv(v + v), gv(v + v + 1));\n}\n\nvoid ad(int v, int tl, int tr, int l, int r, int x) {\n    if (r < tl || l > tr) {\n        return;\n    }\n    if (tl >= l && tr <= r) {\n        md[v] += x;\n    } else {\n        push(v);\n        int tm = (tl + tr) >> 1;\n        ad(v + v, tl, tm, l, r, x);\n        ad(v + v + 1, tm + 1, tr, l, r, x);\n        pop(v);\n    }\n}\n\nvector<int> g[MX];\nint tin[MX], tout[MX];\nint timer = 1;\nint a[MX];\n\nvoid dfs(int v) {\n    tin[v] = timer;\n    timer++;\n    for (int to : g[v]) {\n        dfs(to);\n    }\n    tout[v] = timer - 1;\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<pair<int, int> > st;\n    st.emplace_back(INF, n + 1);\n    for (int i = n; i >= 1; i--) {\n        while (!st.empty() && st.back().first <= a[i]) {\n            st.pop_back();\n        }\n        if (st.back().second != n + 1) {\n            g[st.back().second].push_back(i);\n        }\n        st.emplace_back(a[i], i);\n    }\n    for (int i = n; i >= 1; i--) {\n        if (tin[i] == 0) {\n            dfs(i);\n        }\n    }\n    int l = 1, r = 1;\n    auto mvr = [&]() {\n        ad(1, 1, n, tin[r], tout[r], 1);\n        r++;\n    };\n    auto mvl = [&]() {\n        ad(1, 1, n, tin[l], tin[l], -INF);\n        l++;\n    };\n    for (int i = 1; i + k - 1 <= n; i++) {\n        int gl = i, gr = i + k;\n        while (r < gr) {\n            mvr();\n        }\n        while (l < gl) {\n            mvl();\n        }\n        cout << gv(1) << ""\\n"";\n    }\n    return 0;\n}\n\n']",,,"['data structures', 'dp', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Greedy Subsequences.json,https://codeforces.com/blog/entry/65752,Let s calculate for each position position the closest greater from the right element to and add directed edge from to Then we will get oriented forest or tree if we d add fictive vertex where all edges are directed to some root So we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree Then the answer itself is a longest path up to the tree consisting only from marked vertices Key observation is next if and are marked and is an ancestor of then any vertex on path from to is also marked So the longest path up to the tree consisting only from marked vertices has length equal to a number of marked vertices on path to the root And we have three types of queries mark a vertex unmark a vertex and calculate maximum number of marked vertices among all paths to the root It can be done with Segment Tree on Euler Tour of the tree if we calculate and for each vertex in dfs order then marking unmarking is just adding to a segment and maximum among all paths is a maximum on the whole tree Result time complexity is and space complexity is 
https://codeforces.com//contest/1728/problem/G,1534228,G,1728G,1728,G. Illumination,Consider a segment 0 d of the coordinate line There are n lanterns and m points of interest in this segment For each lantern you can choose its power an integer between 0 and d inclusive A lantern with coordinate x illuminates the point of interest with coordinate y if x y is less than or equal to the power of the lantern A way to choose the power values for all lanterns is considered if every point of interest is illuminated by at least one lantern You have to process q queries Each query is represented by one integer f i To answer the i th query you have to add a lantern on coordinate f i calculate the number of valid ways to assign power values to all lanterns and print it modulo 998244353 remove the lantern you just added ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int P = 998244353;\n\nint add(int x, int y) {\n\tif (x + y >= P) return x + y - P;\n\treturn x + y;\n}\n\nint sub(int x, int y) {\n\tif (x < y) return x - y + P;\n\treturn x - y;\n}\n\nint mul(int x, int y) { return 1ull * x * y % P; }\n\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn ans;\n}\n\ninline void upd(int& x, int y) { x = add(x, y); }\n\nconst int N = 3e5 + 5;\n\nint ans[N], p[N], a[25], c[25][25], v[25][25];\nint d, n, m, q;\n\nint getpos(int x) {\n\tint ans = 0;\n\twhile (ans < m && a[ans + 1] <= x) ++ans;\n\treturn ans;\n}\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\td = read();\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++) p[i] = read();\n\tfor (int i = 1; i <= m; i++) a[i] = read();\n\tsort(a + 1, a + m + 1);\n\tfor (int l = 0; l <= m + 1; l++) {\n\t\tfor (int r = l; r <= m + 1; r++) c[l][r] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = getpos(p[i]);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, p[i] - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - p[i]);\n\t\t\t\tc[l][r] = mul(c[l][r], lim);\n\t\t\t\t// fprintf(stderr, ""c[%d][%d] = %d, lim = %d\\n"", l, r, c[l][r], lim);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tint now = 1, las = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tnow = mul(now, c[las][j + 1]);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tnow = mul(now, c[las][m + 1]);\n\t\tlas = 0;\n\t\tif (__builtin_popcount(i) & 1) now = sub(0, now);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tupd(v[las][j + 1], now);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tupd(v[las][m + 1], now);\n\t}\n\tfor (int x = 1; x <= d - 1; x++) {\n\t\tint pos = getpos(x);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, x - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - x);\n\t\t\t\tupd(ans[x], mul(lim, v[l][r]));\n\t\t\t}\n\t\t}\n\t}\n\tq = read();\n\twhile (q--) {\n\t\tint x = read();\n\t\tprintf(""%d\\n"", ans[x]);\n\t}\n}']",,,"['binary search', 'bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'two pointers']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Illumination.json,https://codeforces.com//blog/entry/106805,Let s start without the queries How to calculate the number of ways for the given lanterns First it s much easier to calculate the number of bad ways some point of interest is not illuminated If at least one point of interest is not illuminated then all lanterns have power lower than the distance from them to this point of interest More importantly it s less than Thus the number of good ways is minus the number of bad ways Let s use inclusion exclusion For a mask of non illuminated points of interest let s calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated All other points can be either illuminated or not Let s call it With the values for all masks the answer is the sum of over all masks How to calculate the value for the mask First let s do it in for each mask Each lantern can have any power from to the distance to the closest point of interest inside the mask non inclusive Thus we can iterate over the lanterns and find the closest point to each of them then multiply the number of ways for all lanterns Let s calculate it the other way around Initialize the answers for the masks with Then iterate over the lantern and the point of interest that will be the closest non illuminated one to this lantern Let the distance between them be some value Which masks will this pair affect Let the lantern be to the right of that point of interest The opposite can be handled similarly All points to the left of the chosen point can be in either state All points between the chosen one and the lantern must be illuminated All points to the right of the lantern and with distance smaller than must also be illumunated All point to the right of these can be in either state Thus the masks look like 1000 000 where 1 denotes the chosen non illuminated point All masks that correspond to this template will be multiplied by You have to be careful when there are two points of interest with the same distance to some lantern one to the left of it and one to the right of it In particular in one case you should force illumination on all points with distance In another case you should force illumination on all points with distance How to multiply fast enough We ll use a technique called sum over subsets Let s express the template in terms of submasks For a template 100000 all submasks of 111100000111 will be multiplied by However we accidentally multiplied masks of form 000000 too Let s cancel them by dividing the submasks of 111000000111 by Record all multiplications for all pairs them force push them into submasks with sum over subsets well product over subsets in this case Now we have the values of for all masks in basically give or take the time to find the points that must be forced illuminated extra from lower bound or two pointers which is not really faster Now for the queries How does the answer change after an extra lantern is added Again let s iterate over the closest point of interest and find the mask template All masks corresponding to this template will get multiplied by Thus the answer will change by the sum of values of these masks multiplied by including the inclusion exclusion coefficient How to handle that Well yet another sum over subsets Just collect the sum of values over the submasks beforehand and use these during the query That gives us an per query Overall complexity 
https://codeforces.com//contest/1706/problem/C,1466353,C,1706C,1706,C. Qpwoeirut And The City,Qpwoeirut s city can be described as a row of n buildings the i th 1 le i le n of which is h i floors high You can assume that the height of every floor in this problem is equal Therefore building i is taller than the building j if and only if the number of floors h i in building i is larger than the number of floors h j in building j Building i is if it is taller than both building i 1 and building i 1 and both of them exist Note that neither the 1 st nor the n th building can be cool To remodel the city Qpwoeirut needs to maximize the number of cool buildings To do this Qpwoeirut can build additional floors on top of any of the buildings to make them taller Note that he cannot remove already existing floors Since building new floors is expensive Qpwoeirut wants to minimize the number of floors he builds Find the minimum number of floors Qpwoeirut needs to build in order to maximize the number of cool buildings ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1e5 + 5;\n\nint a[N], val[N];\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\trep(i, 1, n) a[i] = read();\n\t\trep(i, 2, n - 1) val[i] = max(0, max(a[i - 1], a[i + 1]) - a[i] + 1);\n\t\tif (n % 2 == 1) {\n\t\t\tlong long ans = 0;\n\t\t\tfor (int i = 2; i <= n - 1; i += 2) {\n\t\t\t\tans += val[i];\n\t\t\t}\n\t\t\tprintf(""%lld\\n"", ans);\n\t\t} else {\n\t\t\tlong long ans = 1e18, sum = 0;\n\t\t\tfor (int i = 3; i <= n - 1; i += 2) {\n\t\t\t\tsum += val[i];\n\t\t\t}\n\t\t\tans = sum;\n\t\t\tfor (int i = 2; i <= n - 2; i += 2) {\n\t\t\t\tsum += val[i];\n\t\t\t\tsum -= val[i + 1];\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\tprintf(""%lld\\n"", ans);\n\t\t}\n\t}\n}']",,,"['dp', 'flows', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Qpwoeirut And The City.json,https://codeforces.com//blog/entry/105008,The first observation to be made is that no two adjacent building can both be cool at the same time This means that for odd there must be cool buildings arranged in the following configuration For even there must be cool buildings This means that exactly one pair of adjacent buildings in the city is normal meaning that the buildings must be arranged in one of the following configurations For odd the solution is relatively simple Just find the total floors necessary to make each of the alternating buildings starting from the 2nd building cool and that is the answer For even the solution is more complex First find the number of floors necessary to get to the first of the configurations shown above Then loop through each of the subsequent configurations each time using the previous configuration to get the number of floors necessary for the new configuration in time This enables a solution in time For example in the 4th test case from the example in the problem statement the possible configurations of cool buildings are The number of floors necessary to reach each of these configurations are 1st configuration 5 2 6 3 7 3 2nd configuration 7 3 6 6 3rd configuration 6 3 5 5 4th configuration 5 2 4 1 The answer is the minimum of these values which is For even the floors necessary for every configuration can also be found in time using an alternating forward prefix sum array and an alternating backward prefix sum array 
https://codeforces.com//contest/1870/problem/D,2216417,D,1870D,1870,D. Prefix Purchase,You have an array a of size n initially filled with zeros a 1 a 2 ldots a n 0 You also have an array of integers c of size n Initially you have k coins By paying c i coins you can add 1 to all elements of the array a from the first to the i th element a j mathrel 1 for all 1 leq j leq i You can buy any c i any number of times A purchase is only possible if k geq c i meaning that at any moment k geq 0 must hold true Find the lexicographically largest array a that can be obtained An array a is lexicographically smaller than an array b of the same length if and only if in the first position where a and b differ the element in array a is smaller than the corresponding element in b ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint n, k;\nint c[N];\nint cnt[N];\nint a[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> c[i];\n\t}\n\tR(i, n - 1, 0) {\n\t\tc[i] = min(c[i], c[i + 1]);\n\t}\n\tcin >> k;\n\tL(i, 1, n) {\n\t\ta[i] = 0;\n\t}\n\tint cur = 1e9 + 7;\n\tL(i, 1, n) {\n\t\tint ban = c[i] - c[i - 1];\n\t\tint buy = ban == 0 ? cur : min(cur, k / ban);\n\t\ta[i] = buy;\n\t\tcur = buy;\n\t\tk -= buy * ban;\n\t}\n\tL(i, 1, n) {\n\t\tcout << a[i] << ' ';\n\t} \n\tcout << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]",,,"['greedy', 'implementation', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Prefix Purchase.json,https://codeforces.com//blog/entry/120524,TutorialNote that if there is a prefix for which there is a longer prefix that costs less then it is useless to buy the shorter prefix All its purchases can be replaced with purchases of the longer prefix and the answer will only improve Therefore we can replace each with the minimum among the minimum price of a prefix of length at least After this we will have Now let s solve the problem greedily We want to maximize the first element of the resulting array It will be equal to since we cannot buy more prefixes of length is the smallest price After buying prefixes of length we will have some coins left Now we can replace some purchases of with purchases of longer prefixes to improve the answer How much will it cost to replace with It will cost coins Moreover note that to replace with we can sequentially replace with with with since This means that we can make only replacements of purchases of with purchases of Let s say we have maximized the first elements of the answer and we have coins left Now we want to replace some purchases of with How many replacements can we make We can afford to make no more than replacements if then we can replace all and we cannot replace more purchases than we have made so no more than replacements this is the number of purchases of Therefore as we want to maximize Finally subtract the cost of replacements from the number of coins and move on to 
https://codeforces.com//contest/282/problem/D,2738,D,282D,282,D. Yet Another Number Game,Since most contestants do not read this part I have to repeat that Bitlandians are quite weird They have their own jobs their own working method their own lives their own sausages and their own games Since you are so curious about Bitland I ll give you the chance of peeking at one of these games BitLGM and BitAryo are playing yet another of their crazy looking genius needed Bitlandish games They ve got a sequence of non negative integers The players make moves in turns BitLGM moves first Each player can and must do one of the two following actions in his turn Take one of the integers we ll denote it as Choose integer And then decrease by that is apply assignment Choose integer And then decrease all by that is apply assignment for all The player who cannot make a move loses You re given the initial sequence Determine who wins if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define LL long long\n#define maxn 3010100\n#define maxe 210000\n\ndouble sq5 = sqrt(5.0);\n\nint match(int a, int b){\n\tint j = b - a;\n\tint aj = floor(j * (sq5 + 1.0)/2.0);\n\tif(aj == a)\n\t\treturn 1;\n\t// printf(""j = %d, aj = %d\\n"", j, aj);\n\treturn 0;\n}\nint sheng[301][301][301];\nint main()\n{\n\tint i,j,k,cnt=0;\n\tfor(i=0;i<301;i++)\n\t\tfor(j=0;j<301;j++)\n\t\t{\n\t\t\tfor(k=0;k<301;k++)if(!sheng[i][j][k])\n\t\t\t{\n\t\t\t\tint M=min(i,min(j,k));\n\t\t\t\tfor(int t=1;t+M<301;t++)\n\t\t\t\t{\n\t\t\t\t\tif(t+i<301)\n\t\t\t\t\t\tsheng[t+i][j][k]=1;\n\t\t\t\t\tif(t+j<301)\n\t\t\t\t\t\tsheng[i][j+t][k]=1;\n\t\t\t\t\tif(t+k<301)\n\t\t\t\t\t\tsheng[i][j][k+t]=1;\n\t\t\t\t\tif(t+j<301&&t+k<301&&t+i<301)\n\t\t\t\t\t\tsheng[i+t][j+t][k+t]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tscanf(""%d"",&n);\n\t\tif(n==1)\n\t\t{\n\t\t\tscanf(""%d"",&i);\n\t\t\tif(i)\n\t\t\t\tputs(""BitLGM"");\n\t\t\telse\n\t\t\t\tputs(""BitAryo"");\n\t\t}\n\t\telse if(n==2)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(""%d%d"",&a,&b);\n\t\t\tif(a > b)\n\t\t\tswap(a, b);\n\t\tif(match(a, b)){\n\t\t\tprintf(""BitAryo\\n"");\n\t\t}else{\n\t\t\tprintf(""BitLGM\\n"");\n\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(""%d%d%d"",&i,&j,&k);\n\t\t\tint ii,jj,kk;\n\t\t\tii=min(min(i,j),k);\n\t\t\tkk=max(max(i,j),k);\n\t\t\tjj=i+j+k-ii-kk;\n\t\t\ti=ii,j=jj,k=kk;\n\n\t\t\tif(sheng[i][j][k])\n\t\t\t\tputs(""BitLGM"");\n\t\t\telse\n\t\t\t\tputs(""BitAryo"");\n\t\t}\n\t\t//printf(""%d\\n"",cnt);\n}']",,,"['dp', 'games']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Yet Another Number Game.json,https://codeforces.com//blog/entry/6999,For n 1 everything is clear If a1 0 then BitAryo wins otherwise BitLGM is the winner For n 2 define win i j Whether i j is a Winning position It s easy to calculate win i j for all i and j using a loop Checking all possible moves This leads us to an O n3 solution For n 3 Everything is similar to NIM With the same statement of proof as for NIM i j k is a winning position if and only if i xor j xor k 0 Don t forget the parentheses in code Complexity O 1 One can also solve this case using DP We define lose i j Least k such that i j k is a losing position lose2 i j Least k such that k k i k i j is a losing position and win i j k just as the case with n 2 As in the codes below one can calculate all these values in O n3 Using the same DP strategy for n 2 and the O 1 algorithm for n 3 and n 1 leads us to a total complexity of O n2 which was not necessary in this contest 
https://codeforces.com//contest/1367/problem/F1,650998,F1,1367F1,1367,F1. Flying Sort  Easy Version ,You are given an array a of n integers You can perform the following operations on array elements choose any index i 1 le i le n and move the element a i to the of the array choose any index i 1 le i le n and move the element a i to the of the array For example if n 5 a 4 7 2 3 9 then the following sequence of operations can be performed after performing the operation of the first type to the second element the array a will become 7 4 2 3 9 after performing the operation of the second type to the second element the array a will become 7 2 3 9 4 You can perform operations of any type any number of times in any order Find the minimum total number of operations of the first and second type that will make the a array sorted in non decreasing order In other words what is the minimum number of operations that must be performed so the array satisfies the inequalities a 1 le a 2 le ldots le a n ,"[""#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nvoid f()\n{\n\tint n;\n\tcin >> n;\n\tint dp[n + 1] = {0};\n\tint arr[n + 1];\n\tarr[0] = -5;\n\tvector<int> comp;\n\tfl(i,1,n + 1)\n\t{\n\t\tcin >> arr[i];\n\t\tcomp.pb(arr[i]);\n\t}\n\tsort(comp.begin(), comp.end());\n\tcomp.resize(unique(comp.begin(), comp.end()) - comp.begin());\n\tfl(i,1,n + 1)\n\t{\n\t\tarr[i] = upper_bound(comp.begin(), comp.end(),arr[i]) - comp.begin();\n\t}\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 0;\n\t}\n\tint ans = 0;\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 1;\n\t\tfl(j,0,i)\n\t\t{\n\t\t\tif(arr[j] + 1 ==  arr[i])\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i],dp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tans = max(ans,dp[i]);\n\t}\n\tcout << n - ans << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}""]",,,"['dp', 'greedy', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F1. Flying Sort  Easy Version .json,https://codeforces.com//blog/entry/78864,Let s replace each number ai with the number of unique numbers less than ai For example the array a 3 7 1 2 1 3 will be replaced by 2 3 0 1 0 2 Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array a is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let dp i be the maximum length of a subsequence ending in position i To calculate it we will find the closest past position which also has the value a i and the position with value a i 1 lower numbers cannot be used since a i 1 must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
https://codeforces.com//contest/1870/problem/B,2216415,B,1870B,1870,B. Friendly Arrays,You are given two arrays of integers a 1 ldots a n of length n and b 1 ldots b m of length m You can choose any element b j from array b 1 leq j leq m and for 1 leq i leq n perform a i a i b j You can perform any number of such operations After all the operations the value of x a 1 oplus a 2 oplus ldots oplus a n will be calculated Find the minimum and maximum values of x that could be obtained after performing any set of operations Above is the bitwise OR operation and oplus is the bitwise XOR operation ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint a[N], b[N];\nint n, m;\nvoid Main() {\n\tcin >> m >> n;\n\tL(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tint op = 0;\n\tL(i, 1, m) {\n\t\top ^= b[i];\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tif(m & 1) {\n\t\tans1 = op;\n\t\tL(i, 1, n) {\n\t\t\top |= a[i];\n\t\t}\n\t\tans2 = op;\n\t} else {\n\t\tans2 = op;\n\t\tL(i, 1, n) {\n\t\t\top &= ~a[i];\n\t\t}\n\t\tans1 = op;\n\t}\n\tcout << ans1 << ' ' << ans2 << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]",,,"['bitmasks', 'greedy', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. Friendly Arrays.json,https://codeforces.com//blog/entry/120524,TutorialNote that after performing the operation on which has some bit set to 1 this bit will become 1 for all numbers in and will remain so as a bit cannot change from 1 to 0 in the result of an OR operation If is even then in the final XOR this bit will become 0 as it will be equal to the XOR of an even number of ones If is odd then this bit will be 1 in the final XOR Therefore if is even by performing the operation on we set all the bits that are 1 in to 0 in the final XOR If is odd we do the opposite and set these bits to 1 So if is even the XOR does not increase when applying the operation which means that to obtain the minimum possible XOR we need to apply the operation to all the numbers in and the maximum XOR will be the original XOR For odd it is the opposite the minimum is the original XOR and the maximum is obtained after applying the operation to all elements in To apply the operation to all elements in it is sufficient to calculate their bitwise OR and apply the operation to the array with it 
https://codeforces.com//contest/431/problem/D,9655,D,431D,431,D. Random Task,One day after a difficult lecture a diligent student Sasha saw a graffitied desk in the classroom She came closer and read Find such positive integer that among numbers there are exactly numbers which binary representation contains exactly digits one The girl got interested in the task and she asked you to help her solve it Sasha knows that you are afraid of large numbers so she guaranteed that there is an answer that doesn t exceed ,"['#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nlong long l,r,mid,ans,m,k;\nlong long dp[70][70][2],x[70];\nlong long find(long long now){\n    int len=0;\n    for (;now;){len++; x[len]=now%2; now=now/2;}\n    memset(dp,0x00,sizeof dp);\n    dp[len][1][1]=1;\n    for (int i=len-1;i;i--)\n        for (int j=1;j<=len;j++){\n            dp[i][j][0]=dp[i+1][j-1][0]+dp[i+1][j][0];\n            if (x[i]==1){\n                dp[i][j][0]+=dp[i+1][j][1]; dp[i][j][1]=dp[i+1][j-1][1];\n            } else dp[i][j][1]=dp[i+1][j][1];\n        }\n    long long ans=dp[1][k][0]+dp[1][k][1];// if (kk==5) cout<<ans<<endl;\n    memset(dp,0x00,sizeof dp);\n    if (len==1) return ans;\n    dp[1][1][0]=1; if (k==1) ans++;\n    for (int i=2;i<len;i++){\n        for (int j=1;j<=len;j++)\n            dp[i][j][0]=dp[i-1][j][0]+dp[i-1][j-1][0];\n        ans+=dp[i][k][0];\n    }\n    return ans;\n}\nint main(){\n    scanf(""%I64d%I64d"",&m,&k);\n    l=1; r=1e18+1;\n    while (l<r){\n        mid=l+r>>1;\n        long long num=find(mid*2)-find(mid); //cout<<mid<<"" ""<<num<<endl;\n        if (num<m) l=mid+1; else {r=mid; ans=mid;}\n    }\n    cout<<ans<<endl;\n}\n            ']",,,"['binary search', 'bitmasks', 'combinatorics', 'dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Random Task.json,https://codeforces.com//blog/entry/12369,We will search by binary search Such function is monotone because the amount of numbers with exactly 1 bits on a segment more or equal than amount of such numbers on segment Last statement is correct because of and have equals number of 1 bits To find the amount of numbers on segment which have exactly 1 bits it is sufficient to can calculate this number for segment then the answer will be Let s understand how we can calculate Iterate number of bit will be the first from biggest to smallest which is different in X and numbers which amount we want to calculate Let the first difference will be in th bit it s possible if in X this bit equals to 1 because we consider all numbers do not exceed X Then other smallest bits we can choose in any way but only amount of 1 bits must equals to We can do this in ways where the number of 1 bits in X bigger then and binomailany factor Finally you should not forget about X if it of course has k one bits 6676713 
https://codeforces.com//contest/1627/problem/E,1262394,E,1627E,1627,E. Not Escaping,Major Ram is being chased by his arch enemy Raghav Ram must reach the top of the building to escape via helicopter The building however is on fire Ram must choose the optimal path to reach the top of the building to lose the minimum amount of health The building consists of n floors each with m rooms each Let i j represent the j th room on the i th floor Additionally there are k ladders installed The i th ladder allows Ram to travel from a i b i to c i d i but Ram also gains h i health points if he uses the ladder i If Ram is on the i th floor he can move either left or right Travelling across floors however is treacherous If Ram travels from i j to i k he loses j k cdot x i health points Ram enters the building at 1 1 while his helicopter is waiting at n m What is the minimum amount of health Ram loses if he takes the most optimal path Note this answer may be negative in which case he gains health Output if no matter what path Ram takes he cannot escape the clutches of Raghav ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntemplate<class T>bool umin(T&x,const T&y){return y<x?x=y,1:0;}\ntemplate<class T>bool umax(T&x,const T&y){return x<y?x=y,1:0;}\nconst int N=100005;\nconst long long INFLL=0X3F3F3F3F3F3F3F3FLL;\nint T,n,m,K,x[N],aa[N],bb[N],cc[N],dd[N],hh[N];\nlong long dp[N];\nvector<pair<int,int> >in[N],out[N];\nint main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d%d"",&n,&m,&K);\n\t\trep(i,1,n)scanf(""%d"",&x[i]);\n\t\trep(i,1,n)in[i].clear(),out[i].clear();\n\t\trep(i,1,K){\n\t\t\tscanf(""%d%d%d%d%d"",&aa[i],&bb[i],&cc[i],&dd[i],&hh[i]);\n\t\t\tin[aa[i]].eb(bb[i],i);\n\t\t\tout[cc[i]].eb(dd[i],i);\n\t\t\tdp[i]=INFLL;\n\t\t}\n\t\trep(i,1,n){\n\t\t\tif(i==1){\n\t\t\t\tout[i].eb(1,0);\n\t\t\t}\n\t\t\tsort(in[i].begin(),in[i].end());\n\t\t\tsort(out[i].begin(),out[i].end());\n\t\t\tmap<int,long long>f;\n\t\t\teach(x,out[i])if(get<1>(x)<INFLL){\n\t\t\t\tif(f.find(get<0>(x))==f.end()){\n\t\t\t\t\tf[get<0>(x)]=dp[get<1>(x)];\n\t\t\t\t}else{\n\t\t\t\t\tumin(f[get<0>(x)],dp[get<1>(x)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f.empty()){\n\t\t\t\tfor(auto it=f.begin();it!=f.end();++it){\n\t\t\t\t\tif(next(it)!=f.end()){\n\t\t\t\t\t\tumin(get<1>(*next(it)),get<1>(*it)+1LL*(get<0>(*next(it))-get<0>(*it))*x[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(auto it=prev(f.end());;--it){\n\t\t\t\t\tif(it!=f.begin()){\n\t\t\t\t\t\tumin(get<1>(*prev(it)),get<1>(*it)+1LL*(get<0>(*it)-get<0>(*prev(it)))*x[i]);\n\t\t\t\t\t}else break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto query=[&](int pos)->long long{\n\t\t\t\tauto it=f.lower_bound(pos);\n\t\t\t\tlong long res=INFLL;\n\t\t\t\tif(it!=f.end()){\n\t\t\t\t\tres=min(res,get<1>(*it)+1LL*(get<0>(*it)-pos)*x[i]);\n\t\t\t\t}\n\t\t\t\tif(it!=f.begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tres=min(res,get<1>(*it)+1LL*(pos-get<0>(*it))*x[i]);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t};\n\t\t\teach(x,in[i]){\n\t\t\t\tumin(dp[get<1>(x)],-hh[get<1>(x)]+query(get<0>(x)));\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tlong long ans=query(m);\n\t\t\t\tif(ans<1e18)printf(""%lld\\n"",ans);else printf(""NO ESCAPE\\n"");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['data structures', 'dp', 'implementation', 'shortest paths', 'two pointers']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Not Escaping.json,https://codeforces.com//blog/entry/99067,The building plan of the input consists of rooms which in the worst case is however most of these rooms are unimportant to us We can instead use a much reduced version of the building consisting of at most rooms both endpoints of each ladder as well as our starting and target rooms As every ladder connects a lower floor to a higher floor and is one directional we can process the rooms floor by floor from floor to floor On each floor let s sort all the rooms in non decreasing order Now we can use dynamic programming as well as the compression previously mentioned to calculate the minimum distance to get to all important rooms First we calculate the minimum cost to get to each room using a room on the same floor as an intermediate We can do this by iterating over the rooms on a floor twice once from left to right and then once from right to left Then for each room on the floor if it has a ladder going up from it we can update the value of the room where the ladder ends Our answer is the value of the target room This can be implemented in time per test case 
https://codeforces.com//contest/1852/problem/E,2099136,E,1852E,1852,E. Rivalries,Ntarsis has an array a of length n The of a subarray a l dots a r 1 leq l leq r leq n is defined as The largest value x such that a l dots a r contains x and neither a 1 dots a l 1 nor a r 1 dots a n contains x If no such x exists the power is 0 Call an array b a to a if the following holds The length of both a and b are equal to some n Over all l r where 1 leq l leq r leq n the power of a l dots a r equals the power of b l dots b r The elements of b are positive Ntarsis wants you to find a rival b to a such that the sum of b i over 1 leq i leq n is maximized Help him with this task ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[find(x)];\n    }\n};\ntemplate<class Info>\nstruct SegmentTree {\n    int n;\n    std::vector<Info> info;\n    SegmentTree() : n(0) {}\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    SegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nconstexpr i64 inf = 1E18;\n\nstruct Info {\n    i64 cnt = 0;\n    i64 sum = 0;\n    i64 min = inf;\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.cnt = a.cnt + b.cnt;\n    c.sum = a.sum + b.sum;\n    c.min = std::min(a.min, b.min);\n    return c;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::map<int, int> l, r;\n    for (int i = 0; i < n; i++) {\n        if (!l.count(a[i])) {\n            l[a[i]] = i;\n        }\n        r[a[i]] = i;\n    }\n    \n    std::vector<std::array<int, 3>> e;\n    std::vector<int> b(n);\n    for (auto [x, lx] : l) {\n        e.push_back({x, lx, r[x]});\n    }\n    std::reverse(e.begin(), e.end());\n    \n    std::map<int, int> f;\n    std::vector<std::array<int, 3>> v;\n    DSU dsu(n + 1);\n    std::vector<bool> fix(n);\n    for (auto [x, l, r] : e) {\n        auto it = f.lower_bound(l);\n        if (it != f.end() && it->second < r) {\n            continue;\n        }\n        v.push_back({x, l, r});\n        dsu.merge(l + 1, l);\n        dsu.merge(r + 1, r);\n        fix[l] = fix[r] = true;\n        b[l] = b[r] = x;\n        f[l] = r;\n        it--;\n        while (it != f.begin() && std::prev(it)->second > r) {\n            f.erase(std::prev(it));\n        }\n    }\n    \n    for (auto [x, l, r] : v) {\n        for (int i = dsu.find(l); i <= r; i = dsu.find(i)) {\n            dsu.merge(i + 1, i);\n            b[i] = x;\n        }\n    }\n    i64 ans = -1;\n    i64 sum = std::accumulate(b.begin(), b.end(), 0LL);\n    if (std::count(b.begin(), b.end(), 0) == 0) {\n        ans = sum;\n    }\n    int lz = n, rz = -1;\n    for (int i = 0; i < n; i++) {\n        if (b[i] == 0) {\n            lz = std::min(lz, i);\n            rz = i;\n        }\n    }\n    std::vector<int> p(n);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(), [&](int i, int j) {\n        return b[i] > b[j];\n    });\n    SegmentTree<Info> seg(n);\n    for (int i = 0; i < n; i++) {\n        if (!fix[i]) {\n            seg.modify(i, {1, b[i], b[i]});\n        }\n    }\n    int Val = -1;\n    int Lv = -1, Rv = -1;\n    for (int i = 0, j = 0, k = 0; i < v.size(); i++) {\n        auto [x, l, r] = v[i];\n        if (j < i) {\n            j = i;\n        }\n        while (j + 1 < v.size() && v[j][0] - 1 == v[j + 1][0]) {\n            j++;\n        }\n        int val = v[j][0] - 1;\n        if (val == 0) {\n            continue;\n        }\n        while (k < n && b[p[k]] > val) {\n            if (!fix[p[k]]) {\n                seg.modify(p[k], {0, 0, b[p[k]]});\n            }\n            k++;\n        }\n        int lv = std::min(l, lz);\n        int rv = std::max(r, rz);\n        i64 res = sum;\n        auto info = seg.rangeQuery(0, lv + 1);\n        if (info.cnt) {\n            res += 1LL * info.cnt * val - info.sum;\n        } else {\n            res += val - info.min;\n        }\n        info = seg.rangeQuery(rv, n);\n        if (info.cnt) {\n            res += 1LL * info.cnt * val - info.sum;\n        } else {\n            res += val - info.min;\n        }\n        if (lv < rv) {\n            info = seg.rangeQuery(lv + 1, rv);\n            res += 1LL * info.cnt * val - info.sum;\n        }\n        if (res > ans) {\n            ans = res;\n            Val = val;\n            Lv = lv;\n            Rv = rv;\n        }\n    }\n    if (Val != -1) {\n        int x = -1;\n        bool lt = false;\n        for (int i = Lv; i >= 0; i--) {\n            if (!fix[i]) {\n                if (b[i] < Val) {\n                    b[i] = Val;\n                    lt = true;\n                } else {\n                    if (x == -1 || b[i] < b[x]) {\n                        x = i;\n                    }\n                }\n            }\n        }\n        if (!lt) {\n            b[x] = Val;\n        }\n        x = -1;\n        lt = false;\n        for (int i = Rv; i < n; i++) {\n            if (!fix[i]) {\n                if (b[i] < Val) {\n                    b[i] = Val;\n                    lt = true;\n                } else {\n                    if (x == -1 || b[i] < b[x]) {\n                        x = i;\n                    }\n                }\n            }\n        }\n        if (!lt) {\n            b[x] = Val;\n        }\n        for (int i = Lv + 1; i < Rv; i++) {\n            if (!fix[i] && b[i] < Val) {\n                b[i] = Val;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << b[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Rivalries.json,https://codeforces.com//blog/entry/116940,Problem Credits buffering ArielShehter fast fourier transfem Analysis oursaco SolutionRead the hints We can remove all intervals that will not affect the power by iterating over them in decreasing order of value and maintain a segment tree that stores for each left endpoint of any processed intervals the right endpoint that corresponds to it Checking if an interval is strictly contained then becomes a range minimum query Assume that we know the value of the interval that we want to add We can immediately fill the value for the interior of all intervals that correspond to a value greater than However we also have to guarantee that is strictly contained by an interval with greater value so we can try each interval to contain If are no unfilled indices the left or right side of the interval then we want to replace the smallest filled on either side value with Otherwise we can just fill in all the unfilled indices with Note that it is also possible for to not be able to be contained by any interval Thus we can just try every possible in decreasing order and maintain the filled indices as we iterate There are only at most values of to check which is just the set of that does not appear in 
https://codeforces.com//contest/1511/problem/B,955213,B,1511B,1511,B. GCD Length,You are given three integers a b and c Find two positive integers x and y x 0 y 0 such that the decimal representation of x without leading zeroes consists of a digits the decimal representation of y without leading zeroes consists of b digits the decimal representation of gcd x y without leading zeroes consists of c digits gcd x y denotes the greatest common divisor GCD of integers x and y Output x and y If there are multiple answers output any of them ,"[""#include <bits/stdc++.h>\n\ntemplate <class T>\nconstexpr T power(T a, int64_t n) {\n  assert(n >= 0);\n  T res = n & 1 ? a : 1;\n  while (n >>= 1) {\n    a *= a;\n    if (n & 1) res *= a;\n  }\n  return res;\n}\n\ntemplate <int Id>\nclass DynamicModularInt64 {\n  using D = DynamicModularInt64;\n\n public:\n  static int64_t modulus() { return modulus_; }\n  static void modulus(int64_t modulus) {\n    assert(modulus >= 1);\n    modulus_ = modulus;\n  }\n  static D raw(uint64_t v) { return *reinterpret_cast<D*>(&v); }\n\n  DynamicModularInt64() : v_(0) {}\n  DynamicModularInt64(int64_t v)\n      : v_((v %= modulus()) < 0 ? v + modulus() : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  D& operator++() { return v_ = ++v_ == modulus_ ? 0 : v_, *this; }\n  D& operator--() { return --(v_ ? v_ : v_ = modulus_), *this; }\n  D operator+() const { return *this; }\n  D operator-() const { return raw(v_ ? modulus_ - v_ : 0); }\n  D& operator*=(D o) {\n    v_ = v_ * o.v_ - uint64_t((long double)v_ * o.v_ / modulus_) * modulus_;\n    v_ = int64_t(v_) < 0 ? v_ + modulus_ : v_;\n    v_ = v_ >= modulus_ ? v_ - modulus_ : v_;\n    return *this;\n  }\n  D& operator/=(D o) {\n    auto [inv, gcd] = extgcd(o.v_, modulus_);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  D& operator+=(D o) {\n    return v_ = int64_t(v_ += o.v_ - modulus_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n  D& operator-=(D o) {\n    return v_ = int64_t(v_ -= o.v_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n\n  friend D operator++(D& a, int) { return std::exchange(a, ++D(a)); }\n  friend D operator--(D& a, int) { return std::exchange(a, --D(a)); }\n  friend D operator*(D a, D b) { return a *= b; }\n  friend D operator/(D a, D b) { return a /= b; }\n  friend D operator+(D a, D b) { return a += b; }\n  friend D operator-(D a, D b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, D& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, D x) { return os << x.v_; }\n  friend bool operator==(D a, D b) { return a.v_ == b.v_; }\n  friend bool operator!=(D a, D b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int64_t, int64_t> extgcd(int64_t a, int64_t b) {\n    std::array<int64_t, 2> x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  static inline uint64_t modulus_ = std::numeric_limits<int64_t>::max();\n\n  uint64_t v_;\n};\n\nbool miller_rabin(int64_t n, std::initializer_list<int64_t> bases) {\n  using Mint = DynamicModularInt64<__COUNTER__>;\n  Mint::modulus(n);\n  int tz = __builtin_ctzll(n - 1);\n  for (Mint a : bases) {\n    if (a == 0) continue;\n    a = power(a, n >> tz);\n    int i = tz;\n    while (a != 1 and a != -1 and i--) a *= a;\n    if (a != -1 and i != tz) return false;\n  }\n  return true;\n}\n\nbool is_prime(int64_t n) {\n  if (n < 2 or n % 6 % 4 != 1) return n == 2 or n == 3;\n  if (n < 291831) return miller_rabin(n, {126401071349994536});\n  if (n < 1050535501) return miller_rabin(n, {336781006125, 9639812373923155});\n  if (n < 273919523041)\n    return miller_rabin(n, {15, 7363882082, 992620450144556});\n  if (n < 47636622961201)\n    return miller_rabin(n, {2, 2570940, 211991001, 3749873356});\n  if (n < 7999252175582851)\n    return miller_rabin(n, {2, 4130806001517, 149795463772692060,\n                            186635894390467037, 3967304179347715805});\n  if (n < 585226005592931977)\n    return miller_rabin(\n        n, {2, 123635709730000, 9233062284813009, 43835965440333360,\n            761179012939631437, 1263739024124850375});\n  return miller_rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n}\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  vector<int> x, y;\n  for (int i : Rep(9)) {\n    int p = power(10, i);\n    while (not is_prime(p)) ++p;\n    x.push_back(p);\n    ++p;\n    while (not is_prime(p)) ++p;\n    y.push_back(p);\n  }\n  DUMP(x);\n  DUMP(y);\n  for (int tt = scan(); tt--;) {\n    int a = scan() - 1;\n    int b = scan() - 1;\n    int c = scan() - 1;\n    cout << x[a - c] * power(10, c) << ' ' << y[b - c] * power(10, c) << '\\n';\n  }\n}\n""]",,,"['constructive algorithms', 'math', 'number theory']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. GCD Length.json,https://codeforces.com//blog/entry/89634,The easiest way to force some gcd to be of some fixed length is to use the divisibility rules for or if the number produced by the last digits is divisible by then is also divisible by same goes for and One of the possible constructions is the following let and Since and are pairwise prime gcd is Overall complexity per testcase 
https://codeforces.com//contest/1385/problem/C,675200,C,1385C,1385,C. Make It Good,You are given an array a consisting of n integers You have to find the length of the smallest shortest of elements you need to erase from a to make it a array Recall that the prefix of the array a a 1 a 2 dots a n is a subarray consisting several first elements the prefix of the array a of length k is the array a 1 a 2 dots a k 0 le k le n The array b of length m is called if you can obtain a array c c 1 le c 2 le dots le c m from it repeating the following operation m times initially c is empty select either the first or the last element of b remove it from b and append it to the end of the array c For example if we do 4 operations take b 1 then b m then b m 1 and at last b 2 then b becomes b 3 b 4 dots b m 3 and c b 1 b m b m 1 b 2 Consider the following example b 1 2 3 4 4 2 1 This array is because we can obtain array c from it by the following sequence of operations take the first element of b so b 2 3 4 4 2 1 c 1 take the last element of b so b 2 3 4 4 2 c 1 1 take the last element of b so b 2 3 4 4 c 1 1 2 take the first element of b so b 3 4 4 c 1 1 2 2 take the first element of b so b 4 4 c 1 1 2 2 3 take the last element of b so b 4 c 1 1 2 2 3 4 take the only element of b so b c 1 1 2 2 3 4 4 c is non decreasing Note that the array consisting of one element is Print the length of the shortest prefix of a to delete erase to make a to be a array Note that the required length can be 0 You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint t, n, a[N];\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(""%d"", &n);\n    for (int i = 1; i <= n; ++i) {\n      scanf(""%d"", a + i);\n    }\n    int en = n;\n    while (en > 1 and a[en] <= a[en - 1]) --en;\n    while (en > 1 and a[en] >= a[en - 1]) --en;\n    printf(""%d\\n"", en - 1);\n  }\n  return 0;\n}\n\n']",,,['greedy'],1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Make It Good.json,https://codeforces.com//blog/entry/80257,Consider the maximum element of the good array of length Then we can notice that the array looks like And this is pretty obvious that if the array doesn t have this structure then it isn t good you can see it yourself So we need to find the longest such suffix It s pretty easy doable with pointer initially the pointer is at the last element Then while and decrease by one If we re done with the previous step we do the same but while and The answer is 
https://codeforces.com//contest/1042/problem/D,220708,D,1042D,1042,D. Petya and Array,Petya has an array a consisting of n integers He has learned partial sums recently and now he can calculate the sum of elements on any segment of the array really fast The segment is a non empty sequence of elements standing one next to another in the array Now he wonders what is the number of segments in his array with the sum less than t Help Petya to calculate this number More formally you are required to calculate the number of pairs l r l le r such that a l a l 1 dots a r 1 a r t ,"['#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who’s Kobe? \n// Fisherman can’t stop us\n// Average ABCDE on a good day\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 400005;\nint N;\nll T;\nll A[MAXN];\nll pre[MAXN];\nmap<ll, int> mp;\nint BIT[MAXN];\n\nvoid add(int idx)\n{\n    for (; idx < MAXN; idx += idx&-idx)\n        BIT[idx]++;\n}\n\nint get(int idx)\n{\n    int ret = 0;\n    for (; idx > 0; idx -= idx&-idx)\n        ret += BIT[idx];\n    return ret;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n\n    cin >> N >> T;\n    mp[-T] = 1;\n    mp[0] = 1;\n    for (int i = 1; i <= N; i++)\n    {\n        cin >> A[i];\n        pre[i] = pre[i - 1] + A[i];\n        mp[pre[i] - T] = 1;\n        mp[pre[i]] = 1;\n    }\n    \n    int ind = 0;\n    for (map<ll, int>::iterator it = mp.begin(); it != mp.end(); it++)\n        it->second = ++ind;\n\n    ll ans = 0;\n    add(mp[0]);\n    for (int i = 1; i <= N; i++)\n    {\n        ans += i - get(mp[pre[i] - T]);\n        add(mp[pre[i]]);\n    }\n\n    cout << ans << ""\\n"";\n\n    return 0;\n}\n']",,,"['data structures', 'divide and conquer', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Petya and Array.json,https://codeforces.com/blog/entry/61891,Let s reformulate the problem Now the problem is to calculate the difference between the prefix sums to the right border and to the left border instead of the sum on the segment Let a Then the answer to the problem is It s easy to see that the answer for the fixed is We can calculate this formula using some data structure which allows us to get the number of elements less than given and set the value at some position For example segment tree or BIT Fenwick tree 
https://codeforces.com//contest/1292/problem/A,519776,A,1292A,1292,A. NEKO s Maze Game,NEKO has just got a new maze game on her PC The game s main puzzle is a maze in the forms of a 2 times n rectangle grid NEKO s task is to lead a Nekomimi girl from cell 1 1 to the gate at 2 n and escape the maze The girl can only move between cells sharing a common side However at some moments during the game some cells may change their state either from normal ground to lava which forbids movement into that cell or vice versa which makes that cell passable again Initially all cells are of the ground type After hours of streaming NEKO finally figured out there are only q such moments the i th moment toggles the state of cell r i c i either from ground to lava or vice versa Knowing this NEKO wonders after each of the q moments whether it is still possible to move from cell 1 1 to cell 2 n without going through any lava cells Although NEKO is a great streamer and gamer she still can t get through quizzes and problems requiring large amount of Brain Power Can you help her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nint a[2][N];\nint n, q;\nint cnt;\n\nvoid change(int x, int y) {\n\tfor (int z = y - 1; z <= y + 1; z++) {\n\t\tif (z < 0 || z >= n) continue;\n\t\tcnt -= a[x][y] & a[x ^ 1][z];\n\t}\n\ta[x][y] ^= 1;\n\tfor (int z = y - 1; z <= y + 1; z++) {\n\t\tif (z < 0 || z >= n) continue;\n\t\tcnt += a[x][y] & a[x ^ 1][z];\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &q);\n\twhile(q--) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;y--;\n\t\tchange(x, y);\n\t\tif (cnt == 0)\n\t\t\tprintf(""Yes\\n"");\n\t\telse\n\t\t\tprintf(""No\\n"");\n\t}\n\n\treturn 0;\n}\n']",,,"['data structures', 'dsu', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. NEKO s Maze Game.json,https://codeforces.com//blog/entry/73051,The main observation is that it is possible to travel from to if and only if there exist no pair of forbidden cell and such that Therefore to answer the query quickly for every from to one should keep track of the number of pair such that and are both forbidden One of the methods to do this is after a cell has been swapped check for all cells and update the number of pairs based on the status of those cells and new status of Since the status of all cells can be easily kept in a 2D boolean array and accessed in time complexity Total complexity 
https://codeforces.com//contest/1976/problem/C,2672919,C,1976C,1976,C. Job Interview,Monocarp is opening his own IT company He wants to hire n programmers and m testers There are n m 1 candidates numbered from 1 to n m 1 in chronological order of their arriving time The i th candidate has programming skill a i and testing skill b i a person s programming skill is different from their testing skill The skill of the team is the sum of the programming skills of all candidates hired as programmers and the sum of the testing skills of all candidates hired as testers When a candidate arrives to interview Monocarp tries to assign them to the most suitable position for them if their programming skill is higher then he hires them as a programmer otherwise as a tester If all slots for that position are filled Monocarp assigns them to the other position Your task is for each candidate calculate the skill of the team if everyone except them comes to interview Note that it means that exactly n m candidates will arrive so all n m positions in the company will be filled ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n, m;    std::cin >> n >> m;        const int N = n + m + 1;    std::vector<int> a(N), b(N);    for (int i = 0; i < N; i++) {        std::cin >> a[i];    }    for (int i = 0; i < N; i++) {        std::cin >> b[i];    }        int t = 0;    int x = 0, y = 0;    i64 sum = 0;    while (x < n && y < m) {        if (a[t] > b[t]) {            sum += a[t];            x++;        } else {            sum += b[t];            y++;        }        t++;    }        std::vector<i64> ans(N);    i64 res = sum;    for (int i = t; i < N; i++) {        res += x == n ? b[i] : a[i];    }    for (int i = t; i < N; i++) {        ans[i] = res - (x == n ? b[i] : a[i]);    }    for (int i = 0; i < t; i++) {        if ((x == n) == (a[i] < b[i])) {            ans[i] = res - std::max(a[i], b[i]);        }    }        int ot = t;    int ox = x;    if (x == n) {        x--;    } else {        y--;    }    while (x < n && y < m) {        if (a[t] > b[t]) {            sum += a[t];            x++;        } else {            sum += b[t];            y++;        }        t++;    }    res = sum;    for (int i = t; i < N; i++) {        res += x == n ? b[i] : a[i];    }    for (int i = 0; i < ot; i++) {        if ((ox == n) == (a[i] > b[i])) {            ans[i] = res - std::max(a[i], b[i]);        }    }        for (int i = 0; i < N; i++) {        std::cout << ans[i] << "" \\n""[i == N - 1];    }}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']",,,"['binary search', 'dp', 'greedy', 'implementation', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Job Interview.json,https://codeforces.com//blog/entry/129992,Let s naively calculate the answer for the th candidate While calculating it let s store two values the type of job the th candidate was hired for the index of the first candidate who was hired for a suboptimal role We can show that this first candidate who was hired for a suboptimal role is the only possible candidate who can change his role if another candidate doesn t show up So for all other candidates among the first candidates their roles are fixed To prove this we can consider the following cases if the candidate who doesn t show up has an index or greater then for all candidates after them there is only one possible job when we consider that candidate all positions on one of the job are already filled if the index who doesn t show up has index less than then the candidate will take the same job as that candidate has taken and in any case all positions of the optimal job of the candidate will be filled after we take that candidate Now we can use the th candidate s answer to calculate the answer for the th candidate as follows if and we can move the th candidate to the role and the th candidate to the role this will change the answer by in case of the th candidate was hired as programmer similarly for tester otherwise we can simply move the th candidate to the role this will change the answer by in case of the th candidate was hired as programmer similarly for tester 
https://codeforces.com//contest/850/problem/E,120879,E,850E,850,E. Random Elections,The presidential election is coming in Bearland next year Everybody is so excited about this So far there are three candidates Alice Bob and Charlie There are citizens in Bearland The election result will determine the life of all citizens of Bearland for many years Because of this great responsibility each of citizens will choose one of six orders of preference between Alice Bob and Charlie uniformly at random independently from other voters The government of Bearland has devised a function to help determine the outcome of the election given the voters preferences More specifically the function is takes boolean numbers and returns a boolean number The function also obeys the following property Three rounds will be run between each pair of candidates Alice and Bob Bob and Charlie Charlie and Alice In each round will be equal to if th citizen prefers the first candidate to second in this round and otherwise After this will be calculated If the first candidate will be declared as winner in this round If the second will be the winner respectively Define the probability that there is a candidate who won two rounds as is always an integer Print the value of this integer modulo ,"['#include<map>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2000000 + 10;\nconst int MOD = (int)1e9 + 7, rev=(MOD+1)>>1;\n\nint n;\nchar s[N];\nint a[N], b[N];\nint ans[N];\nint cnt[N];\nint p2[30];\n\nvoid FWT(int *a,int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                int x=a[i+j],y=a[i+j+d];\n                a[i+j]=(x+y)%MOD,a[i+j+d]=(x-y+MOD)%MOD;\n                //xor:a[i+j]=x+y,a[i+j+d]=(x-y+MOD)%MOD;\n                //and:a[i+j]=x+y;\n                //or:a[i+j+d]=x+y;\n            }\n}\n\nvoid UFWT(int *a,int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                int x=a[i+j],y=a[i+j+d];\n                a[i+j]=1LL*(x+y)*rev%MOD,a[i+j+d]=(1LL*(x-y)*rev%MOD+MOD)%MOD;\n                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n                //and:a[i+j]=x-y;\n                //or:a[i+j+d]=y-x;\n            }\n}\n\nvoid solve(int *a,int *b,int n){\n    FWT(a,n);\n    FWT(b,n);\n    for(int i=0;i<n;i++)   a[i]=1LL*a[i]*b[i]%MOD;\n    UFWT(a,n);\n}\n\nvoid solve()\n{\n    /*\n    n = 20;\n    for(int i = 0; i < (1 << n); ++ i) {\n        s[i] = rand() % 2 + \'0\';\n    }\n    */\n    cin >> n;\n    scanf(""%s"", s);\n\n    p2[0] = 1;\n    for(int i = 1; i <= 20; ++ i) {\n        p2[i] = p2[i - 1] * 2 % MOD;\n    }\n\n    for(int i = 0; i < 1 << n; ++ i) {\n        a[i] = s[i] - \'0\';\n        b[i] = 1 - a[i];\n        if (i) {\n            cnt[i] = cnt[i - (i & -i)] + 1;\n        }\n    }\n\n    solve(a, b, 1 << n);\n\n    long long ret = 0;\n    for(int i = 0; i < 1 << n; ++ i) {\n        //cout << i << \' \' << ans[i] << endl;\n        (ret += 1ll * a[i] * p2[cnt[i]]) %= MOD;\n    }\n    cout << (ret * 3 % MOD + MOD) % MOD << endl;\n}\n\nint main()\n{\n    //srand(time(0));\n    solve();\n    return 0;\n}\n']",,,"['bitmasks', 'brute force', 'divide and conquer', 'fft', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Random Elections.json,https://codeforces.com//blog/entry/54317,denotes th bit of denotes number of bits in Count number of ways where Alice wins Suppose Alice wins in first round with mask and in third round with mask so or if voter preferred Alice in corresponding round Necessary condition is Assume we fixed and In how many ways we can choose orders for voters If we can chose two valid permutations for th voter If only one permutation So total number of permutation is So answer to the problem is Denote Lets solve more general problem for each how many pairs are there such that and This is well known problem There are multiple solutions Probably first usage of this problem in competitive programming can be found here https apps topcoder com wiki display tc SRM 518 If you interesting in understanding this approach more deeply from math perspective you can start investigate from here https en wikipedia org wiki Fourier transform on finite groups Sorry for late editorial Btw in task D there are always an answer for any set S that s called Reid s conjectue and was proven by T X Yao in 1988 and have very difficult proof that I didn t manage to find in English if somebody succeed in search please direct it to me 
https://codeforces.com//contest/1900/problem/C,2348160,C,1900C,1900,C. Anji s Binary Tree,Keksic keeps getting left on seen by Anji Through a mutual friend he s figured out that Anji really likes binary trees and decided to solve her problem in order to get her attention Anji has given Keksic a binary tree with n vertices Vertex 1 is the root and does not have a parent All other vertices have exactly one parent Each vertex can have up to 2 children a left child and a right child For each vertex Anji tells Keksic index of both its left and its right child or tells him that they do not exist Additionally each of the vertices has a letter s i on it which is either or Keksic begins his journey on the root and in each move he does the following If the letter on his current vertex is he moves to its parent If it doesn t exist he does nothing If the letter on his current vertex is he moves to its left child If it doesn t exist he does nothing If the letter on his current vertex is he moves to its right child If it doesn t exist he does nothing Before his journey he can perform the following operations choose any node and replace the letter written on it with another one You are interested in the minimal number of operations he needs to do before his journey such that when he starts his journey he will reach a leaf at some point A leaf is a vertex that has no children It does not matter which leaf he reaches Note that it does not matter whether he will stay in the leaf he just needs to move to it Additionally note that it does not matter how many times he needs to move before reaching a leaf Help Keksic solve Anji s tree so that he can win her heart and make her come to a ak ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint n, l[300005], r[300005], ans;\nchar s[300005];\nvoid dfs(int x, int now){\n\tif(l[x] == 0 && r[x] == 0) {\n\t\tans = std::min(ans, now);\n\t\treturn ;\n\t}\n\tif(s[x] != \'L\' && l[x]) dfs(l[x], now + 1);\n\telse if(l[x]) dfs(l[x], now);\n\tif(s[x] != \'R\' && r[x]) dfs(r[x], now + 1); \n\telse if(r[x]) dfs(r[x], now);\n\treturn ;\n}\nvoid solve(){\n\tscanf(""%d%s"", &n, s + 1); ans = 1e9;\n\tfor(int i = 1; i <= n; ++i) scanf(""%d%d"", &l[i], &r[i]);\n\tdfs(1, 0);\n\tprintf(""%d\\n"", ans);\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']",,,"['dfs and similar', 'dp', 'trees']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Anji s Binary Tree.json,https://codeforces.com//blog/entry/122677,SolutionRead the hints We will make edges from a vertex to its children The weight of that edge will be unless one of the following holds The weight of an edge between a vertex and its left child will be if the letter written on that vertex is L The weight of an edge between a vertex and its right child will be if the letter written on that vertex is R Now we run a modified DFS to find the distance of each vertex from the root but with weighted edges We output the minimal value among all the leaves Time and memory complexities are 
https://codeforces.com//contest/1840/problem/E,1953890,E,1840E,1840,E. Character Blocking,You are given two strings of equal length s 1 and s 2 consisting of lowercase Latin letters and an integer t You need to answer q queries numbered from 1 to q The i th query comes in the i th second of time Each query is one of three types block the characters at position pos indexed from 1 in both strings for t seconds swap two unblocked characters determine if the two strings are equal at the time of the query ignoring blocked characters Note that in queries of the second type the characters being swapped can be from the same string or from s 1 and s 2 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint k,q;\nchar s[N],t[N];\nvector<int >V[N];\nint tot;\nbool vis[N];\nvoid calc(int x)\n{\n\t\n}\nvoid solve()\n{\n\tscanf(""%s"",s+1);\n\tscanf(""%s"",t+1);\n\tn=strlen(s+1);\n\tk=read();\tq=read();\ttot=0;\n\tfor(int i=1;i<=n;++i)\tvis[i]=true;\n\tfor(int i=1;i<=q;++i)\tV[i].clear();\n\tfor(int i=1;i<=n;++i)\tif(s[i]!=t[i])\ttot++;\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tfor(auto v:V[i])\n\t\t{\n\t\t\tif(s[v]!=t[v])\ttot++;\n\t\t}\n\t\tint opt=read();\n\t\tif(opt==1)\n\t\t{\n\t\t\tint x=read();\n\t\t\tif(i+k<=q)\tV[i+k].push_back(x);\n\t\t\tif(s[x]!=t[x])\ttot--;\n\t\t}\n\t\tif(opt==2)\n\t\t{\n\t\t\tint t1=read();\tint p1=read();\n\t\t\tint t2=read();\tint p2=read();\n\t\t\tif(t1>t2)\n\t\t\t{\n\t\t\t\tswap(t1,t2);\n\t\t\t\tswap(p1,p2);\n\t\t\t}\n\t\t\tif(t2==1)\n\t\t\t{\n\t\t\t\tif(s[p1]!=t[p1])\ttot--;\n\t\t\t\tif(s[p2]!=t[p2])\ttot--;\n\t\t\t\tswap(s[p1],s[p2]);\n\t\t\t\tif(s[p1]!=t[p1])\ttot++;\n\t\t\t\tif(s[p2]!=t[p2])\ttot++;\n\t\t\t}\n\t\t\telse if(t1==2)\n\t\t\t{\n\t\t\t\tif(s[p1]!=t[p1])\ttot--;\n\t\t\t\tif(s[p2]!=t[p2])\ttot--;\n\t\t\t\tswap(t[p1],t[p2]);\n\t\t\t\tif(s[p1]!=t[p1])\ttot++;\n\t\t\t\tif(s[p2]!=t[p2])\ttot++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[p1]!=t[p1])\ttot--;\n\t\t\t\tif(s[p2]!=t[p2])\ttot--;\n\t\t\t\tswap(s[p1],t[p2]);\n\t\t\t\tif(s[p1]!=t[p1])\ttot++;\n\t\t\t\tif(s[p2]!=t[p2])\ttot++;\n\t\t\t}\n\t\t}\n\t\tif(opt==3)\n\t\t{\n\t\t\tputs(tot? ""NO"":""YES"");\n\t\t}\n\t}\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}']",,,"['data structures', 'hashing', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Character Blocking.json,https://codeforces.com//blog/entry/117060,Two strings are equal if and only if there is no position such that the characters at position are not blocked and we will call such a position We will use this observation to maintain the current number of positions denoted by Let be an indicator variable if position is otherwise During an operation blocking or swapping we only need to subtract the indicator variables of all positions affected by the operation from There will be of them Then we modify the string according to the operation and add new indicator variables to To correctly handle blocking queries or more precisely to unblock positions in time we will use a queue After each blocking query we will add a pair of numbers to the queue The first number of the pair is the position to unblock and the second number is the time to unblock Now before each operation we will unblock positions by looking at the head of the queue 
https://codeforces.com//contest/1620/problem/D,1233291,D,1620D,1620,D. Exact Change,One day early in the morning you decided to buy yourself a bag of chips in the nearby store The store has chips of n different flavors A bag of the i th flavor costs a i burles The store may run out of some flavors so you ll decide which one to buy after arriving there But there are two major flaws in this plan you have only coins of 1 2 and 3 burles since it s morning the store will ask you to pay in exact change i e if you choose the i th flavor you ll have to pay a i burles Coins are heavy so you d like to take the least possible number of coins in total That s why you are wondering what is the minimum total number of coins you should take with you so you can buy a bag of chips of any flavor in exact change ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int INF = int(1e9) + 5;\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    int best = INF;\n\n    for (int ones = 0; ones <= 1; ones++)\n        for (int twos = 0; ones + twos <= 2; twos++) {\n            int threes = 0;\n\n            for (int a : A) {\n                int least = INF;\n\n                for (int x = 0; x <= ones; x++)\n                    for (int y = 0; y <= twos; y++) {\n                        int need = a - x - 2 * y;\n\n                        if (need >= 0 && need % 3 == 0)\n                            least = min(least, need / 3);\n                    }\n\n                threes = max(threes, least);\n            }\n\n            best = min(best, ones + twos + threes);\n        }\n\n    cout << best << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Exact Change.json,https://codeforces.com//blog/entry/98061,Let s define then it should be obvious that we need at least coins to buy a bag of chips of cost Now it s not hard to prove that coins is always enough to buy a bag of chips of any cost Proof if we ll take coins of value coin and coin if we ll take coins and two coins if we ll take coins one coin and two coins So the question is how to decide is coins enough The solution is to note that there is no need to take more than coins and more than coins so we can just brute force the number of coins we ll take and the number of coins we ll take Then the number of coins and we can check is it possible to pay exactly using at most and coins respectively There exists casework solution as well but it s quite tricky so brute force is preferable The main problem for case work is the case since there are two different ways to take coins either coins and coin or coins and two coins In the first way you can t gather exactly and in the second one you can gather neither nor 
https://codeforces.com//contest/435/problem/B,9909,B,435B,435,B. Pasha Maximizes,Pasha has a positive integer without leading zeroes Today he decided that the number is too small and he should make it larger Unfortunately the only operation Pasha can do is to swap two adjacent decimal digits of the integer Help Pasha count the maximum number he can get if he has the time to make at most swaps ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    char s[100];\n    int x;\n    scanf(""%s%d"", s, &x);\n    int n = strlen(s), tot = 0;\n    for (int i = 0; i < n; i++) {\n        int to = -1;\n        for (int j = 9; j >= 0; j--) {\n            for (int k = i; k < n; k++) {\n                if (s[k] == j + \'0\') {\n                    to = k;\n                    break;\n                }\n            }\n            if (to == -1) continue;\n            if (tot + to - i <= x) {\n                for (int k = to - 1; k >= i; k--) {\n                    s[k + 1] = s[k];\n                }\n                tot += to - i;\n                s[i] = j + \'0\';\n                break;\n            }\n        }\n    }\n    puts(s);\n    return 0;\n}\n']",,,['greedy'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Pasha Maximizes.json,https://codeforces.com//blog/entry/12479,The problem could solved by greedy algorithm We will try to pull maximum digits to the beginning The algorithm could be described in this way 1 Consider every position in the number from the first assume that the current position is 2 Find the nearest maximum digit from the next digits of the number assume that this digit is on position 3 If this maximum digit is greater than current digit on position then make series of swaps push this digit to position also decrease that is do 
https://codeforces.com//contest/1015/problem/D,203549,D,1015D,1015,D. Walking Between Houses,There are n houses in a row They are numbered from 1 to n in order from left to right Initially you are in the house 1 You have to perform k moves to other house In one move you go from your current house to some other house You can t stay where you are i e in each move the new house differs from the current house If you go from the house x to the house y the total distance you walked increases by x y units of distance where a is the absolute value of a It is possible to visit the same house multiple times but you can t visit the same house in sequence Your goal is to walk exactly s units of distance in total If it is impossible print Otherwise print and any of the ways to do that Remember that you should do exactly k moves ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define p_b push_back\n#define pll pair<ll,ll>\n#define endl ""\\n""\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define ld long double\n\nusing namespace std;\ntypedef long long ll;\nconst ll MAXN = 1123456;\n\ntemplate <typename T>\nT sqr(T x){\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s){\n    cout << s << endl;\n    exit(0);\n}\n\nll bp(ll a,ll n){\n    ll res = 1;\n    while(n){\n        if(n % 2)res *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    ll n, k, s;\n    cin >> n >> k >> s;\n    vector <ll> ans(k);\n    if((n - 1) * k < s)vout(""NO"");\n    if(s < k)vout(""NO"");\n    cout << ""YES\\n"";\n    ll pos = 1;\n    for(int i = 0; i < k; i++){\n        ll ost = k - i - 1;\n        ll sum = min(n - 1, s - ost);\n        s -= sum;\n        if(pos + sum <= n)pos += sum; else pos -= sum;\n        ans[i] = pos;\n    }\n    for(auto i : ans)cout << i << "" "";\n\n    return 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Walking Between Houses.json,https://codeforces.com/blog/entry/60949,The solution for this problem is very simple at first if or the answer is Otherwise let s do the following thing times let be we have to greedily decrease the remaining distance but we also should remember about the number of moves which we need to perform We have to walk to possible house which is located at distance from the current house also don t forget to subtract from The proof of the fact that we can always walk to the house at distance is very simple one of the possible answers which is obtained by the algorithm above will looks like several moves of distance possibly one move of random distance less than and several moves of distance The first part of the answer can be obtained if we are stay near the leftmost or the rightmost house second and third parts always can be obtained because distances we will walk in every of such moves is less than Time complexity is 
https://codeforces.com//contest/1809/problem/F,1839366,F,1809F,1809,F. Traveling in Berland,There are n cities in Berland arranged in a circle and numbered from 1 to n in clockwise order You want to travel all over Berland starting in some city visiting all the other cities and returning to the starting city Unfortunately you can only drive along the Berland Ring Highway which connects all n cities The road was designed by a very titled and respectable minister so it is one directional it can only be traversed clockwise only from the city i to the city i bmod n 1 i e from 1 to 2 from 2 in 3 from n to 1 The fuel tank of your car holds up to k liters of fuel To drive from the i th city to the next one a i liters of fuel are needed and are consumed in the process Every city has a fuel station a liter of fuel in the i th city costs b i burles Refueling between cities is not allowed if fuel has run out between cities then your journey is considered incomplete For each city calculate the minimum cost of the journey if you start and finish it in that city ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    \n    std::vector<i64> f(2 * n + 1);\n    for (int i = 0; i < 2 * n; i++) {\n        f[i + 1] = f[i] + a[i % n];\n    }\n    \n    int last = -1;\n    std::vector<int> pre(2 * n);\n    for (int i = 0; i < 2 * n; i++) {\n        if (b[i % n] == 1) {\n            last = i;\n        }\n        pre[i] = last;\n    }\n    \n    std::vector<i64> ans(n);\n    ans[0] += sum;\n    for (int i = 0; i < 2 * n - 1; i++) {\n        if (b[i % n] == 2) {\n            if (pre[i] == -1) {\n                ans[std::max(0, i - n + 1)] += a[i % n];\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            } else {\n                int v = std::max(0LL, std::min(1LL * a[i % n], f[i + 1] - f[pre[i]] - k));\n                ans[std::max(0, i - n + 1)] += v;\n                if (pre[i] + 1 < n) {\n                    ans[pre[i] + 1] += a[i % n] - v;\n                }\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        ans[i] += ans[i - 1];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['binary search', 'data structures', 'graphs', 'greedy', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Traveling in Berland.json,https://codeforces.com//blog/entry/114300,The problem has a rather obvious naive solution in for each starting city but it s too slow So we have to speed up this solution somehow Binary lifting is one of the options but here we have a problem that it is difficult to connect two consecutive groups of steps because after the first group there is a certain amount of fuel left Therefore one of the solutions is to switch to such steps that liters of fuel remains after it Let s consider one of such greedy steps Suppose we are in the city with fuel then the following situations are possible let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and where is the maximum number such that i e the number of consecutive cities with the cost let s buy exactly liters of fuel to reach the next city then the step length is and the cost is and let s find a minimum such that and i e such that you can reach it by spending all of liters let s buy exactly liters with the cost in the city then the step length is and the cost is let s buy liters with the cost in the city and the remainder of liters with the cost in the city then the step length is and the cost is Now using these types of steps we maintain an important invariant after each step the amount of fuel is So we can easily calculate the total distance and cost for several consecutive steps Which leads us to a solution using binary lifting for each city calculate the length and cost of the path with for all up to greedy steps And then using this data we can calculate the answer for each starting city in 
https://codeforces.com//contest/1975/problem/F,2665477,F,1975F,1975,F. Set,Define the of a finite set of natural numbers T subseteq 0 1 2 ldots as f T sum limits i in T 2 i For example f 0 2 2 0 2 2 5 and f 0 Notice that f is a bijection from all such sets to all non negative integers As such f 1 is also defined You are given an integer n along with 2 n 1 sets V 1 V 2 ldots V 2 n 1 Find all sets S that satisfy the following constraint S subseteq 0 1 ldots n 1 Note that S can be For all subsets T subseteq 0 1 ldots n 1 S cap T in V f T Due to the large input and output both input and output will be given in terms of binary encodings of the sets ,"['/** *    author:  tourist *    created: 25.05.2024 10:57:59**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int n;  cin >> n;  vector<int> v(1 << n);  for (int i = 1; i < (1 << n); i++) {    cin >> v[i];  }  v[0] = 1;  vector<vector<int>> a(n + 1);  a[0] = v;  for (int i = 1; i <= n; i++) {    a[i].resize(1 << (n - i));  }  vector<int> res;  auto Dfs = [&](auto&& self, int b, int num) {    if (b == n) {      if (a[b][0] > 0) {        res.push_back(num);      }      return;    }    for (int val = 0; val < 2; val++) {      for (int i = 0; i < (1 << (n - b - 1)); i++) {        a[b + 1][i] = a[b][2 * i] & (a[b][2 * i + 1] >> val);      }      self(self, b + 1, num + (val << b));    }  };  Dfs(Dfs, 0, 0);  sort(res.begin(), res.end());  cout << res.size() << \'\\n\';  for (int x : res) {    cout << x << \'\\n\';  }  return 0;}']",,,"['bitmasks', 'brute force', 'combinatorics', 'dfs and similar', 'divide and conquer', 'dp', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Set.json,https://codeforces.com//blog/entry/129801,SolutionRead the hints Consider enumerating each number from to whether it is contained by Suppose that the current enumeration reaches and in the remaining constraints and are two sets the only difference between them is whether they contain contains contains We can merge and into a new constraint and doesn t contain We can merge and into a new constraint and We can merge constraints quickly when the enumeration reaches a new number And the time complexity is 
https://codeforces.com//contest/724/problem/F,74855,F,724F,724,F. Uniformly Branched Trees,A tree is a connected graph without cycles Two trees consisting of vertices each are called if there exists a permutation such that the edge is present in the first tree if and only if the edge is present in the second tree Vertex of the tree is called internal if its degree is greater than or equal to two Count the number of different non isomorphic trees consisting of vertices such that the degree of each internal vertex is Print the answer over the given prime modulo ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\n//const ll mod=1000000007;\nint mod;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nll dp[N][20],pd[N][20],f[N],t[20];\nint n,d;\n\nint main() {\n\tscanf(""%d%d%d"",&n,&d,&mod);\n\tif (n<=2) {\n\t\tputs(""1"");\n\t\treturn 0;\n\t}\n\tif ((n-2)%(d-1)!=0) {\n\t\tputs(""0"");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\trep(i,1,n/2+1) if ((i-1)%(d-1)==0) {\n\t\tif (i==1) f[i]=1; else f[i]=dp[i-1][d-1];\n\t\tt[0]=1;\n\t\trep(j,1,d+1) {\n\t\t\tt[j]=t[j-1]*(f[i]+j-1)%mod*powmod(j,mod-2)%mod;\n\t\t}\n\t\trep(p,0,n+1) rep(q,0,d+1) pd[p][q]=0;\n\t\trep(r,0,d+1) rep(q,0,d+1) if (r+q<=d) rep(p,0,n+1) if (p+q*i<=n) {\n\t\t\tpd[p+q*i][r+q]=(pd[p+q*i][r+q]+dp[p][r]*t[q])%mod;\n\t\t}\n\t\trep(p,0,n+1) rep(q,0,d+1) if (pd[p][q]) {\n\t\t\tdp[p][q]=pd[p][q];\n\t\t}\n\t}\n\tint ret=dp[n-1][d];\n\tif (n%2==0) {\n\t\tret=(ret-dp[n/2-1][d-1]*(dp[n/2-1][d-1]-1)/2)%mod;\n\t\tif (ret<0) ret+=mod;\n\t}\n\tprintf(""%d\\n"",ret);\n}\n']",,,"['combinatorics', 'dp', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Uniformly Branched Trees.json,https://codeforces.com//blog/entry/47644,At first we will calculate the following dynamic programming will be the number of rooted trees where the root has exactly directed subtrees the maximum size of which does not exceed and the degree of internal vertices is equal to except for the root Calculation of the value of the dynamics for fixed parameters is divided into two cases there are on subtrees of size at all In this case you can take the value of there are subtrees of size In this case we got different trees The main idea here is that we do not distinguish trees that differ only by a permutation of the sons for some vertices this is where the number of combinations come from It s enough to set some order in which we will place the sons of all vertices In this case they are arranged in the order of ascending sizes and the index number of its subtrees all the trees of fixed size can be written in one big list and enumerated Now we need to count the number of unrooted trees Let s get rid of this restriction by rooting all the trees using some vertex For this vertex we will take the centroid the vertex after removing which the tree splits into connected components with the sizes not larger than the half of the original size of the tree The advantage of this choice is that any tree always have either one or two centroids The number of trees that have exactly one centroid is equal to The fact that we chose the centroid implies that the size of subtrees cannot exceed The number of trees that have exactly two centroids is equal to if is divisible by and zero otherwise If there are two centroids they will be connected by an edge and the removing of this edge will split the graph into two parts each of which will contain exactly vertices The resulting complexity of this solution is 
https://codeforces.com//contest/2003/problem/D2,2836629,D2,2003D2,2003,D2. Turtle and a MEX Problem  Hard Version ,One day Turtle was playing with n sequences Let the length of the i th sequence be l i Then the i th sequence was a i 1 a i 2 ldots a i l i Piggy gave Turtle a problem to solve when Turtle was playing The statement of the problem was There was a non negative integer x at first Turtle would perform an arbitrary number possibly zero of operations on the integer In each operation Turtle could choose an integer i such that 1 le i le n and and set x to text mex dagger x a i 1 a i 2 ldots a i l i Turtle was asked to find the answer which was the value of x after performing an arbitrary number of operations Turtle solved the above problem without difficulty He defined f k as the answer to the above problem when the initial value of x was k Then Piggy gave Turtle a non negative integer m and asked Turtle to find the value of sum limits i 0 m f i i e the value of f 0 f 1 ldots f m Unfortunately he couldn t solve this problem Please help him dagger text mex c 1 c 2 ldots c k is defined as the smallest integer x which does not occur in the sequence c For example text mex 2 2 0 3 is 1 text mex 1 2 is 0 ,"['#include <bits/stdc++.h>\xa0#define ranges std::ranges#define views std::views\xa0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\xa0using pii = std::pair<int, int>;using a3 = std::array<int, 3>;using a4 = std::array<int, 4>;\xa0const int N = 1e6;const int MAXN = 1e6 + 10;const int inf = 1e9;// const int mod = 1e9 + 7;const int mod = 998244353;\xa0void solve() {    i64 n, m;std::cin >> n >> m;    std::vector<pii> p(n);    i64 mxsize = 0;    for (int i = 0;i < n;++i) {        i64 k;std::cin >> k;        mxsize = std::max(mxsize, k);        std::vector<int> a(k);        for (int& x : a)std::cin >> x;        ranges::sort(a);        int mex = 0;        bool ok = true;        for (int j = 0;j < k;++j) {            if (a[j] > mex) {                if (ok) {                    p[i].first = mex;                    mex++;                    ok = false;                }                else break;            }            if (a[j] == mex)mex++;        }        // auto [l, r] = p[i];        // std::cout << l << \' \' << r << "" "" << mex << ""\\n"";        if (ok) {            p[i].first = mex;            mex++;            ok = false;        }        p[i].second = mex;    }    mxsize += 10;    std::vector<i64> dp(mxsize, 0), cnt(mxsize, 0);    std::iota(dp.begin(), dp.end(), 0);    for (auto& [l, r] : p)cnt[l]++;    ranges::sort(p, std::greater<pii>());    i64 res = 0;    for (auto& [l, r] : p) {        // std::cout << l << \' \' << r << ""\\n"";        dp[l] = std::max(dp[l], dp[r]);        res = std::max(res, 1ll * l);    }    for (int i = 0;i < mxsize;++i) {        if (cnt[i] > 1) {            res = std::max(res, dp[i]);        }    }    // for (auto& x : dp)std::cout << x << \' \';    // std::cout << res << "" "";    i64 ans = 0;    if (m >= mxsize) {        ans += (mxsize + m) * (m - mxsize + 1) / 2;    }    for (int i = 0;i < std::min(mxsize, m + 1); ++i) {        ans += std::max(res, dp[i]);    }    std::cout << ans;}\xa0signed main() {    std::ios::sync_with_stdio(false);    std::cin.tie(0), std::cout.tie(0);    int t;std::cin >> t;    while (t--) {        solve();        std::cout << \'\\n\';    }    return 0;}']",,,"['dfs and similar', 'dp', 'graphs', 'greedy', 'implementation', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D2. Turtle and a MEX Problem  Hard Version .json,https://codeforces.com/blog/entry/132953,Please first read the solution for problem D1 Construct a directed graph For the th sequence add a directed edge from to In each operation you can either move along an outgoing edge of or move to any vertex and remove one of its outgoing edges Let be the maximum vertex number that can be reached starting from vertex by continuously selecting one outgoing edge in the directed graph This can be solved using DP in reverse order from large to small Firstly the answer for is at least Additionally the answer for every is at least Moreover for any vertex with outdegree greater than 1 the answer for every is at least since you can disconnect any outgoing edge from except the one leading to Let For values we can directly enumerate and calculate For values they won t be operated Time complexity per test case 
https://codeforces.com//contest/137/problem/E,725,E,137E,137,E. Last Chance,Having read half of the book called Storm and Calm on the IT lesson Innocentius was absolutely determined to finish the book on the maths lessons All was fine until the math teacher Ms Watkins saw Innocentius reading fiction books instead of solving equations of the fifth degree As during the last maths class Innocentius suggested the algorithm of solving equations of the fifth degree in the general case Ms Watkins had no other choice but to give him a new task The teacher asked to write consecutively without spaces all words from the Storm and Calm in one long string She thought that a string is good if the number of vowels in the string is no more than twice more than the number of consonants That is the string with vowels and consonants is good if and only if The task Innocentius had to solve turned out to be rather simple he should find the number of the longest good substrings of the string ,"['#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nchar vow[128],s[200005];\nint a[200005];\n\nint main(){\n    vow[\'a\']=vow[\'e\']=vow[\'i\']=vow[\'o\']=vow[\'u\']=1;\n    vow[\'A\']=vow[\'E\']=vow[\'I\']=vow[\'O\']=vow[\'U\']=1;\n    int n=strlen(gets(s+1)),ans=0,cnt=0;\n    for(int i=1;i<=n;i++) s[i]=vow[s[i]];\n    for(int i=1;i<=n;i++) a[i]=a[i-1]+(s[i]?-1:2);\n    vector<int> u={0};\n    for(int i=1;i<=n;i++){\n        if(a[i]-a[u.back()]>=0){\n            int lo=0,hi=u.size()-1;\n            while(lo<hi){\n                int m=(lo+hi)/2;\n                if(a[i]-a[u[m]]>=0) hi=m; else lo=m+1;\n            }\n            ans=max(ans,i-u[lo]);\n        }\n        if(a[i]<a[u.back()]) u.push_back(i);\n    }\n    if(!ans) return printf(""No solution"")&0;\n    for(int i=ans;i<=n;i++) if(a[i]-a[i-ans]>=0) cnt++;\n    printf(""%d %d\\n"",ans,cnt);\n}\n']",,,"['data structures', 'implementation', 'strings']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Last Chance.json,https://codeforces.com//blog/entry/3318,Let s replace all vowels by 1 and all consonants by 2 Obviously substring from position i to j is good if sum in the substring i j is nonnegative Denote this sum by sum i j Obviously sum i j p j 1 p i where p i is the sum of first i elements Now for all i we want to find maximal j such that j i and sum i j 0 For this let s sort the array of p i i and build segment tree on this array by i Let s iterate over all p i in nondescending order Obsiously for fixed i we have that j max index i where index i is the index of i th partial sum in nondescending order and i from range x n where x is the position of the first partial sum with value p i in sorted array Than we must update position i by value of negative infinity and update answer by j i The complexity is O n logn 
https://codeforces.com//contest/875/problem/C,128560,C,875C,875,C. National Property,You all know that the Library of Bookland is the largest library in the world There are dozens of thousands of books in the library The alphabet of Bookland is so large that its letters are denoted by positive integers Each letter can be small or large the large version of a letter is denoted by BSCII encoding which is used everywhere in Bookland is made in that way so that large letters are presented in the order of the numbers they are denoted by and small letters are presented in the order of the numbers they are denoted by but all large letters are all small letters For example the following conditions hold A word is not greater than if one of the two following conditions holds and i e the first word is the prefix of the second word there is a position such that and i e at the first position where the words differ the first word has a smaller letter than the second word has For example the word is before the word in lexicographical order It is said that sequence of words is in lexicographical order if each word is not lexicographically greater than the next word in the sequence Denis has a sequence of words consisting of small letters only He wants to change some letters to large let s call this process a in such a way that the sequence of words is in lexicographical order However he soon realized that for some reason he can t change a single letter in a single word He only can choose a letter and change all of its occurrences in words to large letters He can perform this operation any number of times with arbitrary letters of Bookland s alphabet Help Denis to choose which letters he needs to capitalize make large in order to make the sequence of words lexicographically ordered or determine that it is impossible Note that some words can be ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,f[100010],p;\nvector<int> a[100010],x[100010];\ninline void dfs(int i)\n{\n\tint j;\n\tfor(j=0;j<a[i].size();j++)\n\t  if(f[a[i][j]]==2)\n\t    p=1;\n\t  else if(!f[a[i][j]])\n\t    {\n\t\t f[a[i][j]]=1;\n\t\t dfs(a[i][j]);\n\t\t}\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k;\n\tscanf(""%d%d"",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(""%d"",&k);\n\t   while(k--)\n\t     {\n\t\t  scanf(""%d"",&j);\n\t\t  x[i].push_back(j);\n\t\t }\n\t  }\n\tfor(i=1;i<n;i++)\n\t  {\n\t   for(j=0;j<x[i].size() && j<x[i+1].size();j++)\n\t     if(x[i][j]!=x[i+1][j])\n\t       break;\n\t   if(j==x[i].size() || j==x[i+1].size())\n\t     {\n\t      if(x[i].size()>x[i+1].size())\n\t        p=1;\n\t\t }\n\t   else\n\t     if(x[i][j]<x[i+1][j])\n\t       a[x[i+1][j]].push_back(x[i][j]);\n\t     else\n\t       if(f[x[i][j]]==2 || f[x[i+1][j]]==1)\n\t         p=1;\n\t       else\n\t         f[x[i][j]]=1,f[x[i+1][j]]=2;\n\t  }\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]==1)\n\t    dfs(i);\n\tif(p)\n\t  printf(""No\\n"");\n\telse\n\t  {\n\t   printf(""Yes\\n"");\n\t   for(i=1,k=0;i<=m;i++)\n\t     if(f[i]==1)\n\t       k++;\n\t   printf(""%d\\n"",k);\n\t   for(i=1,k=0;i<=m;i++)\n\t     if(f[i]==1)\n\t       printf(""%d "",i);\n\t  }\n\treturn 0;\n}\n']",,,"['2-sat', 'dfs and similar', 'graphs', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. National Property.json,https://codeforces.com//blog/entry/55233,Let the strings and are not prefixes of each other Then it is necessary that where k is the first position where and differ Consider strings and Let be the first position in which they differ Then there are two cases If you capitalize and not capitalize If both these letters should be capitalized or not capitalizes simultaneously Let s make a graph in which letters will be vertexes If then mark as capitalized otherwise make a directed edge between and It means that if we capitalize you also should capitalize Note that our graph is acyclic because the edges are directed from big letters to small letters Using dfs we capitalize all the letters that are reachable from the capitalized letters and check the answer If the answer is wrong there is no answer 
https://codeforces.com//contest/620/problem/B,45928,B,620B,620,B. Grandfather Dovlet’s calculator,Once Max found an electronic calculator from his grandfather Dovlet s chest He noticed that the numbers were written with seven segment indicators https en wikipedia org wiki Seven segment display Max starts to type all the values from to After typing each number Max resets the calculator Find the total number of segments printed on the calculator For example if and then at first the calculator will print segments then segments and at last it will print segments So the total number of printed segments is ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int cnt[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\n\nint main() {\n  int a, b;\n  scanf(""%d %d"", &a, &b);\n  int ans = 0;\n  for (int i = a; i <= b; i++) {\n    int x = i;\n    while (x > 0) {\n      ans += cnt[x % 10];\n      x /= 10;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Grandfather Dovlet’s calculator.json,https://codeforces.com//blog/entry/22936,Let s simply iterate over all the values from to and add to the answer the number of segments of the current value To count the number of segments we should iterate over all the digits of the number and add to the answer the number of segments of the current digit These values can be calculated by the image from the problem statement and stored in some array in code C solution Complexity 
https://codeforces.com//contest/1927/problem/G,2464700,G,1927G,1927,G. Paint Charges,A horizontal grid strip of n cells is given In the i th cell there is a paint charge of size a i This charge can be either used to the left then all cells to the left at a distance less than a i from max i a i 1 1 to i inclusive will be painted or used to the right then all cells to the right at a distance less than a i from i to min i a i 1 n inclusive will be painted or not used at all Note that a charge can be used no more than once that is it be used simultaneously to the left and to the right It is allowed for a cell to be painted more than once What is the minimum number of times a charge needs to be used to paint all the cells of the strip ,"['// LUOGU_RID: 146673924\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint tt;\nint n,a[101];\nint f[2][105][105];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin>>tt;\n\twhile(tt--){\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\tf[0][i][j]=f[1][i][j]=n+1;\n\t\t\t}\n\t\t}\n\t\tf[0][0][1]=0;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\tint S=p&1,S_=S^1;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(f[S_][i][j]==n+1) continue;\n//\t\t\t\t\tcout<<i<<\' \'<<j<<\' \'<<p<<"" ""<<f[i][j]<<\':\'<<\'\\n\';\n\t\t\t\t\tint lim=max(p-a[p]+1,1ll);\n\t\t\t\t\tif(j>=lim) f[S][max(i,p)][max(i,p)+1]=min(f[S][max(i,p)][max(i,p)+1],f[S_][i][j]+1);\n//\t\t\t\t\tcout<<f[max(i,p)][p+1]<<\' \'<<max(i,p)<<\' \'<<p+1<<\'\\n\';\n\t\t\t\t\tlim=min(n,p+a[p]-1);\n\t\t\t\t\tint t=max(lim,i);\n\t\t\t\t\tif(j<p){\n\t\t\t\t\t\tf[S][t][j]=min(f[S][t][j],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<\'*\'<<f[t][j]<<\' \'<<t<<\' \'<<j<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tf[S][t][t+1]=min(f[S][t][t+1],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<f[t][t+1]<<\' \'<<t<<\' \'<<t+1<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tf[S][i][j]=min(f[S][i][j],f[S_][i][j]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif(p==6) cout<<f[S][10][1]<<\'\\n\';\n\t\t}\n\t\tcout<<min(f[0][n][n+1],f[1][n][n+1])<<\'\\n\';\n\t}\n}']",,,"['data structures', 'dp', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Paint Charges.json,https://codeforces.com//blog/entry/125597,Let s use the method of dynamic programming Let be the minimum number of operations required for the distance from to the farthest unpainted cell on the left to be and to the nearest unpainted cell on the right to be including itself We will update the values forward that is for all reachable states we will find the states reachable from it and update the answer for them In this case we will move from the current to recalculating and depending on the action not spraying paint from spraying paint from to the left spraying paint from to the right The problem could also have been solved in however the constraints did not require this 
https://codeforces.com//contest/1292/problem/E,519780,E,1292E,1292,E. Rin and The Unknown Flower,On a normal day at the hidden office in A R C Markland N Rin received an artifact given to her by the exploration captain Sagar After much analysis she now realizes that this artifact contains data about a strange flower which has existed way before the New Age However the information about its chemical structure has been encrypted heavily The chemical structure of this flower can be represented as a string p From the unencrypted papers included Rin already knows the length n of that string and she can also conclude that the string contains at most three distinct letters as in Carbon as in Hydrogen and as in Oxygen At each moment Rin can input a string s of an arbitrary length into the artifact s terminal and it will return every starting position of s as a of p However the artifact has limited energy and cannot be recharged in any way since the technology is way too ancient and is incompatible with any current A R C s devices To be specific The artifact only contains frac 7 5 units of energy For each time Rin inputs a string s of length t the artifact consumes frac 1 t 2 units of energy If the amount of energy reaches below zero the task will be considered failed immediately as the artifact will go black forever Since the artifact is so precious yet fragile Rin is very nervous to attempt to crack the final data Can you give her a helping hand ,"['/**\n *    author:  tourist\n *    created: 19.01.2020 17:31:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s(n, \'?\');\n    auto Ask = [&](string t) {\n      cout << ""? "" << t << endl;\n      int foo;\n      cin >> foo;\n      for (int i = 0; i < foo; i++) {\n        int bar;\n        cin >> bar;\n        --bar;\n        for (int j = 0; j < (int) t.size(); j++) {\n          s[bar + j] = t[j];\n        }\n      }\n    };\n    if (n <= 7) {\n      Ask(""CH"");\n      Ask(""CO"");\n      if (s == string(n, \'?\')) {\n        if (n == 4) {\n          Ask(""HO"");\n          if (s == string(n, \'?\')) {\n            Ask(""OH"");\n            if (s == string(n, \'?\')) {\n              Ask(""CCC"");\n              if (s == string(n, \'?\')) {\n                Ask(""OOO"");\n                if (s[0] == \'O\') {\n                  if (s[n - 1] == \'?\') s[n - 1] = \'C\';\n                } else {\n                  Ask(""HHH"");\n                  if (s[0] == \'H\') {\n                    if (s[n - 1] == \'?\') s[n - 1] = \'C\';\n                  } else {\n                    Ask(""OOCC"");\n                    if (s == string(n, \'?\')) s = ""HHCC"";\n                  }\n                }\n              } else {\n                Ask(""HCCC"");\n                Ask(""OCCC"");\n              }\n            } else {\n              for (int i = 0; i < n; i++) {\n                if (s[i] == \'?\') {\n                  s[i] = \'O\';\n                } else {\n                  break;\n                }\n              }\n              goto haha;\n            }\n          } else {\n            goto haha;\n          }\n        } else {\n          Ask(""CC"");\n          if (s[1] != \'?\' && s[0] == \'?\') {\n            string q = s;\n            q[0] = \'H\';\n            Ask(q);\n            if (s[0] == \'?\') {\n              s[0] = \'O\';\n            }\n          } else {\n            Ask(""OH"");\n            Ask(""HO"");\n            if (s == string(n, \'?\')) {\n              Ask(string(n, \'H\'));\n              Ask(string(n, \'O\'));\n              if (s == string(n, \'?\')) {\n                string q(n, \'H\');\n                q[n - 1] = \'C\';\n                Ask(q);\n                if (s == string(n, \'?\')) {\n                  s = string(n, \'O\');\n                  s[n - 1] = \'C\';\n                }\n              }\n            } else {\n              if (s[n - 1] == \'C\' && s.find(""H"") == string::npos && s.find(""O"") == string::npos) {\n                string q = s;\n                for (int i = 0; i < n; i++) {\n                  if (q[i] == \'?\') {\n                    q[i] = \'H\';\n                  }\n                }\n                Ask(q);\n                if (s[0] == \'?\') {\n                  for (int i = 0; i < n; i++) {\n                    if (s[i] == \'?\') {\n                      s[i] = \'O\';\n                    }\n                  }\n                }\n              } else {\n                int beg = 0;\n                while (beg < n) {\n                  if (s[beg] != \'?\') {\n                    ++beg;\n                    continue;\n                  }\n                  int end = beg;\n                  while (end + 1 < n && s[end + 1] == \'?\') {\n                    ++end;\n                  }\n                  if (beg == 0) {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[end + 1];\n                    }\n                  } else {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[beg - 1];\n                    }\n                  }\n                  beg = end + 1;\n                }\n                string q = s;\n                q[n - 1] = \'C\';\n                Ask(q);\n              }\n            }\n          }\n        }\n      } else {\n        haha:\n        while (true) {\n          bool any = false;\n          for (int i = 0; i < n; i++) {\n            if (s[i] == \'?\') {\n              any = true;\n              break;\n            }\n          }\n          if (!any) {\n            break;\n          }\n          bool found = false;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] == \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] != \'?\' && s[i + 4] != \'?\') {\n              string q = ""C"";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += s[i + 4];\n              Ask(q);\n              if (s[i] == \'?\') {\n                q[0] = \'O\';\n                Ask(q);\n                if (s[i] == \'?\') {\n                  s[i] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] != \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] != \'?\' && s[i + 4] == \'?\') {\n              string q = """";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += ""C"";\n              Ask(q);\n              if (s[i + 4] == \'?\') {\n                q[4] = \'O\';\n                Ask(q);\n                if (s[i + 4] == \'?\') {\n                  s[i + 4] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] == \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] != \'?\') {\n              string q = ""C"";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              Ask(q);\n              if (s[i] == \'?\') {\n                q[0] = \'O\';\n                Ask(q);\n                if (s[i] == \'?\') {\n                  s[i] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] != \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] == \'?\') {\n              string q = """";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += ""C"";\n              Ask(q);\n              if (s[i + 3] == \'?\') {\n                q[3] = \'O\';\n                Ask(q);\n                if (s[i + 3] == \'?\') {\n                  s[i + 3] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] == \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\') {\n              string q = ""C"";\n              q += s[i + 1];\n              q += s[i + 2];\n              Ask(q);\n              if (s[i] == \'?\') {\n                q[0] = \'O\';\n                Ask(q);\n                if (s[i] == \'?\') {\n                  s[i] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] != \'?\' && s[i + 1] != \'?\' && s[i + 2] == \'?\') {\n              string q = """";\n              q += s[i];\n              q += s[i + 1];\n              q += ""C"";\n              Ask(q);\n              if (s[i + 2] == \'?\') {\n                q[2] = \'O\';\n                Ask(q);\n                if (s[i + 2] == \'?\') {\n                  s[i + 2] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          assert(found);\n        }\n      }\n    } else {\n      Ask(""CH"");\n      Ask(""CO"");\n      Ask(""HC"");\n      Ask(""HO"");\n      Ask(""OC"");\n      if (s == string(n, \'?\')) {\n        Ask(string(n, \'C\'));\n        if (s == string(n, \'?\')) {\n          Ask(""OHH"");\n          if (s == string(n, \'?\')) {\n            Ask(string(n - 1, \'O\'));\n            if (s == string(n, \'?\')) {\n              s = string(n, \'H\');\n            } else {\n              if (s[n - 1] == \'?\') {\n                s[n - 1] = \'H\';\n              }\n            }\n          } else {\n            for (int i = 0; i < n; i++) {\n              if (s[i] == \'?\') {\n                s[i] = \'O\';\n              } else {\n                break;\n              }\n            }\n            for (int i = n - 1; i >= 0; i--) {\n              if (s[i] == \'?\') {\n                s[i] = \'H\';\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        Ask(""OHH"");\n        int pref = 0, suf = 0;\n        int beg = 0;\n        while (beg < n) {\n          if (s[beg] != \'?\') {\n            ++beg;\n            continue;\n          }\n          int end = beg;\n          while (end + 1 < n && s[end + 1] == \'?\') {\n            ++end;\n          }\n          if (beg == 0) {\n            if (s[end + 1] != \'H\') {\n              for (int i = beg; i <= end; i++) {\n                s[i] = s[end + 1];\n              }\n            } else {\n              pref = end + 1;\n            }\n          } else {\n            if (end == n - 1) {\n              if (s[beg - 1] != \'O\') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              } else {\n                for (int i = beg; i <= end - 1; i++) {\n                  s[i] = \'O\';\n                }\n                suf = 1;\n              }\n            } else {\n              if (s[beg - 1] == \'O\' && s[end + 1] == \'H\') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = \'O\';\n                }\n              } else {\n                assert(s[beg - 1] == s[end + 1]);\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              }\n            }\n          }\n          beg = end + 1;\n        }\n        if (pref > 0) {\n          string q = s;\n          if (suf > 0) {\n            q.pop_back();\n          }\n          for (int i = 0; i < pref; i++) {\n            q[i] = \'O\';\n          }\n          Ask(q);\n          if (s[0] == \'?\') {\n            for (int i = 0; i < pref; i++) {\n              s[i] = \'H\';\n            }\n          }\n        }\n        if (suf > 0) {\n          string q = s;\n          q[n - 1] = \'O\';\n          Ask(q);\n          if (s[n - 1] == \'?\') {\n            s[n - 1] = \'H\';\n          }\n        }\n      }\n    }\n    cout << ""! "" << s << endl;\n    int foo;\n    cin >> foo;\n    if (foo == 0) break;\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'interactive', 'math']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Rin and The Unknown Flower.json,https://codeforces.com//blog/entry/73051,To be fair this is a complicated decision tree problem I recommend instead of heading straight to read the main solutions for this try to spend some time and come up with at least 2 solutions for the case when the query limit is 5 3 first spoilers There are many solutions when limit 5 3 and I ll point 2 of them out The difference between the two solutions is how you approach the string and build a decision tree out of those queries 1 disclose every joint of the string which is equivalent to find every position that S i S i 1 All remaining letters can be filled up with the nearest disclosed letter to it This can be done by asking 6 queries If none of the letters is disclosed then all of the letters are the same You can disclose all of them by asking 2 more queries of length n and determine what letter is it 2 in my opinion The idea of this is to disclose at least one letter of the string to disclose the rest with at most one string of length to each We could do this by simply asking This could go either way If a is disclosed at a position we can disclose the position with one query of length with one query of length and so on From there undisclose position with a query of length with a query of length and so on If no letter is disclosed the problem narrows down to solve with a binary string and total cost of There are multiple ways to tackle this so I won t spend any more time to explain this case The key here is to come up with a strategy that works in all branches of the decision tree And to do that we must find a good starting query set of queries to begin with In the two strategies above number 1 is too brutal and number 2 is too naive But my main solution contains the essences which can be seen in both solutions The main idea is to find a set of queries to begin with like strat 2 but would give us more hints and cost us less when things go the other way We ll start by asking queries with which in total have cost of That way the non disclosed parts can be one of those Consecutive similar characters A joint starting with Supposed that after four above queries and no occurrences were found at all the string can now be only in one of those kinds An entire string constructed by a single character A string of form with being either or In other words the string is constructed by characters followed by characters Proof for this is trivial We ll find the trace of large chunks of or cannot find every trace since the cost limit is very tight here the minimum length allowed should only be To do this we ll ask queries and sequentially If any of the two queries return occurrence s that means all occurrences of or has been revealed and also guaranteed to completely inherit the right side of the string any undisclosed characters on the left will obviously be From here we can conclude and return the original string However if both queries return nothing this means either the string contains only characters or there are at most rightmost characters being or Given this we ought to find the chunk of by asking query similar logic to the former step If it returns occurrence s and there are still undisclosed characters we ll need another query of length to finalize replacing all of the undisclosed positions to then ask a query with that string if it returns occurrence then is for the missing characters otherwise is This method works because there will always be one chunk with length at least on either end of the string except two cases and You will get to this if all three above queries failed to return anything However since this is a matter of picking one from two a single query of either string will work the original string is the asked string if occurrence found otherwise the other This is also the worst case in this branch Total cost would be very close to the limit Back to the case that some occurrence s are found when after asking the joint queries The logic now is pretty similar to strat 2 mentioned above however due to the more varied undisclosed patterns we ll need to take some extra caution First of all we ll start at the leftmost revealed segment and disclose any hidden characters to the left of it It s easy to see that the leftmost revealed character can never be and since the leftmost hidden segment always come in one of two forms similar to the no occurrence case branch above you can always reveal the nearest character by assuming it is the same as the current leftmost revealed character and use it as a query to ask If the assumption is incorrect then it and any remaining hidden letters to the left of it will be Now that we have a fully revealed prefix we ll extend it by revealing letters to the right For simplicity let s split into two cases one when there are revealed letter s not within our current prefix one when there is none If such revealed letters are found consider the one being closest to our prefix We can see that the hidden gap between our prefix and it can only be produced by some probably none characters being the same as our rightmost character in the prefix followed by some probably none characters being the same as our leftmost character outside of the prefix Thus we can simply assume the next hidden character is the same as our rightmost in prefix character then ask the query If the assumption is incorrect fill it and all the remaining hidden characters in that segment with the other one If there are none then the last hidden segment is again similar to the no occurrence case branch However we have a significant clue this time our rightmost in prefix character If it is not we can quickly fill all the hidden positions with it otherwise we ll keep asking query again assuming the next hidden character is still if incorrect take another query to ask if either it is or and then fill it and all the other hidden ones Example interaction The string is in other words the string is construct by appending character to the string 50 Finding joints not starting at O CH 0 CO 1 1 HC 0 HO 0 Now the string can be deduced as COO 0 Assuming that the third character is still sadly it isn t COC 0 Assuming that the third character is still and it isn t either By now we can deduce the string to be since the fourth character and beyond cannot be anything other than otherwise it would have raised a signal in the joints queries COHHHH 1 End of example The maximum cost for this will be because starting from a joint means we have at least found characters incremented by by the character we re about to guess With going to positive infinity the limit of this function will be therefore this solution still works spoilers Big credits to Sooke for making this problem more interesting by pointing out a way to reduce the initial limit 5 3 and make this problem much less trivial 
https://codeforces.com//contest/1454/problem/B,808361,B,1454B,1454,B. Unique Bid Auction,There is a game called Unique Bid Auction You can read more about it here https en wikipedia org wiki Unique bid auction though you don t have to do it to solve this problem Let s simplify this game a bit Formally there are n participants the i th participant chose the number a i The winner of the game is such a participant that the number he chose is i e nobody else chose this number except him and is i e among all unique values of a the minimum one is the winning one Your task is to find the of the participant who won the game or if there is no winner Indexing is 1 based i e the participants are numbered from 1 to n You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        map<int, vi> use;\n        f0r(i, n) use[a[i]].eb(i);\n        bool ok = false;\n        for (auto x : use) {\n            if (sz(x.s) == 1) {\n                ok = true;\n                ps(x.s[0] + 1);\n                break;\n            }\n        }\n        if (ok) continue;\n        ps(-1);\n    }\n    return 0;\n}']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Unique Bid Auction.json,https://codeforces.com//blog/entry/84984,This is a simple implementation problem Let s calculate two values for each from to the number of occurrences of in and any position of in Then let s iterate through from to and if just print because if it is the only such element then we found the winner If we didn t find any such element we have to print 
https://codeforces.com//contest/1461/problem/E,829210,E,1461E,1461,E. Water Level,In recent years John has very successfully settled at his new job at the office But John doesn t like to idly sit around while his code is compiling so he immediately found himself an interesting distraction The point of his distraction was to maintain a water level in the water cooler used by other zebras Originally the cooler contained exactly k liters of water John decided that the amount of water must always be at least l liters of water but no more than r liters John will stay at the office for exactly t days He knows that each day exactly x liters of water will be used by his colleagues At the beginning of each day he can add exactly y liters of water to the cooler but at any point in time the amount of water in the cooler must be in the range l r Now John wants to find out whether he will be able to maintain the water level at the necessary level for t days Help him answer this question ,"['//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<"" "";cout<<""\\n"";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int k, l, r, t, x, y;\n    cin>>k>>l>>r>>t>>x>>y;\n    set <int> s;\n    int f=0;\n    while(1)\n    {\n        int d=(k-l)/x;\n        t-=d;\n        if(t<=0)\n        break;\n        k-=(d*x);\n        if(s.find(k%x)!=s.end())\n        break;\n        if((k+y)>r)\n        {\n            f=1;\n            break;\n        }\n        s.insert(k%x);\n        k+=y;\n        if((k-x)<l)\n        {\n            f=1;\n            break;\n        }\n    }\n    if(f)\n    cout<<""No"";\n    else\n    cout<<""Yes"";\n}']",,,"['brute force', 'graphs', 'greedy', 'implementation', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Water Level.json,https://codeforces.com//blog/entry/85491,If it is quite easy to calculate the answer Note that at each iteration of the algorithm except perhaps the first the water level will decrease by x y liters and we will have to calculate whether it can decrease t times Otherwise lets note when we use the rise in water level we change the value of the expression mod At each step of the algorithm we will lower the water level as many times as we can and then raise the level Further we note that if we have already reached the value mod then we are in a cycle and therefore we will be able to maintain the water level If the water level is out of bounds then the answer is No 
https://codeforces.com//contest/2049/problem/F,3095890,F,2049F,2049,F. MEX OR Mania,An integer sequence b 1 b 2 ldots b n is if operatorname mex b 1 b 2 ldots b n b 1 b 2 ldots b n 1 Here operatorname mex c denotes the MEX text of the collection c and is the bitwise OR operator Shohag has an integer sequence a 1 a 2 ldots a n He will perform the following q updates on a i x increase a i by x After each update help him find the length of the longest good subarray text of a text The minimum excluded MEX of a collection of integers c 1 c 2 ldots c k is defined as the smallest non negative integer y which does not occur in the collection c text An array d is a subarray of an array f if d can be obtained from f by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include<bits/stdc++.h>\xa0using namespace std;\xa0#pragma GCC optimize(""O3,unroll-loops"")#pragma GCC optimize(""Ofast"",""inline"",""-ffast-math"")\xa0#define int long long #define F first #define S second #define pb push_backconst int mol=998244353;\xa0\xa0const int N = 1e5+5;multiset<int, greater<>>ans;struct Dsu{    int dsu[N], sz[N];    map<int, int>ha[N];    void init(int n){        for(int i=1;i<=n;i++) dsu[i]=i, sz[i]=1, ha[i].clear();    }\xa0    int find(int g){        if(g==dsu[g]) return g;        return dsu[g]=find(dsu[g]);    }    void un(int g, int h, int id){        g=find(g), h=find(h);                if(sz[g]>sz[h]) swap(g, h);        if(ha[g].size()==(1ll<<id)){            ans.erase(ans.find(sz[g]));        }        if(ha[h].size()==(1ll<<id)){            ans.erase(ans.find(sz[h]));        }                dsu[g]=h, sz[h]+=sz[g];        for(auto t: ha[g]){            ha[h][t.F]+=t.S;        }        if(ha[h].size()==(1ll<<id)){            ans.insert(sz[h]);        }    }}iu[20];int a[N], id[N];void solve(){    int n, q;    cin>>n>>q;    ans.clear();    ans.insert(0);    for(int i=0;i<20;i++) iu[i].init(n);    for(int i=1;i<=n;i++){        cin>>a[i];        id[i]=20;    }\xa0    vector<pair<int, int>>qq;    for(int i=1;i<=q;i++){        int g, h;        cin>>g>>h;        a[g]+=h;        qq.pb({g, h});    }\xa0    for(int i=19;i>=0;i--){        for(int j=1;j<=n;j++) if(a[j]<(1ll<<i)){            id[j]=i;            if(i==0) ans.insert(1);            iu[i].ha[j][a[j]]=1;        }        for(int j=1;j<n;j++){            if(a[j]<(1ll<<i)&&a[j+1]<(1ll<<i)){                iu[i].un(j, j+1, i);            }        }    }    vector<int>ansq(q+1);    for(int i=q;i>=1;i--){        ansq[i]=*ans.begin();        auto g=qq.back();qq.pop_back();        a[g.F]-=g.S;        for(int i=id[g.F];i<20;i++){            int t=iu[i].find(g.F);            iu[i].ha[t][a[g.F]+g.S]--;            if(iu[i].ha[t][a[g.F]+g.S]==0){                if(iu[i].ha[t].size()==(1ll<<i)) ans.erase(ans.find(iu[i].sz[t]));                iu[i].ha[t].erase(a[g.F]+g.S);            }            iu[i].ha[t][a[g.F]]++;            if(iu[i].ha[t].size()==(1ll<<i)&&iu[i].ha[t][a[g.F]]==1) ans.insert(iu[i].sz[t]);        }        while(id[g.F]>0){            if((1ll<<(id[g.F]-1))>a[g.F]){                id[g.F]--;                iu[id[g.F]].ha[g.F][a[g.F]]=1;                if(id[g.F]==0) ans.insert(1);                if(g.F>1&&a[g.F-1]<(1ll<<(id[g.F]))){                    iu[id[g.F]].un(g.F, g.F-1, id[g.F]);                }                if(g.F<n&&a[g.F+1]<(1ll<<(id[g.F]))){                    iu[id[g.F]].un(g.F, g.F+1, id[g.F]);                }            }            else break;        }    }\xa0    for(int i=1;i<=q;i++) cout<<ansq[i]<<""\\n"";}signed main(){    ios::sync_with_stdio(0);cin.tie(0);    int t;    cin>>t;    while(t--)    solve();    return 0;}']",,,"['bitmasks', 'brute force', 'data structures', 'dsu', 'implementation']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. MEX OR Mania.json,https://codeforces.com//blog/entry/137273,Let s figure out when a sequence is good Let be the maximum element of the sequence Notice that the bitwise OR of the sequence is at least and as MEX OR that means MEX has to be at least Which means all elements from to has to be present in the sequence As MEX can t be greater than the MEX has to be exactly Now we need to check for which the bitwise OR of the elements from to is exactly It s not hard to see that this is true for for some integer The reason is that all bits from to have to be set in for the OR to be and it s only possible if is of the form So a sequence is good if the maximum element is for some integer and all elements from to are present in the sequence Now let s see how to answer the queries without any updates To find the longest good subarray we can use a two pointers approach But a better way to do this is to fix the power and find the longest good subarray with maximum element To do this ignore the elements greater than and then split the array into segments of consecutive numbers where each segment has elements from to To check if a segment is good we can track the number of distinct elements in the segment If the number of distinct elements is then the segment is good So to sum it up for each power we will track some segments components and the number of distinct elements in them and also the lengths of the segments to get the longest one during queries Now regarding the updates it is hard to track everything if we do the updates normally But its s easier if we look at them in reverse order Then each update will be decreasing the value of by Then for each power we will have to add a new element to a component or merge two components For tracking distinct elements we can use a map or unordered map and to merge we can use DSU with small to large merging And that s pretty much it Please check my code for more details Overall complexity is or depending on if you use an unordered map or a map Solution 
https://codeforces.com//contest/1062/problem/C,254596,C,1062C,1062,C. Banh-mi,JATC loves Banh mi a Vietnamese food His affection for Banh mi is so much that he always has it for breakfast This morning as usual he buys a Banh mi and decides to enjoy it in a special way First he splits the Banh mi into n parts places them on a row and numbers them from 1 through n For each part i he defines the of the part as x i in 0 1 JATC s going to eat those parts one by one At each step he chooses arbitrary remaining part and eats it Suppose that part is the i th part then his of the Banh mi will increase by x i and the deliciousness of all the remaining parts will also increase by x i The initial enjoyment of JATC is equal to 0 For example suppose the deliciousness of 3 parts are 0 1 0 If JATC eats the second part then his enjoyment will become 1 and the deliciousness of remaining parts will become 1 1 Next if he eats the first part then his enjoyment will become 2 and the remaining parts will become 2 After eating the last part JATC s enjoyment will become 4 However JATC doesn t want to eat all the parts but to save some for later He gives you q queries each of them consisting of two integers l i and r i For each query you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range l i r i in some order All the queries are independent of each other Since the answer to the query could be very large print it modulo 10 9 7 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nint a[100006];\nint pre[100006];\n\nll ppow(ll a,ll n) {\n\tll ret=1,now=a;\n\twhile (n) {\n\t\tif (n&1) {\n\t\t\tret = (ret*now)%mod;\n\t\t}\n\t\tnow = (now*now)%mod;\n\t\tn >>=1;\n\t}\n\treturn ret;\n}\n\nint main () {\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint n,q;\n\tcin >> n >> q;\n\tstring s;\n\tcin >> s;\n\tfor (int i=1;i<=n;++i) {\n\t\tchar c = s[i-1];\n\t\tif (c == '0') a[i] = 0;\n\t\telse a[i] = 1;\n\t\tpre[i] = pre[i-1] + a[i];\n\t}\n\twhile (q--) {\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tlong long _1 = pre[r] - pre[l-1],len = r-l+1;\n\t\tcout << ( (ppow(2,_1)-1) + (ppow(2,_1)-1)*(ppow(2,len-_1)-1) )%mod << endl;\n\t}\n}\n""]",,,"['greedy', 'implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Banh-mi.json,https://codeforces.com/blog/entry/63199,For each part that we choose we need to calculate how many times that element is added to our score You can see that the first element that we choose is added times in our score the second element is added times and so on Therefore we just need to choose all the first and then all the remaining parts The final score is where is the number of and is the number of Complexity 
https://codeforces.com//contest/761/problem/A,90958,A,761A,761,A. Dasha and Stairs,On her way to programming school tiger Dasha faced her first test a huge staircase The steps were numbered from one to infinity As we know tigers are very fond of all striped things it is possible that it has something to do with their color So on some interval of her way she calculated two values the number of steps with even and odd numbers You need to check whether there is an interval of steps from the th to the th for which values that Dasha has found are correct ,"['#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == \'-\')\n\t\t\ts = -1, c = getChar();\n\t\twhile (\'0\' <= c && c <= \'9\')\n\t\t\tx = x * 10 + c - \'0\', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar(\'-\'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)(\'0\' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 1e6;\n\nint main()\n{\n\tint a, b;\n\tcin >> a >> b;\n\tif (a == 0 && b == 0)\n\t\tcout << ""NO"";\n\telse if (abs(a - b) > 1)\n\t\tcout << ""NO"";\n\telse\n\t\tcout << ""YES"";\n\treturn 0;\n}']",,,"['brute force', 'constructive algorithms', 'implementation', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Dasha and Stairs.json,https://codeforces.com//blog/entry/50179,It s obvious that if the answer is answer was also in the case when and are equal to because according to the statement such interval should exist In other cases the answer is 
https://codeforces.com//contest/768/problem/D,94875,D,768D,768,D. Jon and Orbs,Jon Snow is on the lookout for some orbs required to defeat the white walkers There are different types of orbs and he needs at least one of each One orb spawns daily at the base of a Weirwood tree north of the wall The probability of this orb being of any kind is equal As the north of wall is full of dangers he wants to know the minimum number of days he should wait before sending a ranger to collect the orbs such that the probability of him getting at least one of each kind of orb is at least where To better prepare himself he wants to know the answer for different values of Since he is busy designing the battle strategy with Sam he asks you for your help ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nconst ld TAU=2*acos(-1);\nconst ld eps=1e-7;\nconst int inf=1e9+99;\nconst ll linf=1e18+88;\n\n\n\nint32_t main() {\n\tconst int N=1024;\n\tstatic ld dp[2][N];\n\tint k,q; cin>>k>>q;\n\tdp[0][0]=1;\n\tvector<ld> Z={0};\n\tfor(;Z.back()<.5;) {\n\t\tstatic int qq=0;\n\t\tauto ndp=dp[qq^1];\n\t\tauto odp=dp[qq];\n\t\tqq^=1;\n\n\t\tfor(int i=0;i<=k;i++) ndp[i]=0;\n\t\tfor(int i=0;i<=k;i++) {\n\t\t\tndp[i]+=odp[i]*i/k;\n\t\t\tndp[i+1]+=odp[i]*(k-i)/k;\n\t\t}\n\n\n\t\tZ.push_back(ndp[k]);\n\t}\n\tfor(;q--;) {\n\t\tint p; cin>>p;\n\t\tld need = (p-eps)/2e3;\n\t\tcout<<lower_bound(Z.begin(),Z.end(),need)-Z.begin()<<endl;\n\t}\n}\n\n\n']",,,"['dp', 'math', 'probabilities']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Jon and Orbs.json,https://codeforces.com//blog/entry/50550,Set and Editorial by arnabsamanta This problem can be solve using inclusion exclusion principle but precision errors need to be handled Therefore we use the following dynamic programming approach to solve this problem On day there are two possibilities Case 1 Jon doesn t find a new orb then the probability of it is Case 2 Jon does find a new orb then the probability of it is Therefore We need to find the minimum such that where number of days Jon waited number of distinct orbs Jon have till now probability of Jon having distinct orbs in days Total number of distinct orbs possible Code 
https://codeforces.com//contest/1582/problem/G,1156638,G,1582G,1582,G. Kuzya and Homework,Kuzya started going to school He was given math homework in which he was given an array a of length n and an array of symbols b of length n consisting of symbols and Let s denote a for a segment l r 1 le l le r le n in the following way Let x 1 initially For every i from l to r we will consequently do the following if b i x x a i and if b i then x frac x a i Let s call for the segment l r a list of all x that we got during the calculations the number of them is exactly r l 1 For example let a 7 12 3 5 4 10 9 b l 2 r 6 then the path of calculations for that segment is 12 4 0 8 0 2 2 Let s call a segment l r if the path of calculations for it contains Kuzya needs to find the number of simple segments l r 1 le l le r le n Since he obviously has no time and no interest to do the calculations for each option he asked you to write a program to get to find that number ,"['#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = (1 << 20);\n\nvector<int> p;\n\nvoid solve(int n) {\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tstring b;\n\tcin >> b;\n\tvector<vector<pair<int, int>>> f(M);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint val = a[i];\n\t\tint op = (b[i] == \'*\' ? +1 : -1); \n\t\twhile (val > 1) {\n\t\t\tint p0 = p[val];\n\t\t\tint e0 = 0;\n\t\t\twhile (val % p0 == 0) {\n\t\t\t\tval /= p0;\n\t\t\t\te0 += op;\n\t\t\t}\n\t\t\tf[p0].push_back({i, e0});\n\t\t}\n\t}\n\tvector<int> g(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tg[i] = i;\n\t}\n\tfor (const auto& f0 : f) {\n\t\tif (!f0.empty()) {\n\t\t\tvector<pair<int, int>> sk;\n\t\t\tauto add = [&](int val, int pos) {\n\t\t\t\twhile (sk.size() > 0 && sk.back().first >= val) {\n\t\t\t\t\tsk.pop_back();\n\t\t\t\t}\n\t\t\t\tsk.push_back({ val, pos });\n\t\t\t};\n\t\t\tadd(0, 0);\n\t\t\tint cur = 0;\n\t\t\tfor (const auto& w : f0) {\n\t\t\t\tadd(cur, w.first);\n\t\t\t\tcur += w.second;\n\t\t\t\tint target =  -1;\n\t\t\t\tif (sk[0].first <= cur) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = sk.size();\n\t\t\t\t\twhile (hi - lo > 1) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (sk[mi].first <= cur) {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget = sk[lo].second;\n\t\t\t\t}\n\t\t\t\tg[w.first] = min(g[w.first], target);\n\t\t\t\tadd(cur, w.first + 1);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> h(n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\th[g[i] + 1].push_back(i);\n\t}\n\tset<int> w;\n\tw.insert(n);\n\tlong long r = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j : h[i]) {\n\t\t\tw.insert(j);\n\t\t}\n\t\twhile (*w.begin() < i) {\n\t\t\tw.erase(w.begin());\n\t\t}\n\t\tr += *w.begin() - i;\n\t}\n\tcout << r << endl;\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""g.in"", ""r"", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tp = vector<int>(M);\n\tfor (int i = 2; i < M; ++i) {\n\t\tif (p[i] == 0) {\n\t\t\tfor (int j = i; j < M; j += i) {\n\t\t\t\tp[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tsolve(n);\n\t}\n\treturn 0;\n}\n']",,,"['data structures', 'number theory']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\G. Kuzya and Homework.json,https://codeforces.com//blog/entry/96267,Notice that the segment is simple if for any prime number we will get a bracket sequence which has the minimal balance greater of equal to The bracket sequence is formed the following way we will iterate over the segment and add an opening bracket if we multiply by that number and a closing bracket if we divide by that number Let s consider the elements of the array and calculate the array wich contains the greatest left bound such that we can do the th operations in integer numbers with every To calculate such bounds for each prime number let s maintain all indices of its occurences in the numbers of in a stack if the prime numbers occurs in a number several times we need to store the index several times If the th operation is the operation of multiplying then is equal to and for all prime divisors of the number we need to add the index and if it s the operation of division then for all prime divisors of we need to delete indices in the same amount as the prime divisor occurs in and save the smallest erased index in If for any prime divisor we had to erase an index from an empty stack then we got a non integer result so Now that we know the values of the array we need to calculate the number of segments such that where is the minimal value of on segment We can do that using segment tree on minimum in iterate over the left bound and traversing the tree from the root find the greatest right bound for current left one or using linear algorithms with a stack to do that let s iterate over all left bounds in decreasing order and maintain a stack on minimum on the array 
https://codeforces.com//contest/670/problem/D2,59598,D2,670D2,670,D2. Magic Powder - 2,The term of this problem is the same as the previous one the only exception increased restrictions ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e5 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\n    int n, k;\n    vector <int> a, b;\n\nbool can(ll x) {\n    ll need = 0;\n    for (int i = 0; i < n; ++i) {\n        need += max(0LL, a[i] * 1LL * x - b[i]);\n        if (need >k) return false;\n    }\n    return need <= k;\n}\n\nint main() {\n\n  //  freopen(""input.txt"", ""r"", stdin);\n  //  freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    a.resize(n);\n    b.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n\n    ll l = 0, r = 4LL * INF;\n    for (int iter = 0; iter < 50; ++iter) {\n        ll m = (l + r) / 2;\n        if (can(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    cout << l << \'\\n\';\n    return 0;\n}\n']",,,"['binary search', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D2. Magic Powder - 2.json,https://codeforces.com//blog/entry/44715,Here we will use binary search on the answer Let s we check the current answer equals to Then the objective function must be realized in the following way Let s store in the variable how many grams of the magic powder we need to bake cookies Let s iterate through the ingredients and the current ingredient has the number Then if let s make If after looking on some ingredient becomes more than the objective function must return If there is no such an ingredient the objective function must return If the objective function returned we need to move the left end of the binary search to the else we need to move the right end of the binary search to the 
https://codeforces.com//contest/1811/problem/G1,1864329,G1,1811G1,1811,G1. Vlad and the Nice Paths  easy version , Vlad found a row of n tiles and the integer k The tiles are indexed from left to right and the i th tile has the color c i After a little thought he decided what to do with it You can start from any tile and jump to any number of tiles forming the path p Let s call the path p of length m if p can be divided into blocks of length exactly k that is m is divisible by k c p 1 c p 2 ldots c p k c p k 1 c p k 2 ldots c p 2k ldots c p m k 1 c p m k 2 ldots c p m Your task is to find the number of paths of length Since this number may be too large print it modulo 10 9 7 ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint f[105][105];\nint g[105][105];\nint a[105];\n\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= k; j++) {\n      f[i][j] = 0;\n      g[i][j] = 0;\n    }\n  }\n//  for (int i = 0; i <= n; i++) {\n//    g[i][0] = 1;\n//  }\n  for (int i = 1; i <= n; i++) {\n    f[i][1] = 1;\n    g[i][1] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k; j++) {\n      int jj = j - 1 > 0 ? j - 1 : k;\n      for (int ii = 1; ii < i; ii++) {\n        if (j == 1 || a[ii] == a[i]) {\n          if (!f[ii][jj]) continue;\n          if (f[i][j] < f[ii][jj] + 1) {\n            f[i][j] = f[ii][jj] + 1;\n            g[i][j] = g[ii][jj];\n          } else if (f[i][j] == f[ii][jj] + 1) {\n            (g[i][j] += g[ii][jj]) %= MOD;\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n//    if (f[i][0] == 10) cerr << i << "" "" << g[i][0] << endl;\n    if (mx < f[i][k]) {\n      mx = f[i][k];\n      tot = g[i][k];\n    } else if (mx == f[i][k]) {\n      (tot += g[i][k]) %= MOD;\n    }\n  }\n//  cerr << mx << endl;\n  if (mx == 0) {\n    cout << 1 << ""\\n"";\n    return;\n  }\n  cout << tot << ""\\n"";\n}\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n  int tt; cin >> tt;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n']",,,"['combinatorics', 'dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G1. Vlad and the Nice Paths  easy version .json,https://codeforces.com//blog/entry/114788,Let s use the dynamic programming Let be the number of paths on the prefix of blocks of the same color To make transitions in such dynamics for the position we will iterate over the position in which the block started Denote as the number of the same elements as and between them then such a transition creates combinations This solution works in complexity 
https://codeforces.com//contest/815/problem/D,110362,D,815D,815,D. Karen and Cards,Karen just got home from the supermarket and is getting ready to go to sleep After taking a shower and changing into her pajamas she looked at her shelf and saw an album Curious she opened it and saw a trading card collection She recalled that she used to play with those cards as a child and although she is now grown up she still wonders a few things about it Each card has three characteristics and The values of all characteristics of all cards are positive integers The maximum possible strength any card can have is the maximum possible defense is and the maximum possible speed is There are cards in her collection The th card has a strength defense and speed respectively A card another card if at least two of its characteristics are than the corresponding characteristics of the other card She now wonders how many different cards can beat all the cards in her collection Two cards are considered different if at least one of their characteristics have different values ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst long long inf=1000*1000*1000+7;\nconst int n1=(1<<19);\n\nint n, p, q, r;\n\nstruct drz\n{\n\tdrz* lew=NULL;\n\tdrz* pra=NULL;\n\t\n\tlong long fixed=0;\n\tlong long freed=0;\n\t\n\tlong long czyt(int a, int b, int graa, int grab, long long poz)\n\t{\n\t\tif (a>=graa && b<=grab)\n\t\t{\n\t\t\t//debug() << "" na "" << a << "" "" << b << "" "" << imie(fixed) << "" "" << imie(freed);\n\t\t\treturn fixed+freed*(r-poz);\n\t\t}\n\t\tif (a>grab || b<graa)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn lew->czyt(a, (a+b)>>1, graa, grab, poz)+pra->czyt((a+b+2)>>1, b, graa, grab, poz);\n\t}\n\tdrz* fixuj(int a, int b, int cel, long long poz)\n\t{\n\t\tif (a>cel || b<cel)\n\t\t\treturn this;\n\t\tdrz *ret=new drz;\n\t\tif (a==b)\n\t\t{\n\t\t\tret->fixed=r-poz;\n\t\t\tret->freed=0;\n\t\t\treturn ret;\n\t\t}\n\t\tret->lew=lew->fixuj(a, (a+b)>>1, cel, poz);\n\t\tret->pra=pra->fixuj((a+b+2)>>1, b, cel, poz);\n\t\tret->fixed=ret->lew->fixed+ret->pra->fixed;\n\t\tret->freed=ret->lew->freed+ret->pra->freed;\n\t\treturn ret;\n\t}\n};\n\nint a[nax];\nint b[nax];\nint c[nax];\n\nvector <int> weka[nax];\nvector <int> wekc[nax];\n\ndrz* wys[nax];\n\nlong long wyn;\n\ndrz* start(int a, int b)\n{\n\tdrz* ret=new drz;\n\tif (a!=b)\n\t{\n\t\tret->lew=start(a, (a+b)>>1);\n\t\tret->pra=start((a+b+2)>>1, b);\n\t\tret->freed=ret->lew->freed+ret->pra->freed;\n\t}\n\telse\n\t{\n\t\tret->freed=(b<=q);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d%d%d%d"", &n, &p, &q, &r);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d%d%d"", &a[i], &b[i], &c[i]);\n\t\tweka[a[i]].push_back(i);\n\t\twekc[c[i]].push_back(i);\n\t}\n\twys[r+1]=start(1, n1);\n\tint juz=0;\n\tfor (int i=r; i; i--)\n\t{\n\t\twys[i]=wys[i+1];\n\t\tfor (int j : wekc[i])\n\t\t{\n\t\t\twhile (b[j]>juz)\n\t\t\t{\n\t\t\t\tjuz++;\n\t\t\t\twys[i]=wys[i]->fixuj(1, n1, juz, i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint pra=0;\n\tint gor=0;\n\t\n\tfor (int i=p; i; i--)\n\t{\n\t\tfor (int j : weka[i])\n\t\t{\n\t\t\tpra=max(pra, b[j]);\n\t\t\tgor=max(gor, c[j]);\n\t\t}\n\t\t//debug() << ""dla "" << i << "" "" << imie(pra) << imie(gor);\n\t\twyn+=wys[gor+1]->czyt(1, n1, pra+1, q, gor);\n\t\t//debug() << wyn;\n\t}\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['binary search', 'combinatorics', 'data structures', 'geometry']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Karen and Cards.json,https://codeforces.com//blog/entry/52742,Let s say we have one card with and For simplicity we have Consider which cards will beat this one Let s fix the of our card and see what happens at all various Note that a green cell at in grid represents that the card can beat the card Hence the total number of cards that can beat this card is simply the number of green cells across all grids This representation is helpful because we can easily account for more cards For example let s say we have another card and Now what happens when we want to consider the cards that beat of these cards Well we simply have to consider the of both sets of grids Remember that we are simply trying to count the total number of green cells in all grids It turns out that trying to count the number of green cells directly is quite difficult Instead it is more feasible to count the number of cells and then simply subtract it from the number of cells How could we do this We should exploit some properties of the grids First for any particular card all the grids from to are the same and all the grids from to are the same This means that we can avoid a lot of redundancy and only perform some sort of update when we reach the change Second if some cell is not green for some fixed then neither are the cells for all and for the same This means that we can replace each grid with an array where is the largest for which is not green Additionally Third for any card there are only at most two distinct values in for any fixed in one card Finally for any card no value in is less than in if These properties are all pretty easy to observe and prove but they will form the bread and butter of our solution Let s iterate cards from to Suppose we maintain an array which will at first contain all This will be the number of cells that are not green We will update it for all grids first For each card we are essentially setting for all to Of course doing this for each grid will take which is too slow To remedy this initialize as a instead Now we are basically just setting to for all cards Because is essentially a maximum of a bunch of s which are all nonincreasing by the second property it follows that is also nonincreasing at all times Therefore these updates are easy to do we are essentially setting to for the smallest where We can find using binary search Binary searching the segment tree can be done in time using an implicit binary search by going down the tree an explicit binary search might have trouble passing the time limit Using the aforementioned procedure we are able to generate corresponding to the layer in time Using the segment tree we should also be able to get the sum of all values in at all times This will allow us to count the number of not green cells Now we will go backwards from to We should decrement and then see which grids changed Just sort the cards by and do a two pointers approach All the newly changed grids can then be updated in a similar manner as before When a grid changes thanks to the fourth property there is no worry of any getting smaller than it was before they can only get bigger So we have to update two ranges to and to The former is a simple range update the latter can be done using binary search like before After we update all grids for a particular get the range sum and decrement again and so on until we reach We will have the found the total number of not green cells in all and from there we can recover all the green cells and hence the final answer Sorting the cards by takes time constructing the segment tree takes time there are updates each taking time and iterating takes time The final runtime is therefore time which is sufficient to solve this problem This solution can be modified to pass too however this was not done as it uses only standard ideas and just contains more tedious implementation If you want you can try to implement it 
https://codeforces.com//contest/822/problem/D,112701,D,822D,822,D. My pretty girl Noora,In Pavlopolis University where Noora studies it was decided to hold beauty contest Miss Pavlopolis University Let s describe the process of choosing the most beautiful girl in the university in more detail The contest is held in several stages Suppose that exactly girls participate in the competition initially All the participants are divided into equal groups participants in each group Furthermore the number is chosen arbitrarily i e on every stage number can be different Within each group the jury of the contest compares beauty of the girls in the format each with each In this way if group consists of girls then comparisons occur Then from each group the most beautiful participant is selected Selected girls enter the next stage of the competition Thus if girls were divided into groups participants in each group then exactly participants will enter the next stage The contest continues until there is exactly one girl left who will be Miss Pavlopolis University But for the jury this contest is a very tedious task They would like to divide the girls into groups in each stage so that the total number of pairwise comparisons of the girls is as few as possible Let be the minimal total number of comparisons that should be made to select the most beautiful participant if we admit girls to the first stage The organizers of the competition are insane They give Noora three integers and and ask the poor girl to calculate the value of the following expression However since the value of this expression can be quite large the organizers ask her to calculate it modulo If Noora can calculate the value of this expression the organizers promise her to help during the beauty contest But the poor girl is not strong in mathematics so she turned for help to Leha and he turned to you ,"['#include <bits/stdc++.h>\n\nconst int MOD = 1E9 + 7;\n\nstd::vector <int> prime;\nbool is_nonprime[5100000];\nint f[5100000];\n\nint main () {\n\tfor (int i = 2; i <= 5000000; ++i) {\n\t\tif (!is_nonprime[i]) {\n\t\t\tprime.push_back (i);\n\t\t\tf[i] = 1LL * i * (i - 1) / 2 % MOD;\n\t\t}\n\t\tfor (int j = 0; i * prime[j] <= 5000000 && j < prime.size (); ++j) {\n\t\t\tis_nonprime[i * prime[j]] = true;\n\t\t\tf[i * prime[j]] = (f[i] + (1LL * prime[j] * (prime[j] - 1) / 2 % MOD) * i % MOD) % MOD;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n\tint T, L, R;\n\tscanf (""%d%d%d"", &T, &L, &R);\n\tint mul = 1, ans = 0;\n\tfor (int i = L; i <= R; ++i) {\n//\t\tprintf (""%d\\n"", f[i]);\n\t\tans = (ans + 1LL * mul * f[i] % MOD) % MOD;\n\t\tmul = (1LL * mul * T) % MOD;\n\t}\n\tprintf (""%d\\n"", ans);\n}\n\n']",,,"['brute force', 'dp', 'greedy', 'math', 'number theory']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. My pretty girl Noora.json,https://codeforces.com//blog/entry/53068?locale=en,Suppose we have already calculated Then calculating the value of the expression is easy Consider process of calculating Suppose we found optimal answer Represent this answer as sequence of integers on the first stage we will divide girls into groups of participants on the second stage into groups of participants and so on Let us prove that all should be prime Suppose some is a composite number Then it can be decomposed into two numbers In addition let girls are admitted to the th stage Then on current th stage comparisons will occur But if we divide this stage into two new stages then number of comparisons is So we proved that all should be prime Then it s easy to write DP which will be calculated by transition from the state to the states given by dividing current state by prime divisors For solving this task we can use Eratosthenes sieve Total complexity is same as complexity of Eratosthenes sieve In addition you can prove the fact that we should split the girls into groups by prime numbers in the order of their increasing This optimization significantly accelerates the algorithm 
https://codeforces.com//contest/372/problem/C,4184,C,372C,372,C. Watching Fireworks is Fun,A festival will be held in a town s main street There are sections in the main street The sections are numbered through from left to right The distance between each adjacent sections is In the festival fireworks will be launched The th launching is on time at section If you are at section at the time of th launching you ll gain happiness value note that the happiness value might be a negative value You can move up to length units in a unit time interval but it s prohibited to go out of the main street Also you can be in an arbitrary section at initial time moment time equals to and want to maximize the sum of happiness that can be gained from watching fireworks Find the maximum total happiness Note that two or more fireworks can be launched at the same time ,"['#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n//#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(int)n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ACCU accumulate\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<ll> VL;\nconst ll mod=1000000007,inf=(1ll<<60);\nconst double eps=1e-9;\nconst double pi=acos(0)*2;\nll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\nconst int N=150100;\nll dp[N],pd[N],ans;\nint q[N],n,m,d,prt,a[567],b[567],t[567];\n\nvoid transfer(int leg,int a,int b) {\n\tint h=1,t=0;\n\tmemset(q,0,sizeof(q));\n\trep(i,0,leg) {\n\t\twhile (h<=t&&dp[i]>dp[q[t]]) --t;\n\t\tq[++t]=i;\n\t}\n\trep(i,0,n) {\n\t\tif (i+leg<n) {\n\t\t\twhile (h<=t&&dp[i+leg]>dp[q[t]]) --t;\n\t\t\tq[++t]=i+leg;\n\t\t}\n\t\twhile (h<=t&&i-q[h]>leg) h++;\n\t\tpd[i]=dp[q[h]];\n\t}\n\trep(i,0,n) pd[i]+=b-abs(a-i);\n}\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&d);\n\tprt=1;\n\trep(i,0,m) {\n\t\trep(j,0,n) pd[j]=-inf;\n\t\tscanf(""%d%d%d"",a+i,b+i,t+i);--a[i];\n\t\ttransfer(min(1ll*(t[i]-prt)*d,1ll*n),a[i],b[i]);\n\t\trep(j,0,n) dp[j]=pd[j];prt=t[i];\n\t}\n\tans=-inf;\n\trep(i,0,n) ans=max(ans,pd[i]);\n\tprintf(""%I64d\\n"",ans);\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Watching Fireworks is Fun.json,https://codeforces.com/blog/entry/9944,I think most of the participants came up with simple DP algorithm dp i j the maximum happiness value that you can gain when you re on poisition j at i th launching Each value in table can be calculated by this formula where If you look up for all k since the table s size is O mn the overall complexity will be O mn 2 and its too slow to solve the problem Now We re going to make this algorithm faster Since the second term in the DP formula doesn t depend on k you have to find maximum value of dp i 1 j k faster Using segment tree or sparse table can fasten finding from O n to O log n but the overall complexity is still O mn log n and the solution will get time limit exceeded Intended solution uses sliding window maximum see this page http people cs uct ac za ksmith articles sliding window minimum html for some information since the interval is independent for all the fireworks It can be implemented by simple array or deque This will speed up to calculate formula and overall complexity will be O mn kcm1700 has submitted faster solution than our intended one during contest It s complexity is O m 2 Please read his comment http codeforces com blog entry 9907comment 153963 for further information My solution http ideone com Unrfaa kcm1700 s solution http codeforces com contest 372 submission 5431649 
https://codeforces.com//contest/18/problem/C,84,C,18C,18,C. Stripe,Once Bob took a paper stripe of squares the height of the stripe is 1 square In each square he wrote an integer number possibly negative He became interested in how many ways exist to cut this stripe into two pieces so that the sum of numbers from one piece is equal to the sum of numbers from the other piece and each piece contains positive integer amount of squares Would you help Bob solve this problem ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""g""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\n\nint const N=100005;\n\nint a[N], s[N];\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n\n\n    int n;\n    cin >> n;\n    s[0]=0;\n    for (int i=1; i<=n; i++) {\n        cin >> a[i];\n        s[i]=s[i-1]+a[i];\n    }\n    int res=0;\n    for (int i=1; i<n; i++)\n        if (s[i]+s[i]==s[n])\n            res++;\n    cout << res << endl;\n    return 0;\n}']",,,"['data structures', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Stripe.json,https://codeforces.com//blog/entry/463,One should keep two sums S1 ans S2 where S1 is the sum of all numbers on the left part of the stripe and S2 is the sum of the right one At the beginning S1 0 and S2 equals to the sum of all numbers of the stripe Then we move the border of the parts within a cycle from left to right recalculating the values of S1 and S2 each iteration and increasing the answer when it s necessary 
https://codeforces.com//contest/383/problem/E,5726,E,383E,383,E. Vowels,Iahubina is tired of so many complicated languages so she decided to invent a new simple language She already made a dictionary consisting of 3 words A 3 word is a sequence of exactly lowercase letters of the first 24 letters of the English alphabet to She decided that some of the letters are vowels and all the others are consonants The whole language is based on a simple rule any word that contains at least one vowel is Iahubina forgot which letters are the vowels and wants to find some possible correct sets of vowels She asks Iahub questions In each question she will give Iahub a set of letters considered vowels in this question For each question she wants to know how many words of the dictionary are correct considering the given set of vowels Iahubina wants to know the of the squared answers to all the possible questions There are different questions they are all subsets of the set of the first 24 letters of the English alphabet Help Iahub find that number ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nvoid norm(int *f) {\n  for (int m = (1 << 12) - 1; m >= 0; m--) {\n    int res = 0;\n    for (int sub = m;; sub = (sub - 1) & m) {\n      res += f[sub];\n      if (!sub) break;\n    }\n    f[m] = res;\n  }\n}\n\nint fir[(1 << 12) + 10], las[(1 << 12) + 10];\nint fpc[12][(1 << 12) + 10];\nint lpc[12][(1 << 12) + 10];\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n;\n  while (scanf(""%d"", &n) >= 1) {\n    memset(fir, 0, sizeof fir);\n    memset(las, 0, sizeof las);\n    memset(fpc, 0, sizeof fpc);\n    memset(lpc, 0, sizeof lpc);\n\n    const int FIM = (1 << 12) - 1;\n    const int LAM = FIM << 12;\n\n    vi msks(n);\n    for (int i = 0; i < n; i++) {\n      char s[4];\n      scanf(""%s"", s);\n      int msk = 0;\n      for (int i2 = 0; s[i2]; i2++)\n        msk |= 1 << (s[i2] - \'a\');\n      msks[i] = msk;\n\n      int a = msk & FIM, b = (msk & LAM) >> 12;\n      int apos = __builtin_ctz(a);\n      int bpos = __builtin_ctz(b);\n\n      if (__builtin_popcount(a) == 0) {\n        las[b]++;\n      } else if (__builtin_popcount(b) == 0) {\n        fir[a]++;\n      } else if (__builtin_popcount(a) == 1) {\n        lpc[apos][b]++;\n      } else if (__builtin_popcount(b) == 1) {\n        fpc[bpos][a]++;\n      } else {\n        assert(false);\n      }\n    }\n    eprintf(""go\\n"");\n    norm(fir);\n    norm(las);\n    for (int i = 0; i < 12; i++)\n      norm(fpc[i]), norm(lpc[i]);\n    eprintf(""go2\\n"");\n\n    int ans = 0;\n    for (int m = 0; m < (1 << 24); m++) { // consonant is 1, vowel is 0\n      int cnt = 0;\n     \n      // cnt <-- number of bad, that is, subsets if \'m\'\n      cnt += fir[m & FIM];\n      cnt += las[(m & LAM) >> 12];\n      for (int i = 0; i < 12; i++) if (m & (1 << i))\n        cnt += lpc[i][(m & LAM) >> 12];\n      for (int i = 0; i < 12; i++) if (m & (1 << (12 + i)))\n        cnt += fpc[i][m & FIM];\n\n//      eprintf(""cnt=%d\\n"", cnt);\n      cnt = n - cnt;\n\n/*      int rcnt = 0;\n      for (int i = 0; i < n; i++) {\n        rcnt += ((~m & msks[i]) != 0);\n      }\n      if (cnt != rcnt) {\n        eprintf(""m=%d; found %d != expected %d\\n"", ~m & (FIM | LAM), cnt, rcnt);\n        exit(0);\n      }*/\n      ans ^= cnt * cnt;\n    }\n    printf(""%d\\n"", ans);\n  }\n  return 0;\n}\n']",,,"['combinatorics', 'divide and conquer', 'dp']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Vowels.json,https://codeforces.com/blog/entry/10476,Let s iterate over all possible vowel sets For a given set x1 x2 xk we re interested in number of correct words from dictionary After a precalculation we can do it in O k Suppose our current vowel set is x1 x2 xk How many words are covered by the current vowels By definition we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set We can calculate this number using principle of inclusion and exclusion We ll denote by v1 v2 v3 number of words containing ALL of vowels v1 v2 v3 Using principle of inclusion and exclusion we get number of words covered x1 x2 xk x1 x2 x1 x3 x1 x2 x3 x1 x2 x4 xk 2 xk 1 xk This formula is simply a reformulation of principle of inclusion and exclusion You can easily observe that v1 v2 vk makes sense only when k is at most 3 as no word from input can contain 4 or more letters and hence can t contain 4 or more vowels Example Suppose words are abc abd and bcd a 2 first 2 words both contain character a a b 2 as well first 2 words contain characters a and b b 3 all 3 words contain character b a b d 1 only second word contains all 3 characters Also note how principle of inclusion and exclusion works number of words covered for vowels a b is a b a b 2 3 2 Indeed answer is 3 We divide our problem in 3 subproblems First one for a vowel set compute sum of a where a is a letter from subset Second compute sum of a b where both a and b are letters from set Third compute sum of a b c where a b c are letters from set As stated the answer is number from 1st step number from 3rd step number from 2nd step If you followed me you ll see that we want to compute results for each subproblem in O queryLetters First subproblem can be solved trivially in O queryLetters Let array single with following meaning single c is how many words contain character c It can be trivially precomputed in O 24 N Note that if a word contains twice third times a character c it needs to be counted only one e g word aba will add only 1 to single a For compute result of this subproblem for a given set of vowels I ll take all letters from set If letter belongs to set I add to result single letter This step can be also be solved in O 1 but there s no need since other subproblems allow only an O queryLetters solution For second and third subproblems it s a little more difficult I ll present here how to solve second subproblem and some hints for third one if you understand second with hints you should be able to solve third one by your own Similarly to first step I ll define a matrix double c1 c2 how many words contain both characters c1 and c2 A trivially solution would be for a given vowel set take all combinations of letters c1 and c2 that belong to set and add to result value double c1 c2 However this solves each query in O queryLetters 2 which is too slow Note if we d have 12 letters instead of 24 this approach would be fast enough From here it comes a pretty classical idea in exponential optimization meet in the middle attack We split those 24 letters in 2 groups first 12 letters and last 12 letters The answer for a subset is sum of double c1 c2 when c1 and c2 belong to current vowel set when 1 c1 and c2 belong to first 12 letters 2 c1 and c2 belong to last 12 letters 3 c1 belongs to first 12 letters and c2 belongs to last 12 letters 1 and 2 can be immediately precalculated as stated above in O 2 12 12 2 We ll remember results for each half using bitmasks arrays Let Half1 mask sum over double c1 c2 when c1 and c2 are in first 12 letters and correspond to 1 bits of mask Half2 mask is defined similarly but for last 12 letters e g subset a c d corresponds to bitmask 2 0 2 2 2 3 13 in first half and subset m n p corresponds to bitmask 2 0 2 1 2 3 11 for second half Now for a given subset one can answer first 2 parts in O queryCount worst case read input for a query and convert it to bitmasks How to answer 3 With another precalculation of course We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters The precalculation we do here is mixed half mask i sum over c1 c2 when c1 belongs to first half and is a 1 bit of mask and c2 is i th character of second half Hence for a query we can fix character from second half c2 by iteration of query letters from second half and know sums of c1 c2 between it and all available characters from first half after we do this precalculation Also precalculation is done trivially in O 2 12 12 2 fix mask fix i and then iterate over 1 bits from mask and add double c1 c2 Third subproblem is left but it can be done similarly to second one Instead of double c1 c2 we ll have triple c1 c2 c3 how many words contain all 3 characters c1 c2 and c3 We also do meet in the middle here divide those 24 letters into 2 sets of 12 letters We have 4 cases 1 c1 c2 c3 belong to first half 2 c1 c2 c3 belong to second half 3 c1 c2 belong to first half and c3 to second half 4 c1 belongs to first half and c2 c3 to second half 1 and 2 are done brute force like in second subproblem the only difference is we choose 3 characters instead of 2 having complexity O 2 12 12 3 For 3 and 4 we also precompute 2 matrixes mixed two one mask i c1 and c2 belong to mask from first half and c3 is i th character from second half and mixed one two mask i c1 is i th character from first half and c2 c3 belong to mask from second half Those can also be calculated in O 2 12 12 3 So precalculation part is O 2 12 12 3 7077888 operations For calculate answering queries complexity take all numbers from 0 to 2 24 1 and sum their bit count This is a well known problem the sum is 0 C 24 0 1 C 24 1 24 C 24 24 201326592 In total we get 208404480 operations C source makes them in 2 seconds 
https://codeforces.com//contest/713/problem/A,71345,A,713A,713,A. Sonya and Queries,Today Sonya learned about long integers and invited all her friends to share the fun Sonya has an initially empty multiset with integers Friends give her queries each of one of the following type add non negative integer to the multiset Note that she has a multiset thus there may be many occurrences of the same integer delete a single occurrence of non negative integer from the multiset It s guaranteed that there is at least one in the multiset count the number of integers in the multiset with repetitions that match some pattern consisting of and In the pattern stands for the even digits while stands for the odd Integer matches the pattern if the parity of the th from the right digit in decimal notation matches the th from the right digit of the pattern If the pattern is shorter than this integer it s supplemented with s from the left Similarly if the integer is shorter than the pattern its decimal notation is supplemented with the s from the left For example if the pattern is than integers and match the pattern while integers and do not ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, ap[(1 << 19) + 2];\nchar sir[30];\n\nint main ()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nscanf (""%d\\n"", &M);\nwhile (M --)\n{\n    char type;\n    scanf (""%c "", &type);\n    if (type == \'+\' || type == \'-\')\n    {\n        long long x;\n        scanf (""%I64d\\n"", &x);\n        long long msk = 0;\n        for (int i=18; i>=0; i--)\n        {\n            int dig = x % 10;\n            if (dig & 1) msk |= 1 << i;\n            x /= 10;\n        }\n        if (type == \'+\') ap[msk] ++;\n        else ap[msk] --;\n        continue;\n    }\n    gets (sir + 1), N = strlen (sir + 1);\n    int j = N, msk = 0;\n    for (int i=18; i>=0; i--)\n    {\n        bool curr = 0;\n        if (j >= 1) curr = sir[j] - \'0\', j --;\n        if (curr) msk |= 1 << i;\n    }\n    printf (""%d\\n"", ap[msk]);\n}\n\nreturn 0;\n}\n']",,,"['data structures', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Sonya and Queries.json,https://codeforces.com//blog/entry/47094,Lets exchange every digit by value of digit modulo and receive binary string We will convert it to binary form in number array for counts If we have query we increase If we have query we decrease Otherwise we output 
https://codeforces.com//contest/154/problem/B,955,B,154B,154,B. Colliders,By 2312 there were Large Hadron Colliders in the inhabited part of the universe Each of them corresponded to a single natural number from to However scientists did not know what activating several colliders simultaneously could cause so the colliders were deactivated In 2312 there was a startling discovery a collider s activity is safe if and only if all numbers of activated colliders are pairwise relatively prime to each other two numbers are relatively prime if their greatest common divisor equals If two colliders with relatively nonprime numbers are activated it will cause a global collapse Upon learning this physicists rushed to turn the colliders on and off and carry out all sorts of experiments To make sure than the scientists quickness doesn t end with big trouble the Large Hadron Colliders Large Remote Control was created You are commissioned to write the software for the remote well you do not expect anybody to operate it manually do you Initially all colliders are deactivated Your program receives multiple requests of the form activate deactivate the th collider The program should handle requests in the order of receiving them The program should print the processed results in the format described below To the request of that is to activate the th collider the program should print exactly one of the following responses if the activation was successful if the th collider was already activated before the request if there is a conflict with the th collider that is the th collider is on and numbers and are not relatively prime In this case the th collider shouldn t be activated If a conflict occurs with several colliders simultaneously you should print the number of any of them The request of that is to deactivate the th collider should receive one of the following responses from the program if the deactivation was successful if the th collider was already deactivated before the request You don t need to print quotes in the output of the responses to the requests ,"['#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> di[101000];\nbool ison[101000];\nint cnt[101000];\nvector<int> as[101000];\ninline void seton(int x){\n    ison[x]=1;\n    for(int i=1;i<di[x].size();i++){\n        cnt[di[x][i]]++;\n        as[di[x][i]].push_back(x);\n    }\n}\ninline void setoff(int x){\n    ison[x]=0;\n    for(int i=1;i<di[x].size();i++)cnt[di[x][i]]--;\n}\ninline int conf(int x){\n    int i;\n    for(i=1;i<di[x].size();i++){\n        if(cnt[di[x][i]]){\n            while(1){\n                int r=as[di[x][i]][as[di[x][i]].size()-1];\n                if(ison[r])return r;\n                as[di[x][i]].pop_back();\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    int n,m,i,j;\n    scanf(""%d%d"",&n,&m);\n    vector<int> d2;\n    for(i=1;i<=n;i++){\n        d2.clear();\n        for(j=1;j*j<=i;j++){\n            if(i%j==0){\n                di[i].push_back(j);\n                if(j*j!=i)d2.push_back(i/j);\n            }\n        }\n        for(j=d2.size()-1;j>=0;j--)di[i].push_back(d2[j]);\n    }\n    while(m--){\n        char tmp[10];\n        int x;\n        scanf(""%s%d"",tmp,&x);\n        if(tmp[0]==\'+\'){\n            if(ison[x])puts(""Already on"");\n            else{\n                int d=conf(x);\n                if(d==-1){\n                    seton(x);\n                    puts(""Success"");\n                }else printf(""Conflict with %d\\n"",d);\n            }\n        }else{\n            if(!ison[x])puts(""Already off"");\n            else{\n                setoff(x);\n                puts(""Success"");\n            }\n        }\n    }\n}\n']",,,"['math', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Colliders.json,https://codeforces.com//blog/entry/3969,The clueless solution store all the enabled numbers and compare each new number with each of them works too slow as we can add all the prime numbers below number of which is O n log n We can note that for each number k 1 at any time no more than one collider is turned on which number is divided by k Let us store an array which has in k th element the number of turned on collider which is divided by k on 0 if there is no such at the moment To enable the collider with number q we can look over q s divisors and check whether all the array s elements with these numbers have 0 s If some of them has a positive integer that s the number of collider we conflict with we can just print it and go on Otherwise we have to put q into all the overlooked elements This works in O M sqrt N N There s faster solution as we can store all of the above only for prime divisors Total size of the prime divisors list for number from 1 to N is O N log log N Thus we have a solution with complexity O N log log N M log N as the number of prime divisors of k doesn t exceed log k exact upper bound log k log log k 1 o 1 
https://codeforces.com//contest/914/problem/H,148494,H,914H,914,H. Ember and Storm's Tree Game,Ember and Storm play a game First Ember picks a labelled tree of vertices such that the degree of every vertex is at most Then Storm picks two distinct vertices and in this tree and writes down the labels of the vertices in the path from to in a sequence Finally Ember picks any index in the array Now he performs one of the following two operations exactly once flip the subrange and add to it After this the sequence becomes negate the subrange and add to it i e the array becomes Ember wins if the array is monotonically increasing or decreasing after this Otherwise Storm wins The game can be described by the tuple where is flip or negate depending on the action Ember chose in the last turn Find the number of tuples that can occur if Ember and Storm play optimally When they play optimally if there are multiple moves by which they are guaranteed to win then they may play any of the winning moves Otherwise if someone loses no matter what they play then they may play any of the possible moves Report the answer modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\nint n,D,mo;\nlong long C[210][210],T[210][210],f[210][210],g[210][210],fpre[210][210],gpre[210][210];\nstruct atom{\n\tlong long way,tot;\n};\natom operator + (atom k1,atom k2){\n\treturn (atom){(k1.way+k2.way)%mo,(k1.tot+k2.tot)%mo};\n}\natom calc1(){\n\tlong long way=0,tot=0;\n\tfor (int d=2;d<=D;d++){\n\t\tway=(way+f[n][d])%mo;\n\t\ttot=(tot+g[n][d])%mo;\n\t}\n\treturn (atom){way,tot};\n}\natom calc2(){\n\tlong long way=0,tot=0;\n\tfor (int d1=1;d1<=D;d1++)\n\t\tfor (int d2=2;d1+d2<=D;d2++)\n\t\t\tfor (int i=1;i<=n;i++){\n\t\t\t\tint rem=n-i+1;\n\t\t\t\tlong long num=1ll*f[i][d1]*f[rem][d2]%mo;\n\t\t\t\tway=(way+num)%mo;\n\t\t\t\ttot=(tot+1ll*f[i][d1]*g[rem][d2]%mo+1ll*f[rem][d2]*g[i][d1])%mo;\t\n\t\t\t}\n\treturn (atom){way,tot};\n}\natom calcrem(){\n\tlong long way=0,tot=0;\n\tfor (int d=1;d<=D;d++){\n\t\tway=(way+f[n][d])%mo;\n\t\ttot=(tot+g[n][d])%mo;\n\t}\n\treturn (atom){way,tot};\n}\nint main(){\n\tscanf(""%d%d%d"",&n,&D,&mo);\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(1ll*C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tmemset(f,0x00,sizeof f);\n\tmemset(g,0x00,sizeof g);\n\tf[1][0]=1; \n\tfor (int i=0;i<=n;i++) fpre[1][i]=1;\n\tfor (int i=2;i<=n;i++){\n\t\tfor (int d=1;d<=n;d++)\n\t\t\tfor (int j=1;j<i;j++){\n\t\t\t\tf[i][d]=(f[i][d]+1ll*f[i-j][d-1]*C[i-2][j-1]%mo*fpre[j][D-1])%mo;\n\t\t\t\tg[i][d]=(g[i][d]+1ll*g[i-j][d-1]*C[i-2][j-1]%mo*fpre[j][D-1]%mo+1ll*gpre[j][D-1]*C[i-2][j-1]%mo*f[i-j][d-1]%mo+1ll*j*f[i-j][d-1]%mo*C[i-2][j-1]%mo*fpre[j][D-1])%mo;\n\t\t\t//\tif (i==3&&d==2) cout<<""fa ""<<j<<"" ""<<g[i-j][d-1]<<"" ""<<f[i-j][d-1]<<"" ""<<g[i][d]<<endl;\n\t\t\t}\n\t\tfor (int d=1;d<=n;d++){\n\t\t\tfpre[i][d]=(f[i][d]+fpre[i][d-1])%mo;\n\t\t\tgpre[i][d]=(g[i][d]+gpre[i][d-1])%mo;\n\t\t}\n\t\t//for (int d=0;d<=n;d++) cout<<g[i][d]<<"" ""; cout<<endl;\n\t}\n\t/*for (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<f[i][j]<<"" ""; cout<<endl;} cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<g[i][j]<<"" ""; cout<<endl;} cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<fpre[i][j]<<"" ""; cout<<endl;}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<gpre[i][j]<<"" ""; cout<<endl;}*/\n\tatom ans=calc1();\n\t//cout<<ans.way<<"" ""<<ans.tot<<endl;\n\tans=ans+calc2();\n\t//cout<<ans.way<<"" ""<<ans.tot<<endl;\n\tans=ans+calcrem();\n\t//cout<<ans.way<<"" ""<<ans.tot<<endl;\n\tans.tot=(ans.tot-1ll*ans.way*(n-1))%mo;\n\tans.tot=0;\n\tlong long tot=n*(n-1)*2*ans.way%mo;\n\ttot=(tot-ans.tot*2)%mo;\n\ttot=(tot+mo)%mo;\n\tcout<<tot<<endl;\n}']",,,"['combinatorics', 'dp', 'games', 'trees']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. Ember and Storm's Tree Game.json,https://codeforces.com//blog/entry/57250,Ember wins if the path chosen by Storm is monotonic or bitonic In this case there can be two pairs Let be the set of trees having vertices in which all paths are bitonic or monotonic We need to find For every tree in there exists at least one vertex such that every path starting or ending at that vertex is monotonically increasing or decreasing First let s count the number of rooted trees such that all paths starting at the root are increasing Later we ll combine this with trees having decreasing paths Let be the number of trees having vertices and maximum degree such that all paths starting at vertex are monotonically increasing and the degree of the vertex is We can find this quantity by a kind of knapsack DP in as follows We can construct a tree of vertices and degree of root by taking a tree of vertices having root degree and attaching trees of vertices each to its root Let the set of vertices be Initially we remove vertices from and use these vertices to construct the tree of vertices Let be the set of remaining vertices We partition into subsets of vertices each Sort these subsets by their minimum element Now we make trees of vertices each and use the th set of vertices to construct the th tree Therefore the number of ways to do this is where is the number of trees of vertices with any root degree from to Note that there is a bijection from trees in which all paths from root are increasing and trees in which all paths from root are decreasing Note that is the number of trees such that all paths starting at the root are monotonic and there are vertices lying on the increasing paths and there are vertices lying on the decreasing paths and the degree of the root is Therefore the quantityis the number of rooted trees of vertices such that all paths starting at the root are monotonically increasing or decreasing However we want to count unrooted trees Note that if a tree in has possible roots then these roots form a chain of consecutive numbers with an increasing tree of size on the larger end of the chain and a decreasing tree of size on the smaller end of the chain Such a tree gets counted times in But for all of these roots except one there is exactly one child of the root smaller than it Therefore the total number of unrooted trees isTime Complexity 
https://codeforces.com//contest/879/problem/B,130663,B,879B,879,B. Table Tennis,people are standing in a line to play table tennis At first the first two players in the line play a game Then the loser goes to the end of the line and the winner plays with the next person from the line and so on They play until someone wins games in a row This player becomes the winner For each of the participants you know the power to play table tennis and for all players these values are different In a game the player with greater power always wins Determine who will be the winner ,"['#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FORE(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nconst int N = 1000;\nint n;\nlong long k;\nint a[N],win[N];\n\nint main() {\n  scanf(""%d%I64d"",&n,&k);\n  REP(i,n) {\n    scanf(""%d"", &a[i]); --a[i];\n  }\n  while (true) {\n    if (a[1] > a[0]) { swap(a[1], a[0]); }\n    if (++win[a[0]] >= k || a[0] == n-1) { printf(""%d\\n"", a[0]+1); return 0; }\n    rotate(a+1,a+2,a+n);\n  }\n}\n']",,,"['data structures', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Table Tennis.json,https://codeforces.com//blog/entry/55435,It s not very difficult to solve this problem in The statement hints us that we can use the data structure We need to maintain the queue of players the current winner and the number of wins he has Each game is processed in It can be shown that number of games is less than Of course this solution is too slow Let s think what happens if is large More precisely assume that The winner need to win at least games in a row that is he need to win against all the other players Hence the winner is just the strongest player So if we can solve the problem in Otherwise simulation works in 
https://codeforces.com//contest/1293/problem/A,519782,A,1293A,1293,A. ConneR and the A.R.C. Markland-N,A R C Markland N is a tall building with n floors numbered from 1 to n Between each two adjacent floors in the building there is a staircase connecting them It s lunchtime for our sensei Colin ConneR Neumann Jr and he s planning for a location to enjoy his meal ConneR s office is at floor s of the building On each floor including floor s of course there is a restaurant offering meals However due to renovations being in progress k of the restaurants are currently closed and as a result ConneR can t enjoy his lunch there CooneR wants to reach a restaurant as quickly as possible to save time What is the minimum number of staircases he needs to walk to reach a closest currently open restaurant Please answer him quickly and you might earn his praise and even enjoy the lunch with him in the elegant Neumanns way ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    int ntest;\n    cin >> ntest;\n    while (ntest--) {\n        int n, s, k, x;\n        cin >> n >> s >> k;\n        set <int> ss;\n        for (int i = 1; i <= k; ++i) cin >> x, ss.insert(x);\n        int ans = 0;\n        while (true) {\n            if (s + ans <= n && ss.find(s + ans) == ss.end()) break;\n            if (s - ans >= 1 && ss.find(s - ans) == ss.end()) break;\n            ++ans;\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n""]",,,"['binary search', 'brute force', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. ConneR and the A.R.C. Markland-N.json,https://codeforces.com//blog/entry/73051,Since there s only closed restaurants in the worst case we ll only have to walk for staircases only one such case would be and all the restaurants from floor to are closed Therefore a brute force solution is possible try out every distance from to For each determine if either or is within range and not being in the closed list The check of an element being a list or not can be done easily by a built in function in most programming languages for C it would be the function with linear time complexity Of course one would love to check with but for this problem it s an overkill Time complexity 
https://codeforces.com//contest/1437/problem/F,775844,F,1437F,1437,F. Emotional Fishermen,n fishermen have just returned from a fishing vacation The i th fisherman has caught a fish of weight a i Fishermen are going to show off the fish they caught to each other To do so they firstly choose an order in which they show their fish each fisherman shows his fish exactly once so formally the order of showing fish is a permutation of integers from 1 to n Then they show the fish they caught according to the chosen order When a fisherman shows his fish he might either become happy become sad or stay content Suppose a fisherman shows a fish of weight x and the maximum weight of a previously shown fish is y y 0 if that fisherman is the first to show his fish Then if x ge 2y the fisherman becomes happy if 2x le y the fisherman becomes sad if none of these two conditions is met the fisherman stays content Let s call an order in which the fishermen show their fish if after all fishermen show their fish according to this order each fisherman becomes either happy or sad Calculate the number of orders modulo 998244353 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 5020;\nint n;\nint a[N];\nint dp[N][N];\nint pref[N][N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][0] = 1;\n\tint p = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\twhile(2 * a[p] <= a[i]) p++;\n\t\tfor (int x = 0; x < i; x++)\n\t\t\tdp[i][x + 1] = add(dp[i][x + 1], pref[x][p]);\n\t\tfor (int x = 0; x < p; x++)\n\t\t\tdp[i][x + 1] = add(dp[i][x + 1], mult(dp[i][x], p - x));\n\t\tfor (int x = 0; x <= i; x++)\n\t\t\tpref[x][i + 1] = add(pref[x][i], dp[i][x]);\n\t}\n\tprintf(""%d\\n"", dp[n - 1][n - 1]);\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'math', 'two pointers']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Emotional Fishermen.json,https://codeforces.com//blog/entry/84149,First of all sort the fishermen so it is easier to consider them in ascending order The key observation that allows us to solve the problem is the following there will be an increasing sequence of happy fishermen and all other fishermen will be unhappy Consider the fisherman which belongs to the increasing sequence Let s analyze which fisherman will be next to it in the order It is either a fisherman that will be happy or a fisherman that will be sad In the first case the fish caught by this fisherman must have a size of at least in the second case at most The first case will be considered later For the second case if we know the number of fishermen that were already placed in the order we know that all of them except the th one belong to the sad category that is the fish of every already placed fisherman except for the th one is at least two times smaller than the fish of the th fisherman So if we have already placed fishermen the last happy fisherman was the th one and we want to place a sad fisherman then the number of ways to choose this sad fisherman is exactly where is the number of fishermen such that If we can handle the first case this observation will allow us to solve the problem with dynamic programming Let be the number of ways to choose first fishermen in the order so that the th fisherman is the last happy one The case when the next fisherman is sad can be handled with a transition to the state don t forget to multiply by the number of ways to choose the next sad fisherman as described earlier What about the case when the next fisherman is happy We should iterate on the fisherman such that and transition from to but this part works in To get an solution we have to speed it up with prefix sums or something like that 
https://codeforces.com//contest/1775/problem/C,1730875,C,1775C,1775,C. Interesting Sequence,Petya and his friend robot Petya like to solve exciting math problems One day Petya came up with the numbers n and x and wrote the following equality on the board n n 1 dots m x where denotes the bitwise AND operation Then he suggested his friend Petya find such a minimal m m ge n that the equality on the board holds Unfortunately Petya couldn t solve this problem in his head and decided to ask for computer help He quickly wrote a program and found the answer Can you solve this difficult problem ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tint n,x;\n\t\tcin>>n>>x;\n\t\t\n\t\tint res=n^x;\n\t\t\n\t\tif (n==x) cout<<n<<endl;\n\t\telse if (x==0) cout<<(2LL<<__lg(n))<<endl;\n\t\telse if ((n&x)==x && __builtin_ctzll(n^res)>__lg(res)+1){\n\t\t\tint temp=2LL<<__lg(res);\n\t\t\tn-=n&(temp-1);\n\t\t\tn|=temp;\n\t\t\tcout<<n<<endl;\n\t\t}\n\t\telse cout<<""-1""<<endl;\n\t}\n}\n']",,,"['bitmasks', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Interesting Sequence.json,https://codeforces.com//blog/entry/111286,Note that the answer will be when AND This holds if there is a bit with number which exists in number but it does not exist in number What is clear now is that some bits in must be zeroed Since we have bitwise AND going sequentially with numbers larger than we change the bits from the lowest to the highest Thus in number some bit prefix is zeroed out so if number is not number with a zeroed prefix possibly empty of bits then there is no answer Now we can calculate for each bit the minimal number such that AND AND AND has in the th bit Now calculate as the maximum on all bits to be zeroed and as the minimum on all bits to be left untouched Then if we will take as the answer otherwise there is no answer The problem can also be solved by binary search we will use it to find and check the answer by the formula for each bit find the nearest at which it will be zeroed We can do this using the following fact for th bit the first numbers starting from zero will not contain it then will then again will not and so on Such a solution works for 
https://codeforces.com//contest/1623/problem/A,1243265,A,1623A,1623,A. Robot Cleaner,A robot cleaner is placed on the floor of a rectangle room surrounded by walls The floor consists of n rows and m columns The rows of the floor are numbered from 1 to n from top to bottom and columns of the floor are numbered from 1 to m from left to right The cell on the intersection of the r th row and the c th column is denoted as r c The initial position of the robot is r b c b In one second the robot moves by dr rows and dc columns that is after one second the robot moves from the cell r c to r dr c dc Initially dr 1 dc 1 If there is a vertical wall the left or the right walls in the movement direction dc is before the movement so the new value of dc is dc And if there is a horizontal wall the upper or lower walls dr is before the movement so the new value of dr is dr Each second including the moment before the robot starts moving the robot cleans every cell lying in the same row the same column as its position There is only one dirty cell at r d c d The job of the robot is to clean that dirty cell Given the floor size n and m the robot s initial position r b c b and the dirty cell s position r d c d find the time for the robot to do its job ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, m, x, y, a, b;\n\t\tcin >> n >> m >> x >> y >> a >> b;\n\t\tint dx = 1, dy = 1, cnt = 0;\n\t\twhile (1) {\n\t\t\tif (x == a || y == b) break;\n\t\t\t++cnt;\n\t\t\tif (x + dx < 1 || x + dx > n) dx = -dx;\n\t\t\tif (y + dy < 1 || y + dy > m) dy = -dy;\n\t\t\tx += dx; y += dy;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}']",,,"['brute force', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Robot Cleaner.json,https://codeforces.com//blog/entry/98463,Let s consider the 1 D problem of this problem there are cells lying in a row The robot is at the th cell and the dirty cell is at the th cell Each second the robot cleans the cell at its position The robot initially moves by 1 cell to the right each second If there is no cell in the movement direction its direction will be reflected What is the minimum time for the robot to clean the dirty cell There are two cases needed to be considered If then the answer is The robot just goes straight to the dirty cell Otherwise if then the robot needs to go to the right endpoint first and then go back to the dirty cell Going to the right endpoint takes seconds and going from that cell to the dirty cell takes seconds Therefore the answer for this case is Going back to our original problem we can solve it by dividing it into two 1 D versions This is done by projecting the position of the robot and the dirty cell onto the and axis as follows By doing so we can see that we can clean the dirty cell if and only if one of the projections of the robot can reach the dirty cell Therefore the answer is the minimum between the answers of the two sub problems 
https://codeforces.com//contest/1547/problem/E,1041929,E,1547E,1547,E. Air Conditioners,On a strip of land of length n there are k air conditioners the i th air conditioner is placed in cell a i 1 le a i le n Two or more air conditioners cannot be placed in the same cell i e all a i are distinct Each air conditioner is characterized by one parameter temperature The i th air conditioner is set to the temperature t i For each cell i 1 le i le n find it s temperature that can be calculated by the formula min 1 le j le k t j a j i where a j i denotes absolute value of the difference a j i In other words the temperature in cell i is equal to the minimum among the temperatures of air conditioners increased by the distance from it to the cell i Let s look at an example Consider that n 6 k 2 the first air conditioner is placed in cell a 1 2 and is set to the temperature t 1 14 and the second air conditioner is placed in cell a 2 5 and is set to the temperature t 2 16 In that case temperatures in cells are temperature in cell 1 is min 14 2 1 16 5 1 min 14 1 16 4 min 15 20 15 temperature in cell 2 is min 14 2 2 16 5 2 min 14 0 16 3 min 14 19 14 temperature in cell 3 is min 14 2 3 16 5 3 min 14 1 16 2 min 15 18 15 temperature in cell 4 is min 14 2 4 16 5 4 min 14 2 16 1 min 16 17 16 temperature in cell 5 is min 14 2 5 16 5 5 min 14 3 16 0 min 17 16 16 temperature in cell 6 is min 14 2 6 16 5 6 min 14 4 16 1 min 18 17 17 For each cell from 1 to n find the temperature in it ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n, k;\n        cin >> n >> k;\n        priority_queue<pair<int, int>> q;\n        vector<int> x(k), y(k);\n        vector<int> a(n, int(2e9));\n        for (int i = 0; i < k; i++) {\n            cin >> x[i];\n            --x[i];\n        }\n        for (int i = 0; i < k; i++) {\n            cin >> y[i];\n            q.emplace(-y[i], x[i]);\n            a[x[i]] = y[i];\n        }\n\n        while (!q.empty()) {\n            auto [vy, vx] = q.top();\n            q.pop();\n            if (vx && a[vx] + 1 < a[vx - 1]) {\n                a[vx - 1] = a[vx] + 1;\n                q.emplace(-a[vx - 1], vx - 1);\n            }\n            if (vx + 1 < n && a[vx] + 1 < a[vx + 1]) {\n                a[vx + 1] = a[vx] + 1;\n                q.emplace(-a[vx + 1], vx + 1);\n            }\n        }\n        for (int i : a) {\n            cout << i << "" "";\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']",,,"['data structures', 'dp', 'implementation', 'shortest paths', 'sortings', 'two pointers']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Air Conditioners.json,https://codeforces.com//blog/entry/92715,Let s calculate two arrays and where is the temperature in cell if we take only air conditioners with numbers less than or equal to is the temperature in cell if we take only air conditioners with numbers greater than or equal to Let s show how to calculate array We will calculate values from left to right using DP and next formula where is the temperature of air conditioner in cell or infinity if there is no air conditioner in this cell Indeed the value of is either determined by the air conditioner in this cell i e equals or by some air conditioner to the left but this means that we should take the answer from the previous cell and increase it by The full code for calculating looks like this In exactly the same way but from right to left we will calculate The answer for cell is 
https://codeforces.com//contest/1009/problem/E,197476,E,1009E,1009,E. Intercity Travelling,Leha is planning his journey from Moscow to Saratov He hates trains so he has decided to get from one city to another by car The path from Moscow to Saratov can be represented as a straight line well it s not that straight in reality but in this problem we will consider it to be straight and the distance between Moscow and Saratov is n km Let s say that Moscow is situated at the point with coordinate 0 km and Saratov at coordinate n km Driving for a long time may be really difficult Formally if Leha has already covered i kilometers since he stopped to have a rest he considers the i 1 th kilometer as a i 1 It is guaranteed that for every i in 1 n 1 a i le a i 1 The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey Fortunately there may be some rest sites between Moscow and Saratov Every integer point from 1 to n 1 may contain a rest site When Leha enters a rest site he may have a rest and the next kilometer will have difficulty a 1 the kilometer after it difficulty a 2 and so on For example if n 5 and there is a rest site in coordinate 2 the difficulty of journey will be 2a 1 2a 2 a 3 the first kilometer will have difficulty a 1 the second one a 2 then Leha will have a rest and the third kilometer will have difficulty a 1 the fourth a 2 and the last one a 3 Another example if n 7 and there are rest sites in coordinates 1 and 5 the difficulty of Leha s journey is 3a 1 2a 2 a 3 a 4 Leha doesn t know which integer points contain rest sites So he has to consider every possible situation Obviously there are 2 n 1 different distributions of rest sites two distributions are different if there exists some point x such that it contains a rest site in exactly one of these distributions Leha considers all these distributions to be equiprobable He wants to calculate p the expected value of difficulty of his journey Obviously p cdot 2 n 1 is an integer number You have to calculate it modulo 998244353 ,"['//nie, 3 cze 2018, 13:38:19 CEST\n//Konrad Paluszek, University of Warsaw (former XIV LO Staszic)\n# include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst bool local = \n#ifdef LOCAL\ntrue;\n#else\nfalse;\n#endif\n#define f first\n#define s second\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define bvt(s, f) int s(int x){return f(x);}int s(UI x){return f(x);}int s(LL x){return f##ll(x);}int s(ULL x){return f##ll(x);}\n#define FORBITS(i,m)  for(decltype(m)lP6N4Slr=(m),i=lP6N4Slr?ctz(lP6N4Slr):0;lP6N4Slr;lP6N4Slr^=((decltype(m))1<<i),i=ctz(lP6N4Slr))\n#define FORDBITS(i,m) for(decltype(m)_6Im=(m),i=_6Im?8*sizeof(m)-clz(_6Im)-1:0;_6Im;_6Im^=((decltype(m))1<<i),i=8*sizeof(m)-clz(_6Im)-1)\n#define SUBS(i, mask) for(decltype(mask)i = (mask),NFR9xNQCJZTrYQ=1;NFR9xNQCJZTrYQ;NFR9xNQCJZTrYQ=i,i=(i-1)&(mask))\n#define PB push_back\n#define MP make_pair\n#define MT(a, b, c) MP(MP(a, b), c)\n#define MQ(a, b, c, d) MP(MP(a, b), MP(c, d))\n#define tri(a, b, c) pair <pair <a, b>, c>\n#define quadr(a, b, c, d) pair <pair <a, b>, pair <c, d> >\n#define EB emplace_back\n# define jvx(...)\n# define fkz(...) __VA_ARGS__ jvx()\n# define cxo(...) __VA_ARGS__\n#define uuu_id() uuu\nusing LL=long long;using PII=pair<int,int>;using VI=vector<int>;using SI=set<int>;\nusing MII=map<int,int>;using UMII=unordered_map<int, int>;using LD=long double;using TII=\npair<PII,int>;using QII=pair<PII,PII>;using UI=unsigned int;using ULL=unsigned long long;\n#define uuu(prev, t) using S##t=set<t>; using V##t=vector<t>; using M##t=map<t,t>;\\\n\tusing MI##t=map<int,t>;using US##t=unordered_set<t>; prev(S##t) prev(V##t)\n#define uuu_() uuu\n#define ymd(t) \n#define ymd2(t) fkz(uuu_)()(ymd, t)\n#define ymd3(t) cxo(cxo(cxo(fkz(uuu_)()(ymd2, t))))\n#define ymd4(t) using P##t = pair<t,t>; using T##t=tri(t,t,t); using Q##t=quadr(t,t,t,t); \\\n\tymd3(P##t) ymd3(T##t) ymd3(Q##t) ymd3(t)\nymd4(LL) ymd4(LD) ymd3(PII) ymd3(TII) ymd3(QII) ymd4(VI) ymd4(SI) ymd4(UI) ymd4(ULL)\nbvt(popc,__builtin_popcount)bvt(ctz,__builtin_ctz)bvt(clz,__builtin_clz)bvt(bit_parity,__builtin_parity)\n#define siz(r) ((int)r.size())\n#define ALL(r) r.begin(), r.end()\n#define sim template <class T\n#define ros return o\nsim,class N>bool mini(T&o,N h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(T&o,N h){if(o<h)ros=h,1;return 0;}\n#define oor >ostream &operator<<(ostream &o,\n#define urs(r) typename pta<typename remove_reference<decltype(r)>::type>::t\n#define bnt ;}sim> struct\nsim,class N oor pair<T,N>u){ros<<""<""<<u.f<<"", ""<<u.s<<"">"" bnt pta{using t=T;};sim,int N>struct pta<T[N]>{using t=T*;};\nsim,typename=typename enable_if<!is_same<T,string>::value,urs(T().end())>::type oor\nT u){int c=0;o<<""{"";for(auto e:u)o<<"", ""+2*!c++<<e;ros<<""}"";}\nint mpow(int b, int e) {int o = 1; while (e) {if (e & 1)o = o * 1ll * b % MOD;b = b * 1ll * b % MOD;e /= 2;}ros;}\nvoid dor(){cerr<<dec<<""\\033[0m""<<endl;}sim,class...N>void dor(T x,N...y){cerr<<boolalpha<<x<<""; "";dor(y...);} const bool deb =\n#define acv(N,O) sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(N o, T x) {ros O N(x);} \\\n  sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(T o, N x) {return N(o) O x;} \\\n  sim> typename enable_if<is_arithmetic<T>::value || is_same<T,N>::value, N&>::type operator O##=(N &o, T x) {ros = o O N(x);}\n#ifdef DEB\ntrue;\n#define debug(c...)cerr<<""\\033[1;""<<30+__LINE__%8<<""m[""<<__FUNCTION__<<""#""<<__LINE__<<""] \\033[""<<30+(__LINE__/8+__LINE__*3)%8<<""m"",::dor(c)\n#define rcu m);}g(+) g(-) g(*) g(/) g(%) g(<<) g(>>) g(^) g(|) g(&) g(>=) g(<=) g(>) g(<) g(!=) g(==)\n#define zub(h,t,n...) class N> auto operator h(n u)->nep<urs(t)> {return ngy(t,\nsim>string bte(T u){stringstream o;o<<u;ros.str()bnt nep;sim>T yyo(nep<T>);sim>nep<T>ngy(T v,string c,int m=0);sim>T yyo(T o){ros bnt\nnep{T v;string c;int m; nep<T>mask(){return ngy(v,c,1);}\n#define g(o) template<zub(o, v o u, N) ""("" + bte(*this) + "") "" #o "" ("" + bte(u) + "")"", m);}\ntemplate<zub([],v[yyo(u)],N)c+""[""+bte(u)+""]"",rcu};sim>nep<T>ngy(T v,string c,int m){return nep<T>{v,c,m};}\nsim>T yyo(nep<T> o){ros.v;}sim>int uhn(T){return 0;}sim>int uhn(nep<T>o){ros.m;}\n#define ccy(c, y) sim> class enable_if<c is_arithmetic<T>::value,string>::type ema(T u){return bte(y);}\nccy(,bitset<8*sizeof(T)>(u))ccy(!,u)sim,class N> string ema(pair<T,N> o) {return ""<"" + ema(o.f) + "", "" + ema(o.s) + "">"";}\n#define g(o) sim, zub(o, yyo(p) o u.v, T p, nep<N>) ""("" + bte(p) + "") "" #o "" ("" + bte(u) + "")"", uhn(p) + u.m);}\nsim>string bte(nep<T>o){ros.c+"" = ""+(o.m?ema(o.v):bte(o.v));}sim oor nep<T>m){ros<<bte(rcu sim>nep<T>ngy(nep<T>o,string c="""",int m=0){ros;}\n#undef g\n#define imie(a...) ngy(a, #a)\n#define imask(a...) ngy(a, #a, 1)\n#define range(u, g, c) ngy(list<urs(u[0])>(&u[yyo(g)], &u[yyo(c)] + 1), #u ""["" + bte(g) + ""..."" + bte(c) + ""]"")\n#define arr(a, i) imie(a)[imie(i)]\n#define arr2(a, i, j) imie(a)[imie(i)][imie(j)]\n#define arr3(a, i, j, k) imie(a)[imie(i)][imie(j)][imie(k)]\n#define arr4(a, i, j, k, q) imie(a)[imie(i)][imie(j)][imie(k)][imie(q)]\nvector <stringstream> lif;struct prux {prux() {lif.EB();}~prux() {lif.pop_back();}};\n#define mark_stack(c...) udz(__LINE__,c)\n#define udz(a,b...) erf(a, b)\n#define erf(l,c...) prux _4IJ1MYUxZy2p_Q##l;lif.back()<<""\\033[1;""<<30+l%8<<""m[""<<__FUNCTION__<<\\\n  ""#""<<l<<""] \\033[""<<30+(l/8+l*3)%8<<""m"";siw(c)\nvoid siw(){};sim, class...N> void siw(T x, N...y) {lif.back() << x << ""; "";siw(y...);}\n#define print_stack() cerr << ""STACK_TRACE_FROM:"" << __FUNCTION__ << ""#"" << __LINE__<<endl,nfl()\n#define ckx(o) template<zub(o, o yyo(u), nep<N>) #o ""("" + bte(u) + "")"", u.m);}\nsim> struct tqaz{T a;int u,d,l,r;};sim> tqaz<T> zaqt(T a,int u,int d,int l,int r){return tqaz<T>{a,u,d,l,r};}\n#define matr(a,u,d,l,r) ngy(zaqt(a,yyo(u),yyo(d),yyo(l),yyo(r)), #a""[""+bte(u)+""...""+bte(d)+""][""+bte(l)+""...""+bte(r)+""]"")\n#define avc(f) sim>string f(tqaz<T> x){vector<vector<string>> t;FOR(i,x.u,x.d){t.EB();FOR(j,x.l,x.r)t.back().PB(f(x.a[i][j]));}\\\nstringstream o;VI M;FOR(j,x.l,x.r){int m=0;FOR(i,x.u,x.d)maxi(m, siz(t[i-x.u][j-x.l]));M.PB(m);}FOR(i,x.u,x.d){o<<""\\n\\t[""<<i<<""] "";\\\nFOR(j,x.l,x.r){REP(_, M[j-x.l]-siz(t[i-x.u][j-x.l]))o<<"" "";o<<t[i-x.u][j-x.l]<<((j+1)%5?"", "":""; "");}}ros.str() + ""\\n"";}\nvoid nfl() {for (auto &s : lif)cerr << ""  "" << s.str() << ""\\033[m"" << endl;} ckx(+) ckx(-) ckx(!) ckx(~) avc(bte) avc(ema)\nstruct zet_p {int o;LD v;zet_p(LL x=0):o(x%MOD),v(x){} zet_p(LL x, LD y):o(x%MOD),v(y){} int get(){ros>=0?o:o+MOD;}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o,v+a.v);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o,v-a.v);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o,v*a.v);}\n  zet_p operator/(zet_p a) {assert(a.o != 0); return zet_p(o*1ll*mpow(a.o, MOD-2),v/a.v);}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nostream&operator<<(ostream &o, zet_p u) {ros<<""[""<<u.o<<"" @ ""<<u.v<<""]"";}using frac_mod = zet_p;\n#else\nfalse;\nstruct zet_p {int o;int get(){ros>=0?o:o+MOD;}zet_p(LL x=0):o(x%MOD){}zet_p(int x):o(x%MOD){}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o);}\n  zet_p operator/(zet_p a) {return zet_p(o*1ll*mpow(a.o, MOD - 2));}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nstruct frac_mod {int o,m;int get(){return (o*1ll*mpow(m,MOD-2)%MOD+MOD)%MOD;}frac_mod(int x=0):o(x%MOD),m(1){}frac_mod(LL x):o(x%MOD),m(1){}\n  frac_mod(LL a,LL b):o(a),m(b){}\n  frac_mod operator+(frac_mod a){return frac_mod(o*1ll*a.m+m*1ll*a.o,m*a.m);}\n  frac_mod operator-(frac_mod a){return frac_mod(o*1ll*a.m-m*1ll*a.o,m*a.m);}\n  frac_mod operator*(frac_mod a){return frac_mod(o*1ll*a.o,m*1ll*a.m);}\n  frac_mod operator/(frac_mod a){return frac_mod(o*1ll*a.m,m*1ll*a.o);}\n  bool operator==(frac_mod a) {return (o * 1ll * a.m - m * 1ll * a.o) % MOD == 0;}};\nacv(frac_mod, +) acv(frac_mod, -) acv(frac_mod, *) acv(frac_mod, /)\n#define debug(...)\n#define mark_stack(...)\n#define print_stack(...)\n#endif\nacv(zet_p, +) acv(zet_p, -) acv(zet_p, *) acv(zet_p, /)\n#define nok(o,c,r,l...) auto operator o(c p, r y)-> decltype(MP(l)) {return MP(l);}\n#define pcg(o) sim, class S, class N, class H> nok(o, pair<S u T>, pair<H u N>, p.f o y.f, p.s o y.s)\\\nsim,class S,class N,class=typename enable_if<!is_base_of<ios_base,typename remove_reference<T>::type>::value>::type>nok\\\n(o,T,pair<S u N>, p o y.f, p o y.s) sim, class S, class N> nok(o, pair<S u N>, T, p.f o y, p.s o y)\n#define clp(r) pcg(r) sim, class S, class N, class H> \\\n\tpair <T,S> & operator r##=(pair <T,S> &p, pair<N,H> y) {p.f r##= y.f; p.s r##= y.s; return p;}\\\n\tsim, class S, class N> pair <T,S> &operator r##=(pair<T,S> &p, N y) {p.f r##= y; p.s r##= y; return p;}\n#define u ,\n#define syd(o) sim, class N> auto operator o(pair<T,N> e) -> decltype(MP(o e.f, o e.s)) {return MP(o e.f, o e.s);}\nclp(+) clp(-) clp(*) clp(/) clp(%) clp(^) clp(|) clp(>>) clp(<<) clp(&) pcg(&&) pcg(||) syd(-) syd(+) syd(~) syd(!)\n#undef u\nsim> int dud(T &, T&);sim> char dud(T x, ...);\n#define muf(c...) {\\\n\tsim, class N> static T c get1(pair <T, N> c o){ros.f;}\\\n\tsim, class N> static N c get2(pair <T, N> c o){ros.s;}\\\n\tsim, class N, class S> static T c get1(tri(T, N, S) c o){ros.f.f;}\\\n\tsim, class N, class S> static N c get2(tri(T, N, S) c o){ros.f.s;}\\\n\tsim, class N, class S> static S c get3(tri(T, N, S) c o){ros.s;}\\\n\tsim, class N, class S, class H> static S c get3(quadr(T, N, S, H) c o){ros.s.f;}\\\n\tsim, class N, class S, class H> static H c get4(quadr(T, N, S, H) c o){ros.s.s;}\\\n};\ntemplate <class X> struct qul muf()\ntemplate <> struct qul <int> muf(&)\n#define get1(o) qul<decltype(dud(o, o))>::get1(o)\n#define get2(o) qul<decltype(dud(o, o))>::get2(o)\n#define get3(o) qul<decltype(dud(o, o))>::get3(o)\n#define get4(o) qul<decltype(dud(o, o))>::get4(o)\nsim, class N> using gyv = T;\nnamespace std {sim, class N> struct hash<pair<T,N>>{size_t operator()(const pair<T,N>&u)const {\n      return hash<T>()(u.f) * 440624741ULL ^ hash<N>()(u.s);}};\n  sim> struct hash<gyv<T, decltype(((T*)0)->end())>> {size_t operator()(const T& u) const {size_t o = 505347433;\nfor (auto e : u)o = hash<urs(e)>()(e) ^ o * 277953755ULL;ros;}};}\n\nconst int MN = 1e6 + 44;\nvoid PdAYB7V() {\n\tprint_stack();\n\tdebug(imie(MN) * 1ll * imie(MOD), ""make sure it is right!!!!"");\n\tdebug(""make sure m, n aren\'t misused"");\n\tdebug(""long longs!!!!!!!!!!!!!!!!!!!"");\n\tdebug(""run with m, n = 1"");\n\tdebug(""make sure bounds on values aren\'t misused"");\n\tdebug(""Check time/memory limit"");\n\twhile (getchar() != EOF);\n\texit(0);\n}\nint a[MN];\nint main() {\n\t#ifdef DEB\n\tatexit(PdAYB7V);\n\t#endif\n\tint n;\n\tscanf(""%d"", &n);\n\tREP(i, n)\n\t\tscanf(""%d"", a + i);\n\tzet_p ans = a[0];\n\tzet_p curr = a[0];\n\tzet_p powe = 1;\n\tFOR(i, 1, n - 1) {\n\t\tpowe /= 2;\n\t\tcurr += (a[i] - a[i - 1]) * powe;\n\t\tdebug(imie(curr));\n\t\tans += curr;\n\t}\n\tdebug(imie(ans));\n\tREP(i, n - 1)\n\t\tans *= 2;\n\tprintf(""%d\\n"", ans.get());\n}\n\n\n']",,,"['combinatorics', 'math', 'probabilities']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Intercity Travelling.json,https://codeforces.com/blog/entry/60630,Let s consider each kilometer of the journey separatedly and calculate the expected value of its difficulty and then use linearity of expectation to obtain the answer The difficulty of each kilometer depends on the rest site right before it or if there were no rest sites on the distance from Moscow to this kilometer So when considering the difficulty of th kilometer one indexed we may obtain a formula The denominator of the last summand is because it represents the situation where the last rest was in Moscow and its probability is exactly We can actually rewrite this as follows thus calculating all that we need in linear time 
https://codeforces.com//contest/1650/problem/E,1321164,E,1650E,1650,E. Rescheduling the Exam,Now Dmitry has a session and he has to pass n exams The session starts on day 1 and lasts d days The ith exam will take place on the day of a i 1 le a i le d all a i are different For the session schedule Dmitry considers a special value mu the smallest of the rest times before the exam for all exams For example for the image above mu 1 In other words for the schedule he counts exactly n numbers how many days he rests between the exam i 1 and i for i 0 between the start of the session and the exam i Then it finds mu the minimum among these n numbers Dmitry believes that he can improve the schedule of the session He may ask to change the date of one exam change one arbitrary value of a i Help him change the date so that all a i remain different and the value of mu is as large as possible For example for the schedule above it is most advantageous for Dmitry to move the second exam to the very end of the session The new schedule will take the form Dmitry can leave the proposed schedule unchanged if there is no way to move one exam so that it will lead to an improvement in the situation ,"[""#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector<ll> V;\nint n,d;\nint arr[200005];\nvoid solve(){\n\tcin>>n>>d;\n\tfor(int i=1; i<=n; i++) cin>>arr[i];\n\tsort(arr+1,arr+n+1);\n\tarr[n+1] = d+1;\n\tmultiset<int>st;\n\tfor(int i=1; i<=n; i++) st.insert(arr[i]-1-arr[i-1]);\n\tint ans = *st.begin();\n\tfor(int i=1; i<n; i++){\n\t\tint a = arr[i]-1-arr[i-1];\n\t\tint b = arr[i+1]-1-arr[i];\n\t\tst.erase(st.find(a));\n\t\tst.erase(st.find(b));\n\t\tst.insert(arr[i+1]-1-arr[i-1]);\n\t\t\n\t\tint mx = *st.rbegin();\n\t\tint half = mx/2; if(mx%2==0) half--;\n\t\tst.erase(st.find(mx)); st.insert(half);\n\t\tans = max(ans,*st.begin());\n\t\t\n\t\tst.erase(st.find(half)); st.insert(mx);\n\t\tif(d-arr[n]){\n\t\t\tst.insert(d-1-arr[n]);\n\t\t\tans = max(ans,*st.begin());\n\t\t\tst.erase(st.find(d-1-arr[n]));\n\t\t}\n\t\tst.erase(st.find(arr[i+1]-1-arr[i-1]));\n\t\tst.insert(a); st.insert(b);\n\t}\n\tint diff = arr[n]-1-arr[n-1];\n\tst.erase(st.find(diff));\n\tst.insert(d-1-arr[n-1]); \n\tans = max(ans,*st.begin()); st.erase(st.find(d-1-arr[n-1]));\n\t\n\tint mx = *st.rbegin();\n\tint half = mx/2; if(mx%2==0) half--;\n\tst.erase(st.find(mx)); st.insert(half);\n\tans = max(ans,*st.begin());\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}""]",,,"['binary search', 'data structures', 'greedy', 'implementation', 'math', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Rescheduling the Exam.json,https://codeforces.com//blog/entry/100712,To begin with we will learn how to find the optimal place for the exam that we want to move Let s imagine that it is not in the schedule in this case we have two options Put the exam at the end of the session so that there are days before it Put it in the middle of the largest break between exams let its length be so that between it and the nearest one there is because this is no worse than putting it in any part of any other break That is the answer for such an arrangement is the minimum of the larger of these options and the minimum break in schedule without the moved exam Now note that the minimum break in most variants is the same minimum in the initial schedule So in order to reduce you need to move exactly one of the two exams that form it and you need to check which of the two options is better 
https://codeforces.com//contest/1675/problem/C,1389920,C,1675C,1675,C. Detective Task,Polycarp bought a new expensive painting and decided to show it to his n friends He hung it in his room n of his friends entered and exited there one by one At one moment there was no more than one person in the room In other words the first friend entered and left first then the second and so on It is known that at the beginning before visiting friends a picture hung in the room At the end after the n th friend it turned out that it disappeared At what exact moment it disappeared there is no information Polycarp asked his friends one by one He asked each one if there was a picture when he entered the room Each friend answered one of three response encoded with response encoded as response is encoded with Everyone except the thief either doesn t remember or told the The thief can say anything any of the three options Polycarp cannot understand who the thief is He asks you to find out the number of those who can be considered a thief according to the answers ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\ninline int reads(char* s){\n\tint t = 0;\n\tregister char c = getchar();\n\twhile (c != \'1\' && c != \'0\' && c != \'?\') c = getchar();\n\twhile (c == \'1\' || c == \'0\' || c == \'?\') s[++t] = c,c = getchar();\n\treturn t;\n}\n\nconst int N = 2e5 + 10;\nint T,n,ans,pre[N + 1],suf[N + 1];\nchar inp[N + 1];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = reads(inp);\n\t\tans = 0;\n\t\tfor (int i = 0;i <= n + 1;i++) pre[i] = suf[i] = 0;\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tpre[i] = pre[i - 1];\n\t\t\tif (inp[i] == \'1\' || inp[i] == \'?\') ++pre[i];\n\t\t}\n\t\tfor (int i = n;i >= 1;i--){\n\t\t\tsuf[i] = suf[i + 1];\n\t\t\tif (inp[i] == \'1\') ++suf[i];\n\t\t}\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (pre[i - 1] == i - 1 && suf[i + 1] == 0) ++ans;\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}']",,,['implementation'],1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Detective Task.json,https://codeforces.com//blog/entry/102550,First let s note that we will have a transition from to only once otherwise it turns out that first the picture disappeared then it appeared and disappeared back but we can consider that a friend in the middle who answered lied to us but this is not true because even before him the picture disappeared So we need to find this transition Since we can also meet we find the index of the leftmost in case of absence we take and mark it as and the index of rightmost in case of absence we take and mark as Answer the number of indices between them inclusive because only they could lie There could not be a thief to the left of since either the friend under the index lied or the picture was not stolen before There could not be a thief to the right of since either the painting had already been stolen in the presence of s friend or it was he who lied 
https://codeforces.com//contest/988/problem/D,186729,D,988D,988,D. Points and Powers of Two,There are n distinct points on a coordinate line the coordinate of i th point equals to x i Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two It is necessary to consider each pair of points not only adjacent Note that any subset containing one element satisfies the condition above Among all these subsets choose a subset with maximum possible size In other words you have to choose the maximum possible number of points x i 1 x i 2 dots x i m such that for each pair x i j x i k it is true that x i j x i k 2 d where d is some non negative integer number not necessarily the same for each pair of points ,"['/// In The Name Of God\n\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl \'\\n\'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)5e5 + 7;\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint n;\nll a[N];\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (""in.txt"", ""r"", stdin);\n\t#endif\n\tKazakhstan\n\tcin >> n;\n\tset <ll> st;\n\trep(i, 1, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tst.insert(x);\n\t}\n\tn = 0;\n\tfor (auto it : st) a[++n] = it;\n\trep(i, 1, n) {\n\t\tll x = 1;\n\t\trep(d, 0, 30) {\n\t\t\tif (st.count(a[i] + x) && st.count(a[i] + x + x)) cout << 3 << nl << a[i] << \' \' << a[i] + x << \' \' << a[i] + x + x, ioi\n\t\t\tx *= 2;\n\t\t}\n\t}\n\trep(i, 1, n) {\n\t\tll x = 1;\n\t\trep(d, 0, 30) {\n\t\t\tif (st.count(a[i] + x)) cout << 2 << nl << a[i] << \' \' << a[i] + x, ioi\n\t\t\tx *= 2;\n\t\t}\n\t}\n\tcout << 1 << nl << a[1];\n\tioi\n}\n']",,,"['brute force', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Points and Powers of Two.json,https://codeforces.com/blog/entry/59810,Firstly let s prove that the size of the answer is not greater than Suppose that the answer equals to Let be coordinates of the points in the answer and Let and Then because of the condition It means that Conditions must hold for a triple too Now it is easy to see that if then that is not a power of two So the size of the answer is not greater than Firstly let s check if the answer is Iterate over all middle elements of the answer and over all powers of two from to inclusively Let be the middle element of the answer and the current power of two Then if there are elements and in the array then the answer is Now check if the answer is Do the same as in the previous solution but now we have left point and right point If we did not find answer of lengths or then print any element of the array The solution above have time complexity because of we can check if the element is in the array with some data structure in 
https://codeforces.com//contest/1194/problem/D,372218,D,1194D,1194,D. 1-2-K Game,Alice and Bob play a game There is a paper strip which is divided into cells numbered from left to right starting from There is a chip placed in the th cell the last one Players take turns Alice is first Each player during his or her turn has to move the chip or cells to the left so if the chip is currently in the cell the player can move it into cell or The chip should not leave the borders of the paper strip it is impossible for example to move it cells to the left if the current cell has number The player who can t make a move loses the game Who wins if both participants play optimally Alice and Bob would like to play several games so you should determine the winner in each game ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>\n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint T;\n\nbool win(ll n, ll k) {\n\tif (k%3!= 0) return n%3 != 0;\n\tn %= k+1;\n\treturn n == k || n%3 != 0;\n}\n\nint main() {\n    setIO(); re(T);\n    F0R(i,T) {\n    \tint n,k; re(n,k);\n    \tif(win(n,k)) ps(""Alice"");\n    \telse ps(""Bob"");\n    }\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/']",,,"['games', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. 1-2-K Game.json,https://codeforces.com//blog/entry/68405,Let s determine for each cell whether it s winning or losing position we can do it since the game is symmetric and doesn t depend on a player The th cell is obviously losing the st and nd ones is both winning since we can move to the th cell and put our opponent in the losing position here comes criterion the position is winning if and only if there is a move to the losing position If is large enough then the th rd th th are losing So here comes divisibility by If then this move doesn t change anything since if then so it s not the move to the losing position so doesn t become the winning one Otherwise if then the th positions becomes winning but the th cell is losing all moves are to th th or st cells and all of them are winning The th and th cells are winning and so on In the end we came up with cycle of length where position divisible by except are losing All we need to do is small case work 
https://codeforces.com//contest/387/problem/A,6206,A,387A,387,A. George and Sleep,George woke up and saw the current time on the digital clock Besides George knows that he has slept for time Help George Write a program that will given time and determine the time when George went to bed Note that George could have gone to bed yesterday relatively to the current time see the second test sample ,"['#include<bits/stdc++.h>\n\n\n\nusing namespace std;\n\n\n\nchar s[3][6];\n\nint i, d[3], ans;\n\n\n\nint main(){\n\n\t\n\n\tscanf(""%s%s"", s[1], s[2]);\n\n\t\n\n\tfor(i=1; i<3; i++) d[i]=60*((s[i][0]-\'0\')*10+s[i][1]-\'0\')+(s[i][3]-\'0\')*10+s[i][4]-\'0\';\n\n\t\n\n\tans=d[1]-d[2];\n\n\tif(ans<0) ans+=24*60;\n\n\tif(ans/60<10) printf(""0"");\n\n\tprintf(""%d:"", ans/60);\n\n\tif(ans%60<10) printf(""0"");\n\n\tprintf(""%d\\n"", ans%60);\n\n\treturn 0;\n\n}\n                                ']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. George and Sleep.json,https://codeforces.com//blog/entry/10583,I will describe the simple solution Let George woke up in the hours and minutes and he slept for hours and minutes Let s get the number and If then you should add to minutes and subtract from one hour After that if then add to it hours You can print the answer in C by using the following line The complexity is time and memory Author s solution 5850831 
https://codeforces.com//contest/1766/problem/C,1690148,C,1766C,1766,C. Hamiltonian Wall,Sir Monocarp Hamilton is planning to paint his wall The wall can be represented as a grid consisting of 2 rows and m columns Initially the wall is completely white Monocarp wants to paint a black picture on the wall In particular he wants cell i j the j th cell in the i th row to be colored black if c i j and to be left white if c i j Additionally he wants each column to have at least one black cell so for each j the following constraint is satisfied c 1 j c 2 j or both of them will be equal to In order for the picture to turn out smooth Monocarp wants to place down a paint brush in some cell x 1 y 1 and move it along the path x 1 y 1 x 2 y 2 dots x k y k so that for each i x i y i and x i 1 y i 1 share a common side all black cells appear in the path white cells don t appear in the path Determine if Monocarp can paint the wall ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<char>> c(2, vector<char>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> c[j][k];\n      }\n    }\n    vector<bool> ok(2, true);\n    int cnt = 0;\n    for (int j = 0; j < m; j++){\n      if (c[0][j] == \'B\' && c[1][j] == \'B\'){\n        cnt++;\n      }\n      if (c[0][j] == \'W\'){\n        ok[cnt % 2] = false;\n      }\n      if (c[1][j] == \'W\'){\n        ok[1 - cnt % 2] = false;\n      }\n    }\n    if (ok[0] || ok[1]){\n      cout << ""YES"" << endl;\n    } else {\n      cout << ""NO"" << endl;\n    }\n  }\n}']",,,"['dp', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Hamiltonian Wall.json,https://codeforces.com//blog/entry/110066,Why is there a constraint of each column having at least one black cell Does the problem change a lot if there were white columns Well if such a column was inbetween some black cells then the answer would be If it was on the side of the grid you could remove it and proceed to solve without it So that doesn t really change the problem other than removing some casework Let s try to fix a start Find a column that has only one black cell in it If there are no such columns the answer is immediately Otherwise the path will always go through it in known directions to the left and to the right if both of them exist Let s solve the problem separately for the left part of the path and for the right one find a path that starts to the left of it and covers everything to the left and the same for the right part Consider the right part If the next column also has one black cell then we can determine where to go uniquely If this cell is on the opposite row then the answer is Otherwise go there and proceed further Let it have two black cells now Find the entire two black row rectangle of maximum size that starts there If there s nothing after it you can easily traverse it any way you like Otherwise you have to traverse it in such a way that you end up in its last column then go to the right from there Turns out there s only one way to achieve that Go up down to another row go right up down to another row right and so on Now you just have to check if you end up in the correct row Thus you can simulate the path to the left and to the right and check if you never get stuck Overall comlexity per testcase 
https://codeforces.com//contest/1691/problem/E,1416261,E,1691E,1691,E. Number of Groups,You are given n colored segments on the number line Each segment is either colored red or blue The i th segment can be represented by a tuple c i l i r i The segment contains all the points in the range l i r i inclusive and its color denoted by c i if c i 0 it is a red segment if c i 1 it is a blue segment We say that two segments of colors are if they share at least one common point Two segments belong to the same group if they are either connected directly or through a sequence of directly connected segments Find the number of groups of segments ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nvector < tuple < int, int, int > > pot;\nint n, fa[N];\nset < pii > tpot[2];\n\nint gf(int x) { return x == fa[x] ? x : fa[x] = gf(fa[x]); }\n\nvoid solve() {\n\tn = in; pot.clear(), tpot[0].clear(), tpot[1].clear(); rep(i, 1, n) { int c = in, l = in, r = in; pot.eb(l, r, c); }\n\tsort(pot.begin(), pot.end()); rep(i, 1, n) fa[i] = i; int tot = 0;\n\tfor(auto v : pot) {\n\t\tint l, r, c, id = ++tot; tie(l, r, c) = v;\n\t\tauto it = tpot[c ^ 1].begin();\n\t\twhile(it != tpot[c ^ 1].end()) {\n\t\t\tif(it->fi < l) tpot[c ^ 1].erase(it++);\n\t\t\telse it++;\n\t\t}\n\t\tif(tpot[c ^ 1].size()) {\n\t\t\tpii mxr = { 0, 0 };\n\t\t\tfor(auto v : tpot[c ^ 1]) chkmax(mxr, v), fa[gf(v.se)] = gf(id);\n\t\t\ttpot[c ^ 1].clear(); tpot[c ^ 1].ep(mxr);\n\t\t}\n\t\ttpot[c].ep(r, id);\n\t}\n\tint ans = 0; rep(i, 1, n) if(gf(i) == i) ans++;\n\tprintf(""%d\\n"", ans);\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n']",,,"['data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Number of Groups.json,https://codeforces.com//blog/entry/103212,We will be using the starting and ending points of different segments to count the final answer We maintain a Union Find data structure DSU on size corresponding to the segments given as input We store all the starting and ending points in a set example If segments are and we store in a set irrespective of the color of the segment We now iterate through these points in ascending order We maintain running sets corresponding to the colors In these sets we will store the segments for which the starting point has been reached while iterating through the set of points but the ending point hasn t been reached ie we store the segments that have started but not ended The algorithm works as follows If we are at a point If it corresponds to a segment s starting point We add that segment to the set corresponding to its color We merge DSU merge this segment with all segments present in the set corresponding to the other color since their ending point hasn t been reached yet We also erase all segments in the set corresponding to the other color except the one with the largest closing point value If the point corresponds to a segment s ending point We delete the segment from the set corresponding to its color Why can we delete the segments of color except for the one with the largest ending point if we encounter a starting point of the other color We are able to greedily pick the segment with the furthest ending point value because all segments of the same color in that set have been connected together by the segments of the other color Hence we can just work with the segments with the largest ending point value of both colors for each component that exists 
https://codeforces.com//contest/819/problem/B,112024,B,819B,819,B. Mister B and PR Shifts,Some time ago Mister B detected a strange signal from the space which he started to study After some transformation the signal turned out to be a permutation of length or its cyclic shift For the further investigation Mister B need some basis that s why he decided to choose cyclic shift of this permutation which has the minimum possible deviation Let s define the deviation of a permutation as Find a cyclic shift of permutation with minimum possible deviation If there are multiple solutions print any of them Let s denote id of a cyclic shift of permutation as the number of right shifts needed to reach this shift for example shift shift shift ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int N=1e6+10;\nlong long A[N],B[N];\nint x[N];\nint n;\nvoid addin(int l,int r,int k,int b){\n\tA[l]+=b; B[l]+=k;\n\tA[r+1]-=b; B[r+1]-=k;\n}\nvoid add(int l,int r,int where,int w){\n\tif (l>r) return;\n\tint wherel=(l+where-1)%n+1,wherer=(r+where-1)%n+1;\n\tint wl=abs(wherel-w),wr=abs(wherer-w);\n\tif (wl<=wr) addin(l,r,wl-l,1);\n\telse addin(l,r,wl+l,-1);\n}\nint main(){\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++) scanf(""%d"",&x[i]);\n\tfor (int i=1;i<=n;i++){\n\t\tint k1=n-i,k2=(x[i]-i+n)%n;\n\t\tif (k1>k2) swap(k1,k2);\n\t\tadd(0,k1,i,x[i]);\n\t\tadd(k1+1,k2,i,x[i]);\n\t\tadd(k2+1,n-1,i,x[i]);\n\t}\n\tfor (int i=1;i<=n;i++) A[i]+=A[i-1],B[i]+=B[i-1];\n\tlong long ans=1e18;\n\tint where=0;\n\tfor (int i=0;i<n;i++){\n\t\tlong long w=1ll*A[i]*i+B[i];\n\t\tif (w<ans) ans=w,where=i;\n\t}\n\tcout<<ans<<"" ""<<where<<endl;\n\treturn 0;\n}']",,,"['data structures', 'implementation', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Mister B and PR Shifts.json,https://codeforces.com//blog/entry/52946,Let s see how affects different shifts Let s denote is deviation of the shift At first all Then affects it in following way Then there are 2 cases or not If after removing modules we will get 3 query to add to where to add to where and to add to where Else if we need to perform next operation to add to where to add to where and to add to where But in both cases we must add 3 arithmetic progression to the segment of array Or make operation of adding to segment Its known task which can be done by adding subtracting values in start and end of segment offline To make such operation we need to remember how to add value to segment of array offline We can just do next operations and Now value in position So what is adding progression with coef it s only adding to array value to all positions in segment That s why we need other array for example and making and In result So algorithm to add to segment is next After all queries we need recover array with formula And after that get answer with formula So complexity is 
https://codeforces.com//contest/949/problem/D,163631,D,949D,949,D. Curfew,Instructors of Some Informatics School make students go to bed The house contains rooms in each room exactly students were supposed to sleep However at the time of curfew it happened that many students are not located in their assigned rooms The rooms are arranged in a row and numbered from to Initially in th room there are students All students are currently somewhere in the house therefore Also instructors live in this house The process of curfew enforcement is the following One instructor starts near room and moves toward room while the second instructor starts near room and moves toward room After processing current room each instructor moves on to the next one Both instructors enter rooms and move simultaneously if is odd then only the first instructor processes the middle room When all rooms are processed the process ends When an instructor processes a room she counts the number of students in the room then turns off the light and locks the room Also if the number of students inside the processed room is not equal to the instructor writes down the number of this room into her notebook and turns off the light and locks the room Instructors are in a hurry to prepare the study plan for the next day so they don t care about who is in the room but only about the number of students While instructors are inside the rooms students can run between rooms that are not locked and not being processed A student can run by at most rooms that is she can move to a room with number that differs my at most Also after or instead of running each student can hide under a bed in a room she is in In this case the instructor will not count her during the processing In each room any number of students can hide simultaneously Formally here is what s happening A curfew is announced at this point in room there are students Each student can run to another room but not further than rooms away from her initial room or stay in place After that each student can optionally hide under a bed Instructors enter room and room they count students there and lock the room after it no one can enter or leave this room Each student from rooms with numbers from to can run to another room but not further than rooms away from her room or stay in place Each student can optionally hide under a bed Instructors move from room to room and from room to room This process continues until all rooms are processed Let denote the number of rooms in which the first instructor counted the number of non hidden students different from and be the same number for the second instructor Students know that the principal will only listen to one complaint therefore they want to minimize the maximum of numbers Help them find this value if they use the optimal strategy ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define Se second\n#define Fi first\n\nll in[100050];\nll uin[100050];\nvector <pll> Vl;\nint main() {\n\tint N, D, B, i, j;\n\tscanf(""%d %d %d"", &N, &D, &B);\n\tfor (i = 1; i <= N; i++) scanf(""%lld"", &in[i]);\n\n\tint st = 0, en = N / 2 - 1 , mi, rv = N / 2;\n\twhile (st <= en) {\n\t\tmi = (st + en) / 2;\n\n\t\tint s1 = mi + 1, e1 = N / 2 - 1;\n\t\tint s2 = (N + 4) / 2, e2 = N - mi;\n\t\tif (N % 2 == 0) {\n\t\t\te1 = N / 2 - 1;\n\t\t\ts2 = N / 2 + 2;\n\t\t}\n\t\telse {\n\t\t\te1 = N / 2;\n\t\t\ts2 = N / 2 + 2;\n\t\t}\n\n\t\tfor (i = 1; i <= N; i++) uin[i] = in[i];\n\n\t\tint pst = 1, pen = N;\n\t\tfor (i = s1; i <= e1; i++) {\n\t\t\tll tl = (ll)i*D;\n\n\t\t\tll v = B;\n\t\t\tint sp = INF, ep = -INF;\n\t\t\twhile (v) {\n\t\t\t\tif (uin[pst] == 0) {\n\t\t\t\t\tpst++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsp = min(sp, pst);\n\t\t\t\tep = max(ep, pst);\n\t\t\t\tif (uin[pst] > v) {\n\t\t\t\t\tuin[pst] -= v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv -= uin[pst];\n\t\t\t\t\tuin[pst] = 0;\n\t\t\t\t\tpst++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(sp - i) > tl) break;\n\t\t\tif (abs(ep - i) > tl) break;\n\t\t}\n\t\tif (i <= e1) {\n\t\t\tst = mi + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = e2; i >= s2; i--) {\n\t\t\tll tl = (ll)(N+1-i)*D;\n\n\t\t\tll v = B;\n\t\t\tint sp = INF, ep = -INF;\n\t\t\twhile (v) {\n\t\t\t\tif (uin[pen] == 0) {\n\t\t\t\t\tpen--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsp = min(sp, pen);\n\t\t\t\tep = max(ep, pen);\n\t\t\t\tif (uin[pen] > v) {\n\t\t\t\t\tuin[pen] -= v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv -= uin[pen];\n\t\t\t\t\tuin[pen] = 0;\n\t\t\t\t\tpen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(sp - i) > tl) break;\n\t\t\tif (abs(ep - i) > tl) break;\n\t\t}\n\t\tif (i >= s2) {\n\t\t\tst = mi + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint p1 = N / 2, p2 = p1 + 1;\n\t\tif (N % 2 == 1) p1 = p2;\n\t\tll cnt[3] = { 0,0,0 };\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tll tl = (ll)((N + 1) / 2) * D;\n\t\t\tll st = i - tl, en = i + tl;\n\t\t\t\n\t\t\tbool c1 = false, c2 = false;\n\t\t\tif (st <= p1 && p1 <= en) c1 = true;\n\t\t\tif (st <= p2 && p2 <= en) c2 = true;\n\n\t\t\tif (c1 || c2) cnt[2] += uin[i];\n\t\t\tif (c1) cnt[0] += uin[i];\n\t\t\tif (c2) cnt[1] += uin[i];\n\t\t}\n\n\t\tbool chk = false;\n\t\tif (N % 2 == 1) chk = (cnt[0] >= B);\n\t\telse chk = (cnt[0] >= B && cnt[1] >= B && cnt[2] >= 2 * B);\n\t\tif (chk) {\n\t\t\trv = mi;\n\t\t\ten = mi - 1;\n\t\t}\n\t\telse st = mi + 1;\n\t}\n\treturn !printf(""%d\\n"", rv);\n}']",,,"['binary search', 'brute force', 'greedy', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Curfew.json,https://codeforces.com//blog/entry/58291,Let s solve the problem in case when there is only one instructor which moves from left to right and the only goal is to minimize number of bad rooms I claim that the following greedy works Move through rooms from left to right If there are too many students inside room send the excess students to the next room If there are not enough students but it is possible to fulfill this room from rooms on the right the sum is at least then do it If it s not possible then send all students to the following room If it is the last room say that those students are hiding in it This greedy can be implemented in time calculate the prefix sums on the this way you can check if it is possible to move students from following rooms here fast To handle the removal students from following rooms you can maintain the current debt of students When you first consider room you can repay the debt as much as you can and then check one of the cases above Since the both left and right borders of segments are moving monotonously the debt will be inherited correctly Notice that you can only consider paths of different students never cross that means if first student was initially in room and moved to while the second student was in and moved to then if than Because otherwise you can swap students and nothing will change you can possibly skip it Suppose there is a better answer which completes the rooms while the greedy solutions completes rooms We will assume that in optimal solution paths of students don t intersect that all excessive students are hiding in last room and that all rooms in optimal answer are either full or empty Otherwise it s possible to change the correct answer in such way that number of good rooms will not decrease Let s is smallest index when Then because greedy solution would always fulfill the room if it would be possible actually greedy solution builts the lexmin solution But if we can patch the supposed optimal solution and move all students which were sent to room to we know it is possible by the greedy solution s answer This way we can increase the common prefix with any possible best answer hence contradiction Back to the problem with Recall that paths of different students don t cross hence there exists a border the number from to where the first students are going to the first instructor and all others to second One could have bruteforced that border and solved the both halfs of the array by the method above but then the complexity will be which is too much We need to search for the border more efficiently Let will be the answer for first instructor when he is given first students and is the answer for second instructor when he is given all students except first ones It is easy to see that in decreasing while is increasing both times it is not strict monotonicity Indeed the more students are given to instructor than more opportunities he has all excessive students can always hide so it is not a problem We are searching for where is smallest possible Let s introduce function increasing but still not strict Let s call the smallest index such that One can see that a is the final answer Indeed if one will try greater s than than the will be dominating in max and hence is more optimal Otherwise if then is better Solve this problem in time Students became fat and can t hide under the bed Can you solve it now 
https://codeforces.com//contest/1395/problem/A,697389,A,1395A,1395,A. Boboniu Likes to Color Balls,Boboniu gives you r red balls g green balls b blue balls w white balls He allows you to do the following operation as many times as you want Pick a red ball a green ball and a blue ball and then change their color to white You should answer if it s possible to arrange all the balls into a after several possibly zero number of described operations ,"['#include<bits/stdc++.h>\nusing namespace std;\nint T,a,b,c,d;\nbool ok;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d%d%d"",&a,&b,&c,&d),ok=false;\n\t\tok|=((a&1)+(b&1)+(c&1)+(d&1)<=1);\n\t\tif(a&&b&&c)a--,b--,c--,d+=3;\n\t\tok|=((a&1)+(b&1)+(c&1)+(d&1)<=1);\n\t\tputs(ok?""Yes"":""No"");\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Boboniu Likes to Color Balls.json,https://codeforces.com//blog/entry/81355,If there are less than or equal to one odd number in then you can order them to be a palindrome Otherwise do the operation once if you can and check the condition above It is meaningless to do operation more than once because we only care about the parity of 
https://codeforces.com//contest/484/problem/D,16631,D,484D,484,D. Kindergarten,In a kindergarten the children are being divided into groups The teacher put the children in a line and associated each child with his or her integer charisma value Each child should go to exactly one group Each group should be a nonempty segment of consecutive children of a line A group s is the maximum difference of charisma of two children in the group in particular if the group consists of one child its sociability equals a zero The teacher wants to divide the children into some number of groups in such way that the total of the groups is maximum Help him find this value ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nconst int MAXN = 1000010;\nint a[MAXN];\ni64 dp[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    scanf(""%d"", &N);\n    forn(i, N) scanf(""%d"", &a[i]);\n    dp[0] = dp[1] = 0;\n    int extr = 0;\n    bool ismin = true, ismax = true;\n    for (int i = 1; i < N; ++i) {\n        if (a[i] == a[i - 1]) {\n            extr = i - 1;\n            ismin = ismax = true;\n        }\n        if (a[i] < a[i - 1] && ismin) {\n            extr = i - 1;\n            ismax = true;\n            ismin = false;\n        }\n        if (a[i] > a[i - 1] && ismax) {\n            extr = i - 1;\n            ismin = true;\n            ismax = false;\n        }\n        dp[i + 1] = abs(a[i] - a[extr]) + dp[extr];\n        dp[i + 1] = max(dp[i + 1], abs(a[i] - a[extr + 1]) + dp[extr + 1]);\n    }\n    cout << dp[N] << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",,,"['data structures', 'dp', 'greedy']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Kindergarten.json,https://codeforces.com//blog/entry/14592,Let us note that in optimal answer any segment that making a group contains their minimum and maximum values on borders Otherwise it will be better to split this segment to two other segments Another note that is every segment in optimal solution is strictly monotonic increasing or decreasing Paying attention to the interesting points in sequence which making local maximums i e local minimums and point adjacent to them Solve the problem by dynamic programming is the answer in the prefix To calculate we need to look at no more than three previous interesting points and to previous Total time complexity is 
https://codeforces.com//contest/792/problem/C,100426,C,792C,792,C. Divide by Three,A positive integer number is written on a blackboard It consists of not more than digits You have to transform it into a number by erasing some of the digits and you want to erase as few digits as possible The number is called beautiful if it consists of at least one digit doesn t have leading zeroes and is a multiple of For example are beautiful numbers and are not Write a program which for the given will find a beautiful number such that can be transformed into this number by erasing as few digits as possible You can erase an arbitraty set of digits For example they don t have to go one after another in the number If it s impossible to obtain a beautiful number print If there are multiple answers print any of them ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << "" "";\n    }\n    cerr << ""\\n"";\n}\n\nstring s;\n\nvector<string> vv;\n\nstring tr(string s) {\n\tint now = 0;\n\twhile (now + 1 < s.size() && s[now] == \'0\')\n\t\t++now;\n\treturn s.substr(now);\n}\n\nint main() {\n\tcin >> s;\n\tint sum = 0;\n\tfor (int i = 0; i < s.size(); ++i)\n\t\tsum += (s[i] - \'0\');\n\tsum %= 3;\n\tif (sum != 0) {\n\t\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\t\tif ((s[i] - \'0\') % 3 == sum) {\n\t\t\t\tstring t = s.substr(0, i) + s.substr(i + 1);\n\t\t\t\tt = tr(t);\n\t\t\t\tif (!t.empty())\n\t\t\t\t\tvv.push_back(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint p1 = -1;\n\t\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\t\tif ((s[i] - \'0\') % 3 == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((s[i] - \'0\') % 3 == sum)\n\t\t\t\tcontinue;\n\t\t\tif (p1 == -1) {\n\t\t\t\tp1 = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring t = s.substr(0, i) + s.substr(i + 1, p1 - i - 1) + s.substr(p1 + 1);\n\t\t\tt = tr(t);\n\t\t\tif (!t.empty())\n\t\t\t\tvv.push_back(t);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\ts = tr(s);\n\t\tif (!s.empty())\n\t\t\tvv.push_back(s);\n\t}\n\tstring ans = """";\n\tfor (string t: vv)\n\t\tif (t.size() > ans.size())\n\t\t\tans = t;\n\tif (ans.empty())\n\t\tcout << -1 << ""\\n"";\n\telse\n\t\tcout << ans << ""\\n"";\n\treturn 0;\n}\n\n\n']",,,"['dp', 'greedy', 'math', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Divide by Three.json,https://codeforces.com//blog/entry/51254,Let s declare a function which takes number as a string and erases minimal number of digits in substring from nd to last character to obtain beautiful number Note that if the answer for given string exists then this function will erase no more than digits If the number is divisible by then sum of its digits is also divisible by So here are the only options for the function Sum of digits is already equal to modulo Thus you don t have to erase any digits There exists such a digit that equals sum modulo Then you just have to erase this digit All of the digits are neither divisible by nor equal to sum modulo So two of such digits will sum up to number which equals sum modulo Let positions of non zero numbers be Then you can easily see that its enough to check only three function outputs on substrings We imply that all digits to the left of the taken non zero digit are erased As we can erase no more than digits these options will cover all the cases If there exists no answer for any of substrings than you need to check if the number contains it will be answer in that case If there is no then answer is Otherwise the answer is the function output of maximal length Overall complexity 
https://codeforces.com//contest/1155/problem/D,334464,D,1155D,1155,D. Beautiful Array,You are given an array a consisting of n integers Beauty of array is the maximum sum of some of this array this subarray may be empty For example the beauty of the array is and the beauty of the array is You may choose of a and multiply all values contained in this subarray by x You want to maximize the beauty of array after applying at most one such operation ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)1e18;\nconst int N = 300300;\nll dp[N][3][3];\nll a[N];\nint n;\nll X;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%lld"", &n, &X);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tfor (int h = 0; h < 3; h++)\n\t\t\t\tdp[i][j][h] = -INF;\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tfor (int h = 0; h < 3; h++) {\n\t\t\t\tif (dp[i][j][h] == -INF) continue;\n\t\t\t\tif (j < 2) dp[i][j + 1][h] = max(dp[i][j + 1][h], dp[i][j][h]);\n\t\t\t\tif (h < 2) dp[i][j][h + 1] = max(dp[i][j][h + 1], dp[i][j][h]);\n\t\t\t\tif (i < n) {\n\t\t\t\t\tll w = dp[i][j][h];\n\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\tif (h == 1)\n\t\t\t\t\t\t\tw += a[i] * X;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tw += a[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j][h] = max(dp[i + 1][j][h], w);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(""%lld\\n"", dp[n][2][2]);\n\n\treturn 0;\n}\n']",,,"['brute force', 'data structures', 'divide and conquer', 'dp', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Beautiful Array.json,https://codeforces.com/blog/entry/66687,The first intuitive guess one s probably made is multiplying the segment of maximum sum for positive That thing is correct Unfortunately there is no similar strategy for non positive simple greedy won t work there Thus dynamic programming is our new friend Let s introduce the following state where is the length of the currently processed prefix is the state of maximum sum segment is not reached it ll appear later is open current elements are added to it is passed the segment appeared earlier and is the state of segment multiplied by with the same values This will store the maximum segment sum we can achieve The only base state is the prefix of length is processed and both segments are not open yet The rest of values in are There are two main transitions At any moment we can change the state of each segment to the next one without moving to the next position From state not reached we can go to state opened and from state we can go to state passed Note that this easily covers the case where optimal segment is empty We can also move to the next position updating the value of with correspondance to the current states of segments The answer will be stored in the state where all the array is processed and both segments are closed Overall complexity 
https://codeforces.com//contest/660/problem/C,54413,C,660C,660,C. Hard Process,You are given an array with elements Each element of is either or Let s denote the length of the longest subsegment of consecutive elements in consisting of only numbers one as You can change no more than zeroes to ones to maximize ,"['# include <cstdio>\n# include <set>\nusing namespace std;\nconst int MN = 3e5 + 44;\nint a[MN];\nint main()\n{\n\tint n, k;\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(""%d"", a + i);\n\t\ta[i] ^= 1;\n\t}\n\tint res = 0;\n\tint sum = 0;\n\tint h = 0;\n\tint l = 0, r = 0;\n\tfor (int t = 0; t < n; ++t)\n\t{\n\t\twhile (sum + a[h] <= k && h < n)\n\t\t{\n\t\t\tsum += a[h];\n\t\t\th++;\n\t\t}\n\t\tif (h - t > res)\n\t\t{\n\t\t\tres = h - t;\n\t\t\tl = t;\n\t\t\tr = h;\n\t\t}\n\t\tres = max(res, h - t);\n\t\tsum -= a[t];\n\t}\n\tprintf(""%d\\n"", res);\n\tfor (int i = l; i < r; ++i)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tprintf(""%d "", 1 - a[i]);\n\tprintf(""\\n"");\n}']",,,"['binary search', 'dp', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Hard Process.json,https://codeforces.com//blog/entry/44259,The problem was suggested by Mohammad Amin Raeisi Smaug Let s call the segment good if it contains no more than zeroes Note if segment is good than the segment is also good So we can use the method of two pointers the first pointer is and the second is Let s iterate over from the left to the right and move while we can to do that we should simply maintain the number of zeroes in the current segment C solution 
https://codeforces.com//contest/383/problem/B,5723,B,383B,383,B. Volcanoes,Iahub got lost in a very big desert The desert can be represented as a square matrix where each cell is a zone of the desert The cell represents the cell at row and column Iahub can go from one cell only down or right that is to cells or Also there are cells that are occupied by volcanoes which Iahub cannot enter Iahub is initially at cell and he needs to travel to cell Knowing that Iahub needs second to travel from one cell to another find the minimum time in which he can arrive in cell ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nbool cmp2(const pii &a, const pii &b) {\n  return a.second == b.second ? a.first < b.first : a.second < b.second;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int h, m;\n  while (scanf(""%d%d"", &h, &m) >= 1) {\n    int w = h;\n\n    vector<pii> pts(m);\n    for (int i = 0; i < m; i++)\n      scanf(""%d%d"", &pts[i].first, &pts[i].second);\n    sort(pts.begin(), pts.end(), cmp2);\n\n    vi ys;\n    ys.pb(1);\n    ys.pb(2);\n    ys.pb(h - 1);\n    ys.pb(h);\n    for (int i = 0; i < m; i++)\n    for (int k = -1; k <= 1; k++)\n      ys.pb(pts[i].second + k);\n    {\n      int ptr = 0;\n      for (int i = 0; i < sz(ys); i++)\n        if (1 <= ys[i] && ys[i] <= h)\n          ys[ptr++] = ys[i];\n      ys.resize(ptr);\n    }\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    assert(sz(ys) >= 1);\n    assert(ys[0] == 1);\n    assert(ys.back() == h);\n\n    set<pii> cur;\n    cur.insert(mp(1, 1));\n\n    int pptr = 0;\n    for (int cyid = 0; cyid < sz(ys); cyid++) {\n      int cy = ys[cyid];\n//      eprintf(""y=%d\\n"", cy);\n      vi curs;\n      while (pptr < m && pts[pptr].second == cy) {\n        curs.pb(pts[pptr++].first);\n      }\n      curs.pb(w + 1);\n\n      int bord = 0;\n      for (int i = 0; i < sz(curs); i++) {\n        int minx = curs[i];\n//        eprintf(""  process %d\\n"", minx);\n        for (;;) {\n          set<pii>::iterator it = cur.lower_bound(mp(bord + 1, -1));\n          if (it == cur.end()) break;\n          if (it->first > curs[i]) break;\n          minx = min(minx, it->first);\n//          eprintf(""    remove %d..%d\\n"", it->first, it->second);\n          if (it->second > curs[i]) {\n//            eprintf(""      add %d..%d\\n"", curs[i] + 1, it->second);\n            cur.insert(mp(curs[i] + 1, it->second));\n          }\n          cur.erase(it);\n        }\n        assert(minx > bord);\n        if (minx < curs[i]) {\n//          eprintf(""    new %d..%d\\n"", minx, curs[i] - 1);\n          cur.insert(mp(minx, curs[i] - 1));\n        }\n        bord = minx;\n      }\n      assert(sz(cur) <= sz(curs) + 3);\n\n/*      eprintf(""  nya:\\n"");\n      for (set<pii>::iterator it = cur.begin(); it != cur.end(); it++)\n        eprintf(""    %d..%d\\n"", it->first, it->second);*/\n    }\n\n    if (!cur.empty() && cur.rbegin()->second >= w)\n      printf(""%d\\n"", h + w - 2);\n    else\n      printf(""-1\\n"");\n  }\n  return 0;\n}\n']",,,"['binary search', 'implementation', 'sortings', 'two pointers']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Volcanoes.json,https://codeforces.com/blog/entry/10476,Our first observation is that if there is a path from 1 1 to N N then the length of path is 2 N 2 Since all paths have length 2 N 2 it follows that if there is at least one path the answer is 2 N 2 and if there isn t the answer is 1 How to prove it Every path from 1 1 to N N has exactly N 1 down directions and exactly N 1 right directions So total length for each path is N 1 N 1 2 N 2 So we reduced our problem to determine if there is at least one path from 1 1 to N N This is the challenging part of this task considering that N 10 9 How would you do it for a decently small N let s say N 10 3 One possible approach would be for each row keep a set of reachable columns We could easily solve this one by doing this if i j denotes element from ith row and jth column then i j is is not reachable if if i j contains a volcano then i j is not reachable Otherwise if at least one of i 1 j and i j 1 is reachable then i j is reachable Otherwise i j is not reachable What s the main problem of this approach It needs to keep track of 10 9 lines and in worst case each of those lines can have 10 9 reachable elements So worst case we need 10 9 10 9 10 18 operations and memory Can we optimize it We can note for beginning that we don t need to keep track of 10 9 lines only m lines are really necessarily We need only lines containing at least one obstacle in worst case when each line contains only one obstacle we need m lines How to solve it this way Suppose line number x contains some obstacles and lines x 1 x 2 x 3 do not contain any obstacle Suppose we calculated set S y cell x y is reachable How would look S1 S2 S3 corresponding to lines x 1 x 2 x 3 For S1 we can reach cell x 1 ymin where ymin is minimal value from set S Then we can also reach ymin 1 ymin 2 N by moving right from x 1 ymin So S1 ymin ymin 1 N How do S2 and S3 look It s easy to see that they ll be as well ymin ymin 1 N So we get following optimization suppose set of lines containing at least one obstacle is L1 L2 Lk We need to run algorithm only for lines L1 L1 1 L2 L2 1 L3 L3 1 Lk Lk 1 It looks like we didn t make anything with this optimization Even if we calculate for m lines each line can still have 10 9 reachable positions So worst case we perform 10 14 operations We need something better for managing information from a line You can note that for a given line y there are a lot of positions having consecutive values There are a lot of positions x y and x y 1 both reachable This should give us following idea what if instead of keeping reachable positions we keep reachable ranges That is for each line x we keep a set of ranges S a b all cells x k with a k b are reachable How many ranges can it be for a line If the line contains m obstacles there are m 1 ranges Suppose for line x all cells are reachable but for line x 1 cells x 1 3 x 1 5 x 1 N 1 are blocked Then the ranges of reachable cells are 1 2 4 4 6 N 2 and N N By now we get worst case m lines and worst case each line having m elements so in worst case we d have to handle m m 10 10 events This may still look too much but happily this bound is over estimated If a line has o obstacles there can be at most o 1 ranges If lines L1 L2 Lk have o1 o2 ok obstacles there ll be at most o1 o2 ok k ranges But o1 o2 ok m and also k is at most m proved above why we re interested in at most m lines so in worst case we get m m 2 m ranges Yaay finally a decent number of states for this problem So we iterate each line we re interested in Let s find set of ranges for this line thinking that all cells from line above are reachable This is easy to do After we get our ranges like all cells from above can be visited let s think how having obstacles above can influence current ranges After adding ranges from above current ranges can t increase obviously they can only decrease remain the same or some of them can become empty So let s take each range a b from current line and see how it will transform after adding ranges from previous line Given range a b it can transform only in a b with a a If a b then obviously range is empty Why second number of range keeps constant Let a smallest reachable column from current line which is in range a b It s enough to check a a as if a b range will be empty It s obviously why we need to keep a smallest value possible a we re interested to keep range as big as possible and as less as we cut from left as big it is Once we ve found a in range a b or a b if range is empty all cells a 1 a 2 b are reachable as well by going right from a so if interval is not empty then second number defining it remains b Next question is how to find a fast enough In order a point a to be reachable on current range it also needs to exist a range on previous line containing it If the range from previous line is pa pb then a needs to follow 3 conditions a minimal such as pa a pb a a What if instead of finding a we find pa pb Then a is max pa a In order a to be as small as possible since a is constant pa needs to be as small as possible So we reduced it to pa minimal pb a a pb a Intervals from previous line are disjoint no 2 intervals cross each other It means that if pb is minimal than pa is minimal too if we increase pb then pa will increase too so it won t be minimal Hence you need to find an interval pa pb such as pb is minimal and pb a Then a is max a pa This is easy to do if we sort all intervals from previous line increasing by second value pb then we binary search for value a Finally after running algorithm for all lines last range from last line has second number N assuming ranges are sorted increasing by second value then there exist a path otherwise there does not exist This algorithm should run O m logm worst case good enough to pass 
https://codeforces.com//contest/1852/problem/B,2099133,B,1852B,1852,B. Imbalanced Arrays,Ntarsis has come up with an array a of n non negative integers Call an array b of n integers if it satisfies the following n le b i le n b i ne 0 there are no two indices i j 1 le i j le n such that b i b j 0 for each 1 leq i leq n there are a i indices j 1 le j le n such that b i b j 0 where i and j are not necessarily distinct Given the array a Ntarsis wants you to construct some imbalanced array Help him solve this task or determine it is impossible ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> p(n);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(), [&](int i, int j) {\n        return a[i] < a[j];\n    });\n    \n    int l = 0, r = n - 1;\n    int pos = 0;\n    std::vector<int> ans(n);\n    for (int i = n; i > 0; i--) {\n        if (a[p[l]] - pos == 0) {\n            ans[p[l]] = -i;\n            l++;\n        } else if (a[p[r]] - pos == i) {\n            ans[p[r]] = i;\n            pos++;\n            r--;\n        } else {\n            std::cout << ""NO\\n"";\n            return;\n        }\n    }\n    std::cout << ""YES\\n"";\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'graphs', 'greedy', 'math', 'sortings', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Imbalanced Arrays.json,https://codeforces.com//blog/entry/116940,Analysis buffering nsqrtlog SolutionAt the start let be an index such that has the greatest absolute value If is negative we have and else Moreover we can t have for any indices and because that implies is both positive and negative contradiction Hence the necessary and sufficient condition to check if we can determine an element in array with maximum absolute value is there exists an element of array equal to xor there exists an element of array equal to Then we can remove that element and re calculate the array leading to an solution If the check fails at any moment there is no valid solution To optimize it further note that we can sort array at the start and keep track of them in a deque like structure We only need to check the front and end of the deque to see if our key condition holds Finally we can use a variable to record the number of positive elements deleted so far and subtract it from the front and end of the deque when checking our condition so that each check is The overall complexity becomes due to sorting 
https://codeforces.com//contest/777/problem/C,95271,C,777C,777,C. Alyona and Spreadsheet,During the lesson small girl Alyona works with one famous spreadsheet computer program and learns how to edit tables Now she has a table filled with integers The table consists of rows and columns By we will denote the integer located at the th row and the th column We say that the table is sorted in non decreasing order in the column if for all from to Teacher gave Alyona tasks For each of the tasks two integers and are given and Alyona has to answer the following question if one keeps the rows from to inclusive and deletes all others will the table be sorted in non decreasing order in at least one column Formally does there exist such that for all from to inclusive Alyona is too small to deal with this task and asks you to help ,"['#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c==\'-\') start=neg=true;\n        else if(c>=\'0\' && c<=\'9\') {\n            start=true;\n            num=num*10+c-\'0\';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nconst int maxn=(int)(1e5)+5;\nvector<int> a[maxn];\nint mi[maxn];\nint tmp[maxn];\n\nint main() {\n    int n,m;\n    read(n);read(m);\n    REP(i,1,n) {\n        a[i].push_back(0);\n        REP(j,1,m) {\n            int x;\n            read(x);\n            a[i].push_back(x);\n        }\n    }\n    int q;\n    read(q);\n    memset(mi,0x3f,sizeof(mi));\n    REP(j,1,m) {\n        int lst=1;\n        tmp[1]=1;\n        REP(i,2,n) {\n            if(a[i][j]<a[i-1][j]) lst=i;\n            tmp[i]=lst;\n        }\n        REP(i,1,n) mi[i]=min(mi[i],tmp[i]);\n    }\n    REP(i,1,q) {\n        int l,r;\n        read(l);read(r);\n        if(mi[r]<=l) {\n            printf(""Yes\\n"");\n        } else {\n            printf(""No\\n"");\n        }\n    }\n    return 0;\n}']",,,"['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'two pointers']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Alyona and Spreadsheet.json,https://codeforces.com//blog/entry/50670,For each cell compute value equal to maximum such that table is non decreasing in row if we keep only rows from to inclusive This values can be computed in time using the following formulas if and otherwise To process the query we have to check whether there exists such that We will answer this questions using by precomputing maximum values in each row 
https://codeforces.com//contest/1011/problem/A,201796,A,1011A,1011,A. Stages,Natasha is going to fly to Mars She needs to build a rocket which consists of several stages in some order Each of the stages is defined by a lowercase Latin letter This way the rocket can be described by the string concatenation of letters which correspond to the stages There are n stages available The rocket must contain exactly k of them Stages in the rocket should be ordered by their weight So after the stage with some letter can go only stage with a letter which is at least two positions after in the alphabet skipping one letter in between or even more For example after letter can t go letters and but can go letters For the rocket to fly as far as possible its weight should be minimal The weight of the rocket is equal to the sum of the weights of its stages The weight of the stage is the number of its letter in the alphabet For example the stage weighs one ton weighs two tons and 26 tons Build the rocket with the minimal weight or determine that it is impossible to build a rocket at all Each stage can be used at most once ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar str[100];\n\nint main() {\n  int n,k;\n  scanf(""%d%d"",&n,&k);\n  scanf(""%s"",str+1);\n  sort(str+1,str+n+1);\n  int s=0,x=1,cnt=0;\n  while (x<=n&&cnt<k) {\n  \tcnt++;\n  \ts+=str[x]-\'a\'+1;\n  \tchar c=str[x];\n  \tfor(;x<=n&&str[x]-c<2;x++);\n  }\n  printf(""%d\\n"",(cnt<k)?-1:s);\n  return 0;\n}']",,,"['greedy', 'implementation', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Stages.json,https://codeforces.com/blog/entry/60851,The problem can be solved by the following greedy algorithm Sort letters in increasing order Let s try to add letters in this order If the current letter is the first in the string then add it to the answer Otherwise check if the current letter is at least two positions later in the alphabet than the previous letter of the answer add it to the response otherwise go over to the next letter As soon as there are k letters in the answer print it If after this algorithm the answer has less than k letters print Complexity O n log n 
https://codeforces.com//contest/677/problem/B,61382,B,677B,677,B. Vanya and Food Processor,Vanya smashes potato in a vertical food processor At each moment of time the height of the potato in the processor doesn t exceed and the processor smashes centimeters of potato each second If there are less than centimeters remaining than during this second processor smashes all the remaining potato Vanya has pieces of potato the height of the th piece is equal to He puts them in the food processor one by one starting from the piece number and finishing with piece number Formally each second the following happens If there is at least one piece of potato remaining Vanya puts them in the processor one by one until there is not enough space for the next piece Processor smashes centimeters of potato or just everything that is inside Provided the information about the parameter of the food processor and the size of each potato in a row compute how long will it take for all the potato to become smashed ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,h,k;\nlong long ans;\nlong long a[1000000];\n\nvoid make(long long &x,long long y)\n{\n    long long kek=y/k;\n    if(y%k)\n        ++kek;\n    ans+=kek;\n    x-=k*kek;\n    if(x<0)\n        x=0;\n}\n\nint main()\n{\n    cin>>n>>h>>k;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    long long cur=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(cur+a[i]<=h)\n        {\n            cur+=a[i];\n            continue;\n        }\n        long long dif=cur+a[i]-h;\n        make(cur,dif);\n        cur+=a[i];\n    }\n    make(cur,cur);\n    cout<<ans<<""\\n"";\n}\n']",,,"['implementation', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Vanya and Food Processor.json,https://codeforces.com//blog/entry/45181,The solution that does same thing as in the problem statement will fail with TL because if the height of each piece of potato will be and smashing speed will be then for each piece we will do operations With each new piece of potato we will smash the potato till so we will waste seconds on it If we can not put this piece of potato after that we will waste more second to smash everything that inside else just put this piece We will get an answer same as we could get with actions from the statement Complexity Code 
https://codeforces.com//contest/860/problem/A,122864,A,860A,860,A. Did you mean...,Beroffice text editor has a wide range of features that help working with text One of the features is an automatic search for typos and suggestions of how to fix them Beroffice works only with small English letters i e with 26 letters from to Beroffice thinks that a word is typed with a typo if there are three or more consonants in a row in the word The only exception is that if the block of consonants has all letters the same then this block even if its length is greater than three is not considered a typo Formally a word is typed with a typo if there is a block of not less that three consonants in a row and there are at least two different letters in this block For example the following words have typos and the following words don t have typos and When Beroffice editor finds a word with a typo it inserts as little as possible number of spaces in this word dividing it into several words in such a way that each of the resulting words is typed without any typos Implement this feature of Beroffice editor Consider the following letters as the only vowels and All the other letters are consonants in this problem ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\n\nint cons[256];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tFOR(i,256) cons[i]=1;\n\tcons['a']=0;\n\tcons['i']=0;\n\tcons['u']=0;\n\tcons['e']=0;\n\tcons['o']=0;\n\t\n\t\n\tcin>>S;\n\tstring T;\n\tint hoge=0;\n\tFOR(i,S.size()) {\n\t\tchar c=S[i];\n\t\tif(cons[c]==0) hoge=0;\n\t\telse hoge++;\n\t\tif(hoge>=3) {\n\t\t\tif(S[i]==S[i-1] && S[i]==S[i-2]) {\n\t\t\t\thoge=3;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thoge=1;\n\t\t\t\tT+=' ';\n\t\t\t}\n\t\t}\n\t\tT+=c;\n\t}\n\tcout<<T<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n""]",,,"['greedy', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Did you mean....json,https://codeforces.com//blog/entry/54604,We will solve the problem greedily Let s find the leftmost typo It will be three consecutive characters si 1 si and si 1 such that all of them are consonants and there are at least two diffirent letters It is clear that we can cut this string after position i because prefix will be correct and we will leave only one letter in the remaining part of the string So each time we find the leftmost typo and cut out the prefix Remember that after cutting the prefix you have to continue checking from index i 2 not i 1 
https://codeforces.com//contest/763/problem/D,91412,D,763D,763,D. Timofey and a flat tree,Little Timofey has a big tree an undirected connected graph with vertices and no simple cycles He likes to walk along it His tree is flat so when he walks along it he sees it entirely Quite naturally when he stands on a vertex he sees the tree as a rooted tree with the root in this vertex Timofey assumes that the non isomorphic subtrees are there in the tree the more beautiful the tree is A subtree of a vertex is a subgraph containing this vertex and all its descendants You should tell Timofey the vertex in which he should stand to see the most beautiful rooted tree Subtrees of vertices and are isomorphic if the number of children of equals the number of children of and their children can be arranged in such a way that the subtree of the first son of is isomorphic to the subtree of the first son of the subtree of the second son of is isomorphic to the subtree of the second son of and so on In particular subtrees consisting of single vertex are isomorphic to each other ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\ntypedef vector<int> VI;\n// head\ntypedef unsigned long long ull;\n\nconst int N=101000;\null seed[2*N],hv[N],hv2[N];\nmap<ull,int> hp;\nint ansv,ansp,n,u,v,tot,hd[N],hd2[N],hs[N*2],cnt;\nVI e[N];\nvoid dfs(int u,int f) {\n\thv[u]=seed[0];\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t\thv[u]+=seed[hd[v]];\n\t}\n\tif (!hp.count(hv[u])) hp[hv[u]]=++tot;\n\thd[u]=hp[hv[u]];\n}\nvoid dfs2(int u,int f) {\n\tull h0=hv[u];\n\tif (f!=0) h0+=seed[hd2[u]];\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\thv2[v]=h0-seed[hd[v]];\n\t\tif (!hp.count(hv2[v])) hp[hv2[v]]=++tot;\n\t\thd2[v]=hp[hv2[v]];\n\t}\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs2(v,u);\n\t}\n}\n\nvoid dfs3(int u,int f) {\n\tif (cnt>ansv) {\n\t\tansv=cnt; ansp=u;\n\t}\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tcnt-=!(--hs[hd[v]]);\n\t\tcnt+=!(hs[hd2[v]]++);\n\t\tdfs3(v,u);\n\t\tcnt-=!(--hs[hd2[v]]);\n\t\tcnt+=!(hs[hd[v]]++);\n\t}\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,2*n+2) seed[i]=((ull)rand()<<40)+((ull)rand()<<20)+(ull)rand();\n\trep(i,1,n) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tdfs2(1,0);\n\trep(i,2,n+1) cnt+=!(hs[hd[i]]++);\n\tansp=1; ansv=cnt;\n\tdfs3(1,0);\n\tprintf(""%d\\n"",ansp);\n}\n']",,,"['data structures', 'graphs', 'hashing', 'shortest paths', 'trees']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Timofey and a flat tree.json,https://codeforces.com//blog/entry/50205,There are only subtrees in the whole tree two for each edge Let s calculate hashes of each of them We can calculate hash of a subtree for example in a following Let s associate each vertex with a correct bracket sequence Leaves are associated with other vertices are associated with their sequences according to the following rule Assume that the children of our vertex are associated with sequences Let s sort strings in some order for example in order of ascending hashes Then our vertex is associated with sequence It s easy to check that isomorphic subtrees are associated with equal sequences and non isomoriphic are associated with different sequences Then hash of a subtree is the hash of the sequence associated with the root of the subtree In this problem we will calculate the polynomial hash because we will need to count the hash of concatenation of several strings knowing only their hash and length We know hashes for all of the leaves Let s do a bfs like algorithm that will greedily count all of the hashes Let s count number of outer edges for vertex for which we have already counted hashes of their subtrees Then we know new hashes in two cases Then we can calculate the hash for the inner edge of for which we don t already know the outer hash in time Then we can calculate the hash for all of the inner edges for which we don t already know it Let s calculate hashes for all of concatenations of prefixes and suffixes of the sorted array If we count polynomial hash we can calculate them knowing only their hashes and length Then when we calculate the hash for particular edge we just have to concatenate the prefix and the suffix of our array This all works in time Now we have to calculate for each vertex the number of distinct hashes in case is the root Let s select some vertex and calculate this number fairly using dfs and storing for each hash number of its occurrences in a hashtable Then we go through the tree in order of Euler tour and maintain the hashtable When we go through edge we should add hash of the edge and remove hash of the edge other hashes in the hashtable doesn t change This works in time Author s solution http pastebin com 05KPvqN1 Find the vertex with amount of distinct subtrees in terms of isomorphism in time 
https://codeforces.com//contest/1027/problem/B,209489,B,1027B,1027,B. Numbers on the Chessboard,You are given a chessboard of size n times n It is filled with numbers from 1 to n 2 in the following way the first lceil frac n 2 2 rceil numbers from 1 to lceil frac n 2 2 rceil are written in the cells with even sum of coordinates from left to right from top to bottom The rest n 2 lceil frac n 2 2 rceil numbers from lceil frac n 2 2 rceil 1 to n 2 are written in the cells with odd sum of coordinates from left to right from top to bottom The operation lceil frac x y rceil means division x by y rounded up For example the left board on the following picture is the chessboard which is given for n 4 and the right board is the chessboard which is given for n 5 You are given q queries The i th query is described as a pair x i y i The answer to the i th query is the number written in the cell x i y i x i is the row y i is the column Rows and columns are numbered from 1 to n ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nll n;\n\nvoid solve() {\n\tll x, y;\n\tscanf(""%lld%lld"", &x, &y);\n\tx--;y--;\n\tll ans = 0;\n\tif ((x + y) % 2 == 0) {\n\t\tans += (x / 2) * n;\n\t\tif (x % 2 == 0) {\n\t\t} else {\n\t\t\tans += (n + 1) / 2;\n\t\t}\n\t\tans += y / 2;\n\t} else {\n\t\tans += (n * n + 1) / 2;\n\t\tans += (x / 2) * n;\n\t\tif (x % 2 == 0) {\n\n\t\t} else {\n\t\t\tans += n / 2;\n\t\t}\n\t\tans += y / 2;\n\t}\n\tprintf(""%lld\\n"", ans + 1);\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%lld%d"", &n, &q);\n\twhile(q--) solve();\n\n\treturn 0;\n}\n']",,,"['implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Numbers on the Chessboard.json,https://codeforces.com//blog/entry/61311,Let s see the following fact if we will decrease from all numbers written in cells with an odd sum of coordinates and write out the numbers obtained on the board from left to right from top to bottom the sequence will looks like for even for odd there is only one number at the end of the sequence but in general it does not matter Let s try to find out the answer for some query Let 1 indexed There is the position of our cell in order of the written sequence The first approximation of the answer is But now we are remember that we decreased from all numbers written in cells with an odd sum of coordinates So if is even then the answer is otherwise the answer is Note that you should be careful with integer overflow in C Java or similar languages 64 bit datatype is quite enough Time complexity 
https://codeforces.com//contest/839/problem/C,117994,C,839C,839,C. Journey,There are cities and roads in the Seven Kingdoms each road connects two cities and we can reach any city from any other by the roads Theon and Yara Greyjoy are on a horse in the first city they are starting traveling through the roads But the weather is foggy so they can t see where the horse brings them When the horse reaches a city including the first one it goes to one of the cities connected to the current city But it is a strange horse it only goes to cities in which they weren t before In each such city the horse goes with equal probabilities and it stops when there are no such cities Let the length of each road be The journey starts in the city What is the expected length expected value of length of their journey You can read about expected average value by the link https en wikipedia org wiki Expected value ,"['#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=1000*1007;\n\nint n;\n\nvector <int> graf[N];\n\ndouble dfs(int v, int par)\n{\n    double res=0.0;\n    int cou=0;\n    for (int i : graf[v])\n    {\n        if (i==par)\n            continue;\n        cou++;\n        res+=dfs(i, v);\n    }\n    if (!cou)\n        return 0.0;\n    return (res/cou)+1.0;\n}\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i=1; i<n; i++)\n    {\n        int a, b;\n        scanf(""%d%d"", &a, &b);\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n    printf(""%.9lf\\n"", dfs(1, 0));\n    return 0;\n}\n']",,,"['dfs and similar', 'dp', 'graphs', 'probabilities', 'trees']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Journey.json,https://codeforces.com//blog/entry/53815,Let the cities be vertices and roads be edges of a tree and vertex be the root of the tree Let be the answer for the th vertex the expected value if they start their journey from that vertex and the horse doesn t go to it s parent Now we can calculate by knowing the answer for it s children Let be the children of th vertex then Because when we are at th vertex we have choices with equal probabilities and for going to one of them length of the edge between th vertex and it s children So if we know the answer of some vertex s children we can calculate its expected value and we can do it by a simple DFS note that the answer for a leave is 
https://codeforces.com//contest/757/problem/F,88533,F,757F,757,F. Team Rocket Rises Again,It s the turn of the year so Bash wants to send presents to his friends There are cities in the Himalayan region and they are connected by bidirectional roads Bash is living in city Bash has exactly one friend in each of the other cities Since Bash wants to surprise his friends he decides to send a Pikachu to each of them He also wants to send it to them as soon as possible He finds out the minimum time for each of his Pikachus to reach its destination city Since he is a perfectionist he informs all his friends with the time their gift will reach them A Pikachu travels at a speed of meters per second His friends were excited to hear this and would be unhappy if their presents got delayed Unfortunately Team Rocket is on the loose and they came to know of Bash s plan They want to maximize the number of friends who are unhappy with Bash They do this by destroying exactly one of the other cities This implies that Note that Since Bash is already a legend can you help Team Rocket this time and find out the maximum number of Bash s friends who can be made unhappy by destroying exactly one city ,"['/**\n *    author:  tourist\n *    created: 07.09.2017 15:04:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n  public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector< vector<int> > g;\n  int n;\n\n  function<bool(int)> ignore;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n    ignore = nullptr;\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n\n  virtual void set_ignore_edge_rule(const function<bool(int)> &f) {\n    ignore = f;\n  }\n\n  virtual void unset_ignore_edge_rule() {\n    ignore = nullptr;\n  }\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n  public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n  using graph<T>::ignore;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    if (ignore != nullptr) {\n      rev.set_ignore_edge_rule([&](int id) {\n        return ignore(id);\n      });\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n  public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector <T> dijkstra(const graph<T> &g, int start) {\n  assert(0 <= start && start < g.n);\n  vector<T> dist(g.n, numeric_limits<T>::max());\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > s;\n  dist[start] = 0;\n  s.emplace(dist[start], start);\n  while (!s.empty()) {\n    T expected = s.top().first;\n    int i = s.top().second;\n    s.pop();\n    if (dist[i] != expected) {\n      continue;\n    }\n    for (int id : g.g[i]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ i;\n      if (dist[i] + e.cost < dist[to]) {\n        dist[to] = dist[i] + e.cost;\n        s.emplace(dist[to], to);\n      }\n    }\n  }\n  return dist;\n  // returns numeric_limits<T>::max() if there\'s no path\n}\n\ntemplate <typename T>\nvector<int> dominators(digraph<T> &g, int root) {\n  int n = g.n;\n  vector<int> pos(n, -1);\n  vector<int> order;\n  vector<int> parent(n, -1);\n  function<void(int)> dfs = [&](int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    for (int id : g.g[v]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int u = e.to;\n      if (pos[u] == -1) {\n        parent[u] = v;\n        dfs(u);\n      }\n    }\n  };\n  dfs(root);\n  vector<int> p(n), best(n);\n  iota(p.begin(), p.end(), 0);\n  iota(best.begin(), best.end(), 0);\n  vector<int> sdom = pos;\n  function<int(int)> find_best = [&](int x) {\n    if (p[x] != x) {\n      int u = find_best(p[x]);\n      if (sdom[u] < sdom[best[x]]) {\n        best[x] = u;\n      }\n      p[x] = p[p[x]];\n    }\n    if (sdom[best[p[x]]] < sdom[best[x]]) {\n      best[x] = best[p[x]];\n    }\n    return best[x];\n  };\n  digraph<int> g_rev = g.reverse();\n  vector<int> idom(n, -1);\n  vector<int> link(n, 0);\n  vector< vector<int> > bucket(n);\n  for (int it = (int) order.size() - 1; it >= 0; it--) {\n    int w = order[it];\n    for (int id : g_rev.g[w]) {\n      if (g_rev.ignore != nullptr && g_rev.ignore(id)) {\n        continue;\n      }\n      auto &e = g_rev.edges[id];\n      int u = e.to;\n      sdom[w] = min(sdom[w], sdom[find_best(u)]);\n    }\n    idom[w] = order[sdom[w]];\n    for (int u : bucket[w]) {\n      link[u] = find_best(u);\n    }\n    for (int id : g.g[w]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int u = e.to;\n      if (parent[u] == w) {\n        p[u] = w;\n      }\n    }\n    bucket[order[sdom[w]]].push_back(w);\n  }\n  for (int it = 1; it < (int) order.size(); it++) {\n    int w = order[it];\n    idom[w] = idom[link[w]];\n  }\n  return idom;\n  // idom[i] -- immediate dominator for vertex i\n}\n\ntemplate <typename T>\nvector<int> find_topsort(const digraph<T> &g) {\n  vector<int> deg(g.n, 0);\n  for (int id = 0; id < (int) g.edges.size(); id++) {\n    if (g.ignore != nullptr && g.ignore(id)) {\n      continue;\n    }\n    deg[g.edges[id].to]++;\n  }\n  vector<int> x;\n  for (int i = 0; i < g.n; i++) {\n    if (deg[i] == 0) {\n      x.push_back(i);\n    }\n  }\n  for (int ptr = 0; ptr < (int) x.size(); ptr++) {\n    int i = x[ptr];\n    for (int id : g.g[i]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (--deg[to] == 0) {\n        x.push_back(to);\n      }\n    }\n  }\n  if ((int) x.size() != g.n) {\n    return vector<int>();\n  }\n  return x;\n}\n\nint main() {\n  int n, m, st;\n  scanf(""%d %d %d"", &n, &m, &st);\n  st--;\n  undigraph<long long> gd(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    scanf(""%d %d %d"", &x, &y, &z);\n    x--; y--;\n    gd.add(x, y, z);\n  }\n  vector<long long> d = dijkstra(gd, st);\n  digraph<int> g(n);\n  const long long inf = numeric_limits<long long>::max();\n  for (int i = 0; i < n; i++) {\n    for (int id : gd.g[i]) {\n      auto &e = gd.edges[id];\n      int to = i ^ e.from ^ e.to;\n      if (d[to] != inf && d[i] != inf && d[i] + e.cost == d[to]) {\n        g.add(i, to);\n      }\n    }\n  }\n  vector<int> dom = dominators(g, st);\n  vector<int> order = find_topsort(g);\n  vector<int> who(n), dcnt(n);\n  for (int i : order) {\n    if (i == st || dom[i] == -1) {\n      continue;\n    }\n    if (dom[i] == st) {\n      who[i] = i;\n    } else {\n      who[i] = who[dom[i]];\n    }\n    dcnt[who[i]]++;\n  }\n  int mx = 0;\n  for (int x : dcnt) {\n    mx = max(mx, x);\n  }\n  printf(""%d\\n"", mx);\n  return 0;\n}\n']",,,"['data structures', 'graphs', 'shortest paths']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Team Rocket Rises Again.json,https://codeforces.com//blog/entry/49743,Main idea Building Dominator tree on shortest path DAG First of all we run Dijkstra s shortest path algorithm from s as the source vertex and construct the shortest path DAG of the given graph Note that in the shortest path DAG the length of any path from s to any other node x is equal to the length of the shortest path from s to x in the given graph Now let us analyze what the function f s x means It will be equal to the number of nodes u such that every path from s to u passes through node x in the shortest path DAG such that on removing node x from the DAG there will be no path from s to u In other words we want to find the number of nodes u that are dominated by node x considering s as the sources vertex in the shortest path DAG This can be calculated by building dominator tree of the shortest path DAG considering s as the source vertex A node u is said to dominate a node w wrt source vertex s if all the paths from s to w in the graph must pass through node u You can read more about dominator tree here Once the dominator tree is formed the answer for any node x is equal to the number of nodes in the subtree of x in the tree formed Author s code Another approach for forming dominator tree is by observing that the shortest path directed graph formed is a DAG i e acyclic So suppose we process the nodes of the shortest path dag in topological order and have a dominator tree of all nodes from which we can reach x already formed Now for the node x we look at all the parents p of x in the DAG and compute their LCA in the dominator tree built till now We can now attach the node x as a child of the LCA in the tree 
https://codeforces.com//contest/930/problem/E,162262,E,930E,930,E. Coins Exhibition,Arkady and Kirill visited an exhibition of rare coins The coins were located in a row and enumerated from left to right from to each coin either was laid with its obverse front side up or with its reverse back side up Arkady and Kirill made some photos of the coins each photo contained a segment of neighboring coins Akrady is interested in obverses so on each photo made by him there is at least one coin with obverse side up On the contrary Kirill is interested in reverses so on each photo made by him there is at least one coin with its reverse side up The photos are lost now but Arkady and Kirill still remember the bounds of the segments of coins each photo contained Given this information compute the remainder of division by of the number of ways to choose the upper side of each coin in such a way that on each Arkady s photo there is at least one coin with obverse side up and on each Kirill s photo there is at least one coin with reverse side up ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 600001;\n\nconst ll MOD = static_cast<ll>(1e9 + 7);\n\nll pw(ll a, ll b) {\n    if (!b) {\n        return 1;\n    }\n\n    ll v = pw(a, b / 2);\n    v = (v * v) % MOD;\n\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\n\nvoid add(ll& x, ll y) {\n    x = (x + y) % MOD;\n}\n\nvoid sub(ll& x, ll y) {\n    x -= y;\n    x %= MOD;\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\nvector<ll> xs;\n\n\nint la[MAXN];\nint ra[MAXN];\nint lb[MAXN];\nint rb[MAXN];\n\nll f[2][MAXN];\nll tot[2];\nint req[2][MAXN];\nint p[2];\n\nint gt(int x) {\n    return lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n}\n\nvoid ad(int x, int y, ll z) {\n    add(tot[x], z);\n    add(f[x][y], z);\n}\n\nint main() {\n#ifdef BZ\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int k, n, m;\n    cin >> k >> n >> m;\n    xs = { 0, k };\n    for (int i = 0; i < n; ++i) {\n        cin >> la[i] >> ra[i];\n        xs.push_back(--la[i]);\n        xs.push_back(ra[i]);\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        cin >> lb[i] >> rb[i];\n        xs.push_back(--lb[i]);\n        xs.push_back(rb[i]);\n    }\n\n    xs.push_back(-1);\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    int c = xs.size() - 1;\n\n    ad(0, 0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        int& x = req[0][gt(ra[i])];\n        x = max(x, gt(la[i]));\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int& x = req[1][gt(rb[i])];\n        x = max(x, gt(lb[i]));\n    }\n\n    for (int i = 1; i < c; ++i) {\n        ll good = pw(2, xs[i + 1] - xs[i]);\n        ll t[2] = { tot[0], tot[1] };\n\n        good -= 2;\n        if (good < 0) {\n            good += MOD;\n        }\n\n        good = (good * (t[0] + t[1])) % MOD;\n        ad(0, i, good);\n\n        for (int j = 0; j < 2; ++j) {\n            int rj = j ^ 1;\n            ad(j, i - 1, t[rj]);\n\n            while (p[j] < req[rj][i + 1]) {\n                sub(tot[j], f[j][p[j]++]);\n            }\n        }\n    }\n\n    cout << (tot[0] + tot[1]) % MOD;\n}']",,,"['data structures', 'dp', 'math']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Coins Exhibition.json,https://codeforces.com//blog/entry/58177,Denote obverse up coin as 0 and reverse up coin as 1 Then we are to compute the number of binary strings of length k such that n of the given segments have atleast one 0 and other m ones atleast one 1 Let dp i l0 l1 be the number of binary strings of length i such that the last zero is at position l0 the last one is at l1 and all restrictions are satisfied for all segments with right borders not exceeding i The transitions then are straighforward check all possible values for position i 1 and relax l0 and l1 accordingly Let the new values be l0 and l1 Now consider all segments ending at i 1 If there are such l r among them demanding zero while l l0 or demanding one while l l1 this continuation doesn t suit Otherwise add dp i l0 l1 to dp i 1 l0 l1 This works in O k3 n m if we precompute all segments ending in r for all r Anyway this is too slow The first thing to enhance is to notice that either l0 i or l1 i Then we have to deal with dp0 i l1 implying l0 i and dp1 i l0 implying l1 i The transitions are the same and the complexity becomes O k2 n m Still too slow The further improvement is that all positions with no segments endings can be treated similarly since the transitions are equal At the same time it doesn t matter whether the last zero is at l0 or l0 1 if there are no segments beginning at l0 1 Same applies to l1 Let s compress coordinates then i e find all xi such that xi and xi 1 are covered by different sets of segments Now it s time to slightly change the dp definition let dp0 i l1 be the number of binary strings of length xi such that the last digit is 0 the last 1 is somewhere between xl1 1 1 and xl1 and all restrictions are satisfied for all segments with endings not exceeding xi dp1 i l0 is denoted in a similar fashion Consider the possible transitions Without loss of generality we ll account for transitions from dp0 i l1 to some dp i 1 The goal is to somehow append a binary string of length xi 1 xi to the existing one There are three major cases All additional digits are 0 then we jump to dp0 i 1 l1 with coefficient 1 there s only one way to construct a string of zeros All additional digits are 1 then we jump to dp1 i 1 i with coefficient 1 Note that the last zero remains at xi There are some 0 and some 1 Then the jump is to dp0 i 1 i 1 and dp1 i 1 i 1 with coefficients equal to 2xi 1 xi 1 1 since only the last digit if fixed This is possible iff xi 1 xi 1 Moreover we have to consider all segments ending at xi 1 and discard those not satisfying the restrictions This works in extra logarithm is for fast powers There s only one step left to a full solution Note that in the dp above you can separate digit adding from constraint accounting transitions and treat them one after another That means that you can first apply all transitions from to disregarding segments endings at xi 1 and then null dp0 i 1 l1 where l1 l where l xi is an arbitrary segment applying 1 constraint and null dp1 i 1 l0 where l0 l where l xi is an arbitrary segment applying 0 constraint Futhermore note that transitions with coeffitients not equal to 1 are applied only to and while values of where j i are either or 0 That means we can store two arrays dp0 l1 and dp1 l0 implying i being equal to the current value Now when jumping from i to i 1 we have to relax and and null some prefix of dp0 and some prefix of dp1 depending on beginnins of segments ending at xi The new values of and are easy to obtain via sum of elements in this arrays and xi 1 xi With a properly chosen data structure the complexity becomes with O n m memory This is now enough to get ac There s an alternative approach you can just keep track of the first non nulled element since it can only increase This also helps maintain the current sum of values without using specific data structures This works in including sort 
https://codeforces.com//contest/1716/problem/C,1494202,C,1716C,1716,C. Robot in a Hallway,There is a grid consisting of 2 rows and m columns The rows are numbered from 1 to 2 from top to bottom The columns are numbered from 1 to m from left to right The robot starts in a cell 1 1 In one second it can perform either of two actions move into a cell adjacent by a side up right down or left remain in the same cell The robot is not allowed to move outside the grid Initially all cells except for the cell 1 1 are locked Each cell i j contains a value a i j the moment that this cell gets unlocked The robot can only move into a cell i j if at least a i j seconds have passed before the move The robot should visit all cells cell 1 1 is considered entered at the start It can finish in any cell What is the fastest the robot can achieve that ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[2][N];\nint b[2][N];\nint c[2][N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(""%d"", &a[i][j]);\n\t\t\tif (i + j > 0) a[i][j]++;\n\t\t}\n\tb[0][n] = b[1][n] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tb[k][i] = max(max(a[k ^ 1][i], a[k][i] + 2 * (n - i) - 1), b[k][i + 1] + 1);\n\t\t}\n\t}\n\tint ans = (int)1e9 + (int)1e8;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k = i & 1;\n\t\tans = min(ans, max(cur, b[k][i]));\n\t\tcur = max(cur, a[k][i] + 2 * (n - i) - 1);\n\t\tcur = max(cur, a[k ^ 1][i] + 2 * (n - i) - 2);\n\t}\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'greedy', 'implementation', 'ternary search']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Robot in a Hallway.json,https://codeforces.com//blog/entry/105653,Let s first consider the possible paths across the grid that visit all cells You can immediately think of two of them The first one is go right to the wall turn into the other row and return Let s call it a hook The second one is go down go right go up go right and so on Let s call it a snake Turns out these two are basically the two extremes of all paths You can start with a snake and turn into a hook when you wish You can see that once you move right twice in a row you can only continue with a hook And as long as you didn t move right twice you are just doing a snake Let s fix some path across the grid What will its minimum time be Calculate it iteratively If you want to enter the next cell and it s still locked wait until it isn t So there are some seconds of waiting possibly zero before each cell However why not instead do the following Let s calculate the sum of waiting time required and wait for that amount of seconds before starting to move All cells will be visited at the same time as before or even later Thus they will surely be unlocked if they were in the original plan So the goal is to calculate the minimum amount of time required to wait in the start then add the movement time to it Once again the path is fixed Let the th cell of the path be If you start after waiting for seconds then you reach the th cell at time is indexed Thus the th cell should have If all cells satisfy this condition then the path can be done after waiting for seconds at the start Let s rewrite it into So the condition tells us that should be greater or equal than this value for all cells In other words should be greater or equal than the maximum of the values over all cells Study the formula Imagine we have some path with a known length and want to append a cell to it That s pretty simple Just update the maximum with the value with the corresponding cell and increase the length What if we wanted to prepend a cell to it Turns out it s not that hard as well Every cell in the path gets its value increased by From the formula you can see that this actually decreases the value of each cell by So the maximum decreases by as well The only thing left is to update the maximum with the value of the new first cell Well and increase the length again Finally let s learn how to choose the best path We can iterate over the length of the snake part The hook part is determined uniquely It s easy to maintain the maximum on the snake Just append the new cell to the path How to glue up the hook part to that Well actually realize that the formula allows us to glue up two paths into one Let path have length and maximum and path have length and maximum To make path start after path we just decrease its maximum by The resulting path has length and maximum Let s look closer into what the hooks look like They start in some column traverse all the way right then left up to the same column If the snake part took both cells in its last column then that s it Otherwise the hook has to take the final cell in the last column column If we manage to precalculate something for hooks that start in some column and end in column then we will be able to use that Appending the final cell is not a hard task since we know its index in the path Let be the waiting time required for a hook that starts in cell and ends in a cell as if the path started with the hook cell is the first one can be calculated from Prepend it with a cell and append it with a cell The only thing left is to find the best answer I found the most convenient to start with a snake of length only cell and progress it two steps at the time update the answer progress the snake to the other cell of the current column update the answer progress the snake into the next column Overall complexity per testcase 
https://codeforces.com//contest/2034/problem/G1,3057442,G1,2034G1,2034,G1. Simurgh s Watch  Easy Version ,The legendary Simurgh a mythical bird is responsible for keeping watch over vast lands and for this purpose she has enlisted n vigilant warriors Each warrior is alert during a specific time segment l i r i where l i is the start time included and r i is the end time included both positive integers One of Simurgh s trusted advisors Zal is concerned that if multiple warriors are stationed at the same time and all wear the same color the distinction between them might be lost causing confusion in the watch To prevent this whenever multiple warriors are on guard at the same moment there must be at least one color which is worn by exactly one warrior So the task is to determine the minimum number of colors required and assign a color c i to each warrior s segment l i r i such that for every real time t contained in at least one segment there exists one color which belongs to exactly one segment containing t ,"['#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n;struct inter {\tint l, r, id;\tinter() {\xa0\t}} it[N];int l[N], r[N];int ans[N];int tak[N];int arr[N], atot;vi to[N], bak[N];int cov[N];int ncov[N];bool check_1() {\tL(i, 1, atot) ncov[i] = 0;\tL(i, 1, n) {\t\t++ncov[l[i]];\t\t--ncov[r[i] + 1];\t}\tL(i, 1, atot) ncov[i] += ncov[i - 1];\tL(i, 1, atot) if(ncov[i] > 1) return 0;\tcout << ""1\\n"";\tL(i, 1, n) cout << 1 << \' \';\tcout << \'\\n\';\treturn 1;}int p1[N], p2[N];bool check_2() {\tint vl[2] = {0, 0}, vr[2] = {0, 0}, cur = 0;\tL(i, 1, atot) {\t\tsort(to[i].begin(), to[i].end(), [&] (int x, int y) {\t\t\treturn r[x] > r[y];\t\t});\t\tfor(auto j : to[i]) {\t\t\t// cout << j << "" : "" << l[i] << "" "" << r[i] << "", "" << vl[0] << \' \' << vr[0] << "", "" << vl[1] << \' \' << vr[1] << endl;\t\t\tint winl = vl[0] < i;\t\t\tint winr = vl[1] < i;\t\t\tif(vr[0] < i) {\t\t\t\tans[j] = 0;\t\t\t} else if(vr[1] < i) {\t\t\t\tans[j] = 1;\t\t\t} else if(winl && winr) {\t\t\t\tif(vr[0] < vr[1]) {\t\t\t\t\tans[j] = 0;\t\t\t\t} else {\t\t\t\t\tans[j] = 1;\t\t\t\t}\t\t\t} else if(winl) {\t\t\t\tans[j] = 1;\t\t\t} else {\t\t\t\tans[j] = 0;\t\t\t}\t\t\tvl[ans[j]] = max(vl[ans[j]], min(vr[ans[j]], r[j]));\t\t\tvr[ans[j]] = max(vr[ans[j]], r[j]);\t\t}\t}\tL(i, 0, atot + 1) p1[i] = p2[i] = 0;\tL(o, 0, 1) {\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i] + 1] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p1[i] = 1;\xa0\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i]] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p2[i] = 1;\t}\tL(i, 1, atot) if(!p1[i]) return 0;\tL(i, 1, atot - 1) if(!p2[i] && cov[i]) return 0; \tcout << ""2\\n"";\tL(i, 1, n) cout << ans[i] + 1 << \' \';\tcout << \'\\n\';\treturn 1;}mt19937 rng;int rad(int l, int r) {\treturn rng() % (r - l + 1) + l;}void Main() {\t// n = 10;\t// L(i, 1, n) {\t// \tit[i].l = rng() % 10 + 1;\t// \tit[i].r = rng() % 10 + 1;\t// \tif(it[i].l > it[i].r) {\t// \t\tswap(it[i].l, it[i].r);\t// \t}\t// }\tcin >> n;\tL(i, 1, n) cin >> it[i].l >> it[i].r;\t\tatot = 0;\tL(i, 1, n) it[i].id = i;\tL(i, 1, n) arr[++atot] = it[i].l, arr[++atot] = it[i].r;\tsort(arr + 1, arr + atot + 1);\tatot = unique(arr + 1, arr + atot + 1) - arr - 1;\tL(i, 1, n) \t\tit[i].l = lower_bound(arr + 1, arr + atot + 1, it[i].l) - arr, \t\tit[i].r = lower_bound(arr + 1, arr + atot + 1, it[i].r) - arr;\tL(i, 0, atot + 1) cov[i] = 0, to[i].clear(), bak[i].clear();\tL(i, 1, n)\t\tl[i] = it[i].l, r[i] = it[i].r, to[l[i]].pb(i), bak[r[i]].pb(i);\tL(i, 1, n) cov[l[i]] += 1, cov[r[i]] -= 1;\tL(i, 1, atot) cov[i] += cov[i - 1];\tif(check_1()) {\t\treturn;\t}\tif(check_2()) {\t\treturn;\t}\tcout << ""3\\n"";\tvi vp;\tL(i, 1, atot) {\t\tsort(to[i].begin(), to[i].end(), [&] (int x, int y) {\t\t\treturn r[x] > r[y];\t\t});\t\tfor(auto j : to[i]) {\t\t\tif(!sz(vp) || r[j] > r[vp.back()]) {\t\t\t\twhile(sz(vp) > 1 && r[vp[sz(vp) - 2]] >= l[j]) {\t\t\t\t\tvp.pop_back();\t\t\t\t}\t\t\t\tvp.pb(j);\t\t\t}\t\t}\t}\t// cout<<""SZ=""<<sz(vp)<<endl;\tL(i, 1, n) ans[i] = 3;\tL(i, 0, sz(vp) - 1) {\t\tans[vp[i]] = 1 + (i & 1);\t}\tL(i, 1, n) cout << ans[i] << \' \';\tcout << \'\\n\';\tL(o, 1, 3) {\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i] + 1] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p1[i] = 1;\xa0\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i]] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p2[i] = 1;\t}\t// for(auto u : vp) {\t// \tcout << l[u] << \' \' << r[u] << endl;\t// }\tL(i, 1, atot) if(!p1[i]) assert(false);\tL(i, 1, atot - 1) if(!p2[i] && cov[i]) assert(false);}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tinit(1e6);\tint t; cin >> t; while(t--) Main();\treturn 0;}']",,,"['constructive algorithms', 'greedy', 'implementation', 'sortings']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G1. Simurgh s Watch  Easy Version .json,https://codeforces.com//blog/entry/136579,Solution It is easy to check if the solution can be achieved with only one color For any time point there must be at most one interval containing since if multiple intervals contain they must be colored differently A simple strategy is to solve the problem using three colors First we color some intervals with colors 1 and 2 then color others with color 3 For each step we find the leftmost point that has not been colored yet and color the segment that contains this point We always choose the interval with the largest endpoint that contains the current point By coloring the intervals alternately with colors 1 and 2 we ensure that all points are covered by exactly one of these colors Now we check if we can color the intervals with just two colors using a greedy algorithm We iterate over the intervals sorted by start increasingly and then by end decreasingly At each point we keep track of the number of colors used in previous intervals that are not yet closed Let this number be and suppose we are currently at interval We color the current interval based on the value of If color interval with color 1 If color interval with the opposite color of the current used color If color interval with the opposite color of the interval with the greatest endpoint among the currently open intervals If it is impossible to assign a unique color between overlapping intervals at any point it can be shown that coloring the intervals using only 2 colors is impossible Solving G1 using G2 It s sufficient to check the integer points and half points e g 1 5 2 5 to verify whether the coloring is valid Why To handle this we can multiply all the given points by two effectively converting the problem into one in which only integer points exist After this transformation we solve the problem in the integer system of G2 where the intervals and coloring rules are defined using integer boundaries Note A brief explanation of why this greedy algorithm works can be found here 
https://codeforces.com//contest/747/problem/B,85393,B,747B,747,B. Mammoth s Genome Decoding,The process of mammoth s genome decoding in Berland comes to its end One of the few remaining tasks is to restore unrecognized nucleotides in a found chain Each nucleotide is coded with a capital letter of English alphabet or Unrecognized nucleotides are coded by a question mark Thus is a string consisting of letters and characters It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define ff first\n#define ss second\nusing namespace std;\nconst int N=200005;\nconst int inf=1e9+7;\ntypedef long long ll;\ntypedef long double lb;\ninline void read(int &x){x=0; char ch=getchar();while(ch<\'0\') ch=getchar();while(ch>=\'0\'){x=x*10+ch-48; ch=getchar();}}\n//------------------------------------------head---------------------------------------------------//\nint cnt[5];\nchar s[N];\nint main()\n{\n\tint n; scanf(""%d"",&n);\n\tif(n%4!=0)return puts(""===""),0;\n\tscanf(""%s"",s); cnt[0]=cnt[1]=cnt[2]=cnt[3]=n/4;\n\trep(i,0,n-1)\n\t{\n\t\tif(s[i]==\'A\') --cnt[0];\n\t\telse if(s[i]==\'C\') --cnt[1];\n\t\telse if(s[i]==\'G\') --cnt[2];\n\t\telse if(s[i]==\'T\') --cnt[3];\n\t}\n\tif(cnt[0]<0 || cnt[1]<0 || cnt[2]<0 || cnt[3]<0) return puts(""===""),0;\n\trep(i,0,n-1)\n\t{\n\t\tif(s[i]==\'?\')\n\t\t{\n\t\t\tif(cnt[0])\n\t\t\t{\n\t\t\t\t--cnt[0];\n\t\t\t\ts[i]=\'A\';\n\t\t\t}\n\t\t\telse if(cnt[1])\n\t\t\t{\n\t\t\t\t--cnt[1];\n\t\t\t\ts[i]=\'C\';\n\t\t\t}\n\t\t\telse if(cnt[2])\n\t\t\t{\n\t\t\t\t--cnt[2];\n\t\t\t\ts[i]=\'G\';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--cnt[3];\n\t\t\t\ts[i]=\'T\';\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%s\\n"",s);\n\treturn 0;\n}']",,,"['implementation', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Mammoth s Genome Decoding.json,https://codeforces.com//blog/entry/49171,Let is the length of the given string The number of each letter in the resulting string must be equals to If does not equal to 0 there is no solution If some letter meets in the given string more than times there is no solution After that we always can build the answer We need to iterate through the given string and change question symbols on any letter which meets in the current string less than times 
https://codeforces.com//contest/834/problem/B,116225,B,834B,834,B. The Festive Evening,It s the end of July the time when a festive evening is held at Jelly Castle Guests from all over the kingdom gather here to discuss new trends in the world of confectionery Yet some of the things discussed here are not supposed to be disclosed to the general public the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands So it s a necessity to not let any uninvited guests in There are 26 entrances in Jelly Castle enumerated with uppercase English letters from to Because of security measures each guest is known to be assigned an entrance he should enter the castle through The door of each entrance is opened right before the first guest s arrival and closed right after the arrival of the last guest that should enter the castle through this entrance No two guests can enter the castle simultaneously For an entrance to be protected from possible intrusion a candy guard should be assigned to it There are such guards in the castle so if there are more than opened doors one of them is going to be left unguarded Notice that a guard can t leave his post until the door he is assigned to is closed Slastyona had a suspicion that there could be uninvited guests at the evening She knows the order in which the invited guests entered the castle and wants you to help her check whether there was a moment when more than doors were opened ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n#define fir first\n#define sec second\n\nint n, k;\nchar a[1000006];\nint s[1000006];\nint L[128];\nint R[128];\n\nint main() {\n\tcin >> n >> k;\n\tscanf(""%s"", a);\n\t\n\tfor (int i = 0; i < 128; ++i) {\n\t\tL[i] = INT_MAX;\n\t\tR[i] = INT_MIN;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tL[a[i]] = min(L[a[i]], i);\n\t\tR[a[i]] = max(R[a[i]], i);\n\t}\n\t\n\tfor (int i = 0; i < 128; ++i) if (L[i] != INT_MAX)\n\t\tfor (int j = L[i]; j <= R[i]; ++j)\n\t\t\t++s[j];\n\t\n\tputs(*max_element(s, s + n) <= k ? ""NO"" : ""YES"");\n\t\n\treturn 0;\n}\n']",,,"['data structures', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. The Festive Evening.json,https://codeforces.com//blog/entry/53567,none This problem is solved with two linear sweeps In the first one we determine the last position for each letter In the second one we just model the process we mark the letter as active when we stumble upon it for the first time and as inactive when we reach the last position for this letter If there are more than letters active at some specific point of time we output Otherwise we output 
https://codeforces.com//contest/915/problem/C,146470,C,915C,915,C. Permute Digits,You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>haveInt;\nvector<int>need;\nvector<int>answer;\n\nvoid prnt() {\n\tfor (auto x : answer)cout << x;\n\texit(0);\n}\n\nvoid formAll() {\n\twhile (!haveInt.empty()) {\n\t\tmap<int, int>::iterator it = haveInt.end();\n\t\tit--;\n\t\tanswer.push_back(it->first);\n\t\tit->second -= 1;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t}\n\tprnt();\n}\n\nvoid tryNum(int a) {\n\tif (haveInt.size()==0)\n\t\tprnt();\n\tmap<int, int>::iterator it = haveInt.lower_bound(need[a]);\n\tif (it != haveInt.end() && it->first == need[a]) {\n\t\tint x = it->first;\n\t\tit->second--;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t\tanswer.push_back(x);\n\t\ttryNum(a + 1);\n\t\thaveInt[x]++;\n\t\tanswer.pop_back();\n\t}\n\tit = haveInt.lower_bound(need[a]);\n\tif (it == haveInt.begin())return;\n\tit--;\n\tanswer.push_back(it->first);\n\tit->second--;\n\tif (it->second == 0)\n\t\thaveInt.erase(it);\n\tformAll();\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tswap(s1, s2);\n\tfor (auto x : s2)\n\t\thaveInt[x - \'0\']++;\n\tif (s2.length() < s1.length())\n\t\tformAll();\n\tfor (auto x : s1)\n\t\tneed.push_back(x - \'0\');\n\ttryNum(0);\n\n\t\n\treturn 0;\n}']",,,"['dp', 'greedy']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Permute Digits.json,https://codeforces.com//blog/entry/57123,Let s construct the answer digit by digit starting from the leftmost Obviously we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step Precalc number of digits in number Iterate over all possible digits starting from the greatest For each digit check if it s possible to put it in this position For this you construct minimal suffix greedily put the lowest digit and compare the resulting number with number If it became less or equal then proceed to the next digit Overall complexity where is digits from to 
https://codeforces.com//contest/1477/problem/E,879399,E,1477E,1477,E. Nezzar and Tournaments,In the famous Oh Suit United tournament two teams are playing against each other for the grand prize of precious pepper points The first team consists of n players and the second team consists of m players Each player has a potential the potential of the i th player in the first team is a i and the potential of the i th player in the second team is b i In the tournament players will be on the stage in some order There will be a scoring device initially assigned to an integer k which will be used to value the performance of all players The scores for all players will be assigned in the order they appear on the stage Let the potential of the current player be x and the potential of the previous player be y Then x y is added to the value in the scoring device Afterwards if the value in the scoring device becomes negative Lastly the player s score is assigned to the current value on the scoring device The score of a team is the sum of the scores of all its members As an insane fan of the first team Nezzar desperately wants the biggest win for the first team He now wonders what is the maximum difference between scores of the first team and the second team Formally let the score of the first team be score f and the score of the second team be score s Nezzar wants to find the maximum value of score f score s over all possible orders of players on the stage However situation often changes and there are q events that will happen There are three types of events 1 pos x change a pos to x 2 pos x change b pos to x 3 x tournament is held with k x and Nezzar wants you to compute the maximum value of score f score s Can you help Nezzar to answer the queries of the third type ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\nstruct Waf{\n\tvi vs;\n\tBIT<int> bit,cnt;\n\tvoid prepare(){\n\t\tmkuni(vs);\n\t\tbit=BIT<int>(si(vs));\n\t\tcnt=BIT<int>(si(vs));\n\t}\n\tvoid insert(int v){\n\t\tint i=lwb(vs,v);\n\t\tbit.add(i,v);\n\t\tcnt.add(i,1);\n\t}\n\tvoid erase(int v){\n\t\tint i=lwb(vs,v);\n\t\tbit.add(i,-v);\n\t\tcnt.add(i,-1);\n\t}\n\tint query(int v){\n\t\tint i=lwb(vs,v);\n\t\tint val=bit.sum(i,si(vs));\n\t\tval-=cnt.sum(i,si(vs))*v;\n\t\treturn val;\n\t}\n};\n\nint getmin(const multiset<int>&s){\n\tassert(si(s));\n\treturn *s.bg;\n}\nint getmax(const multiset<int>&s){\n\tassert(si(s));\n\treturn *s.rbegin();\n}\nvoid del(multiset<int>&s,int val){\n\tauto itr=s.find(val);\n\tassert(itr!=s.ed);\n\ts.erase(itr);\n}\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\tvi a=readvi(n);\n\tvi b=readvi(m);\n\tint asum=accumulate(all(a),int(0));\n\tint bsum=accumulate(all(b),int(0));\n\tmultiset<int> as,bs,abvs;\n\tfor(auto v:a){\n\t\tas.insert(v);\n\t\tabvs.insert(v);\n\t}\n\tfor(auto v:b){\n\t\tbs.insert(v);\n\t\tabvs.insert(v);\n\t}\n\tWaf waf;\n\twaf.vs=b;\n\tstruct Query{\n\t\tint t,pos,x;\n\t\tvoid readinit(){\n\t\t\tcin>>t;\n\t\t\tif(t<=2){\n\t\t\t\tcin>>pos>>x;\n\t\t\t\tpos--;\n\t\t\t}else if(t==3){\n\t\t\t\tcin>>x;\n\t\t\t}else{\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t};\n\tvc<Query> qs(q);\n\trep(i,q){\n\t\tqs[i].readinit();\n\t\tif(qs[i].t==2)waf.vs.pb(qs[i].x);\n\t}\n\twaf.prepare();\n\tfor(auto v:b)waf.insert(v);\n\tfor(auto qq:qs){\n\t\tif(qq.t<=2){\n\t\t\tint pos=qq.pos,x=qq.x;\n\t\t\tif(qq.t==1){\n\t\t\t\tasum-=a[pos];\n\t\t\t\tdel(as,a[pos]);\n\t\t\t\tdel(abvs,a[pos]);\n\t\t\t\ta[pos]=x;\n\t\t\t\tasum+=a[pos];\n\t\t\t\tas.insert(a[pos]);\n\t\t\t\tabvs.insert(a[pos]);\n\t\t\t}else if(qq.t==2){\n\t\t\t\tbsum-=b[pos];\n\t\t\t\tdel(bs,b[pos]);\n\t\t\t\tdel(abvs,b[pos]);\n\t\t\t\twaf.erase(b[pos]);\n\t\t\t\tb[pos]=x;\n\t\t\t\tbsum+=b[pos];\n\t\t\t\tbs.insert(b[pos]);\n\t\t\t\tabvs.insert(b[pos]);\n\t\t\t\twaf.insert(b[pos]);\n\t\t\t}else assert(false);\n\t\t}else if(qq.t==3){\n\t\t\tint x=qq.x,ans=-inf;\n\t\t\tint tmp=getmin(abvs);\n\t\t\t{\n\t\t\t\tint top=getmax(bs);\n\t\t\t\t//dmp(waf.query(top-x));\n\t\t\t\tchmax(ans,asum-tmp*n-waf.query(top-x));\n\t\t\t\tauto upd=[&](int use){\n\t\t\t\t\tchmax(ans,asum-use-tmp*(n-1)-waf.query(use-x)+x);\n\t\t\t\t};\n\t\t\t\tauto itr=as.lower_bound(top+x);\n\t\t\t\tif(itr!=as.ed)upd(*itr);\n\t\t\t\tif(itr!=as.bg)upd(*prev(itr));\n\t\t\t}\n\t\t\t//dmp(ans);\n\t\t\t{\n\t\t\t\tconst auto upd=[&](int lv){\n\t\t\t\t\tchmax(ans,asum-lv*n-(bsum-lv*m));\n\t\t\t\t};\n\t\t\t\tupd(tmp-x);\n\t\t\t\tauto itr=abvs.upper_bound(tmp+x);\n\t\t\t\t--itr;\n\t\t\t\tupd(*itr-x);\n\t\t\t}\n\t\t\tprint(ans);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['data structures', 'greedy']",3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Nezzar and Tournaments.json,https://codeforces.com//blog/entry/87294,Let s firstly consider a simplified problem where the scoring device will not reset to For any player his score will be fully determined by his potential as well as the potential of first player when is fixed Indeed similar property still holds in our setting For any fixed arrangement of players with potentials where is the score of the th player If the first player is fixed it is optimal to place players in second team in descending order of potentials then place all players in ascending order of potentials Let be the difference where is selected as the first and others ordered optimally and for sequence similarly With some calculation we may get where is the minimum value among and and is a universal constant similarly for Suppose that we have an oracle of we are aiming to find out the maximum value of over sets of values It can be seen that maximum values can only be reached on inputs which can be found in time For better understanding you may refer to the following figure Therefore it only remains to calculate for any given input efficiently which can be decomposed to the following queries minimum value over for given All those can be done efficiently via segment tree 
https://codeforces.com//contest/757/problem/C,88530,C,757C,757,C. Felicity is Coming ,It s that time of the year Felicity is around the corner and you can see people celebrating all around the Himalayan region The Himalayan region has gyms The th gym has Pokemon in it There are distinct Pokemon types in the Himalayan region numbered from to There is a special evolution camp set up in the fest which claims to evolve any Pokemon The type of a Pokemon could change after evolving subject to the constraint that if two Pokemon have the same type before evolving they will have the same type after evolving Also if two Pokemon have different types before evolving they will have different types after evolving It is also possible that a Pokemon has the same type before and after evolving Formally an is a permutation of such that means that a Pokemon of type evolves into a Pokemon of type The gym leaders are intrigued by the special evolution camp and all of them plan to evolve their Pokemons The protocol of the mountain states that in each gym for every type of Pokemon the number of Pokemon of that type before evolving any Pokemon should be equal the number of Pokemon of that type after evolving all the Pokemons according to the evolution plan They now want to find out how many distinct exist which satisfy the protocol Two evolution plans and are distinct if they have at least one Pokemon type evolving into a different Pokemon type in the two plans i e there exists an such that Your task is to find how many distinct are possible such that if all Pokemon in all the gyms are evolved the number of Pokemon of each type in each of the gyms remains the same As the answer can be large output it modulo ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\nconst int N = 1234567;\n\nvector <int> a[N];\n\nint main() {\n  int n, m;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    while (foo--) {\n      int bar;\n      scanf(""%d"", &bar);\n      a[bar].push_back(i);\n    }\n  }\n  sort(a + 1, a + m + 1);\n  int ans = 1;\n  int t = 1;\n  for (int i = 2; i <= m; i++) {\n    if (a[i] == a[i - 1]) {\n      t++;\n      ans = (long long) ans * t % md;\n    } else {\n      t = 1;\n    }\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']",,,"['data structures', 'hashing', 'sortings', 'strings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Felicity is Coming .json,https://codeforces.com//blog/entry/49743,Main idea Divide pokemon types into equivalence classes based on their counts in each list Consider a valid evolution plan f Let c p g be the number of times Pokemon p appears in gym g If f p q then Now consider a group of Pokemon P such that all of them occur equal number of times in each gym i e for each Any permutation of this group would be a valid bijection Say we have groups s1 s2 s3 then the answer would be s1 s2 s3 mod 109 7 For implementing groups we can use vector vector int and for i th pokemon add the index of the gym to i th vector Now we need to find which of these vectors are equal If we have the sorted vector vector int we can find equal elements by iterating over it and comparing adjacent elements Consider the merge step of merge sort For a comparison between 2 vectors v1 and v2 we cover at least min v1 size v2 size elements Hence work is done at each level There are levels 
https://codeforces.com//contest/1796/problem/D,1802548,D,1796D,1796,D. Maximum Subarray,You are given an array a 1 a 2 dots a n consisting of n integers You are also given two integers k and x You have to perform the following operation exactly once add x to the elements on k positions and subtract x from all the others For example if a 2 1 2 3 k 1 x 2 and we have picked the first element then after the operation the array a 4 3 0 1 Let f a be the maximum possible sum of a subarray of a The subarray of a is a contiguous part of the array a i e the array a i a i 1 dots a j for some 1 le i le j le n An empty subarray should also be considered it has sum 0 Let the array a be the array a after applying the aforementioned operation Apply the operation in such a way that f a is the maximum possible and print the maximum possible value of f a ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nint n,a[2000005];\nint f[200005][22];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,k,x;\n\t\tcin >> n >> k >> x;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i];\n\t\tint ans=0;\n\t\tif(x>=0)\n\t\t{\n\t\t\tfor(int p=0;p<=n;p++)\n\t\t\tfor(int i=0;i<=k+1;i++) f[p][i]=-1e18;\n\t\t\tf[0][0]=0;\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<=k+1;j++)\n\t\t\t\t{\n\t\t\t\t\tf[i][min(j+1,k+1)]=max(f[i][min(j+1,k+1)],f[i-1][j]+a[i]-x);\n\t\t\t\t\tf[i][0]=max(f[i][0],0ll);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<=k+1;j++)\n\t\t\t\t{\n\t\t\t\t\tint cnt=min(j,k);\n\t\t\t\t\tans=max(ans,f[i][j]+cnt*x*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int l=1;l<=min(n,k+1);l++)\n\t\t\t{\n\t\t\t\tint nw=0,mx=0;\n\t\t\t\tfor(int r=l;r<=n;r++)\n\t\t\t\t{\n\t\t\t\t\tnw+=a[r]-x;\n\t\t\t\t\tif(nw<=0) nw=0;\n\t\t\t\t\tmx=max(mx,nw);\n\t\t\t\t\tint len=r-l+1;\n\t\t\t\t\tif(len>n-k) ans=max(ans,mx+2*x*(k-n+len));\n\t\t\t\t\telse ans=max(ans,mx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}\n/*\n1\n2 2 3\n-1 2\n*/']",,,"['data structures', 'dp', 'greedy', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Maximum Subarray.json,https://codeforces.com//blog/entry/113408,There are greedy and dynamic programming solutions We will describe dynamic programming solution The main task is to choose some segment that is the answer to the problem while choosing positions to increase by To do this we can use dynamic programming where is the number of positions that have already been considered from to is the number of elements that have already been increased by from to is the flag showing the current state whether we are before the chosen segment inside the segment or after the segment Transitions in such dynamic programming are quite simple we have a choice either to increase by then the value of the th element is or not to increase then the value of the th element is we can also change the state of the flag note that you can only switch from the current state to the subsequent ones i e for example you cannot switch from the state the segment has already ended to the state inside the segment If the current state of the flag is inside the segment then or depending on the selected transition should be added to the dynamic programming value itself So we got a solution in 
https://codeforces.com//contest/1709/problem/B,1473245,B,1709B,1709,B. Also Try Minecraft,You are beta testing the new secret Terraria update This update will add quests to the game Simply the world map can be represented as an array of length n where the i th column of the world has height a i There are m quests you have to test The j th of them is represented by two integers s j and t j In this quest you have to go from the column s j to the column t j At the start of the quest you are appearing at the column s j In one move you can go from the column x to the column x 1 or to the column x 1 In this version you have Spectre Boots which allow you to fly Since it is a beta version they are bugged so they only allow you to fly when you are going up and have infinite fly duration When you are moving from the column with the height p to the column with the height q then you get some amount of fall damage If the height p is greater than the height q you get p q fall damage otherwise you fly up and get 0 damage For each of the given quests determine the minimum amount of fall damage you can get during this quest ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 100100;\nint n;\nll a[N];\nll pref[N], suf[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tpref[0] = 0;\n\tfor (int i = 1; i < n; i++)\n\t\tpref[i] = pref[i - 1] + max(0LL, a[i - 1] - a[i]);\n\tsuf[n - 1] = 0;\n\tfor (int i = n - 2; i >= 0; i--)\n\t\tsuf[i] = suf[i + 1] + max(0LL, a[i + 1] - a[i]);\n\twhile(q--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tif (v <= u) {\n\t\t\tprintf(""%lld\\n"", pref[u] - pref[v]);\n\t\t} else {\n\t\t\tprintf(""%lld\\n"", suf[u] - suf[v]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Also Try Minecraft.json,https://codeforces.com//blog/entry/105164,So the first idea that is coming into mind is prefix sums Let s define two values and The value means the amount of fall damage when we are going to the right from the column to the column and means the amount of fall damage when we are going to the left from the column to the column Then let s build prefix sums on these two arrays Now let be the sum of all on a prefix i e and be the sum of all on a prefix Then if in a query the answer is otherwise if the answer is Time complexity 
https://codeforces.com//contest/285/problem/D,2758,D,285D,285,D. Permutation Sum,Petya decided to introduce the sum operation on the set of permutations of length Let s assume that we are given two permutations of length and Petya calls the sum of permutations and such permutation of length where Operation means taking the remainder after dividing number by number Obviously not for all permutations and exists permutation that is sum of and That s why Petya got sad and asked you to do the following given count the number of such pairs of permutations and of length that exists permutation that is sum of and The pair of permutations and the pair of permutations are considered distinct pairs As the answer can be rather large print the remainder after dividing it by ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nconst ll mod=1000000007LL;\nll a[]={1, 3, 15, 133, 2025, 37851, 1030367, 36362925};\nint n;\nint main()\n{\n    int i,j,k;\n    cin>>n;\n    if (n%2==0)\n    {\n        puts(""0"");\n        return 0;\n    }\n    int p=(n+1)/2-1;\n    ll x=a[p];\n    for (i=1;i<=n;i++)\n    {\n        x*=(ll)i;\n        x%=mod;\n    }\n    cout<<x<<endl;\n    return 0;\n}']",,,"['bitmasks', 'combinatorics', 'dp', 'implementation', 'meet-in-the-middle']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Permutation Sum.json,https://codeforces.com//blog/entry/7093,For a start describe bruteforce solution Firstly we will always assume that is identity permutation that is In this case the answer should be multiplied by Or in other way your bruteforce will not be counted Secondly using our bruteforce we can see that for even the answer is What do you also need to get accepted First case is to calculate answers for all on your computer and write them in constant array In other words you can make precalc Second case is to make you solution faster The soltuion using meet in the middle idea works fast for If you remember that for even answer is then you can get accepted using such solution But other simple bruteforces and dynamic programmings on maps work slower than seconds 
https://codeforces.com//contest/1761/problem/F1,1651706,F1,1761F1,1761,F1. Anti-median  Easy Version ,Let s call an array a of odd length 2m 1 with m ge 1 if element a m 1 is equal to the median of this array In other words the array is bad if after sorting it the element at m 1 st position remains the same Let s call a permutation p of integers from 1 to n if every its subarray of odd length ge 3 is not bad You are already given values of some elements of the permutation Find the number of ways to set unknown values to obtain an permutation As this number can be very large find it modulo 10 9 7 ,"['/**\n *    author:  tourist\n *    created: 20.11.2022 19:36:59       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      if (a[i] > 0) {\n        --a[i];\n      }\n    }\n    vector<int> order;\n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        order.push_back(i);\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      if (i % 2 == 1) {\n        order.push_back(i);\n      }\n    }\n    vector<vector<bool>> is_seg(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n      int mn = n;\n      int mx = -1;\n      for (int k = 0; k < n; k++) {\n        int j = (i + k) % n;\n        mn = min(mn, order[j]);\n        mx = max(mx, order[j]);\n        if (mx - mn == k && (mn == 0 || mx == n - 1)) {\n          is_seg[i][j] = true;\n        }\n      }\n    }\n    vector<vector<Mint>> dp(n, vector<Mint>(n));\n    for (int i = 0; i < n; i++) {\n      if (a[order[i]] == 0 || a[order[i]] == -1) {\n        dp[i][i] = 1;\n      }\n    }\n    Mint ans = 0;\n    for (int len = 1; len <= n - 1; len++) {\n      for (int i = 0; i < n; i++) {\n        int j = (i + len - 1) % n;\n        if (len == n - 1) {\n          int lst = (j + 1) % n;\n          if (a[order[lst]] == len || a[order[lst]] == -1) {\n            ans += dp[i][j];\n          }\n          continue;\n        }\n        int pi = (i + n - 1) % n;\n        if (a[order[pi]] == len || a[order[pi]] == -1) {\n//          if (order[i] + order[pi] == 2 * order[j]) {\n//          debug(i, j, pi, j, ""check"");\n          if (!is_seg[i][j] || !is_seg[pi][j]) {\n//            debug(i, j, pi, j);\n            dp[pi][j] += dp[i][j];\n          }\n        }\n        int pj = (j + 1) % n;\n        if (a[order[pj]] == len || a[order[pj]] == -1) {\n//          if (order[j] + order[pj] == 2 * order[i]) {\n//          debug(i, j, i, pj, ""check"");\n          if (!is_seg[i][j] || !is_seg[i][pj]) {\n//            debug(i, j, i, pj);\n            dp[i][pj] += dp[i][j];\n          }\n        }\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['dp', 'math']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F1. Anti-median  Easy Version .json,https://codeforces.com//blog/entry/109256,Let s analyze the structure of anti median permutations First if for any holds or then segment is bad So the signs between adjacent elements are alternating So consider two cases all elements on even positions are local maximums and on odd local minimums and vice versa Let s find the answer for the first case for the second you can find the answer similarly Consider a segment of length Consider the case when is even first Then For to not be median it has to be larger than one of So when we consider only even elements each element except the first and last one has at least one adjacent element smaller than it It s easy to see that this implies that elements at even positions are first increasing and then decreasing Similarly we can see that elements at odd positions are first decreasing then increasing It s not hard to see that these conditions are sufficient Indeed suppose that All elements on even positions are local maximums and all elements on odd positions are local minimums Elements at even positions are first increasing and then decreasing Elements at odd positions are first decreasing then increasing Then consider any segment of odd length Denote it by and wlog is local maximum If we look at local maximums at least one of the following two conditions has to hold all local maximums to the right of are smaller than it or all local maximums to the left of are smaller than it Wlog first case Then all elements to the right of are smaller than it and is also smaller than it so can t be a median Now let s put all elements on the circle in the following order first all even elements from left to right then all odd elements from right to left In this circle the elements on both paths between and are decreasing It follows that for any numbers from to form a segment in this cyclic arrangement Then we can write a of the form how many ways are there to arrange the largest elements so that they end up in the positions from th to th in this cyclic arrangement All the transitions and checks are done in and there are states so we are done 
https://codeforces.com//contest/1166/problem/F,345557,F,1166F,1166,F. Vicky s Delivery Service,In a magical land there are n cities conveniently numbered 1 2 dots n Some pairs of these cities are connected by magical colored roads Magic is unstable so at any time new roads may appear between two cities Vicky the witch has been tasked with performing deliveries between some pairs of cities However Vicky is a beginner so she can only complete a delivery if she can move from her starting city to her destination city through a A double rainbow is a sequence of cities c 1 c 2 dots c k satisfying the following properties For each i with 1 le i le k 1 the cities c i and c i 1 are connected by a road For each i with 1 le i le frac k 1 2 the roads connecting c 2i with c 2i 1 and c 2i 1 have the same color For example if k 5 the road between c 1 and c 2 must be the same color as the road between c 2 and c 3 and the road between c 3 and c 4 must be the same color as the road between c 4 and c 5 Vicky has a list of events in chronological order where each event is either a delivery she must perform or appearance of a new road Help her determine which of her deliveries she will be able to complete ,"['#pragma GCC optimize(""Ofast"")\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl \'\\n\'\n\nint n, m, c, q; vector<int> DSUpar, DSUsize;\nvector<map<int, int>> adj;\nvector<set<int>> neighbors;\n\nint DSUfind(int x) {\n\twhile (DSUpar[x] != -1) x = DSUpar[x];\n\treturn x;\n}\n\nvoid DSUmerge(int x, int y) {\n\tx = DSUfind(x); y = DSUfind(y);\n\tif (x == y) return;\n\tif (DSUsize[x] < DSUsize[y]) swap(x, y);\n\tDSUsize[x] += DSUsize[y]; DSUpar[y] = x;\n\tfor (auto it=neighbors[y].begin(); it!=neighbors[y].end(); it++) {\n\t\tneighbors[x].insert(*it);\n\t}\n}\n\nvoid Input() {\n\tcin >> n >> m >> c >> q; adj.resize(n); neighbors.resize(n);\n\tDSUpar.resize(n, -1); DSUsize.resize(n, +1);\n\twhile (m--) {\n\t\tint x, y, z; cin >> x >> y >> z; x--; y--;\n\t\tneighbors[DSUfind(x)].insert(y); neighbors[DSUfind(y)].insert(x);\n\t\tif (adj[x].find(z) != adj[x].end()) DSUmerge(y, adj[x][z]); else adj[x][z] = y;\n\t\tif (adj[y].find(z) != adj[y].end()) DSUmerge(x, adj[y][z]); else adj[y][z] = x;\n\t}\n}\n\nvoid Solve() {\n\twhile (q--) {\n\t\tchar cmd; int x, y; cin >> cmd >> x >> y; x--; y--;\n\t\tif (cmd == \'+\') {\n\t\t\tint z; cin >> z;\n\t\t\tneighbors[DSUfind(x)].insert(y); neighbors[DSUfind(y)].insert(x);\n\t\t\tif (adj[x].find(z) != adj[x].end()) DSUmerge(y, adj[x][z]); else adj[x][z] = y;\n\t\t\tif (adj[y].find(z) != adj[y].end()) DSUmerge(x, adj[y][z]); else adj[y][z] = x;\n\t\t}\n\t\telse if (cmd == \'?\') {\n\t\t\tif (DSUfind(x) == DSUfind(y)) cout << ""Yes\\n"";\n\t\t\telse if (neighbors[DSUfind(x)].find(y) != neighbors[DSUfind(x)].end()) cout << ""Yes\\n"";\n\t\t\telse cout << ""No\\n"";\n\t\t}\n\t}\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}']",,,"['data structures', 'dsu', 'graphs', 'hashing']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Vicky s Delivery Service.json,https://codeforces.com//blog/entry/67081,Let be the graph with cities as vertices and roads as edges Note that the edges originally in can be regarded as queries of the add edge type so we will just describe a solution that can handle queries of any type We need a way to capture the idea of going through two roads of the same color in a row To do this consider a graph with the same vertices as in which vertices and are connected by an edge if and are edges of the same color for some vertex Then any path in this graph corresponds to a double rainbow in the original However this doesn t solve the problem yet because of the condition that the final edge of a double rainbow can be of any color To help in solving this issue consider sets such that has all of the connected components of both and any neighbor of Then we can see that we have a double rainbow from to if and only if the connected component of is in either we reach directly or we reach one of its neighbors and then use our final edge to go to So as long as we can mantain these sets we have a time way to answer queries of the second type Now we need to deal with adding edges To do this we will store the connectivity of using a DSU When we connect two connected components in we do the merges from small to large If we merge component into component then for each vertex in component and every neighbor of we remove from and insert instead By merging from small to large we guarantee that each vertex changes component at most times and thus we also update through the edge at most times Each update is just two operations so over all updates this amortizes to because we have edges plus for actually moving the vertices There s an easy to fix but important note which is that the number of edges in can be quadratically large However we can check that for each edge of color that we add we only need to add two edges to Namely if and are neighbors of and respectively through an edge of color then it is enough to add edges and If one of or doesn t exist then we just don t add the corresponding edge We can store these colored neighbors of each vertex in sets which have total size at most so we can find in which updates we need to perform and we perform a constant number of updates per added edge Complexity or using hash tables 
https://codeforces.com//contest/1609/problem/G,1205815,G,1609G,1609,G. A Stroll Around the Matrix,William has two arrays of numbers a 1 a 2 dots a n and b 1 b 2 dots b m The arrays satisfy the conditions of being convex Formally an array c of length k is considered convex if c i c i 1 c i 1 c i for all i from 2 to k 1 and c 1 c 2 Throughout William s life he observed q changes of two types happening to the arrays Add the arithmetic progression d d cdot 2 d cdot 3 dots d cdot k to the suffix of the array a of length k The array after the change looks like this a 1 a 2 dots a n k a n k 1 d a n k 2 d cdot 2 dots a n d cdot k The same operation but for array b After each change a matrix d is created from arrays a and b of size n times m where d i j a i b j William wants to get from cell 1 1 to cell n m of this matrix From cell x y he can only move to cells x 1 y and x y 1 The length of a path is calculated as the sum of numbers in cells visited by William including the first and the last cells After each change William wants you to help find out the minimal length of the path he could take ,"['/**\n *    author:  tourist\n *    created: 28.11.2021 18:24:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  auto init_b = b;\n  vector<long long> da(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    da[i] = a[i + 1] - a[i];\n  }\n  vector<long long> db(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    db[i] = b[i + 1] - b[i];\n  }\n  fenwick<int> fenw(m - 1);\n  fenwick<long long> fenw2(m - 1);\n  long long ans = 0;\n  for (int i = 0; i < m - 1; i++) {\n    ans += db[i] * (m - 1 - i);\n  }\n  while (q--) {\n    int type, k, d;\n    cin >> type >> k >> d;\n    if (type == 1) {\n      if (k == n) {\n        a[0] += d;\n        k -= 1;\n      }\n      for (int i = 0; i < k; i++) {\n        a[n - k + i] += d * (i + 1);\n        da[n - k + i - 1] += d;\n      }\n    } else {\n      if (k == m) {\n        b[0] += d;\n        k -= 1;\n      }\n      fenw.modify(m - k - 1, d);\n      fenw2.modify(m - k - 1, ((long long) -d) * (m - k - 2));\n      ans += ((long long) d) * k * (k + 1LL) / 2;\n    }\n    long long res = ans;\n    res += (a[0] + b[0]) * (n + m - 1);\n    for (int i = 0; i < n - 1; i++) {\n      int low = 0, high = m - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        if (db[mid] + fenw.get(mid) > da[i]) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      int my_id = (n - 2 - i) + (m - 1 - low) + 1;\n      res += da[i] * my_id;\n      res += init_b[low] - init_b[0];\n      res += fenw.get(low - 1) * (long long) (low - 1) + fenw2.get(low - 1);\n    }\n    cout << res << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['data structures', 'greedy', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. A Stroll Around the Matrix.json,https://codeforces.com//blog/entry/97350,First of all it should be noted that one iteration of the described algorithm of robots movements can be implemented in time For example using stack Let s consider moments of time that are multiple of And segments of time between such two consecutive moments of time Consider two adjacent robots It can be proved that if these two robots touched each other during a segment of time then they will touch each other during any succeeding segment of time One thing that may change in the future is that the left robot will be blocked from moving to the left or the right robot will be blocked from moving to the right Robots just will become closer to each other after such a change It s also possible that the left robot will be blocked from moving to the right or the right robot from moving to the left But then they are touching Similarly if after seconds distance between two robots decreases then it will continue decreasing until they touch during some segment of time And if two robots touch during a segment of time then the distance between them after this segment of time will be less than or equal to the distance between them before this segment Let s simulate the first seconds and then another seconds Let s look at pairs of adjacent robots If the distance between two robots increased or didn t change skip this pair If the distance between two robots decreased If the distance is then robots may touch during the next segment So let s simulate the next seconds again Otherwise let distance be and it decreased by during the last segment of time Then during the next segments of time it will continue decreasing with the same speed units per seconds So we can skip these segments of time and simulate the next after them Let s choose the minimum segment of time that should be simulated Let s skip all till this segment of time and simulate it Then again choose the minimum segment of time till which we can skip simulation It can be proved that there will be simulated segments of time overall This is due to the fact that there re no more than decreases of the distance between two adjacent robots after which we will do the simulation In order to answer questions let s also simulate segments of time that contain moments of time of questions Total time complexity is 
https://codeforces.com//contest/1555/problem/A,1062140,A,1555A,1555,A. PizzaForces,PizzaForces is Petya s favorite pizzeria PizzaForces makes and sells pizzas of three sizes small pizzas consist of 6 slices medium ones consist of 8 slices and large pizzas consist of 10 slices each Baking them takes 15 20 and 25 minutes respectively Petya s birthday is today and n of his friends will come so he decided to make an order from his favorite pizzeria Petya wants to order so much pizza that each of his friends gets at least one slice of pizza The cooking time of the order is the total baking time of all the pizzas in the order Your task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total For example if 12 friends come to Petya s birthday he has to order pizzas containing at least 12 slices in total He can order two small pizzas containing exactly 12 slices and the time to bake them is 30 minutes if 15 friends come to Petya s birthday he has to order pizzas containing at least 15 slices in total He can order a small pizza and a large pizza containing 16 slices and the time to bake them is 40 minutes if 300 friends come to Petya s birthday he has to order pizzas containing at least 300 slices in total He can order 15 small pizzas 10 medium pizzas and 13 large pizzas in total they contain 15 cdot 6 10 cdot 8 13 cdot 10 300 slices and the total time to bake them is 15 cdot 15 10 cdot 20 13 cdot 25 750 minutes if only one friend comes to Petya s birthday he can order a small pizza and the time to bake it is 15 minutes ,['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    long long n;\n    cin >> n;\n    n = (n + 1) / 2;\n    if (n <= 2){\n      cout << 15 << endl;\n    } else {\n      cout << n * 5 << endl;\n    }\n  }\n}'],,,"['brute force', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. PizzaForces.json,https://codeforces.com//blog/entry/93389,Note that the speed of cooking slice of pizza is the same for all sizes slice of pizza for minutes If is odd then we will increase it by since the pizza is cooked only with an even number of pieces Now the value of is always even If then for such the answer is equal to the answer for so we can say that While we can order a small pizza Eventually the value of will be equal to or This means that for any there will be a set of pizzas with exactly slices Then the answer is in the solution it is better to use the formula 
https://codeforces.com//contest/1358/problem/C,630277,C,1358C,1358,C. Celex Update,During the quarantine Sicromoft has more free time to create the new functions in The developers made a new function which infinitely fills an infinite table to the right and down from the upper left corner as follows The cell with coordinates x y is at the intersection of x th row and y th column Upper left cell 1 1 contains an integer 1 The developers of the function don t sleep either Because of the boredom they teamed up with the developers of the function so they added the ability to calculate the sum on an arbitrary path from one cell to another moving down or right Formally from the cell x y in one step you can move to the cell x 1 y or x y 1 After another Dinwows update Levian started to study because he wants to be an accountant After filling in the table with the function he asked you to calculate the quantity of possible different amounts on the path from a given cell x 1 y 1 to another given cell x 2 y 2 if you can only move one cell down or right Formally consider all the paths from the cell x 1 y 1 to cell x 2 y 2 such that each next cell in the path is located either to the down or to the right of the previous one Calculate the number of different sums of elements for all such paths ,"['// Author : PinkRabbit\n#include<bits/stdc++.h>\nusing namespace std;\n#define F(i,a,b) for(int i=a;i<=(b);++i)\n#define F2(i,a,b) for(int i=a;i<(b);++i)\n#define dF(i,a,b) for(int i=a;i>=(b);--i)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define Debug debug(""Passing [%s] in LINE %d\\n"",__FUNCTION__,__LINE__)\n#define MN 300005\n#define MM 600005\n#define ll long long\n#define mod 998244353\n#define inf 0x3f3f3f3f\n#define infll 0x3f3f3f3f3f3f3f3f\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mkp make_pair\n#define fi first\n#define se second\ninline int qpow(int b,ll e,int m=mod){int a=1;for(;e;e>>=1,b=(ll)b*b%m)if(e&1)a=(ll)a*b%m;return a;}\nint n,m,q,k;\nint a[MN],b[MN],f[MN],g[MN];\nvector<int>G[MN];\nint h[MN],nxt[MM],to[MM],tot;\ninline void ins(int x,int y){nxt[++tot]=h[x];to[tot]=y;h[x]=tot;}\nint main(){int tests=1;scanf(""%d"",&tests);\nwhile(tests--){\n\tint a,b,c,d,x,y;\n\tscanf(""%d%d%d%d"",&a,&b,&c,&d);\n\tx=c-a,y=d-b;\n\tprintf(""%lld\\n"",(ll)x*y+1);\n}\treturn 0;\n}\n']",,,['math'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Celex Update.json,https://codeforces.com//blog/entry/77869,Let s look at the way with the minimum sum first we go steps right and then steps down Let s look at such a change in the bends of the way After each step the sum on the way will increase by We re going to bend like this until we get to the maximum sum We re not going to miss any possible sum because we re incrementing the sum by 1 We started with the minimum sum and finished with the maximum sum so we can use these changes to get all possible sums In order for us to come from the minimum to the maximum way we must bend the way exactly 1 time per each cell of table except for the cells of the minimum way That is the number of changes equals the number of cells not belonging to the minimum way Then the number of different sums will be The overall compexity is per test 
https://codeforces.com//contest/1183/problem/F,363546,F,1183F,1183,F. Topforces Strikes Back,One important contest will take place on the most famous programming platform Topforces very soon The authors have a pool of n problems and should choose of them into this contest The prettiness of the i th problem is a i The authors have to compose the most pretty contest in other words the cumulative prettinesses of chosen problems should be But there is one important thing in the contest preparation because of some superstitions of authors the prettinesses of problems cannot divide each other In other words if the prettinesses of chosen problems are x y z then x should be divisible by neither y nor z y should be divisible by neither x nor z and z should be divisible by neither x nor y If the prettinesses of chosen problems are x and y then neither x should be divisible by y nor y should be divisible by x Any contest composed from one problem is considered good Your task is to find out the maximum possible total prettiness of the contest composed of problems from the given pool You have to answer q independent queries ,"['#include<bits/stdc++.h>\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nll t,te,n,N,has,a[202020],b[202020],i,ta,X[99];\nvoid cek(ll aa,ll bb,ll cc)\n{\n\tif(cc==0)return ;\n\thas=max(has,aa);\n\tif(cc==1)return ;\n\tX[cc]=a[bb];\n\tll ii,jj;\n\tfor(ii=bb-1;ii>=1;ii--)\n\t{\n\t\tll gagal=0;\n\t\tfor(jj=cc;jj<=3;jj++)\n\t\t{\n\t\t//\tcout<<ii<<"" ""<<jj<<"" ""<<X[jj]<<"" ""<<a[ii]<<""\\n"";\n\t\t\tif(X[jj]%a[ii]==0)\n\t\t\t\tgagal=1;\n\t\t}\n\t\tif(!gagal)\n\t\t{\n\t\t\tcek(aa+a[ii],ii,cc-1);\n\t\t\treturn ;\n\t\t}\n\t}\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tte++;\n\t\tcin>>n;\n\t\tN=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>ta;\n\t\t\tif(b[ta]!=te)\n\t\t\t\ta[++N]=ta;\n\t\t\tb[ta]=te;\n\t\t}\n\t\tsort(a+1,a+1+N);\n\t\thas=0;\n\t\tcek(a[N],N,3);\n\t\tif(N>1)\n\t\t\tcek(a[N-1],N-1,3);\n\t\tcout<<has<<""\\n"";\n\t}\n}']",,,"['brute force', 'math', 'sortings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Topforces Strikes Back.json,https://codeforces.com//blog/entry/68003,I know about some solutions that are trying to iterate over almost all possible triples but I have a better and more interesting one Possibly it was already mentioned in comments but I need to explain it Let s solve the problem greedily Let s sort the initial array The first number we would like to choose is the maximum element Then we need to pop out some maximum elements that are divisors of the maximum Then there are two cases the array becomes empty or we have some maximum number that does not divide the chosen number Let s take it and repeat the same procedure again but now we have to find the number that does not divide neither the first taken number nor the second taken number So we have at most three numbers after this procedure Let s update the answer with their sum This solution is almost correct Almost What have we forgotten Let s imagine that the maximum element is divisible by and and there are three following numbers in the array maximum divided by by and by Then their sum is greater than the maximum and may be greater than the answer we have because So if these conditions are satisfied let s update the answer with the sum of these three numbers It can be shown that this is the only possible triple that can break our solution The triple does not match because the maximum divided by divides the maximum divided by The triple is bad for the same reason And the triple has sum less than the maximum element 
https://codeforces.com//contest/678/problem/C,62341,C,678C,678,C. Joty and Chocolate,Little Joty has got a task to do She has a line of tiles indexed from to She has to paint them in a strange pattern An unpainted tile should be painted Red if it s index is divisible by and an unpainted tile should be painted Blue if it s index is divisible by So the tile with the number divisible by and can be either painted Red or Blue After her painting is done she will get chocolates for each tile that is painted Red and chocolates for each tile that is painted Blue Note that she can paint tiles in any order she wants Given the required information find the maximum number of chocolates Joty can get ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint main() {\n    LL n , a , b , p , q;\n    cin >> n >> a >> b >> p >> q;\n    LL A = n / a , B = n / b , c = a / __gcd(a , b) * b;\n    LL C = n / c;\n    A -= C , B -= C;\n    cout << A * p + B * q + max(p , q) * C << endl;\n}\n']",,,"['implementation', 'math', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Joty and Chocolate.json,https://codeforces.com//blog/entry/45405,The problem was suggested by Sheikh Monir skmonir Easy to see that we can paint with both colours only tiles with the numbers multiple of Obviously that tiles should be painted with more expensive colour So the answer equals to C solution 
https://codeforces.com//contest/1678/problem/A,1392737,A,1678A,1678,A. Tokitsukaze and All Zero Sequence,Tokitsukaze has a sequence a of length n For each operation she selects two numbers a i and a j i ne j 1 leq i j leq n If a i a j change one of them to 0 Otherwise change both of them to min a i a j Tokitsukaze wants to know the minimum number of operations to change all numbers in the sequence to 0 It can be proved that the answer always exists ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int N=111;\nLL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\')x=x*10ll+ch-\'0\',ch=getchar();\n\treturn x*f;\n}\nint n,c[N];\nvoid solve()\n{\n\tn=read();\n\tmemset(c,0,sizeof(c));\n\tfor(int i=1;i<=n;i++)c[read()]++;\n\tint ans=0,p=-1;\n\tfor(int i=0;i<=100;i++)\n\tif(c[i]>1)\n\t{\n\t\tp=i;\n\t\tbreak;\n\t}\n\tif(c[0])printf(""%d\\n"",n-c[0]);\n\telse if(p!=-1)printf(""%d\\n"",n);\n\telse printf(""%d\\n"",n+1);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)solve();\n \treturn 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Tokitsukaze and All Zero Sequence.json,https://codeforces.com//blog/entry/102631,TutorialWe observe that when there is in the sequence it is optimal to choose and any number other than for each operation Therefore when there is in the sequence let be the number of s the answer is Otherwise when does not exist in the sequence there are two situations When there exist two equal numbers in the sequence we can perform the operation time to convert it into the situation of having in the sequence So the answer must be When all numbers in the sequence are distinct we can perform the operation times to convert it into the situation of having in the sequence So the answer must be 
https://codeforces.com//contest/2009/problem/G1,2852157,G1,2009G1,2009,G1. Yunli s Subarray Queries  easy version ,For an arbitrary array b Yunli can perform the following operation any number of times Select an index i Set b i x where x is any integer she desires x is not limited to the interval 1 n Denote f b as the minimum number of operations she needs to perform until there exists a consecutive subarray text of length at least k in b Yunli is given an array a of size n and asks you q queries In each query you must output sum j l k 1 r f a l a l 1 ldots a j Note that in this version you are only required to output f a l a l 1 ldots a l k 1 text If there exists a consecutive subarray of length k that starts at index i 1 leq i leq b k 1 then b j b j 1 1 for all i j leq i k 1 ,"['#include<bits/stdc++.h>using namespace std;using ll=long long;using i128=__int128;using ull=unsigned long long;using ld=long double;using pii=pair<int,int>;using pll=pair<ll,ll>;clock_t a;const int M=998244353;const ll inf=1e17;const ld eps=1e-10;void oT(char c=\'.\'){cout<<c<<""Time:""<<double(clock()-a)<<\'\\n\';}struct Solution{\t\tint n,k,q;vector<int>a,cnt,res;\tpriority_queue<pii>Q;\tvoid Init()\t{\t\tcin>>n>>k>>q;a.resize(n+1,0);cnt=res=a;map<int,int>mp;\t\tfor(int i=1;i<=n;i++)cin>>a[i],a[i]-=i,mp[a[i]]=1;\t\t//for(int i=1;i<=n;i++)cout<<a[i]<<"".\\n""[i==n];\t\tint cc=0;for(auto&k:mp)k.second=++cc;\t\tfor(int i=1;i<=n;i++)a[i]=mp[a[i]];\t\t//reverse(a.begin()+1,a.end());\t\t//for(int i=1;i<=n;i++)cout<<a[i]<<"".\\n""[i==n];\t}\tvoid Solve()\t{\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tint x=a[i];cnt[x]++;Q.push({cnt[x],x});\t\t\tif(i>=k)\t\t\t{\t\t\t\tint y=a[i-k];cnt[y]--;Q.push({cnt[y],y});\t\t\t}\t\t\twhile(1)\t\t\t{\t\t\t\tauto [c,id]=Q.top();if(cnt[id]^c){Q.pop();continue;}\t\t\t\tbreak;\t\t\t}\t\t\tauto [c,id]=Q.top();res[i]=k-c;\t\t}\t\tfor(int i=1,l,r;i<=q;i++)\t\t{\t\t\tcin>>l>>r;cout<<res[r]<<""\\n"";\t\t}\t}};void precal(){}signed main() {    ios::sync_with_stdio(0);cin.tie(0);precal();    int t=1;cin>>t;while(t--){Solution sol;sol.Init();sol.Solve();}}']",,,"['binary search', 'data structures', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\G1. Yunli s Subarray Queries  easy version .json,https://codeforces.com//blog/entry/133296,Problem Credits cry Proof by QED Analysis Proof by QED Solution We first make the sequence for all Now if then and are in correct relative order Now to solve the problem we precompute the answer for every window of and then each query is a lookup We use a sliding window maintaining a multiset of frequencies of values of in the current window To move from the window to we lower the frequency of by and increase the frequency of by 
https://codeforces.com//contest/1551/problem/E,1055225,E,1551E,1551,E. Fixed Points,Consider a sequence of integers a 1 a 2 ldots a n In one move you can select any element of the sequence and delete it After an element is deleted all elements to the right are shifted to the left by 1 position so there are no empty spaces in the sequence So after you make a move the sequence s length decreases by 1 The indices of the elements after the move are recalculated E g let the sequence be a 3 2 2 1 5 Let s select the element a 3 2 in a move Then after the move the sequence will be equal to a 3 2 1 5 so the 3 rd element of the new sequence will be a 3 1 and the 4 th element will be a 4 5 You are given a sequence a 1 a 2 ldots a n and a number k You need to find the minimum number of moves you have to make so that in the resulting sequence there will be k elements that are equal to their indices i e the resulting sequence b 1 b 2 ldots b m will contain at least k indices i such that b i i ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    vector<int> a(n+1);\n    for(int i=1;i<=n;++i)\n        cin >> a[i];\n    vector<vector<ll>> dp(n+10,vector<ll>(n+10,0));\n    dp[0][0] = 0;\n    for(int i=0;i<n;++i)\n    {\n        for(int j=0;j<=i;++j)\n        {\n            amax(dp[i+1][j],dp[i][j]);\n            if(a[i+1] == j + 1)\n                amax(dp[i+1][j+1],dp[i][j] + 1);\n            else\n                amax(dp[i+1][j+1],dp[i][j]);\n        }\n    }\n    int ans = -1;\n    for(int i=1;i<=n;++i)\n    {\n        if(dp[n][i] >= k)\n            amax(ans,i);\n    }\n    if(ans == -1)\n        cout << ans << ""\\n"";\n    else\n        cout << n - ans << ""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']",,,"['binary search', 'brute force', 'dp']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Fixed Points.json,https://codeforces.com//blog/entry/93149,Let s use the concept of dynamic programming Let s create an array indexed with size of will contain the maximal number of the elements equal to their indices if we have considered the first elements of the sequence and have elements Let s fill the array with zeroes then we will increase the elements of the array for different and Let s start the loop with parameter from to and the internal one with parameter from to Consider an element We can delete or not delete it If we delete this element the number of the elements equal to their indices will not be increased and the number of the non deleted element will not be increased too It means that the answer for may be updated with Since we are interested in a maximum answer we rewrite only if is greater than Suppose we don t delete this element We haven t deleted previously elements so will have the index and there will be non deleted elements if we consider elements so we must update If i e an element equal to its index is found let s update with Otherwise we should update it with Remember that update may be done only if we rewrite the less value with the greater value Let s build the answer as follows We need to minimize the number of deleted elements maximize the number of non deleted elements so that the number of the elements equal to their indices is at least Consider only the elements of having the first index Let s start a loop in the descending order of If is the maximum number of elements that we will not delete so the answer is If we will not find such that there s no desired sequence of moves so the answer is The algorithm works in 
https://codeforces.com//contest/573/problem/E,34314,E,573E,573,E. Bear and Bowling,Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for th roll is multiplied by and scores are summed up So for rolls with scores total score is Total score is if there were no rolls Limak made rolls and got score for th of them He wants to maximize his total score and he came up with an interesting idea He will cancel some rolls saying that something distracted him or there was a strong wind Limak is able to cancel any number of rolls maybe even all or none of them Total score is calculated as if there were only non canceled rolls Look at the sample tests for clarification What maximum total score can Limak get ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint n;\nbool cz[MAX];\nLL wyn = 0;\nLL t[MAX];\nbool us(){\n  LL sum = 0;\n  int il = 0;\n  bool res = 0;\n  R(i,n)if(cz[i])sum+=t[i];\n  R(i,n){\n    if(cz[i]){\n      il++;\n      sum -= t[i];\n      if(t[i] * il + sum < 0){\n        wyn -= t[i] * il + sum;\n        il--;\n        cz[i] = 0;\n        res = 1;\n      }\n    }\n  }\n  return res;\n}\nbool dod(){\n  int il = 0;\n  LL sum = 0;\n  bool res = 0;\n  R(i,n)if(cz[i])il++;\n  FD(i,n){\n    if(!cz[i]){\n      if(t[i] * (il+1) + sum > 0){\n        wyn += t[i] * (il+1) + sum;\n        il++;\n        cz[i] = 1;\n        res = 1;\n      }\n    }\n    if(cz[i]){\n      il--;\n      sum += t[i];\n    }\n  }\n  return res;\n}\nmain(){\n  make(n);\n  R(i,n){\n    cz[i] = 1;\n    scanf(""%lld"",&t[i]);\n    wyn += t[i]*(i+1);\n  }\n  bool x = 1;\n  while(x){\n    x=0;\n    if(us())x=1;\n    if(dod())x=1;\n  }\n  printf(""%lld\\n"",wyn);\n}\n']",,,"['data structures', 'greedy']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Bear and Bowling.json,https://codeforces.com//blog/entry/20040,FIRST PART greedy works We will add take elements to a subsequence one by one Adding number when we have taken numbers on the left increases result by where is sum of taken numbers on the right Let s call this added value as the Quality of element We will prove correctness of the following greedy algorithm We take element with the biggest Quality till there are no elements left For every size of a subsequence number of taken elements we will get optimal score lemma If and we won t take first Proof Let s consider a moment when we don t fulfill the lemma for the first time If there are no taken numbers between and we have so is a better choice For taken numbers between and each number changes by and by We ll see that so will remain greater than If the lemma fulfilled till now says that wasn t taken before it can t be true because is taken and is not So indeed Let s assume that our greedy strategy is not correct Let s consider first moment when we take some element and for some we can t get optimal subsequence with size by taking more elements using any strategy Let denote a set of elements taken before So there is no way to add some more elements to set and achieve optimal score with size But it was possible just before taking so there is a subset of remaining elements that and set is the best among sets with size Note that can t be empty case 1 contains at least one element on the left from Let denote last element from that here last means with the biggest Our strategy wanted before elements from so we know from lemma that It will turn out that replacing with in set doesn t decrease the score so taking is acceptable Note that replacing an element with another one doesn t change size of a set subsequence In moment of choosing it had the biggest quality so then Now in there are new elements those in Let s imagine adding them to without and Each new element on the right change both and by Elements on the left change by and by note that And there are no elements between and Now taking would give us set but remains not less than so we can take instead case 2 contains only elements on the right from Similarly we can replace with closest from set As before elements on the right change and by the same value SECOND PART how to implement it First let s understand solution We divide a sequence into Parts When choosing the best candidate in a Part we want to forget about other Parts It s enough to remember only and number of taken elements on the left in previous Parts and sum of elements on the right in next Parts affects choosing the best element in a Part doesn t but we need this constant to add it to result for best candidate For a Part we want to have hull with linear functions of form With binary search we can find the best element in and then construct new hull for this Part in We can remove from complexity First binary search can be replaced with pointers for each Part initially we set a pointer at the beginning of Part To find best candidate in Part we slowly move pointer to the right by one Complexity is amortized And we can sort linear functions by angle only once because value doesn t change then constructing a hull is only Note that when rebuilding a hull we must set pointer to the beginning of Part So we have Code There are other two correct lemmas to speed your solution up We can take all positive numbers first it s not so easy to prove And we can stop when taken number doesn t increase score next taken numbers won t increase score neither 
https://codeforces.com//contest/1907/problem/F,2365627,F,1907F,1907,F. Shift and Reverse,Given an array of integers a 1 a 2 ldots a n You can make two types of operations with this array Shift move the last element of array to the first place and shift all other elements to the right so you get the array a n a 1 a 2 ldots a n 1 Reverse reverse the whole array so you get the array a n a n 1 ldots a 1 Your task is to sort the array in non decreasing order using the minimal number of operations or say that it is impossible ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define ll long long\n#define ii pair<int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n#define pub push_back\n#define pob pop_backac\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n;\nint a[N];\nint al[N],ar[N];\nint bl[N],br[N];\nvoid solve()\n{\n    n=read();   int ans=INF;\n    for(int i=1;i<=n;++i)   a[i]=read();\n    \n    for(int i=1;i<=n;++i)\n    {\n        al[i]=bl[i]=i;\n        if(i==1)    continue;\n        if(a[i-1]<=a[i])    al[i]=al[i-1];\n        if(a[i-1]>=a[i])    bl[i]=bl[i-1];\n    }\n    for(int i=n;i>=1;--i)\n    {\n        ar[i]=br[i]=i;\n        if(i==n)    continue;\n        if(a[i]<=a[i+1])    ar[i]=ar[i+1];\n        if(a[i]>=a[i+1])    br[i]=br[i+1];\n    }\n    if(al[n]==1)    ans=min(ans,0);\n    if(br[1]==n)    ans=min(ans,1);\n    for(int i=1;i<n;++i)\n    {\n        if(al[i]==1&&ar[i+1]==n&&a[n]<=a[1])\n        {\n            ans=min(ans,n-i);\n            ans=min(ans,1+i+1);\n        }\n        if(bl[i]==1&&br[i+1]==n&&a[1]<=a[n])\n        {\n            ans=min(ans,n-i+1);\n            ans=min(ans,1+i);\n        }\n    }\n    if(ans>=INF)    puts(""-1"");\n    else    printf(""%d\\n"",ans);\n    \n}\nint main()\n{\n    T=read();\n    while(T--)  solve();\n    return 0;\n}']",,,"['greedy', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Shift and Reverse.json,https://codeforces.com//blog/entry/123012,In this problem there are several possible sequences of actions from which the optimal one must be chosen For brevity let s denote the reverse by the letter and the shift by the letter Let s write out the array twice and count the segments on which it increases and decreases This way we can find all possible shifts that will sort the array 
https://codeforces.com//contest/1365/problem/C,643138,C,1365C,1365,C. Rotation Matching,After the mysterious disappearance of Ashish his two favourite disciples Ishika and Hriday were each left with one half of a secret message These messages can each be represented by a permutation of size n Let s call them a and b Note that a permutation of n elements is a sequence of numbers a 1 a 2 ldots a n in which every number from 1 to n appears exactly once The message can be decoded by an arrangement of sequence a and b such that the number of matching pairs of elements between them is maximum A pair of elements a i and b j is said to match if i j that is they are at the same index a i b j His two disciples are allowed to perform the following operation any number of times choose a number k and cyclically shift one of the permutations to the left or right k times A single cyclic shift to the left on any permutation c is an operation that sets c 1 c 2 c 2 c 3 ldots c n c 1 simultaneously Likewise a single cyclic shift to the right on any permutation c is an operation that sets c 1 c n c 2 c 1 ldots c n c n 1 simultaneously Help Ishika and Hriday find the maximum number of pairs of elements that match after performing the operation any possibly zero number of times ,"['#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint t;\n\t// scanf(""%d"" ,&t);\n\tt=1;\n\twhile(t--){\n\t\tint n;\n\t\tscanf(""%d"", &n);\n\t\tvector <int> a(n);\n\t\tvector <int> b(n);\n\t\tvector <int> c(n);\n\t\tfor(int&i:a){\n\t\t\tscanf(""%d"", &i);i--;\n\t\t}\n\t\tfor(int&i:b){\n\t\t\tscanf(""%d"", &i);i--;\n\t\t}\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tc[a[i]]=i;\n\t\t}\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tb[i]=c[b[i]];\n\t\t}\n\t\ta.assign(n, 0);\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\ta[(b[i]-i+n)%n]++;\n\t\t}\n\t\tprintf(""%d\\n"", *max_element(a.begin(), a.end()));\n\t}\n}']",,,"['constructive algorithms', 'data structures', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Rotation Matching.json,https://codeforces.com//blog/entry/78504,We only need to perform shifts on one of the arrays Moreover all the shifts can be of the same type right or left First of all a left cyclic shift is the same as right cyclic shifts and vice versa So we only need to perform shifts of one type say right Moreover a right cyclic shift of is the same as performing a left cyclic shift on and vice versa So we don t need to perform any shifts on Now the problem reduces to finding the maximum number of matching pairs over all right cyclic shifts of Since right cyclic shifts on results in again there are only right cyclic shifts possible Since both arrays are a permutation each element in would match with its corresponding equal element in only for one of the shifts For example if is and is the number in would match with the number in only if one right cyclic shift is performed So for each element in we can find the number of right cyclic shifts after which it would match with its corresponding equal element in If then would match with after right cyclic shifts If then would with after shifts Now for each shift we can find the number of matching pairs and take the maximum Time complexity or if you use a map 
https://codeforces.com//contest/1149/problem/B,337470,B,1149B,1149,B. Three Religions,During the archaeological research in the Middle East you found the traces of three ancient religions First religion Second religion and Third religion You compiled the information on the evolution of each of these beliefs and you now wonder if the followers of each religion could coexist in peace The is a long word containing the lowercase English characters only At each moment of time each of the religion beliefs could be described by a word consisting of lowercase English characters The three religions can coexist in peace if their descriptions form disjoint subsequences of the More formally one can paint some of the characters of the in three colors 1 2 3 so that each character is painted in one color and the description of the i th religion can be constructed from the by removing all characters that aren t painted in color i The religions however evolve In the beginning each religion description is empty Every once in a while either a character is appended to the end of the description of a single religion or the last character is dropped from the description After each change determine if the religions could coexist in peace ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int A = 26;\nconst int N = 100100;\nconst int M = 255;\nchar s[N];\nint n, q;\nint nxt[N][A];\nint dp[M][M][M];\nint p[3][M];\nint sz[3];\n\nint getPos(int pos, int c) {\n\tif (pos >= n || nxt[pos][c] == n) return N;\n\treturn nxt[pos][c] + 1;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &q);\n\tscanf(""%s"", s);\n\tfor (int c = 0; c < A; c++)\n\t\tnxt[n][c] = N;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int c = 0; c < A; c++)\n\t\t\tnxt[i][c] = nxt[i + 1][c];\n\t\tnxt[i][(int)(s[i] - \'a\')] = i;\n\t}\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tfor (int z = 0; z < M; z++)\n\t\t\t\tdp[x][y][z] = N;\n\tdp[0][0][0] = 0;\n\twhile(q--) {\n\t\tchar t;\n\t\tint w;\n\t\tscanf("" %c %d"", &t, &w);\n\t\tw--;\n\t\tif (t == \'+\') {\n\t\t\tint c;\n\t\t\tscanf("" %c"", &t);\n\t\t\tc = (int)(t - \'a\');\n\t\t\tp[w][sz[w]++] = c;\n\t\t\tif (w == 0) {\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[sz[0]][y][z] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[sz[0]][y][z] = min(dp[sz[0]][y][z], getPos(dp[sz[0] - 1][y][z], c));\n\t\t\t\t\t\tif (y < sz[1])\n\t\t\t\t\t\t\tdp[sz[0]][y + 1][z] = min(dp[sz[0]][y + 1][z], getPos(dp[sz[0]][y][z], p[1][y]));\n\t\t\t\t\t\tif (z < sz[2])\n\t\t\t\t\t\t\tdp[sz[0]][y][z + 1] = min(dp[sz[0]][y][z + 1], getPos(dp[sz[0]][y][z], p[2][z]));\n\t\t\t\t\t}\n\t\t\t} else if (w == 1) {\n\t\t\t\tfor (int x = 0; x <= sz[0]; x++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[x][sz[1]][z] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int x = 0; x <= sz[0]; x++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[x][sz[1]][z] = min(dp[x][sz[1]][z], getPos(dp[x][sz[1] - 1][z], c));\n\t\t\t\t\t\tif (x < sz[0])\n\t\t\t\t\t\t\tdp[x + 1][sz[1]][z] = min(dp[x + 1][sz[1]][z], getPos(dp[x][sz[1]][z], p[0][x]));\n\t\t\t\t\t\tif (z < sz[2])\n\t\t\t\t\t\t\tdp[x][sz[1]][z + 1] = min(dp[x][sz[1]][z + 1], getPos(dp[x][sz[1]][z], p[2][z]));\n\t\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int x = 0; x <= sz[0]; x++) {\n\t\t\t\t\t\tdp[x][y][sz[2]] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int x = 0; x <= sz[0]; x++) {\n\t\t\t\t\t\tdp[x][y][sz[2]] = min(dp[x][y][sz[2]], getPos(dp[x][y][sz[2] - 1], c));\n\t\t\t\t\t\tif (y < sz[1])\n\t\t\t\t\t\t\tdp[x][y + 1][sz[2]] = min(dp[x][y + 1][sz[2]], getPos(dp[x][y][sz[2]], p[1][y]));\n\t\t\t\t\t\tif (x < sz[0])\n\t\t\t\t\t\t\tdp[x + 1][y][sz[2]] = min(dp[x + 1][y][sz[2]], getPos(dp[x][y][sz[2]], p[0][x]));\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tsz[w]--;\n\t\t}\n\t\tif (dp[sz[0]][sz[1]][sz[2]] <= n)\n\t\t\tprintf(""YES\\n"");\n\t\telse\n\t\t\tprintf(""NO\\n"");\n\t}\n\n\treturn 0;\n}\n']",,,"['dp', 'implementation', 'strings']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Three Religions.json,https://codeforces.com/blog/entry/66783,For our convenience construct a two dimensional helper array where is the location of the first occurrence of character in the on position or later or if no such character exists This array can be created in a straightforward in time by iterating the word from the end to the beginning Consider the equal to The helper array looks as follows Actually for our purposes it s easier to set in our example and also consider additional links from indices and to index Why We ll later need the index of the first occurrence of some character some location If this already happens to be as we already established we can easily see that no requested occurrence exists Let s now try to answer each query in time We can do it using dynamic programming let be the length of the shortest prefix of the that contains the disjoint occurrences of the prefix of length of the first religion s description the prefix of length of the second religion s description and the prefix of length of the third religion s description Each state can be evaluated in constant time by checking for each religion what the prefix length would be if the last character of the prefix is a part of the th religion s description We use the helper array to speed up the search How to write the state transitions For each chop the last character of the th description s prefix find the shortest prefix of the containing all three descriptions and then reappend this last character We can do that using our helper array Now if the lengths of the descriptions are and respectively then the embedding of these descriptions as distinct subsequences exists if and only if However due to the nature of queries we can do a single update in time if we drop a character we don t need to recompute any states if we add a character to the th description we only need to recompute the states with equal to the length of the description and there are at most of them This allows us to solve the problem in time 
https://codeforces.com//contest/612/problem/E,43953,E,612E,612,E. Square Root of Permutation,A of length is an array containing each integer from to exactly once For example is a permutation For the permutation the square of permutation is the permutation that for each For example the square of is This problem is about the inverse operation given the permutation you task is to find such permutation that If there are several such find any of them ,"['/*\nWe live for the magic in the sound, distorted guitars are breaking ground\nThe drum pounding faster than my heart, the vocals are screaming extreme art\nThe passion for metal drives us forth, the best heavy metal comes from north\n\nThe powerful tunes, spectacular shows, the audience screams in ecstasy\n\nMetal, Metal\nBack with the vengeance\nMetal, Metal\nAll that I need is heavy metal\nMetal\nScreaming together\nMetal, Metal\nMetal is all that I need\n\nWhile hell bends for leather we stand strong, a rocker can party all night long\nthe school couldn\'t teach us rock\' n roll, the school couldn\'t help us reach our goal\nWe live for the magic in the sound, distorted guitars are breaking ground\n\nThe powerful tunes, spectacular shows, the audience screams in ecstasy\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 1100000;\n\nusing namespace std;\n\nvector<vector<int> >cycles[N];\nint used[N];\nint ans[N];\nint p[N];\nvector<int> cycle;\nint n;\n\nvoid dfs(int v)\n{\n\tcycle.push_back(v);\n\tused[v] = 1;\n\tint to = p[v];\n\tif (used[to])\n\t\treturn;\n\tdfs(to);\n}\n\nvoid update(vector<int> v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tans[v[i]] = v[(i + 1) % v.size()];\n\t}\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(""%d"", &p[i]);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i])\n\t\t\tcontinue;\n\t\tcycle.clear();\n\t\tdfs(i);\n\t\tcycles[cycle.size()].push_back(cycle);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i % 2 == 0 && cycles[i].size() % 2 == 1)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tused[i] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i % 2 == 1)\n\t\t{\n\t\t\tfor (int j = 0; j < cycles[i].size(); j++)\n\t\t\t{\n\t\t\t\tvector<int> V;\n\t\t\t\tfor (int q = 0; q < i / 2; q++)\n\t\t\t\t{\n\t\t\t\t\tV.push_back(cycles[i][j][q]);\n\t\t\t\t\tV.push_back(cycles[i][j][(q+1) + i / 2]);\n\t\t\t\t}\n\t\t\t\tV.push_back(cycles[i][j][i / 2 ]);\n\t\t\t\tupdate(V);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < cycles[i].size(); j += 2)\n\t\t\t{\n\t\t\t\tvector<int> V;\n\t\t\t\tfor (int q = 0; q < cycles[i][j].size(); q++)\n\t\t\t\t{\n\t\t\t\t\tV.push_back(cycles[i][j][q]);\n\t\t\t\t\tV.push_back(cycles[i][j + 1][q]);\n\t\t\t\t}\n\t\t\t\tupdate(V);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tprintf("" "");\n\t\tprintf(""%d"", ans[i]);\n//\t\tcout << ans[i];\n\t}\n\tcout << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']",,,"['combinatorics', 'constructive algorithms', 'dfs and similar', 'graphs', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Square Root of Permutation.json,https://codeforces.com//blog/entry/22299,Consider some permutation Let s build by it the oriented graph with edges Easy to see and easy to prove that this graph is the set of disjoint cycles Now let s see what would be with that graph when the permutation will be multiplied by itself all the cycles of odd length would remain so only the order of vertices will change they will be alternated but the cycles of even length will be split to the two cycles of the same length So to get the square root from the permutation we should simply alternate in reverse order all cycles of the odd length and group all the cycles of the same even length to pairs and merge cycles in each pair If it s impossible to group all even cycles to pairs then the answer doesn t exist Complexity 
https://codeforces.com//contest/634/problem/B,49945,B,634B,634,B. XOR Equation,Two integers and have a sum of and a bitwise XOR of How many possible values are there for the ordered pair ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nll solve(ll s, ll x)\n{\n\tll os = s;\n\tll ways = 1;\n\tfor (int qaz = 60; qaz >= 0; qaz--)\n\t{\n\t\tll c = 1LL << qaz;\n\t\tif (c & x)\n\t\t{\n\t\t\tways *= 2;\n\t\t\ts -= c;\n\t\t\tif (s < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll change = c*2;\n\t\t\tif (change <= s)\n\t\t\t\ts -= change;\n\t\t}\n\t}\n\tif (s != 0)\n\t\treturn 0;\n\tif (os == x)\n\t\tways -= 2;\n\treturn ways;\n}\n\nint main()\n{\n\tll s, x;\n\trint(s); rint(x);\n\tprintf(""%lld\\n"", solve(s, x));\n}\n']",,,"['constructive algorithms', 'dp', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. XOR Equation.json,https://codeforces.com//blog/entry/43467,For any two integers a and b we have where is the xor and a b is the bitwise AND This is because is non carrying binary addition Thus we can find a b s x 2 if this is not an integer there are no solutions Now for each bit we have 4 cases and If then ai bi so we have one possibility ai bi ai bi If then we must have ai bi 0 otherwise we print 0 and we have two choices ai 1 and bi 0 or vice versa Thus we can return 2n where n is the number of one bits in x Remember to subtract 2 for the cases a 0 or b 0 if necessary 
https://codeforces.com//contest/1281/problem/A,495766,A,1281A,1281,A. Suffix Three,We just discovered a new data structure in our research group a It s very useful for natural language processing Given three languages and three suffixes a suffix three can determine which language a sentence is written in It s super simple 100 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    for (int tt = 0; tt < t; tt++) {\n        string s; cin >> s;\n        string tmp;\n        string a;\n        for (char c : s) {\n            if (c == \'_\') {\n                reverse(tmp.begin(), tmp.end());\n                if (tmp.find(""op"") == 0) {\n                    a = ""FILIPINO"";\n                }\n                if (tmp.find(""used"") == 0 || tmp.find(""usam"") == 0) {\n                    a = ""JAPANESE"";\n                }\n                if (tmp.find(""adinm"") == 0) {\n                    a = ""KOREAN"";\n                }\n                tmp = """";\n            }\n            else {\n                tmp += c;\n            }\n        }\n        reverse(tmp.begin(), tmp.end());\n        if (tmp.find(""op"") == 0) {\n            a = ""FILIPINO"";\n        }\n        if (tmp.find(""used"") == 0 || tmp.find(""usam"") == 0) {\n            a = ""JAPANESE"";\n        }\n        if (tmp.find(""adinm"") == 0) {\n            a = ""KOREAN"";\n        }\n        cout << a << ""\\n"";\n    }\n    return 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Suffix Three.json,https://codeforces.com//blog/entry/72212,The simplest way to solve it is to use your language s builtin string methods like It might be different in your preferred language Alternatively if you know how to access the individual letters of a string then you may implement something similar to yourself To print the required output you can just use something like if s endswith po print FILIPINO if s endswith desu or s endswith masu print JAPANESE if s endswith mnida print KOREAN Alternatively notice that you can simply check the last letter since and are distinct so it can be simplified slightly One can even write a Python one liner for a single test case print o FILIPINO a KOREAN u JAPANESE input 1 
https://codeforces.com//contest/1191/problem/B,371218,B,1191B,1191,B. Tokitsukaze and Mahjong,Tokitsukaze is playing a game derivated from Japanese mahjong In this game she has three tiles in her hand Each tile she owns is a suited tile which means it has a suit or and a number a digit ranged from 1 to 9 In this problem we use one digit and one lowercase letter which is the first character of the suit to represent a suited tile All possible suited tiles are represented as ldots ldots ldots In order to win the game she must have at least one described below in her hand so sometimes she should draw extra suited tiles After drawing a tile the number of her tiles increases by one She can draw any tiles she wants including those already in her hand Do you know the minimum number of extra suited tiles she needs to draw so that she can win Here are some useful definitions in this game A also known as meld is formed by a or a A also known as triplet is made of three identical tiles such as however or is NOT a A also known as sequence is made of three sequential numbered tiles in the same suit such as and however or is NOT a Some examples it contains no or so it includes no it contains a but no so it includes a it contains no but a or so it includes a Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite ,"['#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>=\'0\'&&ch<=\'9\')) {if (ch==\'-\')f=-1;ch=getchar();}\n    while (ch>=\'0\'&&ch<=\'9\') {x=x*10+(ch-\'0\'); ch=getchar();}\n    return x*f;\n}\n\nchar a[5],b[5],c[5];\n\nint main() {\n\n\tscanf(""%s"",a); scanf(""%s"",b); scanf(""%s"",c);\n\tif (a[1]==b[1]&&a[1]==c[1]) {\n\t\tint x=a[0]-\'0\',y=b[0]-\'0\',z=c[0]-\'0\';\n\t\tif (x>y) swap(x,y); if (x>z) swap(x,z);\n\t\tif (y>z) swap(y,z);\n\t\tif (x==y&&y==z) puts(""0"");\n\t\telse if (y-x==1&&z-y==1) puts(""0"");\n\t\telse if (abs(x-y)<=2||abs(y-z)<=2) puts(""1"");\n\t\telse puts(""2"");\n\t} else {\n\t\tif (a[1]==b[1]) {\n\t\t\tint x=a[0]-\'0\',y=b[0]-\'0\';\n\t\t\tif (abs(x-y)<=2) puts(""1"");\n\t\t\telse puts(""2"");\n\t\t} else if (a[1]==c[1]) {\n\t\t\tint x=a[0]-\'0\',y=c[0]-\'0\';\n\t\t\tif (abs(x-y)<=2) puts(""1"");\n\t\t\telse puts(""2"");\n\t\t} else if (b[1]==c[1]) {\n\t\t\tint x=c[0]-\'0\',y=b[0]-\'0\';\n\t\t\tif (abs(x-y)<=2) puts(""1"");\n\t\t\telse puts(""2"");\n\t\t} else puts(""2"");\n\t}\n\n\treturn 0;\n\t\n}\n']",,,"['brute force', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Tokitsukaze and Mahjong.json,https://codeforces.com/blog/entry/68314,TutorialThere are only two types of mentsus so you can enumerate the mentsu you want her to form and check the difference between that and those currently in her hand Alternatively you can find out that the answer is at most since she can draw two extra identical tiles which are the same as one of those in her hand You may enumerate at most extra tile for her and check if it can contribute to a mentsu If she can t the answer will be 
https://codeforces.com//contest/1713/problem/C,1496886,C,1713C,1713,C. Build Permutation,A array a of size n is called if for all valid indices i 0 le i le n 1 a i i is a perfect square dagger Given an integer n Find a permutation ddagger p of 0 1 2 ldots n 1 that is good or determine that no such permutation exists dagger An integer x is said to be a perfect square if there exists an integer y such that x y 2 ddagger An array b is a permutation of an array a if b consists of the elements of a in arbitrary order For example 4 2 3 4 is a permutation of 3 2 4 4 while 1 2 2 is not a permutation of 1 2 3 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nconst int MAX = 200200;\n\nconst int MOD = 998244353;\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vi res(n);\n\n    int curr = n-1;\n\n    while (curr > 0) {\n        int base;\n        for (base = 0; base*base < curr; base++);\n        int need = base*base-curr;\n        int start = curr;\n        for (int i = need; i <= start; i++) {\n            res[i] = curr;\n            curr--;\n        }\n    }\n    for (int i = 0; i < n; i++) cout << res[i] << "" "";\n    cout << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""input.in"", ""r"", stdin);\n    // freopen(""input.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}']",,,"['constructive algorithms', 'dp', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Build Permutation.json,https://codeforces.com//blog/entry/105419,First let s prove that the answer always exists Let s call the smallest square number that is not smaller than is Therefore which means Proof So we can fill for Using this method we can recursively reduce to then all the way down to We can prove that as Time complexity Solution 
https://codeforces.com//contest/817/problem/A,110087,A,817A,817,A. Treasure Hunt,Captain Bill the Hummingbird and his crew recieved an interesting challenge offer Some stranger gave them a map potion of teleportation and said that only this potion might help them to reach the treasure Bottle with potion has two values and written on it These values define four moves which can be performed using the potion Map shows that the position of Captain Bill the Hummingbird is and the position of the treasure is You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline If it is possible for Captain to reach the treasure using the potion then output otherwise without quotes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nvoid solve() {\n    int x[2], y[2], a, b;\n    FOR(i, 0, 2) cin >> x[i] >> y[i];\n    cin >> a >> b;\n    int u = abs(x[0] - x[1]);\n    int v = abs(y[0] - y[1]);\n    if (u % a || v % b) {\n        cout << ""NO\\n"";\n        return;\n    }\n    if (u / a + v / b & 1) {\n        cout << ""NO\\n"";\n    }\n    else {\n        cout << ""YES\\n"";\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']",,,"['implementation', 'math', 'number theory']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Treasure Hunt.json,https://codeforces.com//blog/entry/52638,Firstly let s approach this problem as if the steps were and Then the answer is if and It s easy to see that if the answer to this problem is then the answer to the original one is also Let s return to the original problem and take a look at some sequence of steps It ends in some point Define as and as The parity of is the same as the parity of It is like this because every type of move changes parity of both and So the answer is if and Overall complexity 
https://codeforces.com//contest/403/problem/D,7186,D,403D,403,D. Beautiful Pairs of Numbers,The sequence of integer pairs is if the following statements are fulfilled where is a given positive integer all numbers are distinct For the given number find the number of beautiful sequences of length As the answer can be rather large print the remainder after dividing it by ,"['#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<"" = ""<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define MD 1000000007\n#define maxn 1010\n\nint C[maxn][maxn], fact[maxn], dp[maxn][maxn];\n\nvoid su(int &a, int b)\n{\n\ta+=b; if (a>=MD) a-=MD;\n}\n\nvoid lemon()\n{\n\tC[0][0]=1;\n\trep(i,1,1000)\n\t{\n\t\tC[i][0]=1; C[i][i]=1;\n\t\trep(j,1,i-1)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%MD;\n\t}\n\t\n\tfact[0]=1;\n\trep(i,1,1000) fact[i]=LL(fact[i-1])*i%MD;\n\t\n\t//dp[s][k]=sum(dp[s-k*i+1][k-1]) i>=1\n\trep(s,0,1000)\n\t{\n\t\tdp[s][1]=1;\n\t\trep(k,2,1000)\n\t\t\trep(i,1,(s+1)/k)\n\t\t\t\tsu(dp[s][k],dp[s-i*k+1][k-1]);\n\t}\n\t\n\trep(s,0,1000)\n\t\trep(k,0,1000)\n\t\t\tdp[s][k]=LL(dp[s][k])*fact[k]%MD;\n\t\t\t\n\tint tcase; scanf(""%d"",&tcase);\n\twhile (tcase--)\n\t{\n\t\tint n,k; scanf(""%d%d"",&n,&k);\n\t\tint final=0;\n\t\trep(s,0,n)\n\t\t\tsu(final,LL(C[n-s][k])*dp[s][k]%MD);\n\t\tprintf(""%d\\n"",final);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""D.in"",""r"",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n']",,,"['combinatorics', 'dp']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Beautiful Pairs of Numbers.json,https://codeforces.com//blog/entry/10972,First we can note that length of sequence is not greater then Ok but why Because all numbers are different so Let s imagine that sequence from input is a sequence of non intersecting segments So is length of segment Also After that let s calculate the following DP number of sequences for which following holds and maximal number is less then upper bound of sequence This DP will helps us to calculate number of ways to set length to each segment in sequence It s simple to calculate such DP We can calculate such DP by using only of memory where After that we should multiply on because we need number of sequences where order does not matter After that we can calculate answer for Let s where some upper bound of sequences After that we should calculate next number how many ways to set to distances between segments It s clear that we can increase distance between some segments but we have only such operations It s well known that answer number of ways equals to So for each we should sum by following values Note that we need array binomials where 
https://codeforces.com//contest/187/problem/E,1325,E,187E,187,E. Heaven Tour,The story was not finished as PMP thought God offered him one more chance to reincarnate and come back to life But before he can come back God told him that PMP should ask great men including prominent programmers about their life experiences The men are standing on a straight line They are numbered through from left to right The coordinate of the th man is PMP should visit all these people one by one in arbitrary order Each men should be visited At the beginning of his tour he starts at location of th man and asks him about his experiences Each time PMP wants to change his location he should give a ticket to an angel and the angel carries him to his destination Angels take PMP from one location fly to his destination and put him down there Nobody else is visited in this movement Moving from th man to th man takes time PMP can get back to life as soon as he visits all men There are two types of angels Some angels are going to the right and they only accept right tickets Others are going the left and they only accept left tickets There are an unlimited number of angels of each type PMP has left tickets and right tickets PMP wants to get back to life as soon as possible to be able to compete in this year s final instead of the final he missed last year He wants to know the quickest way to visit all the men exactly once He also needs to know the exact sequence moves he should make ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,lt,rt,s;\nint di[101000];\nint dd[101000];\nconst long long INF=10000000000000000ll;\nlong long ans=INF;\nint aid[101000];\nint tid[101000],tt;\nbool flag;\nbool ansf;\nlong long ta;\ninline void cl(){tt=0;}\ninline void pp(int x){tid[tt++]=x;}\ninline void tr(){\n    //for(int i=0;i<tt;i++)printf(""%d "",tid[i]);\n   // puts("""");\n    if(ta<ans){\n        ans=ta;\n        ansf=flag;\n        for(int i=0;i<n-1;i++)aid[i]=tid[i];\n    }\n}\npair<int,int> ev[101000];\nint to[101000];\nbool rev[101000];\ninline void trylr(){\n    if(s==n-1)return;\n    if(rt==0)return;\n    int i,j;\n    if(lt==0){\n        if(s!=0)return;\n        cl();\n        for(i=1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0];\n        tr();\n        return;\n    }\n    if(lt<=s){\n        //puts(""Case 1"");\n        cl();\n        for(i=lt-1;i>=0;i--)pp(i);\n        for(i=lt;i<s;i++)pp(i);\n        for(i=s+1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0]+(long long)di[s]-di[0];\n        tr();\n        return;\n    }else if(rt==1){\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        for(i=n-1;i>s;i--)pp(i);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+(long long)di[n-1]-di[s+1];\n        tr();\n        return;\n    }else{\n        int mo=lt-s;\n        int evc=0;\n        for(i=s+1;i<n-1;i++){\n            ev[evc++]=make_pair(dd[i],i);\n        }\n        sort(ev,ev+evc);\n        for(i=0;i<evc;i++)to[ev[i].second]=i;\n        long long ss=0;\n        int bi=-1;\n        long long ba=INF;\n        set<int> XD;\n        set<int>::iterator pt;\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo-1;i<n;i++){\n            //printf(""i=%d ss=%I64d\\n"",i,ss);\n            if(ba>ss*2+di[n-1]-di[i]){\n                ba=ss*2+di[n-1]-di[i];\n                bi=i;\n            }\n            int toa=i-1;\n            if(i==n-mo-1){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                ss+=ev[*pt].first;\n            }else{\n                if(to[toa]<*pt){\n                    ss+=ev[to[toa]].first;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    ss+=ev[*pt].first;\n                }\n            }\n        }\n        //printf(""ba=%I64d bi=%d\\n"",ba,bi);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+ba;\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        memset(rev,0,sizeof(rev));\n        XD.clear();\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo;i<=bi;i++){\n            int toa=i-1;\n            if(i==n-mo){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                rev[ev[*pt].second]=1;\n            }else{\n                if(to[toa]<*pt){\n                    rev[toa]=1;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    rev[ev[*pt].second]=1;\n                }\n            }\n        }\n        for(i=s+1;i<bi;i=j+1){\n            for(j=i;j<bi-1&&rev[j];j++);\n            for(int q=j;q>=i;q--)pp(q);\n        }\n        for(i=n-1;i>=bi;i--){\n            pp(i);\n        }\n        tr();\n    }\n}\ninline void tryrl(){\n    //puts(""tryrl"");\n    swap(lt,rt);\n    s=n-1-s;\n    int i,j;\n    int l=di[n-1];\n    for(i=0;i<n;i++){\n        di[i]=l-di[i];\n    }\n    for(i=0,j=n-1;i<j;i++,j--)swap(di[i],di[j]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=1;\n    trylr();\n}\nint main(){\n    int i,j,k;\n    scanf(""%d%d%d"",&n,&lt,&s);\n    rt=n-1-lt;\n    s--;\n    for(i=0;i<n;i++)scanf(""%d"",&di[i]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=0;\n    trylr();\n    tryrl();\n    if(ans==INF)puts(""-1"");\n    else{\n        printf(""%I64d\\n"",ans);\n        for(i=0;i<n-1;i++)printf(""%d%c"",ansf?n-aid[i]:aid[i]+1,(i==n-2?\'\\n\':\' \'));\n    }\n}\n\n']",,,"['data structures', 'greedy']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Heaven Tour.json,https://codeforces.com/blog/entry/4540,Step 1 Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man Obviously every segment the distance between two consecutive men should be covered at least once We also argue that at least l the number of left tickets segments should be covered at least three times Proof Each time you use a left ticket to go to man i with 1 i n 1 the segment between i th and i 1 th men is covered at least three times Once for you should go after i be in a position to come back Once for you use a left ticked to come back to i And once again you should go after i because you want to finish at man number n Note that in the first and the last segments are always covered once no matter what we do But except for these two segments every other segment can be chosen to be among the segments that are covered three times and every combination that we choose l segments is feasible Proof it as practice So we choose the smallest l segments and the problem can be solved with a simple sort in O n logn Step 2 Solve the problem if the starting man is the leftmost man but the finishing man can be anywhere To solve this problem we first fix the finishing man With reasoning similar to that of step 1 we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him But obviously every segment after the finishing man is covered at least two times So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three So the algorithm would be iterate over i the number of finishing man and maintain the l n i smallest segments to the right of finishing man as you progress This can be implemented in O n logn Step 3 Solve the problem if the starting man is fixed but the finishing man can be anywhere Assume that the starting man is not the first man or the last man otherwise we could use algorithm of step 2 to solve the problem Without loss of generality assume that you finish your tour to the right side of finishing man Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times So just like what we said in step 2 it is good to waste as many left tickets as possible in this area So the algorithm would be choose to finish left or right first then greedily waste as many bad moves by bad moves I mean the moves that if breach to the other side will be more costly as possible there and follow the algorithm in step 2 to solve the whole problem There are some special cases such as when the tour cannot be finished at all that we left to readers find a way how to handle them 
https://codeforces.com//contest/1707/problem/E,1465657,E,1707E,1707,E. Replace,You are given an integer array a 1 ldots a n where 1 le a i le n for all i There s a replace function f which takes a pair of integers l r where l le r as input and outputs the pair f big l r big left min a l a l 1 ldots a r max a l a l 1 ldots a r right Consider repeated calls of this function That is from a starting pair l r we get f big l r big then f big f big l r big big then f big f big f big l r big big big and so on Now you need to answer q queries For the i th query you have two integers l i and r i 1 le l i le r i le n You must answer the minimum number of times you must apply the replace function to the pair l i r i to get 1 n or report that it is impossible ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nint Log[100001];\nint n,q,a[100001],L[100001],R[100001];\nstruct ST{\n\tint st[100001][21];\n\tvoid init(){\n\t\tfor(int j=1;(1<<j)<=n;++j)\n\t\t\tfor(int i=1;i+(1<<j)-1<=n;++i)\n\t\t\t\tst[i][j]=std::min(st[i][j-1],st[i+(1<<(j-1))][j-1]);\n\t}\n\tint query(int l,int r){\n\t\tif(l>r)return 0x7f7f7f7f;\n\t\tint k=Log[r-l+1];\n\t\treturn std::min(st[l][k],st[r-(1<<k)+1][k]);\n\t}\n}mn[21],mx[21],amn;\nint f[100001];\nint dis[100001];\nint Q[100001],h,t;\nstd::vector<int>vec[1000001];\nvoid add(int root,int l,int r,int el,int er,int x){\n\tif(el>r||er<l)return;\n\tif(el<=l&&er>=r){\n\t\tvec[root].push_back(x);\n\t\t// printf(""add %d %d\\n"",root,x);\n\t\treturn;\n\t}\n\tadd(root<<1,l,(l+r)>>1,el,er,x);\n\tadd(root<<1|1,((l+r)>>1)+1,r,el,er,x);\n}\nvoid upd(int root,int l,int r,int e,int d){\n\tfor(int i=0;i<vec[root].size();++i){\n\t\tint u=vec[root][i];\n\t\tif(dis[vec[root][i]]>d){\n\t\t\tdis[u]=d;\n\t\t\tQ[++t]=u;\n\t\t}\n\t}\n\tvec[root].clear();\n\tif(l==r)return;\n\tif((l+r)>>1>=e)upd(root<<1,l,(l+r)>>1,e,d);\n\telse upd(root<<1|1,((l+r)>>1)+1,r,e,d);\n}\nint ans[100001];\nbool vis[100001];\nvoid upd2(int root,int l,int r,int e,int d){\n\tfor(int i=0;i<vec[root].size();++i){\n\t\tint u=vec[root][i];\n\t\tif(ans[vec[root][i]]==-1){\n\t\t\tans[u]=d;\n\t\t\tQ[++t]=u;\n\t\t}\n\t}\n\tvec[root].clear();\n\tif(l==r)return;\n\tif((l+r)>>1>=e)upd2(root<<1,l,(l+r)>>1,e,d);\n\telse upd2(root<<1|1,((l+r)>>1)+1,r,e,d);\n}\nint getans(int l,int r,int st){\n\tfor(int i=20;~i;--i)\n\t\tif(st>=(1<<i)){\n\t\t\tst-=1<<i;\n\t\t\tint ol=l,Or=r;\n\t\t\tl=mn[i].query(ol,Or);\n\t\t\tr=-mx[i].query(ol,Or);\n\t\t}\n\treturn r;\n}\nint g[100001];\nvoid upd3(int root,int l,int r,int e,int d){\n\t// printf(""%d %d %d\\n"",root,l,r);\n\tfor(int i=0;i<vec[root].size();++i){\n\t\tint u=vec[root][i];\n\t\t// printf(""%d\\n"",u);\n\t\tif(f[vec[root][i]]==-1){\n\t\t\tf[u]=d+g[u];\n\t\t\tQ[++t]=u;\n\t\t}\n\t}\n\tvec[root].clear();\n\tif(l==r)return;\n\tif((l+r)>>1>=e)upd3(root<<1,l,(l+r)>>1,e,d);\n\telse upd3(root<<1|1,((l+r)>>1)+1,r,e,d);\n}\nint main(){\n\tscanf(""%d%d"",&n,&q);\n\tfor(int i=1;i<=n;++i)scanf(""%d"",a+i);\n\tfor(int i=2;i<=n;++i)Log[i]=Log[i>>1]+1;\n\tfor(int i=1;i<n;++i)L[i]=std::min(a[i],a[i+1]),R[i]=std::max(a[i],a[i+1])-1;\n\tfor(int i=0;(1<<i)<=n;++i){\n\t\tfor(int j=1;j<n;++j){\n\t\t\tif(i==0){\n\t\t\t\tmn[i].st[j][0]=L[j];\n\t\t\t\tmx[i].st[j][0]=-(R[j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint l=mn[i-1].query(j,j);\n\t\t\t\tint r=-mx[i-1].query(j,j);\n\t\t\t\tmn[i].st[j][0]=mn[i-1].query(l,r);\n\t\t\t\tmx[i].st[j][0]=mx[i-1].query(l,r);\n\t\t\t\t// printf(""%d %d %d %d %d %d\\n"",j,i,l,r,mn[i-1].query(l,r),-mx[i-1].query(l,r));\n\t\t\t}\n\t\t}\n\t\tmn[i].init();\n\t\tmx[i].init();\n\t}\n\tfor(int i=2;i<n;++i)add(1,1,n,L[i],R[i],i);\n\tfor(int i=1;i<=n;++i)dis[i]=0x7f7f7f7f;\n\tQ[++t]=1;\n\tdis[1]=0;\n\twhile(h<t){\n\t\t++h;\n\t\tupd(1,1,n,Q[h],dis[Q[h]]+1);\n\t}\n\tfor(int i=1;i<n;++i)amn.st[i][0]=dis[i];\n\tamn.init();\n\tfor(int i=1;i<=1000000;++i)vec[i].clear();\n\tfor(int i=1;i<=n;++i)add(1,1,n,a[i],a[i],i);\n\th=t=0;\n\tfor(int i=1;i<=n;++i)ans[i]=-1;\n\tQ[++t]=1;\n\tans[1]=0;\n\twhile(h<t){\n\t\t++h;\n\t\tupd2(1,1,n,Q[h],ans[Q[h]]+1);\n\t}\n\t// for(int i=1;i<=n;++i)printf(""%d "",ans[i]);putchar(\'\\n\');\n\tfor(int i=1;i<=1000000;++i)vec[i].clear();\n\tfor(int i=1;i<n-1;++i){\n\t\tint L=mn[0].query(1,i),R=-mx[0].query(1,i);\n\t\tint mn=amn.query(L,R);\n\t\tif(mn==0x7f7f7f7f)f[i]=-1;\n\t\telse{\n\t\t\t++mn;\n\t\t\tint now=getans(1,i,mn);\n\t\t\t// printf(""%d %d %d\\n"",i,now,mn);\n\t\t\tf[i]=-1;\n\t\t\tg[i]=mn;\n\t\t\tadd(1,1,n,now,now,i);\n\t\t}\n\t}\n\th=t=0;\n\tQ[++t]=n-1;\n\tf[n-1]=0;\n\twhile(h<t){\n\t\t++h;\n\t\t// printf(""%d\\n"",Q[h]);\n\t\tupd3(1,1,n,Q[h],f[Q[h]]);\n\t}\n\t// for(int i=1;i<n;++i)printf(""%d "",f[i]);putchar(\'\\n\');\n\tfor(int i=1,l,r;i<=q;++i){\n\t\tscanf(""%d%d"",&l,&r);\n\t\tif(l==r){\n\t\t\tif(n==1)puts(""0"");\n\t\t\telse puts(""-1"");\n\t\t}\n\t\telse{\n\t\t\tint mn=amn.query(l,r-1);\n\t\t\t// printf(""%d\\n"",mn);\n\t\t\tif(mn==0x7f7f7f7f)puts(""-1"");\n\t\t\telse{\n\t\t\t\tint now=getans(l,r-1,mn);\n\t\t\t\t// printf(""%d\\n"",now);\n\t\t\t\tif(f[now]==-1)puts(""-1"");\n\t\t\t\telse printf(""%d\\n"",mn+f[now]);\n\t\t\t}\n\t\t}\n\t}\n}']",,,"['binary search', 'data structures']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Replace.json,https://codeforces.com//blog/entry/104930,Let be the replace function That means means applying the function times When Let then and So and That means so When it can be similarly proved that if then And we also know that if then then So we know So We can use to easily get in at first then we can calculate in Use binary search we can get answer in So the time complexity is We can use BIT instead of segment tree to make our program run faster 
https://codeforces.com//contest/1677/problem/B,1392745,B,1677B,1677,B. Tokitsukaze and Meeting,Tokitsukaze is arranging a meeting There are n rows and m columns of seats in the meeting hall There are exactly n cdot m students attending the meeting including several naughty students and several serious students The students are numerated from 1 to n cdot m The students will enter the meeting hall in order When the i th student enters the meeting hall he will sit in the 1 st column of the 1 st row and the students who are already seated will move back one seat Specifically the student sitting in the j th 1 leq j leq m 1 column of the i th row will move to the j 1 th column of the i th row and the student sitting in m th column of the i th row will move to the 1 st column of the i 1 th row For example there is a meeting hall with 2 rows and 2 columns of seats shown as below There will be 4 students entering the meeting hall in order represented as a binary string of which represents naughty students and represents serious students The changes of seats in the meeting hall are as follows Denote a row or a column good if and only if there is at least one serious student in this row or column Please predict the number of good rows and columns just after the i th student enters the meeting hall for all i ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tstring s;cin>>s;\n\tvi base(n*m),sum(n*m);\n\tvi has(m);\n\tint pre=-inf;\n\trep(i,si(s))if(s[i]==\'1\'){\n\t\tif(!has[i%m]){\n\t\t\tbase[i]++;\n\t\t\thas[i%m]=1;\n\t\t}\n\t\tint dif=min(i-pre,m);\n\t\trng(j,i+m-dif,min(n*m,i+m))sum[j]++;\n\t\tpre=i;\n\t}\n\trep(i,n*m-1)base[i+1]+=base[i];\n\trep(i,n*m-m)sum[i+m]+=sum[i];\n\trep(i,n*m)base[i]+=sum[i];\n\tprint(base);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['data structures', 'implementation', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Tokitsukaze and Meeting.json,https://codeforces.com//blog/entry/102631,Tutorial Obviously we can calculate the answers of rows and columns separately For the answers of columns we can observe that since there are only students in total no students will leave and every time a new student entering the meeting hall all columns will move one step to the right circularly so the answer will not decrease If the th student is a serious student for all the previous students with subscript where and are naughty students the answer in the column will increase by For the answer of rows we can transfer it from the answer of which is equivalent to adding a new row to the answer of Suppose the last serious student is the th student If the answer will increase by otherwise the answer will be the same as that of when the student enters the meeting hall 
https://codeforces.com//contest/1542/problem/E1,1034813,E1,1542E1,1542,E1. Abnormal Permutation Pairs  easy version ,A permutation of 1 2 ldots n is a sequence of n integers where each integer from 1 to n appears exactly once For example 2 3 1 4 is a permutation of 1 2 3 4 but 1 4 2 2 isn t because 2 appears twice in it Recall that the number of inversions in a permutation a 1 a 2 ldots a n is the number of pairs of indices i j such that i j and a i a j Let p and q be two permutations of 1 2 ldots n Find the number of permutation pairs p q that satisfy the following conditions p is lexicographically smaller than q the number of inversions in p is greater than the number of inversions in q Print the number of such pairs modulo mod Note that mod may not be a prime ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nint MOD;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=505,MAXM=500005;\n\nint n;\nint s[MAXM],f[MAXN],d[MAXM],g[MAXM],h[MAXM];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\treadint(n),readint(MOD);\n\ts[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=1ll*i*f[i-1]%MOD;\n\t\tg[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)g[j]=(g[j-1]+1ll*s[j]*(j+1))%MOD;\n\t\th[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)h[j]=dmy(h[j-1]+s[j]);\n\t\tfor(int j=0;j<=(i-1)*(i-2)/2;j++)\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tif(j>=2)inc(tmp,g[j-2]),inc(tmp,MOD-1ll*(j-i+MOD)*h[j-2]%MOD);\n\t\t\tif(j-i-1>=0)inc(tmp,MOD-g[j-i-1]),inc(tmp,1ll*(j-i+MOD)*h[j-i-1]%MOD);\n\t\t\tinc(f[i],1ll*d[j]*tmp%MOD);\n\t\t}\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)d[j]=0;\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)\n\t\t{\n\t\t\td[j]=s[j];\n\t\t\tif(j>=i)inc(d[j],MOD-s[j-i]);\n\t\t}\n\t\ts[0]=d[0];\n\t\tfor(int j=1;j<=i*(i+1)/2;j++)s[j]=dmy(s[j-1]+d[j]);\n\t}\n\tprintf(""%d\\n"",f[n]);\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'fft', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Abnormal Permutation Pairs  easy version .json,https://codeforces.com//blog/entry/92492,Let s first calculate the number of permutation pair p q s with length i that p1 q1 but inv p inv q inv p is the number of inversions in p Call it ti Let s enumerate p1 j and q1 k then inv p 2 i inv q 2 i k j inv p inv p 2 i j 1 inv q inv q 2 i k 1 with inv p inv q we get the following Precalculate f i j the number of permutation p s of length i such that inv p j Let s i j be k jf i k then ti 1 j i j k i wf i 1 w s i 1 w k j 1 f and s can be calculated in O n4 or O n3 in the following way if you insert i into a permutation of length i 1 after the i 1 p th element 0 p i 1 it will bring p inversions into the permutation So f i j j i 1 k jf i 1 k After calculating t calculating the answer it easy Let ansi be the answer for n i then ansi i ansi 1 ti Consider if p1 q1 If so there are i choices of p1 and ansi 1 choices of the following n 1 numbers Otherwise there are ti choices Total complexity is O n5 but it can be optimized to O n4 if you consider the difference between j k only and can be optimized to O n3logn using FFT with arbitary mod which we hope can t pass E2 
https://codeforces.com//contest/1929/problem/F,2478908,F,1929F,1929,F. Sasha and the Wedding Binary Search Tree,Having overcome all the difficulties and hardships Sasha finally decided to marry his girlfriend To do this he needs to give her an engagement ring However his girlfriend does not like such romantic gestures but she does like binary search trees dagger So Sasha decided to give her such a tree After spending a lot of time on wedding websites for programmers he found the perfect binary search tree with the root at vertex 1 In this tree the value at vertex v is equal to val v But after some time he forgot the values in some vertices Trying to remember the found tree Sasha wondered how many binary search trees could he have found on the website if it is known that the values in all vertices are integers in the segment 1 C Since this number can be very large output it modulo 998 244 353 dagger A binary search tree is a rooted binary tree in which for any vertex x the following property holds the values of all vertices in the left subtree of vertex x if it exists are less than or equal to the value at vertex x and the values of all vertices in the right subtree of vertex x if it exists are greater than or equal to the value at vertex x ,"['#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint tl[500005],tr[500005],val[500005];\nint zh[500005],cnt;\nint ny[500005];\nvoid dfs(int x)\n{\n\tif(x==-1)return;\n\tdfs(tl[x]);\n\tzh[++cnt]=val[x];\n\tdfs(tr[x]);\n}\nint main()\n{\n\tny[1]=1;\n\tfor(int i=2;i<=500000;i++)ny[i]=1LL*(mod-mod/i)*ny[mod%i]%mod;\n\tint t,n,c;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tc=read();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ttl[i]=read();\n\t\t\ttr[i]=read();\n\t\t\tval[i]=read();\n\t\t}\n\t\tcnt=0;\n\t\tdfs(1);\n\t\t//for(int i=1;i<=cnt;i++)printf(""%d "",zh[i]);\n\t\t//printf(""\\n"");\n\t\tint pre=1,xb=0,ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(zh[i]!=-1)\n\t\t\t{\n\t\t\t\tint sx=zh[i]-pre+i-xb-1;\n\t\t\t\tfor(int j=1;j<=i-xb-1;j++)\n\t\t\t\t{\n\t\t\t\t\tans=1LL*ans*(sx+mod-j+1)%mod*ny[j]%mod;\n\t\t\t\t}\n\t\t\t\tpre=zh[i];\n\t\t\t\txb=i;\n\t\t\t}\n\t\t}\n\t\tif(xb!=n)\n\t\t{\n\t\t\tint sx=c-pre+n-xb;\n\t\t\tfor(int j=1;j<=n-xb;j++)\n\t\t\t{\n\t\t\t\tans=1LL*ans*(sx+mod-j+1)%mod*ny[j]%mod;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n}\n']",,,"['brute force', 'combinatorics', 'data structures', 'dfs and similar', 'math', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Sasha and the Wedding Binary Search Tree.json,https://codeforces.com//blog/entry/125943,Let s list the numbers of vertices in the order of their values Let it be v1 vn Then it must satisfy valuevi valuevi 1 Then we have some segments in this order for which we do not know the values For each segment we know the maximum and minimum value that the values in this segment can take let s say L and R Then we need to choose a value from the interval L R for each number in this segment in order to maintain the relative order This is a known problem and there are R L lenlen possible ways to do this where len is the length of the segment Then we need to multiply all these binomial coefficients Now notice that R L len is large so for calculation we can simply use the formula nk n n 1 n k 1 k since the sum len does not exceed n 
https://codeforces.com//contest/1743/problem/D,1590319,D,1743D,1743,D. Problem with Random Tests,You are given a string s consisting of n characters Each character of s is either or A substring of s is a contiguous subsequence of its characters You have to choose two substrings of s possibly intersecting possibly the same possibly non intersecting just any two substrings After choosing them you calculate the value of the chosen pair of substrings as follows let s 1 be the first substring s 2 be the second chosen substring and f s i be the integer such that s i is its binary representation for example if s i is f s i 26 the value is the of f s 1 and f s 2 Calculate the maximum possible value you can get and print it ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::string s;\n    std::cin >> s;\n    \n    if (s.find(\'1\') == std::string::npos) {\n        std::cout << 0 << ""\\n"";\n        return 0;\n    }\n    \n    int a = s.find(\'1\');\n    \n    if (s.substr(a).find(\'0\') == std::string::npos) {\n        std::cout << s.substr(a) << ""\\n"";\n        return 0;\n    }\n    \n    int b = a + s.substr(a).find(\'0\');\n    \n    auto ans = s;\n    \n    for (int i = 0; i <= b - a; i++) {\n        auto res = s;\n        for (int j = 0; j + i < n; j++) {\n            res[j + i] |= s[j];\n        }\n        ans = std::max(ans, res);\n    }\n    ans = ans.substr(ans.find(\'1\'));\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']",,,"['brute force', 'dp', 'greedy', 'probabilities']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Problem with Random Tests.json,https://codeforces.com//blog/entry/108153,The first observation we need is that we can choose two prefixes of as the substrings used in forming the results This can be proved easily suppose we chose a substring which does not contain the leftmost character of if we expand it to the left the answer won t become worse So it is optimal to choose two prefixes of as the substrings Furthermore one of these prefixes must be itself if the leftmost index of is the length of the answer won t exceed but the only way to have a in the th bit of the answer is to choose a prefix of where the th character from the right is and there is only one such prefix of which is itself So now we can solve the problem in try to combine all prefixes of with itself and choose the one that yields the best answer To speed this up we need to somehow cut down on the number of prefixes of we check Let s look at the first block of s in The next character after this block is since we take as one of the substring in order to get instead of in the corresponding position of the answer we need to choose a prefix which has in that position This represents one of the s from the first block of s since only one of them can shift to that position So we need to check only the prefixes such that by using them we shift some character from the first block to the position of the first after this block Since the tests are random the expected length of the first block of s is furthermore even the probabiliy that its length is or bigger is about so the expected number of prefixes we need to check is also Thus the expected runtime of our solution is 
https://codeforces.com//contest/1312/problem/C,557979,C,1312C,1312,C. Adding Powers,Suppose you are performing the following algorithm There is an array v 1 v 2 dots v n filled with zeroes at start The following operation is applied to the array several times at i th step 0 indexed you can either choose position pos 1 le pos le n and increase v pos by k i or not choose any position and skip this step You can choose how the algorithm would behave on each step and when to stop it The question is can you make array v equal to the given array a v j a j for each j after some step ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 65;\nbool ok[maxN][maxN];\nint k;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n;\n        cin >> n >> k;\n        memset(ok, 0, sizeof ok);\n        bool can = true;\n        for (int i = 1; i <= n; i++) {\n            ll x;\n            cin >> x;\n            for (int pos = 0; pos < maxN; pos++) {\n                int t = x % k;\n                x /= k;\n                if (t > 1) {\n                    can = false;\n                }\n                else if (t == 1) {\n                    if (ok[pos][t]) can = false;\n                    ok[pos][t] = true;\n                }\n            }\n        }\n        if (can) cout << ""YES\\n"";\n        else cout << ""NO\\n"";\n    }\n    return 0;\n}']",,,"['bitmasks', 'greedy', 'implementation', 'math', 'number theory', 'ternary search']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Adding Powers.json,https://codeforces.com//blog/entry/74640,This is the solution that doesn t involve masks Let s reverse the process and try to get all zeroes from the array since all we can start from maximum The key idea since then there should be no more than one position such that and we should decrease it by Now we can decrease by and repeat the same process If at any step there are at least two or as result we won t get array filled with then there is no way to build the array 
https://codeforces.com//contest/1859/problem/E,2156545,E,1859E,1859,E. Maximum Monogonosity,You are given an array a of length n and an array b of length n The of a segment l r 1 le l le r le n is defined as b l a r b r a l Recall that two segments l 1 r 1 1 le l 1 le r 1 le n and l 2 r 2 1 le l 2 le r 2 le n are non intersecting if one of the following conditions is satisfied r 1 l 2 or r 2 l 1 The length of a segment l r 1 le l le r le n is defined as r l 1 Find the maximum possible sum of costs of non intersecting segments l j r j 1 le l j le r j le n whose total length is equal to k ,"['#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nint a[3005],b[3005];\nint dp[3005][3005][5];\nsigned main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tint n,k; cin>>n>>k;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=1;i<=n;i++) cin>>b[i];\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=3000;j++) for(int l=0;l<5;l++) dp[i][j][l]=-1e18;\n\t\tdp[0][0][0]=0; \n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<=k;j++){\n\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\tif(l==0){\n\t\t\t\t\t\tdp[i][j][0]=max(dp[i][j][0],dp[i-1][j][l]);\n\t\t\t\t\t\tdp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+llabs(a[i]-b[i])*2);\n\t\t\t\t\t\tdp[i][j+1][1]=max(dp[i][j+1][1],dp[i-1][j][l]+a[i]+b[i]);\n\t\t\t\t\t\tdp[i][j+1][2]=max(dp[i][j+1][2],dp[i-1][j][l]+a[i]-b[i]);\n\t\t\t\t\t\tdp[i][j+1][3]=max(dp[i][j+1][3],dp[i-1][j][l]-a[i]+b[i]);\n\t\t\t\t\t\tdp[i][j+1][4]=max(dp[i][j+1][4],dp[i-1][j][l]-a[i]-b[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j+1][l]=max(dp[i][j+1][l],dp[i-1][j][l]);\n\t\t\t\t\t\tif(l==1) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]-a[i]-b[i]);\n\t\t\t\t\t\tif(l==2) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+a[i]-b[i]);\n\t\t\t\t\t\tif(l==3) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]-a[i]+b[i]);\n\t\t\t\t\t\tif(l==4) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+a[i]+b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n][k][0]<<""\\n"";\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'dp', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Maximum Monogonosity.json,https://codeforces.com//blog/entry/119287,TutorialLet s call the value of a segment Let s write maximum value of segments of total length that end before The obvious way to recalc is the following This works in and is too slow Now let s consider the following instead of getting the absolute value of segment we consider the maximum of the following four combinations We can see that this always gives us the correct answer to the absolute value since we check all of the possibilities Now we can look at out dp states as a table and notice that we recalc over the diagonal we recalc over all states that have the same value of n1 k1 Now for each diagonal we maintain four maximum combinations and when we want to recalc state we just consider all of the four possibilities 
https://codeforces.com//contest/1927/problem/G,2464700,G,1927G,1927,G. Paint Charges,A horizontal grid strip of n cells is given In the i th cell there is a paint charge of size a i This charge can be either used to the left then all cells to the left at a distance less than a i from max i a i 1 1 to i inclusive will be painted or used to the right then all cells to the right at a distance less than a i from i to min i a i 1 n inclusive will be painted or not used at all Note that a charge can be used no more than once that is it be used simultaneously to the left and to the right It is allowed for a cell to be painted more than once What is the minimum number of times a charge needs to be used to paint all the cells of the strip ,"['// LUOGU_RID: 146673924\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint tt;\nint n,a[101];\nint f[2][105][105];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin>>tt;\n\twhile(tt--){\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\tf[0][i][j]=f[1][i][j]=n+1;\n\t\t\t}\n\t\t}\n\t\tf[0][0][1]=0;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\tint S=p&1,S_=S^1;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(f[S_][i][j]==n+1) continue;\n//\t\t\t\t\tcout<<i<<\' \'<<j<<\' \'<<p<<"" ""<<f[i][j]<<\':\'<<\'\\n\';\n\t\t\t\t\tint lim=max(p-a[p]+1,1ll);\n\t\t\t\t\tif(j>=lim) f[S][max(i,p)][max(i,p)+1]=min(f[S][max(i,p)][max(i,p)+1],f[S_][i][j]+1);\n//\t\t\t\t\tcout<<f[max(i,p)][p+1]<<\' \'<<max(i,p)<<\' \'<<p+1<<\'\\n\';\n\t\t\t\t\tlim=min(n,p+a[p]-1);\n\t\t\t\t\tint t=max(lim,i);\n\t\t\t\t\tif(j<p){\n\t\t\t\t\t\tf[S][t][j]=min(f[S][t][j],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<\'*\'<<f[t][j]<<\' \'<<t<<\' \'<<j<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tf[S][t][t+1]=min(f[S][t][t+1],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<f[t][t+1]<<\' \'<<t<<\' \'<<t+1<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tf[S][i][j]=min(f[S][i][j],f[S_][i][j]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif(p==6) cout<<f[S][10][1]<<\'\\n\';\n\t\t}\n\t\tcout<<min(f[0][n][n+1],f[1][n][n+1])<<\'\\n\';\n\t}\n}']",,,"['data structures', 'dp', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Paint Charges.json,https://codeforces.com//blog/entry/125597,Let s use the method of dynamic programming Let be the minimum number of operations required for the distance from to the farthest unpainted cell on the left to be and to the nearest unpainted cell on the right to be including itself We will update the values forward that is for all reachable states we will find the states reachable from it and update the answer for them In this case we will move from the current to recalculating and depending on the action not spraying paint from spraying paint from to the left spraying paint from to the right The problem could also have been solved in however the constraints did not require this 
https://codeforces.com//contest/1872/problem/E,2198224,E,1872E,1872,E. Data Structures Fan,You are given an array of integers a 1 a 2 ldots a n as well as a binary string dagger s consisting of n characters Augustin is a big fan of data structures Therefore he asked you to implement a data structure that can answer q queries There are two types of queries 1 l r 1 le l le r le n replace each character s i for l le i le r with its opposite That is replace all texttt 0 with texttt 1 and all texttt 1 with texttt 0 2 g g in 0 1 calculate the value of the bitwise XOR of the numbers a i for all indices i such that s i g Note that the operatorname XOR of an empty set of numbers is considered to be equal to 0 Please help Augustin to answer all the queries For example if n 4 a 1 2 3 6 s texttt 1001 consider the following series of queries 2 0 we are interested in the indices i for which s i tt 0 since s tt 1001 these are the indices 2 and 3 so the answer to the query will be a 2 oplus a 3 2 oplus 3 1 1 1 3 we need to replace the characters s 1 s 2 s 3 with their opposites so before the query s tt 1001 and after the query s tt 0111 2 1 we are interested in the indices i for which s i tt 1 since s tt 0111 these are the indices 2 3 and 4 so the answer to the query will be a 2 oplus a 3 oplus a 4 2 oplus 3 oplus 6 7 1 2 4 s tt 0111 to s tt 0000 2 1 s tt 0000 there are no indices with s i tt 1 so since the operatorname XOR of an empty set of numbers is considered to be equal to 0 the answer to this query is 0 dagger A binary string is a string containing only characters texttt 0 or texttt 1 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\n#define pll pair<ll,ll>\n\nstruct SEG {\n    vector<pll> arr;\n    vector<bool> tswap;\n\n    void make(ll n) {\n        arr.resize(4*n);\n        tswap.resize(4*n);\n    }\n\n    void pull(ll v) {\n        arr[v] = arr[v*2];\n        arr[v].first ^= arr[v*2+1].first;\n        arr[v].second ^= arr[v*2+1].second;\n    }\n\n    void dswap(ll v) {\n        tswap[v] = !tswap[v];\n        swap(arr[v].first, arr[v].second);\n    }\n\n    void push(ll v) {\n        if (tswap[v]) {\n            dswap(v*2);\n            dswap(v*2+1);\n            tswap[v] = 0;\n        }\n    }\n\n    void set(ll v, ll tl, ll tr, ll ind, pll val) {\n        if (tl == tr) {\n            arr[v] = val;\n            return;\n        }\n        ll tm = (tl + tr) / 2;\n        if (ind <= tm)\n            set(v*2, tl, tm, ind, val);\n        else set(v*2+1, tm+1, tr, ind, val);\n        pull(v);\n    }\n\n    void rswap(ll v, ll tl, ll tr, ll l, ll r) {\n        if (l > r) return;\n        if (tl == l && tr == r) {\n            dswap(v);\n            return;\n        }\n        push(v);\n        ll tm = (tl + tr) / 2;\n        rswap(v*2, tl, tm, l, min(r, tm));\n        rswap(v*2+1, tm+1, tr, max(l,tm+1), r);\n        pull(v);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        SEG seg;\n        seg.make(n);\n        for (ll i = 0; i < n; i++) {\n            ll v;\n            cin >> v;\n            seg.set(1, 0, n-1, i, {v, 0});\n        }\n        for (ll i = 0; i < n; i++) {\n            char c;\n            cin >> c;\n            if (c == '1') seg.rswap(1, 0, n-1, i, i);\n        }\n        ll q;\n        cin >> q;\n        while (q--) {\n            ll t;\n            cin >> t;\n            if (t == 1) {\n                ll l, r;\n                cin >> l >> r;\n                seg.rswap(1, 0, n-1, l-1, r-1);\n            } else {\n                ll g;\n                cin >> g;\n                if (g == 0) {\n                    cout << seg.arr[1].first << ' ';\n                } else {\n                    cout << seg.arr[1].second << ' ';\n                }\n            }\n        }\n        cout << '\\n';\n    }\n}""]",,,"['binary search', 'bitmasks', 'data structures', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Data Structures Fan.json,https://codeforces.com//blog/entry/120165,Of course this problem has solutions that use data structures For example you can use a segment tree with range updates to solve it in time or you can use a square root decomposition to solve it in time However of course we do not expect participants in Div3 to have knowledge of these advanced data structures so there is a simpler solution We will store 2 variables which represent the XOR of all numbers from group and group respectively When answering a query of type 2 we will simply output either or Now we need to understand how to update and after receiving a query of type 1 Let s first solve a simplified version suppose that in type 1 queries only a single character of the string is inverted i e in all type 1 queries Let s see how and change after this query If was and became then the number will be removed from group So we need to invert XOR from Since XOR is its own inverse operation we can do this with And in we need to add the number since now And we can do this with The same thing happens if was This is the key observation when we invert and change in the same way regardless of whether this inversion was from to or from to Therefore to update and after a query of type 1 with parameters we need to do this and the same for To quickly find the XOR value on a subsegment of the array we can use a prefix XOR array If then 
https://codeforces.com//contest/790/problem/D,98952,D,790D,790,D. Bear and Rectangle Strips,Limak has a grid that consists of rows and columns The th cell in the th row contains an integer which can be positive negative or zero A non empty rectangle of cells is called if and only if the sum of numbers in its cells is equal to Limak wants to choose some nice rectangles and give them to his friends as gifts No two chosen rectangles should share a cell What is the maximum possible number of nice rectangles Limak can choose ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 3e5 + 10;\nint a[2][maxn];\nint n;\n\nint read() {\n  if (scanf(""%d"", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < n; ++j) {\n      scanf(""%d"", a[i] + j);\n    }\n  }\n  return 1;\n}\n\nint go[3][maxn];\n\nint ans[maxn];\n\nvector<pair<int, int> > toup[maxn][2];\n\nvoid mmax(int &x, int y) {\n  x = max(x, y);\n}\n\nvoid process(int s, int t, int val) {\n  mmax(ans[max(s, t)], val);\n\n  for (int j = 0; j < 3; ++j) {\n    int from = (!j ? s : (j == 1 ? t : max(s, t)));\n    from = go[j][from];\n    if (from > n) {\n      continue;\n    }\n    int ns = s, nt = t;\n    if (j != 1) {\n      ns = from;\n    }\n    if (j != 0) {\n      nt = from;\n    }\n\n    mmax(ans[max(ns, nt)], val + 1);\n    if (ns < nt) {\n      toup[ns][1].pb(mp(val + 1, nt));\n    }\n    if (nt < ns) {\n      toup[nt][0].pb(mp(val + 1, ns));\n    }\n  }\n}\n\nvoid solve() {\n  for (int iter = 0; iter < 3; ++iter) {\n    go[iter][n] = n + 1;\n    map<long long, int> last;\n\n    long long sum = 0;\n    last[sum] = n;\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = 0; j < 2; ++j) {\n        if ((iter + 1) & (1 << j)) {\n          sum += a[j][i];\n        }\n      }\n      auto &cur = go[iter][i];\n      cur = go[iter][i + 1];\n      auto iter = last.find(sum);\n      if (iter != last.end()) {\n        int pos = iter->second;\n        cur = min(cur, pos);\n      }\n      last[sum] = i;\n    }\n  }\n\n  for (int i = 0; i <= n; ++i) {\n    ans[i] = 0;\n    toup[i][0].clear();\n    toup[i][1].clear();\n  }\n\n  for (int i = 0; i < n; ++i) {\n    process(i, i, ans[i]);\n\n    for (int j = 0; j < 2; ++j) {\n      int best = n + 1;\n      for (auto p : toup[i][j]) {\n        if (p.first == ans[i] + 1) {\n          best = min(best, p.second);\n        }\n      }\n      if (best > n) {\n        continue;\n      }\n\n      int s = i, t = best;\n      if (!j) {\n        swap(s, t);\n      }\n      process(s, t, ans[i] + 1);\n    }\n  }\n\n  int res = *max_element(ans, ans + n + 1);\n  printf(""%d\\n"", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK "".out"", ""w"", stdout);\n  assert(freopen(TASK "".in"", ""r"", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""Time %.2f\\n"", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']",,,['dp'],3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Bear and Rectangle Strips.json,https://codeforces.com//blog/entry/51068,There are three types of rectangles in the top row in the bottom row and in both rows with height 2 For each type and for each starting index i we can quite easily find the first possible ending index it s the first index on the right with the same prefix sum of numbers it means that the difference of prefix sums is 0 We can iterate from right to left for each of three types use store prefix sums in the set and for each type and each starting index we can remember the first possible ending index or we will know that there is no such index The complexity of this part is Now the naive square solution would be to create an array dp n n and compute dp i j as the maximum possible score if we are allowed to use only first i cells in the first row and first j cells in the second row Thanks to the precomputing above we can move from a state in O 1 considering the following options increase i by 1 without taking any rectangle increase j by 1 take the first possible rectangle in the first row check what is the first possible ending index of a rectangle in the first row starting at index i 1 take the first possible rectangle in the second row if i j also consider taking first possible rectangle of height 2 in both rows Now let s improve this part to O n Let Ci denote the best score if we were allowed to use only first i cells in each row Ci dp i i It turns out that the following values for each i are enough to solve the problem Ci If we were allowed to use only first i cells in the first row how far we must go in the second row in order to get the score Ci 1 In other words what is the smallest j such that dp i j Ci 1 Similarly the smallest j such that dp j i Ci 1 Take a look at the drawings below The value Ci is the maximum possible score for light blue cells on the left drawing The right drawing shows the third of situation listed above we want to know what prefix of cells in the first row is needed if we want to get the score Ci 1 To see that it works we must prove that we don t have to care how far we must go in one row to get the score Ci 2 or higher The crucial observation that getting score at least Ci 2 means that we took at least two rectangles that are at least partially on the right from index i i e each of them contains at least one cell with index greater than i see the drawing below So instead of considering this situation now we can first take some rectangle in the second row or skip a few cells because we can take that last rectangle in the first row later In other words when we are in the state dp i j where i j it s enough to consider taking a rectangle in the first row or just increasing i without taking anything 
https://codeforces.com//contest/1299/problem/C,536065,C,1299C,1299,C. Water Balance,There are n water tanks in a row i th of them contains a i liters of water The tanks are numbered from 1 to n from left to right You can perform the following operation choose some subsegment l r 1 le l le r le n and redistribute water in tanks l l 1 dots r evenly In other words replace each of a l a l 1 dots a r by frac a l a l 1 dots a r r l 1 For example if for volumes 1 3 6 7 you choose l 2 r 3 new volumes of water will be 1 4 5 4 5 7 What is the lexicographically smallest sequence of volumes of water that you can achieve As a reminder A sequence a is lexicographically smaller than a sequence b of the same length if and only if the following holds in the first leftmost position where a and b differ the sequence a has a smaller element than the corresponding element in b ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010000;\nint n,a[N],t;\nPII st[N];\nll s[N];\ndb sval[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",a+i);\n\t\ts[i]=s[i-1]+a[i];\n\t}\n\trep(i,1,n+1) {\n\t\tdb val=a[i];\n\t\tPII pr=mp(i,i);\n\t\twhile (t>0&&sval[t-1]>val) {\n\t\t\t--t;\n\t\t\tval=1.*(s[i]-s[st[t].fi-1])/(i-st[t].fi+1);\n\t\t\tpr=mp(st[t].fi,i);\n\t\t}\n\t\tsval[t]=val;\n\t\tst[t]=pr;\n\t\tt++;\n\t}\n\trep(i,0,t) rep(j,st[i].fi,st[i].se+1) printf(""%.10f\\n"",sval[i]);\n}\n']",,,"['data structures', 'geometry', 'greedy']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Water Balance.json,https://codeforces.com//blog/entry/73763,Let s try to make the operation simpler When we apply the operation only the sum of the segment matters And so let s instead define the operation on prefix sum array Replace each of by You may see how similar it is to a line function Hence we get the idea to plot points included and our operation is just drawing a line between points on integer coordinates Nicely if sequence is lexicographically smaller than sequence then prefix sum array of is smaller than prefix sum array of So we need to find the lexicographically smallest array And then it is easy to see the lexicographically smallest sequence will be the lower part of the convex hull If you re interested you can solve IMO 2018 SL A4 by plotting similar points I have written my solutionhere 
https://codeforces.com//contest/967/problem/B,179482,B,967B,967,B. Watering System,Arkady wants to water his only flower Unfortunately he has a very poor watering system that was designed for n flowers and so it looks like a pipe with n holes Arkady can only use the water that flows from the first hole Arkady can block some of the holes and then pour A liters of water into the pipe After that the water will flow out from the non blocked holes proportionally to their sizes s 1 s 2 ldots s n In other words if the sum of sizes of non blocked holes is S and the i th hole is not blocked frac s i cdot A S liters of water will flow out of it What is the minimum number of holes Arkady should block to make at least B liters of water flow out of the first hole ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,u,v,a[120000];\n\nint main(){\n\tscanf(""%d%d%d"",&n,&u,&v);\n\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i);\n\tsort(a+2,a+n+1);\n\tlong long sum=a[1];\n\tfor(int i=2;i<=n;i++){\n\t\tsum+=a[i];\n\t\tif(sum*v>(long long)a[1]*u){\n\t\t\tprintf(""%d\\n"",n-i+1);return 0;\n\t\t}\n\t}\n\tputs(""0"");\n\treturn 0;\n}']",,,"['math', 'sortings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Watering System.json,https://codeforces.com//blog/entry/59173,It s obvious that we should block several largest holes Let s first sort them After that let s iterate through the number of blocked holes maintaining the sum of sizes of non blocked holes With the value it is easy to compute if the flow from the first hole is large enough or not Just output the number of blocked pipes at the first moment when the flow is large enough The complexity is 
https://codeforces.com//contest/1327/problem/F,571329,F,1327F,1327,F. AND Segments,You are given three integers n k m and m conditions l 1 r 1 x 1 l 2 r 2 x 2 dots l m r m x m Calculate the number of distinct arrays a consisting of n integers such that 0 le a i 2 k for each 1 le i le n bitwise AND of numbers a l i a l i 1 dots a r i x i for each 1 le i le m Two arrays a and b are considered different if there exists such a position i that a i neq b i The number can be pretty large so print it modulo 998244353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=501000;\nint n,k,m,cnt[N],ss[N];\nll dp[N],ans=1;\nVI l[N];\nll solve(vector<PII> f,vector<int> g) {\n\tint m=SZ(g);\n\trep(i,1,n+1) ss[i]=0;\n\tfor (auto x:g) ss[x]++;\n\trep(i,1,n+1) ss[i]+=ss[i-1];\n\trep(i,0,SZ(f)) {\n\t\tf[i].fi=ss[f[i].fi-1]+1;\n\t\tf[i].se=ss[f[i].se];\n\t\tif (f[i].fi>f[i].se) return 0;\n\t}\n\trep(i,0,m+1) l[i].clear();\t\n\tfor (auto x:f) l[x.se].pb(x.fi);\n\tll sdp=1;\n\tdp[0]=1;\n\tint posl=0;\n\trep(i,1,m+1) {\n\t\tdp[i]=sdp; sdp=sdp*2%mod;\n\t\tint pr=posl;\n\t\tfor (auto x:l[i]) posl=max(posl,x);\n\t\trep(j,pr,posl) {\n\t\t\tsdp=(sdp-dp[j])%mod;\n\t\t\tdp[j]=0;\n\t\t}\n\t\t//rep(j,0,m+1) printf(""%lld "",dp[j]); puts("""");\n\t}\n\tif (sdp<0) sdp+=mod;\n\treturn sdp;\n}\n\nint pl[N],pr[N],x[N];\nint main() {\n\tscanf(""%d%d%d"",&n,&k,&m);;\n\trep(i,0,m) scanf(""%d%d%d"",pl+i,pr+i,x+i);\n\trep(j,0,k) {\n\t\tvector<int> g;\n\t\tvector<PII> cs;\n\t\trep(i,1,n+1) cnt[i]=0;\n\t\trep(i,0,m) {\n\t\t\tif (x[i]&(1<<j)) {\n\t\t\t\tcnt[pl[i]]++; cnt[pr[i]+1]--;\n\t\t\t} else cs.pb(mp(pl[i],pr[i]));\n\t\t}\n\t\trep(i,1,n+1) cnt[i]+=cnt[i-1];\n\t\trep(i,1,n+1) if (cnt[i]==0) g.pb(i);\n\t\tans=ans*solve(cs,g)%mod;\n\t}\n\tprintf(""%lld\\n"",ans);\n}']",,,"['bitmasks', 'combinatorics', 'data structures', 'dp', 'two pointers']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. AND Segments.json,https://codeforces.com//blog/entry/75147,We will solve the problem for each bit separately and then multiply the results Obviously if the position is covered by a segment with the value 1 then we have no choice and we must put 1 there For segments with the value 0 there must be at least one position that they cover and its value is 0 So we can write the following dynamic programming dp i the number of arrays such that the last 0 was exactly at the position i and all 0 segments to the left of it contain at least one zero It remains to determine which states j we can update from The only restriction we have is that there should not be any segment l r with the value 0 such that j l and r i Since in this case this segment will not contain any zero values For each position i we may precalculate the rightmost position f i where some segment ending before i begins and while calculating dp i we should sum up only the values starting from position f i This can be done with prefix sums 
https://codeforces.com//contest/1195/problem/A,373876,A,1195A,1195,A. Drinks Choosing,Old timers of Summer Informatics School can remember previous camps in which each student was given a drink of his choice on the vechorka late evening meal Or may be the story was more complicated There are n students living in a building and for each of them the favorite drink a i is known So you know n integers a 1 a 2 dots a n where a i 1 le a i le k is the type of the favorite drink of the i th student The drink types are numbered from 1 to k There are infinite number of drink sets Each set consists of portions of the same drink In other words there are k types of drink sets the j th type contains two portions of the drink j The available number of sets of each of the k types is infinite You know that students will receive the minimum possible number of sets to give all students exactly one drink Obviously the number of sets will be exactly lceil frac n 2 rceil where lceil x rceil is x rounded up After students receive the sets they will distribute their portions by their choice each student will get exactly one portion Note that if n is odd then one portion will remain unused and the students teacher will drink it What is the maximum number of students that can get their favorite drink if lceil frac n 2 rceil sets will be chosen optimally and students will distribute portions between themselves optimally ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint cnt[1005];\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n        int a;\n        cin >> a;\n        cnt[a]++;\n    }\n    int d = 0;\n    for (int i = 1; i <= k; i++) {\n        d += cnt[i] % 2;\n    }\n    cout << n - d/2 << endl;\n}']",,,"['greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Drinks Choosing.json,https://codeforces.com/blog/entry/68471,Let s take a look on a students If two students have the same favorite drink let s take one set with this drink Let the number of such students which we can satisfy as pairs be Because the number of sets is we always can do it So there are students which are the only with their favorite drinks remain It is obvious that if we take one set we can satisfy at most one student and one of the others will gain not his favorite drink Let the number of such students which remain after satisfying pairs of students be Then the answer is 
https://codeforces.com//contest/1288/problem/E,516091,E,1288E,1288,E. Messenger Simulator,Polycarp is a frequent user of the very popular messenger He s chatting with his friends all the time He has n friends numbered from 1 to n Recall that a permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array So his recent chat list can be represented with a permutation p of size n p 1 is the most recent friend Polycarp talked to p 2 is the second most recent and so on Initially Polycarp s recent chat list p looks like 1 2 dots n in other words it is an identity permutation After that he receives m messages the j th message comes from the friend a j And that causes friend a j to move to the first position in a permutation shifting everyone between the first position and the current position of a j by 1 Note that if the friend a j is in the first position already then nothing happens For example let the recent chat list be p 4 1 5 3 2 if he gets messaged by friend 3 then p becomes 3 4 1 5 2 if he gets messaged by friend 4 then p doesn t change 4 1 5 3 2 if he gets messaged by friend 2 then p becomes 2 4 1 5 3 For each friend consider all position he has been at in the beginning and after receiving each message Polycarp wants to know what were the minimum and the maximum positions ,"['//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 _y0\n#define kill _kill\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll btc = 30;\nconst ld eps = 1e-10;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 1e9 + 7; //(int)(1e9 + 7); //998244353;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n//constants\nconst int M = (int)(6e5 + 239);\nconst int N = (int)(1e3 + 239);\nconst int L = 20;\nconst int T = (1 << 20) + 239;\nconst int B = 500;\nconst int X = 8;\n\nint ans1[M], ans2[M], n, m, a[M], pos[M];\n\nint tree[M];\n\nvoid add(int i, int x)\n{\n    for (; i < n + m; i |= i + 1)\n        tree[i] += x;\n}\n\nint gett(int i)\n{\n    int ans = 0;\n    for (; i >= 0; i = (i & (i + 1)) - 1)\n        ans += tree[i];\n    return ans;\n}\n\nint32_t main()\n{\n#ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        ans1[i] = i;\n        ans2[i] = i;\n        pos[i] = i + m;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        cin >> a[i];\n        a[i]--;\n        ans1[a[i]] = 0;\n    }\n    for (int i = 0; i < n; i++)\n        add(pos[i], 1);\n    for (int i = 0; i < m; i++)\n    {\n        int p = a[i];\n        ans2[p] = max(ans2[p], gett(pos[p]) - 1);\n        add(pos[p], -1);\n        pos[p] = m - i - 1;\n        add(pos[p], 1);\n    }\n    for (int i = 0; i < n; i++)\n        ans2[i] = max(ans2[i], gett(pos[i]) - 1);\n    for (int i = 0; i < n; i++)\n        cout << ans1[i] + 1 << "" "" << ans2[i] + 1 << ""\\n"";\n    return 0;\n}']",,,['data structures'],2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Messenger Simulator.json,https://codeforces.com//blog/entry/73105,So I have two slightly different approaches to the problem There is a straightforward no brain one and a bit smarter one The minimum place is the same in both solutions For the th friend it s just if he never moves and otherwise Obtaining the maximum place is trickier For the first approach take a look what happens with some friend after he gets moved to the first position Or what s more useful what happens after he gets moved to the first position and before he gets moved again afterwards or the queries end Notice how every other friend is to the right of him initially Thus if anyone sends a message then the position of the friend increases by one However if that friend moves again nothing changes That should remind of a well known problem already You are just required to count the number of distinct values on some segments The constraints allow you to do whatever you want segtree with vectors in nodes Mo persistent segtree I hope ML is not too tight for that Unfortunately for each friend we have missed the part before his first move In that case for each you need to count the number of distinct values greater than as only friends with greater index will matter Luckily you can do it in a single BIT Let th its value be set to zero if the friend hasn t sent messages and one otherwise Let s process messages from left to right If the friend sends a message for the first time then update the BIT with in his index and update his answer with the suffix sum of values greater than his index Finally there are also friends who haven t sent messages at all As we have built the BIT already the only thing left is to iterate over these friends and update the answers for them with a suffix sum Overall complexity The attached solutions are and The second solution requires a small observation to be made Notice that for each friend you can only check his position right before his moves and at the end of the messages That works because the position can decrease only by his move so it s either increases or stays the same between the moves So let s learn to simulate the process quickly The process we are given requires us to move someone to the first position and then shift some friends Let s not shift And let s also reverse the list it s more convenient to append instead of prepending So initially the list is and the message moves a friend to the end of the list Allocate positions in a BIT for example Initially the first positions are taken the rest are free mark them with ones and zeroes respectively For each friend his position in this BIT is known initially they are because we reversed the list On the th message sent count the number of taken positions to the right of set in update and set in And don t forget to update each friend s maximum after all the messages are sent that is the number of taken positions to the right of his final one as well Overall complexity 
https://codeforces.com//contest/558/problem/C,31488,C,558C,558,C. Amr and Chemistry,Amr loves Chemistry and specially doing experiments He is preparing for a new interesting experiment Amr has different types of chemicals Each chemical has an initial volume of liters For this experiment Amr has to mix all the chemicals together but all the chemicals volumes must be equal first So his task is to make all the chemicals volumes equal To do this Amr can do two different kind of operations Choose some chemical and double its current volume so the new volume will be Choose some chemical and divide its volume by two integer division so the new volume will be Suppose that each chemical is contained in a vessel of infinite volume Now Amr wonders what is the minimum number of operations required to make all the chemicals volumes equal ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\nint i, j, k, n, m, a[N], x, y, h[N], temp, t, tt, c;\n\npii b[N];\n\nint main(){\n    \n    scanf(""%d"",&n);\n\n    FOR(i,1,n) {\n        scanf(""%d"",&a[i]);\n    \n    }\n\n    memset(h, -1, sizeof h);\n   \n    int t = a[1], ans = inf;\n    \n    vector< int > v;\n    \n    FOR(i,1,n) {\n        \n        v.clear();\n        \n        t = a[i], c = 0;\n        \n        while(1) {\n                    \n            temp = c;\n            \n            if(t == 0) {\n                h[0] = c;\n                v.pb(0);\n                break;\n            }\n               \n               \n            tt = t;\n                    \n            while(tt < 500000) {\n                if(h[tt] != -1 && h[tt] > temp) h[tt] = temp;\n               // else if(h[tt] != -1) break;\n                else if(h[tt] == -1){ h[tt] = temp; v.pb(tt); }\n                tt *= 2; temp++;\n            } c++; t /= 2; \n         \n        }\n        \n        foreach(it, v) {\n            b[*it].st++;b[*it].nd += h[*it];\n            h[*it] = -1;\n        }\n      }\n    \n    FOR(i,0,N-1) if(b[i].st == n) { ans = min(ans, b[i].nd); } \n    \n    cout << ans << endl;\n\n   return 0;\n}']",,,"['brute force', 'graphs', 'greedy', 'math', 'shortest paths']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Amr and Chemistry.json,https://codeforces.com//blog/entry/19212,Let the maximum number in the array be Clearly changing the elements of the array to any element larger than won t be optimal because the last operation is for sure multiplying all the elements of the array by two And not doing this operation is of course a better answer Now we want to count the maximum number of distinct elements that can be reached from some element that are not larger than Consider an element that has a zero in the first bit of its binary representation If we divided the number by two and the multiplied it by two we will get the original number again But if it has a one the resulting number will be different So for counting the maximum number of distinct elements we will assume where has only ones in its binary representation From we can only reach elements that have a prefix of ones in its binary representation and the other bits zeros e g Let s assume has bits in its binary representation then can reach exactly distinct elements So from each element in the array we can reach at most elements So Let s generate the numbers that can be reached from each element using bfs to get minimum number of operations And between all the numbers that are reachable from all the elements let s minimize the total number of operations Time complexity Implementation 
https://codeforces.com//contest/1899/problem/C,2331130,C,1899C,1899,C. Yarik and Array,A is a continuous part of array Yarik recently found an array a of n elements and became very interested in finding the maximum sum of a subarray However Yarik doesn t like consecutive integers with the same parity so the subarray he chooses must have alternating parities for adjacent elements For example 1 2 3 is acceptable but 1 2 4 is not as 2 and 4 are both even and adjacent You need to help Yarik by finding the maximum sum of such a subarray ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int t;\n        cin >> t;\n        while (t--) {\n                int n;\n                cin >> n;\n                vector<int> a(n);\n                for (int i = 0; i < n; i++) cin >> a[i];\n                vector<int64_t> f(n);\n                f[0] = a[0];\n                for (int i = 1; i < n; i++) {\n                        if ((a[i] + a[i - 1]) & 1) {\n                                f[i] = max<int64_t>(a[i], f[i - 1] + a[i]);\n                        } else {\n                                f[i] = a[i];\n                        }\n                }\n                cout << *max_element(f.begin(), f.end()) << '\\n';\n        }\n}""]",,,"['dp', 'greedy', 'two pointers']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Yarik and Array.json,https://codeforces.com//blog/entry/122407,EditorialThere are bad positions in the array i e those on which two numbers of the same parity are next to each other Note that all matching segments cannot contain such positions in other words we need to solve the problem of finding a sub segment with maximal sum on some number of non intersecting sub segments of the array the boundaries of which are between two neighboring elements of the same parity The problem of finding a sub segment with maximal sum can be solved using the classical algorithm with keeping minimal prefix sum on the prefix The problem can be solved in a single pass over the array by simply dropping the keeped values when we are in a bad position Total complexity 
https://codeforces.com//contest/1842/problem/E,1978969,E,1842E,1842,E. Tenzing and Triangle,There are n points and a line x y k on a two dimensional plane The i th point is at x i y i All points have non negative coordinates and are strictly below the line Alternatively 0 leq x i y i x i y i k Tenzing wants to erase all the points He can perform the following two operations Draw triangle Tenzing will choose two non negative integers a b that satisfy a b k then all points inside the triangle formed by lines x a y b and x y k will be erased It can be shown that this triangle is an isosceles right triangle Let the side lengths of the triangle be l l and sqrt 2 l respectively Then the cost of this operation is l cdot A The blue area of the following picture describes the triangle with a 1 b 1 with cost 1 cdot A Erase a specific point Tenzing will choose an integer i that satisfies 1 leq i leq n and erase the point i The cost of this operation is c i Help Tenzing find the minimum cost to erase all of the points ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:36:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    long long mx = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mx += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  long long A;\n  cin >> n >> k >> A;\n  vector<int> l(n), r(n);\n  vector<long long> cost(n);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y >> cost[i];\n    l[i] = x;\n    r[i] = k - y;\n    total += cost[i];\n  }\n  vector<vector<int>> at(k + 1);\n  for (int i = 0; i < n; i++) {\n    at[r[i]].push_back(i);\n  }\n  segtree st(k + 1);\n  long long dp = 0;\n  for (int i = 1; i <= k; i++) {\n    for (int id : at[i]) {\n      st.modify(0, l[id], +cost[id]);\n    }\n    dp = max(dp, -A * i + st.get(0, i - 1).mx);\n    st.modify(i, i, dp + A * i);\n  }\n  cout << total - dp << \'\\n\';\n  return 0;\n}\n']",,,"['data structures', 'dp', 'geometry', 'greedy', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Tenzing and Triangle.json,https://codeforces.com//blog/entry/117606,TutorialObserve that all triangles will be disjoint if two triangle were not disjoint we can merge them together to such that the cost used is less Therefore we can consider doing DP The oblique side of the triangle is a segment on the line Therefore we use the interval to represent the triangle with the upper left corner at and the lower right corner at First suppose that all points will generate costs After covering points with a triangle the costs can be reduced Let represent the sum of costs of points covered by triangle minus We need to find several intervals without common parts and maximize Let represent the maximum value of when considering the prefix There are two transitions If is not covered by any interval then If is covered by interval then Enumerate from small to large for maintain When will change as follows Subtract from For each point add the cost of the point to needs to support interval addition and global maximum value assuming that illegal positions are 0 which can be achieved using a segment tree Time complexity is 
https://codeforces.com//contest/1854/problem/C,2119348,C,1854C,1854,C. Expected Destruction,You have a set S of n distinct integers between 1 and m Each second you do the following steps Pick an element x in S uniformly at random Remove x from S If x 1 leq m and x 1 is not in S add x 1 to S What is the expected number of seconds until S is empty Output the answer modulo 1 000 000 007 Formally let P 1 000 000 007 It can be shown that the answer can be expressed as an irreducible fraction frac a b where a and b are integers and b not equiv 0 pmod P Output the integer equal to a cdot b 1 bmod P In other words output an integer z such that 0 le z P and z cdot b equiv a pmod P ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst ll mod=1000*1000*1000+7;\nconst ll o2=(mod+1)/2;\n\nll inv(ll v)\n{\n\tif (v<=1)\n\t\treturn v;\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nint n, m;\n\nint tab[nax];\n\nll dp[nax][nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tfor (int j=0; j<i; j++)\n\t\t{\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tdp[i][j]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=(dp[i-1][j]+1+dp[i][j-1])*o2%mod;\n\t\t\t}\n\t\t}\n\t}\n\tll wyn=m+1-tab[n];\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a=m+1-tab[i];\n\t\tint b=m+1-tab[i+1];\n\t\twyn+=dp[a][b];\n\t}\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'math', 'probabilities']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Expected Destruction.json,https://codeforces.com//blog/entry/118540,Solution Consider an grid where the th row initially contains a block in column and row contains a block in column The set is empty if all the blocks are in column i e if every block has reached the block in the following row Every connected component of blocks except the last one represents an element in the set These components move equiprobably Let s calculate the expected time required for the block in row to reach the block in row If you consider a single pair of blocks every block moves with probability unless block is in column So you can calculate expected number of moves of the block before it reaches the block if the block is in position and the block is in position The base cases are because only the block can move and because block has already reached block In the other cases By linearity of expectation the answer is the sum of Complexity 
https://codeforces.com//contest/1586/problem/I,1147389,I,1586I,1586,I. Omkar and Mosaic,Omkar is creating a mosaic using colored square tiles which he places in an n times n grid When the mosaic is complete each cell in the grid will have either a glaucous or sinoper tile However currently he has only placed tiles in some cells A completed mosaic will be a if and only if each tile is adjacent to exactly 2 tiles of the same color 2 tiles are adjacent if they share a side Omkar wants to fill the rest of the tiles so that the mosaic becomes a Now he is wondering is the way to do this unique and if it is what is it ,"['//an awesome problem.\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint absv(int x)\n{\n\treturn x < 0 ? -x : x;\n}\nint n, x[2005], G[2005][2005];\nchar S[2005][2005];\nbool dfs(int v, int c)\n{\n\tif(x[v] == !c) return false;\n\telse if(x[v] == c) return true;\n\tx[v] = c;\n\trep(i, n + 1) if(G[v][i] != -1 && !dfs(i, c ^ G[v][i])) return false;\n\treturn true;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%s"", S[i]);\n\tif(n & 1) {\n\t\tprintf(""NONE\\n""); return 0;\n\t}\n\t\n\trep(i, n + 1) rep(j, n + 1) G[i][j] = -1;\n\tfor(int i = 0; i < n; i += 2) G[i][i + 2] = G[i + 2][i] = 1;\n\trep(i, n) rep(j, n) if(S[i][j] != \'.\') {\n\t\tint val = (S[i][j] == \'S\') ^ (i & 1) ^ (j & 1);\n\t\tint d0 = absv(i - j), d1 = absv(i + j - n + 1);\n\t\tif(G[d0][n - d1] == !val) {\n\t\t\tprintf(""NONE\\n""); return 0;\n\t\t}\n\t\tG[d0][n - d1] = G[n - d1][d0] = val; \n\t}\n\t\n\trep(i, n + 1) x[i] = -1;\n\tint cnt = 0;\n\trep(i, n + 1) if(x[i] == -1) {\n\t\tcnt ++;\n\t\tif(!dfs(i, 0)) {\n\t\t\tprintf(""NONE\\n""); return 0;\n\t\t}\n\t}\n\tif(cnt >= 2) printf(""MULTIPLE\\n"");\n\telse {\n\t\trep(i, n) rep(j, n) S[i][j] = (i & 1) ^ (j & 1) ^ x[absv(i - j)] ^ x[n - absv(i + j - n + 1)] ? \'S\' : \'G\';\n\t\tprintf(""UNIQUE\\n"");\n\t\trep(i, n) printf(""%s\\n"", S[i]);\n\t}\n\treturn 0;\n}']",,,"['combinatorics', 'constructive algorithms', 'math']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\I. Omkar and Mosaic.json,https://codeforces.com//blog/entry/96072,The first main observation to make is that the possible mastapeeces don t just have square loops of the same color A counterexample to this is shown below Instead observe that in a mastapeece a The two cells adjacent to corner cells must be the same color as the corner b Any cell not on the border must be adjacent to two sinoper tiles and two glaucous tiles If we then start at two cells adjacent to some corner and keep applying b to cells on the long diagonal with the corner we find that the long diagonals starting at the adjacent cells must be identical and tiled alternately with glaucous and sinoper tiles like so From here we can show that no mastapeece exists for odd Note that the two sets of such diagonals for odd intersect in cells like so But then this forces us two have two consecutive diagonals of the same color on the untiled set of diagonals which is impossible given that we ve shown they must alternate From here if we apply b to the red diagonals we find that the yellow diagonals must alternate in a similar fashion and if we keep applying this argument we find that each diagonal where every cell is the same color in the image below must alternate between glaucous and sinoper in a similar way From here consider the following yellow diagonal We know its cells must alternate so due to parity we have that the ending cells of the diagonal must be the same color Since we know each cell must be surrounded by two of the same color this also fixes the following red cells which must also be the same color This gives that the following yellow diagonals must be identical as they must alternate repeating this kind of argument shows that a mastapeece must be symmetric about both of its main diagonals Finally note that since the yellow diagonal alternates and each cell must be adjacent to of the same color the red cells must be the same color Repeating this kind of argument gives that the cells in each pair of adjacent red cells and each pair of adjacent yellow cells must be the same color Finally applying the symmetry alternating diagonals and the pairs of same colored cells gives that in the following grid fixing a cell of one color fixes all of the cells of that color Finally due to our conditions on alternating diagonals each cell in the middle of the grid will be adjacent to two cells of the same color and due to our conditions on the pairs of cells on the diagonal that must be the same color each border cell will be adjacent to two cells of the same color In other words if we pair up the cells on the leftmost column and color each pair arbitrarily there will be exactly one mastapeece that has the column colored this way For example if we color the leftmost column like so then if we go down and color in the cells fixed by each pair in the left most column we find that the final mastapeece will look like so From here it s pretty easy to figure out how to implement the problem Some examples of what mastapeeces look like are shown below 
https://codeforces.com//contest/887/problem/A,132440,A,887A,887,A. Div. 64,Top model Izabella participates in the competition She wants to impress judges and show her mathematical skills Her problem is following for given string consisting of only 0 and 1 tell if it s possible to remove some digits in such a way that remaining number is a representation of some positive integer divisible by 64 in the binary numerical system ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair < int , int >\n#define pipii pair < int , pii >\n#define pid pair <int, double>\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define pp pop_back()\n#define sz size()\n#define iz insert\n#define lg length()\n#define FRNAME ""A""\n#define inf (int)1e6\n#define fr freopen(FRNAME"".in"",""r"",stdin); freopen (FRNAME"".out"",""w"",stdout);\n#define fr2 freopen(""input.txt"",""r"",stdin); freopen (""output.txt"",""w"",stdout)\nint n, m, k;\nint a[100100];\nint main ()\n{\n    string s;\n    cin >> s;\n    int cnt  = 0;\n\tfor (int i = 0; i < s.sz; i++)\n\t{\n\t\tif(s[i] == \'1\')\n\t\t{\n\t\t\tm = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m) cnt++;\n\t\t}\n\t}\n\tcout << (cnt >= 6 ? ""yes"" : ""no""); \t\n\treturn 0;\n}\t']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Div. 64.json,https://codeforces.com//blog/entry/55584,If the string contains no ones then the answer is NO as the remainig number must be positive Otherwise we can find the leftmost one and check if it is followed by at least six zeroes 
https://codeforces.com//contest/377/problem/E,4965,E,377E,377,E. Cookie Clicker,Kostya is playing the computer game Cookie Clicker The goal of this game is to gather cookies You can get cookies using different you can just click a special field on the screen and get the cookies for the clicks you can buy a cookie factory an alchemy lab a time machine and it all will bring lots and lots of cookies At the beginning of the game time 0 Kostya has 0 cookies and no buildings He has available buildings to choose from the th building is worth cookies and when it s built it brings cookies at the end of each second Also to make the game more interesting to play Kostya decided to add a limit at each moment of time he can use only one building Of course he can change the active building each second at his discretion It s important that Kostya is playing a version of the game where he can buy new buildings and change active building only at time moments that are multiples of one second Kostya can buy new building and use it at the same time If Kostya starts to use a building at the time moment he can get the first profit from it only at the time moment Kostya wants to earn at least cookies as quickly as possible Determine the number of seconds he needs to do that ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst long long inf = (long long)1e18;\n\nconst int N = 400010;\n\npair <int, int> h[N];\nlong double xs[N];\nint st[N];\nlong long value[N], cost[N], f[N], g[N];\n\nlong double inter(int i, int j) {\n  long double vv = value[i];\n  vv *= value[j];\n  long double fvv = vv * (f[j] - f[i]);\n  long double gv = ((long double)g[i] * value[j]) - ((long double)g[j] * value[i]);\n  long double vmv = value[j] - value[i];\n  return (fvv + gv) / vmv;\n}\n\nint main() {\n  int n;\n  long long goal;\n  cin >> n >> goal;\n  for (int i = 0; i < n; i++) {\n    scanf(""%d %d"", &(h[i].second), &(h[i].first));\n    h[i].second = -h[i].second;\n  }\n  sort(h, h + n);\n  int m = 1;\n  for (int i = 1; i < n; i++) {\n    int profit = -h[i].second;\n    int last_p = -h[m - 1].second;\n    if (profit > last_p) {\n      h[m] = h[i];\n      m++;\n    }\n  }\n  n = m;\n  for (int i = 0; i < n; i++) {\n    cost[i] = h[i].first;\n    value[i] = -h[i].second;\n  }\n  int e = 0;\n  for (int i = 0; i < n; i++) {\n    f[i] = inf;\n    g[i] = 0;\n    if (cost[i] == 0) {\n      f[i] = 0;\n      g[i] = 0;\n    } else {\n      int ll = 1, rr = e;\n      while (ll < rr) {\n        int mid = (ll + rr) >> 1;\n        if (xs[mid] < cost[i]) ll = mid + 1;\n        else rr = mid;\n      }\n      for (int u = ll - 5; u <= ll + 5; u++) {\n        if (u < 1 || u > e) continue;\n        int j = st[u];\n        long long nf = f[j], ng = g[j];\n        if (ng < cost[i]) {\n          long long need = cost[i] - ng;\n          if (need > 0) {\n            long long days = (need + value[j] - 1) / value[j];\n            nf += days;\n            ng += days * value[j];\n          }\n        }\n        ng -= cost[i];\n        if (nf < f[i] || nf == f[i] && ng > g[i]) {\n          f[i] = nf;\n          g[i] = ng;\n        }\n      }\n    }\n    while (e > 1) {\n      long double xx = inter(st[e], i);\n      if (xx < xs[e - 1]) e--;\n      else break;\n    }\n    e++;\n    st[e] = i;\n    if (e > 1) {\n      xs[e - 1] = inter(st[e - 1], st[e]);\n    }\n  }\n  long long ans = inf;\n  for (int i = 0; i < n; i++) {\n    long long cur = f[i];\n    if (g[i] < goal) {\n      long long need = goal - g[i];\n      cur += (need + value[i] - 1) / value[i];\n    }\n    if (cur < ans) ans = cur;\n  }\n  cout << ans << endl;\n  return 0;\n}\n']",,,"['dp', 'geometry']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Cookie Clicker.json,https://codeforces.com//blog/entry/10157,First of all throw away the buildings which cannot be used in any optimal answer for each remain only one building that has speed equal to and minimal Also throw away all buildings whose speed is less than the speed of the fastest building which has It s fairly obvious that at any time we should use the fastest building And if some building is used in the optimal answer it should be bought and used immediately when we have enough money I will use the word money instead of cookies Let s imagine the plane where axis stands for the time and axis stands for the money We will maintain the graph of the function maximal number of money that can be obtained at the time and process the buildings one by one changing the graph This function is the union of the line segments with the slopes equal to and each of these line segments is active on a certain segment of the axis For example at the beginning the graph is just the line where is the speed of building that can be bought for 0 units of money Let the next building s price is Find the minimal point where value of our function is greater or equal to and buy this building at the moment Then we should make the line where is the amount of money remaining after the purchase Now we have two lines Till some moment the first line is better not till maybe later but as there exists a moment of time it s where is the coordinate of the lines intersection when the second line becomes better Now we know the segments where a particular line is better than the others Continue add all buildings to the graph this way Line segments should be stored in stack as in all problems with convex hull and every step remove unnecessary line segments from the stack these are the lines those position in the stack is after the line which has an intersection with the currently added line After we process all buildings we use our graph to find the minimal time when we have untis of money If we also should say which building we must use we can store for any line segment its parent the line segment which was active when the current one was bought With such parent array it s not hard to restore the sequence of buildings in the answer We removed this part from the problem to make it a bit easier 
https://codeforces.com//contest/1891/problem/F,2296093,F,1891F,1891,F. A Growing Tree,You are given a rooted tree with the root at vertex 1 initially consisting of a single vertex Each vertex has a numerical value initially set to 0 There are also q queries of two types The first type add a child vertex with the number sz 1 to vertex v where sz is the current size of the tree The numerical value of the new vertex will be 0 The second type add x to the numerical values of all vertices in the subtree of vertex v After all queries output the numerical value of all of the vertices in the final tree ,"['#include <cstdio>\n#include <vector>\nusing namespace std;\nint read(){\n\tchar c=getchar();int x=0;bool f=0;\n\twhile(c<48||c>57) f|=(c==\'-\'),c=getchar();\n\tdo x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\twhile(c>=48&&c<=57);\n\tif(f) return -x;\n\treturn x;\n}\nconst int N=1000003;\ntypedef long long ll;\nvector<int> vec[N];\nint ft[N],sn[N],sz[N],tp[N],dfn[N],num;\nvoid dfs(int u){\n\tsz[u]=1;sn[u]=0;\n\tfor(int v:vec[u]){\n\t\tft[v]=u;\n\t\tdfs(v);\n\t\tsz[u]+=sz[v];\n\t\tif(sz[v]>sz[sn[u]]) sn[u]=v;\n\t}\n}\nvoid split(int u,int tops){\n\ttp[u]=tops;dfn[u]=++num;\n\tif(sn[u]) split(sn[u],tops);\n\tfor(int v:vec[u]){\n\t\tif(v==sn[u]) continue;\n\t\tsplit(v,v);\n\t}\n}\ntypedef long long ll;\nint op[N],val[N],vv[N];\nll tr[N];\nvoid upd(int x,ll v){for(int i=x;i<=num;i+=(i&-i)) tr[i]+=v;}\nll qry(int x){\n\tll res=0;\n\tfor(int i=x;i;i^=(i&-i)) res+=tr[i];\n\treturn res;\n}\nll query(int x){\n\tll res=0;\n\twhile(x){\n\t\tres+=qry(dfn[x])-qry(dfn[tp[x]]-1);\n\t\tx=ft[tp[x]];\n\t}\n\treturn res;\n}\nll res[N];\nvoid calc(int u,ll cur){\n\tcur+=qry(dfn[u])-qry(dfn[u]-1);\n\tres[u]=cur;\n\tfor(int v:vec[u]) calc(v,cur);\n}\nint main(){\n\tint tc=read();\n\twhile(tc--){\n\t\tint q=read();\n\t\tint sz=1;\n\t\tnum=0;\n\t\tfor(int i=1;i<=q;++i){\n\t\t\top[i]=read();\n\t\t\tval[i]=read();\n\t\t\tif(op[i]==1) vec[val[i]].emplace_back(++sz);\n\t\t\telse vv[i]=read();\n\t\t}\n\t\tdfs(1);\n\t\tsplit(1,1);\n\t\tsz=1;\n\t\tfor(int i=1;i<=q;++i)\n\t\t\tif(op[i]==1){\n\t\t\t\t++sz;\n\t\t\t\tupd(dfn[sz],-query(val[i]));\n\t\t\t}\n\t\t\telse upd(dfn[val[i]],vv[i]);\n\t\tcalc(1,0);\n\t\tfor(int i=1;i<=sz;++i) printf(""%lld "",res[i]);\n\t\tputchar(\'\\n\');\n\t\tfor(int i=1;i<=sz;++i) vec[i].clear(),tr[i]=0;\n\t}\n\treturn 0;\n}\n']",,,"['data structures', 'dfs and similar', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. A Growing Tree.json,https://codeforces.com//blog/entry/121876,Let s parse all the queries and build the tree We can easily support subtree addition queries using segment tree on Euler tour of the tree And when we add new vertex we just need to set its value to zero How to do it You can get the value in this vertex now by get query from the segment tree let it be Then you add to its value You can also use Fenwick tree to handle range add point get queries Time complexity Bonus try to find a solution using sqrt decomposition I hope it will get TLE but still 
https://codeforces.com//contest/1691/problem/F,1416262,F,1691F,1691,F. K-Set Tree,You are given a tree G with n vertices and an integer k The vertices of the tree are numbered from 1 to n For a vertex r and a subset S of vertices of G such that S k we define f r S as the size of the smallest rooted subtree containing all vertices in S when the tree is rooted at r A set of vertices T is called a rooted subtree if all the vertices in T are connected and for each vertex in T all its descendants belong to T You need to calculate the sum of f r S over of vertices r and subsets S where S k Formally compute the following sum r in V sum S subseteq V S k f r S where V is the set of vertices in G Output the answer modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n//constexpr int mod = 998244353;\nconstexpr int mod = 1e9 + 7;\n\nint reduce(int x) {\n\tif(x < 0) x += mod;\n\tif(x >= mod) x -= mod;\n\treturn x;\n}\n\ntemplate < typename T > T qp(T x, ll t) { T res = 1; for(; t; t >>= 1, x *= x) if(t & 1) res *= x; return res; }\n\nstruct Z { // modint\n\tint x;\n\tZ(int x = 0) : x(reduce(x)) {}\n\tZ(ll x) : x(reduce(x % mod)) {}\n\tZ operator -() const { return Z(reduce(mod - x)); }\n\tint val() { return x; }\n\tZ inv() const { assert(x); return qp(*this, mod - 2); }\n\tZ &operator += (const Z &t) { x = reduce(x + t.x); return *this; }\n\tZ &operator -= (const Z &t) { x = reduce(x - t.x); return *this; }\n\tZ &operator *= (const Z &t) { x = (ll)x * t.x % mod; return *this; }\n\tZ &operator /= (const Z &t) { return *this *= t.inv(); }\n\tfriend Z operator + (const Z &a, const Z &b) { Z res = a; res += b; return res; }\n\tfriend Z operator - (const Z &a, const Z &b) { Z res = a; res -= b; return res; }\n\tfriend Z operator * (const Z &a, const Z &b) { Z res = a; res *= b; return res; }\n\tfriend Z operator / (const Z &a, const Z &b) { Z res = a; res /= b; return res; }\n};\n\nZ fac[N], ifac[N];\nZ C(int x, int y) { return x < 0 || y < 0 || x < y ? Z(0) : fac[x] * ifac[y] * ifac[x - y]; }\nvoid init(int l) {\n\tfac[0] = 1; rep(i, 1, l) fac[i] = fac[i - 1] * Z(i); ifac[l] = fac[l].inv();\n\tper(i, l - 1, 0) ifac[i] = ifac[i + 1] * Z(i + 1);\n}\n\nint n, K, siz[N], fa[N];\nZ ret[N], ans;\nvec G[N];\n\nvoid dfs(int x, int p) {\n\tsiz[x] = 1; fa[x] = p;\n\tfor(auto y : G[x]) if(y ^ p) {\n\t\t\tdfs(y, x); siz[x] += siz[y]; ret[x] += C(siz[y], K);\n\t\t}\n\tret[x] += C(n - siz[x], K);\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tn = in, K = in; rep(i, 2, n) { int u = in, v = in; G[u].eb(v), G[v].eb(u); }\n\tinit(n); dfs(1, 0);\n\trep(x, 1, n) {\n\t\tfor(auto y : G[x])\n\t\t\tif(y == fa[x]) {\n\t\t\t\tZ t = (n - siz[x]) * (C(siz[x], K) - (ret[x] - C(n - siz[x], K))) * siz[x];\n\t\t\t\tans += t;\n\t\t\t} else {\n\t\t\t\tZ t = siz[y] * (C(n - siz[y], K) - (ret[x] - C(siz[y], K))) * (n - siz[y]);\n\t\t\t\tans += t;\n\t\t\t}\n\t\tans += (C(n, K) - ret[x]) * n;\n\t}\n\tcout << ans.val() << endl;\n\treturn 0;\n}\n']",,,"['combinatorics', 'dfs and similar', 'dp', 'math', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. K-Set Tree.json,https://codeforces.com//blog/entry/103212,Our task is to calculate over all possible Let us first focus on all possible just for a particular root i e let us root our tree at and try to find the sum just for that root We will calculate our answer using dynamic programming over the trees In this technique we will calculate some properties for each sub tree and eventually get those properties for the entire tree The first property that we want to calculate for each sub tree with node as the sub tree root is which is the number of subsets of size such that sub tree of is the minimum size sub tree covering it entirely This can be calculated using combinatorics first we calculate the total number of subsets of size in this sub tree and then from it we can subtract the number of subsets of size which don t have sub tree of as the minimum size sub tree Here are all the children of and represents the size of the sub tree of This first property that we calculated is very important for us If we take the sum of over every node we will get the total number of subsets of size When the tree is rooted at represents the number of subsets where sub tree of is the smallest sub tree containing a set with vertices Conclusively The second property that we want to find for each sub tree is the the size of the sub tree of The third property that we want to find for each sub tree is Now we have as explained above i e the contribution to the final answer when the root of the entire tree is fixed at We can calculate the final answer by fixing other nodes as roots and then summing these value up Notice what happens when we try to change the root from to one of it s children The properties that we calculated for each sub tree remain the same except for the old root and the new root We can recalculate the properties for these two nodes using some clever arithmetic and get the new answer with a new root This is known as re rooting technique The method to calculate the new properties are Note We use to represent Old Root and to represent New Root Subtracting the size of this branch This is the main root Removing contribution of old size and putting contribution of new size Removing contribution of the branch Removing contribution of old size and putting contribution of new size Putting contribution of new brach By definition By definition Subtracting old contribution and adding new contribution The final answer is given by 
https://codeforces.com//contest/1922/problem/D,2433277,D,1922D,1922,D. Berserk Monsters,Monocarp is playing a computer game yet again Guess what is he doing That s right killing monsters There are n monsters in a row numbered from 1 to n The i th monster has two parameters attack value equal to a i and defense value equal to d i In order to kill these monsters Monocarp put a berserk spell on them so they re attacking each other instead of Monocarp s character The fight consists of n rounds Every round the following happens first every alive monster i deals a i damage to the alive monster to the left if it exists and the alive monster to the right if it exists then every alive monster j which received more than d j damage dies I e the j th monster dies if and only if its defense value d j is than the total damage it received For each round calculate the number of monsters that will die during that round ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include ""debug.h""  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    cin >> n;\n    vector<int> a(n), d(n);\n    for (int& ai : a) { cin >> ai; }\n    for (int& di : d) { cin >> di; }\n    set<int> alive, die;\n    for (int i = 0; i < n; i += 1) { alive.insert(i); }\n    for (int i = 0; i < n; i += 1) {\n      if ((i ? a[i - 1] : 0) + (i + 1 < n ? a[i + 1] : 0) > d[i]) {\n        die.insert(i);\n      }\n    }\n    for (int i = 0; i < n; i += 1) {\n      cout << die.size() << "" "";\n      set<int> to_die;\n      for (int x : die) { alive.erase(x); }\n      auto check = [&](auto it) {\n        if ((it != alive.begin() ? a[*prev(it)] : 0) +\n                (next(it) != alive.end() ? a[*next(it)] : 0) >\n            d[*it]) {\n          to_die.insert(*it);\n        }\n      };\n      for (int x : die) {\n        auto it = alive.lower_bound(x);\n        if (it != alive.end()) { check(it); };\n        if (it != alive.begin()) { check(prev(it)); };\n      }\n      to_die.swap(die);\n    }\n    cout << ""\\n"";\n  }\n}']",,,"['brute force', 'data structures', 'dsu', 'implementation', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Berserk Monsters.json,https://codeforces.com//blog/entry/124890,It is important to note that if during the th round the th monster did not die and none of its alive neighbors died then there is no point in checking this monster in the th round Therefore we can solve the problem as follows let s maintain a list of candidates those who can die for the current round if the monster dies in the current round then add its neighbors to the list of candidates for the next round Since killing a monster adds no more than candidates the total size of the candidate lists for all rounds does not exceed since the size of the list for the first round is equal to plus no more than for each killed monster Therefore we can simply iterate through these lists to check if the monster will be killed The only problem left is finding the alive neighbors of the monster to check whether he is killed or not during the round This can be done by creating an ordered with the indices of the monsters allows us to remove the killed ones and find neighboring monsters in Thus the solution works in 
https://codeforces.com//contest/1083/problem/A,268421,A,1083A,1083,A. The Fair Nut and the Best Path,The Fair Nut is going to travel to the Tree Country in which there are n cities Most of the land of this country is covered by forest Furthermore the local road system forms a tree connected graph without cycles Nut wants to rent a car in the city u and go by a simple path to city v He hasn t determined the path so it s time to do it Note that chosen path can consist of only one vertex A filling station is located in every city Because of strange law Nut can buy only w i liters of gasoline in the i th city We can assume that he has Each road has a length and as soon as Nut drives through this road the amount of gasoline decreases by length Of course Nut can t choose a path which consists of roads where he runs out of gasoline He can buy gasoline in visited city even in and He also wants to find the maximum amount of gasoline that he can have at the end of the path Help him count it ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nvector <pair <int,ll> > graf[nax];\n\nll dfs(int v, int oj)\n{\n\tll ret=tab[v];\n\twyn=max(wyn, tab[v]);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tll w=dfs(i.first, v)-i.second;\n\t\twyn=max(wyn, ret+w);\n\t\tret=max(ret, w+tab[v]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c);\n\t\tgraf[a].push_back({b, c});\n\t\tgraf[b].push_back({a, c});\n\t}\n\tdfs(1, 0);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. The Fair Nut and the Best Path.json,https://codeforces.com/blog/entry/63753?locale=en,Let s write on edge with length number Let sum on the path be sum of amounts of gasoline which can be bought in cities on this path plus sum of the numbers which were written on its edges If we don t run out of gasoline on some path sum on it will be equal to amount of gasoline at the end of way If we run out of gasoline on a path we can start from the next city after the road where it happened and sum on the path won t decrease So there is a path with maximal sum where we don t run out of gasoline This sum is answer to the problem How to find it Let is maximal sum on vertical way which starts in vertex It is not difficult to calculate using values for children of vertex Every way can be divided to two vertical ways so we can calculate answer by turning over which is the highest vertex of a path and taking the two biggest vertical ways which starts from vertex 
https://codeforces.com//contest/1106/problem/C,290932,C,1106C,1106,C. Lunar New Year and Number Division,There are n positive integers a 1 a 2 ldots a n on Bob s homework paper where n is always an number Bob is asked to divide those numbers into groups where each group must contain at least 2 numbers Suppose the numbers are divided into m groups and the sum of the numbers in the j th group is s j Bob s aim is to minimize the sum of the square of s j that is sum j 1 m s j 2 Bob is puzzled by this hard problem Could you please help him solve it ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 550000;\nint a[N];\n\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tsort(a + 1, a + n + 1);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) ans += a[i] * 1LL * a[i];\n\tfor (int i = 1; i <= n / 2; i++) ans += 2LL * a[i] * a[n + 1 - i];\n\tcout << ans << endl;\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'math', 'sortings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Lunar New Year and Number Division.json,https://codeforces.com/blog/entry/64928,This problem is easy as it looks like and it is proved to be simple As is even the optimal grouping policy is to group the smallest with the largest the second smallest with the second largest etc First it is easy to prove that it is optimal to group these numbers by so the proof is given as an exercise to you The proof of the second part is about the Rearrangement Inequality Let s consider two of the permutations of the sequence Suppose they are where if and only if Then the sum is one of the grouping policy of As we do not care about the part We only aim to minimize That is the direct application of the Rearrangement Inequality 
https://codeforces.com//contest/1704/problem/E,1489128,E,1704E,1704,E. Count Seconds,Cirno has a DAG Directed Acyclic Graph with n nodes and m edges The graph has exactly one node that has no out edges The i th node has an integer a i on it Every second the following happens Let S be the set of nodes x that have a x 0 For all x in S 1 is subtracted from a x and then for each node y such that there is an edge from x to y 1 is added to a y Find the first moment of time when all a i become 0 Since the answer can be very large output it modulo 998 244 353 ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 17:24:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_topsort(const digraph<T> &g) {\n  vector<int> deg(g.n, 0);\n  for (int id = 0; id < (int) g.edges.size(); id++) {\n    deg[g.edges[id].to]++;\n  }\n  vector<int> x;\n  for (int i = 0; i < g.n; i++) {\n    if (deg[i] == 0) {\n      x.push_back(i);\n    }\n  }\n  for (int ptr = 0; ptr < (int) x.size(); ptr++) {\n    int i = x[ptr];\n    for (int id : g.g[i]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (--deg[to] == 0) {\n        x.push_back(to);\n      }\n    }\n  }\n  if ((int) x.size() != g.n) {\n    return vector<int>();\n  }\n  return x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    digraph<int> g(n);\n    vector<vector<int>> gr(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      gr[x].push_back(y);\n      g.add(x, y);\n    }\n    auto order = find_topsort(g);\n    assert(!order.empty());\n    const long long inf = (long long) 1e18;\n    vector<vector<long long>> dp(n, vector<long long>(n + 2));\n    vector<vector<Mint>> dm(n, vector<Mint>(n + 2));\n    for (int i : order) {\n      dp[i][0] += a[i];\n      dm[i][0] += a[i];\n      for (int j : gr[i]) {\n        for (int k = 0; k <= n; k++) {\n          dp[j][k + 1] += dp[i][k];\n          dm[j][k + 1] += dm[i][k];\n          dp[j][k + 1] = min(dp[j][k + 1], inf);\n        }\n      }\n    }\n    int ver = order.back();\n    long long M = 0;\n    Mint ans = 0;\n    for (int k = 0; k <= n; k++) {\n      if (dp[ver][k] > 0) {\n        if (k > M) {\n          ans += k - M;\n          M = k;\n        }\n        M += dp[ver][k];\n        M = min(M, inf);\n        ans += dm[ver][k];\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'dp', 'graphs', 'implementation', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Count Seconds.json,https://codeforces.com//blog/entry/105464,For the sink point We can find that it may be zero at some time and then it will be full for some continous time and then will be zero forever That s because for time for some certain all roads from to the sink point must be greater than since rounds are enough for such to spread along these roads Meanwhile when some is decreased it will also receive the numbers from upper nodes As a result after turns will be greater than until all turns to for all that there s an edge from to Simulate the first rounds then we just need to calculate what s the final number on the sink node if the the number on the sink point is never decreased That s exactly the rounds it will take the sink point to be decreased to Let be the total number of s the i th node will add to some sink point finally if there is an on the i th node We can easily get the in O n time for every sink point Do a topological sort and add the of the current node to the of the newly queued point during the sorting process Calculate the sum of and you can get the answer The total time complexity will be Note that the numbers on the nodes may be a multiple of so pay attention to them when simulating in the first turns 
https://codeforces.com//contest/238/problem/A,2111,A,238A,238,A. Not Wool Sequences,A sequence of non negative integers of length is called a if and only if there exists two integers and such that In other words each wool sequence contains a subsequence of consecutive elements with xor equal to 0 The expression means applying the operation of a bitwise xor to numbers and The given operation exists in all modern programming languages for example in languages and it is marked as in as In this problem you are asked to compute the number of sequences made of integers from 0 to that are not a wool sequence You should print this number modulo ,"['#include <stdio.h>\n#include <ctype.h>\n#include <iostream>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <time.h>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <utility>\n#include <assert.h>\n\n#define MPI 3.141592653589793238462643\n#define eps 1e-8\n#define inf ((int)1e9)\n#define pb push_back\n#define mp make_pair\n#define mod (1000000009ll)\n\nusing namespace std;\n\nlong long res=1ll, d=1ll;\n\nint main()\n{\n  int i, n, m;\n  //freopen("".in"", ""r"", stdin);\n  //freopen("".out"", ""w"", stdout);\n  cin>>n>>m;\n  for (i=0; i<m; i++)\n    d*=2ll, d%=mod;\n  for (i=1; i<=n; i++)\n    res*=(d+mod-i), res%=mod;\n  cout<<res<<endl;\n  return 0;\n}\n']",,,"['constructive algorithms', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Not Wool Sequences.json,https://codeforces.com//blog/entry/5765,Let a1 an be a not wool sequence We define another sequence called b in which bi is xor of the first i elements of a and b0 0 Now xor of elements of a consecutive subsequence like ai aj will be equal to So we know that all elements of b should be different Therefore b is a sequence of distinct integers of length n 1 starting with 0 made of numbers 0 to 2m 1 The number of such sequences is and this is the answer to problem 
https://codeforces.com//contest/1005/problem/C,196283,C,1005C,1005,C. Summarize to the Power of Two,A sequence a 1 a 2 dots a n is called good if for each element a i there exists an element a j i ne j such that a i a j is a power of two that is 2 d for some non negative integer d For example the following sequences are good 5 3 11 for example for a 1 5 we can choose a 2 3 Note that their sum is a power of two Similarly such an element can be found for a 2 and a 3 1 1 1 1023 7 39 89 25 89 Note that by definition an empty sequence with a length of 0 is good For example the following sequences are not good 16 for a 1 16 it is impossible to find another element a j such that their sum is a power of two 4 16 for a 1 4 it is impossible to find another element a j such that their sum is a power of two 1 3 2 8 8 8 for a 3 2 it is impossible to find another element a j such that their sum is a power of two You are given a sequence a 1 a 2 dots a n What is the minimum number of elements you need to remove to make it good You can delete an arbitrary set of elements ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n    map<int, int> A;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        A[x]++;\n    }\n\n    int sc = 0;\n\n    for (auto i : A) {\n\n        bool t = 0;\n        int x = (i.ft);\n\n        for (int j = 1; j < 34; j++) {\n            int y = (1 << j) - x;\n            if (y > 0 && A.count(y) && (y != x) || (y == x && A[y] > 1)) {\n                t = 1;\n                break;\n            }\n        }\n\n        if (!t) sc += i.sd;\n    }\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n']",,,"['brute force', 'greedy', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Summarize to the Power of Two.json,https://codeforces.com//blog/entry/60511,You should delete only such for which there is no such that is a power of For each value let s find the number of its occurrences You can use simple standard data structure Do for each element Now you can easily check that doesn t have a pair Let s iterate over all possible sums and for each find calculate If for some or then a pair exists Note that in C solutions it s better to first check that is a key in and only after it calculate This needs to be done since in C when you access a key using the square brackets operator a default mapping key value is created on the absence of the key This increases both the running time and the memory consumption 
https://codeforces.com//contest/1555/problem/C,1062142,C,1555C,1555,C. Coin Rows,Alice and Bob are playing a game on a matrix consisting of 2 rows and m columns The cell in the i th row in the j th column contains a i j coins in it Initially both Alice and Bob are standing in a cell 1 1 They are going to perform a sequence of moves to reach a cell 2 m The possible moves are Move right from some cell x y to x y 1 Move down from some cell x y to x 1 y First Alice makes until she reaches 2 m She collects the coins in all cells she visit including the starting cell When Alice finishes Bob starts his journey He also performs the moves to reach 2 m and collects the coins in all cells that he visited The score of the game is the total number of coins Bob collects Alice wants to minimize the score Bob wants to maximize the score What will the score of the game be if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<int>> a(2, vector<int>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> a[j][k];\n      }\n    }\n    vector<int> S1(m + 1);\n    S1[m] = 0;\n    for (int j = m - 1; j >= 0; j--){\n      S1[j] = S1[j + 1] + a[0][j];\n    }\n    vector<int> S2(m + 1);\n    S2[0] = 0;\n    for (int j = 0; j < m; j++){\n      S2[j + 1] = S2[j] + a[1][j];\n    }\n    int ans = INF;\n    for (int j = 0; j < m; j++){\n      ans = min(ans, max(S1[j + 1], S2[j]));\n    }\n    cout << ans << endl;\n  }\n}']",,,"['brute force', 'constructive algorithms', 'dp', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Coin Rows.json,https://codeforces.com//blog/entry/93389,First observe that each of the players has only options for their path which column to go down in Let s consider a Bob s response to a strategy chosen by Alice The easiest way to approach that is to look at the picture of the Alice s path The path clearly separates the field into two independent pieces suffix of the first row and the prefix of the second row Bob can t grab the coins from both of them at once However he can grab either of them fully So the optimal path for him will be one of these two options You can precalculate some prefix sums and become able to get the Bob s score given the Alice s path Alice has possibly paths so you can iterate over them and choose the minimum answer However prefix sums are not required since you can quickly recalculate both needed sums while iterating over the Alice s column to go down in Overall complexity per testcase 
https://codeforces.com//contest/1543/problem/E,1038890,E,1543E,1543,E. The Final Pursuit,Finally you have defeated Razor and now you are the Most Wanted street racer Sergeant Cross has sent the full police force after you in a deadly pursuit Fortunately you have found a hiding spot but you fear that Cross and his force will eventually find you To increase your chances of survival you want to tune and repaint your BMW M3 GTR The car can be imagined as a n dimensional hypercube A simple n dimensional hypercube is an undirected unweighted graph built recursively as follows Take two simple n 1 dimensional hypercubes one having vertices numbered from 0 to 2 n 1 1 and the other having vertices numbered from 2 n 1 to 2 n 1 A simple 0 dimensional Hypercube is just a single vertex Add an edge between the vertices i and i 2 n 1 for each 0 leq i 2 n 1 A permuted n dimensional hypercube is formed by permuting the vertex numbers of a simple n dimensional hypercube in any arbitrary manner Examples of a simple and permuted 3 dimensional hypercubes are given below Note that a permuted n dimensional hypercube has the following properties There are exactly 2 n vertices There are exactly n cdot 2 n 1 edges Each vertex is connected to exactly n other vertices There are no self loops or duplicate edges Let s denote the permutation used to generate the permuted n dimensional hypercube representing your car from a simple n dimensional hypercube by P Before messing up the functionalities of the car you want to find this permutation so that you can restore the car if anything goes wrong But the job isn t done yet You have n different colours numbered from 0 to n 1 You want to colour the vertices of this permuted n dimensional hypercube in such a way that for each and every vertex u satisfying 0 leq u 2 n and for each and every colour c satisfying 0 leq c n there is at least one vertex v adjacent to u having a colour c In other words from each and every vertex it must be possible to reach a vertex of any colour by just moving to an adjacent vertex Given the permuted n dimensional hypercube find any valid permutation P and colouring ,"['// Problem: E. The Final Pursuit\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nvector<int> e[65536];\nint vis[65536];\nint id[65536],inv[65536];\nint col[65536];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tint m=n*(1<<(n-1));\n\t\tint N=1<<n;\n\t\tfor(int i=0; i<N; ++i) e[i].clear(),vis[i]=0,id[i]=0;\n\t\tfor(int i=1; i<=m; ++i) \n\t\t{\n\t\t\tint u=read(),v=read();\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tint visc=1;\n\t\tvector<int> cur,nxt;\n#define pb push_back\n\t\tvis[0]=2;\n\t\tint powpowpow2=1;\n\t\tfor(int i:e[0])\n\t\t{\n\t\t\tvis[i]=1,cur.pb(i),id[i]=powpowpow2,++visc;\n\t\t\tpowpowpow2<<=1;\n\t\t}\n\t\twhile(visc!=N)\n\t\t{\n\t\t\tnxt.clear();\n\t\t\tfor(int i:cur) vis[i]=2;\n\t\t\tfor(int i:cur) for(int j:e[i]) if(vis[j]!=2)\n\t\t\t{\n\t\t\t\tid[j]|=id[i];\n\t\t\t\tif(!vis[j]) vis[j]=1,++visc,nxt.pb(j);\n\t\t\t}\n\t\t\tcur=nxt;\n\t\t}\n\t\tfor(int i=0; i<N; ++i) inv[id[i]]=i;\n\t\tfor(int i=0; i<N; ++i) printf(""%d "",inv[i]);\n\t\tputs(""""); \n\t\tint o=n;\n\t\twhile(!(o&1)) o>>=1;\n\t\tif(o!=1) puts(""-1"");\n\t\telse\n\t\t{\n\t\t\tfor(int i=0; i<N; ++i)\n\t\t\t{\n\t\t\t\tint s=0;\n\t\t\t\tfor(int j=0; j<n; ++j) if(i&(1<<j)) s^=j;\n\t\t\t\tcol[inv[i]]=s;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; ++i)\n\t\t\t{\n\t\t\t\tset<int> s;\n\t\t\t\tfor(int j:e[i]) s.insert(col[j]);\n\t\t\t\tassert((int)s.size()==n);\n\t\t\t}\n\t\t\tfor(int i=0; i<N; ++i) printf(""%d "",col[i]);\n\t\t\tputs("""");\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['bitmasks', 'constructive algorithms', 'divide and conquer', 'graphs', 'greedy', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. The Final Pursuit.json,https://codeforces.com//blog/entry/92582,Tutorial Part 1 Finding the PermutationBefore moving to the solution notice a very important property of simple Dimensional Hypercubes Two vertices and are connected if and only if and differ by exactly one bit in their binary representations The permutation can be found using the following greedy algorithm First assign any arbitrary vertex as This is obvious since all vertices are equivalent Then in the simple Dimensional Hypercube all powers of must be connected to the vertex Moreover these vertices are added only when we are adding another dimension to the cube Since all directions are also equivalent it does not matter in which direction we add a new dimension So we can assign all the vertices connected to in the permuted Dimensional Hypercube as in any arbitrary order Now we will find for the remaining vertices in increasing order of In order to find first find a set of vertices such that and is connected to in the simple Dimensional Hypercube Then find any vertex connected to all the vertices such that in the permuted Dimensional Hypercube and assign I claim that we can never make a wrong choice because we will never have a choice There will only be one such vertex for any Let s prove it ProofConsider two vertices and in the set These vertices will differ by exactly bits in their binary representation Let the bits in which they differ be and Then they will have the form and where represent the same bits Now only two vertices and can be connected to both and Since a permuted Dimensional Hypercube is isomorphic to a simple Dimensional Hypercube there will only be two vertices connected to both and in the permuted Dimensional Hypercube also If we iterate over in increasing order then otherwise one of or will be greater than which is a contradiction So the only vertices connected to both and will have the forms and Now since and has already been calculated and so one of the vertex connected to both and in the permuted Dimensional Hypercube has already been used So we are left with only one choice for such a vertex Alternate method of finding the permutation by mshiladityam Let s call the vertex connected to a given vertex and which is in the opposite constituent smaller hypercube the image of the given vertex Lemma if there is an edge in the Dimensional hypercube where vertices and lie in different constituent Dimensional Hypercubes in other words and are images of each other then for all vertices adjacent to the image of is adjacent to This lemma can be proved by using the fact that two vertex are connected if and only if they differ by exactly bit Select any two vertices and They form a starting point we treat them as two vertices in opposite constituents by symmetry we can prove that any pairs can be treated as such Now let us perform multisource BFS with and as source nodes Due to the lemma the nodes which are discovered from first lie in the component of and those which are discovered from first lie in the component of it is easy again to prove it using induction on depth of already discovered vertices So we have separated these two constituent smaller dimension hypercubes Lets call a recursive function on any one of them this recursive function returns a permutation which transforms the permutated hypercube to the simple hypercube Now we find for each vertex in the constituent hypercube whose permutation we just found its image Then we can find the permutation for the other constituent by just adding to the corresponding image Hence we perform the merging process of recursion The time complexity of this approach is 
https://codeforces.com//contest/1105/problem/C,284896,C,1105C,1105,C. Ayoub and Lost Array,Ayoub had an array a of integers of size n and this array had two interesting properties All the integers in the array were between l and r inclusive The sum of all the elements was divisible by 3 Unfortunately Ayoub has lost his array but he remembers the size of the array n and the numbers l and r so he asked you to find the number of ways to restore the array Since the answer could be very large print it modulo 10 9 7 i e the remainder when dividing by 10 9 7 In case there are no satisfying arrays Ayoub has a wrong memory print 0 ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch=\'*\'; (ch<\'0\'||ch>\'9\')&&ch!=\'-\'; ch=getchar());\n    if(ch==\'-\') fu=1, ch=getchar();\n    for(v=0; ch>=\'0\'&&ch<=\'9\'; ch=getchar()) v=v*10+ch-\'0\';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint n,l,r;\nLL ans,f[200010][3],s[3];\nint main(){\n//\tfreopen(""t.in"",""r"",stdin);\n//\tfreopen(""t.out"",""w"",stdout);\n\tcin>>n>>l>>r;\n\t--l;\n\ts[0]=r/3-l/3;\n\ts[1]=(r+2)/3-(l+2)/3;\n\ts[2]=(r+1)/3-(l+1)/3;\n\tf[0][0]=1;\n\tFOR(i,0,n-1)\n\t\tFOR(j,0,2)\n\t\t\tif (f[i][j]){\n\t\t\t\tFOR(k,0,2)\n\t\t\t\t\t(f[i+1][(j+k)%3]+=f[i][j]*s[k])%=MO;\n\t\t\t}\n\tans=(f[n][0]%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']",,,"['combinatorics', 'dp', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Ayoub and Lost Array.json,https://codeforces.com//blog/entry/64664,Since we need the sum of the array to be divisible by we don t care about the numbers themselves We care about how many numbers such that or or and we count them by simple formulas For example let s count the number of with remainder modulo hence for some integer Then we have and then It is easy to count number of such then After counting all numbers we can solve the problem using dynamic programming Let s say that dp i j represents that the sum of the first numbers modulo is equal to There are states and transitions and the answer will be at dp n 0 
https://codeforces.com//contest/1606/problem/B,1163613,B,1606B,1606,B. Update Files,Berland State University has received a new update for the operating system Initially it is installed only on the 1 st computer Update files should be copied to all n computers The computers are not connected to the internet so the only way to transfer update files from one computer to another is to copy them using a patch cable a cable connecting two computers directly Only one patch cable can be connected to a computer at a time Thus from any computer where the update files are installed they can be copied to some other computer in exactly one hour Your task is to find the minimum number of hours required to copy the update files to all n computers if there are only k patch cables in Berland State University ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tint f=1;char c;x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=200005;\n\nvoid solve()\n{\n\tll n,k;\n\treadint(n),readint(k);\n\tll u=1,s=1,c=0;\n\tif(s>=n){printf(""%lld\\n"",c);return;}\n\tfor(;u<=k;u*=2)\n\t{\n\t\ts+=u,++c;\n\t\tif(s>=n){printf(""%lld\\n"",c);return;}\n\t}\n\tprintf(""%lld\\n"",c+(n-s+k-1)/k);\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Update Files.json,https://codeforces.com//blog/entry/96454,Let be the current number of computers with the update already installed initially it is Then in hour we can increase by From here we can see that the value of will double for the first few hours and then when it becomes greater than it will begin to increase by exactly The process when the number of computers doubles can be modeled using a loop because the number of doublings does not exceed And after that we have to increase the answer by to take the number of additions of into account Note that computing should be done without using fractional data types to calculate in integers you should divide by using integer division this will work provided that both and are non negative and If you use real numbers this may cause precision issues 
https://codeforces.com//contest/1948/problem/B,2532314,B,1948B,1948,B. Array Fix,You are given an integer array a of length n You can perform the following operation any number of times possibly zero take any element of the array a which is at least 10 delete it and instead insert the digits that element consisted of in the same position in order they appear in that element For example if we apply this operation to the 3 rd element of the array 12 3 45 67 then the array becomes 12 3 4 5 67 if we apply this operation to the 2 nd element of the array 2 10 then the array becomes 2 1 0 Your task is to determine whether it is possible to make a sorted in non descending order using the aforementioned operation In other words you have to determine if it is possible to transform the array a in such a way that a 1 le a 2 le dots le a k where k is the current length of the array a ,"['/**\n *    author:  tourist\n *    created: 15.03.2024 10:39:06\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    bool fail = false;\n    int p = 0;\n    for (int x : a) {\n      if (x >= 10 && x / 10 >= p && x % 10 >= x / 10) {\n        p = x % 10;\n      } else {\n        if (x >= p) {\n          p = x;\n        } else {\n          fail = true;\n          break;\n        }\n      }\n    }\n    cout << (fail ? ""NO"" : ""YES"") << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['brute force', 'dp', 'greedy', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Array Fix.json,https://codeforces.com//blog/entry/127182,The key to solving the problem is the following observation if a i a i 1 then the i th element should always be split since it is the only way to decrease the element compared with a i 1 This observation allows us to solve the problem greedily as follows iterate on the array a from right to left keeping track of the list of elements we processed if the current element is greater than the last element in our list we have to split it and add the digits it consists of to the list otherwise we don t have to split it because it might forbid some of the next elements and force them to split as well After that we have to make sure we obtained a sorted array because for example a number like 98 will break the sorted order if we split it and we didn t check that But since we maintained the list of elements we processed that s quite easy because that list is the resulting array a in reversed order 
https://codeforces.com//contest/1138/problem/B,309124,B,1138B,1138,B. Circus,Polycarp is a head of a circus troupe There are n an even number artists in the troupe It is known whether the i th artist can perform as a clown if yes then c i 1 otherwise c i 0 and whether they can perform as an acrobat if yes then a i 1 otherwise a i 0 Split the artists into two performances in such a way that each artist plays in exactly one performance the number of artists in the two performances is equal i e equal to frac n 2 the number of artists that can perform as clowns in the first performance is the same as the number of artists that can perform as acrobats in the second performance ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000;\nint n;\nchar s[maxn + 10], t[maxn + 10];\nvector<int> a, b, c, d;\n\nint main() {\n\tscanf(""%d"", &n);\n\tscanf(""%s%s"", s + 1, t + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (s[i] == \'0\' && t[i] == \'0\') a.push_back(i);\n\t\telse if (s[i] == \'1\' && t[i] == \'0\') b.push_back(i);\n\t\telse if (s[i] == \'0\' && t[i] == \'1\') c.push_back(i);\n\t\telse if (s[i] == \'1\' && t[i] == \'1\') d.push_back(i);\n\tfor (int i = 0; i <= (int)b.size(); ++i)\n\t\tfor (int j = 0; j <= (int)d.size(); ++j) {\n\t\t\tint s = (int)c.size() - i - 2 * j + (int)d.size();\n\t\t\tif (s >= 0 && s <= (int)c.size()) {\n\t\t\t\tint all = i + s + j;\n\t\t\t\tint k = n / 2 - all;\n\t\t\t\tif (k >= 0 && k <= (int)a.size()) {\n\t\t\t\t\tfor (int p = 0; p < k; ++p) printf(""%d "", a[p]);\n\t\t\t\t\tfor (int p = 0; p < i; ++p) printf(""%d "", b[p]);\n\t\t\t\t\tfor (int p = 0; p < s; ++p) printf(""%d "", c[p]);\n\t\t\t\t\tfor (int p = 0; p < j; ++p) printf(""%d "", d[p]);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(""-1"");\n}']",,,"['brute force', 'greedy', 'math', 'strings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Circus.json,https://codeforces.com//blog/entry/65825,Note that there are only four types of artists 0 0 0 1 1 0 1 1 So the whole problem can be described with four integers the number of artists of each type Let s say that there are 0 0 artists 0 1 artists 1 0 artists 1 1 artists In the same manner the selection of artists for the first performance can be described with four integers Note that we have some restrictions on In particular we need to select exactly half of the artists Also we have a requirement that the number of clowns in first performance must be equal to number of acrobats in the second so we have This equations are necessary and sufficient So we have 4 unknown variables and 2 equations We can bruteforce any two variables calculate using them other two variables And if everything went well print an answer Complexity 
https://codeforces.com//contest/1496/problem/A,920580,A,1496A,1496,A. Split it ,Kawashiro Nitori is a girl who loves competitive programming One day she found a string and an integer As an advanced problem setter she quickly thought of a problem Given a string s and a parameter k you need to check if there exist k 1 non empty strings a 1 a 2 a k 1 such that s a 1 a 2 ldots a k a k 1 R a k R a k 1 ldots R a 1 Here represents concatenation We define R x as a reversed string x For example R abcd dcba Note that in the formula above the part R a k 1 is intentionally skipped ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\nint n,m,T,k;\nchar s[105];\nint main(){\n\tcin>>T;\n\twhile (T--){\n\t\tcin>>n>>k;\n\t\tscanf(""%s"",s+1);\n\t\tif (k*2==n){\n\t\t\tputs(""NO"");\n\t\t\tcontinue;\n\t\t}\n\t\tint flag=0;\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tif (s[i]!=s[n-i+1]){\n\t\t\t\tputs(""NO"");\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!flag)puts(""YES"");\n\t}\n}\n']",,,"['brute force', 'constructive algorithms', 'greedy', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Split it .json,https://codeforces.com//blog/entry/88533,If or is a palindrome the answer is yes Otherwise the answer is no Note that when the answer is no too The time complexity is for each test case 
https://codeforces.com//contest/1998/problem/E2,2808664,E2,1998E2,1998,E2. Eliminating Balls With Merging  Hard Version ,Sun Tzu You are given two integers n and x x 1 There are n balls lined up in a row numbered from 1 to n from left to right Initially there is a value a i written on the i th ball For each integer i from 1 to n we define a function f i as follows Suppose you have a set S 1 2 ldots i In each operation you have to select an integer l 1 leq l i from S such that l is not the largest element of S Suppose r is the smallest element in S which is greater than l If a l a r you set a l a l a r and remove r from S If a l a r you set a r a l a r and remove l from S If a l a r you choose either the integer l or r to remove from S If you choose to remove l from S you set a r a l a r and remove l from S If you choose to remove r from S you set a l a l a r and remove r from S f i denotes the number of integers j 1 le j le i such that it is possible to obtain S j after performing the above operations exactly i 1 times For each integer i from x to n you need to find f i ,"['#include <bits/stdc++.h>using namespace std;\xa0#define int long long\xa0const int INF=0x3f3f3f3f3f3f3f3f;const int N=2e5+5;\xa0int lc[N], rc[N], stk[N], sum[N], a[N], n;\xa0struct Segment_Tree1{\tint L[N*4], R[N*4], add[N*4], Min[N*4], cnt[N*4], val[N];\xa0\tSegment_Tree1()\t{\t\tmemset(L,0,sizeof(L));\t\tmemset(R,0,sizeof(R));\t\tmemset(add,0,sizeof(add));\t\tmemset(Min,0,sizeof(Min));\t\tmemset(cnt,0,sizeof(cnt));\t\tmemset(val,0,sizeof(val));\t}\xa0\tvoid pushup(int rt)\t{\t\tMin[rt]=min(Min[rt*2],Min[rt*2+1]);\t\tcnt[rt]=0;\t\tif(Min[rt]==Min[rt*2])\t\t\tcnt[rt] += cnt[rt*2];\t\tif(Min[rt]==Min[rt*2+1])\t\t\tcnt[rt] += cnt[rt*2+1];\t}\xa0\tvoid Add(int rt,int val)\t{\t\tadd[rt] += val;\t\tMin[rt] += val;\t}\xa0\tvoid pushdown(int rt)\t{\t\tif(add[rt])\t\t{\t\t\tAdd(rt*2,add[rt]);\t\t\tAdd(rt*2+1,add[rt]);\t\t\tadd[rt]=0;\t\t}\t}\xa0\tvoid update(int rt,int l,int r,int val)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t{\t\t\tAdd(rt,val);\t\t\treturn;\t\t}\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l<=mid)\t\t\tupdate(rt*2,l,r,val);\t\tif(mid+1<=r)\t\t\tupdate(rt*2+1,l,r,val);\t\tpushup(rt);\t}\xa0\tpair<int,int> query(int rt,int l,int r)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t\treturn make_pair(Min[rt],cnt[rt]);\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l>mid)\t\t\treturn query(rt*2+1,l,r);\t\tif(mid+1>r)\t\t\treturn query(rt*2,l,r);\xa0\t\tpair <int,int> L=query(rt*2,l,r);\t\tpair <int,int> R=query(rt*2+1,l,r);\t\tpair <int,int> ans=make_pair(min(L.first,R.first),0);\t\tif(L.first==ans.first)\t\t\tans.second += L.second;\xa0\t\tif(R.first==ans.first)\t\t\tans.second += R.second;\t\treturn ans;\t}\xa0\tint lstpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn 0;\xa0\t\tif(L[rt]==R[rt])\t\t\treturn L[rt];\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn lstpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn lstpos(rt*2+1,l,r,val);\xa0\t\tint rans=lstpos(rt*2+1,l,r,val);\t\tif(rans==0)\t\t\treturn lstpos(rt*2,l,r,val);\t\treturn rans;\t}\xa0\tint firpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn n+1;\xa0\t\tif(L[rt]==R[rt])\t\t\treturn L[rt];\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn firpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn firpos(rt*2+1,l,r,val);\xa0\t\tint lans=firpos(rt*2,l,r,val);\t\tif(lans==n+1)\t\t\treturn firpos(rt*2+1,l,r,val);\t\treturn lans;\t}\xa0\tvoid build(int rt,int l,int r)\t{\t\tL[rt]=l, R[rt]=r, add[rt]=0;\t\tif(l==r)\t\t{\t\t\tMin[rt]=val[l], cnt[rt]=1;\t\t\treturn;\t\t}\xa0\t\tint mid=(l+r)/2;\t\tbuild(rt*2,l,mid);\t\tbuild(rt*2+1,mid+1,r);\t\tpushup(rt);\t}}tr1, tr2, tr3;\xa0int L[N*35], R[N*35], indx;bool del[N*35];\xa0struct Segment_Tree2{\tvector <int> vec[N*4];\xa0\tvoid update(int rt,int l,int r,int ql,int qr,int val)\t{\t\tif(ql<=l && r<=qr)\t\t{\t\t\tvec[rt].push_back(val);\t\t\treturn;\t\t}\xa0\t\tint mid=(l+r)/2;\t\tif(ql<=mid)\t\t\tupdate(rt*2,l,mid,ql,qr,val);\t\tif(mid+1<=qr)\t\t\tupdate(rt*2+1,mid+1,r,ql,qr,val);\t}\xa0\tvoid query(int rt,int l,int r,int pos)\t{\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\tvec[rt].clear();\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tquery(rt*2,l,mid,pos);\t\telse\t\t\tquery(rt*2+1,mid+1,r,pos);\t}\xa0\tvoid queryl(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(L[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec);\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryl(rt*2,l,mid,pos);\t\telse\t\t\tqueryl(rt*2+1,mid+1,r,pos);\t}\xa0\tvoid queryr(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(R[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec);\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryr(rt*2,l,mid,pos);\t\telse\t\t\tqueryr(rt*2+1,mid+1,r,pos);\t}}tr4;\xa0void dfs(int l,int r,int root){\tif(l>r)\t\treturn;\xa0\tif(sum[r]-sum[l-1]<a[l-1] && sum[r]-sum[l-1]<a[r+1])\t{\t\tindx++, L[indx]=l, R[indx]=r;\t\ttr4.update(1,1,n,l,r,indx);\t\ttr1.update(1,l,r,1);\t}\xa0\tdfs(l,root-1,lc[root]);\tdfs(root+1,r,rc[root]);}\xa0void build(){\ta[0]=a[n+1]=INF;\tint top=0, root=0;\tfor(int i=1;i<=n;i++)\t{\t\tstk[top+1]=0;\t\twhile(top && a[stk[top]]<=a[i])\t\t\ttop--;\xa0\t\tif(top)\t\t\trc[stk[top]]=i;\t\telse\t\t\troot=i;\xa0\t\tlc[i]=stk[top+1];\t\tstk[++top]=i;\t}\xa0\tdfs(1,n,root);}\xa0int c[N];\xa0int query_sum(int x){\tint ans=0;\tfor(int i=x;i;i-=i&-i)\t\tans += c[i];\treturn ans;}\xa0void update_sum(int x,int y){\tfor(int i=x;i<=n;i+=i&-i)\t\tc[i] += y;}\xa0void work(){\tint x;\tcin >> n >> x;\tfor(int i=1;i<=indx;i++)\t\tL[i]=R[i]=del[i]=0;\tindx=0;\xa0\tfor(int i=0;i<=n;i++)\t\tc[i]=lc[i]=rc[i]=sum[i]=a[i]=stk[i]=0;\xa0\tfor(int i=0;i<=n*4;i++)\t\ttr4.vec[i].clear();\xa0\tfor(int i=1;i<=n;i++)\t{\t\tscanf(""%lld"",&a[i]);\t\tupdate_sum(i,a[i]);\t\tsum[i]=sum[i-1]+a[i];\t}\xa0\tfor(int i=1;i<=n;i++)\t{\t\ttr2.val[i]=sum[i-1]-a[i];\t\ttr3.val[i]=-a[i]-sum[i];\t}\xa0\ttr1.build(1,1,n), tr2.build(1,1,n), tr3.build(1,1,n);\tbuild();\xa0\tfor(int i=x;i<=n;i++)\t{\t\tint l=1, r=i;\t\tif(l==r)\t\t{\t\t\tprintf(""1\\n"");\t\t\tcontinue;\t\t}\xa0\t\tint pos1=tr2.lstpos(1,l+1,r,query_sum(l-1))-1;\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,1);\xa0\t\tint pos2=tr3.firpos(1,l,r-1,-query_sum(r))+1;\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,1);\xa0\t\tprintf(""%lld\\n"",tr1.query(1,l,r).second);\xa0\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,-1);\xa0\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,-1);\t}}\xa0signed main(){\tint T;\tcin >> T;\twhile(T--)\t\twork();\treturn 0;}']",,,"['binary search', 'brute force', 'data structures', 'divide and conquer', 'greedy', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E2. Eliminating Balls With Merging  Hard Version .json,https://codeforces.com//blog/entry/132512,Hint 1 For each element j there is a range Lj Rj in which it can be present as last elemt Hint 2 Modify the Solve function to now return what is the minimum index Lj instead of boolean earlier Basically find minimum Lj such that element j can become A1 A2 ALj Hint 3 Also for each index i precalcute how much right it can go Use this to calculate Rj based on Lj Hint 4 Otherway around you can also return this range in your solve function 
https://codeforces.com//contest/1799/problem/C,1800599,C,1799C,1799,C. Double Lexicographically Minimum,You are given a string s You can reorder the characters to form a string t Define t mathrm max to be the lexicographical maximum of t and t in reverse order Given s determine the lexicographically minimum value of t mathrm max over all reorderings t of s A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    std::string t(n, \'?\');\n    \n    int cnt[26] {};\n    for (auto c : s) {\n        cnt[c - \'a\']++;\n    }\n    \n    int l = 0, r = n - 1;\n    for (int c = 0; c < 26; c++) {\n        while (cnt[c] >= 2) {\n            cnt[c] -= 2;\n            t[l++] = t[r--] = \'a\' + c;\n        }\n        if (cnt[c] == 1) {\n            cnt[c] -= 1;\n            if (l == r) {\n                t[l] = \'a\' + c;\n            } else {\n                int x = c + 1;\n                while (cnt[x] == 0) {\n                    x++;\n                }\n                if (cnt[x] == r - l) {\n                    while (cnt[x] >= 2) {\n                        cnt[x] -= 2;\n                        t[l++] = t[r--] = \'a\' + x;\n                    }\n                    if (cnt[x] == 1) {\n                        cnt[x] -= 1;\n                        t[l++] = \'a\' + x;\n                    }\n                    t[r] = \'a\' + c;\n                } else {\n                    for (; x < 26; x++) {\n                        while (cnt[x] > 0) {\n                            cnt[x] -= 1;\n                            t[l++] = \'a\' + x;\n                        }\n                    }\n                    t[r] = \'a\' + c;\n                }\n            }\n            break;\n        }\n    }\n    \n    std::cout << t << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['greedy', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Double Lexicographically Minimum.json,https://codeforces.com//blog/entry/113321,Let s iterate all symbols of in order from smallest to largest and construct an answer Let the current symbol be If there are at least remaining symbols equal to we should add them to the current prefix and suffix of and continue If there are at most one other symbol is left there are and times left in we should add symbols symbol and symbols to the prefix of and break Otherwise we should add all remaining symbols of excluding to prefix of in the sorted order and after it symbol Time complexity where 
https://codeforces.com//contest/1494/problem/B,913251,B,1494B,1494,B. Berland Crossword,Berland crossword is a puzzle that is solved on a square grid with n rows and n columns Initially all the cells are white To solve the puzzle one has to color some cells on the border of the grid black in such a way that exactly U cells in the top row are black exactly R cells in the rightmost column are black exactly D cells in the bottom row are black exactly L cells in the leftmost column are black Note that you can color zero cells black and leave every cell white Your task is to check if there exists a solution to the given puzzle ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\n\n\nvoid solve()\n{\n    int n, U, R, D, L;\n    cin>>n>>U>>R>>D>>L;\n\n    for (int mask = 0; mask<16; mask++)\n    {\n        bool check = true;\n\n        int u = 0, d = 0, r = 0, l = 0;\n        if (mask&1)\n        {\n            u++; l++;\n        }\n        if (mask&2)\n        {\n            l++; d++;\n        }\n        if (mask&4)\n        {\n            d++; r++;\n        }\n        if (mask&8)\n        {\n            r++; u++;\n        }\n        if (u>U || u + (n-2)<U) check = false;\n        if (d>D || d + (n-2)<D) check = false;\n        if (l>L || l + (n-2)<L) check = false;\n        if (r>R || r + (n-2)<R) check = false;\n\n        if (check) {cout<<""YES""<<endl; return;}\n    }\n    cout<<""NO""<<endl;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}']",,,"['bitmasks', 'brute force', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Berland Crossword.json,https://codeforces.com//blog/entry/88344,Consider some corner of the picture If it s colored black then it contributes to counts to both of the adjacent sides Otherwise it contributes to none All the remaining cells can contribute only to the side they are on There are of such cells on each side So let s try all options of coloring the corners After fixing the colors of the corners we can calculate the number of cells that have to be colored on each side That is calculated by taking the initial requirement and subtracting the adjacent colored corners from it If any of the numbers is below or above then that corner coloring doesn t work Otherwise you can always color the cells in some way Overall complexity per testcase 
https://codeforces.com//contest/1749/problem/A,1596422,A,1749A,1749,A. Cowardly Rooks,There s a chessboard of size n times n m rooks are placed on it in such a way that no two rooks occupy the same cell no two rooks attack each other A rook attacks all cells that are in its row or column Is it possible to move rook you can choose which one to move into a different cell so that no two rooks still attack each other A rook can move into any cell in its row or column if no other rook stands on its path ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll t;cin>>t;\n  while(t--){\n    ll n,m;cin>>n>>m;\n    rep(i,0,m){\n      ll x,y;cin>>x>>y;\n    }\n    ans2(n>m);\n  }\n  return 0;\n}']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Cowardly Rooks.json,https://codeforces.com//blog/entry/108269,First note that is always less than or equal to If there were at least rooks on the board at least two of them would share a row or a column by pigeonhole principle If then there is always at least one free row and at least one free column You can move any rook into that row or column Otherwise all rows and columns are taken so any move will make two rooks share a row or a column which is prohibited Thus if then it s Otherwise it s Overall complexity per testcase Alternatively you could check every rook and every possible move Overall complexity per testcase 
https://codeforces.com//contest/521/problem/B,23439,B,521B,521,B. Cubes,Once Vasya and Petya assembled a figure of cubes each of them is associated with a number between and inclusive each number appeared exactly once Let s consider a coordinate system such that the is the ground and the is directed upwards Each cube is associated with the coordinates of its lower left corner these coordinates are integers for each cube The figure turned out to be This means that for any cube that is not on the ground there is at least one cube under it such that those two cubes touch More formally this means that for the cube with coordinates either or there is a cube with coordinates or Now the boys want to disassemble the figure and put all the cubes in a row In one step the cube is removed from the figure and being put to the right of the blocks that have already been laid The guys remove the cubes in such order that the figure remains stable To make the process more interesting the guys decided to play the following game The guys take out the cubes from the figure in turns It is easy to see that after the figure is disassembled the integers written on the cubes form a number written in the ary positional numerical system possibly with a leading zero Vasya wants the resulting number to be maximum possible and Petya on the contrary tries to make it as small as possible Vasya starts the game Your task is to determine what number is formed after the figure is disassembled if the boys play optimally Determine the remainder of the answer modulo ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define mp make_pair\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << ""("" << a.first << "", "" << a.second << "")""; };\ntemplate <typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate <typename T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <typename T> void chmax(T &t, const T &f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\nconst Int MO = 1000000009;\n\nint N;\nint X[100010], Y[100010];\n\nmap<pint, int> tr;\nint nei[100010][5][3];\n\nbool is[100010];\n\nset<int> cands;\nbool on[100010];\n\nbool canRemove(int u) {\n#define has(e,f) is[nei[u][e][f]]\n\tif (has(1, 2) && !has(0, 1) && !has(1, 1)) return false;\n\tif (has(2, 2) && !has(1, 1) && !has(3, 1)) return false;\n\tif (has(3, 2) && !has(3, 1) && !has(4, 1)) return false;\n\treturn true;\n#undef has\n}\n\nint main() {\n\t\n\t\n\tfor (; ~scanf(""%d"", &N); ) {\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\tX[u] = in();\n\t\t\tY[u] = in();\n\t\t}\n\t\ttr.clear();\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\ttr[mp(X[u], Y[u])] = u;\n\t\t}\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\tfor (int e = 0; e < 5; ++e) for (int f = 0; f < 3; ++f) {\n\t\t\t\tauto it = tr.find(mp(X[u] - 2 + e, Y[u] - 1 + f));\n\t\t\t\tnei[u][e][f] = (it != tr.end()) ? it->second : N;\n\t\t\t}\n\t\t}\n\t\tfill(is, is + N, true);\n\t\tis[N] = false;\n\t\t\n\t\tcands.clear();\n\t\tfill(on, on + N, false);\n\t\tfor (int u = 0; u < N; ++u) {\n\t\t\tif (canRemove(u)) {\n\t\t\t\tcands.insert(u);\n\t\t\t\ton[u] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tInt ans = 0;\n\t\tfor (int turn = 0; turn < N; ++turn) {\n\t\t\tassert(!cands.empty());\n\t\t\tint u = -1;\n\t\t\tswitch (turn % 2) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tu = *--cands.end();\n\t\t\t\t} break;\n\t\t\t\tcase 1: {\n\t\t\t\t\tu = *cands.begin();\n\t\t\t\t} break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t\tassert(is[u]);\n\t\t\tans = (ans * N + u) % MO;\n\t\t\tcands.erase(u);\n\t\t\ton[u] = false;\n\t\t\tis[u] = false;\n\t\t\tfor (int e = 0; e < 5; ++e) for (int f = 0; f < 3; ++f) {\n\t\t\t\tconst int v = nei[u][e][f];\n\t\t\t\tif (is[v]) {\n\t\t\t\t\tconst bool res = canRemove(v);\n\t\t\t\t\tif (on[v] != res) {\n\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\tcands.insert(v);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcands.erase(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ton[v] = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n']",,,"['data structures', 'greedy', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Cubes.json,https://codeforces.com//blog/entry/16736,Basically the first player should maximize the lexicographical order of numbers and the second player should minimize it Thus at every move the first player should choose the largest available number and the second should choose the minimal one First of all how do we check if the cube can be removed It is impossible only if there is some cube supported by it i e it has coordinates x 1 y 1 x y 1 x 1 y 1 such that our cube is the only one supporting it This can be checked explicitly The large coordinates limitations do not allow us to store a simply array for that so we should use an associative array like a set in C Now we should find the maximal minimal number that can be removed A simple linear search won t work fast enough so we store another data structure containing all numbers available to remove the structure should allow inserting erasing and finding global minimum maximum so the set C structure fits again When we ve made our move some cubes may have become available or unavailable to remove However there is an O 1 amount of cubes we have to recheck and possibly insert erase from our structure the cubes x 1 y and x 2 y may have become unavailable because some higher cube has become dangerous that is there is a single cube supporting it and some of the cubes x 1 y 1 x y 1 and x 1 y 1 may have become available because our cube was the only dangerous cube that it has been supporting Anyway a simple recheck for these cubes will handle all the cases 
https://codeforces.com//contest/809/problem/D,106953,D,809D,809,D. Hitchhiking in the Baltic States,Leha and Noora decided to go on a trip in the Baltic States As you know from the previous problem Leha has lost his car on the parking of the restaurant Unfortunately requests to the watchman didn t helped hacker find the car so friends decided to go hitchhiking In total they intended to visit towns However it turned out that sights in th town are open for visitors only on days from to What to do Leha proposed to choose for each town a day when they will visit this town i e any integer in interval After that Noora choses some subsequence of towns which friends are going to visit that at first they are strictly increasing i e is for all integers from to but also the dates of the friends visits are strictly increasing i e is true for all integers from to Please help Leha and Noora in choosing such for each town and such subsequence of towns so that friends can visit maximal number of towns You may assume that Leha and Noora can start the trip any day ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int inf=1000*1000*1007;\n\nstruct node\n{\n\tint id;\n\tint roz;\n\tint prior;\n\tnode * lew;\n\tnode * pra;\n\tnode * oj;\n\t\n\tlong long narz;\n\tlong long war;\n\t\n\tnode(int idid)\n\t{\n\t\tprior=rand();\n\t\tlew=NULL;\n\t\tpra=NULL;\n\t\toj=NULL;\n\t\troz=1;\n\t\tid=idid;\n\t\tnarz=0;\n\t\twar=inf;\n\t}\n\tnode()\n\t{\n\t\tprior=rand();\n\t\tlew=NULL;\n\t\tpra=NULL;\n\t\toj=NULL;\n\t\troz=1;\n\t\tnarz=0;\n\t\twar=inf;\n\t}\n};\ninline void update(node * v)\n{\n\tif (v==NULL)\n\t\treturn;\n\tv->roz=1;\n\tv->war+=v->narz;\n\tif (v->lew!=NULL)\n\t{\n\t\tv->lew->narz+=v->narz;\n\t\tv->roz+=v->lew->roz;\n\t}\n\tif (v->pra!=NULL)\n\t{\n\t\tv->pra->narz+=v->narz;\n\t\tv->roz+=v->pra->roz;\n\t}\n\tv->narz=0;\n\t//tutaj dodajemy wszystkie operacje związane z funkcjami m.in. drzewa przedziałowego, tzn. lazy propagation itp.\n}\nnode * merge(node * v, node * u)\n{\n\tif (v==NULL)\n\t\treturn u;\n\tif (u==NULL)\n\t\treturn v;\n\tif ((v->prior)>=(u->prior))\n\t{\n\t\tupdate(v);//czasem można usunąć\n\t\tv->pra=merge(v->pra, u);\n\t\tif (v->pra!=NULL)\n\t\t\tv->pra->oj=v;\n\t\tupdate(v);\n\t\treturn v;\n\t}\n\telse\n\t{\n\t\tupdate(u);//czasem można usunąć\n\t\tu->lew=merge(v, u->lew);\n\t\tif (u->lew!=NULL)\n\t\t\tu->lew->oj=u;\n\t\tupdate(u);\n\t\treturn u;\n\t}\n}\npair <node *, node *> split(node * v, const function <bool(node*)> &is_left)//is_left ma stwierdzać, czy dany wierzchołek powinien być w lewej części\n{\n\tif (v==NULL)\n\t\treturn make_pair(v, v);\n\tpair <node *, node *> ret;\n\tupdate(v);//czasem można usunąć\n\tv->oj=NULL;\n\tif (is_left(v))\n\t{\n\t\tret=split(v->pra, is_left);\n\t\tv->pra=ret.first;\n\t\tif (v->pra!=NULL)\n\t\t\tv->pra->oj=v;\n\t\tret.first=v;\n\t}\n\telse\n\t{\n\t\tret=split(v->lew, is_left);\n\t\tv->lew=ret.second;\n\t\tif (v->lew!=NULL)\n\t\t\tv->lew->oj=v;\n\t\tret.second=v;\n\t}\n\tupdate(v);\n\treturn ret;\n}\nint gl_help;\nfunction <bool(node*)> cut_v(int v)//ucnina v pierwszych elementow\n{\n\tgl_help=v;\n\treturn [](node* u)->bool\n\t{\n\t\tint pom=1;\n\t\tif (u->lew!=NULL)\n\t\t\tpom+=u->lew->roz;\n\t\tif (pom>gl_help)\n\t\t\treturn false;\n\t\tgl_help-=pom;\n\t\treturn true;\n\t};\n}\nfunction <bool(node*)> cut_cos(int v)//ucnina v pierwszych elementow - kuamstfo\n{\n\tgl_help=v;\n\treturn [](node* u)->bool\n\t{\n\t\tupdate(u);\n\t\treturn u->war<gl_help;\n\t};\n}\n\nint n;\n\nnode *korz=NULL;\n\nint main()\n{\n\tkorz=new node();\n\tkorz->war=0;\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n+3; i++)\n\t{\n\t\tnode *tu=new node;\n\t\tkorz=merge(korz, tu);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tauto jed=split(korz, cut_cos(l));\n\t\tauto dwa=split(jed.second, cut_cos(r));\n\t\tauto trz=split(dwa.second, cut_v(1));\n\t\ttrz.first->narz=0;\n\t\ttrz.first->war=l;\n\t\tif (dwa.first!=NULL)\n\t\t\tdwa.first->narz++;\n\t\tkorz=merge(jed.first, merge(trz.first, merge(dwa.first, trz.second)));\n\t}\n\tauto jed=split(korz, cut_cos(inf-1));\n\tprintf(""%d\\n"", jed.first->roz-1);\n\treturn 0;\n}\n']",,,"['data structures', 'dp']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Hitchhiking in the Baltic States.json,https://codeforces.com/blog/entry/52099,Let minimal number that can be last in strictly increasing subsequence with length Iterate through prefixes of intervals and maintain this dp Obviously this dp is strictly increasing What happens when we add new interval In the rightmost position such that we can make a transion Since the rightmost position than this i e Let the rightmost position such that the for each we can make a transition But since than so this Thinking from the facts above we can solve this task maintaining dp in cartesian tree treap Let s find and split interval from to Add to every number in this tree Delete t node And merge everything adding one more node with key 
https://codeforces.com//contest/1611/problem/E2,1202189,E2,1611E2,1611,E2. Escape The Maze  hard version , Vlad built a maze out of n rooms and n 1 bidirectional corridors From any room u any other room v can be reached through a sequence of corridors Thus the room system forms an undirected tree Vlad invited k friends to play a game with them Vlad starts the game in the room 1 and wins if he reaches a room other than 1 into which exactly one corridor leads Friends are placed in the maze the friend with number i is in the room x i and no two friends are in the same room that is x i neq x j for all i neq j Friends win if one of them meets Vlad in any room or corridor before he wins For one unit of time each participant of the game can go through one corridor All participants move at the same time Participants may not move Each room can fit all participants at the same time Friends know the plan of a maze and intend to win They don t want to waste too much energy They ask you to determine if they can win and if they can what number of friends must remain in the maze so that they can always catch Vlad In other words you need to determine the size of the minimum by the number of elements subset of friends who can catch Vlad or say that such a subset does not exist ,"['#include <bits/stdc++.h>\ntypedef std::pair<int,int> pii;\ntypedef std::pair<pii,int> ppi;\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        int N,K;\n        std::cin>>N>>K;\n        std::vector<int> con[N];\n        std::queue<ppi> niveis;\n        int tol[N]={};\n        bool visitou[N]={};\n        int amg[N]={};\n        for(int i=0;i!=K;++i){\n            int x;\n            std::cin>>x;--x;\n            niveis.push({{x,0},i});\n        }\n        for(int i=1;i!=N;++i){\n            int a,b;\n            std::cin>>a>>b;\n            --a;--b;\n            con[a].push_back(b);\n            con[b].push_back(a);\n        }\n        while(niveis.size()){\n            auto __ = niveis.front();\n            auto _ = __.first;\n            niveis.pop();\n            if(visitou[_.first])continue;\n            visitou[_.first]=true;\n            amg[_.first]=__.second;\n            tol[_.first]=_.second;\n            for(auto&x:con[_.first]){\n                niveis.push({{x,_.second+1},__.second});\n            }\n        }\n        std::queue<pii> bfs2;\n        bfs2.push({0,0});\n        bool vis[N]={};\n        bool mau_amigo[K]={};\n        while(bfs2.size()){\n            auto _ = bfs2.front();\n            bfs2.pop();\n            if(tol[_.first]<=_.second){\n                mau_amigo[amg[_.first]]=true;\n                continue;\n            }\n            if(vis[_.first])continue;\n            vis[_.first]=true;\n            if(con[_.first].size()==1&&_.first){\n                printf(""-1\\n"");\n                goto prox;\n            }\n            for(auto&x:con[_.first])bfs2.push({x,_.second+1});\n        }{\n        int count=0;\n        for(auto&x:mau_amigo)if(x)++count;\n        std::cout<<count<<""\\n"";}\n        prox:{}\n    }\n}\n']",,,"['dfs and similar', 'dp', 'greedy', 'shortest paths', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E2. Escape The Maze  hard version .json,https://codeforces.com//blog/entry/97288,Let s learn how to find an answer for the subtree rooted in vertex At first it is obvious from E1 tutorial that if the nearest to vertex with a friend from this subtree is no further from it than the root of the entire tree from then the answer for the entire subtree is since a friend can come to and catch Vlad in it not allowing him to go to any leaf of this subtree Else we will find the answer leaning on its children If a solution does not exist for at least one child then it does not exist for the entire subtree because after reaching Vlad will be able to go to such child and reach any exit Otherwise the answer for is the sum of the answers of its children since we need to beat it in each subtree to win and for each subtree we have found the minimum answer 
https://codeforces.com//contest/1516/problem/C,963908,C,1516C,1516,C. Baby Ehab Partitions Again,Baby Ehab was toying around with arrays He has an array a of length n He defines an array to be good if there s no way to partition it into 2 subsequences such that the sum of the elements in the first is equal to the sum of the elements in the second Now he wants to remove the minimum number of elements in a so that it becomes a good array Can you help him A sequence b is a subsequence of an array a if b can be obtained from a by deleting some possibly zero or all elements A partitioning of an array is a way to divide it into 2 subsequences such that every element belongs to exactly one subsequence so you must use all the elements and you can t share any elements ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,a[2002],sum,G;\nbitset<200002>B;\nint main(){\n\tn=read(),B[0]=1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=read(),sum+=a[i];\n\t\tB|=(B<<a[i]);\n\t}\n\tif((sum&1)||(!B[sum>>1]))return puts(""0""),0;\n\tG=a[1];\n\tfor(re int i=2;i<=n;++i)G=__gcd(G,a[i]);\n\tfor(re int i=1;i<=n;++i)a[i]/=G;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]&1){\n\t\t\tprintf(""1\\n%d"",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n']",,,"['bitmasks', 'constructive algorithms', 'dp', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Baby Ehab Partitions Again.json,https://codeforces.com//blog/entry/89846,First of all let s check if the array is already good This can be done with knapsack dp If it is the answer is If it isn t I claim you can always remove one element to make it good and here s how to find it Since the array can be partitioned its sum is even So if we remove an odd element it will be odd and there will be no way to partition it If there s no odd element then all elements are even But then you can divide all the elements by without changing the answer Why Because a partitioning in the new array after dividing everything by is a partitioning in the original array and vice versa We just re scaled everything So while all the elements are even you can keep dividing by until one of the elements becomes odd Remove it and you re done If you want the solution in one sentence remove the element with the smallest possible least significant bit Alternatively for a very similar reasoning you can start by dividing the whole array by its and remove any odd element which must exist because the is but I think this doesn t give as much insight Code link https pastebin com aiknVwkZ 
https://codeforces.com//contest/374/problem/E,4194,E,374E,374,E. Inna and Babies,Inna Dima and Sereja are in one room together It s cold outside so Sereja suggested to play a board game called Babies The babies playing board is an infinite plane containing blue babies and red ones Each baby is a segment that grows in time At time moment the blue baby is a blue segment with ends at points Similarly at time the red baby is a red segment with ends at points of the plane Initially at time all babies are points on the plane The goal of the game is to find the first integer moment of time when the plane contains a rectangle of a non zero area which sides are fully covered by some babies A side may be covered by multiple babies More formally each point of each side of the rectangle should be covered by at least one baby of any color At that you must assume that the babies are closed segments that is they contain their endpoints You are given the positions of all babies help Inna and Dima to find the required moment of time ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 2005;\nint n, m;\nstruct pt {\n\tint x, y;\n\tinline void read() {\n\t\tscanf(""%d%d"", &x, &y);\n\t}\n} a[N], b[N];\nstruct line {\n\tint x1, x2, y1, y2;\n\tline() {}\n\tline(int X1, int Y1, int X2, int Y2) {\n\t\tif (X1 < X2)\t\n\t\t\tx1 = X1, x2 = X2, y1 = Y1, y2 = Y2; else\n\t\t\tx1 = X2, x2 = X1, y1 = Y2, Y2 = y1;\n\t}\n\tinline int k() const {\n\t\treturn x1==x2 ? 1 : (y2-y1) / (x2-x1);\n\t}\n\tinline int at(int x) const {\n\t\treturn y1 + (x-x1) * k();\n\t}\n} l1[N], l2[N];\nint n1, n2, l[N];\ninline bool conj(const line &A, const line &B) {\n\tconst line &a = A.x1 > B.x1 ? B : A, &b = A.x1 > B.x1 ? A : B;\n\tif (a.x2 < b.x1) return 0;\n\treturn a.at(b.x1) == b.y1;\n}\ninline bool inter(const line &a, const line &b) {\n\tint x = -2 * (b.at(0) - a.at(0)) / (b.k() - a.k());\n\treturn a.x1*2<=x && a.x2*2>=x && b.x1*2<=x && b.x2*2>=x;\n}\nline merge(const line &A, const line &B) {\n\tconst line &a = A.x1 > B.x1 ? B : A, &b = A.x1 > B.x1 ? A : B;\n\treturn line(a.x1, a.y1, b.x2, b.y2);\n}\nbool vis[N][N];\nbool check(int t) {\n\tline cur;\n\tbool flag;\n\tn1 = 0;\n\tfor (int i=1; i<=n; ++i) {\n\t\tcur = line(a[i].x-t, a[i].y+t, a[i].x+t, a[i].y-t);\n\t\tflag = 0;\n\t\tfor (int j=1; !flag && j<=n1; ++j) {\n\t\t\tif (conj(l1[j], cur))\n\t\t\t\tl1[j] = merge(l1[j], cur), flag = 1;\n\t\t}\n\t\tif (!flag) l1[++n1] = cur;\n\t}\n\t\n\tn2 = 0;\n\tfor (int i=1; i<=m; ++i) {\n\t\tcur = line(b[i].x-t, b[i].y-t, b[i].x+t, b[i].y+t);\n\t\tflag = 0;\n\t\tfor (int j=1; !flag && j<=n2; ++j) {\n\t\t\tif (conj(l2[j], cur))\n\t\t\t\tl2[j] = merge(l2[j], cur), flag = 1;\n\t\t}\n\t\tif (!flag) l2[++n2] = cur;\n\t}\n\t\n\tint ln;\n\tfor (int i=1; i<=n2; ++i)\n\t\tfor (int j=1; j<=n2; ++j)\n\t\t\tvis[i][j] = 0;\n\tfor (int i=1; i<=n1; ++i) {\n\t\tln = 0;\n\t\tfor (int j=1; j<=n2; ++j)\n\t\t\tif (inter(l1[i], l2[j]))\n\t\t\t\tl[++ln] = j;\n\t\tfor (int j=1; j<=ln; ++j)\n\t\t\tfor (int k=j+1; k<=ln; ++k)\n\t\t\t\tif (vis[l[j]][l[k]])\n\t\t\t\t\treturn 1; else\n\t\t\t\t\tvis[l[j]][l[k]] = 1;\n\t}\n\treturn 0;\n}\ninline bool cmp(pt x, pt y) {\n\treturn x.x < y.x;\n}\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; ++i) a[i].read();\n\tfor (int j=1; j<=m; ++j) b[j].read();\n\tsort(a+1, a+n+1, cmp);\n\tsort(b+1, b+m+1, cmp);\n\tint l = 1, r = 2000005, mid;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid))\n\t\t\tr = mid; else\n\t\t\tl = mid + 1;\n\t}\n\tif (l > 2000000)\n\t\tputs(""Poor Sereja!""); else\n\t\tprintf(""%d\\n"", l);\n\treturn 0;\n}']",,,"['binary search', 'data structures', 'dsu', 'geometry', 'implementation']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Inna and Babies.json,https://codeforces.com//blog/entry/10018,We will make the binary search to find the answer For each time let s generate our segments and rotate them to transform them into horizontal and verticle We can use transformation to Don t forget to make the union of all segments which were at the one diagonal and have an intersection You should sort all segments of one type and iterate through them updating the size of the segment Now we should only determine if there is at least one rectangle For example we can iterate each verticle segment updating the set of all horizontal which begin not later than our verticle For each verticle the left one we should iterate the right verticle and now calculate the set of horizontal which not only begin not later than the left verticle but also don t end earlier than the right one Now we should only determine is ther is two or more horizontal segments from the set which satisfy also y conditions for current vertical 
https://codeforces.com//contest/685/problem/D,63495,D,685D,685,D. Kay and Eternity,Snow Queen told Kay to form a word eternity using pieces of ice Kay is eager to deal with the task because he will then become free and Snow Queen will give him all the world and a pair of skates Behind the palace of the Snow Queen there is an infinite field consisting of cells There are pieces of ice spread over the field each piece occupying exactly one cell and no two pieces occupying the same cell To estimate the difficulty of the task Kay looks at some squares of size cells with corners located at the corners of the cells and sides parallel to coordinate axis and counts the number of pieces of the ice inside them This method gives an estimation of the difficulty of some part of the field However Kay also wants to estimate the total difficulty so he came up with the following criteria for each he wants to count the number of squares of size such that there are exactly pieces of the ice inside Please help Kay estimate the difficulty of the task given by the Snow Queen ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(""%d\\n"",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(""%d\\n"",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define lld ""%I64d""\n#else\n    #define lld ""%lld""\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');c==\'-\'?(sg=-1,x=0):(x=c-\'0\');\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gn(long double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gs(char *s){scanf(""%s"",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n,k;\nstruct pkt{\n\tint x,y;\n\tvoid read(){\n\t}\n}a[111111];\nset<int> se;\nint num[222222],sum[222222];\nint totnum;\nmap<int,int>id;\nint back[222222];\nint xtot=0;\n\nint le[222222],ri[222222];\n\nvoid add(int x,int sumdel,int numdel){\n\tint ii=id[x];\n\n\tsum[ii]+=sumdel;\n\tnum[ii]+=numdel;\n\ttotnum+=numdel;\n\n\tif(num[ii]==0 && numdel==-1){\n\t\tse.erase(x);\n\t\tle[ri[ii]]=le[ii];\n\t\tri[le[ii]]=ri[ii];\n\t}else if(num[ii]==1 && numdel==1){\n\t\tset<int>::iterator it=se.lower_bound(x);\n\t\tint rig=*it;\n\t\tit--;\n\t\tint lef=*it;\n\t\tse.insert(x);\n\t\tri[id[lef]]=ii;le[ii]=id[lef];\n\t\tle[id[rig]]=ii;ri[ii]=id[rig];\n\t}\n}\nstruct seg{\n\tint l,r;\n\tint y;\n\tint del;\n}ss[222222];int sstot=0;\nint cmpy(const seg&a,const seg&b){\n\treturn a.y<b.y;\n}\n\nll ans[111111];\n\nvoid tongji(){\n\n\tint u=ri[1];\n\tint su=sum[u];\n\n\twhile(u!=xtot){\n\t\tint v=ri[u];\n\n\t\tans[su]+=back[v]-back[u];\n\t\tsu+=sum[v];\n\t\tu=v;\n\t}\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(k);\n\trep(i,1,n+1){\n\t\tint x,y;\n\t\tgn(x);gn(y);\n\t\tss[++sstot]=(seg){x-k,x,y-k,+1};\n\t\tss[++sstot]=(seg){x-k,x,y,-1};\n\t\tid[x-k],id[x];\n\t}\n\tid[-inf];id[inf];\n\tse.insert(-inf);se.insert(inf);\n\tforeach(it,id)back[it->se=++xtot]=it->fi;\n\tri[1]=xtot;le[xtot]=1;\n\tsort(ss+1,ss+1+sstot,cmpy);\n\n\n\tint cur=1;\n\tfor (int y=-inf;cur<=sstot;y++){\n\t\twhile(cur<=sstot && ss[cur].y==y){\n\t\t\tif(ss[cur].del==1){\n\t\t\t\tadd(ss[cur].l,1,1);\n\t\t\t\tadd(ss[cur].r,-1,1);\n\t\t\t}else {\n\t\t\t\tadd(ss[cur].l,-1,-1);\n\t\t\t\tadd(ss[cur].r,1,-1);\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\ttongji();\n\t\tif(cur>sstot)break;\n\t\tif(totnum==0){\n\t\t\ty=ss[cur].y-1;\n\t\t}\n\t}\n\trep(i,1,n+1)printf(""%I64d "",ans[i]);\n#ifdef JCVB\n\tdebug(""time: %d\\n"",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n']",,,"['brute force', 'implementation', 'sortings']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Kay and Eternity.json,https://codeforces.com//blog/entry/45558,Let s solve this problem with scanline Go through all rows from left to right and maintain the array in which in j index we will store the number of points in a square with bottom left coordinate i j where i is current row of scanline This takes O MAXCORD2 time Note that the set of squares that contain some of the shaded points is not very large namely if the point has coordinates x y then the set of left bottom corners of square is defined as a b x k 1 a x y k 1 b y Let s consider each point x y as the 2 events Add one to the all elements with indexes from y k 1 to y on the row x k 1 and take one at the same interval on the row x 1 How to calculate answer Suppose we update the value of a cell on the row a and before it was updated the value x on the row b Let add to the answer for the number of squares containing x points value a b We can implement the addition of the segment directly and have O nk for processing all the events that fit in time limit To get rid of O MAXCORD memory we need to write all interested in the coordinates before processing events them no more than nk and reduce the coordinates in the events It takes time and O nk memory Now we can execute the previous point in O nk memory Complexity is time and O nk memory 
https://codeforces.com//contest/1860/problem/D,2169700,D,1860D,1860,D. Balanced String,You are given a binary string s a binary string is a string consisting of characters and or Let s call a binary string if the number of subsequences the number of indices i and j such that 1 le i j le n s i 0 and s j 1 equals to the number of subsequences the number of indices k and l such that 1 le k l le n s k 1 and s l 0 in it For example the string is balanced because both the number of subsequences and the number of subsequences are equal to 6 On the other hand is not balanced because the number of subsequences is 1 but the number of subsequences is 5 You can perform the following operation any number of times choose two characters in s and swap them Your task is to calculate the minimum number of operations to make the string s balanced ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int inf = 1E9;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    int c1 = std::count(s.begin(), s.end(), \'1\'), c0 = n - c1;\n    \n    int need = (n * (n - 1) / 2 - c0 * (c0 - 1) / 2 + c1 * (c1 - 1) / 2) / 2;\n    \n    std::vector dp(c1 + 1, std::vector<int>(need + 1, inf));\n    dp[0][0] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = c1 - 1; j >= 0; j--) {\n            for (int k = 0; k + i <= need; k++) {\n                dp[j + 1][k + i] = std::min(dp[j + 1][k + i], dp[j][k] + (s[i] == \'0\'));\n            }\n        }\n    }\n    std::cout << dp[c1][need] << ""\\n"";\n    \n    return 0;\n}\n']",,,['dp'],2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Balanced String.json,https://codeforces.com//blog/entry/119504,Let s calculate the following dynamic programming the minimum number of changes in string if we consider only first characters of it the number of characters on that prefix is and the number of subsequences on that prefix is equal to The transitions are pretty simple Let s look at the transitions according to the character we are trying to place at the next position if it is then there is transition from the state to the state and the value of depends on the value stays the same if and increases by otherwise if it is then there is transition from the state to the state and the value of depends on the value stays the same if and increases by otherwise So this dynamic programming works in It remains us to get the answer to the problem from that dynamic programming It is stored in where is equal to the number of characters in the string and because the number of subsequences should be equal to the number of subsequences But our dynamic programming stores the number of changes in the string and the problems asks for the minimum number of swaps However we can easily get it from the value Since the amounts of zeroes and ones are fixed in the string then the number of changes from to equals to the number of changes from to and we can pair them up So the answer to the problem is the half of the value 
https://codeforces.com//contest/1793/problem/E,1779691,E,1793E,1793,E. Velepin and Marketing,The famous writer Velepin is very productive Recently he signed a contract with a well known publication and now he needs to write k i books for i th year This is not a problem for him at all he can write as much as he wants about samurai space emptiness insects and werewolves He has n regular readers each of whom in the i th year will read one of the k i books published by Velepin Readers are very fond of discussing books so the j th of them will be satisfied within a year if at least a j persons read the same book as him Velepin has obvious problems with marketing so he turned to you A well known book reading service can control what each of Velepin s regular readers will read but he does not want books to be wasted so And so they turned to you with a request to tell you what the maximum number of regular readers can be made satisfied during each of the years if you can choose each person the book he will read ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint n,q,a[300003];\nint f[300003],ans[300003],pre[300003];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=i)\n\t\t\tf[i]=max(f[i],pre[i-a[i]]+1);\n\t\tpre[i]=max(pre[i-1],f[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i])\n\t\t\tans[f[i]+n-i]=i;\n\t\telse\n\t\t\tans[n-a[i]+1]=i;\n\tfor(int i=n;i>0;i--)\n\t\tans[i]=max(ans[i],ans[i+1]);\n\tcin>>q;\n\twhile(q--){\n\t\tint x;\n\t\tcin>>x;\n\t\tcout<<ans[x]<<'\\n';\n\t}\n}\n""]",,,"['binary search', 'data structures', 'dp', 'greedy', 'sortings', 'two pointers']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Velepin and Marketing.json,https://codeforces.com//blog/entry/112723,Let s sort people by their group size requirement Suppose we have such a person that he is not satisfied and we have a person who is satisfied Then we can replace person in his group with and the answer for us will not be worse It follows that for a particular the answer is some prefix of the people we can make satisfied Let us also prove that there exists some arrangement of groups that covers the same prefix and that each group is a continuous segment Let s take some correct partitioning into groups Then each group will be a set of unconnected segments Let s take the leftmost such segment Note that we can swap it to the nearest segment of the same group to the right without breaking anything Thus we obtained that we can look for a solution in the form of partitioning each prefix into valid groups which are segments We will solve this problem using dynamic programming Let the maximum number of groups into which th prefix can be partitioned so that everyone is satisfied and no elements beyond the prefix can be used Dynamics base empty prefix maximum can be divided into 0 groups Transition for th person his group must have size at least so the transition looks like this But what if Then we can t dial the th prefix Then we put This dynamics can be calculated using prefix maximums This part of the solution works for Earlier we said that the answer would be some prefix of people who would be satisfied If we can partition the prefix into some number of groups then that answer can be the prefix for all we partition our prefix into and the rest of the people one by one into the group If we can t make the whole prefix satisfied then we need to add people from outside Thus the maximum number of groups we can split into if th prefix is completely satisfied is Note that if by some prefix we can score then we can also score combining two groups into one Then we need to find the largest prefix that fits the given in the query This can be done by an array of suffix maximums over total The final asymptotic of the solution is Code 
https://codeforces.com//contest/914/problem/E,148490,E,914E,914,E. Palindromes in a Tree,You are given a tree a connected acyclic undirected graph of vertices Vertices are numbered from to and each vertex is assigned a character from to A path in the tree is said to be palindromic if at least one permutation of the labels in the path is a palindrome For each vertex output the number of palindromic paths passing through it The path from vertex to vertex is considered to be the same as the path from vertex to vertex and this path will be counted only once for each of the vertices it passes through ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=210000;\nint head[N],np[N<<1],p[N<<1],tot;\nint n;\nchar _str[N];\nint col[N];\nint fa[N],size[N];\nbool vis[N],inq[N];\nint q[N];\nLL ans[N];\nint getRoot(int ss){\n\tq[q[0]=1]=ss;\n\tinq[ss]=1;\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfor(int u=head[x];u;u=np[u])if(!vis[p[u]])if(!inq[p[u]]){\n\t\t\tfa[p[u]]=x;\n\t\t\tq[++q[0]]=p[u];\n\t\t\tinq[p[u]]=1;\n\t\t}\n\t}\n\tint mi=1000000;\n\tint rp=0;\n\tper(i,q[0],1){\n\t\tint x=q[i];\n\t\tint ma=-1;\n\t\tsize[x]=1;\n\t\tfor(int u=head[x];u;u=np[u])if(!vis[p[u]])if(inq[p[u]])if(fa[p[u]]==x){\n\t\t\tsize[x]+=size[p[u]];\n\t\t\tma=max(ma,size[p[u]]);\n\t\t}\n\t\tma=max(ma,q[0]-size[x]);\n\t\tif(ma<mi){\n\t\t\tmi=ma;\n\t\t\trp=x;\n\t\t}\n\t}\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tsize[x]=fa[x];inq[x]=0;\n\t}\n\tq[0]=0;\n\treturn rp;\n}\nint val[N];\nvoid bfs1(int rt){\n\tq[q[0]=1]=rt;\n\tinq[rt]=1;\n\tval[rt]=(1<<col[rt]);\n\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfor(int u=head[x];u;u=np[u])if(!inq[p[u]])if(!vis[p[u]]){\n\t\t\tfa[p[u]]=x;\n\t\t\tinq[p[u]]=1;\n\t\t\tval[p[u]]=val[x]^(1<<col[p[u]]);\n\t\t\tq[++q[0]]=p[u];\n\t\t}\n\t}\n}\nint pp[1<<20];\nint ti[1<<20];\nint cnt[1<<20];\nint nowt;\nint meask(int t){\n\tif(ti[t]!=nowt){\n\t\tpp[t]=0;\n\t\tti[t]=nowt;\n\t}\n\treturn pp[t];\n}\nvoid meadd(int t,int v){\n\tif(ti[t]!=nowt){\n\t\tpp[t]=0;\n\t\tti[t]=nowt;\n\t}\n\tpp[t]+=v;\n}\nLL res=0;\nLL sb[N];\nvoid dfs1(int x,int ff){\n\tsb[x]=0;\n\tif(cnt[val[x]]<=1)++sb[x];\n\t//if(ff==2&&x==6)printf(""____________%d\\n"",sb[x]);\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tdfs1(p[u],x);\n\t\tsb[x]+=sb[p[u]];\n\t}\n\tans[x]+=sb[x];\n}\nint nowcol;\nvoid calc1(int x,int ff=-1){\n\tsb[x]=meask(val[x]^(1<<nowcol));\n\trep(i,0,19){\n\t\tint ot=(val[x]^(1<<nowcol));\n\t\tot^=(1<<i);\n\t\tsb[x]+=meask(ot);\n\t}\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tcalc1(p[u],x);\n\t\tsb[x]+=sb[p[u]];\n\t}\n\tans[x]+=sb[x];\n}\nvoid add1(int x,int ff=-1){\n\tmeadd(val[x],1);\n\tfor(int u=head[x];u;u=np[u])if(p[u]!=ff)if(inq[p[u]])if(fa[p[u]]==x)if(!vis[p[u]]){\n\t\tadd1(p[u],x);\n\t}\n}\nint xp[N];\nvoid work(int ss){\n\tint rt=getRoot(ss);\n\tvis[rt]=1;\n\tbfs1(rt);\n\tnowt=rt;\n\tnowcol=col[rt];\n\t//root to it\n\tres=0;\n\tdfs1(rt,-1);\n\txp[0]=0;\n\t//rep(i,1,n)printf("".%d:%lld\\n"",i,ans[i]);\n\tfor(int u=head[rt];u;u=np[u])if(!vis[p[u]])if(inq[p[u]]){\n\t\tcalc1(p[u]);\n\t\tadd1(p[u]);\n\t\txp[++xp[0]]=p[u];\n\t\tans[rt]+=sb[p[u]];\n\t}\n\tnowt=n+rt;\n\tper(i,xp[0],1){\n\t\tint x=xp[i];\n\t\tcalc1(x);\n\t\tadd1(x);\n\t}\n\t//rep(i,1,n)printf(""%d:%lld\\n"",i,ans[i]);\n\t//rep(i,1,n)printf(""_%d:%d\\n"",i,val[i]);\n\trep(i,1,q[0]){\n\t\tint x=q[i];\n\t\tfa[x]=0;\n\t\tinq[x]=0;\n\t\tval[x]=0;\n\t\tsize[x]=0;\n\t}\n\tq[0]=0;\n\tfor(int u=head[rt];u;u=np[u])if(!vis[p[u]])work(p[u]);\n}\nint main(){\n\trep(i,1,(1<<20)-1)cnt[i]=cnt[i>>1]+(i&1);\n\tscanf(""%d"",&n);\n\trep(i,1,n-1){\n\t\tint a,b;scanf(""%d%d"",&a,&b);\n\t\t++tot;p[tot]=b;np[tot]=head[a];head[a]=tot;\n\t\t++tot;p[tot]=a;np[tot]=head[b];head[b]=tot;\n\t}\n\tscanf(""%s"",_str+1);\n\trep(i,1,n)col[i]=_str[i]-\'a\';\n\n\twork(1);\n\trep(i,1,n)printf(""%lld%c"",ans[i],i==n?\'\\n\':\' \');\n\treturn 0;\n}\n\n\n']",,,"['bitmasks', 'data structures', 'divide and conquer', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Palindromes in a Tree.json,https://codeforces.com//blog/entry/57250,The problem can be solved by centroid decomposition A path will be palindromic at most one letter appears odd number of times in the path We maintain a bitmask for each node where th bit is if the th character occurs odd number of times otherwise The path from to is valid if mask mask has at most one bit set to Consider a part as the subtree of the immediate children of the root of the the centroid tree For a node we need to consider the paths that go from its subtree to any other part We add the contribution of nodes in the subtree of a node using a simple dfs and propagating the values above and add the corresponding contribution to the answer of the node currently in consideration dfs Complexity is n log n 20 
https://codeforces.com//contest/1608/problem/C,1223925,C,1608C,1608,C. Game Master,n players are playing a game There are two different maps in the game For each player we know his strength on each map When two players fight on a specific map the player with higher strength on that map always wins No two players have the same strength on the same map You are the game master and want to organize a tournament There will be a total of n 1 battles While there is more than one player in the tournament choose any map and any two remaining players to fight on it The player who loses will be eliminated from the tournament In the end exactly one player will remain and he is declared the winner of the tournament For each player determine if he can win the tournament ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvi unko(int n){\n\tvi a=readvi(n);\n\tvi vs=a;sort(all(vs));\n\trep(i,n)a[i]=lwb(vs,a[i]);\n\treturn a;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=unko(n);\n\tvi b=unko(n);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\tvi ans(n);\n\tint mn=inf;\n\tper(i,n){\n\t\tassert(a[idx[i]]==i);\n\t\tchmin(mn,b[idx[i]]);\n\t\tif(mn==i){\n\t\t\trng(j,i,n){\n\t\t\t\tans[idx[j]]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trep(i,n)cout<<ans[i];\n\tcout<<""\\n"";\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Game Master.json,https://codeforces.com//blog/entry/97782,Let s look at the fights in the reversed order If player is the winner then he won against some player in the last fight In th fight either or won against some player and so on We always expand the set by adding a player that can lose against at least one player in the set so if we can start from and end up with the set of all players can win the tournament If we construct a directed graph where we add an edge from player to player if and only if can win against in a fight the problem is equivalent to finding the set of nodes from which we can reach all the other nodes To reduce the number of edges to we can sort players descending by and by and add only edges from th to th player in these orders Notice that can win the tournament if and only if there is a path from to the player with maximum To find the set of such nodes we can run DFS from the player with maximum on the graph with each edge reversed or do two pointers technique on arrays of players sorted by and 
https://codeforces.com//contest/722/problem/F,74004,F,722F,722,F. Cyclic Cipher,You are given sequences Each sequence consists of positive integers not exceeding All integers in one sequence are distinct but the same integer may appear in multiple sequences The length of the th sequence is Each second integers in each of the sequences are shifted by one to the left i e integers at positions go to positions while the first integers becomes the last Each second we take the first integer of each sequence and write it down to a new array Then for each value from to we compute the longest of the array consisting of element only The above operation is performed for seconds For each integer from to find out the longest segment found at this time ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct info\n{\n    int i, c, m;\n};\n\nint N, M;\nvector<info> A[100001];\nint cnt[41];\nint which[41];\nint g[41][41];\n\nbool check()\n{\n    for(int i=1; i<=40; i++) if(cnt[i])\n        for(int j=i+1; j<=40; j++) if(cnt[j])\n            if(which[i]%g[i][j]!=which[j]%g[i][j])\n                return false;\n    return true;\n}\n\nint subsolve(info *V, int n)\n{\n    for(int i=1; i<=40; i++)\n        cnt[i]=0;\n    int ret=0;\n    for(int i=0, j=0; j<n; j++)\n    {\n        while(cnt[V[j].m]>0 && which[V[j].m]!=V[j].c)\n        {\n            cnt[V[i].m]--;\n            i++;\n        }\n        cnt[V[j].m]++;\n        which[V[j].m]=V[j].c;\n        while(!check())\n        {\n            cnt[V[i].m]--;\n            i++;\n        }\n        ret=max(ret, j-i+1);\n    }\n    return ret;\n}\n\nint solve(vector<info>& V)\n{\n    int ret=0;\n    for(int i=0, j; i<(int)V.size(); i=j)\n    {\n        for(j=i; j<(int)V.size() && j-i==V[j].i-V[i].i; j++);\n        ret=max(ret, subsolve((info*)(V.data()+i), j-i));\n    }\n    return ret;\n}\n\nint main()\n{\n    for(int i=1; i<=40; i++)\n        for(int j=1; j<=40; j++)\n            g[i][j]=__gcd(i, j);\n    scanf(""%d%d"", &N, &M);\n    for(int i=0; i<N; i++)\n    {\n        int K;\n        scanf(""%d"", &K);\n        for(int j=0; j<K; j++)\n        {\n            int a;\n            scanf(""%d"", &a);\n            A[a].push_back((info){i, j, K});\n        }\n    }\n    for(int i=1; i<=M; i++)\n        printf(""%d\\n"", solve(A[i]));\n    return 0;\n}\n']",,,"['chinese remainder theorem', 'data structures', 'implementation', 'number theory', 'two pointers']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Cyclic Cipher.json,https://codeforces.com//blog/entry/47497,Let s solve the problem for a particular number Without loss of generality we assume that appeared in each sequence If not then the whole sequence is divided into contigous subsegments for which above statement is true and the answer for the number is equal to the maximum of the answers for these subsegments Let s denote as the position from to 1 of in the th sequence Then the number occures in the new array at position in the seconds equal to This condition can be rewritten as follows the number occures at position on the th second if Thus to determine whether the number occurs at some point in all positions from to you need to determine whether there is a solution for a system of equations Suppose that we are able to quickly answer to such queries for arbitrary and Then the problem can be solved for example using two pointers We will move the left boundary of the subsegment and for fixed left boundary we will move the right boundary as far as possible until the solution of the corresponding system still exists We can solve a system of equations for any subsegment in time per query using precalculation in the following way To begin with we note that the set of solutions of this system is either empty or it itself can be represented in the same form where We will find the solutions of the systems for the following subsegments for each and for each we will take subsegment For each such subsegment we can find the solution of the corresponding system using time by solving a system consisting of two equations obtained from each of the halves of this subsegment We can solve a system consisting of two equations using the Chinese remainder theorem Now to find a solution for any subsegment it is enough to take two subsegments presented above that their union is equal to the initial subsegment and again solve a system of two equations The resulting complexity of the solution is Since the lengths of the sequences does not exceed 40 the resulting LCM can be upper bounded by 10 16 Since the total length of all sequences is the total complexity of the solution for all the numbers remains the same 
https://codeforces.com//contest/1944/problem/A,2535049,A,1944A,1944,A. Destroying Bridges,There are n islands numbered 1 2 ldots n Initially every pair of islands is connected by a bridge Hence there are a total of frac n n 1 2 bridges Everule lives on island 1 and enjoys visiting the other islands using bridges Dominater has the power to destroy at most k bridges to minimize the number of islands that Everule can reach using possibly multiple bridges Find the minimum number of islands including island 1 that Everule can visit if Dominater destroys bridges optimally ,"['#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl \'\\n\'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nvoid work() {\n\tint n,k; cin>>n>>k;\n\tFor(i,1,n) {\n\t\tif(k>=i*(n-i)) return cout<<i<<endl,void();\n\t}\n}\nint main() {\n#ifdef LOCAL\n\tfreopen("".in"",""r"",stdin);\n\t// freopen("".out"",""w"",stdout);\n\t// freopen("".debug"",""w"",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}']",,,"['graphs', 'greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Destroying Bridges.json,https://codeforces.com//blog/entry/127195,O n SolutionAtleast bridges need to burnt the bridges connecting the reachable islands and the non reachable islands A simple solution is for every from to check if in which case print and break 
https://codeforces.com//contest/1197/problem/E,376706,E,1197E,1197,E. Culture Code,There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby and you d like to buy several of them The store has n different matryoshkas Any matryoshka is a figure of volume out i with an empty space inside of volume in i of course out i in i You don t have much free space inside your bag but fortunately you know that matryoshkas can be nested one inside another Formally let s call a set of matryoshkas if we can rearrange dolls in such a way that the first doll can be nested inside the second one the second doll inside the third one and so on Matryoshka i can be nested inside matryoshka j if out i le in j So only the last doll will take space inside your bag Let s call of a nested set of dolls as a total volume of empty space inside this structure Obviously it s equal to in i 1 in i 2 out i 1 in i 3 out i 2 dots in i k out i k 1 where i 1 i 2 i k are the indices of the chosen dolls in the order they are nested in each other Finally let s call a nested subset of the given sequence as if there isn t any doll from the sequence that can be added to the nested subset without breaking its nested property You want to buy many matryoshkas so you should choose a nested subset to buy it But you will be disappointed if too much space in your bag will be wasted so you want to choose a big enough subset so that its is minimum possible among all big enough subsets Now you wonder how many different nested subsets meet these conditions they are big enough and there is no big enough subset such that its extra space is less than the extra space of the chosen subset Two subsets are considered different if there exists at least one index i such that one of the subsets contains the i th doll and another subset doesn t Since the answer can be large print it modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\n\npii merge(pii x, pii y) {\n\tpii res = min(x, y);\n\tres.second = 0;\n\tif (res.first == x.first) res.second = add(res.second, x.second);\n\tif (res.first == y.first) res.second = add(res.second, y.second);\n\treturn res;\n}\n\nconst int N = 400400;\nint n;\npii dp[N];\nint a[N][2];\n\nstruct Event {\n\tint t, x, id;\n\n\tEvent() : t(), x(), id() {}\n\tEvent(int _t, int _x, int _id) : t(_t), x(_x), id(_id) {}\n\n\tbool operator < (const Event &e) const {\n\t\tif (x != e.x) return x > e.x;\n\t\treturn t < e.t;\n\t}\n};\nEvent ev[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d%d"", &a[i][1], &a[i][0]);\n\t\tev[2 * i] = Event(0, a[i][0], i);\n\t\tev[2 * i + 1] = Event(1, a[i][1], i);\n\t}\n\tsort(ev, ev + 2 * n);\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i] = mp(MOD, 0);\n\tpii cur = mp(MOD, 0);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (ev[i].t == 0) {\n\t\t\tcur = merge(cur, dp[ev[i].id]);\n\t\t} else {\n\t\t\tif (cur.first == MOD) {\n\t\t\t\tdp[ev[i].id] = mp(a[ev[i].id][0], 1);\n\t\t\t} else {\n\t\t\t\tpii w = cur;\n\t\t\t\tw.first -= a[ev[i].id][1] - a[ev[i].id][0];\n\t\t\t\tdp[ev[i].id] = w;\n\t\t\t}\n\t\t}\n\t}\n\tcur = mp(MOD, 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcur = merge(cur, dp[i]);\n\tprintf(""%d\\n"", cur.second);\n\n\treturn 0;\n}\n']",,,"['binary search', 'combinatorics', 'data structures', 'dp', 'shortest paths', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Culture Code.json,https://codeforces.com/blog/entry/68615,Let s at first sort all matryoshkas by increasing its inner volume Then each nested subset will appear as subsequence in its canonical order Now we ll write the DP with the minimum extra space and number of such subsequences among all nested subsets where the th doll is Why minimal not maximal for example It s just easier transitions and easier proof There are two main cases If there isn t such that then we can t put the th doll inside any other So Otherwise we must put the th doll inside other doll otherwise the subset won t be a big enough If we put the th doll inside the th doll then we extra space of such subset is equal to Since we minimize the extra space then Since we sorted all matryoshkas so there is a position such that and The is just a sum from all minimums As you can see we can store in Segment Tree with minimum number of minimums Why in the second transition we will build only subsets It s because not big enough subsets are not optimal in terms of minimality of extra space The result complexity is 
https://codeforces.com//contest/1921/problem/E,2427795,E,1921E,1921,E. Eat the Chip,Alice and Bob are playing a game on a checkered board The board has h rows numbered from top to bottom and w columns numbered from left to right Both players have a chip each Initially Alice s chip is located at the cell with coordinates x a y a row x a column y a and Bob s chip is located at x b y b It is guaranteed that the initial positions of the chips do not coincide Players take turns making moves with Alice starting On her turn Alice can move her chip one cell down or one cell down right or down left diagonally Bob on the other hand moves his chip one cell up up right or up left It is not allowed to make moves that go beyond the board boundaries More formally if at the beginning of Alice s turn she is in the cell with coordinates x a y a then she can move her chip to one of the cells x a 1 y a x a 1 y a 1 or x a 1 y a 1 Bob on his turn from the cell x b y b can move to x b 1 y b x b 1 y b 1 or x b 1 y b 1 The new chip coordinates x y must satisfy the conditions 1 le x le h and 1 le y le w Example game state Alice plays with the white chip Bob with the black one Arrows indicate possible moves A player immediately wins if they place their chip in a cell occupied by the other player s chip If either player cannot make a move Alice if she is in the last row i e x a h Bob if he is in the first row i e x b 1 the game immediately ends in a draw What will be the outcome of the game if both opponents play optimally ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll h,w,x1,y1,x2,y2;\n    cin>>h>>w>>x1>>y1>>x2>>y2;\n    if(abs(y1-y2)>x2-x1) cout<<""Draw"";\n    else if((x2-x1)%2==1){\n        ll s=(x2-x1)/2;\n        if(max(1ll,y2-s)<max(1ll,y1-s-1) || min(w,y2+s)>min(w,y1+s+1)) cout<<""Draw"";\n        else cout<<""Alice"";\n    }else{\n        ll s=(x2-x1)/2;\n        if(max(1ll,y1-s)<max(1ll,y2-s) || min(w,y1+s)>min(w,y2+s)) cout<<""Draw"";\n        else cout<<""Bob"";\n    }\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']",,,"['brute force', 'games', 'greedy', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Eat the Chip.json,https://codeforces.com//blog/entry/124757,First let s note that the difference decreases exactly by one each both Alice s and Bob s turn In the end if one of the players was able to win In particular that means that if is initially odd then only Alice has a chance of winning the match and vice versa Suppose that is initially even the outcome of the match could be either Bob s win or draw If the answer is immediately draw Otherwise the players will make moves each before If at some point during these moves Bob can achieve he is winning as he can continue with symmetrical responses to Alice s turns If and Bob cannot reach right border Alice can always choose the rightmost option for her and after each of moves will be greater than which means Bob cannot win Otherwise if Bob always chooses the rightmost option for him he will eventually achieve The case when is initially less than as well as the case when Alice has a chance to win is odd can be covered in a similar way 
https://codeforces.com//contest/1156/problem/D,338451,D,1156D,1156,D. 0-1-Tree,You are given a tree an undirected connected acyclic graph consisting of n vertices and n 1 edges A number is written on each edge each number is either 0 let s call such edges 0 edges or 1 those are 1 edges Let s call an ordered pair of vertices x y x ne y if while traversing the simple path from x to y we never go through a 0 edge after going through a 1 edge Your task is to calculate the number of pairs in the tree ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nvector<int> g0[N], g1[N];\nbool used[N];\nint cnt0[N], cnt1[N];\n\nvector<int> comp;\n\nvoid dfs0(int u) {\n    used[u] = true;\n    comp.push_back(u);\n    for (int v : g0[u]) {\n        if (!used[v]) {\n            dfs0(v);\n        }\n    }\n}\n\nvoid dfs1(int u) {\n    used[u] = true;\n    comp.push_back(u);\n    for (int v : g1[u]) {\n        if (!used[v]) {\n            dfs1(v);\n        }\n    }\n}\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    rep(i, 0, n - 1) {\n        int u, v, w;\n        cin >> u >> v >> w; u--; v--;\n        if (w == 0) {\n            g0[u].push_back(v);\n            g0[v].push_back(u);\n        } else {\n            g1[u].push_back(v);\n            g1[v].push_back(u);\n        }\n    }\n    ll ans = 0;\n    fill(used, used + n, false);\n    rep(i, 0, n) {\n        if (!used[i]) {\n            comp.clear();\n            dfs0(i);\n            ans += 1LL * sz(comp) * (sz(comp) - 1);\n            for (int x : comp) {\n                cnt0[x] = sz(comp);\n            }\n        }\n    }\n    fill(used, used + n, false);\n    rep(i, 0, n) {\n        if (!used[i]) {\n            comp.clear();\n            dfs1(i);\n            ans += 1LL * sz(comp) * (sz(comp) - 1);\n            for (int x : comp) {\n                cnt1[x] = sz(comp);\n            }\n        }\n    }\n    rep(i, 0, n) {\n        ans += 1LL * (cnt0[i] - 1) * (cnt1[i] - 1);\n    }\n    cout << ans << ""\\n"";\n    return 0;\n}']",,,"['dfs and similar', 'divide and conquer', 'dp', 'dsu', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. 0-1-Tree.json,https://codeforces.com/blog/entry/66827,Let s divide all valid pairs into three categories the ones containing only edges on the path the ones containing only edges and the ones containing both types of edges To calculate the number of pairs containing only edges we may build a forest on the vertices of the original graph and edges and choose all pairs of vertices belonging to the same connected components of this forest we can find all connected components with DSU or any graph traversal algorithm The same can be done for the pairs containing only edges If a path from to is valid and contains both types of edges then there exists a vertex such that the simple path from to goes only through edges and the simple path from to goes only through edges So let s iterate on this vertex and choose some other vertex from its component in graph as and some other vertex from its component in graph as and add the number of ways to choose them to the answer 
https://codeforces.com//contest/792/problem/A,100424,A,792A,792,A. New Bus Route,There are cities situated along the main road of Berland Cities are represented by their coordinates integer numbers All coordinates are pairwise distinct It is possible to get from one city to another only by bus But all buses and roads are very old so the Minister of Transport decided to build a new bus route The Minister doesn t want to spend large amounts of money he wants to choose two cities in such a way that the distance between them is minimal possible The distance between two cities is equal to the absolute value of the difference between their coordinates It is possible that there are multiple pairs of cities with minimal possible distance so the Minister wants to know the quantity of such pairs Your task is to write a program that will calculate the minimal possible distance between two pairs of cities and the quantity of pairs which have this distance ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << "" "";\n    }\n    cerr << ""\\n"";\n}\n\nint n;\nint a[220000];\n\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%d"", a + i);\n\tsort(a, a + n);\n\tll bst = a[n - 1] - a[0];\n\tll cnt = 0;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tll l = a[i + 1] - a[i];\n\t\tif (bst > l)\n\t\t\tbst = l, cnt = 0;\n\t\tif (bst == l)\n\t\t\t++cnt;\n\t}\n\tcout << bst << "" "" << cnt << ""\\n"";\n\treturn 0;\n}\n\n\n']",,,"['implementation', 'sortings']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. New Bus Route.json,https://codeforces.com//blog/entry/51254,At first let s notice that if there exists such triple and that then and Thus we can sort all numbers and check only adjacent ones There are exactly of such pairs The only thing left is to find minimal distance of all pairs and count pairs with that distance Overall complexity 
https://codeforces.com//contest/1900/problem/D,2348161,D,1900D,1900,D. Small GCD,Let a b and c be integers We define function f a b c as follows Order the numbers a b c in such a way that a le b le c Then return gcd a b where gcd a b denotes the greatest common divisor GCD of integers a and b So basically we take the gcd of the 2 smaller values and ignore the biggest one You are given an array a of n elements Compute the sum of f a i a j a k for each i j k such that 1 le i j k le n More formally compute sum i 1 n sum j i 1 n sum k j 1 n f a i a j a k ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint n, a[80005], f[100005], g[100005];\nlong long ans;\nstd::vector <int> fac[100005];\nvoid solve(){\n\tscanf(""%d"", &n); ans = 0ll;\n\tfor(int i = 1; i <= 100000; ++i) f[i] = g[i] = 0;\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tstd::sort(a + 1, a + n + 1);\n\tlong long tmp = 0ll;\n\tfor(int i = 1; i <= n; ++i){\n\t\tans += tmp;\n\t\tfor(auto v : fac[a[i]]){\n\t\t\tf[v] = g[v];\n\t\t\tfor(auto u : fac[a[i] / v]) if(u != 1) f[v] -= f[v * u];\n\t\t\ttmp += 1ll * v * f[v];\n\t\t}\n\t\tfor(auto v : fac[a[i]]) ++g[v];\n\t}\n\tprintf(""%lld\\n"", ans);\n\treturn ;\n}\nint main(){\n\tfor(int i = 1; i <= 100000; ++i) for(int j = i; j <= 100000; j += i) fac[j].push_back(i);\n\tfor(int i = 1; i <= 100000; ++i) std::reverse(fac[i].begin(), fac[i].end()); \n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']",,,"['bitmasks', 'brute force', 'dp', 'math', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Small GCD.json,https://codeforces.com//blog/entry/122677,Solution part 1We calculate from to For some we can first calculate the number of triples that have a value of function that is an integer multiple of and then from it subtract Because of the previous hint the subtractions will be quite fast Now the question is how to calculate the number of triples that have a value of function that is an integer multiple of 
https://codeforces.com//contest/1969/problem/F,2619522,F,1969F,1969,F. Card Pairing,There is a deck of n cards each card has one of k types You are given the sequence a 1 a 2 dots a n denoting the types of cards in the deck from top to bottom Both n and k are even numbers You play a game with these cards First you draw k topmost cards from the deck Then the following happens each turn of the game you choose two cards from your hand and play them If these cards have the same type you earn a coin then if the deck is not empty you draw two top cards from it then if both your hand and your deck are empty the game ends Otherwise the new turn begins You have to calculate the maximum number of coins you can earn during the game ,"['#include ""bits/stdc++.h""#pragma GCC optimize (""O3"")#pragma GCC target (""sse4"") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\xa0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\xa0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}void __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}void __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}void __print(bool x) {cerr << (x ? ""true"" : ""false"");}\xa0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}template<typename T>void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}void _print() {cerr << ""]\\n"";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;#else#define dbg(x...)#endif\xa0\xa0const int MOD = 1000000007;const char nl = \'\\n\';const int MX = 100001; \xa0set<int> cur;\xa0void flip(int X) {    if (cur.count(X)) {        cur.erase(X);    } else cur.ins(X);}\xa0void solve() {    int N, K; cin >> N >> K;    vi A(N); F0R(i, N) cin >> A[i];    F0R(i, N) A[i]--;    F0R(i, K) flip(A[i]);    int dp[(N-K)/2 + 1];    F0R(i, (N-K)/2 + 1) dp[i] = MX;    F0R(i, (N-K)/2) {        if (sz(cur) == K) {            dp[i] = 0;            goto done;        }        flip(A[K+i*2]); flip(A[K+i*2+1]);    }    dp[(N-K)/2] = 0;    done:    ;\xa0    F0R(i, (N-K)/2) {        bool ev[K]; F0R(j, K) ev[j] = false;        FOR(j, K+i*2, N) {            ev[A[j]] = !ev[A[j]];        }        cur.clear();        int cOdd = K, cEv = 0;        F0R(i, K) if (ev[i]) {            cEv++; cOdd--;        }        int c0 = (cOdd * (cOdd - 1)) / 2;        int c1 = cOdd * cEv;        int c2 = (cEv * (cEv - 1)) / 2;        set<pi> used;        FOR(j, i+1, (N-K)/2) {            flip(A[K+j*2-2]); flip(A[K+j*2-1]);            if (sz(cur) == 2) {                pi cp = {*cur.begin(), *cur.rbegin()};                if (used.count(cp)) continue;                if (!ev[cp.f] && !ev[cp.s]) {                    c0--;                } else if (ev[cp.f] && ev[cp.s]) {                    c2--;                } else c1--;                used.ins(cp);                int cv = dp[i];                if (ev[*cur.begin()]) cv++;                if (ev[*cur.rbegin()]) cv++;                ckmin(dp[j], cv);            }        }        if (c0) {            ckmin(dp[(N-K)/2], dp[i]);        } else if (c1) {            ckmin(dp[(N-K)/2], dp[i] + 1);        } else if (c2) {            ckmin(dp[(N-K)/2], dp[i] + 2);        }    }\xa0    cur.clear();    F0R(i, N) flip(A[i]);    cout << (N-sz(cur))/2 - dp[(N-K)/2] << nl;\xa0\xa0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\xa0    int T = 1;//    cin >> T;    while(T--) {        solve();    }\xa0\treturn 0;}\xa0\xa0']",,,"['dp', 'greedy', 'hashing', 'implementation']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Card Pairing.json,https://codeforces.com//blog/entry/129022,It s pretty obvious that every time we have a pair of equal cards in hand we should play one of these pairs If you re interested in a formal proof please read the paragraph in italic otherwise skip it Whenever we have a pair of equal cards we will always play it at some moment and earn a coin and it does not matter in which order we play different pairs So we have to make a meaningful choice about which cards we play only when all cards in our hand are different In the ideal situation if there are cards of type we want to earn coins by playing these cards But whenever we play only one card of type and there is an odd number of cards of type left both in hand and in deck we lose a coin because the number of pairs we can make decreases by Let s calculate the answer as the maximum possible number of pairs we can form equal to minus the minimum number of coins we lose in such a way Since we play a pair when we have at least one pair we can lose coins only when all cards in our hand are different So let s try to use a dynamic programming of the form is the minimum number of coins we could lose when we have drawn first cards from the deck and all cards in our hand are different Let s analyze the transitions of this dynamic programming When transitioning out of we can iterate on the pair of cards we play since we consider the situation when all cards in our hand are different we can play any pair of different cards for each of these two cards check if we lose a coin by playing them and try to find the next moment when all cards in our hand will be different or update the answer if there is no such moment However when implemented naively it is too slow might take up to We can use the following optimizations to improve it this is one of my favorite techniques Let s assign each card type a random bit number let it be for type Then let be the XOR of the numbers assigned to the first cards in the deck Suppose we are considering transitions from we try to play cards of type and when will be the next moment when we have all types of cards If this moment is then we need to take an odd number of cards of type and from moment to moment and an even number of cards for all other types So we can see that and this allows us to locate the next moment when we have different cards more easily in or even we have up to pairs of cards we can play from each state but only different states we can go into and no two transitions lead to the same state Let s try to make only transitions from each state When considering a state we can split all cards into two types the ones that make us lose a coin when we play them group and all the others group First let s try to play two cards from the group if we find a combination of them such that after playing it we never have different cards in our hand because this transition updates the answer directly without any increases Otherwise perform all transitions with pairs of cards from group and try to play a pair of cards from different groups If we find a combination that updates the answer directly we again can stop considering transitions the next transitions we use won t be more optimal And then we do the same with transitions where we use a pair of cards of group This way we will consider at most transitions from each state Combining these two optimizations results in a solution in or but there are other optimizations you can try 
https://codeforces.com//contest/1512/problem/F,953479,F,1512F,1512,F. Education,Polycarp is wondering about buying a new computer which costs c tugriks To do this he wants to get a job as a programmer in a big company There are n positions in Polycarp s company numbered starting from one An employee in position i earns a i tugriks every day The higher the position number the more tugriks the employee receives Initially Polycarp gets a position with the number 1 and has 0 tugriks Each day Polycarp can do one of two things If Polycarp is in the position of x then he can earn a x tugriks If Polycarp is in the position of x x n and has at least b x tugriks then he can spend b x tugriks on an online course and move to the position x 1 For example if n 4 c 15 a 1 3 10 11 b 1 2 7 then Polycarp can act like this On the first day Polycarp is in the 1 st position and earns 1 tugrik Now he has 1 tugrik On the second day Polycarp is in the 1 st position and move to the 2 nd position Now he has 0 tugriks On the third day Polycarp is in the 2 nd position and earns 3 tugriks Now he has 3 tugriks On the fourth day Polycarp is in the 2 nd position and is transferred to the 3 rd position Now he has 1 tugriks On the fifth day Polycarp is in the 3 rd position and earns 10 tugriks Now he has 11 tugriks On the sixth day Polycarp is in the 3 rd position and earns 10 tugriks Now he has 21 tugriks Six days later Polycarp can buy himself a new computer Find the minimum number of days after which Polycarp will be able to buy himself a new computer ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=200010;\nconst int mod=1000000007;\nusing namespace std;\n\nll a[def],b[def];\n\nint main()\n{\tint _=1,__=1,n;\n\tll c;\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""/Users/py/Documents/workspace/C++/try.in"",""r"",stdin);\n\tfreopen(""/Users/py/Documents/workspace/C++/try.out"",""w"",stdout);\n\t#endif\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d%lld"",&n,&c);\n\t\tfor(int i=1;i<=n;i++)scanf(""%lld"",&a[i]);\n\t\tfor(int i=1;i<n;i++)scanf(""%lld"",&b[i]);\n\t\tll sum=0,ans=inf,maxx=0,now=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tMax(maxx,a[i]);\n\t\t\tif(c<=sum)\n\t\t\t\tMin(ans,now);\n\t\t\telse\n\t\t\t\tMin(ans,(c-sum+maxx-1)/maxx+now);\n\t\t\tif(sum<b[i]){\n\t\t\t\tint d=(b[i]-sum+maxx-1)/maxx;\n\t\t\t\tnow+=d;\n\t\t\t\tsum+=d*maxx;\n\t\t\t}\n\t\t\tsum-=b[i];\n\t\t\tnow++;\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}']",,,"['brute force', 'dp', 'greedy', 'implementation']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Education.json,https://codeforces.com//blog/entry/89535,Since the array does not decrease if we want to get the position at some point it is best to get it as early as possible because if we get it earlier we will earn no less money Therefore the solution looks like this rise to some position and earn money on it for a laptop Let s go through the number of the position and use simple formulas to calculate the number of days it takes to raise to this position and the number of days it takes to buy a laptop From all the options choose the minimum one 
https://codeforces.com//contest/1924/problem/A,2447857,A,1924A,1924,A. Did We Get Everything Covered ,You are given two integers n and k along with a string s Your task is to check whether all possible strings of length n that can be formed using the first k lowercase English alphabets occur as a subsequence of s If the answer is you also need to print a string of length n that can be formed using the first k lowercase English alphabets which does not occur as a subsequence of s If there are multiple answers you may print any of them A string a is called a subsequence of another string b if a can be obtained by deleting some possibly zero characters from b without changing the order of the remaining characters ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k, m;\n    std::cin >> n >> k >> m;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::string t;\n    int j = 0;\n    bool ok = true;\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        std::vector<int> occ(k);\n        while (cnt < k && j < m) {\n            cnt += !occ[s[j] - \'a\'];\n            occ[s[j] - \'a\'] = 1;\n            j += 1;\n        }\n        if (cnt < k) {\n            ok = false;\n            for (int x = 0; x < k; x++) {\n                if (!occ[x]) {\n                    t += \'a\' + x;\n                    break;\n                }\n            }\n        } else {\n            t += s[j - 1];\n        }\n    }\n    \n    if (ok) {\n        std::cout << ""YES\\n"";\n    } else {\n        std::cout << ""NO\\n"";\n        std::cout << t << ""\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['constructive algorithms', 'dp', 'greedy', 'shortest paths', 'strings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Did We Get Everything Covered .json,https://codeforces.com//blog/entry/125137,We will try to construct a counter case If we can t the answer is YES otherwise NO We will greedily construct the counter case It is always optimal to choose the first character of our counter case as the character among the first English alphabets whose first index of occurrence in is the highest Add this character to our counter case remove the prefix up to this character from and repeat until the length of the counter case reaches or we reach the end of If the length of the counter case is less than find a character which does not appear in the last remaining suffix of Keep adding this character to the counter case until its length becomes This is a valid string which does not occur as a subsequence of Otherwise all possible strings of length formed using the first English alphabets occur as a subsequence of 
https://codeforces.com//contest/1487/problem/F,897752,F,1487F,1487,F. Ones,You are given a positive greater than zero integer n You have to represent n as the sum of integers possibly negative consisting only of ones digits For example 24 11 11 1 1 and 102 111 11 1 1 Among all possible representations you have to find the one that uses the minimum number of ones in total ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    string S; cin >> S;\n    S = ""0"" + S;\n    int N = sz(S);\n    int dp[N][101][2001];\n    F0R(i, N) {\n        F0R(j, 101) F0R(k, 2001) dp[i][j][k] = 1000000;\n    }\n    dp[0][50][1000] = 0;\n    F0R(i, N-1) {\n        F0R(j, 100) {\n            F0R(k, 2000) {\n                ckmin(dp[i][j+1][k+1], dp[i][j][k] + N-i);\n            }\n        }\n        FORd(j, 1, 101) {\n            FORd(k, 1, 2001) {\n                ckmin(dp[i][j-1][k-1], dp[i][j][k]+N-i);\n            }\n        }\n        F0R(j, 101) {\n            F0R(k, 2001) {\n                int nxt = 50 + (j-50)*10 - (S[i+1]-\'0\') + (k-1000);\n                if (nxt < 101 && nxt >= 0) {\n                    ckmin(dp[i+1][nxt][k], dp[i][j][k]);\n                    /*if (i+1 == N-1 && nxt == 56 && k == 1003) {\n                        cout << ""TEST "" << j << "" "" << k << endl;\n                    }*/\n                }\n            }\n        }\n    }\n    int ans = 1000000;\n    F0R(i, 101) F0R(j, 2001) {\n        ckmin(ans, dp[N-1][i][j] + abs(i-50));\n        /*if (dp[N-1][i][j] + abs(i-50) == 20) {\n            cout << i-50 << "" "" << j-1000 << nl;\n        }*/\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['dp', 'greedy', 'shortest paths']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Ones.json,https://codeforces.com//blog/entry/87873,Let s build the number from the lowest digit to the highest digit with the following dynamic programming the minimum number of ones if least significant digits are already fixed the carry to the next digit is can be negative there are positive numbers of the form of length greater than or equal to and negative numbers of length greater than or equal to First consider the transitions when we reduce the values of and or Such transitions correspond to the fact that in the optimal answer there were several numbers of length exactly and they should not be considered further If the value of matches the th least significant digit in then we can use transition to th state with the new value of and the number of ones in the answer increased by It remains to estimate what the maximum value of and we need The value of doesn t exceed the total number of numbers that we use in the answer Using at most numbers we can decrease the length of by at least Thus the maximum value of and is at most where n is the length of the number For the value of the condition should be met similarly for a negative value Thus we can assume that the absolute value of doesn t exceed The total complexity of this solution is yet with a high constant factor 
https://codeforces.com//contest/1374/problem/C,659586,C,1374C,1374,C. Move Brackets,You are given a bracket sequence s of length n where n is even divisible by two The string s consists of frac n 2 opening brackets and frac n 2 closing brackets In one move you can choose and move it to the beginning of the string or to the end of the string i e you choose some index i remove the i th character of s and insert it before or after all remaining characters of s Your task is to find the minimum number of moves required to obtain from s It can be proved that the answer always exists under the given constraints Recall what the regular bracket sequence is is regular bracket sequence if s is regular bracket sequence then s is regular bracket sequence if s and t are regular bracket sequences then s t is regular bracket sequence For example and are regular bracket sequences but and are not You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << "" is "" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7;\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tstring s;\n\t\tint n;\n\t\tcin >> n >> s;\n\t\tint cnt = 0;\n\t\twhile(true) {\n\t\t\tint bal = 0;\n\t\t\tbool yes = 1;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c == \'(\') bal++;\n\t\t\t\telse bal--;\n\t\t\t\tif(bal < 0) yes = 0;\n\t\t\t}\n\t\t\tif(yes) break;\n\t\t\tstring t;\n\t\t\tbool f = 0;\n\t\t\tfor(int i = s.size() - 1; i >= 0; i--) {\n\t\t\t\tif(s[i] == \'(\') {\n\t\t\t\t\tif(f == 0) f = 1;\n\t\t\t\t\telse t.PB(s[i]);\n\t\t\t\t} else {\n\t\t\t\t\tt.PB(s[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.PB(\'(\');\n\t\t\treverse(ALL(t));\n\t\t\ts = t;\n\t\t\tcnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n}\n\n\n\n']",,,"['greedy', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Move Brackets.json,https://codeforces.com//blog/entry/79517,Let s go from left to right over characters of maintaining the current bracket balance for the position the balance is the number of opening brackets on the prefix till the th character minus the number of closing brackets on the same prefix If the current balance becomes less than zero then let s just take some opening bracket after the current position it obviously exists because the number of opening equals the number of closing brackets and move it to the beginning so the negative balance becomes zero again and the answer increases by one Or we can move the current closing bracket to the end of the string because it leads to the same result Time complexity 
https://codeforces.com//contest/258/problem/A,2442,A,258A,258,A. Little Elephant and Bits,The Little Elephant has an integer written in the binary notation He wants to write this number on a piece of paper To make sure that the number fits on the piece of paper the Little Elephant to delete exactly one any digit from number in the binary record At that a new number appears It consists of the remaining binary digits written in the corresponding order possible with leading zeroes The Little Elephant wants the number he is going to write on the paper to be as large as possible Help him find the maximum number that he can obtain after deleting exactly one binary digit and print it in the binary notation ,"['#include <cstdio>\n#include <cstring>\n\nconst int N = 100000;\n\nchar s[N + 1];\n\nint main() {\n    scanf(""%s"", s);\n    int n = strlen(s);\n    for (int i = 0; i < n; ++ i) {\n        if (s[i] == \'0\') {\n            for (int j = 0; j < n; ++ j) {\n                if (i != j) {\n                    putchar(s[j]);\n                }\n            }\n            puts("""");\n            return 0;\n        }\n    }\n    printf(""%s\\n"", s + 1);\n    return 0;\n}\n']",,,"['greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Little Elephant and Bits.json,https://codeforces.com//blog/entry/6213,It s pretty easy to notice that you need to delete the first from the left 0 digit The only catchy case is 111 111 here you need to delete any of 1 digits 
https://codeforces.com//contest/731/problem/F,75977,F,731F,731,F. Video Cards,Little Vlad is fond of popular computer game Bota 2 Recently the developers announced the new add on named Bota 3 Of course Vlad immediately bought only to find out his computer is too old for the new game and needs to be updated There are video cards in the shop the power of the th video card is equal to integer value As Vlad wants to be sure the new game will work he wants to buy not one but several video cards and unite their powers using the cutting edge technology To use this technology one of the cards is chosen as the leading one and other video cards are attached to it as secondary For this new technology to work it s required that the power of each of the secondary video cards is divisible by the power of the leading video card In order to achieve that the power of any secondary video card can be reduced to any integer value less or equal than the current power However the power of the leading video card should remain unchanged i e it be reduced Vlad has an infinite amount of money so he can buy any set of video cards Help him determine which video cards he should buy such that after picking the leading video card and may be reducing some powers of others to make them work together he will get the maximum total value of video power ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)2e5+5;\nll n,a[N],ans;\n\nint bs(int l,int r,int val)\n{\n\tif(l==r) return l;\n\tif(r==l+1)\n\t\tif(a[l]>=val)return l; else return r;\n\tint m=(r+l)/2;\n\tif(a[m]>=val) return bs(l,m,val);else return bs(m,r,val);\n}\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t\tcin >> a[i];\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll curans=0;\n\t\tif(i!=0&&a[i]==a[i-1])continue;\n\t\tfor(int val=a[i];val<=300000;val+=a[i])\n\t\t{\n\t\t\tif(a[n-1]<val)break;\n\t\t\tcurans+=(n-bs(0,n-1,val))*a[i];\n\t\t}\n\t\tans=max(ans,curans);\n\t}\n\tcout << ans;\n\treturn 0;\n}\n']",,,"['brute force', 'data structures', 'implementation', 'math', 'number theory']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Video Cards.json,https://codeforces.com//blog/entry/47840,Problem author olympiad jury developer vintage Vlad Makeev First observation is that if we fix the leading video card power we may take all the video cards of power at least as each of them brings the positive power value So we may sort all the cards in the ascending power order and then we will always choose some suffix of cards in such an order The final total power equals to Note that under the summation there is a number that is divisible by and that is no larger than at the same time It means that there are no more than different terms in this sum Let s calculate the value of a sum spending the operations proportional to the number of different terms in it To do it we need to find out for each of the values how many video cards will have exactly such power at the end It s easy final power corresponds to those video cards which originally had the power between and Their number can be found out in if we build an array storing the number of video cards of each power and calculate prefix sums on it It means that we got a solution that performs about operations It s useful to know that the sum inside brackets is called a harmonic series and that its sum is very close to the natural logarithm of the number of terms up to a constant factor in limit It means that we got a solution in complexity of where is the maximum power of a single video card Question One may try to submit a solution assuming that the optimum power is always one of the first let s say unique video cards in an ascending power order How to build a test where the optimum power lies between 1 4 and 3 4 of a sorted power list i e a counter test for such a solution 
https://codeforces.com//contest/1388/problem/C,686568,C,1388C,1388,C. Uncle Bogdan and Country Happiness,There are n cities and n 1 undirected roads connecting pairs of cities Citizens of any city can reach any other city traveling by these roads Cities are numbered from 1 to n and the city 1 is a capital In other words the country has a tree structure There are m citizens living in the country A p i people live in the i th city but all of them are working in the capital At evening all citizens return to their home cities using the shortest paths Every person has its own mood somebody leaves his workplace in good mood but somebody are already in bad mood Moreover any person can ruin his mood on the way to the hometown Happiness detectors are installed in each city to monitor the happiness of person who visits the city The detector in the i th city calculates a happiness index h i as the number of people in good mood minus the number of people in bad mood Let s say for the simplicity that Happiness detector is still in development so there is a probability of a mistake in judging a person s happiness One late evening when all citizens successfully returned home the government asked uncle Bogdan the best programmer of the country to check the correctness of the collected happiness indexes Uncle Bogdan successfully solved the problem Can you do the same More formally ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 200000\n\nlong long h[N];\nlong long a[N];\nvector<long long>e[N];\nbool used[N];\nbool v;\n\nlong long dfs(long long k) {\n\tused[k] = true;\n\tlong long re = 0;\n\tlong long s = 0;\n\tlong long sz = e[k].size();\n\tf(i, sz) {\n\t\tif (!used[e[k][i]]) {\n\t\t\tre += dfs(e[k][i]);\n\t\t\ts += h[e[k][i]];\n\t\t}\n\t}\n\tre += a[k];\n    s-=a[k];\n\tif (s > h[k])v = false;\n\telse if (re < h[k])v = false;\n\telse if ((re - h[k]) % 2 != 0)v = false;\n\treturn re;\n}\n\n\nint main() {\n\n\tf(i, N) {\n\t\ta[i] = 0;\n\t\th[i] = 0;\n\t}\n\tlong long n, m,k, t;\n\tlong long x, y, z;\n\tlong long s, ans;\n\tans = 0;\n\tscanf(""%lld"", &t);\n\tf(tt, t) {\n\t\tscanf(""%lld %lld"", &n, &m);\n\t\tf(i, n) {\n\t\t\tscanf(""%lld"", &a[i]);\n\t\t}\n\t\tf(i, n) {\n\t\t\tscanf(""%lld"", &h[i]);\n\t\t}\n\t\tf(i, n-1) {\n\t\t\tscanf(""%lld %lld"", &x, &y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tv = true;\n\t\tf(i, n)used[i] = false;\n\t\tdfs(0);\n\t\tif (v)printf(""YES\\n"");\n\t\telse printf(""NO\\n"");\n\t\tf(i, n)e[i].clear();\n\t}\n\n\treturn 0;\n}']",,,"['dfs and similar', 'greedy', 'math', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Uncle Bogdan and Country Happiness.json,https://codeforces.com//blog/entry/80828,For each city count how many people will visit it Knowing this value and the value of the level of happiness we can calculate how many people visited the city in a good mood We can single out the criterions for the correctness of the values of the happiness indices is a multiple of For each an integer In each city the number of residents who passed this city in a good mood a non negative number not exceeding where are the cities where the resident can move out of the city on the way home This follows from the fact that the mood of the inhabitants can be deteriorated and cannot be improved This is enough since these conditions guarantee the correctness of the happiness indices by definition as well as the peculiarities of changes in the mood of residents 
https://codeforces.com//contest/1182/problem/E,356990,E,1182E,1182,E. Product Oriented Recurrence,Let f x c 2x 6 cdot f x 1 cdot f x 2 cdot f x 3 for x ge 4 You have given integers n f 1 f 2 f 3 and c Find f n bmod 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nconst int Ha=1000000007;\nconst int phi=1000000006;\nstruct matrix\n{\n\tint a[5][5];\n\tmatrix(){memset(a,0,sizeof(a));}\n}t;\ninline matrix operator*(const matrix&a,const matrix&b)\n{\n\tmatrix c;\n\tfor(int i=0;i<5;++i)\n\t\tfor(int j=0;j<5;++j)\n\t\t\tfor(int k=0;k<5;++k)\n\t\t\t\tc.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j])%phi;\n\treturn c;\n}\ninline matrix fp(matrix b,long long e)\n{\n\tmatrix r;\n\tfor(int i=0;i<5;++i)r.a[i][i]=1;\n\tfor(;e;e>>=1,b=b*b)if(e&1)r=r*b;\n\treturn r;\n}\nmap<int,int>mp;\nint B=1;\nint fp(int b,int e)\n{\n\tint r=1;\n\tfor(;e;e>>=1,b=1ll*b*b%Ha)if(e&1)r=1ll*r*b%Ha;\n\treturn r;\n}\nint dlog(int x)\n{\n\tint now=1;\n\tint res;\n\tfor(int i=0;;++i)\n\t{\n\t\tint y=1ll*x*now%Ha;\n\t\tif(mp.count(y))\n\t\t{\n\t\t\tres=mp[y]-i*33333;\n\t\t\tbreak;\n\t\t}\n\t\tnow=1ll*now*B%Ha;\n\t}\n\tres=(res+phi)%phi;\n\tres=(res+phi)%phi;\n\tres=(res+phi)%phi;\n\tassert(fp(5,res)==x);\n\treturn res;\n}\nint z[5];\nint main()\n{\n\tfor(int i=0;i<33333;++i)\n\t{\n\t\tmp[B]=i;\n\t\tB=5ll*B%Ha;\n\t}\n\tlong long n;\n\tint f1,f2,f3,c;\n\tscanf(""%lld%d%d%d%d"",&n,&f1,&f2,&f3,&c);\n\tc=dlog(c);\n\tf1=dlog(f1);\n\tf2=dlog(f2);\n\tf3=dlog(f3);\n\tt.a[0][1]=1;\n\tt.a[1][2]=1;\n\tt.a[1][0]=1;\n\tt.a[0][0]=1;\n\tt.a[1][0]=1;\n\tt.a[2][0]=1;\n\tt.a[3][3]=1;\n\tt.a[3][0]=(phi-6ll*c%phi)%phi;\n\tt.a[4][0]=2ll*c%phi;\n\tt.a[3][4]=1;\n\tt.a[4][4]=1;\n\tz[0]=f3;\n\tz[1]=f2;\n\tz[2]=f1;\n\tz[3]=1;\n\tz[4]=4;\n\tt=fp(t,n-3);\n\tint res=0;\n\tfor(int i=0;i<5;++i)res=(res+1ll*z[i]*t.a[i][0])%phi;\n\tprintf(""%d\\n"",fp(5,res));\n\treturn 0;\n}']",,,"['dp', 'math', 'matrices', 'number theory']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Product Oriented Recurrence.json,https://codeforces.com//blog/entry/67614,You can form the expression into this Let s occurrence for prime number For example so s occurrence is Then we can set the formula and calculate using matrix exponentiation Since all different prime numbers share same matrix we can calculate matrix only once And we have less or equal than 36 distinct prime numbers targeted because you cannot get more than distinct prime numbers by prime decomposition from numbers in range With we can calculate and we can calculate using modulo inverse Time complexity is 
https://codeforces.com//contest/1929/problem/F,2478908,F,1929F,1929,F. Sasha and the Wedding Binary Search Tree,Having overcome all the difficulties and hardships Sasha finally decided to marry his girlfriend To do this he needs to give her an engagement ring However his girlfriend does not like such romantic gestures but she does like binary search trees dagger So Sasha decided to give her such a tree After spending a lot of time on wedding websites for programmers he found the perfect binary search tree with the root at vertex 1 In this tree the value at vertex v is equal to val v But after some time he forgot the values in some vertices Trying to remember the found tree Sasha wondered how many binary search trees could he have found on the website if it is known that the values in all vertices are integers in the segment 1 C Since this number can be very large output it modulo 998 244 353 dagger A binary search tree is a rooted binary tree in which for any vertex x the following property holds the values of all vertices in the left subtree of vertex x if it exists are less than or equal to the value at vertex x and the values of all vertices in the right subtree of vertex x if it exists are greater than or equal to the value at vertex x ,"['#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint tl[500005],tr[500005],val[500005];\nint zh[500005],cnt;\nint ny[500005];\nvoid dfs(int x)\n{\n\tif(x==-1)return;\n\tdfs(tl[x]);\n\tzh[++cnt]=val[x];\n\tdfs(tr[x]);\n}\nint main()\n{\n\tny[1]=1;\n\tfor(int i=2;i<=500000;i++)ny[i]=1LL*(mod-mod/i)*ny[mod%i]%mod;\n\tint t,n,c;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tc=read();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ttl[i]=read();\n\t\t\ttr[i]=read();\n\t\t\tval[i]=read();\n\t\t}\n\t\tcnt=0;\n\t\tdfs(1);\n\t\t//for(int i=1;i<=cnt;i++)printf(""%d "",zh[i]);\n\t\t//printf(""\\n"");\n\t\tint pre=1,xb=0,ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(zh[i]!=-1)\n\t\t\t{\n\t\t\t\tint sx=zh[i]-pre+i-xb-1;\n\t\t\t\tfor(int j=1;j<=i-xb-1;j++)\n\t\t\t\t{\n\t\t\t\t\tans=1LL*ans*(sx+mod-j+1)%mod*ny[j]%mod;\n\t\t\t\t}\n\t\t\t\tpre=zh[i];\n\t\t\t\txb=i;\n\t\t\t}\n\t\t}\n\t\tif(xb!=n)\n\t\t{\n\t\t\tint sx=c-pre+n-xb;\n\t\t\tfor(int j=1;j<=n-xb;j++)\n\t\t\t{\n\t\t\t\tans=1LL*ans*(sx+mod-j+1)%mod*ny[j]%mod;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n}\n']",,,"['brute force', 'combinatorics', 'data structures', 'dfs and similar', 'math', 'trees']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Sasha and the Wedding Binary Search Tree.json,https://codeforces.com//blog/entry/125943,Let s list the numbers of vertices in the order of their values Let it be v1 vn Then it must satisfy valuevi valuevi 1 Then we have some segments in this order for which we do not know the values For each segment we know the maximum and minimum value that the values in this segment can take let s say L and R Then we need to choose a value from the interval L R for each number in this segment in order to maintain the relative order This is a known problem and there are R L lenlen possible ways to do this where len is the length of the segment Then we need to multiply all these binomial coefficients Now notice that R L len is large so for calculation we can simply use the formula nk n n 1 n k 1 k since the sum len does not exceed n 
https://codeforces.com//contest/1217/problem/E,404647,E,1217E,1217,E. Sum Queries ,Let s define a multiset the following way Write down the sum of all elements of the multiset in its decimal representation For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same If that holds for every position then the multiset is Otherwise it s For example multiset 20 300 10001 is and multiset 20 310 10001 is The red digits mark the elements and the positions for which these elements have the same digit as the sum The sum of the first multiset is 10321 every position has the digit required The sum of the second multiset is 10331 and the second to last digit doesn t appear in any number thus making the multiset You are given an array a 1 a 2 dots a n consisting of n integers You are asked to perform some queries on it The queries can be of two types 1 i x replace a i with the value x 2 l r find the subset of the multiset of the numbers a l a l 1 dots a r with the minimum sum or report that no subset exists Note that the empty multiset is For each query of the second type print the lowest sum of the subset Print if no subset exists ,"['#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/06, 00:05:55\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst int inf = 1e9 + 5;\n\npii operator+(pii a, pii b) {\n    if (a.fs > b.fs) a.se = a.fs, a.fs = b.fs;\n    else if (a.se > b.fs) a.se = b.fs;\n    if (a.fs > b.se) a.se = a.fs, a.fs = b.se;\n    else if (a.se > b.se) a.se = b.se;\n    return a;\n}\n\nconst int sz = 1 << 18;\nstruct segtree {\n    pii seg[sz << 1];\n    segtree() {\n        for (int i = 0; i < (sz << 1); ++i) seg[i] = pii(inf, inf);\n    }\n    void init() {\n        for (int i = sz; --i; ) seg[i] = seg[i << 1] + seg[i << 1 | 1];\n    }\n    void update(int x, int v) {\n        x += sz;\n        seg[x] = pii(v, inf);\n        while (x >>= 1)\n            seg[x] = seg[x << 1] + seg[x << 1 | 1];\n    }\n    pii query(int x, int y) {\n        x += sz;\n        y += sz;\n        pii ret = pii(inf, inf);\n        while (x <= y) {\n            if ((x & 1) == 1) ret = ret + seg[x++];\n            if ((y & 1) == 0) ret = ret + seg[y--];\n            x >>= 1;\n            y >>= 1;\n        }\n        return ret;\n    }\n} seg[10];\n\nvoid update(int i, int x) {\n    for (int j = 0, k = x; j < 10; ++j, k /= 10) {\n        if (k % 10 > 0) seg[j].update(i, x);\n        else seg[j].update(i, inf);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        int x;\n        cin >> x;\n        for (int j = 0, k = x; j < 10; ++j, k /= 10) {\n            if (k % 10 > 0) seg[j].seg[i + sz] = pii(x, inf);\n            else seg[j].seg[i + sz] = pii(inf, inf);\n        }\n    }\n    for (int i = 0; i < 10; ++i) seg[i].init();\n    while (q--) {\n        int t, x, y;\n        cin >> t >> x >> y;\n        if (t == 1) update(x, y);\n        else {\n            int ans = inf + inf;\n            for (int i = 0; i < 10; ++i) {\n                pii ret = seg[i].query(x, y);\n                if (ret.se == inf) continue;\n                ans = min(ans, ret.fs + ret.se);\n            }\n            printf(""%d\\n"", ans < inf + inf ? ans : -1);\n        }\n    }\n    return 0;\n}\n']",,,"['data structures', 'greedy', 'implementation', 'math']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Sum Queries .json,https://codeforces.com//blog/entry/69605,We are given the definition of the balanced multiset but let s instead fix the criteria to determine if the multiset is unbalanced Take an empty multiset and start adding numbers to it until it becomes unbalanced Empty set to the set of one number is trivial Now for the second number If there is some position such that both numbers have non zero digits in it then the multiset becomes unbalanced let these be non zero digits and then can be neither nor After that let s prove that you can never make an unbalanced multiset balanced again by adding numbers to it Let there be such multisets and such is unbalanced is balanced and Take a look at the lowest position which has non zero digits in several numbers from The sum of these digits should be equal to at least one of them modulo to satisfy the condition of balance That can only mean their sum is greater or equal to thus is make a carry to the next position The sum of digits on the next position plus carry should also be equal to some digit of them thus pushing some other carry value to the next one And so on until the carry makes it to the position greater than any position in any of the numbers But the carry is non zero and there is no number with any non zero digit in this position That makes our assumption incorrect After all it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two The problem now got reduced to find a pair of numbers and such that there is at least one position such that both and have non zero digits on it and is minimal possible That can be easily maintained in a segment tree Let a node corresponding to the interval keep the best answer on an interval the sum of such a pair and an array the smallest number on an interval which has a non zero digit at position or if none exists The update is easy Iterate over the digits of a new number and update the values in the array in the corresponding nodes The merge is done the following way push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child Idea wise this is the same as storing a segtree and calculating the answer by each position separately However these approaches differ by a huge constant factor performance wise The former one accesses the memory in a much more cache friendly way You might want to take that as a general advice on implementing multiple segtrees Overall complexity 
https://codeforces.com//contest/594/problem/C,40380,C,594C,594,C. Edo and Magnets,Edo has got a collection of refrigerator magnets He decided to buy a refrigerator and hang the magnets on the door The shop can make the refrigerator with any size of the door that meets the following restrictions the refrigerator door must be rectangle and both the length and the width of the door must be Edo figured out how he wants to place the magnets on the refrigerator He introduced a system of coordinates on the plane where each magnet is represented as a rectangle with sides parallel to the coordinate axes Now he wants to remove no more than magnets he may choose to keep all of them and attach all remaining magnets to the refrigerator door and the area of the door should be as small as possible A magnet is considered to be attached to the refrigerator door if lies on the door or on its boundary The relative positions of all the remaining magnets must correspond to the plan Let us explain the last two sentences Let s suppose we want to hang two magnets on the refrigerator If the magnet in the plan has coordinates of the lower left corner and the upper right corner then its center is located at may not be integers By saying the relative position should correspond to the plan we mean that the only available operation is translation i e the vector connecting the centers of two magnets in the original plan must be equal to the vector connecting the centers of these two magnets on the refrigerator ,"[""#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=acos(-1);\nvoid gn(int &x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n\tif(c=='-')sg=-1,x=0;else x=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n\tx*=sg;\n}\nvoid gn(ll &x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n\tif(c=='-')sg=-1,x=0;else x=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n\tx*=sg;\n}\nconst int mo=1000000007;\nconst int inf=1061109567;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint n,k;\n\nstruct node{\n\tll x,y;int id;\n}p[111111],q[111111];\nint cmpx(const node &a,const node&b){\n\treturn a.x<b.x;\n}\nint cmpy(const node &a,const node&b){\n\treturn a.y<b.y;\n}\nint ind=0;\nint off[111111];\nint cnt=0;\nvoid mark(int i){\n\tif(off[i]!=ind){\n\t\toff[i]=ind;\n\t\tcnt++;\n\t}\n}\n\nint main(){\n\tgn(n);gn(k);\n\tfor (int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tgn(a);\n\t\tgn(b);\n\t\tgn(c);\n\t\tgn(d);\n\t\tp[i].x=a+c;\n\t\tp[i].y=b+d;\n\t\tp[i].id=i;\n\t}\n\tfor (int i=1;i<=n;i++)q[i]=p[i];\n\tsort(p+1,p+1+n,cmpx);\n\tsort(q+1,q+1+n,cmpy);\n\t\n\tll mi=ll(6e18);\n\tfor (int l=0;l<=k;l++)\n\t\tfor (int r=0;r<=k;r++)\n\t\t\tfor (int u=0;u<=k;u++)\n\t\t\t\tfor (int d=0;d<=k;d++){\n\t\t\t\t\t++ind;cnt=0;\n\t\t\t\t\tfor (int i=1;i<=l;i++)mark(p[i].id);\n\t\t\t\t\tfor (int i=n;i>=n-r+1;i--)mark(p[i].id);\n\t\t\t\t\tfor (int i=1;i<=d;i++)mark(q[i].id);\n\t\t\t\t\tfor (int i=n;i>=n-u+1;i--)mark(q[i].id);\n\t\t\t\t\tif(cnt>k)continue;\n\n\t\t\t\t\tll w=max(2ll,p[n-r].x-p[l+1].x);\n\t\t\t\t\tll h=max(2ll,q[n-u].y-q[d+1].y);\n\t\t\t\t\tif(w&1)w++;\n\t\t\t\t\tif(h&1)h++;\n\t\t\t\t\tmi=min(mi,(w/2)*(h/2));\n\t\t\t\t}\n\tcout<<mi<<endl;\n\treturn 0;\n}\n""]",,,"['brute force', 'greedy', 'implementation', 'two pointers']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Edo and Magnets.json,https://codeforces.com//blog/entry/21487,Let s find the centers of every rectangle and multiple them of 2 to make all coordinates integers Then we need to by the rectangle door which contains all dots but the lengths of the sides of this door must be rounded up to the nearest integers Now let s delete the magnets from the door one by one gradually the door will decrease Obviously every time optimal to delete only dots which owned to the sides of the rectangle Let s brute 4k ways how we will do delete the magnets We will do it with helps of recursion every time we will delete point with minimum or maximum value of the coordinates If we will store 4 arrays or 2 deques we can do it with asymptotic O 1 Such a solution works O 4k It can be easily shown that this algorithm delete always some number of the leftmost rightmost uppermost and lowermost points So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays This solution has asymptotic behavior O k4 
https://codeforces.com//contest/702/problem/A,66878,A,702A,702,A. Maximum Increase,You are given array consisting of integers Your task is to find the maximum length of an increasing subarray of the given array A subarray is the sequence of consecutive elements of the array Subarray is called increasing if each element of this subarray than previous ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\n\nvoid solve() {\n\tint i,j,k,l,r,y; string s;\n\t\n\tint ma=1,x=0,cur=0;\n\tcin>>N;\n\twhile(N--) {\n\t\tcin>>y;\n\t\tif(y>x) ma=max(ma,++cur);\n\t\telse cur=1;\n\t\tx = y;\n\t}\n\tcout<<ma<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n""]",,,"['dp', 'greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Maximum Increase.json,https://codeforces.com//blog/entry/46324?locale=en,Let s iterate through the given array from the left to the right and store in the variable the length of the current increasing subarray If the current element is more than the previous we need to increase on one In the other case we need to update the answer with the value of and put in 1 because new increasing subarray began 
https://codeforces.com//contest/1654/problem/G,1337004,G,1654G,1654,G. Snowy Mountain,There are n locations on a snowy mountain range numbered from 1 to n connected by n 1 trails in the shape of a tree Each trail has length 1 Some of the locations are base lodges The height h i of each location is equal to the distance to the nearest base lodge a base lodge has height 0 There is a skier at each location each skier has initial kinetic energy 0 Each skier wants to ski along as many trails as possible Suppose that the skier is skiing along a trail from location i to j Skiers are not allowed to ski uphill i e if h i h j It costs one unit of kinetic energy to ski along flat ground i e if h i h j and a skier gains one unit of kinetic energy by skiing downhill i e if h i h j For each location compute the length of the longest sequence of trails that the skier starting at that location can ski along without their kinetic energy ever becoming negative Skiers are allowed to visit the same location or trail multiple times ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nconst int N = 202\'222;\nvector<int> a[N];\nint h[N];\n\nvector<int> same[N];\nvector<int> up[N];\nbool good[N];\n\nint lowest[N];\nint could[N];\n\nvoid remin(int& x, int y) {\n\tx = (x < y) ? x : y;\n}\n\nvoid dfs(int v, int cur, int dest) {\n\tif (cur == 0) {\n\t\tremin(lowest[v], h[dest]);\n\t}\n\tif (h[dest] > lowest[v]) {\n\t\treturn;\n\t}\n\tif (cur >= could[v]) {\n\t\treturn;\n\t}\n\tcould[v] = cur;\n\tfor (int x : same[v]) {\n\t\tdfs(x, cur + 1, dest);\n\t}\n\tfor (int x : up[v]) {\n\t\tdfs(x, cur ? cur - 1 : 0, dest);\n\t}\n}\n\nvoid solve() {\n\tint n = nxt();\n\tfor (int i = 0; i < n; ++i) {\n\t\th[i] = nxt() - 1;\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (~h[i]) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tfor (int x : a[v]) {\n\t\t\tif (h[x] == -1) {\n\t\t\t\th[x] = h[v] + 1;\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tgood[i] = false;\n\t\tfor (int x : a[i]) {\n\t\t\tif (h[i] == h[x]) {\n\t\t\t\tsame[i].push_back(x);\n\t\t\t\tgood[i] = true;\n\t\t\t} else if (h[x] > h[i]) {\n\t\t\t\tup[i].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> all_good;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (good[i]) {\n\t\t\tall_good.push_back(i);\n\t\t}\n\t}\n\tsort(all(all_good), [&](int x, int y) {\n\t\treturn h[x] < h[y];\n\t});\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tlowest[i] = 1e9;\n\t\tcould[i] = 1e9;\n\t}\n\n\tfor (int v : all_good) {\n\t\tdfs(v, 0, v);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint ans = h[i];\n\t\tif (lowest[i] < 1e8) {\n\t\t\tans = max(ans, 2 * h[i] - lowest[i]);\n\t\t}\n\t\tcout << ans << "" "";\n\t}\n\tcout << ""\\n"";\n}\n\nint main() {\n\tint t = 1; // nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']",,,"['data structures', 'dfs and similar', 'graphs', 'greedy', 'shortest paths', 'trees']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Snowy Mountain.json,https://codeforces.com//blog/entry/100127,SolutionRead the hints The rest is just implementation For each set of flippable vertices of the same height we can calculate the set of starting vertices which are able to reach at least one vertex in that flippable set To do this split the graph up into layers of equal height Let be the minimum required energy to reach a vertex in the flippable set can be computed via shortests paths where edges in the same layer have weight and edges from layer to have weight We can use bfs to relax the costs of vertices in a single layer and then easily transition to the next layer We do this for different starting heights so the total complexity is 
https://codeforces.com//contest/1456/problem/E,814140,E,1456E,1456,E. XOR-ranges,Given integers c 0 c 1 ldots c k 1 we can define the cost of a number 0 le x 2 k as p x sum i 0 k 1 left left lfloor frac x 2 i right rfloor bmod 2 right cdot c i In other words the cost of number x is the sum of c i over the bits of x which are equal to one Let s define the cost of array a of length n ge 2 with elements from 0 2 k as follows cost a sum i 1 n 1 p a i oplus a i 1 where oplus denotes bitwise exclusive OR operation You have to construct an array of length n with minimal cost given that each element should belong to the given segment l i le a i le r i ,"[""#include <bits/stdc++.h>\n\ntemplate <typename T> void setmin(T& a, T b) { if (b < a) a = b; }\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint N, K; cin >> N >> K;\n\tvector<array<int64_t, 2>> bounds(N);\n\t// make them both exclusive\n\tfor (auto& a : bounds) {\n\t\tcin >> a[0] >> a[1];\n\t\ta[0]--, a[1]++;\n\t}\n\tvector<int64_t> costs(K); for (auto& c : costs) cin >> c;\n\n\tconst int64_t INF = 1e18;\n\tvector<array<array<int64_t, 4>, 4>> dp((N+1)*(N+2)/2);\n\tauto I = [](int i, int j) {\n\t\treturn j * (j+1) / 2 + (j - i - 1);\n\t};\n\tfor (int k = K; k >= 0; k--) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tfor (int i = j-1; i >= -1; i--) {\n\t\t\t\tfor (int mi = 3; mi >= 0; mi--) {\n\t\t\t\t\tfor (int mj = 3; mj >= 0; mj--) {\n\t\t\t\t\t\tint64_t val;\n\t\t\t\t\t\tif (k == K) {\n\t\t\t\t\t\t\tval = (j-i == 1) ? 0 : INF;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbool needs = i >= 0 && j <= N-1 && bool((((bounds[i][mi>>1] ^ bounds[j][mj>>1]) >> k) ^ mi ^ mj) & 1);\n\t\t\t\t\t\t\tval = dp[I(i,j)][mi&2][mj&2] + (needs * costs[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((mi & 1) && (mj & 1)) {\n\t\t\t\t\t\t\t// we get to skip this part\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int md = i+1; md <= j-1; md++) {\n\t\t\t\t\t\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\t\t\t\t\t\t// we can try using this midpoint\n\t\t\t\t\t\t\t\t\tint64_t mm = (bounds[md][z] >> k) ^ 1;\n\t\t\t\t\t\t\t\t\tif (bounds[md][0] < (mm << k) && ((mm + 1) << k) <= bounds[md][1]) {\n\t\t\t\t\t\t\t\t\t\tsetmin(val, dp[I(i,md)][mi][2*z+1] + dp[I(md,j)][2*z+1][mj]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[I(i,j)][mi][mj] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp.back()[0][0] << '\\n';\n\n\treturn 0;\n}""]",,,"['dp', 'greedy']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. XOR-ranges.json,https://codeforces.com//blog/entry/85118,First we will make all segments exclusive for convenience Assume we have segment we gonna analyze the process of forming from highest bit to lowest bit Let is the highest bit such that th bit of and are different Apparently bits higher than of x has to be same with bits of and We call bit of the segment Now we set th bit of off almost similar if we set on From now on we have and continue considering lower bits If the considered bit is on in we must set this bit on in otherwise we have two choices Set this bit off in and consider lower bits Set this bit on in and don t need to care about lower bits Because now Let call low bits that we don t need to care bits Back to the problem imagine if we fixed all non free bits of every element how should we set other bits in order to minimize the cost It s quite simple Consider th bit call the pair if th bits of and are non free but ones of are free For each visible pair such that th bit of endpoints in this pair are different from each other we ll add to the answer This thing inspire us to write a dynamic programming function is with is how did you set key bit for th element and is where is lowest non free bit of this element equal to or lower than similar to is minimal cost at th and higher bits of such that is currently visible We have two types of transition Make really visible by going to th bit Make invisible by choosing and choosing such that lowest non free bit of th element is Note that if is the highest bit first transition only be allowed if Our answer is just 
https://codeforces.com//contest/1567/problem/D,1099176,D,1567D,1567,D. Expression Evaluation Error,On the board Bob wrote n positive integers in base 10 with sum s i e in decimal numeral system Alice sees the board but accidentally interprets the numbers on the board as base 11 integers and adds them up in base 11 What numbers should Bob write on the board so Alice s sum is as large as possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint pw[200];\nvoid solve() {\n\tint s, n;\n\tscanf(""%d%d"", &s, &n);\n\tint s2 = s;\n\tvector<int> d;\n\tint cnt = 0;\n\twhile (s) {\n\t\tcnt += s % 10;\n\t\td.push_back(s % 10);\n\t\ts /= 10;\n\t}\n\twhile (cnt < n) {\n\t\tfor (int j = 1; j < d.size(); j++) {\n\t\t\tif (d[j] > 0) {\n\t\t\t\td[j] -= 1;\n\t\t\t\td[j - 1] += 10;\n\t\t\t\tcnt += 9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ans;\n\tfor (int j = 0; j < d.size(); j++) {\n\t\tfor (int k = 0; k < d[j]; k++)\n\t\t\tans.push_back(pw[j]);\n\t}\n\treverse(ans.begin(), ans.end());\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tprintf(""%d "", ans[i]);\n\t\ts2 -= ans[i];\n\t}\n\tprintf(""%d\\n"", s2);\n}\n\nint main() {\n\tpw[0] = 1;\n\tfor (int i = 1; i < 10; i++) pw[i] = pw[i - 1] * 10;\n\tint T;\n\tscanf(""%d"", &T);\n\tfor (int i = 0; i < T; i++) solve();\n}']",,,"['constructive algorithms', 'greedy', 'implementation', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Expression Evaluation Error.json,https://codeforces.com//blog/entry/94581,Let s greedily construct the largest possible sum for Alice digit by digit That is the leftmost position should have the largest value possible then the second leftmost position and so on The maximum value of the leftmost digit of Alice s sum is clearly equal to the leftmost digit of the number since it cannot be larger Similarly the maximum possible value for the second leftmost digit in Alice s sum cannot be larger than the corresponding digit in and so on In general Alice s sum cannot be larger than the number when interpreted as a base 11 number So how can we maintain the sum of when we express it as a sum of numbers The idea is to split into a sum of powers of For example if and Bob writes down Then Alice will not have any carries and so the answer will just be interpreted as a base 11 number But what if we need to write down more numbers than the sum of the digits of Then we re forced to split a power ten into units When we split a power of it can be seen that we should split the smallest power of that isn t call it as and We can check all powers of and it can be shown that this is the best way to split For example if and then we do the following process to to to If and we do the following process to to Note that in this last case splitting is better than splitting since the sum of and Time complexity if you lazily iterate over all currently split numbers or if you use a priority queue 
https://codeforces.com//contest/1767/problem/D,1697003,D,1767D,1767,D. Playoff,2 n teams participate in a playoff tournament The tournament consists of 2 n 1 games They are held as follows in the first phase of the tournament the teams are split into pairs team 1 plays against team 2 team 3 plays against team 4 and so on so 2 n 1 games are played in that phase When a team loses a game it is eliminated and each game results in elimination of one team there are no ties After that only 2 n 1 teams remain If only one team remains it is declared the champion otherwise the second phase begins where 2 n 2 games are played in the first one of them the winner of the game 1 vs 2 plays against the winner of the game 3 vs 4 then the winner of the game 5 vs 6 plays against the winner of the game 7 vs 8 and so on This process repeats until only one team remains The skill level of the i th team is p i where p is a permutation of integers 1 2 2 n a permutation is an array where each element from 1 to 2 n occurs exactly once You are given a string s which consists of n characters These characters denote the results of games in each phase of the tournament as follows if s i is equal to then during the i th phase the phase with 2 n i games in each match the team with the lower skill level wins if s i is equal to then during the i th phase the phase with 2 n i games in each match the team with the higher skill level wins Let s say that an integer x is if it is possible to find a permutation p such that the team with skill x wins the tournament Find all winning integers ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nint n;\nint dp[2][N];\nchar s[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tscanf("" %s"", s);\n\treverse(s, s + n);\n\tdp[0][0] = 1;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i <= (1 << (k + 1)); i++)\n\t\t\tdp[1][i] = 0;\n\t\tfor (int w = 0; w < (1 << k); w++) if (dp[0][w]) {\n\t\t\tint curW = w;\n\t\t\tint curL = (1 << k) - 1 - w;\n\t\t\tint l, r;\n\t\t\tif (s[k] == \'0\') {\n\t\t\t\tl = curL;\n\t\t\t\tr = 2 * curL;\n\t\t\t\tswap(l, r);\n\t\t\t\tl = (1 << (k + 1)) - 1 - l;\n\t\t\t\tr = (1 << (k + 1)) - 1 - r;\n\t\t\t} else {\n\t\t\t\tl = curW;\n\t\t\t\tr = 2 * curW;\n\t\t\t}\n\t\t\tdp[1][l]++;\n\t\t\tdp[1][r + 1]--;\n\t\t}\n\t\tint bal = 0;\n\t\tfor (int i = 0; i < (1 << (k + 1)); i++) {\n\t\t\tbal += dp[1][i];\n\t\t\tdp[0][i] = min(1, bal);\n\t\t}\n\t}\n\tfor (int i = (1 << n) - 1; i >= 0; i--) if (dp[0][i])\n\t\tprintf(""%d "", (1 << n) - i);\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'constructive algorithms', 'dp', 'greedy', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Playoff.json,https://codeforces.com//blog/entry/110225,Firstly let s prove that the order of characters in is interchangeable Suppose we have a tournament of four teams with skills and such that and this tournament has the form or It s easy to see that and cannot be winners since will be eliminated in the round with type and will be eliminated in the round with type However it s easy to show that both with and with and can be winners Using this argument to matches that go during phases and a group of two matches during phase and a match during phase between the winners of those matches can be considered a tournament with we can show that swapping and does not affect the possible winners of the tournament So suppose all phases of type happen before phases of type there are phases of type and phases of type teams will be eliminated in the first part phases of type and the team with the lowest skill that wasn t eliminated in the first half will win the second half It s easy to see that the teams with skills cannot pass through the first part of the tournament since to pass the first part a team has to be the strongest in its subtree of size Furthermore since the minimum of teams passing through the first half wins the winner should have skill not greater than the winner should have lower skill than at least teams so teams with skills higher than cannot win Okay now all possible winners belong to the segment Let s show that any integer from this segment can be winning Suppose let s construct the tournament in such a way that only team with skill and teams with the highest skill pass through the first part of the tournament obviously then team wins There are independent tournaments of size in the first part let s assign teams with skills from to and also the team to one of those tournaments for all other tournaments let s assign the teams in such a way that exactly one team from the highest ones competes in each of them It s easy to see that the team will win its tournament and every team from the highest ones will win its tournament as well so the second half will contain only teams with skills and and obviously will be the winner of this tournament So the answer to the problem is the segment of integers 
https://codeforces.com//contest/375/problem/B,4236,B,375B,375,B. Maximum Submatrix 2,You are given a matrix consisting of digits zero and one its size is You are allowed to rearrange its rows What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations Let s assume that the rows of matrix are numbered from 1 to from top to bottom and the columns are numbered from 1 to from left to right A matrix cell on the intersection of the th row and the th column can be represented as Formally a submatrix of matrix is a group of four integers We will assume that the submatrix contains cells The area of the submatrix is the number of cells it contains ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int MAX_N = 5000 + 10;\nchar map[MAX_N][MAX_N];\nint rt[MAX_N][MAX_N];\nint n, m;\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int r = 0; r < n; ++r) {\n\t\tscanf(""%s"", map[r]);\n\t}\n\n\tfor (int r = 0; r < n; ++r) {\n\t\trt[r][m] = 0;\n\t\tfor (int c = m - 1; c >= 0; --c) {\n\t\t\trt[r][c] = map[r][c] == \'1\' ? rt[r][c + 1] + 1 : 0;\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor (int c = 0; c < m; ++c) {\n\t\tstatic int a[MAX_N];\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\ta[r] = rt[r][c];\n\t\t}\n\t\tsort(a, a + n);\n\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tans = max(ans, a[r] * (n - r));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'implementation', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Maximum Submatrix 2.json,https://codeforces.com//blog/entry/10084,We can get right i j by O n m dp Let right i j how many continuous 1s is on cell j i s right Let answer 0 For all column i 
https://codeforces.com//contest/126/problem/C,664,C,126C,126,C. E-reader Display,After years of hard work scientists invented an absolutely new e reader display The new display has a larger resolution consumes less energy and its production is cheaper And besides one can bend it The only inconvenience is highly unusual management For that very reason the developers decided to leave the e readers software to programmers The display is represented by square of pixels each of which can be either black or white The display rows are numbered with integers from to upside down the columns are numbered with integers from to from the left to the right The display can perform commands like When a traditional display fulfills such command it simply inverts a color of where is the row number and is the column number But in our new display every pixel that belongs to at least one of the segments and both ends of both segments are included inverts a color For example if initially a display in size is absolutely white then the sequence of commands leads to the following changes You are an e reader software programmer and you should calculate minimal number of commands needed to display the picture You can regard all display pixels as initially white ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 2010\nchar s[N][N];int n,S=0;bool v1[N],v2[N],w1[N],w2[N];\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor(int i=0;i<n;i++)scanf(""%s"",s[i]);\n\tfor(int i=n-1;i>0;i--)\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif((s[j][j-i]-\'0\')^v1[j]^v2[j-i])S++,v1[j]^=1,v2[j-i]^=1;\n\tfor(int i=n-1;i>0;i--)\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif((s[j-i][j]-\'0\')^w1[j-i]^w2[j])S++,w1[j-i]^=1,w2[j]^=1;\n\tfor(int i=0;i<n;i++)\n\t\tif((s[i][i]-\'0\')^v1[i]^v2[i]^w1[i]^w2[i])S++;\n\tprintf(""%d\\n"",S);\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. E-reader Display.json,https://codeforces.com/blog/entry/3140,You can see that every command i j you should do no more than once Also order of commands doesn t matter Actually sequence of command you can represent as boolean matrix A with size n n where aij 1 mean that you do the command i j and aij 0 mean that you don t do it Let us describe one way to construct the matrix Let the starting image is boolean matrix G A boolean matrix B of size n n stores intermediate image that you will recieve during process of doing commands For the upper half of matrix G without main diagonal you should move line by line from the up to the down For every line you should move from the right to the left You can see that for every positions all nonconsidered positions do not affect the current position So if you see that values for position i j in the matrices G and B are different you should do command i j set in the matrix A aij 1 and change segments i i i j and j j i j in the matrix B For the lower half of the matrix G without main diagonal you should do it absolutely symmetric At the end you should iterate over main diagonal Here it should be clear Well for matrix G you always can build matrix A and do it by exactly one way It mean that this way requires minimum number of commands So you can get answer for problem by following way you can build the matrix A from the matrix G and output number of ones in the matrix A There is only one problem that you should solve Algorithm that you can see above works in O n3 that doesn t fit into time limits Let s speed up it to O n2 Consider in the matrix B the upper half without main diagonal During doing commands all columns of cells that placed below current position will have same values Values above current position are not matter for us Therefore instead of the matrix B you can use only one array that stores values of columns It allows you do every command in O 1 instead of O n This optimization gives a solution that works in O n2 
https://codeforces.com//contest/1216/problem/F,416606,F,1216F,1216,F. Wi-Fi,You work as a system administrator in a dormitory which has n rooms one after another along a straight hallway Rooms are numbered from 1 to n You have to connect all n rooms to the Internet You can connect each room to the Internet directly the cost of such connection for the i th room is i coins Some rooms also have a spot for a router The cost of placing a router in the i th room is also i coins You cannot place a router in a room which does not have a spot for it When you place a router in the room i you connect all rooms with the numbers from max 1 i k to min n i k inclusive to the Internet where k is the range of router The value of k is the same for all routers Calculate the minimum total cost of connecting all n rooms to the Internet You can assume that the number of rooms which have a spot for a router is not greater than the number of routers you have ,"['//#pragma GCC optimize(2)\n//#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define LL long long\n#define re register\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\n#define lson (node<<1)\n#define rson (node<<1|1)\nusing namespace std;\nconst int N=400004;\nconst int p=998244353;\nint n,K;\nchar s[N];\nLL f[N];\nint h[N],t,w;\n\nvoid read(int &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<\'0\'||ch>\'9\';ch=getchar());\n\tfor(;ch>=\'0\'&&ch<=\'9\';ch=getchar()) x=(x<<3)+(x<<1)+ch-\'0\';\n}\n\nint main(){\n\tread(n);read(K);\n\tscanf(""%s"",s+1);\n\tmemset(f,0x3f,sizeof f);\n\tf[0]=0;h[t=w=1]=0;\n\tLL ans=1e18;\n\tfr(i,1,n+K){\n\t\tf[i]=min(f[i],f[i-1]+i);\n\t\tif (i<=K||s[i-K]!=\'1\') 233;\n\t\t else{\n\t\t \twhile(w-t>=0&&h[t]<=i-2*K-2) t++;\n\t\t\tif (w-t>=0) f[i]=min(f[i],f[h[t]]+i-K);\n\t\t }\n\t\th[++w]=i;\n\t\twhile(w>t&&f[h[w]]<=f[h[w-1]]) h[w-1]=h[w],w--;\n\t\tif (i>=n) ans=min(ans,f[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}']",,,"['data structures', 'dp', 'greedy']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Wi-Fi.json,https://codeforces.com//blog/entry/69954,Firstly I know that this problem has very pretty linear solution and its author can describe it if he wants I ll describe my own solution without any data structures but Let be the total cost to connect all rooms from to to the Internet indexed Initially all other values are Let s iterate over all from to and make some transitions After all the answer will be The first transition is the easier update with just connect the current room directly To do other transitions let s carry two sets and and one array of vectors of length Set carries all values Initially it carries Set carries the minimum cost to cover some suffix of rooms that also covers the room Array of vectors helps us to carry the set efficiently First of all if then let s remove from Then let s remove all values of from Then if is not empty let s update with the minimum value of Then if then let be the minimum value of plus Update with and insert into Also let s add into if And after we make all we need with the current add the value to the set Time complexity It can be optimized to solution with some advanced data structures as a queue with minimums 
https://codeforces.com//contest/1742/problem/E,1584060,E,1742E,1742,E. Scuza,Timur has a stairway with n steps The i th step is a i meters higher than its predecessor The first step is a 1 meters higher than the ground and the ground starts at 0 meters Timur has q questions each denoted by an integer k 1 dots k q For each question k i you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length k i Timur can only climb the j th step if his legs are of length at least a j In other words k i geq a j for each step j climbed Note that you should answer each question independently ,"['#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\n#define vi vector<int>\n\nvoid solve()\n{\n\tint n,q;\n\tcin>>n>>q;\n\n\tvi v(n);\n\tfor(int i=0;i<n;i++)\n\t\t cin>>v[i];\n\n\t\tvi dp(n);\n\t\tdp[0]=v[0];\n\n\t\tfor(int i=1;i<n;i++)\n\t\t\t dp[i]=max(v[i],dp[i-1]);\n\n\t\tvi pre(n,0);\n\t\tpre[0]=v[0];\n\n\t\tfor(int i=1;i<n;i++)\n\t\t\t pre[i]=pre[i-1]+v[i];\n\n\t\twhile(q--)\n\t\t{\n\t\t\t int a;\n\t\t\t cin>>a;\n\n\t\t\t int index=upper_bound(dp.begin(),dp.end(),a)-dp.begin();\n\n\t\t\t index--;\n\t\t\t if(index<0)\n\t\t\t \t cout<<""0""<<"" "";\n\t\t\t else\n\t\t\t \tcout<<pre[index]<<"" "";\n\t\t}\n\n\t\tcout<<endl;\n}\n\nint32_t main()\n{\n\t int t=1;\n\n\t cin>>t;\n\n\t while(t--)\n\t {\n\t \t solve();\n\t }\n\t return 0;\n}                                    ']",,,"['binary search', 'greedy', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\E. Scuza.json,https://codeforces.com//blog/entry/107962,Let s compute the prefix sums of the array let Rephrasing the problem for each question containing an integer we need to find the largest such that are all at most and then output In other words Let s make the prefix maximums of the array let Then we need to find the largest such that which is doable using binary search since the array is non decreasing Once we find the index we simply need to output The time complexity is per testcase 
https://codeforces.com//contest/866/problem/B,125341,B,866B,866,B. Ordering Pizza,It s another Start c up finals and that means there is pizza to order for the onsite contestants There are only 2 types of pizza obviously not but let s just pretend for the sake of the problem and all pizzas contain exactly slices It is known that the th contestant will eat slices of pizza and gain happiness for each slice of type 1 pizza they eat and happiness for each slice of type 2 pizza they eat We can order any number of type 1 and type 2 pizzas but we want to buy the minimum possible number of pizzas for all of the contestants to be able to eat their required number of slices Given that restriction what is the maximum possible total happiness that can be achieved ,"['/**\n *    author:  tourist\n *    created: 30.09.2017 20:08:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint eat[N], a[N], b[N];\n\nint main() {\n  int n, s;\n  scanf(""%d %d"", &n, &s);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(""%d %d %d"", eat + i, a + i, b + i);\n    total += eat[i];\n  }\n  long long pizzas = (total + s - 1) / s;\n  eat[n] = s * pizzas - total;\n  a[n] = 0;\n  b[n] = 0;\n  n++;\n  vector< pair<long long, long long> > a_to_b, b_to_a;\n  long long ans = 0;\n  long long cnt_a = 0, cnt_b = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] > b[i]) {\n      ans += eat[i] * 1LL * a[i];\n      a_to_b.emplace_back(a[i] - b[i], eat[i]);\n      cnt_a += eat[i];\n    } else {\n      ans += eat[i] * 1LL * b[i];\n      b_to_a.emplace_back(b[i] - a[i], eat[i]);\n      cnt_b += eat[i];\n    }\n  }\n  long long best = (long long) 1e18;\n  {\n    long long extra = cnt_a % s;\n    sort(a_to_b.begin(), a_to_b.end());\n    long long cur = 0;\n    for (int i = 0; i < (int) a_to_b.size(); i++) {\n      auto &p = a_to_b[i];\n      long long take = min(p.second, extra);\n      cur += take * p.first;\n      extra -= take;\n    }\n    best = min(best, cur);\n  }\n  {\n    long long extra = cnt_b % s;\n    sort(b_to_a.begin(), b_to_a.end());\n    long long cur = 0;\n    for (int i = 0; i < (int) b_to_a.size(); i++) {\n      auto &p = b_to_a[i];\n      long long take = min(p.second, extra);\n      cur += take * p.first;\n      extra -= take;\n    }\n    best = min(best, cur);\n  }\n  cout << (ans - best) << endl;\n  return 0;\n}\n']",,,"['greedy', 'implementation', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Ordering Pizza.json,https://codeforces.com//blog/entry/54888,To simplify things let s first add a dummy contestant who will eat all the leftover pizza but gain no happiness Then let s sort the contestants by bi ai Now we can describe the optimal way to feed the contestants once the pizzas are already bought we should line up the contestants in order and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back Then the first contestant should take the first s1 slices then the second contestant should take the next s2 slices and so on Observe that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2 The remainder of pizzas will have only one type of preference or possibly no preference so those pizzas can be made of whichever type is preferred For the final pizza we can check both possibilities and order the one that provides more happiness 
https://codeforces.com//contest/1625/problem/E2,1258604,E2,1625E2,1625,E2. Cats on the Upgrade  hard version , Interplanetary Software Inc together with Robots of Cydonia Ltd has developed and released robot cats These electronic pets can meow catch mice and entertain the owner in various ways The developers from Interplanetary Software Inc have recently decided to release a software update for these robots After the update the cats must solve the problems about bracket sequences One of the problems is described below First we need to learn a bit of bracket sequence theory Consider the strings that contain characters and Call a string if it can be transformed to an empty string by one or more operations of removing either single characters or a continuous substring For instance the string is an RBS as it can be transformed to an empty string with the following sequence of removals rightarrow rightarrow rightarrow rightarrow We got an empty string so the initial string was an RBS At the same time the string is not an RBS as it is not possible to apply such removal operations to it An RBS is if this RBS is not empty doesn t start with and doesn t end with Denote the of the string s as its sequential subsegment In particular s l dots r s ls l 1 dots s r where s i is the i th character of the string s Now move on to the problem statement itself You are given a string s initially consisting of characters and You need to answer the following queries Given two indices l and r 1 le l r le n It s that the l th character is equal to the r th character is equal to and the characters between them are equal to Then the l th and the r th characters must be set to Given two indices l and r 1 le l r le n and it s that the substring s l dots r is a You need to find the number of substrings in s l dots r such that they are simple RBS In other words find the number of index pairs i j such that l le i j le r and s i dots j is a simple RBS You are an employee in Interplanetary Software Inc and you were given the task to teach the cats to solve the problem above after the update ,"['#include <bits/stdc++.h>\n#define rep(i,n) for (i=1;i<=(n);i++)\nusing namespace std;\nint n,m,i,mat[300007];\nmap<int,int> id[300007];\nchar s[300007];\nint dfc,nfd[600007],deg[600007],fa[600007],ord[600007];\nint snc;\nlong long r[600007];\nvoid add(int x,long long v){\n\twhile(x<=600006){\n\t\tr[x]+=v;\n\t\tx+=(x&-x);\n\t}\n}\nlong long qsum(int x){\n\tlong long ans=0;\n\twhile(x){\n\t\tans+=r[x];\n\t\tx&=(x-1);\n\t}\n\treturn ans;\n}\nint ex[600007];\nvoid add2(int x,int v){\n\twhile(x<=600006){\n\t\tex[x]+=v;\n\t\tx+=(x&-x);\n\t}\n}\nint qsum2(int x){\n\tint ans=0;\n\twhile(x){\n\t\tans+=ex[x];\n\t\tx&=(x-1);\n\t}\n\treturn ans;\n}\nint solve(int l,int r){\n\tint u=++dfc;\n\tid[l][r]=u;\n\tl++;r--;\n\tif(l>r){\n\t\tnfd[u]=dfc;\n\t\treturn u;\n\t}\n\tvector<int> vson;\n\twhile(l<=r){\n\t\tint son;\n\t\tfa[son=solve(l,mat[l])]=u;\n\t\tl=mat[l]+1;\n\t\tdeg[u]++;\n\t\tvson.push_back(son);\n\t}\n\tfor(int son:vson){\n\t\tord[son]=++snc;\n\t}\n\tadd(u,1ll*deg[u]*(deg[u]+1)/2);\n\tnfd[u]=dfc;\n\treturn u;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tscanf("" %s"",s+1);\n\tstack<int> c;\n\trep(i,n){\n\t\tif(s[i]==\'(\') c.push(i);\n\t\telse if(!c.empty()){\n\t\t\tmat[c.top()]=i;\n\t\t\tmat[i]=c.top();\n\t\t\tc.pop();\n\t\t}\n\t}\n\tvector<int> vson;\n\tfor(int i=1;i<=n;i++){\n\t\tif(mat[i]){\n\t\t\tvson.push_back(solve(i,mat[i]));\n\t\t\ti=mat[i];\n\t\t}\n\t}\n\tfor(int son:vson){\n\t\tord[son]=++snc;\n\t}\n\trep(i,snc) add2(i,1);\n\twhile(m--){\n\t\tint op,l,r;\n\t\tscanf(""%d%d%d"",&op,&l,&r);\n\t\tif(op==2){\n\t\t\tint lid=id[l][mat[l]];\n\t\t\tint rid=id[mat[r]][r];\n\t\t\tprintf(""%lld\\n"",qsum(nfd[rid])-qsum(lid-1)+1ll*(qsum2(ord[rid])-qsum2(ord[lid])+1)*(qsum2(ord[rid])-qsum2(ord[lid])+2)/2);\n\t\t}\n\t\telse{\n\t\t\tint i=id[l][r];\n\t\t\tif(fa[i]){\n\t\t\t\tadd(fa[i],-deg[fa[i]]);\n\t\t\t\tdeg[fa[i]]--;\n\t\t\t}\n\t\t\tadd2(ord[i],-1);\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['binary search', 'data structures', 'dfs and similar', 'graphs', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E2. Cats on the Upgrade  hard version .json,https://codeforces.com//blog/entry/99031,Now we need to see how to handle removal queries in this task Build an SQRT decomposition in the following way We will rebuild the entire tree after each queries and recalculate the DP Between the rebuilds we hold a list of removed leaves Now look how we can recalculate the answer if some leaves are removed First suppose that the leaf is not a direct child of the vertex we are interested in Then the removal of this leaf decreases the answer by where is the number of children of this leaf s parent Why so The parent of this leaf had the answer as sum of answers in its children plus The answer in the leaf is equal to zero so the new answer became sum plus thus decreased by When we build the DP the modification of answer in a vertex is passed to its parents unchanged So the answer decreases by on the entire path from this leaf to the root We can easily check if we are affected by this removal It must be applied only if the removed leaf lies strictly inside our query of the second type We also need to handle the case where our leaf is a direct child of the vertex we consider as the removal described above doesn t fully apply to this case This is an exercise left to the reader So we get the solution in There is also a solution in We consider it very shortly Let s hold just in each vertex not the sum over children plus as we did before Then the answer for each vertex is the sum in the subtree We can keep a Fenwick tree as we can calculate sums in the subtree with it using Eulerian tour over the tree It s not hard to see that each update must be applied only once to the direct parent 
https://codeforces.com//contest/1898/problem/B,2335769,B,1898B,1898,B. Milena and Admirer,Milena has received an array of integers a 1 a 2 ldots a n of length n from a secret admirer She thinks that making it non decreasing should help her identify the secret admirer She can use the following operation to make this array non decreasing Select an element a i of array a and an integer x such that 1 le x a i Then replace a i by two elements x and a i x in array a New elements x and a i x are placed in the array a in this order instead of a i More formally let a 1 a 2 ldots a i ldots a k be an array a before the operation After the operation it becomes equal to a 1 a 2 ldots a i 1 x a i x a i 1 ldots a k Note that the length of a increases by 1 on each operation Milena can perform this operation multiple times possibly zero She wants you to determine the minimum number of times she should perform this operation to make array a non decreasing An array x 1 x 2 ldots x k of length k is called non decreasing if x i le x i 1 for all 1 le i k ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    long long ans = 0;\n    int c = 1;\n    for (int i = n - 2; i >= 0; --i) {\n        int x = a[i + 1] / c;\n        c = (a[i] + x - 1) / x;\n        c = max(c, 1);\n        ans += c - 1;\n    }\n    cout << ans << ""\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']",,,"['greedy', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Milena and Admirer.json,https://codeforces.com//blog/entry/120960,SolutionWe will iterate over the array from right to left Then as described in the hint section we will split the current and create almost equal parts For example split into three parts forms the subarray Splitting into four parts forms the subarray Notice that the subarrays must be sorted Because we want to perform as few splits as possible the rightmost endpoint value should be as high as possible as long as it is lower than or equal to the leftmost endpoint of the splitting of if it exists When we iterate over the array it is enough to set the current to the leftmost endpoint of the splitting the smallest current value It will help to calculate the optimal splitting of For the current we want to find the least such that we can split into parts so the rightmost endpoint is less than or equal to More formally we want to hold Afterwards we set to and continue with our algorithm The simplest way to find the desired is to apply the following formula The answer is the sum over all 
https://codeforces.com//contest/1679/problem/C,1399038,C,1679C,1679,C. Rooks Defenders,You have a square chessboard of size n times n Rows are numbered from top to bottom with numbers from 1 to n and columns from left to right with numbers from 1 to n So each cell is denoted with pair of integers x y 1 le x y le n where x is a row number and y is a column number You have to perform q queries of three types Put a new rook in cell x y Remove a rook from cell x y It s guaranteed that the rook was put in this cell before Check if each cell of x 1 y 1 x 2 y 2 of the board is attacked by at least one rook is a set of cells x y such that for each cell two conditions are satisfied x 1 le x le x 2 and y 1 le y le y 2 Recall that cell a b is attacked by a rook placed in cell c d if either a c or b d In particular the cell containing a rook is attacked by this rook ,"['#include<algorithm>\n#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#define lc(x) (x<<1)\n#define rc(x) (x<<1|1)\n#define mid (l+r>>1)\nusing namespace std;\nconst int maxn=500005,maxt=maxn<<2;\nint n,m,T,ans;\nint t[maxn][2],mn[maxt][2];\nvoid update(int l,int r,int now,int p,int v,int tp){\n\tif(l==r){\n\t\tmn[now][tp]+=v;\n\t\treturn ;\n\t}\n\tif(p<=mid)\n\t\tupdate(l,mid,lc(now),p,v,tp);\n\telse update(mid+1,r,rc(now),p,v,tp);\n\tmn[now][tp]=min(mn[lc(now)][tp],mn[rc(now)][tp]);\n}\nint query(int l,int r,int now,int L,int R,int tp){\n\tif(L<=l&&r<=R)\n\t\treturn mn[now][tp];\n\tint res=2;\n\tif(L<=mid)\n\t\tres=min(res,query(l,mid,lc(now),L,R,tp));\n\tif(mid<R)\n\t\tres=min(res,query(mid+1,r,rc(now),L,R,tp));\n\treturn res;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\twhile(m--){\n\t\tint t,x,y,a,b;\n\t\tscanf(""%d%d%d"",&t,&x,&y);\n\t\tif(t==1)\n\t\t\tupdate(1,n,1,x,1,0),update(1,n,1,y,1,1);\n\t\tif(t==2)\n\t\t\tupdate(1,n,1,x,-1,0),update(1,n,1,y,-1,1);\n\t\tif(t==3){\n\t\t\tscanf(""%d%d"",&a,&b);\n\t\t\tif(query(1,n,1,x,a,0)||query(1,n,1,y,b,1))\n\t\t\t\tputs(""Yes"");\n\t\t\telse puts(""No"");\n\t\t}\n\t}\n\treturn 0;\n}\n']",,,"['data structures', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Rooks Defenders.json,https://codeforces.com//blog/entry/102859,Consider some subrectangle Note that each its cell is attacked by some rook if and only if there is at least one rook in each row or in each column Now we will solve the problem using this criterium Let s create a set where we will store indices of rows in which there are rooks Similarly we will store indices of columns in which there are rooks in a set If we have to answer the query of the third type we have to check if there is at least one in the set such that or there is at least one in the set such that If we will store these two sets sorted we can perform this type of query in using binary search Now we re going to answer queries of the first and the second types Let s store for each row and column how many rooks are there in this row or column When we add a new rook we should increment this counters for the corresponding row and column and remove the row from set and the column from set When we remove a rook we should decrement counters for its row and column and if there is no more rooks in the row or in the column we should add their indices to or Time complexity 
https://codeforces.com//contest/1105/problem/E,284898,E,1105E,1105,E. Helping Hiasat ,Hiasat registered a new account in NeckoForces and when his friends found out about that each one of them asked to use his name as Hiasat s handle Luckily for Hiasat he can change his handle in some points in time Also he knows the exact moments friends will visit his profile page Formally you are given a sequence of events of two types 1 Hiasat can change his handle 2 s friend s visits Hiasat s profile The friend s will be happy if each time he visits Hiasat s profile his handle would be s Hiasat asks you to help him find the maximum possible number of happy friends he can get ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch=\'*\'; (ch<\'0\'||ch>\'9\')&&ch!=\'-\'; ch=getchar());\n    if(ch==\'-\') fu=1, ch=getchar();\n    for(v=0; ch>=\'0\'&&ch<=\'9\'; ch=getchar()) v=v*10+ch-\'0\';\n    if(fu) v=-v;\n}\nbitset<100010> a[44];\nint now,n,t,ans,m,ren,c[55][55],p[500010],tp[500010];\nstring s;\nmap<string,int> M;\nbool u[500010];\nint main(){\n//\tfreopen(""t.in"",""r"",stdin);\n//\tfreopen(""t.out"",""w"",stdout);\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tnow=0;\n\tFOR(i,1,n){\n\t\tcin>>tp[i];\n\t\tif (tp[i]==1){\n\t\t\tif (tp[i-1]==1) continue;\n\t\t\t++now;\n\t\t}\n\t\telse{\n\t\t\tcin>>s;\n\t\t\tif (M.find(s)==M.end()) M[s]=++ren;\n\t\t\tt=M[s];\n\t\t\ta[t][now]=1;\n\t\t}\n\t}\n\tFOR(i,1,ren) c[i][i]=1;\n\tFOR(i,1,ren)\n\t\tFOR(j,i+1,ren)\n\t\t\tif (((int)(a[i]&a[j]).count())!=0){\n\t\t\t\tc[i][j]=c[j][i]=0;\n\t\t\t}\n\t\t\telse c[i][j]=c[j][i]=1;\n\tint rp=10000;\n\twhile (rp--){\n\t\tFOR(i,1,ren) p[i]=i;\n\t\trandom_shuffle(p+1,p+ren+1);\n\t\tint s=0;\n\t\tFOR(i,1,ren) u[i]=0;\n\t\tFOR(i,1,ren){\n\t\t\tbool gg=0;\n\t\t\tint x=p[i];\n\t\t\tFOR(j,1,ren)\n\t\t\t\tif (u[j] && !c[j][x]) gg=1;\n\t\t\tif (!gg){\n\t\t\t\t++s;\n\t\t\t\tu[x]=1;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,s);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n\t\n}\n']",,,"['bitmasks', 'brute force', 'dp', 'meet-in-the-middle']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Helping Hiasat .json,https://codeforces.com//blog/entry/64664,Let s change this problem to a graph problem first Let s say that each action of the first type is a border Consider all friends visiting our profile after this border but before the next one Clearly we can satisfy at most one of them Let s change the friends into graph nodes and add edges between every two friends that are between the same borders Then it s enough to solve the maximum independent set of the graph clearly any possible answer must be an independent set and by any independent set we can always build a way to change our handle The maximum independent set can be solved in where is the number of friends But since is up to it is too slow However we can apply the meet in the middle approach and then it becomes or The simplest way is to do the following notice that the independent set is same as clique if all edges are inverted so we will solve a max clique problem Let s write a bruteforce which returns size of the largest clique which forms a subset of mask The answer will be just to run solve of full mask How to write solve Let s find a of mask let it be vertex There are two cases The vertex is not in an answer Kick it and run a recursive call The vertex is in answer Hence all other vertices of answers are neighbors of Run the recursive call from where denotes the mask of neighbors Clearly it works in However if we add memorization don t calculate for same mask twice it is magically becomes Why Consider the recursion there are at most recursion calls before we arrive into the state where there are no set bits of the first half This part will take at most then And clearly there are at most states with no set bits in the first half 
https://codeforces.com//contest/420/problem/A,8698,A,420A,420,A. Start Up,Recently a start up by two students of a state university of city F gained incredible popularity Now it s time to start a new company But what do we call it The market analysts came up with a very smart plan the name of the company should be identical to its reflection in a mirror In other words if we write out the name of the company on a piece of paper in a line horizontally from left to right with large English letters then put this piece of paper in front of the mirror then the reflection of the name in the mirror should perfectly match the line written on the piece of paper There are many suggestions for the company name so coming up to the mirror with a piece of paper for each name wouldn t be sensible The founders of the company decided to automatize this process They asked you to write a program that can given a word determine whether the word is a mirror word or not ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define LLD long long\nusing namespace std;\n\nint ok, n;\nchar s[100005], v[300];\n\nint main(){\n\tscanf(""%s"", s);\n\tv[\'A\'] = v[\'H\'] = v[\'I\'] = v[\'M\'] = v[\'O\'] = v[\'T\'] = v[\'U\'] =\n\tv[\'V\'] = v[\'W\'] = v[\'X\'] = v[\'Y\'] = 1;\n\t\n\tn = strlen(s);\n\tok = 1;\n\tFOR(i,0,n){\n\t\tif (!v[s[i]]) ok = 0;\n\t\tif (s[i] != s[n - i - 1]) ok = 0;\n\t}\n\t\n\tputs(ok ? ""YES"" : ""NO"");\n\treturn 0;\n}\n']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Start Up.json,https://codeforces.com//blog/entry/11871,One should firstly recognize that the required string should be palindrome and each character of the string should be symmetric All the symmetric characters are 
https://codeforces.com//contest/1694/problem/A,1430894,A,1694A,1694,A. Creep,Define the score of some binary string T as the absolute difference between the number of zeroes and ones in it for example T contains 4 zeroes and 2 ones so the score of T is 4 2 2 Define the creepiness of some binary string S as the maximum score among all of its prefixes for example the creepiness of S is equal to 2 because the score of the prefix S 1 ldots 4 is 2 and the rest of the prefixes have a score of 2 or less Given two integers a and b construct a binary string consisting of a zeroes and b ones with the minimum possible creepiness ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename Fun>\nstruct y_combinator {\n    const Fun fun;\n\n    explicit y_combinator(const Fun&& fun) : fun(std::forward<const Fun>(fun)) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) const {\n        return fun(std::ref(*this), std::forward<Args>(args)...);\n    }\n};\n\nvoid solve() {\n    int a, b;\n    cin >> a >> b;\n    while (a && b) {\n        cout << 10;\n        a--, b--;\n    }\n    while (a) {\n        cout << 0;\n        a--;\n    }\n    while (b) {\n        cout << 1;\n        b--;\n    }\n    cout << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n""]",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Creep.json,https://codeforces.com//blog/entry/103952,Define the minimum possible creepiness of the string as We want to show that is equal to Creepiness of is equal to and creepiness of is equal to so The way to make a string with creepiness equal to while holds add to the end of the string After that add the remaining character to the end of the string Now we know So complexity 
https://codeforces.com//contest/1332/problem/E,578665,E,1332E,1332,E. Height All the Same,Alice has got addicted to a game called Sirtet recently In Sirtet player is given an n times m grid Initially a i j cubes are stacked up in the cell i j Two cells are called adjacent if they share a side Player can perform the following operations stack up one cube in two cells stack up two cubes in one cell Cubes mentioned above are identical in height Here is an illustration of the game States on the right are obtained by performing one of the above operations on the state on the left and grey cubes are added due to the operation Player s goal is to i e so that each cell has the same number of cubes in it using above operations Alice however has found out that on some starting grids she may never reach the goal no matter what strategy she uses Thus she is wondering the number of initial grids such that L le a i j le R for all 1 le i le n 1 le j le m player can reach the goal using above operations Please help Alice with it Notice that the answer might be large please output the desired value modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int djq = 998244353;\n\nint n, m, L, R, c0, c1;\n\nstruct matrix\n{\n\tint n, m, a[2][2];\n\t\n\tmatrix() {}\n\tmatrix(int _n, int _m) :\n\t\tn(_n), m(_m) {memset(a, 0, sizeof(a));}\n\t\n\tfriend inline matrix operator * (matrix a, matrix b)\n\t{\n\t\tmatrix res = matrix(a.n, b.m);\n\t\tfor (int i = 0; i < a.n; i++) for (int j = 0; j < b.m; j++)\n\t\t\tfor (int k = 0; k < a.m; k++)\n\t\t\t\tres.a[i][j] = (1ll * a.a[i][k] * b.a[k][j] + res.a[i][j]) % djq;\n\t\treturn res;\n\t}\n\t\n\tfriend inline matrix operator ^ (matrix a, ll b)\n\t{\n\t\tmatrix res = matrix(a.n, a.m);\n\t\tfor (int i = 0; i < res.n; i++) res.a[i][i] = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1) res = res * a;\n\t\t\ta = a * a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n} F, A;\n\nint main()\n{\n\tstd::cin >> n >> m >> L >> R;\n\tc0 = (R >> 1) - (L - 1 >> 1); c1 = (R + 1 >> 1) - (L >> 1);\n\tA = matrix(2, 2); F = matrix(2, 1);\n\tA.a[0][0] = A.a[1][1] = c0; A.a[1][0] = A.a[0][1] = c1;\n\tF.a[0][0] = 1;\n\tF = (A ^ 1ll * n * m) * F;\n\tif (n * m & 1) std::cout << (F.a[0][0] + F.a[1][0]) % djq << std::endl;\n\telse std::cout << F.a[0][0] << std::endl;\n\treturn 0;\n}']",,,"['combinatorics', 'constructive algorithms', 'math', 'matrices']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Height All the Same.json,https://codeforces.com//blog/entry/75432,The actual values in the cells don t matter only parity matters Using the second operation one can make all the values of same parity equal by applying it to the lowest value until done That observation helps us to get rid of the second operation let us only have the first one Player is able to change parity of any pair of cells at the same time For any given cell and cell there exists a path from to namely such that and Perform operation for adjacent cells and for all If is odd player can always reach the goal no matter what the initial state is There are two cases there is an even number of even cells or there is an even number of odd cells Whichever of these holds we can change all cells of that parity to the opposite one with the aforementioned operation making all cells the same parity If is even and is even player can reach the goal Similar to the proof of Observation 3 Proof is omitted If is even and is odd player can never reach the goal no matter what strategies player takes Note that applying the operation never changes the parity of the number of cells of each parity i e if we start with an odd number of odd cells and an odd number of even cells they will both be odd until the end Thus there is no way to make zero cells of some parity How does that help us to calculate the answer The first case is odd is trivial the answer is all grids Let s declare this as value The second case is even is harder Me and pikmike have different formulas to obtain it but the answer is the same WLOG let s move the range of values from to let Let s find out the number of ways to choose the grid such that the number of even cells is even and Suppose that there are even numbers in odds Therefore for any given the number of ways to have exactly even numbers should be Thus the total answer should be which should remind you of the Newton expansion Note that and Adding those two formulas will get us exactly the formula we were looking for but doubled Thus the answer is that divided by There is a general solution to this kind of problems Let s try to pair up each valid grid with exactly one invalid grid Valid in our problem is such a grid that the number of even cells is even If such a matching exists then the answer is exactly half of all grids Let s come up with some way to pair them up For example this works but leaves us with two cases to handle Let be odd For each grid let s replace with You can see that the parity changed thus the number of even cells also changed its parity So if the grid was invalid it became valid and vice versa For an even it s slightly trickier but actually one can show that almost all grids pair up with each other and only a single grid remains unpaired So we can add a fake grid and claim that the answer is The algorithm is the following Find the first position such that the value on it is not equal to Replace it with You can easily see that only grid that consists of all numbers has no pair 
https://codeforces.com//contest/1384/problem/B1,681334,B1,1384B1,1384,B1. Koa and the Beach  Easy Version ,Koa the Koala is at the beach The beach consists from left to right of a shore n 1 meters of sea and an island at n 1 meters from the shore She measured the depth of the sea at 1 2 dots n meters from the shore and saved them in array d d i denotes the depth of the sea at i meters from the shore for 1 le i le n Like any beach this one has tide the intensity of the tide is measured by parameter k and affects all depths in the following way For a total of k seconds each second tide all depths by 1 Then for a total of k seconds each second tide all depths by 1 This process repeats again and again ie depths increase for k seconds then decrease for k seconds and so on Formally let s define 0 indexed array p 0 1 2 ldots k 2 k 1 k k 1 k 2 ldots 2 1 of length 2k At time t 0 le t depth at i meters from the shore equals d i p t bmod 2k t bmod 2k denotes the remainder of the division of t by 2k Note that the changes occur after each second see the notes for better understanding At time t 0 Koa is standing at the shore and wants to get to the island Suppose that at some time t 0 le t she is at x 0 le x le n meters from the shore In one second Koa can swim 1 meter further from the shore x changes to x 1 or not swim at all x stays the same in both cases t changes to t 1 As Koa is a bad swimmer the depth of the sea at the point where she is can t exceed l at integer points of time or she will drown More formally if Koa is at x 1 le x le n meters from the shore at the moment t for some integer t ge 0 the depth of the sea at this point d x p t bmod 2k can t exceed l In other words d x p t bmod 2k le l must hold always Once Koa reaches the island at n 1 meters from the shore she stops and can rest Note that ie she can t drown while swimming Note that and they are solid ground and she won t drown there Koa wants to know whether she can go from the shore to the island Help her ,"['#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n#define m_k make_pair\nusing namespace std;\nconst int N=3*1e5+100;\nint t,n,k,l,a[N],b[N],st;\nsigned main()\n{\n\tscanf(""%d"",&t);\n\twhile (t--)\n\t{\n\t\tscanf(""%d%d%d"",&n,&k,&l);\n\t\tfor (int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n\t\tfor (int i=1;i<=n;i++) b[i]=min(k,l-a[i]);\n\t\tbool bl=1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (b[i]<0)\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bl)\n\t\t{\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tst=b[1];\n\t\tint add;\n\t\tif (st==0) add=1;\n\t\telse add=-1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (st>b[i])\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i==n) break;\n\t\t\tif (b[i]==k) st=b[i+1]+1,add=-1;\n\t\t\telse if (add==-1 && st-1>b[i+1]) st=b[i+1]+1;\n\t\t\tst+=add;\n\t\t\tif (st==0) add=1;\n\t\t\tif (st==k) add=-1;\n\t\t}\n\t\tif (bl) printf(""Yes\\n"");\n\t\telse printf(""No\\n"");\n\t}\n}\n']",,,"['brute force', 'dp', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B1. Koa and the Beach  Easy Version .json,https://codeforces.com//blog/entry/80562,For this version you can just simulate each possible action of Koa Let a state where is the current position of Koa ie is the shore from to is the th meter of sea and is the island is the current increment of the tide and is a boolean that is true if the tide is decreasing and false otherwise You can see each state like a node and each action ie wait or swim like an edge so you can just do a dfs to see if the island is reachable from the shore The number of nodes and edges is Time complexity per testcase 
https://codeforces.com//contest/2022/problem/A,2947274,A,2022A,2022,A. Bus to Pénjamo,Ya vamos llegando a P eeenjamoo There are n families travelling to P njamo to witness Mexico s largest ever walking a chicken on a leash marathon The i th family has a i family members All families will travel using a single bus consisting of r rows with 2 seats each A person is considered if Another family member is seated in the same row as them or They are sitting alone in their row with an empty seat next to them Determine the maximum number of happy people in an optimal seating arrangement Note that must be seated in the bus It is guaranteed that all family members will fit on the bus Formally it is guaranteed that displaystyle sum i 1 n a i le 2r ,"['#line 1 ""library/Template/template.hpp""#include <bits/stdc++.h>using namespace std;\xa0#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin())\xa0using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff;\xa0template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));}\xa0template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << ""P("" << p.first << "", "" << p.second << "")"";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << ""{"";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? """" : "", "");    }    os << ""}"";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << ""{"";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << ""("" << itr->first << "", "" << itr->second << "")"";        itr++;        if (itr != map_var.end())            os << "", "";        itr--;    }    os << ""}"";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << ""{"";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << "", "";        itr--;    }    os << ""}"";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << \'\\n\';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != \',\' && a[i] != \'\\0\'; i++)        cerr << a[i];    cerr << "":"" << b << "" "";    _show(i + 1, a, c...);}#line 2 ""library/Utility/fastio.hpp""#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf\xa0uint32_t pil = 0, pir = 0, por = 0;\xa0struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | \'0\';                n /= 10;            }        }    }} constexpr pre;\xa0inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = \'\\n\';}\xa0inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;}\xa0void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));}\xa0void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));}\xa0template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);}\xa0template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < \'-\');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == \'-\') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while (\'0\' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }}\xa0void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);}\xa0template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);}\xa0template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);}\xa0void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);}\xa0void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);}\xa0template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = \'-\', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | \'0\';        obuf[por + 1] = (x - q * 10) | \'0\';        por += 2;    } else        obuf[por++] = x | \'0\';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;}\xa0template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);}\xa0void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);}\xa0template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(\' \');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(\' \');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(\' \');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(\' \');        wt(val[i]);    }}\xa0void print() {    wt(\'\\n\');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(\' \');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio\xa0using fastio::flush;using fastio::print;using fastio::read;\xa0inline void first(bool i = true) {    print(i ? ""first"" : ""second"");}inline void Alice(bool i = true) {    print(i ? ""Alice"" : ""Bob"");}inline void Takahashi(bool i = true) {    print(i ? ""Takahashi"" : ""Aoki"");}inline void yes(bool i = true) {    print(i ? ""yes"" : ""no"");}inline void Yes(bool i = true) {    print(i ? ""Yes"" : ""No"");}inline void No() {    print(""No"");}inline void YES(bool i = true) {    print(i ? ""YES"" : ""NO"");}inline void NO() {    print(""NO"");}inline void Yay(bool i = true) {    print(i ? ""Yay!"" : "":("");}inline void Possible(bool i = true) {    print(i ? ""Possible"" : ""Impossible"");}inline void POSSIBLE(bool i = true) {    print(i ? ""POSSIBLE"" : ""IMPOSSIBLE"");}\xa0/** * @brief Fast IO */#line 3 ""sol.cpp""\xa0void solve(int _rot) {    // write(""Case #""+to_string(_rot)+"": "");    int n, R;    read(n, R);    vector<int> a(n);    read(a);\xa0    int ret = 0, emp = R, odd = 0;    rep(i, 0, n) {        ret += (a[i] / 2) * 2;        if (a[i] & 1)            odd++;        emp -= a[i] / 2;    }    if (odd <= emp)        ret += odd;    else        ret += emp * 2 - odd;    print(ret);}\xa0int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}']",,,"['constructive algorithms', 'greedy', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Bus to Pénjamo.json,https://codeforces.com//blog/entry/135095,Step 1The key to maximizing happiness is to seat family members together as much as possible If two members of the same family sit in the same row both will be happy and we only use two seats However if they are seated separately only one person is happy but two seats are still used Therefore we prioritize seating family pairs together first 
https://codeforces.com//contest/1801/problem/C,1817546,C,1801C,1801,C. Music Festival,The boy Vitya loves to listen to music very much He knows that n albums are due to be released this Friday i th of which contains k i tracks Of course Vitya has already listened to all the tracks and knows that in the i th album the coolness of the j th track is equal to a i j Vitya has a friend Masha whom he really wants to invite to the festival where his favorite bands perform However in order for a friend to agree she must first evaluate the released novelties Vitya knows that if Masha listens to a track that was cooler than all the previous ones she will get 1 unit of impression Unfortunately albums can only be listened to in their entirety without changing the songs in them in places Help Vitya find such an order of albums so that Masha s impression turns out to be as much as possible and she definitely went to the festival with him ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<tuple<int,int,int>> es;\n\trep(_,n){\n\t\tint k;cin>>k;\n\t\tvi a;\n\t\trep(j,k){\n\t\t\tint v;cin>>v;\n\t\t\tif(a.empty()||a.back()<v)a.pb(v);\n\t\t}\n\t\trep(i,si(a)){\n\t\t\tes.eb(a[i],a.back()+1,si(a)-i);\n\t\t}\n\t}\n\tvi vs;\n\tfor(auto [u,v,w]:es){\n\t\tvs.pb(u);\n\t\tvs.pb(v);\n\t}\n\tmkuni(vs);\n\tint s=si(vs);\n\tvi dp(s,-inf);\n\tdp[0]=0;\n\tvvc<pi> g(s);\n\tfor(auto [u,v,w]:es){\n\t\tu=lwb(vs,u);\n\t\tv=lwb(vs,v);\n\t\tg[u].eb(v,w);\n\t}\n\trep(i,s-1){\n\t\tchmax(dp[i+1],dp[i]);\n\t\tfor(auto [j,c]:g[i])\n\t\t\tchmax(dp[j],dp[i]+c);\n\t}\n\tprint(dp[s-1]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['binary search', 'data structures', 'dp', 'greedy', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Music Festival.json,https://codeforces.com//blog/entry/113857,Solution Let s introduce the concept of a compressed album for an album which is obtained from the original one by removing all elements except those that are the first maxima on their corresponding prefixes For example For the album the album will be compressed Now we note that the solution of the original problem is reduced to solving the same problem but on compressed albums Indeed the answer to them will not be different because if some element increased the impression on ordinary albums then it will increase if you compress albums and vice versa Next it will be assumed that all albums have been compressed beforehand Let s introduce the maximum impression that can be obtained if there were no albums such that they have elements larger than Then is equal to or you can add another element or two if is the maximum element for some album Then for all compressed albums it can be recalculated through the value of at the point before the first element of the album or through Thus for recalculation it is enough to know for each which albums ended in this index as well as for each album its first element Solution for Let s now solve the complete problem For each value of let s remember the indexes of albums that contain an element equal to We go in order of increasing we maintain for each album the value of the maximum impression that can be obtained if there were no elements of large and Masha listened to the last album Suppose for the next there is an album that there is a song with the coolness of in it Then should be taken as the maximum of and the values for all such that the maximum element in the th album is less than the maximum element of th since she could listen to this track either next in this album or after listening to some other album completely Note that you can store the value of maximum for all albums for which the maximum value in them is less than and recalculate it when moving to storing those albums that have ended then you will get a solution for 
https://codeforces.com//contest/1838/problem/C,1951236,C,1838C,1838,C. No Prime Differences,You are given integers n and m Fill an n by m grid with the integers 1 through n cdot m in such a way that for any two adjacent cells in the grid the absolute difference of the values in those cells is not a prime number Two cells in the grid are considered adjacent if they share a side It can be shown that under the given constraints there is always a solution ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t; cin>>t;\n    for (int ti = 0; ti < t; ++ti) {\n        int n,m; cin>>n>>m;\n        int s = n*m;\n        int r = m+1;\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                cout << r+y << (y == m-1 ? ""\\n"" : "" "");\n            }\n            r += 2*m;\n            if (r > s) {\n                r = 1;\n            }\n        }\n    }\n}\n']",,,"['constructive algorithms', 'math', 'number theory']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. No Prime Differences.json,https://codeforces.com//blog/entry/116995,Note that if we fill in the numbers in order from the top left to the bottom right for example for the only adjacent differences are and So if is not prime this solves the problem We ll now rearrange the rows so that it works regardless of whether is prime Put the first rows in rows and the last rows in rows In the example above this would give Note that because we are just rearranging the rows from the above solution all of the horizontal differences are and the vertical differences are multiples of Therefore as long as none of the vertical differences equal itself they must be composite Because no row is next to either of its original neighbors in this ordering and therefore all vertical differences are greater than and thus composite So we can use this final grid regardless of whether is prime Complexity 
https://codeforces.com//contest/2003/problem/E1,2836630,E1,2003E1,2003,E1. Turtle and Inversions  Easy Version ,Turtle gives you m intervals l 1 r 1 l 2 r 2 ldots l m r m He thinks that a permutation p is interesting if there exists an integer k i for every interval l i le k i r i and if he lets a i max limits j l i k i p j b i min limits j k i 1 r i p j for every integer i from 1 to m the following condition holds max limits i 1 m a i min limits i 1 m b iTurtle wants you to calculate the maximum number of inversions of all interesting permutations of length n or tell him if there is no interesting permutation An inversion of a permutation p is a pair of integers i j 1 le i j le n such that p i p j ,"['#include <bits/stdc++.h>\xa0#define ranges std::ranges#define views std::views\xa0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\xa0using pii = std::pair<int, int>;using a3 = std::array<int, 3>;using a4 = std::array<int, 4>;\xa0const int N = 1e6;const int MAXN = 1e6 + 10;const int inf = 1e9;// const int mod = 1e9 + 7;const int mod = 998244353;\xa0template<typename T>struct Fenwick {    int n;    std::vector<T> a;\xa0    Fenwick(int n_ = 0) {        init(n_);    }\xa0    void init(int n_) {        n = n_;        a.assign(n + 5, T{});    }\xa0    void add(int x, const T& v) {        for (int i = x; i <= n; i += i & -i) {            a[i] = a[i] + v;        }    }\xa0    T sum(int x) {        T ans{};        for (int i = x; i > 0; i -= i & -i) {            ans = ans + a[i];        }        return ans;    }\xa0    T rangeSum(int l, int r) {        return sum(r) - sum(l);    }\xa0    int select(const T& k) {        int x = 0;        T cur{};        for (int i = 1 << std::__lg(n); i; i /= 2) {            if (x + i <= n && cur + a[x + i] <= k) {                x += i;                cur = cur + a[x];            }        }        return x;    }};\xa0void solve() {    int n, m;std::cin >> n >> m;    std::vector<pii> info(m);    for (auto& [l, r] : info)std::cin >> l >> r;    std::vector<int> big, small;//, other;    ranges::sort(info);    int cur = 1;    int leg = 0;    for (auto& [l, r] : info) {        while (cur < l) {            // other.push_back(cur);            if (leg >= m - leg) {                small.push_back(cur);            }            else {                big.push_back(cur);            }            cur++;        }        big.push_back(r);        small.push_back(l);        if (leg >= m - leg) {            for (int i = l + 1;i <= r - 1;++i) {                small.push_back(i);            }        }        else {            for (int i = l + 1;i <= r - 1;++i) {                big.push_back(i);            }        }        cur = r + 1;        leg++;    }    while (cur <= n) {        // other.push_back(cur);        if (leg >= m - leg) {            small.push_back(cur);        }        else {            big.push_back(cur);        }        cur++;    }    std::vector<int> ans(n + 1);    int max = n;    // ranges::sort(other);    ranges::sort(big);    ranges::sort(small);    // for (auto y : other)ans[y] = max, max--;    for (auto y : big)ans[y] = max, max--;    for (auto y : small)ans[y] = max, max--;    Fenwick<int> fw(n);    i64 ot = 0;    for (int i = 1;i <= n;++i) {        ot += i - 1 - fw.sum(ans[i]);        fw.add(ans[i], 1);    }    std::cout << ot << \'\\n\';    // for (int i = 1;i <= n;++i)    //     std::cout << ans[i] << "" "";}\xa0signed main() {    std::ios::sync_with_stdio(false);    std::cin.tie(0), std::cout.tie(0);    int t;std::cin >> t;    while (t--) {        solve();    }    return 0;}']",,,"['brute force', 'divide and conquer', 'dp', 'greedy', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Turtle and Inversions  Easy Version .json,https://codeforces.com/blog/entry/132953,Divide all numbers into two types small numbers and large numbers such that any small number is less than any large number In this way a permutation can be transformed into a sequence A permutation is interesting if and only if there exists a way to divide all numbers into two types such that for every given interval all s appear before all s and there is at least one and one in the interval Such a sequence is called interesting If an interesting sequence is fixed we can greedily arrange all s in descending order and all s in descending order Let the number of s be and the number of s be Let be the number of index pairs where the th number is and the th number is such pairs are called pairs Then the maximum number of inversions is In this version the intervals are non overlapping so DP can be applied directly Let represent the maximum number of pairs when considering all numbers from to where there are s For transitions if is the left endpoint of an interval and the right endpoint of this interval is we can enumerate the number of s as and the number of s as for the transition Otherwise we consider whether is or The answer is Time complexity per test case 
https://codeforces.com//contest/1555/problem/E,1062144,E,1555E,1555,E. Boring Segments,You are given n segments on a number line numbered from 1 to n The i th segments covers all integer points from l i to r i and has a value w i You are asked to select a subset of these segments possibly all of them Once the subset is selected it s possible to travel between two integer points if there exists a selected segment that covers both of them A subset is good if it s possible to reach point m starting from point 1 in arbitrary number of moves The cost of the subset is the difference between the maximum and the minimum values of segments in it Find the minimum cost of a good subset In every test there exists at least one good subset ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\ntemplate <typename T>\nstruct lazy_segment_tree{\n\tint N;\n\tvector<T> ST;\n\tvector<T> lazy;\n\tlazy_segment_tree(int n){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, -INF);\n\t\tlazy = vector<T>(N * 2 - 1, -1);\n\t}\n\tvoid eval(int i){\n\t\tif (lazy[i] != -1){\n\t\t\tif (i < N - 1){\n\t\t\t\tlazy[i * 2 + 1] = lazy[i];\n\t\t\t\tlazy[i * 2 + 2] = lazy[i];\n\t\t\t}\n\t\t\tST[i] = lazy[i];\n\t\t\tlazy[i] = -1;\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x, int i, int l, int r){\n\t\teval(i);\n\t\tif (R <= l || r <= L){\n\t\t\treturn;\n\t\t} else if (L <= l && r <= R){\n\t\t\tlazy[i] = x;\n\t\t\teval(i);\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\trange_update(L, R, x, i * 2 + 1, l, m);\n\t\t\trange_update(L, R, x, i * 2 + 2, m, r);\n\t\t\tST[i] = min(ST[i * 2 + 1], ST[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x){\n\t\treturn range_update(L, R, x, 0, 0, N);\n\t}\n\tT range_min(int L, int R, int i, int l, int r){\n\t\teval(i);\n\t\tif (R <= l || r <= L){\n\t\t\treturn INF;\n\t\t} else if (L <= l && r <= R){\n\t\t\treturn ST[i];\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn min(range_min(L, R, i * 2 + 1, l, m), range_min(L, R, i * 2 + 2, m, r));\n\t\t}\n\t}\n\tT range_min(int L, int R){\n\t\treturn range_min(L, R, 0, 0, N);\n\t}\n};\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  vector<tuple<int, int, int>> S(n);\n  for (int i = 0; i < n; i++){\n    int l, r, w;\n    cin >> l >> r >> w;\n    S[i] = make_tuple(w, l, r);\n  }\n  sort(S.begin(), S.end());\n  lazy_segment_tree<int> ST(m);\n  int ans = INF;\n  for (int i = 0; i < n; i++){\n    int w = get<0>(S[i]);\n    int l = get<1>(S[i]);\n    int r = get<2>(S[i]);\n    ST.range_update(l, r, w);\n    ans = min(ans, w - ST.range_min(1, m));\n  }\n  cout << ans << endl;\n}']",,,"['data structures', 'sortings', 'trees', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Boring Segments.json,https://codeforces.com//blog/entry/93389,Take a look at the condition for a good subset The major implication it makes is that every point even non integer of the segment should be covered by at least one segment If some point isn t then there is no way to jump across the gap it produces At the same time this condition is enough to have a path since for every half integer point and so on there exists a segment that covers it So you can take that segment to go from to then from to and so on Thus we are asked to select a subset of segments that covers the entire segment in its union The main prerequisite to the following solution is knowing the way to maintain the union of segments For now I can tell you that there is a data structure that allows you to add a segment remove a segment and query the length of the current union Let s continue with making some observations on the cost function If you fix the minimum and the maximum value you are free to select all segments that have their value in between That allows us to transition from selecting a subset of segment to an interval if you sort the segments by their weight If you fix only minimum then the required maximum should be as small as possible However if some value suffices as a maximum then any value greater than it also suffices since it only adds extra segments to the subset This makes the function on the maximum monotonous So the binary search applicable You could iterate over the minimum and binary search the maximum However it s not too clear how to make a check function You would need to find a union of some interval of segments quickly I don t really know a way to do that so let s try something different Instead let s forget about binary search and try to reach a two pointers solution Let be the smallest possible maximum given the fixed minimum is We want to be greater than or equal than for two pointers to be applicable That condition indeed holds Imagine if is smaller than So there exists some optimal subset for Add all segments with weight to that subset That brings the minimum to However it doesn t change the maximum so is at least equal to what contradicts the assumption Finally the solution comes up to the following Iterate over the minimum value while maintaining When going from to keep increasing the value of until the union of the segments is exactly Going from to and increasing the value of is actually removing some segments and adding some segments to the data structure The data structure that helps us with that is a segment tree The th leaf of the tree holds the number of segments that cover the interval Add remove segment makes it add subtract on a range The union is full if the there are no intervals that are covered by zero segments Thus let s store the minimum of the subtree in every intermediate node If the minimum on the tree is above zero then the current subset is good Instead of applying two pointers on the values of the segments let s apply them on the sorted segments themselves That makes moving the pointer exactly one update to the segtree Overall complexity 
https://codeforces.com//contest/1137/problem/E,309121,E,1137E,1137,E. Train Car Selection,Vasya likes to travel by train but doesn t like when the car he travels in is located in the tail of the train Vasya gets on the train at the station The train consists of n cars indexed from 1 to n counting from the locomotive head of the train Three types of events occur while the train is moving Some number of cars are added to the head of the train Some number of cars are added to the tail of the train Vasya recalculates the values of the convenience of the cars read more about it below At each moment of time we will index the cars from the head of the train starting from 1 Note that when adding new cars to the head of the train the indexing of the old ones may shift To choose which car to go in Vasya will use the value A i for each car where i is a car index which is calculated as follows At the beginning of the trip A i 0 as well as for the new cars at the time of their addition During the next recalculation Vasya chooses some integers b and s and adds to all A i value b i 1 cdot s Vasya hasn t decided yet where he will get on the train and where will get off the train so after each event of one of the three types he wants to know the least index of the car such that its value A i is minimal Since there is a lot of cars Vasya asked you to write a program that answers his question ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n  long long x, y;\n\n  point(long long x = 0, long long y = 0): x(x), y(y) {\n  }\n\n  point operator - (const point &b) const {\n    return point(x - b.x, y - b.y);\n  }\n};\n\nbool check(point p, point q, point r) {\n  point pp = p - q, rr = r - q;\n  return (long double) pp.x * rr.y >= (long double) pp.y * rr.x;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  int m;\n  cin >> n >> m;\n  long long add = 0, slope = 0;\n  vector<point> hull(1, point(0, 0));\n  while (m--) {\n    int type;\n    cin >> type;\n    if (type == 1) {\n      int cnt;\n      cin >> cnt;\n      hull.clear();\n      hull.push_back(point(0, 0));\n      n += cnt;\n      add = slope = 0;\n    } else if (type == 2) {\n      int cnt;\n      cin >> cnt;\n      while (hull.size() > 1 && check(point(n, -(n * slope + add)), hull[hull.size() - 2], hull[hull.size() - 1])) {\n        hull.pop_back();\n      }\n      hull.push_back(point(n, -(n * slope + add)));\n      n += cnt;\n    } else {\n      int b, s;\n      cin >> b >> s;\n      add += b;\n      slope += s;\n    }\n    while (hull.size() > 1 && slope * hull.back().x + hull.back().y >= slope * hull[hull.size() - 2].x + hull[hull.size() - 2].y) {\n      hull.pop_back();\n    }\n    cout << hull.back().x + 1 << "" "" << slope * hull.back().x + hull.back().y + add << ""\\n"";\n  }\n  return 0;\n}\n']",,,"['data structures', 'greedy']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Train Car Selection.json,https://codeforces.com/blog/entry/65825,There are many approaches to this problem many of them having time but we will describe a purely linear solution First notice that for every group of cars added together we need only to care about the first car in this group the remaining ones will never be the answer Second notice that there are some cars appended to the head of the train then all previous cars will never be answer again so we can simply replace them with cars with So now we only need to care about operations of adding cars to the tail and about adding the progression Suppose cars located at positions and have comfort Then observe the lower left convex hull of points One can see that the points not lying on this hull will never be an answer Also note that we can handle all progressions implicitly suppose the progressions are described with Then let s simply store current sums of and Then the operation of adding progression can be done by simply adding to those sums also we don t have to track the moment the cars are added since we can simply subtract from based on sums at the moment of So when we add cars to the end we simply need to add point to the end and possibly drop some points from the end of the current convex hull And when we add new progression we may also need to drop some elements from the hull but since it s the convex hull the line coefficients between neighboring points are monotonous so we need to drop only some points in the end of the hull 
https://codeforces.com//contest/332/problem/E,3363,E,332E,332,E. Binary Key,Let s assume that and are strings of positive length called the and the correspondingly string only consists of characters 0 and 1 Let s take a look at a simple algorithm that extracts from the given container i 0 j 0 s while i is less than the length of the string p if q j 1 then add to the right of string s character p i increase variables i j by one if the value of the variable j equals the length of the string q then j 0 In the given pseudocode are integer variables is a string is an assignment operator is a comparison operation is the operation of obtaining the string character with the preset index is an empty string We suppose that in all strings the characters are numbered starting from zero We understand that implementing such algorithm is quite easy so your task is going to be slightly different You need to construct the lexicographically minimum key of length such that when it is used the algorithm given above extracts message from container otherwise find out that such key doesn t exist ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <sstream>\n#include <stack>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define pb push_back\n#define sz(x) ((x).size())\n#define mp make_pair\n#define x first\n#define y second\n\nconst int N = 1000010;\nconst int M = 2000010;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-6;\n\nint k;\n\nchar p[N], s[N];\nchar str[2010][1010];\n\nchar C[2010][1010];\n\nint work(int x, char C[], int len){\n    for(int i = x; i >= 0; i--){\n        if(strlen(str[i]) != len) continue;\n        bool f = 1;\n        for(int j = 0; j < len; j++)\n            if(str[i][j] != C[j]) f = 0;\n        if(f) return i;\n    }\n    return -1;\n}\n\nint main(){\n    gets(p);\n    gets(s);\n    scanf(""%d"", &k);\n    int len = strlen(p);\n    int l = strlen(s);\n    int r = 0, c = 0;\n    for(int i = 0; i < len; i++){\n        str[r++][c] = p[i];\n        if(r == k) c++, r = 0;\n        if(c > l + 2) return puts(""0""), 0;\n    }\n    string ans;\n    for(int i = 0; i < k; i++)\n        ans += \'1\';\n    bool ret = 0;\n    for(int z = 1; z <= l; z++){\n        int x = len / k;\n        if(x * z > l) break;\n        if(l - x * z > z) continue;\n        memset(C, 0, sizeof(C));\n        for(int i = 0; i < l; i++){\n            C[i % z][i / z] = s[i];\n        }\n        bool f = 1;\n        string tans = """";\n        for(int i = 0; i < k; i++)\n            tans += \'0\';\n        for(int i = k - 1, j = z - 1; j >= 0; j--){\n            int t = work(i, C[j], strlen(C[j]));\n            if(t == -1) {\n                f = 0;\n                break;\n            }\n            i = t - 1;\n            tans[t] = \'1\';\n        }\n        if(!f) continue;\n        ans = min(ans, tans);\n        ret = 1;\n    }\n    if(ret) cout << ans << endl;\n    else cout << 0 << endl;\n    return 0;\n}']",,,"['dp', 'greedy', 'implementation']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Binary Key.json,https://codeforces.com/blog/entry/8447,Let s iterate through the number of ones in the key One can note that can t be large than as the keys containing more than ones can t be lexicographically minimal Let s consider the solution of this problem with the fixed Any complete pass on the key corresponds to the extracting of scanned symbols of the container i e container is divided into blocks of length and the message is divided into blocks of length last blocks may be shorter We ll number the characters in each block of the message from 0 to We ll call suffix suffix of th block of the message that starts from a position in this block Let s solve the problem with dynamic programming is true if there exists a key the first characters of which are zeros and which corresponds to the extracting from container the string that is the result of concatenation of all suffixes of the message The transitions are based on the filling of i th position of the key with zero or one we need to choose the minimum acceptable character To restore the key you can keep chosen characters for each subtask Asymptotics of the solution Code 
https://codeforces.com//contest/1914/problem/C,2388661,C,1914C,1914,C. Quests,Monocarp is playing a computer game In order to level up his character he can complete quests There are n quests in the game numbered from 1 to n Monocarp can complete quests according to the following rules the 1 st quest is always available for completion the i th quest is available for completion if all quests j i have been completed at least once Note that Monocarp can complete the same quest multiple times For each completion the character gets some amount of experience points for the first completion of the i th quest he gets a i experience points for each subsequent completion of the i th quest he gets b i experience points Monocarp is a very busy person so he has free time to complete no more than k quests Your task is to calculate the maximum possible total experience Monocarp can get if he can complete no more than k quests ,"['//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=1e6+5,mod=1e9+7;\nll n,k,a[N],b[N];\nvoid prep(){\n}\nvoid solve()\n{\n    cin>>n>>k;\n    rep(i,1,n) cin>>a[i];\n    rep(i,1,n) cin>>b[i];\n    ll tmp=0,res=0,sum=0;\n    rep(i,1,n){\n        sum+=a[i];\n        tmp=max(tmp,b[i]);\n        k--;\n        if (k>=0) res=max(res,tmp*k+sum);\n    }\n    cout<<res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']",,,"['greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Quests.json,https://codeforces.com//blog/entry/123530,Let s iterate over the number of quests that have been completed at least once denote it as It remains to complete quests more and we are allowed to complete any of the first quests again It is obvious that we would like to complete quests with the largest value of among the first of them So the answer to the problem is the maximum of over all values of from to Note that the value of is too large to calculate sums and maximums in the aforementioned formula every time for each independently so you have to maintain these values as the value for grows 
https://codeforces.com//contest/991/problem/F,192855,F,991F,991,F. Concise and clear,Vasya is a regular participant at programming contests and is already experienced in finding important sentences in long statements Of course numbers constraints are important factorization of a number less than is easier than of a number less than However sometimes it s hard to understand the number at the first glance Could it be shortened For example instead of you could write 10 6 instead of 10 9 instead of 10 9 7 Vasya decided that to be concise the notation should follow several rules the notation should only consist of numbers operations of addition multiplication and exponentiation in particular the use of braces is forbidden the use of several exponentiation operations in a row is forbidden for example writing is unacceptable the value of the resulting expression equals to the initial number the notation should consist of the minimal amount of symbols Given n find the equivalent concise notation for it ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nll n;\nvector<pair<ll,string> > po;\nmap<ll, string> mp;\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int base = 2; base <= 100000; base++) {\n\t\tll val = base;\n\t\tstring s = to_string(base) + '^';\n\t\tfor (int e = 2; val * base <= 10000000000ll; e++) {\n\t\t\tval *= base;\n\t\t\tpo.emplace_back(val, s + to_string(e));\n\t\t\tif(mp.count(val) && SZ(s + to_string(e)) < SZ(mp[val])) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t} else if (!mp.count(val)) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t}\n\t\t}\n\t}\n\t//for (ll n = 1; n <= 10000; n++) {\n\tstring res = to_string(n);\n\tfor (const pair<ll,string> &p : po) {\n\t\tif (n >= p.f) {\n\t\t\tif (mp.count(n - p.f)) {\n\t\t\t\tstring tmp = p.s + '+' + mp[n - p.f];\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif ((n - i) % p.f == 0 && mp.count((n - i) / p.f)) {\n\t\t\t\t\tstring tmp = p.s + '*' + mp[(n - i) / p.f];\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\ttmp += '+';\n\t\t\t\t\t\ttmp += to_string(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 2; i < 10; i++) {\n\t\t\t\tif (p.f * i <= n) {\n\t\t\t\t\tif (mp.count(n - p.f * i)) {\n\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '+' + mp[n - p.f * i];\n\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n % (p.f * i) == 0) {\n\t\t\t\t\t\tif (mp.count(n / (p.f * i))) {\n\t\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '*' + mp[n / (p.f * i)];\n\t\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring tmp = p.s;\n\t\t\tif (n - p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t\tll c = n / p.f;\n\t\t\tint d = 0;\n\t\t\tll asdf = c;\n\t\t\twhile (asdf) {\n\t\t\t\td++;\n\t\t\t\tasdf /= 10;\n\t\t\t}\n\t\t\tll num = 0;\n\t\t\tfor (int i = 1; i < d; i++) {\n\t\t\t\tnum = num * 10 + 9;\n\t\t\t\ttmp = to_string(num) + '*' + p.s;\n\t\t\t\tassert(n - num * p.f >= 0);\n\t\t\t\tif (n - num * p.f != 0) {\n\t\t\t\t\ttmp += '+';\n\t\t\t\t\ttmp += to_string(n - num * p.f);\n\t\t\t\t}\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = to_string(c) + '*' + p.s;\n\t\t\tif (n - c * p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - c * p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << n << ' ';\n\tcout << res << endl;\n\t//}\n\treturn 0;\n}""]",,,"['brute force', 'greedy', 'implementation', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Concise and clear.json,https://codeforces.com/blog/entry/60181,EditorialAll the problem numbers except for which is given in the samples contain at most 10 digits It means that we have to use at most 9 digits if we want to find a shorter representation Notice that the length of sum of two integers is not greater than sum of the lengths of these integers so in the optimal representation at most one term is a number while other terms are expressions containing and or Each expression not a number contains at least 3 symbols so the optimal representation can contain at most 3 terms The maximal integer that can be represented in such manner is 9 9 9 9 9 but it contains only 9 digits while expressions with 3 terms always contain at least 9 symbols So we proved that there always exists an optimal representation which is a sum of at most two terms So there exist only 3 types of representation of the original number n a b n x y n x y where and some expressions in the first case and are numbers which doesn t contain Moreover in all the cases such expressions should contain at most 7 digits Let s find for each a shortest valid representation containing at most 7 symbols if it exists and contains less digits than simple number and for each length set of integers which can be represented by an expression of length The standard containers std map and std set C are suitable for that Firstly let s add all expressions a b there are about sqrt n such expressions Now lets consider the expressions containing several multipliers The same way as for addition in such representation at most one multiplier is a number Including that the expression can contain at most 7 digits we have only 2 possible ways x a b c d x a b c where and are some numbers Lets iterate through the length of the representation of the first multiplier and go over all values stored in The second multiplier can have length at most and the total number of ways to choose two multipliers will be small enough The second multiplier should be selected from containers for length at most in the first case or we should iterate from to in the second case After that we will have about numbers in in total Now lets go back to the representation of the original number For the first case a b we have already stored such values in For the cases x y and x y we may assume that the length of expression of is not greater than 4 Now lets iterate through among found representations of length up to 4 and among integers from 1 to For each such and for each of 2 cases we determine value of uniquely and the optimal representation of is already stored in or it is just a number So for each such we can find optimal answer for by at most two addressing to i e in operations Finally the total algorithm complexity is 
https://codeforces.com//contest/204/problem/E,1546,E,204E,204,E. Little Elephant and Strings,The Little Elephant loves strings very much He has an array from strings consisting of lowercase English letters Let s number the elements of the array from 1 to then let s denote the element number as For each string the Little Elephant wants to find the number of pairs of integers and such that substring is a substring to at least strings from array including the th string Help the Little Elephant solve this problem If you are not familiar with the basic notation in string problems you can find the corresponding definitions in the notes ,"['#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <iterator>\n#include <functional>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\n\n// SA from http://www.prefield.com/algorithm/string/suffix_array.html\n\nstruct SaComp {\n\tconst int sp, *sr, srlen;\n\tSaComp(int sp, const vector<int>& sr) : sp(sp), sr(&sr[0]), srlen(sr.size()) {}\n\tbool operator()(int a, int b) const\n\t  { return make_pair(sr[a], a+sp<srlen?sr[a+sp]:0x7fffffff)\n\t         < make_pair(sr[b], b+sp<srlen?sr[b+sp]:0x7fffffff); }\n};\n\ntemplate<typename RanIt>\nvector<int> compute_suffix_array(RanIt beg, RanIt end)\n{\n\tconst int N = end - beg;\n\n\tvector<int> sa(N);\n\tvector<int> sort_rank(beg, end);\n\tfor(int i=0; i<N; ++i)\n\t\tsa[i] = i;\n\n\tsort(sa.begin(), sa.end(), SaComp(0, sort_rank));\n\tfor(int sorted_prefix=1; sorted_prefix<N; sorted_prefix*=2)\n\t{\n\t\tSaComp cmp(sorted_prefix, sort_rank);\n\t\tsort(sa.begin(), sa.end(), cmp);\n\n\t\tvector<int> block_id(N);\n\t\tfor(int i=1; i<N; ++i)\n\t\t\tblock_id[i] = block_id[i-1] + (cmp(sa[i-1], sa[i]) ? 1 : 0);\n\t\tfor(int i=0; i<N; ++i)\n\t\t\tsort_rank[sa[i]] = block_id[i];\n\t}\n\treturn sa;\n}\n\nvector<int> inv_sa(const vector<int>& sa)\n{\n\tvector<int> isa(sa.size());\n\tfor(int i=0; i<sa.size(); ++i)\n\t\tisa[sa[i]] = i;\n\treturn isa;\n}\n\ntemplate<typename RanIte>\nvector<int> longest_common_prefix(RanIte beg, RanIte end, const vector<int>& sa)\n{\n\tconst int N = sa.size();\n\tvector<int> lcp(N);\n\tvector<int> inv = inv_sa(sa);\n\n\tint len = 0;\n\tfor(int i=0; i<N; ++i) {\n\t\tint sa_idx = inv[i];\n\t\tif( sa_idx == 0 )\n\t\t\tlcp[sa_idx] = -1;\n\t\telse {\n\t\t\tfor(int k=sa[sa_idx-1]; i+len<N && k+len<N && *(beg+i+len)==*(beg+k+len);)\n\t\t\t\t++len;\n\t\t\tlcp[sa_idx] = len;\n\t\t}\n\t\tif(len) --len;\n\t}\n\treturn lcp;\n}\n\ntemplate<typename T>\nstruct RMQ\n{\n\tvector< vector<int> > rm;\n\tvector<T> d;\n\n\tRMQ( const vector<T>& d ) : d(d) {\n\t\tint n = d.size();\n\n\t\t// rm[k][x] = i s.t. d[i] is the minimum in [x, x+2^k)\n\t\trm.push_back( vector<int>(n) );\n\t\tfor(int x=0; x<n; ++x)\n\t\t\trm[0][x] = x;\n\t\tfor(int k=1; (1<<k)<=n; ++k) {\n\t\t\trm.push_back( rm[k-1] );\n\t\t\tfor(int x=0; x+(1<<k-1)<n; ++x)\n\t\t\t\tif( d[rm[k][x]] > d[rm[k-1][x + (1<<k-1)]] )\n\t\t\t\t\trm[k][x] = rm[k-1][x + (1<<k-1)];\n\t\t}\n\t}\n\n\t// min {i in [L,R] | d[i] is minumum among d[L..R]}\n\tint operator()(int L, int R) const {\n\t\tint k=0;\n\t\tfor(; L+(1<<k) < R-(1<<k)+1; ++k) {}\n\t\tint i = rm[k][L];\n\t\tint j = rm[k][R-(1<<k)+1];\n\t\treturn (d[i]<=d[j] ? i : j);\n\t}\n\n\t// {i in [L,R] | d[i] is minumum among d[L..R]}\n\tvector<int> all(int L, int R) const {\n\t\tvector<int> ans;\n\t\tint minValue = d[(*this)(L, R)];\n\t\twhile( L <= R ) {\n\t\t\tint C = (*this)(L, R);\n\t\t\tif( minValue < d[C] )\n\t\t\t\tbreak;\n\t\t\tans.push_back(C);\n\t\t\tL = C+1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// max {i in [L,R] | d[i]<X}, or -1\n\tint rightmost_less_than_X(int L, int R, T X) const {\n\t\tif(L>R) return -1;\n\n\t\tint k=0;\n\t\tfor(; L+(1<<k) < R-(1<<k)+1; ++k) {}\n\n\t\tint i = rm[k][L];\n\t\tint j = rm[k][R-(1<<k)+1];\n\t\tif( !(d[i]<X || d[j]<X) )\n\t\t\treturn -1;\n\t\tif( d[j] < X )\n\t\t\tL = R-(1<<k)+1;\n\n\t\tfor(; k; --k) { // Answer is in [L, L+(1<<k))\n\t\t\ti = rm[k-1][L];\n\t\t\tj = rm[k-1][L+(1<<k-1)];\n\t\t\tif( d[j] < X )\n\t\t\t\tL += 1<<k-1;\n\t\t}\n\t\treturn L;\n\t}\n\n\t// min {i in [L,R] | d[i]<X}, or -1\n\tint leftmost_less_than_X(int L, int R, T X) const {\n\t\tif(L>R) return -1;\n\n\t\tint k=0;\n\t\tfor(; L+(1<<k) < R-(1<<k)+1; ++k) {}\n\n\t\tint i = rm[k][L];\n\t\tint j = rm[k][R-(1<<k)+1];\n\t\tif( !(d[i]<X || d[j]<X) )\n\t\t\treturn -1;\n\t\tif( !(d[i] < X) )\n\t\t\tL = R-(1<<k)+1;\n\n\t\tfor(; k; --k) { // Answer is in [L, L+(1<<k))\n\t\t\ti = rm[k-1][L];\n\t\t\tj = rm[k-1][L+(1<<k-1)];\n\t\t\tif( !(d[i] < X) )\n\t\t\t\tL += 1<<k-1;\n\t\t}\n\t\treturn L;\n\t}\n};\n\nvoid solve(const vector<string>& SS, int K)\n{\n\tstring S;\n\tvector<int> sep;\n\tfor(int i=0; i<SS.size(); ++i) {\n\t\tif(i) S += \'$\';\n\t\tS += SS[i];\n\t\tsep.push_back(S.size());\n\t}\n\n\tint sa_end = S.size();\n\tvector<int> sa = compute_suffix_array(S.begin(), S.end());\n\tvector<int> lcp = longest_common_prefix(S.begin(), S.end(), sa);\n\tint sa_start = 0;\n\twhile(S[sa[sa_start]]<\'A\')\n\t\t++sa_start;\n\n\tvector<int> blk_of(sa_end, -1);\n\tfor(int i=sa_start; i<sa_end; ++i) {\n\t\tint blk = lower_bound(sep.begin(), sep.end(), sa[i]) - sep.begin();\n\t\tblk_of[i] = blk;\n\t}\n\n\tvector<int> first_index_of_K_diff_blocks(sa_end, 0x7fffffff);\n\tmap<int,int> blk_set;\n\tfor(int i=sa_start,k=sa_start; i<sa_end; ++i) {\n\t\tfor(; blk_set.size()<K && k<sa_end; ++k)\n\t\t\tblk_set[blk_of[k]]++;\n\t\tif( blk_set.size() == K )\n\t\t\tfirst_index_of_K_diff_blocks[i] = k-1;\n\t\tif( --blk_set[blk_of[i]] == 0 )\n\t\t\tblk_set.erase(blk_of[i]);\n\t}\n\n\n\n\tRMQ<int> rmq( vector<int>(lcp.begin(), lcp.end()) );\n\n\tvector<LL> total(SS.size());\n\tfor(int s=sa_start; s<sa_end; ++s)\n\t{\n\t\tint len_L=1, len_R=sep[blk_of[s]] - sa[s];\n\t\tint possible_len = 0;\n\t\twhile( len_L <= len_R )\n\t\t{\n\t\t\tint len_C = (len_L+len_R) / 2;\n\n\t\t\tint l = rmq.rightmost_less_than_X(sa_start, s, len_C);\n\t\t\tif(l==-1) l=sa_start;\n\t\t\tint r = rmq.leftmost_less_than_X(s+1, sa_end-1, len_C);\n\t\t\tif(r==-1) r=sa_end-1; else r--;\n\n\t\t\t// [l,r] has same prefix of length >= len_C as s\n\t\t\tif( first_index_of_K_diff_blocks[l] <= r ) {\n\t\t\t\tpossible_len = len_C;\n\t\t\t\tlen_L = len_C + 1;\n\t\t\t} else\n\t\t\t\tlen_R = len_C - 1;\n\t\t}\n\t\ttotal[blk_of[s]] += possible_len;\n\t}\n\n\tfor(int i=0; i<total.size(); ++i)\n\t\tcout << (i?"" "":"""") << total[i];\n\tcout<<endl;\n}\n\nint main()\n{\n\tfor(int N,K; cin>>N>>K; )\n\t{\n\t\tvector<string> SS(N);\n\t\tfor(int i=0; i<SS.size(); ++i)\n\t\t\tcin >> SS[i];\n\t\tsolve(SS, K);\n\t}\n}\n']",,,"['data structures', 'implementation', 'string suffix structures', 'two pointers']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Little Elephant and Strings.json,https://codeforces.com/blog/entry/4849,To solve this problems we can use suffix array More information about suffix arrays you can find in the Internet Firstly concatenate all strings into the one separating consecutive strings by some unique characters it was also useful to not use strings but arrays of integers For example three strings may be concatenated in the following way Now we should build suffix array using this total string this allows to us to sort all cyclic shifts of the string After that each cyclic shift will either begin with additional character or the character from the input strings Notice now that to find the result we need to find for each cyclic shift begging of which doesn t contain additional character the largest size of it s prefix such that this prefix is substring of at least different input strings This value can be found by binary search but for this we need some function which can answer the questions how many input strings contain prefix of size of cyclic shift as a substring How to make Look at all cyclic shifts prefix of size of which is equal to preifx of size of th shift Since all shifts are sorted lexicoraphically this set of shifts can be represented as integral of indices of shifts How to find and For each pair of consecutive shifts we can find it s greatest common prefix using properties of suffix array Than and can be found using RMQ For we need to know the rigthmost pair of shift but to the left from that their greatest common prefix is less than Analogically we can find After that we have interval and we need to find the number of different input strings that belongs to the shifts from th to th actually we need to find the number of different integer on interval But notice that we dont need the exactly number of different integers we need to know just it is at least or not So let equals to the greatest such that the number of different integers on interval is equal to Then if obiously interval will also contains at least different So is done The only thing to done is to fill array This is pretty simple using but it is possible without it but using RMQ We will go from left to righ at keep the indices of the last the rightmost different integers in the If some integer comes then if it was earlier we need to erase this previous index from set if it was still in and insert new current While the size of set is greater than we should erase the minimal number from it Then if in some position the size of the set after above changings is equal to than is equal to the minimal number in set Since we times use binary search and function works in time the total complexity is 
https://codeforces.com//contest/975/problem/D,179942,D,975D,975,D. Ghosts,Ghosts live in harmony and peace they travel the space without any purpose other than scare whoever stands in their way There are n ghosts in the universe they move in the OXY plane each one of them has its own velocity that does not change in time overrightarrow V V x overrightarrow i V y overrightarrow j where V x is its speed on the x axis and V y is on the y axis A ghost i has experience value EX i which represent how many ghosts tried to scare him in his past Two ghosts scare each other if they were in the same cartesian point at a moment of time As the ghosts move with constant speed after some moment of time there will be no further scaring and the experience of ghost kind GX sum i 1 n EX i will never increase Tameem is a red giant he took a picture of the cartesian plane at a certain moment of time T and magically all the ghosts were aligned on a line of the form y a cdot x b You have to compute what will be the experience index of the ghost kind GX in the indefinite future this is your task for today Note that when Tameem took the picture GX may already be greater than 0 because many ghosts may have scared one another at any moment between infty T ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define fr(x, y, z) for(int x=y;x<z;x++)\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppl;\nconst int ms=1e6;\n\n\n/*\n    3 types:\n        1 - on line ab,different speed\n        2 - \n*/\nmap<ll, map<pll,ll> > comp;\nmap<ll, ll > cnt;\nset<pll> ab;\nint main(){\n    ll n,a,b;\n    ll ans=0;\n    scanf(""%lld%lld%lld"",&n,&a,&b);\n    fr(i,0,n){\n        ll vx,vy,tsh;\n        scanf(""%lld%lld%lld"",&tsh,&vx,&vy);\n        cnt[a*vx-vy]++;\n        comp[a*vx-vy][pll(vx,vy)]++;\n        ans+=cnt[a*vx-vy]-comp[a*vx-vy][pll(vx,vy)];\n    }\n    cout<<ans*2<<endl;\n}']",,,"['geometry', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Ghosts.json,https://codeforces.com//blog/entry/59202,The condition for two points to meet in a moment of time T is for them to have the same X coordinates and the same Y coordinates Time when they have the same X coordinates is So should beTime when they will meet on Y axisIn order for them to collide so soSo Meaning that all ghosts with the same will collide except if they were parallel the answer is two times the number of collisions 
https://codeforces.com//contest/1831/problem/B,1942562,B,1831B,1831,B. Array merging,You are given two arrays a and b both of length n You will merge dagger these arrays forming another array c of length 2 cdot n You have to find the maximum length of a subarray consisting of equal values across all arrays c that could be obtained dagger A merge of two arrays results in an array c composed by successively taking the first element of either array as long as that array is nonempty and removing it After this step the element is appended to the back of c We repeat this operation as long as we can i e at least one array is nonempty ,"['// LUOGU_RID: 111682333\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate < typename T >\ninline const void read(T &x)\n{\n\tbool flg = x = 0;\n\tchar c;\n\twhile ((c = getchar()) < 48 || c > 57)\n\t\tflg |= c == \'-\';\n\tdo\n\t\tx = (x << 1) + (x << 3) + (c ^ 48);\n\twhile ((c = getchar()) > 47 && c < 58);\n\tif (flg) x = -x;\n}\n\nint OUTPUT[45];\n\ntemplate < typename T >\ninline const void write(T x)\n{\n\tif (x < 0)\n\t{\n\t\tputchar(\'-\');\n\t\tx = -x;\n\t}\n\tint len = 0;\n\tdo\n\t{\n\t\tOUTPUT[++len] = x % 10 | 48;\n\t\tx /= 10;\n\t}while (x);\n\twhile (len)\n\t\tputchar(OUTPUT[len--]);\n}\n\ntemplate < typename T >\ninline const void writesp(const T x)\n{\n\twrite(x);\n\tputchar(32);\n}\n\ntemplate < typename T >\ninline const void writeln(const T x)\n{\n\twrite(x);\n\tputchar(10);\n}\n\nconst int N = 1e6 + 5;\nint T, n, a[N], b[N], s1[N], s2[N];\n\nint main()\n{\n//\tfreopen("".in"", ""r"", stdin);\n//\tfreopen("".out"", ""w"", stdout);\n\tread(T);\n\twhile (T--)\n\t{\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tread(a[i]);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tread(b[i]);\n\t\tint m = (n << 1);\n\t\tfor (int i = 1; i <= m; ++i)\n\t\t\ts1[i] = s2[i] = 0;\n\t\tfor (int i = 1; i <= n;)\n\t\t{\n\t\t\tint r = i;\n\t\t\twhile (r < n && a[r + 1] == a[i])\n\t\t\t\t++r;\n\t\t\ts1[a[i]] = max(s1[a[i]], r - i + 1);\n\t\t\ti = r + 1;\n\t\t}\n\t\tfor (int i = 1; i <= n;)\n\t\t{\n\t\t\tint r = i;\n\t\t\twhile (r < n && b[r + 1] == b[i])\n\t\t\t\t++r;\n\t\t\ts2[b[i]] = max(s2[b[i]], r - i + 1);\n\t\t\ti = r + 1;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= m; ++i)\n\t\t\tans = max(ans, s1[i] + s2[i]);\n\t\twriteln(ans);\n\t}\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Array merging.json,https://codeforces.com//blog/entry/116527,SolutionLet be the length of the longest subarray from containing only elements equal to If doesn t appear in then Similarly let be the length of the longest subarray from containing only elements equal to If doesn t appear in then and can be computed in by scanning the array while updating current maximal subarray When merging two arrays it is possible to force a particular subarray to be adjacent to another particular subarray in the merged array ProofWe can construct the merged array as follows If then the merged array will have a subarray consisting of equal elements Therefore the answer is equal to Time complexity per testcase 
https://codeforces.com//contest/777/problem/B,95270,B,777B,777,B. Game of Credit Cards,After the fourth season Sherlock and Moriary have realized the whole foolishness of the battle between them and decided to continue their competitions in peaceful game of Credit Cards Rules of this game are simple each player bring his favourite digit credit card Then both players name the digits written on their cards one by one If two digits are not equal then the player whose digit is smaller gets a flick knock in the forehead usually made with a forefinger from the other player For example if Sherlock s card is and Moriarty s card has number first Sherlock names and Moriarty names so Sherlock gets a flick Then they both digit so no one gets a flick Finally Sherlock names while Moriarty names and gets a flick Of course Sherlock will play honestly naming digits one by one in the order they are given while Moriary as a true villain plans to cheat He is going to name his digits in some other order however he is not going to change the overall number of occurences of each digit For example in case above Moriarty could name and get no flicks at all or he can name and to give Sherlock two flicks Your goal is to find out the minimum possible number of flicks Moriarty will get no one likes flicks and the maximum possible number of flicks Sherlock can get from Moriarty Note that these two goals are different and the optimal result may be obtained by using different strategies ,"[""#include <bits/stdc++.h>\n#define REP(i, a, b) for (register int i = a; i <= b; ++i)\n#define PER(i, a, b) for (register int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n\ninline LL read() {\n\tLL x = 0; int ch = getchar(), f = 1;\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x * f;\n}\n\nint n, cnts[10], cntm[10], ta[10], tb[10];\nstring s;\nint main(){\n\tcin >> n;\n\tcin >> s;\n\tREP(i, 0, n - 1) cnts[s[i] - '0']++;\n\tcin >> s;\n\tREP(i, 0, n - 1) cntm[s[i] - '0']++;\n\t\n\tmemcpy(ta, cnts, sizeof cnts);\n\tmemcpy(tb, cntm, sizeof cntm);\n\n\tint j = 0, ans1 = 0;\n\tREP(i, 0, 9){\n\t\tj = i;\n\t\twhile (ta[i]){\n\t\t\tint dt = min(ta[i], tb[j]);\n\t\t\tta[i] -= dt; tb[j] -= dt;\n\t\t\tif (j == 9 && tb[j] == 0) break;\n\t\t\tif (tb[j] == 0) ++j;\n\t\t}\n\t\tans1 += ta[i];\n\t}\n\n\tmemcpy(ta, cnts, sizeof cnts);\n\tmemcpy(tb, cntm, sizeof cntm);\n\t\n\tint ans2 = 0;\n\tREP(i, 0, 9){\n\t\tj = i + 1;\n\t\twhile (j <= 9 && ta[i]){\n\t\t\tint dt = min(ta[i], tb[j]);\n\t\t\tta[i] -= dt; tb[j] -= dt;\n\t\t\tans2 += dt;\n\t\t\tif (j == 9 && tb[j] == 0) break;\n\t\t\tif (tb[j] == 0) ++j;\n\t\t}\n\t}\n\n\tcout << ans1 << endl << ans2 << endl;\n\treturn 0;\n}""]",,,"['data structures', 'dp', 'greedy', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Game of Credit Cards.json,https://codeforces.com//blog/entry/50670,First we want to consider a strategy that minimizes the amount of flicks Moriarty will receive from Sherlock This is similar to loosing as few rounds as possible He can use digit can be used to not loose against digit digit to not loose against digits and and so on Thus Moriarty should try all digits from to and greedily apply them to Sherlock s digits they can beat If the maximum number of rounds Moriarty can not loose is the answer for the first question is For the second question we need to count the maximum number of rounds Moriarty can win Now digit is useless digit wins against digit digit wins against digits and and so on Thus Moriarty should consider his digits from to and greedily use them to digits they can beat 
https://codeforces.com//contest/1954/problem/B,2586692,B,1954B,1954,B. Make It Ugly,Let s call an array a if you can make all its elements the same by using the following operation an arbitrary number of times possibly zero choose an index i 2 le i le a 1 such that a i 1 a i 1 and replace a i with a i 1 You are given a beautiful array a 1 a 2 dots a n What is the minimum number of elements you have to remove from it in order for it to stop being beautiful Swapping elements is prohibited If it is impossible to do so then output ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0//#include<atcoder/all>//using namespace atcoder;\xa0//using mint=modint998244353;//using mint=modint1000000007;\xa0void ahcorz(){    int n; cin >> n;    vi a(n); cin >> a;    if(a[0]!=a[n-1]){        print(0);        return;    }    vi vec;    vec.pb(-1);    rep(n) if(a[i]!=a[0]) vec.pb(i);    vec.pb(n);    if(sz(vec)<=2){        print(-1);        return;    }    int mn=1e9;    rep(sz(vec)-1) chmin(mn,vec[i+1]-vec[i]-1);    print(mn);}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}']",,,"['implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Make It Ugly.json,https://codeforces.com//blog/entry/128421,As given in the problem statement the definition of a beautiful array is not very interesting to us since checking the beauty of an array is quite complex Let s try to simplify it First of all the first and last elements will never be changed as it is impossible to choose such for operations If they are different then the array is definitely not beautiful Moreover if the array is beautiful then all its elements at the end will be equal to the first and the last elements The second idea is a bit more complicated Notice that each element can be changed at most once Consider an arbitrary operation We choose some for which and change to Now both and will always remain equal to their current values because in any operation involving them will also be involved This means that will also remain equal to the new value The next idea is as follows We know what all the elements should be equal to in the end This means that we need to apply operations to all elements that are not equal to this value According to the previous idea this is possible if and only if there are no two consecutive numbers in the array that are not equal to this value The sufficiency of this condition is obvious and the necessity is left as an exercise to the reader In other words the check looks like this and or or both are equal for all What elements should be removed so that the check does not pass There are two options break the first or second condition So you can do the following remove the entire prefix of numbers equal to remove the entire suffix of numbers equal to or they are equal to each other since the given array is beautiful choose two numbers that are not equal to and remove all the numbers between them so that these two numbers become adjacent The third condition can be simplified If other numbers not equal to are encountered between the selected numbers then another pair can be chosen for which fewer numbers have to be removed Therefore it is only optimal to choose a pair for which all the numbers between them are equal to Then the solution is as follows Find the shortest block of numbers equal to Remove it from the array It can be at the prefix or at the suffix then the first condition will be broken Or it can be somewhere in the middle then the second condition will be broken To find such a block you can go through the array from left to right maintaining the position of the previous element not equal to If the current element is not equal to update the answer with the difference between the saved and current positions and update the saved position The only case when the answer is is when all the elements of the array are the same Otherwise it is always possible to make the array not beautiful Overall complexity for each testcase 
https://codeforces.com//contest/1673/problem/A,1385663,A,1673A,1673,A. Subtle Substring Subtraction,Alice and Bob are playing a game with strings There will be t rounds in the game In each round there will be a string s consisting of lowercase English letters Alice moves first and both the players take alternate turns More formally if there was a string s s 1s 2 ldots s k the player can choose a substring s ls l 1 ldots s r 1 s r with length of corresponding parity and remove it After that the string will become s s 1 ldots s l 1 s r 1 ldots s k After the string becomes empty the round ends and each player calculates his her score for this round The score of a player is the sum of values of all characters removed by him her The value of texttt a is 1 the value of texttt b is 2 the value of texttt c is 3 ldots and the value of texttt z is 26 The player with higher score wins the round For each round determine the winner and the difference between winner s and loser s scores Assume that both players play optimally to maximize their score It can be proved that a draw is impossible ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar(\'-\'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nvoid solve(){\n    string a;\n    cin>>a;\n    if(SZ(a)%2==0){\n        int ans=0;\n        for(int i=0;i<SZ(a);i++)ans+=a[i]-\'a\'+1;\n        printf(""Alice %d\\n"",ans);\n    }else{\n        int k1=0,k2=0;\n        for(int i=0;i<SZ(a)-1;i++)k1+=a[i]-\'a\'+1;\n        k1-=a[SZ(a)-1]-\'a\'+1;\n        for(int i=1;i<SZ(a);i++)k2+=a[i]-\'a\'+1;\n        k2-=a[0]-\'a\'+1;\n        if(k1<k2)swap(k1,k2);\n        if(k1>0)printf(""Alice %d\\n"",k1);\n        else printf(""Bob %d\\n"",-k1);\n    }\n}\n\nint main(){\n    int T=read();\n    while(T--)solve();\n    return 0;\n}']",,,"['games', 'greedy', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Subtle Substring Subtraction.json,https://codeforces.com//blog/entry/102389,TutorialThe problem can be solved greedily Let be the length of the given string If the is even it is always optimal for Alice to remove the whole string If the is odd it is always optimal for Alice to remove either or based on which gives the higher score and then Bob can remove the remaining character or respectively This is optimal because if Alice chooses to remove a substring of even length such that then Bob can remove the remaining characters one of which will always be either or thus increasing Bob s score and decreasing Alice s score 
https://codeforces.com//contest/1823/problem/A,1896867,A,1823A,1823,A. A-characteristic,Consider an array a 1 a 2 dots a n consisting of numbers 1 and 1 Define A characteristic of this array as a number of pairs of indices 1 le i j le n such that a i cdot a j 1 Find any array a with given length n with A characteristic equal to the given value k ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k;\n\nvoid ldc(){\n    cin >> n >> k;\n    for(int i=0; i<=n; ++i) if(i*(i-1)/2+(n-i)*(n-i-1)/2==k){\n        cout << ""YES\\n"";\n        for(int j=0; j<i; ++j) cout << ""1 "";\n        for(int j=i; j<n; ++j) cout << ""-1 "";\n        cout << ""\\n"";\n        return;\n    }\n    cout << ""NO\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']",,,"['combinatorics', 'constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. A-characteristic.json,https://codeforces.com//blog/entry/115465,Note that the characteristic depends only on the number of s Let the number of s be equal to then the number of s is equal to and the characteristic is equal to Let s iterate over all from to and check if there is such that Then print numbers and numbers 
https://codeforces.com//contest/862/problem/A,123156,A,862A,862,A. Mahmoud and Ehab and the MEX,Dr Evil kidnapped Mahmoud and Ehab in the evil land because of their performance in the Evil Olympiad in Informatics EOI He decided to give them some problems to let them go Dr Evil is interested in sets He has a set of integers Dr Evil calls a set of integers if the of it is exactly the of a set of integers is the minimum non negative integer that doesn t exist in it For example the of the set is and the of the set is Dr Evil is going to make his set To do this he can perform some operations During each operation he can add some non negative integer to his set or erase some element from it What is the minimal number of operations Dr Evil has to perform to make his set ,"['#include <cstdio>\nint N, cnt[101], K, O;\nint main()\n{\n\tscanf(""%d%d"", &N, &K);\n\tfor (int i = 0, x; i < N; i++)\n\t{\n\t\tscanf(""%d"", &x);\n\t\tif (x == K)\n\t\t\tO++;\n\t\telse if (x < K)\n\t\t\tcnt[x] = 1;\n\t}\n\tfor (int i = 0; i < K; i++)\n\t\tif (!cnt[i])\n\t\t\tO++;\n\tprintf(""%d\\n"", O);\n\treturn 0;\n}\n']",,,"['greedy', 'implementation']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Mahmoud and Ehab and the MEX.json,https://codeforces.com//blog/entry/54590,One can see that in the final set all the elements less than should exist shouldn t exist and any element greater than doesn t matter so we will count the number of elements less than that don t exist in the initial set and add this to the answer If exists we ll add 1 to the answer because should be removed Time complexity Solution link me https pastebin com ALfcu8Ab Solution link mahmoudbadawy https pastebin com yXLkmA5F 
https://codeforces.com//contest/289/problem/B,2797,B,289B,289,B. Polo the Penguin and Matrix,Little penguin Polo has an matrix consisting of integers Let s index the matrix rows from 1 to from top to bottom and let s index the columns from 1 to from left to right Let s represent the matrix element on the intersection of row and column as In one move the penguin can add or subtract number from some matrix element Find the minimum number of moves needed to make all matrix elements equal If the described plan is impossible to carry out say so ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 110\nint n,m,d,a[N*N],b[N*N],c[N*N],ma,mi;\nint main()\n{\n    scanf(""%d%d%d"",&n,&m,&d);\n    for (int i=0;i<n*m;i++) scanf(""%d"",a+i);\n    for (int i=0;i<n*m;i++) \n        if ((a[i]-a[0])%d)\n            return puts(""-1""),0;\n    sort(a,a+n*m);\n    for (int i=1;i<n*m;i++)\n        b[i]=(a[i]!=a[i-1])?b[i-1]+(a[i]-a[i-1])/d*i:b[i-1];\n    for (int i=n*m-2;i>=0;i--)\n        c[i]=(a[i]!=a[i+1])?c[i+1]+(a[i+1]-a[i])/d*(n*m-i-1):c[i+1];\n    int ans=0x7fffffff;\n    for (int i=0;i<n*m;i++)\n        ans=min(ans,b[i]+c[i]);\n    printf(""%d\\n"",ans);\n}']",,,"['brute force', 'dp', 'implementation', 'sortings', 'ternary search']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Polo the Penguin and Matrix.json,https://codeforces.com//blog/entry/7241,Solution First of all we need to know when the answer is 1 For that you should notice that after any operation on number z value doesn t change Indeed This means that there is not answer if there are two different points for which is diffrent Now we can transform our problem a bit We can just write down all integers from matrix n m to one array b of size k n m and sort them all in non decreasing order It is not hard to notice that in some of the optimal solutions all number are at the end equal to one of the number for starting array But also it is optimal to make all number equal to median element Why to median Suppose that we make all numbers equal to non median element with index x Then if x k x 1 i e from one side there are more elements than from another 1 So by moving out element more to median we can make result better After we know to which number we should bring all the answer is just divided by d 
https://codeforces.com//contest/1152/problem/A,335380,A,1152A,1152,A. Neko Finds Grapes,On a random day Neko found n treasure chests and m keys The i th chest has an integer a i written on it and the j th key has an integer b j on it Neko knows those chests contain the powerful mysterious green Grapes thus Neko wants to open as many treasure chests as possible The j th key can be used to unlock the i th chest if and only if the sum of the key number and the chest number is an odd number Formally a i b j equiv 1 pmod 2 One key can be used to open at most one chest and one chest can be opened at most once Find the maximum number of chests Neko can open ,"['#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000003 \n#define N 100005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nint main() {\n\n\tint n,m;\n\n\tint cnt[2][2]={0};\n\n\tscanf(""%d %d"",&n,&m);\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tint x;\n\n\t\tscanf(""%d"",&x);\n\n\t\tcnt[0][x%2]++;\n\n\t}\n\n\tfor(int i=1;i<=m;i++) {\n\n\t\tint x;\n\n\t\tscanf(""%d"",&x);\n\n\t\tcnt[1][x%2]++;\n\n\t}\n\n\tprintf(""%d"",min(cnt[0][0],cnt[1][1])+min(cnt[0][1],cnt[1][0]));\n\n}']",,,"['greedy', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Neko Finds Grapes.json,https://codeforces.com/blog/entry/66696,The most important observation is that Key with odd id can only be used to unlock chest with even id Key with even id can only be used to unlock chest with odd id Let be the number of chests with even and odd id respectively be the number of keys with even and odd id respectively With even id chests and odd id keys you can unlock at most chests With odd id chests and even id keys you can unlock at most chests Therefore the final answer is Complexity 
https://codeforces.com//contest/1671/problem/F,1376220,F,1671F,1671,F. Permutation Counting,Calculate the number of permutations p of size n with exactly k inversions pairs of indices i j such that i j and p i p j and exactly x indices i such that p i p i 1 Yep that s the whole problem Good luck ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:46:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n\n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    for (int i = n - 1; i >= m - 1; i--) {\n      Mint c = a.back() / b.back();\n      for (int j = 0; j < m; j++) {\n        a[i - (m - 1) + j] -= b[j] * c;\n      }\n      a.pop_back();\n    }\n/*    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }*/\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<T> BM(vector<T> a) {\n  vector<T> p = {1};\n  vector<T> q = {1};\n  int l = 0;\n  for (int r = 1; r <= (int) a.size(); r++) {\n    T delta = 0;\n    for (int j = 0; j <= l; j++) {\n      delta += a[r - 1 - j] * p[j];\n    }\n    q.insert(q.begin(), 0);\n    if (delta != 0) {\n      vector<T> t = p;\n      if (q.size() > t.size()) {\n        t.resize(q.size());\n      }\n      for (int i = 0; i < (int) q.size(); i++) {\n        t[i] -= delta * q[i];\n      }\n      if (2 * l <= r - 1) {\n        q = p;\n        T od = 1 / delta;\n        for (T& x : q) {\n          x *= od;\n        }\n        l = r - l;\n      }\n      swap(p, t);\n    }\n  }\n  assert((int) p.size() == l + 1);\n//  assert(l * 2 + 30 < (int) a.size());\n  reverse(p.begin(), p.end());\n  return p;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = 111;\n  vector<vector<vector<vector<Mint>>>> f(N, vector<vector<vector<Mint>>>(N, vector<vector<Mint>>(12, vector<Mint>(12))));\n  f[1][0][0][0] = 1;\n  for (int n = 1; n < N - 1; n++) {\n    for (int p = 0; p < n; p++) {\n      for (int k = 0; k <= 11; k++) {\n        for (int x = 0; x <= 11; x++) {\n          for (int t = 0; t <= n; t++) {\n            int nk = k + (n - t);\n            int nx = x + (t <= p);\n            if (nk <= 11 && nx <= 11) {\n              f[n + 1][t][nk][nx] += f[n][p][k][x];\n            }\n          }\n        }\n      }\n    }\n  }\n  vector<vector<vector<Mint>>> r(12, vector<vector<Mint>>(12));\n  vector<vector<vector<Mint>>> vecs(12, vector<vector<Mint>>(12));\n  for (int k = 1; k <= 11; k++) {\n    for (int x = 1; x <= 11; x++) {\n      vector<Mint>& vec = vecs[k][x];\n      for (int n = 1; n < N; n++) {\n        Mint s = 0;\n        for (int p = 0; p < n; p++) {\n          s += f[n][p][k][x];\n        }\n        vec.push_back(s);\n      }\n      r[k][x] = BM(vec);\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k, x;\n    cin >> n >> k >> x;\n    auto y = power(vector<Mint>{0, 1}, n - 1, r[k][x]);\n    Mint ans = 0;\n    for (int i = 0; i < (int) y.size(); i++) {\n      ans += y[i] * vecs[k][x][i];\n    }\n    cout << ans << \'\\n\';\n  }\n  debug(clock());\n  return 0;\n}\n']",,,"['brute force', 'combinatorics', 'dp', 'fft', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Permutation Counting.json,https://codeforces.com//blog/entry/102181,A lot of solutions which were written during the contest use Berlekamp Messey or some other algorithms related to analyzing linear recurrences but the model solution is based on other principles First of all if the number of inversions is at most it means that most elements of the permutation will stay at their own places and those which don t stay at their places can t be too far away from them Let s denote a block in a permutation as a segment of indices such that all elements less than are to the left of the block all elements greater than are to the right of the block all elements from belong to the block Let s say that a block is non trivial if it contains at least two elements Suppose we split a permutation into the maximum number of blocks Then for each block we can see that if its length is it has at least inversions to prove it you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation and if we cannot split the block into other blocks it means that we have to swap each pair of adjacent elements in it at least once to sort it if the block is non trivial it has at least one such that From these two facts we can see that there will be at most non trivial blocks there will be at most elements in total belonging to non trivial blocks the maximum possible length of a block is The main idea of the solution is to calculate the following dynamic programming is the number of ways to split elements into non trivial blocks such that there are exactly inversions in them and exactly pairs Then to get the answer for the test case we can iterate on the number of non trivial blocks and the number of elements in them and choose the elements belonging to that blocks with a binomial coefficient The only thing that s left is how to calculate this dynamic programming efficiently There are a few ways to do it but the model solution uses a table the number of different non trivial blocks of length with elements and inversions to handle transitions This table is not very big so you can run an exhaustive search for minutes to calculate it and then just paste its results into the source code of your program Note that you have to make sure that you consider only the blocks which cannot be split any further 
https://codeforces.com//contest/723/problem/F,74122,F,723F,723,F. st-Spanning Tree,You are given an undirected connected graph consisting of vertices and edges There are no loops and no multiple edges in the graph You are also given two distinct vertices and and two values and Your task is to build any spanning tree of the given graph note that the graph is not weighted such that the degree of the vertex doesn t exceed and the degree of the vertex doesn t exceed or determine that there is no such spanning tree The of the graph is a subgraph which is a tree and contains all vertices of the graph In other words it is a connected graph which contains edges and can be obtained by removing some of the edges from The degree of a vertex is the number of edges incident to this vertex ,"['#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n\nconst int N = 4e5 + 7;\ntypedef std::vector<std::pair<int, int> > EdgeList;\n\nint father[N];\nEdgeList edges;\n\nint find(int x) {\n\treturn father[x] == x ? x : father[x] = find(father[x]);\n}\n\nint n, m;\nint s, t, ds, dt;\n\nbool rel_st(std::pair<int, int> p) {\n\treturn (p.first == s || p.first == t ||\n\t\tp.second == s || p.second == t);\n}\n\nEdgeList solve(EdgeList edges) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tEdgeList ret;\n\tfor (int i = 0; i < edges.size(); i++) {\n\t\tint u = edges[i].first, v = edges[i].second;\n\t\tif (find(u) != find(v)) {\n\t\t\tfather[find(u)] = find(v);\n\t\t\tret.push_back({u, v});\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool to_s[N], to_t[N];\nint s2who[N], t2who[N];\n\nvoid get_info(int s, bool to[], int to_who[], EdgeList edges) {\n\tstd::fill(to + 1, to + n + 1, false);\n\tfor (auto e : edges) {\n\t\tif (e.second == s) std::swap(e.first, e.second);\n\t\tif (e.first == s) {\n\t\t\tint v = e.second;\n\t\t\tto[find(v)] = true;\n\t\t\tto_who[find(v)] = v;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(""%d %d"", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(""%d %d"", &u, &v);\n\t\tedges.push_back({u, v});\n\t}\n\tscanf(""%d %d %d %d"", &s, &t, &ds, &dt);\n\tstd::vector<std::pair<int, int> > bak = edges;\n\tedges.clear();\n\tfor (auto p : bak) {\n\t\tif (!rel_st(p)) {\n\t\t\tedges.push_back(p);\n\t\t}\n\t}\n\tfor (auto p : bak) {\n\t\tif (rel_st(p)) {\n\t\t\tedges.push_back(p);\n\t\t}\n\t}\n\tauto vec = solve(edges);\n\tif (vec.size() < n - 1) {\n\t\tputs(""No"");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tEdgeList ans;\n\tfor (auto choosed : vec) {\n\t\tif (!rel_st(choosed)) {\n\t\t\tint u = choosed.first;\n\t\t\tint v = choosed.second;\n\t\t\tfather[find(u)] = father[find(v)];\n\t\t\tans.push_back(choosed);\n\t\t}\n\t}\n\tget_info(s, to_s, s2who, edges);\n\tget_info(t, to_t, t2who, edges);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != s && i != t && i == find(i)) {\n\t\t\tassert(to_s[i] || to_t[i]);\n\t\t\tif (to_s[i] && !to_t[i]) {\n\t\t\t\tds--;\n\t\t\t\tfather[i] = s;\n\t\t\t\tans.push_back({s, s2who[i]});\n\t\t\t} else if (to_t[i] && !to_s[i]) {\n\t\t\t\tdt--;\n\t\t\t\tfather[i] = t;\n\t\t\t\tans.push_back({t, t2who[i]});\n\t\t\t}\n\t\t}\n\t}\n\tint extras = -1, extrat = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != s && i != t && i == find(i)) {\n\t\t\tif (to_s[i] && to_t[i]) {\n\t\t\t\tif (ds > dt) {\n\t\t\t\t\tds--;\n\t\t\t\t\tans.push_back({s, s2who[i]});\n\t\t\t\t\textrat = t2who[i];\n\t\t\t\t} else {\n\t\t\t\t\tdt--;\n\t\t\t\t\tans.push_back({t, t2who[i]});\n\t\t\t\t\textras = s2who[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (extras == -1 && extrat == -1) {\n\t\tans.push_back({s, t});\n\t\tds--;\n\t\tdt--;\n\t} else if ((ds >= dt && extras != -1) || extrat == -1) {\n\t\tans.push_back({s, extras});\n\t\tds--;\n\t} else if ((dt >= ds && extrat != -1) || extras == -1) {\n\t\tans.push_back({t, extrat});\n\t\tdt--;\n\t}\n\tif (ds < 0 || dt < 0 || ans.size() < n - 1) {\n\t\tputs(""No"");\n\t\treturn 0;\n\t} else {\n\t\tputs(""Yes"");\n\t\tfor (auto a : ans) {\n\t\t\tprintf(""%d %d\\n"", a.first, a.second);\n\t\t}\n\t}\n}\n']",,,"['dsu', 'graphs', 'greedy', 'implementation']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. st-Spanning Tree.json,https://codeforces.com//blog/entry/47502,At first lets delete vertices and from the graph find all connected components in the remaining graph and build for every component any spanning trees Now we need to add in spanning tree vertices and At first let add edges from to all components which have no edges to Then let add edges from to all components which have no edges to If after that the degree of became more than or the degree of became more than answer does not exist Now we have components which have edges and to and to Also currently we have two spanning trees which does not connect Let s choose how to connect them with vertex with vertex or with both of them only if we have in the graph an edge For each option we need to greedily connect remaining components if it is possible for current option If we done it for any option we need only to print the answer 
https://codeforces.com//contest/193/problem/C,1406,C,193C,193,C. Hamming Distance,between strings and of equal length denoted by is equal to the number of distinct integers such that where is the th symbol of string is the th symbol of string For example the Hamming distance between strings and equals they have different first symbols For strings and the Hamming distance equals John Doe had a paper on which four strings of equal length and were written Each string consisted only of lowercase letters and John found the Hamming distances between all pairs of strings he had Then he lost the paper with the strings but he didn t lose the Hamming distances between all pairs Help John restore the strings find some four strings of equal length that consist only of lowercase letters and such that the pairwise Hamming distances between them are the same as between John s strings More formally set must satisfy the condition To make the strings easier to put down on a piece of paper you should choose among all suitable sets of strings the one that has strings of ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n\nconst int MAXL = 1e6;\n\npdd operator*(const pdd &a, int b) { return mp(a.first * b, a.second * b); }\npdd operator+(const pdd &a, const pdd &b) { return mp(a.first + b.first, a.second + b.second); }\n\nint divide(int a, int b) {\n  if (b < 0) { a = -a; b = -b; }\n  if (a < 0) return 0;\n  // x >= a / b\n  int c = a / b;\n  if (c * b < a) c++;\n  return c;\n}\n\nbool check(const vvi &m, int x, vi &vals) {\n  vals = vi(8);\n  vals[7] = 1;\n  vals[6] = x;\n  for (int y = 5; y >= 0; y--) {\n    int cv = 0;\n    for (int x = y + 1; x < sz(m[y]); x++)\n      cv -= m[y][x] * vals[x];\n    assert(m[y][y]);\n    if (cv % m[y][y]) return false;\n    vals[y] = cv / m[y][y];\n  }\n  for (int i = 0; i <= 7; i++)\n    if (vals[i] < 0) return false;\n  return true;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(""std.in"", ""r"", stdin);\n  freopen(""std.out"", ""w"", stdout);\n  #endif\n\n  int hs[4][4];\n  while (scanf(""%d"", &hs[0][1]) >= 1) {\n    int ids[4][4];\n    memset(ids, -1, sizeof ids);\n\n    vvi m(7, vi(8, 0));\n    int cid = 0;\n\n    for (int a = 0; a < 4; a++)\n    for (int b = a + 1; b < 4; b++) {\n      if (a != 0 || b != 1)\n        scanf(""%d"", &hs[a][b]);\n      ids[a][b] = cid;\n      m[cid][7] = -hs[a][b];\n      cid++;\n    }\n\n    for (int msk = 1; msk < 8; msk++) {\n      int ss[4] = { 0 };\n      for (int i = 0; i < 3; i++) ss[i + 1] = !!(msk & (1 << i));\n\n      for (int a = 0; a < 4; a++)\n      for (int b = a + 1; b < 4; b++) if (ss[a] != ss[b]) {\n        m[ids[a][b]][msk - 1] = 1;\n      }\n    }\n/*    for (int y = 0; y < 7; y++)\n    for (int x = 0; x < 8; x++)\n      eprintf(""%2d%c"", m[y][x], ""\\n ""[x < 7]);\n    eprintf(""\\n"");*/\n    for (int y = 0; y < 7; y++) {\n      for (int y2 = y; y2 < 7; y2++) if (m[y2][y]) {\n        if (y != y2)\n          m[y].swap(m[y2]);\n        break;\n      }\n      if (!m[y][y]) continue;\n      for (int y2 = y + 1; y2 < 7; y2++) if (m[y2][y]) {\n        assert(-m[y2][y] % m[y][y] == 0);\n        int k = -m[y2][y] / m[y][y];\n        for (int x = 0; x < sz(m[y2]); x++)\n          m[y2][x] += k * m[y][x];\n      }\n    }\n/*    for (int y = 0; y < 7; y++)\n    for (int x = 0; x < 8; x++)\n      eprintf(""%2d%c"", m[y][x], ""\\n ""[x < 7]);*/\n\n    vector<pdd> ks(8);\n    ks[6] = mp(1, 0);\n    ks[7] = mp(0, 1);\n\n    for (int y = 5; y >= 0; y--) {\n      pdd cur(0, 0);\n      for (int x = y + 1; x < sz(m[y]); x++)\n        cur = cur + (ks[x] * -m[y][x]);\n\n      int ck = m[y][y];\n      ks[y] = mp(cur.first / ck, cur.second / ck);\n    }\n\n    double minx = 0;\n    for (int i = 0; i < 7; i++) {\n      assert(fabs(ks[i].first) > 1e-8);\n      if (ks[i].first > 0) {\n        minx = max(minx, -ks[i].second / ks[i].first);\n      }\n    }\n\n    eprintf(""minx=%.2lf\\n"", minx);\n    int x = max(0, (int)minx - 100);\n    for (int i = 0; i < 200; i++, x++) {\n      vi vals;\n      if (check(m, x, vals)) {\n        string s[4] = { """" };\n\n        for (int m = 1; m < 8; m++) {\n          int cnt = vals[m - 1];\n          for (int i = 0; i < cnt; i++) {\n            s[0] += ""a"";\n            for (int i2 = 0; i2 < 3; i2++)\n              s[i2 + 1] += string(1, \'a\' + !!(m & (1 << i2)));\n          }\n        }\n        printf(""%d\\n"", s[0].length());\n        for (int i = 0; i < 4; i++)\n          printf(""%s\\n"", s[i].c_str());\n        goto end;\n      } else\n        eprintf(""skip\\n"");\n    }\n    printf(""-1\\n"");\n    end:;\n  }\n  return 0;\n}\n\n']",,,"['constructive algorithms', 'greedy', 'math', 'matrices']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Hamming Distance.json,https://codeforces.com//blog/entry/4673,Main idea reduction to system of linear equations and solving it using Gauss algorithm Let s notice that order of columns in answer doesn t matter That s why there is only one important thing quantity of every type of column There is only 24 16 different columns Let s represent Hamming distance between every pair of strings as sum of quantities of types of columns It s possible because every column adds to every distance between pairs 0 or 1 Now we have system of 6 linear equations with 16 variables It s not good let s decrease number of variables First some columns adds same values to every Hamming distance For example strings abbb and baaa For every column q we can replace all letters a by letters b and all letters b by letters a and reach column that adds same values to every distance We reduced number of variables to 8 We also can notice that columns aaaa and bbbb is useless and reduce number of variables to 7 This system can be solved using Gauss algorithm One variable steel be free Let s fix it It s value can t be more than maximum of h si sj because column adds positive value to one or more Hamming distance For every fixed value we should check if all variables take non negative integer value and choose the best answer We can solve system of equations in integers because coefficients of equation is little Complexity of this solution if O max h si sj If we solve it in rational numbers complexity will change to
https://codeforces.com//contest/1716/problem/A,1494200,A,1716A,1716,A. 2-3 Moves,You are standing at the point 0 on a coordinate line Your goal is to reach the point n In one minute you can move by 2 or by 3 to the left or to the right i e if your current coordinate is x it can become x 3 x 2 x 2 or x 3 Note that the new coordinate can become negative Your task is to find the number of minutes required to get from the point 0 to the point n You have to answer t independent test cases ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tif (x == 1)\n\t\t\tprintf(""2\\n"");\n\t\telse\n\t\t\tprintf(""%d\\n"", (x + 2) / 3);\n\t}\n\n\treturn 0;\n}\n']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. 2-3 Moves.json,https://codeforces.com//blog/entry/105653,If the answer is we can t get so we can move by to the right and by to the left If or the answer is obviously Otherwise the answer is always We can t get the answer less than this value because we need at least moves to get to the point greater than or equal to and we can always get this answer by the recurrence 
https://codeforces.com//contest/1903/problem/E,2355506,E,1903E,1903,E. Geo Game,Theofanis and his sister are playing the following game They have n points in a 2D plane and a starting point s x s y Each player starting from the first player chooses one of the n points that wasn t chosen before and adds to the sum which is initially 0 the of the Euclidean distance from the previous point which is either the starting point or it was chosen by the other person to the new point that the current player selected The game ends after exactly n moves after all the points are chosen The first player wins if the sum is even in the end Otherwise the second player wins Theofanis is a very competitive person and he hates losing Thus he wants to choose whether he should play first or second Can you show him which player to choose and how he should play to beat his sister ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 20;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector <set <int>> bucket(2);\n        int sx, sy; cin >> sx >> sy;\n        int bg = (sx ^ sy) & 1;\n        for (int i = 1, x, y; i <= n; ++i) {\n            cin >> x >> y;\n            bucket[(x ^ y) & 1].insert(i);\n        }\n        // first want bg as last\n        // second want bg ^ 1 as last\n        int choose = 0, tot = n;\n        auto computer = [&]() {\n            int x; cin >> x;\n            bucket[0].erase(x), bucket[1].erase(x), tot--;\n        };\n        auto user = [&]() {\n            int cur = choose;\n            if (bucket[choose].empty()) {\n                cur ^= 1;\n            }\n            int x = *bucket[cur].begin();\n            bucket[cur].erase(bucket[cur].begin()), tot--;\n            cout << x << endl;\n        };\n        if (bucket[bg].size() >= bucket[bg ^ 1].size()) {\n            cout << ""First"" << endl;\n            choose = bg ^ 1;\n        } else {\n            cout << ""Second"" << endl;\n            choose = bg;\n            computer();\n        }\n        while (tot) {\n            user();\n            if (!tot) {\n                break;\n            }\n            computer();\n        }\n    }\n}']",,,"['greedy', 'interactive', 'math']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Geo Game.json,https://codeforces.com//blog/entry/122820,If we went from point to then we will add to the sum which is equal to mod is bitwise xor For each point we find mod mod Let the number of mod mod the number of mod mod and mod mod Let s say that we create a binary string starting with and has another zeros and ones If the number of is odd then the sum will be odd otherwise the sum will be even If you are the first player then you want to have an even number of That holds iff the first element of is the same as the last element of Thus the second player will want to put all occurrences of before the end so that the last element is not equal to the first He can do this iff rounded down this means that If you play as the first player and you choose occurrences of until there aren t anyand else you play as the second player and you choose occurrences of until there aren t any 
https://codeforces.com//contest/1700/problem/F,1433687,F,1700F,1700,F. Puzzle,Pupils Alice and Ibragim are best friends It s Ibragim s birthday soon so Alice decided to gift him a new puzzle The puzzle can be represented as a matrix with 2 rows and n columns every element of which is either 0 or 1 In one move you can swap two values in neighboring cells More formally let s number rows 1 to 2 from top to bottom and columns 1 to n from left to right Also let s denote a cell in row x and column y as x y We consider cells x 1 y 1 and x 2 y 2 neighboring if x 1 x 2 y 1 y 2 1 Alice doesn t like the way in which the cells are currently arranged so she came up with her own arrangement with which she wants to gift the puzzle to Ibragim Since you are her smartest friend she asked you to help her find the minimal possible number of operations in which she can get the desired arrangement Find this number or determine that it s not possible to get the new arrangement ,"['/*\n\n_/      _/       _/_/_/      _/      _/    _/           _/_/_/_/_/\n _/    _/      _/      _/     _/    _/     _/           _/\n  _/  _/      _/               _/  _/      _/           _/\n   _/_/       _/                 _/        _/           _/_/_/_/\n  _/  _/      _/                 _/        _/           _/\n _/    _/      _/      _/        _/        _/           _/\n_/      _/       _/_/_/          _/        _/_/_/_/_/   _/_/_/_/_/\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\n#define maxn 200005\nusing namespace std;\ninline int read()\n{\n\tint x = 0, w = 0; char ch = getchar();\n\twhile(!isdigit(ch)) {w |= ch == \'-\'; ch = getchar();}\n\twhile(isdigit(ch)) {x = x * 10 + ch - \'0\'; ch = getchar();}\n\treturn w ? -x : x;\n}\nint n, a[2][maxn];\nint main()\n{\n\tn = read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] += read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] -= read();\n\tint cnt[2] = {0, 0}; ll ans = 0;\n\tru(i, 1, n)\n\t{\n\t\tans += abs(cnt[0] + cnt[1]);\n\t\tru(j, 0, 1) cnt[j] += a[j][i];\n\t\tif((ll)cnt[0] * cnt[1] < 0)\n\t\t{\n\t\t\tans += min(abs(cnt[0]), abs(cnt[1]));\n\t\t\tif(abs(cnt[0]) > abs(cnt[1]))\n\t\t\t{\n\t\t\t\tcnt[0] += cnt[1];\n\t\t\t\tcnt[1] = 0;\n\t\t\t}\n\t\t\telse cnt[1] += cnt[0], cnt[0] = 0;\n\t\t}\n\t}\n\tif(cnt[0] != 0 || cnt[1] != 0) printf(""-1"");\n\telse printf(""%lld\\n"", ans);\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'dp', 'greedy']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Puzzle.json,https://codeforces.com//blog/entry/103978,We are asked to find a minimum cost perfect matching between s in the matrices where the cost between and is Notice that the answer exists only if the number of s is equal in both matrices Consider that this is the case Notice that every either stays in its original row or changes it in a single operation For simplicity let s assume that all operations of that kind are performed in the beginning Let s denote as the difference between the th prefix sum in th row of the matrices If the final row for each is fixed then the answer is equal to where in the number of s that changed its row Now let s look at what happens when we change the row of a For simplicity let s assume that it was in a cell Then after the swap we have to increment by decrement all by and increment all by Now let s solve the following problem we are given and and in one operation we can increment some suffix by and decrement the same suffix in the other array by The goal is to minimize Notice that the following greedy algorithm works iterate through columns from left to right and while and have different signs decrement the suffix of one that s greater and increment suffix of one that s lower Now let s prove that this algorithm minimizes the target sum For this consider some optimal sequence of operations It doesn t matter in which order operations are performed so let s assume they are performed from left to right and are accumulated in a single element for the same suffix If the sequences differ denote as the first such position Note that before that all and are the same in both our answer and the optimal one Suppose that in the optimal answer we incremented th suffix of by and decremented th suffix of by Then the target sum will increase by Consider the following cases and or and By triangle inequality which means that those operations could be performed on the st suffix and that wouldn t increase the answer and Here if which means that those operations could be performed on the st suffix and that wouldn t increase the answer Now if We can assume that otherwise we will perform an operation on values with the same sign which we already shown can be done later on Then Greedy algorithm suggests doing exactly operations Note that if we perform operations on suffix and operations on suffix we will add to the answer and get the same state as the optimal answer This means that we can do operations and not increase the answer and This case can be analyzed in the same way What we showed here is that we can always extend the matching prefix with the optimal answer which means that the greedy algorithm produces the same answer Let s come back to the original problem Described greedy algorithm finds a lower bound on the answer Let s show that it is always possible to achieve it when the operations are allowed only for moving s between rows and the number of s in each row at the end should be the same For this note that we can perform operations on s from the second matrix if we reverse their order and append to the end of the sequence for the first matrix Now note that if on some prefix and have the same sign but on prefix the signs differ there has to be at least a single in column and we can perform the operation suggested by the greedy algorithm Finally if the answer exists it is true that and if and have the same sign at the end this means that they are both which means that the constructed answer is correct This solution works in time 
https://codeforces.com//contest/1257/problem/D,470639,D,1257D,1257,D. Yet Another Monster Killing Problem,You play a computer game In this game you lead a party of m heroes and you have to clear a dungeon with n monsters Each monster is characterized by its power a i Each hero is characterized by his power p i and endurance s i The heroes clear the dungeon day by day In the beginning of each day you choose a hero exactly one who is going to enter the dungeon this day When the hero enters the dungeon he is challenged by the first monster which was not defeated during the previous days so if the heroes have already defeated k monsters the hero fights with the monster k 1 When the hero fights the monster there are two possible outcomes if the monster s power is strictly greater than the hero s power the hero retreats from the dungeon The current day ends otherwise the monster is defeated After defeating a monster the hero either continues fighting with the next monster or leaves the dungeon He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day so the i th hero cannot defeat more than s i monsters during each day or if all monsters are defeated otherwise he fights with the next monster When the hero leaves the dungeon the current day ends Your goal is to defeat the last monster What is the minimum number of days that you need to achieve your goal Each day you have to use exactly one hero it is possible that some heroes don t fight the monsters at all Each hero can be used arbitrary number of times ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\n\nvoid solve_case() {\n    int N, M;\n    IO::read_int(N);\n    vector<int> A(N);\n    vector<int> best_power(N + 1, 0);\n\n    for (auto &a : A)\n        IO::read_int(a);\n\n    IO::read_int(M);\n\n    for (int i = 0; i < M; i++) {\n        int p, s;\n        IO::read_int(p, s);\n        best_power[s] = max(best_power[s], p);\n    }\n\n    for (int s = N - 1; s >= 0; s--)\n        best_power[s] = max(best_power[s], best_power[s + 1]);\n\n    if (*max_element(A.begin(), A.end()) > best_power[0]) {\n        IO::write_int(-1, '\\n');\n        return;\n    }\n\n    int start = 0, days = 0;\n\n    while (start < N) {\n        int monsters = 0, maximum = 0;\n\n        while (start + monsters < N) {\n            maximum = max(maximum, A[start + monsters]);\n\n            if (best_power[monsters + 1] >= maximum)\n                monsters++;\n            else\n                break;\n        }\n\n        start += monsters;\n        days++;\n    }\n\n    IO::write_int(days, '\\n');\n}\n\nint main() {\n    IO::init();\n\n    int T;\n    IO::read_int(T);\n\n    while (T-- > 0)\n        solve_case();\n}\n""]",,,"['binary search', 'data structures', 'dp', 'greedy', 'sortings', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Yet Another Monster Killing Problem.json,https://codeforces.com//blog/entry/71434,At first lets precalc array is equal to maximum hero power whose endurance is greater than or equal to Now let s notice that every day it s profitable for as to kill as many monster as possible Remains to understand how to calculate it Suppose that we already killed monsters If then answer is because we can t kill the th monster Otherwise we can kill at least monsters All we have to do it increase the value until conditions holds After calculating the value we just move to the next day with killed monsters 
https://codeforces.com//contest/1535/problem/A,1005282,A,1535A,1535,A. Fair Playoff,Four players participate in the playoff tournament The tournament is held according to the following scheme the first player will play with the second and the third player with the fourth then the winners of the pairs will play in the finals of the tournament It is known that in a match between two players the one whose skill is greater will win The skill of the i th player is equal to s i and all skill levels are pairwise different i e there are no two identical values in the array s The tournament is called if the two players with the highest skills meet in the finals Determine whether the given tournament is ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    vector<int> s(4);\n    for (int j = 0; j < 4; j++){\n      cin >> s[j];\n    }\n    int m1 = max(s[0], s[1]);\n    int m2 = max(s[2], s[3]);\n    if (m1 > m2){\n      swap(m1, m2);\n    }\n    sort(s.begin(), s.end());\n    if (s[2] == m1 && s[3] == m2){\n      cout << ""YES"" << ""\\n"";\n    } else {\n      cout << ""NO"" << ""\\n"";\n    }\n  }\n}']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Fair Playoff.json,https://codeforces.com//blog/entry/91481,It is easier to determine the case when the players with the maximum skills will not meet in the finals It means that they met in the semifinals and in the other semifinals both players are weaker It s easy to check this case with the following formula or 
https://codeforces.com//contest/1611/problem/A,1202184,A,1611A,1611,A. Make Even,Polycarp has an integer n that doesn t contain the digit He can do the following operation with his number several possibly zero times Reverse the prefix of length l in other words l leftmost digits of n So the leftmost digit is swapped with the l th digit from the left the second digit from the left swapped with l 1 th left etc For example if n 123456789 and l 5 then the new value of n will be 543216789 Note that for different operations the values of l can be different The number l can be equal to the length of the number n in this case the whole number n is reversed Polycarp loves even numbers Therefore he wants to make his number even At the same time Polycarp is very impatient He wants to do as few operations as possible Help Polycarp Determine the minimum number of operations he needs to perform with the number n to make it even or determine that this is impossible You need to answer t independent test cases ,"['#include <bits/stdc++.h>\n//Make Even\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        std::string x;\n        std::cin>>x;\n        if(!(x[x.size()-1]&1)){\n            printf(""0\\n"");\n        }else{\n            if(!(x[0]&1)){\n                printf(""1\\n"");\n            }else {\n                for(auto&z:x){\n                    if(!(z&1)){\n                        printf(""2\\n"");\n                        goto prox;\n                    }\n                }\n                printf(""-1\\n"");\n            }\n        }\n        prox:{}\n    }\n}\n']",,,"['constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Make Even.json,https://codeforces.com//blog/entry/97288,If the number is already even then nothing needs to be done so the answer in this case is Now let s recall the divisibility by a number is divisible by if and only if its last digit is divisible by It follows that if there are no even digits in our number then the answer is Let s take a look at our operation What is going on The first digit always changes with the digit numbered In particular when we reverse the entire number the first digit is swapped with the last Note that no other digit except for the first one at the current moment can t be the last Therefore you can do this if the first digit of a number is divisible by then we reverse the whole number The first digit will become the last and the number will become even Therefore you only need to do one operation Now what if the first digit of a number is odd In this case we can find the first even digit in the number let it be at position and reverse the prefix of length in one operation Now the first digit of our number has become even and we can use the previous case one more operation Thus we will do only operations 
https://codeforces.com//contest/204/problem/A,1542,A,204A,204,A. Little Elephant and Interval,The Little Elephant very much loves sums on intervals This time he has a pair of integers and The Little Elephant has to find the number of such integers that the first digit of integer equals the last one in decimal notation For example such numbers as or will be included in the answer and or will not Help him and count the number of described numbers for a given pair and ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nll p[22];\nll f(ll n){\n\tstringstream ss;\n\tss<<n;\n\tstring s = ss.str();\n\tll res =  0;\n\tFOR(i,1,s.size()){\n\t\tint len = i;\n\t\tlen -= 2;\n\t\tif(len<0) len = 0;\n\t\tres += p[len]*9;\n\t}\n\tstring t = s;\n\tFOR(i,1,10){\n\t\tif(s[0]-\'0\' < i) break;\n\t\tif(s[0]-\'0\' == i){\n\t\t\tll val = 0;\n\t\t\tFOR(j,1,s.size()-1) val = 10 * val + s[j]-\'0\';\n\t\t\tval ++;\n\t\t\tif(s[s.size()-1]-\'0\' < i) val--;\n\t\t\tres += val;\n\t\t}else res += p[max(0,(int)s.size()-2)];\n\t}\n\treturn res;\n}\n\nbool good(ll n){\n\tstringstream ss;\n\tss<<n;\n\tstring s = ss.str();\n\treturn s[0]==s[s.size()-1];\n}\nll stupid(ll l,ll r){\n\tll res = 0;\n\tfor(ll i = l;i<=r;i++)\n\t\tif(good(i)) res++;\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tp[0]=1;\n\tFOR(i,1,20) p[i]=p[i-1]*10;\n\tll l,r;\n\tcin>>l>>r;\n\tif(l>r) swap(l,r);\n\tcout<<f(r)-f(l-1)<<endl;\n//\tcout<<f(r)<<\' \'<<f(l-1)<<endl;\n//\tcout<<stupid(l,r)<<endl;\n\t//if(f(r)-f(l-1)==stupid(l,r)) goto start;\n\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']",,,"['binary search', 'combinatorics', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Little Elephant and Interval.json,https://codeforces.com/blog/entry/4849,It is well known that for such problem you need to write function F x which solves the problem for the interval 0 x and the answer then is F r F l 1 Now you need to write F x function If x 10 then answer is of course equal to x Otherwise let len be the length of x x the integer x but without first and last digits xi the i th digit of integer x from left to right starting from 0 Interate through all possible first digit d which is the last at the same time and through the length i of the number Then if i len 2 or i len 2 and d x0 you need to add 10i to the answer Otherwise if i len 2 and d x0 you need to add x to the answer Finally if i len 2 and d x0 and xlen 1 d add 1 to the answer This problems also can be solved using DP 
https://codeforces.com//contest/1511/problem/E,955216,E,1511E,1511,E. Colorings and Dominoes,You have a large rectangular board which is divided into n times m cells the board has n rows and m columns Each cell is either white or black You paint each white cell either red or blue Obviously the number of different ways to paint them is 2 w where w is the number of white cells After painting the white cells of the board you want to place the maximum number of dominoes on it according to the following rules each domino covers two adjacent cells each cell is covered by at most one domino if a domino is placed horizontally it covers two adjacent cells in one of the rows it should cover only red cells if a domino is placed vertically it covers two adjacent cells in one of the columns it should cover only blue cells Let the of the board be the maximum number of dominoes you can place Calculate the sum of of the board over all 2 w possible ways to paint it Since it can be huge print it modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\ntemplate <class ForwardIterator,\n          class T = typename std::iterator_traits<ForwardIterator>::value_type>\nstd::vector<std::pair<T, int>> rle(ForwardIterator first,\n                                   ForwardIterator last) {\n  std::vector<std::pair<T, int>> res;\n  int n = 0;\n  for (auto it = first; it != last; ++it)\n    n += std::next(it) == last or not(*it == *std::next(it));\n  res.reserve(n);\n  for (; first != last; ++first)\n    if (std::empty(res) or not(res.back().first == *first))\n      res.emplace_back(*first, 1);\n    else\n      ++res.back().second;\n  return res;\n}\n\ntemplate <uint32_t Modulus>\nclass ModularInt {\n  using M = ModularInt;\n\n public:\n  static_assert(int(Modulus) >= 1, ""Modulus must be in the range [1, 2^31)"");\n  static constexpr int modulus() { return Modulus; }\n  static M raw(uint32_t v) { return *reinterpret_cast<M*>(&v); }\n\n  ModularInt() : v_(0) {}\n  ModularInt(int64_t v) : v_((v %= Modulus) < 0 ? v + Modulus : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  M& operator++() { return v_ = ++v_ == Modulus ? 0 : v_, *this; }\n  M& operator--() { return --(v_ ? v_ : v_ = Modulus), *this; }\n  M operator+() const { return *this; }\n  M operator-() const { return raw(v_ ? Modulus - v_ : 0); }\n  M& operator*=(M o) { return v_ = uint64_t(v_) * o.v_ % Modulus, *this; }\n  M& operator/=(M o) {\n    auto [inv, gcd] = extgcd(o.v_, Modulus);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  M& operator+=(M o) {\n    return v_ = int(v_ += o.v_ - Modulus) < 0 ? v_ + Modulus : v_, *this;\n  }\n  M& operator-=(M o) {\n    return v_ = int(v_ -= o.v_) < 0 ? v_ + Modulus : v_, *this;\n  }\n\n  friend M operator++(M& a, int) { return std::exchange(a, ++M(a)); }\n  friend M operator--(M& a, int) { return std::exchange(a, --M(a)); }\n  friend M operator*(M a, M b) { return a *= b; }\n  friend M operator/(M a, M b) { return a /= b; }\n  friend M operator+(M a, M b) { return a += b; }\n  friend M operator-(M a, M b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, M& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, M x) { return os << x.v_; }\n  friend bool operator==(M a, M b) { return a.v_ == b.v_; }\n  friend bool operator!=(M a, M b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int, int> extgcd(int a, int b) {\n    std::array x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  uint32_t v_;\n};\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nusing Mint = ModularInt<998244353>;\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  vector<Mint> f(3e5 + 1);\n  f[2] = 1;\n  for (int i : Rep(3, 3e5 + 1)) f[i] = 3 * f[i - 1] - 4 * f[i - 3];\n\n  vector<Mint> p2(3e5 + 1);\n  p2[0] = 1;\n  for (int i : Rep(3e5)) p2[i + 1] = 2 * p2[i];\n\n  int h = scan();\n  int w = scan();\n  vector<string> s(h);\n  generate(ALL(s), scan<string>);\n  int white = 0;\n  for (auto&& e : s) white += count(ALL(e), \'o\');\n\n  Mint ans;\n  for (int _ = 2; _--;) {\n    {\n      vector ns(w, string(h, \'?\'));\n      for (int i : Rep(h))\n        for (int j : Rep(w)) ns[j][i] = s[i][j];\n      s = ns;\n      swap(h, w);\n    }\n    for (auto&& e : s) {\n      for (auto&& [c, len] : rle(ALL(e))) {\n        if (c == \'*\') continue;\n        ans += f[len] * p2[white - len];\n      }\n    }\n  }\n  cout << ans << \'\\n\';\n}\n']",,,"['combinatorics', 'dp', 'greedy', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Colorings and Dominoes.json,https://codeforces.com//blog/entry/89634,There are different solutions to this problem involving combinatorics and or dynamic programming but in my opinion it s a bit easier to look at the problem from the perspective of probability theory Let s suppose a coloring is already chosen Then it can be covered with dominoes greedily red and blue cells are independent from each other and for example red cells can be analyzed as a set of strips of them of different length Let s say that we cover each strip from left to right so in each strip the first domino covers the cells and the second domino the cells and and so on Let s calculate the value of the coloring that is the expected value of the coloring if it is chosen randomly Let it be then the answer is By linearity of expectation can be calculated as where is the set of all places we can use for a domino and is the probability that there is a domino in place in our domino covering which we construct greedily Each domino covers two adjacent cells so we can iterate on pairs of adjacent cells and for each pair find the probability that this pair is covered Let s suppose that we want to cover the cells and with a domino Then both of these cells should be red the length of the red strip before these cells should be even otherwise the cell will be paired with the cell The only thing we need to know in order to calculate the probability of these two conditions being true is the number of white cells before the cell which can be easily maintained Knowing the number of white cells before we can either use dynamic programming to calculate the required probability or do the math on several easy examples and try to notice the pattern if there are white cells before the current one the probability of that pair being covered with a domino let s call it is both these cells should be red if there is white cell before the current one the probability of that pair being covered with a domino let s call it is the cells and should be red but the cell before them should not be red is either the chosen two cells are red and the cell before them is not red or all four cells are red is and so on So knowing the number of white cells before and we easily calculate the probability of this pair being covered by a domino By summing up the probabilities over all pairs of adjacent white cells don t forget the vertical ones we get the average or expected value of the coloring All that s left is to multiply it by 
https://codeforces.com//contest/987/problem/C,186077,C,987C,987,C. Three displays,It is the middle of 2018 and Maria Stepanovna who lives outside Krasnokamensk a town in Zabaikalsky region wants to rent three displays to highlight an important problem There are n displays placed along a road and the i th of them can display a text with font size s i only Maria Stepanovna wants to rent such three displays with indices i j k that the font size increases if you move along the road in a particular direction Namely the condition s i s j s k should be held The rent cost is for the i th display is c i Please determine the smallest cost Maria Stepanovna should pay ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint s[3005], c[3005];\n\nint dp[4][3005];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> s[i];\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> c[i];\n\n\tfor (int i=1; i<=n; i++) {\n\t\tdp[1][i] = c[i];\n\t\tfor (int j=2; j<=3; j++) {\n\n\t\t\tdp[j][i] = 1123123123;\n\n\t\t\tfor (int k=1; k<i; k++)\n\t\t\t\tif (s[k] < s[i])\n\t\t\t\t\tdp[j][i] = min(dp[j][i], dp[j-1][k] + c[i]);\n\t\t}\n\t}\n\n\tint x=  *min_element(dp[3]+1, dp[3]+n+1);\n\tif (x == 1123123123)\n\t\tx = -1;\n\tcout << x;\n}']",,,"['brute force', 'dp', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Three displays.json,https://codeforces.com//blog/entry/59758,Let s fix j Now we can see that i and k are independent so we can find best i by iterating over all i j checking if s i s j holds and choosing the one with smallest c i Then do the same for k There are O n options for j for each of them we will do O n operations Total complexity is O n 2 
https://codeforces.com//contest/489/problem/C,17498,C,489C,489,C. Given Length and Sum of Digits...,You have a positive integer and a non negative integer Your task is to find the smallest and the largest of the numbers that have length and sum of digits The required numbers should be non negative integers written in the decimal base without leading zeroes ,"['#include<cstdio>\nusing namespace std;\nint arr[105];\nint main(){\n    int n, m;\n    scanf(""%d %d"", &n, &m);\n    if(n == 1 && m == 0)\n        puts(""0 0"");\n    else if(m == 0 || 9 * n < m)\n        puts(""-1 -1"");\n    else{\n        int tmp = m;\n        for(int i = 0 ; i < n ; i++){\n            if(tmp > 9) arr[i] = 9, tmp -= 9;\n            else arr[i] = tmp - 1 , tmp = 1;\n        }\n        arr[n-1]++;\n        for(int i = n-1 ; i >= 0 ; i--)\n            printf(""%d"", arr[i]);\n        putchar(\' \');\n        tmp = m;\n        int cnt = n;\n        while(cnt--){\n            if(tmp >= 9) printf(""9"");\n            else if(tmp > 0) printf(""%d"", tmp);\n            else putchar(\'0\');\n            tmp -= 9;\n        }\n        puts("""");\n    }\n    return 0;\n}\n']",,,"['dp', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Given Length and Sum of Digits....json,https://codeforces.com//blog/entry/14741,There is a greedy approach to solve the problem Just try first digit from lower values to higher in subtask to minimize number and check if it is possible to construct a tail in such a way that it satisfies rule about length sum You can use a function can m s that answers if it is possible to construct a sequence of length with the sum of digits Using the function can m s you can easily pick up answer digit by digit For the first part of problem to minimize number this part of code is The equation i 0 d 0 m 1 d 0 is needed to be careful with leading zeroes 
https://codeforces.com//contest/1935/problem/F,2510290,F,1935F,1935,F. Andrey s Tree,Master Andrey loves trees dagger very much so he has a tree consisting of n vertices But it s not that simple Master Timofey decided to steal one vertex from the tree If Timofey stole vertex v from the tree then vertex v and all edges with one end at vertex v are removed from the tree while the numbers of other vertices remain unchanged To prevent Andrey from getting upset Timofey decided to make the resulting graph a tree again To do this he can add edges between any vertices a and b but when adding such an edge he must pay a b coins to the Master s Assistance Center Note that the resulting tree vertex v Timofey has not yet decided which vertex v he will remove from the tree so he wants to know for each vertex 1 leq v leq n the minimum number of coins needed to be spent to make the graph a tree again after removing vertex v as well as which edges need to be added dagger A tree is an undirected connected graph without cycles ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,ans,sz[N],f[N];\nint gf(int x){while(x!=f[x])x=f[f[f[f[x]]]];return x;}\nvector<int>lk[N];\nint stk[N],tp;\nstruct dat{\n    int l,r;\n    dat operator+(const dat &z)\n    const{return{min(l,z.l),max(r,z.r)};}\n}bc[N],d[N];\nbitset<N>vs;\nvoid mg(int x,int y){\n    x=gf(x),y=gf(y);\n    if(x!=y){\n        if(sz[x]<sz[y])swap(x,y);\n        sz[f[y]=x]+=sz[y];\n        stk[++tp]=y,bc[tp]=d[x],d[x]=d[x]+d[y];\n    }\n}\nvoid rec(){\n    int x=stk[tp];\n    d[f[x]]=bc[tp--];\n    sz[f[x]]-=sz[x],f[x]=x;\n}\nstruct Eg{int x,y;}g[N];\nint gt;\nvoid sol(int l,int r){\n    if(l==r){\n        int i,y,k,lt=tp;\n        gt=0;\n        for(int x:lk[l]){\n            y=gf(x);\n            // printf(""_l:%d y:%d l:%d r:%d\\n"",l,y,d[y].l,d[y].r);\n            if(d[y].l>1&&d[y].l-1!=l){\n                k=gf(d[y].l-1);\n                g[++gt]={d[y].l-1,d[y].l};\n                mg(k,y);\n            }y=gf(x);\n            if(d[y].r<n&&d[y].r+1!=l){\n                k=gf(d[y].r+1);\n                g[++gt]={d[y].r,d[y].r+1};\n                mg(k,y);\n            }\n        }\n        for(int x:lk[l]){\n            y=gf(x);\n            if(d[y].r==l-1&&l<n){\n                g[++gt]={l-1,l+1};\n                break;\n            }\n        }\n        while(tp>lt)rec();\n        for(i=1,k=0;i<=gt;++i)k+=g[i].y-g[i].x;\n        printf(""%d %d\\n"",k,gt);\n        for(i=1;i<=gt;++i)printf(""%d %d\\n"",g[i].x,g[i].y);\n        puts("""");\n    }else{\n        int md=l+r>>1,lt=tp,i,x;\n        for(x=r;x>md;--x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(l,md);\n        for(x=r;x>md;--x)vs[x]=0;\n        while(tp>lt)rec();\n        for(x=l;x<=md;++x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(md+1,r);\n        for(x=l;x<=md;++x)vs[x]=0;\n        while(tp>lt)rec();\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<n;++i){\n            cin>>x>>y;\n            lk[x].push_back(y);\n            lk[y].push_back(x);\n        }\n        for(x=1;x<=n;++x)\n            sz[f[x]=x]=1,d[x]={x,x};\n        sol(1,n);\n        for(x=1;x<=n;++x)lk[x].clear();\n    }\n    return 0;\n}']",,,"['binary search', 'constructive algorithms', 'data structures', 'dfs and similar', 'dsu', 'greedy', 'implementation', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Andrey s Tree.json,https://codeforces.com//blog/entry/126662,TutorialLet s fix some vertex for which the answer is being calculated Suppose the degree of the vertex in the tree is then it s clear that it s necessary to add edges Consider the components that appear after removing Then the goal is to use the new edges to unite all the components into one using the minimum total cost This is the same as finding the minimum spanning tree in a graph where the vertices are the components that resulted from removing and for every an edge with a weight of is drawn between the components containing and Let s simulate Kruskal s algorithm for this graph Consider all the single weight edges in this graph It s clear that using the single weight edges the vertices with numbers will definitely end up in one component and the vertices with numbers will also end up in one component To unite these two components it would be optimal to add an edge It turns out that it s sufficient to consider only all the single weight edges and the edge Let s limit the number of single weight edges to For this in each component calculate and the minimum and maximum in the component respectively Claim among the single weight edges it s sufficient to consider edges of the form ProofFirst understand when it s necessary to add the edge Note that if there s at least one component such that then the edge won t be needed otherwise it will be This is quite easy to show by simulating Kruskal s algorithm Let We ll show that using edges all components will unite Go through the vertices from to and maintain the invariant that all vertices from to are in one component At this holds When is the minimum in some component then the edge will be added and since is in one component with will now also be When is not the minimum in some component then the minimum in the component will be in one component with the invariant holds meaning will also be in one component with Thus it turns out that all will be in one component Now consider an arbitrary Separately consider the prefix of vertices and the suffix Then similarly to it can be shown that for the prefix of vertices using edges of the form you can unite Similarly for the suffix of vertices using edges of the form you can unite Now if the edge is necessary then add it to the answer Otherwise there s at least one component such that meaning the prefix of vertices and the suffix will unite into one component Finding for each component is straightforward what remains is to determine which components are connected by the edges This can be done with binary search through the Euler tour of the tree After that Kruskal s algorithm can be initiated to calculate the answer Let s estimate the time complexity For a specific vertex the time complexity will be so the total time complexity is Depending on the implementation of the last step the problem can be solved in where is the inverse Ackermann function relative to 
https://codeforces.com//contest/1092/problem/D2,271423,D2,1092D2,1092,D2. Great Vova Wall  Version 2 ,Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence a of n integers with a i being the height of the i th part of the wall Vova can only use 2 times 1 bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighbouring parts of the wall of equal height It means that if for some i the current height of part i is the same as for part i 1 then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part 1 of the wall or to the right of part n of it Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,"['#include<cstdio>\nint m;\nint a[200000];\nint cnt[200000];\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++){\n        int x;\n        scanf(""%d"",&x);\n        while(m&&a[m-1]<x){\n            if(cnt[m-1]&1){\n                puts(""NO"");\n                return 0;\n            }\n            m--;\n        }\n        if(!m||a[m-1]!=x){\n            cnt[m]=1;\n            a[m++]=x;\n        }\n        else{\n            cnt[m-1]++;\n        }\n    }\n    for(int i=1;i<m;i++){\n        if(cnt[i]&1){\n            puts(""NO"");\n            return 0;\n        }\n    }\n    puts(""YES"");\n    return 0;\n}\n']",,,"['data structures', 'implementation']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D2. Great Vova Wall  Version 2 .json,https://codeforces.com//blog/entry/63961,Fairly enough solutions of both versions of the problem are pretty similar Read the second part of the previous tutorial first This problem can also be implemented in the strightforward manner The greedy solution now is searching for the first minimum in array and putting a brick in there If it s impossible then the answer is This can also be simulated with sets a bit more tedious but still ok and also Now back to the stack approach Here you can t go to parities of the numbers like tests and lead to different results You push the number itself However you will also need an extra condition on the stack You can t push to it the number greater than the current topmost element The only problem with this are maximums of array Obviously the resulting wall if the answer exists will be of height equal to the maximum initial height And it means that you shouldn t care about the ability to match all maximums in stack They way I suggest to take around the issue is to process separately each segment between two consecutive maximums One can easily prove the correctness of it by construction Overall complexity 
https://codeforces.com//contest/1926/problem/C,2485153,C,1926C,1926,C. Vlad and a Sum of Sum of Digits,Vladislav wrote the integers from 1 to n inclusive on the board Then he replaced each integer with the sum of its digits What is the sum of the numbers on the board now For example if n 12 then initially the numbers on the board are 1 2 3 4 5 6 7 8 9 10 11 12 Then after the replacement the numbers become 1 2 3 4 5 6 7 8 9 1 2 3 The sum of these numbers is 1 2 3 4 5 6 7 8 9 1 2 3 51 Thus for n 12 the answer is 51 ,"['#include<bits/stdc++.h>\nusing namespace std;\nint f[200010],g[200010];\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tfor(int i=1;i<=200010;i++)\n\t{\n\t\tf[i]=f[i/10]+i%10;\n\t\tg[i]=g[i-1]+f[i];\n\t}\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tcout<<g[n]<<""\\n"";\n\t}\n\t\n\treturn 0;\n}']",,,"['dp', 'implementation']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\C. Vlad and a Sum of Sum of Digits.json,https://codeforces.com//blog/entry/126132,Let s denote as the sum of digits of number Since for a single test case we can brute force and output the answer However since the number of test cases is large we can t compute this value for each time This needs a standard idea of precomputation we will compute the answer for each value from to and store it in an array Then to answer each test case we just output The precomputation takes time it takes time to find sum of digits but now we can answer queries in per test case so overall the complexity is 
https://codeforces.com//contest/1998/problem/E1,2808663,E1,1998E1,1998,E1. Eliminating Balls With Merging  Easy Version ,Sun Tzu You are given two integers n and x x n There are n balls lined up in a row numbered from 1 to n from left to right Initially there is a value a i written on the i th ball For each integer i from 1 to n we define a function f i as follows Suppose you have a set S 1 2 ldots i In each operation you have to select an integer l 1 leq l i from S such that l is not the largest element of S Suppose r is the smallest element in S which is greater than l If a l a r you set a l a l a r and remove r from S If a l a r you set a r a l a r and remove l from S If a l a r you choose either the integer l or r to remove from S If you choose to remove l from S you set a r a l a r and remove l from S If you choose to remove r from S you set a l a l a r and remove r from S f i denotes the number of integers j 1 le j le i such that it is possible to obtain S j after performing the above operations exactly i 1 times For each integer i from x to n you need to find f i ,"['#include <bits/stdc++.h>using namespace std;\xa0#define int long long\xa0const int INF=0x3f3f3f3f3f3f3f3f;const int N=2e5+5;\xa0int lc[N], rc[N], stk[N], sum[N], a[N], n;\xa0struct Segment_Tree1{\tint L[N*4], R[N*4], add[N*4], Min[N*4], cnt[N*4], val[N];\xa0\tSegment_Tree1()\t{\t\tmemset(L,0,sizeof(L));\t\tmemset(R,0,sizeof(R));\t\tmemset(add,0,sizeof(add));\t\tmemset(Min,0,sizeof(Min));\t\tmemset(cnt,0,sizeof(cnt));\t\tmemset(val,0,sizeof(val));\t}\xa0\tvoid pushup(int rt)\t{\t\tMin[rt]=min(Min[rt*2],Min[rt*2+1]);\t\tcnt[rt]=0;\t\tif(Min[rt]==Min[rt*2])\t\t\tcnt[rt] += cnt[rt*2];\t\tif(Min[rt]==Min[rt*2+1])\t\t\tcnt[rt] += cnt[rt*2+1];\t}\xa0\tvoid Add(int rt,int val)\t{\t\tadd[rt] += val;\t\tMin[rt] += val;\t}\xa0\tvoid pushdown(int rt)\t{\t\tif(add[rt])\t\t{\t\t\tAdd(rt*2,add[rt]);\t\t\tAdd(rt*2+1,add[rt]);\t\t\tadd[rt]=0;\t\t}\t}\xa0\tvoid update(int rt,int l,int r,int val)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t{\t\t\tAdd(rt,val);\t\t\treturn;\t\t}\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l<=mid)\t\t\tupdate(rt*2,l,r,val);\t\tif(mid+1<=r)\t\t\tupdate(rt*2+1,l,r,val);\t\tpushup(rt);\t}\xa0\tpair<int,int> query(int rt,int l,int r)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t\treturn make_pair(Min[rt],cnt[rt]);\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l>mid)\t\t\treturn query(rt*2+1,l,r);\t\tif(mid+1>r)\t\t\treturn query(rt*2,l,r);\xa0\t\tpair <int,int> L=query(rt*2,l,r);\t\tpair <int,int> R=query(rt*2+1,l,r);\t\tpair <int,int> ans=make_pair(min(L.first,R.first),0);\t\tif(L.first==ans.first)\t\t\tans.second += L.second;\xa0\t\tif(R.first==ans.first)\t\t\tans.second += R.second;\t\treturn ans;\t}\xa0\tint lstpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn 0;\xa0\t\tif(L[rt]==R[rt])\t\t\treturn L[rt];\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn lstpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn lstpos(rt*2+1,l,r,val);\xa0\t\tint rans=lstpos(rt*2+1,l,r,val);\t\tif(rans==0)\t\t\treturn lstpos(rt*2,l,r,val);\t\treturn rans;\t}\xa0\tint firpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn n+1;\xa0\t\tif(L[rt]==R[rt])\t\t\treturn L[rt];\xa0\t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn firpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn firpos(rt*2+1,l,r,val);\xa0\t\tint lans=firpos(rt*2,l,r,val);\t\tif(lans==n+1)\t\t\treturn firpos(rt*2+1,l,r,val);\t\treturn lans;\t}\xa0\tvoid build(int rt,int l,int r)\t{\t\tL[rt]=l, R[rt]=r, add[rt]=0;\t\tif(l==r)\t\t{\t\t\tMin[rt]=val[l], cnt[rt]=1;\t\t\treturn;\t\t}\xa0\t\tint mid=(l+r)/2;\t\tbuild(rt*2,l,mid);\t\tbuild(rt*2+1,mid+1,r);\t\tpushup(rt);\t}}tr1, tr2, tr3;\xa0int L[N*35], R[N*35], indx;bool del[N*35];\xa0struct Segment_Tree2{\tvector <int> vec[N*4];\xa0\tvoid update(int rt,int l,int r,int ql,int qr,int val)\t{\t\tif(ql<=l && r<=qr)\t\t{\t\t\tvec[rt].push_back(val);\t\t\treturn;\t\t}\xa0\t\tint mid=(l+r)/2;\t\tif(ql<=mid)\t\t\tupdate(rt*2,l,mid,ql,qr,val);\t\tif(mid+1<=qr)\t\t\tupdate(rt*2+1,mid+1,r,ql,qr,val);\t}\xa0\tvoid query(int rt,int l,int r,int pos)\t{\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\tvec[rt].clear();\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tquery(rt*2,l,mid,pos);\t\telse\t\t\tquery(rt*2+1,mid+1,r,pos);\t}\xa0\tvoid queryl(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(L[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec);\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryl(rt*2,l,mid,pos);\t\telse\t\t\tqueryl(rt*2+1,mid+1,r,pos);\t}\xa0\tvoid queryr(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(R[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec);\xa0\t\tif(l==r)\t\t\treturn;\xa0\t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryr(rt*2,l,mid,pos);\t\telse\t\t\tqueryr(rt*2+1,mid+1,r,pos);\t}}tr4;\xa0void dfs(int l,int r,int root){\tif(l>r)\t\treturn;\xa0\tif(sum[r]-sum[l-1]<a[l-1] && sum[r]-sum[l-1]<a[r+1])\t{\t\tindx++, L[indx]=l, R[indx]=r;\t\ttr4.update(1,1,n,l,r,indx);\t\ttr1.update(1,l,r,1);\t}\xa0\tdfs(l,root-1,lc[root]);\tdfs(root+1,r,rc[root]);}\xa0void build(){\ta[0]=a[n+1]=INF;\tint top=0, root=0;\tfor(int i=1;i<=n;i++)\t{\t\tstk[top+1]=0;\t\twhile(top && a[stk[top]]<=a[i])\t\t\ttop--;\xa0\t\tif(top)\t\t\trc[stk[top]]=i;\t\telse\t\t\troot=i;\xa0\t\tlc[i]=stk[top+1];\t\tstk[++top]=i;\t}\xa0\tdfs(1,n,root);}\xa0int c[N];\xa0int query_sum(int x){\tint ans=0;\tfor(int i=x;i;i-=i&-i)\t\tans += c[i];\treturn ans;}\xa0void update_sum(int x,int y){\tfor(int i=x;i<=n;i+=i&-i)\t\tc[i] += y;}\xa0void work(){\tint x;\tcin >> n >> x;\tfor(int i=1;i<=indx;i++)\t\tL[i]=R[i]=del[i]=0;\tindx=0;\xa0\tfor(int i=0;i<=n;i++)\t\tc[i]=lc[i]=rc[i]=sum[i]=a[i]=stk[i]=0;\xa0\tfor(int i=0;i<=n*4;i++)\t\ttr4.vec[i].clear();\xa0\tfor(int i=1;i<=n;i++)\t{\t\tscanf(""%lld"",&a[i]);\t\tupdate_sum(i,a[i]);\t\tsum[i]=sum[i-1]+a[i];\t}\xa0\tfor(int i=1;i<=n;i++)\t{\t\ttr2.val[i]=sum[i-1]-a[i];\t\ttr3.val[i]=-a[i]-sum[i];\t}\xa0\ttr1.build(1,1,n), tr2.build(1,1,n), tr3.build(1,1,n);\tbuild();\xa0\tfor(int i=x;i<=n;i++)\t{\t\tint l=1, r=i;\t\tif(l==r)\t\t{\t\t\tprintf(""1\\n"");\t\t\tcontinue;\t\t}\xa0\t\tint pos1=tr2.lstpos(1,l+1,r,query_sum(l-1))-1;\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,1);\xa0\t\tint pos2=tr3.firpos(1,l,r-1,-query_sum(r))+1;\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,1);\xa0\t\tprintf(""%lld\\n"",tr1.query(1,l,r).second);\xa0\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,-1);\xa0\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,-1);\t}}\xa0signed main(){\tint T;\tcin >> T;\twhile(T--)\t\twork();\treturn 0;}']",,,"['binary search', 'brute force', 'data structures', 'divide and conquer', 'greedy']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E1. Eliminating Balls With Merging  Easy Version .json,https://codeforces.com//blog/entry/132512,Notice that at any point all the elements are sum of continous subarray Hint 2 Define a function solve L R which returns true if we can convert element with weight AL AL 1 AR into an element with weight A Hint 3 Use greedy for fixed index L and R find a minimum nxtL such that AnxtL AnxtL 1 AL 1 AL AL 1 AR make a direct jump to nxtL R segment Hint 4 Do similar for nxtR and memorise all the answer of solve function 
https://codeforces.com//contest/1029/problem/B,211257,B,1029B,1029,B. Creating the Contest,You are given a problemset consisting of n problems The difficulty of the i th problem is a i It is guaranteed that all difficulties are distinct and are given in the increasing order You have to assemble the contest which consists of some problems of the given problemset In other words There is only one condition that should be satisfied for each problem but the hardest one the problem with the maximum difficulty there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem In other words let a i 1 a i 2 dots a i p be the difficulties of the selected problems in increasing order Then for each j from 1 to p 1 a i j 1 le a i j cdot 2 should hold Among all contests satisfying the condition above you have to assemble one with the maximum number of problems Your task is to find this number of problems ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n\nint n,a[200005],mx,cur;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    mx=cur=1;\n    for(int i=2;i<=n;i++){\n        if(a[i]>2*a[i-1]) cur=1;\n        else cur++;\n        mx=max(mx,cur);\n    }\n    cout << mx;\n}\n']",,,"['dp', 'greedy', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Creating the Contest.json,https://codeforces.com/blog/entry/61439,The answer is always a segment of the initial array The authors solution uses two pointers technique let s iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest Let s iterate over all from to and let the current left bound be Let be the maximum right bound of the correct contest starting from the position Initially Now while and let s increase Try to update the answer with the value It is obvious that all positions from to cannot be left bounds of the maximum by inclusion correct contests so let s set and go on Because each element will be processed once time complexity is 
https://codeforces.com//contest/1485/problem/E,893888,E,1485E,1485,E. Move and Swap,You are given n 1 integers a 2 dots a n and a tree with n vertices rooted at vertex 1 The leaves are all at the same distance d from the root Recall that a tree is a connected undirected graph without cycles The distance between two vertices is the number of edges on the simple path between them All non root vertices with degree 1 are leaves If vertices s and f are connected by an edge and the distance of f from the root is greater than the distance of s from the root then f is called a child of s Initially there are a red coin and a blue coin on the vertex 1 Let r be the vertex where the red coin is and let b be the vertex where the blue coin is You should make d moves A move consists of three steps Move the red coin to any child of r Move the blue coin to any vertex b such that dist 1 b dist 1 b 1 Here dist x y indicates the length of the simple path between x and y Note that b and b are not necessarily connected by an edge You can optionally swap the two coins or skip this step Note that r and b can be equal at any time and there is no number written on the root After each move you gain a r a b points What s the maximum number of points you can gain after d moves ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint T,n,a[200005],d[200005],mxd,l[200005],r[200005];\nll f[200005];\nvector<int> v[200005],D[200005];\nvoid dfs(int x,int y){\n\tD[d[x]=d[y]+1].pb(x);\n\tif(d[x]>mxd)mxd=d[x];\n\tl[d[x]]=min(l[d[x]],a[x]);\n\tr[d[x]]=max(r[d[x]],a[x]);\n\tfor(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;++i)v[i].clear(),D[i].clear(),l[i]=orz,r[i]=-orz;\n\t\tmxd=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tv[x].pb(i),v[i].pb(x);\n\t\t}\n\t\tfor(int i=2;i<=n;++i)scanf(""%d"",a+i);\n\t\tdfs(1,0);\n\t\tfor(int i=0;i<D[mxd].size();++i){\n\t\t\tint x=D[mxd][i];\n\t\t\tf[x]=max(r[mxd]-a[x],a[x]-l[mxd]);\n\t\t}\n\t\tfor(int k=mxd-1;k;--k){\n\t\t\tll L=-orz*1ll*orz,R=-orz*1ll*orz;\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=-orz*1ll*orz;\n\t\t\t\tfor(int j=0;j<v[x].size();++j){\n\t\t\t\t\tint y=v[x][j];\n\t\t\t\t\tif(d[y]<d[x]) continue;\n\t\t\t\t\tf[x]=max(f[x],f[y]);\n\t\t\t\t}\n\t\t\t\tL=max(L,f[x]-a[x]);\n\t\t\t\tR=max(R,f[x]+a[x]);\n\t\t\t\tf[x]+=max(r[k]-a[x],a[x]-l[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=max(f[x],max(L+a[x],R-a[x]));\n\t\t\t}\n\t\t}\n\t\tprintf(""%I64d\\n"",f[1]);\n\t}\n    return 0;\n}\n']",,,"['dfs and similar', 'dp', 'greedy', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Move and Swap.json,https://codeforces.com//blog/entry/87470,SolutionDivide the nodes in groups based on the distance from the root Then for each in increasing order calculate the maximum score that you can reach after moves if there is a red coin on node after step You can calculate if you know for each that belongs to the previous group There are two cases if after step the coin on node is red the previous position of the red coin is fixed and the blue coin should reach either the minimum or the maximum among the that belong to the same group of if after step the coin on node is blue there is a red coin on node so you have to maximize the score This can be done efficiently by sorting the in the current group and calculating the answer separately for and for each in the group the optimal node either doesn t change or it s the previous node Alternatively you can notice that and you can maximize both and greedily by choosing the maximum and respectively In this solution you don t need to sort the The answer is Complexity or 
https://codeforces.com//contest/1841/problem/B,1962591,B,1841B,1841,B. Keep it Beautiful,The array a 1 a 2 dots a k is called if it is possible to remove several maybe zero elements from the beginning of the array and insert all these elements to the back of the array in the same order in such a way that the resulting array is sorted in non descending order In other words the array a 1 a 2 dots a k is if there exists an integer i in 0 k 1 such that the array a i 1 a i 2 dots a k 1 a k a 1 a 2 dots a i is sorted in non descending order For example 3 7 7 9 2 3 is we can remove four first elements and insert them to the back in the same order and we get the array 2 3 3 7 7 9 which is sorted in non descending order 1 2 3 4 5 is we can remove zero first elements and insert them to the back and we get the array 1 2 3 4 5 which is sorted in non descending order 5 2 2 1 is not You are given an array a which is initially You have to process q queries to it During the i th query you will be given one integer x i and you have to do the following if you can append the integer x i to the of the array a so that the array a stays you have to append it otherwise do nothing After each query report whether you appended the given integer x i or not ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << "" ""; cout << v[i];\n    }\n    cout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\n\nvoid solve() {\n    int q; cin >> q;\n    vector<int> v;\n    bool isb = false;\n    string ans;\n    rep(i, q) {\n        int x; cin >> x;\n        bool canadd;\n        if (!isb) {\n            if (v.size() && v.back() > x && x > v[0]) {\n                canadd = false;\n            }\n            else {\n                canadd = true;\n            }\n        }\n        else {\n            if (v.back() <= x && x <= v[0])canadd = true;\n            else canadd = false;\n        }\n        if (canadd) {\n            ans.push_back(\'1\');\n            if (v.size() && v.back() > x)isb = true;\n            v.push_back(x);\n        }\n        else {\n            ans.push_back(\'0\');\n        }\n    }\n    cout << ans << ""\\n"";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}']",,,['implementation'],1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Keep it Beautiful.json,https://codeforces.com//blog/entry/117262,First notice that the given operation is a cyclic shift of the array So we can treat the array as cyclic meaning element is a neighbor of element Let s try to rephrase the condition for the beautiful array What does it mean for the array to be sorted For all from to should hold If they do then you can choose leave the array as is What if there are such that If there is only one such then we might still be able to fix the array choose However that will make a pair and cyclically shift into the array So should hold If there are at least two such or just one but then we can show that it s impossible to make the array sorted Since there are at least two pairs of neighboring elements that are not sorted at least one of them will still be in the array after any cyclic shift Thus we can maintain the number of such that and check if every time if the count is exactly Overall complexity per testcase 
https://codeforces.com//contest/1819/problem/F,1880637,F,1819F,1819,"F. Willy-nilly, Crack, Into Release ",You have long dreamed of working in a large IT company and finally got a job there You have studied all existing modern technologies for a long time and are ready to apply all your knowledge in practice But then you sit down at your desk and see a sheet of paper with the company s motto printed in large letters The company s motto contains four main principles Willi Nilli Crack Release Therefore you consider strings of length n consisting of these four Latin letters pairs of letters and in this motto are adjacent so we will call such pairs of symbols So if you are given a string s of length n and it is known that the unordered pair of symbols x y is good then you can perform one of the following operations on the string if s n x then you are allowed to replace this symbol with y if there exists 1 le i n such that s i x and s i 1 ldots s n y then you are allowed to replace the i th symbol of the string with y and all subsequent symbols with x For example the string can be replaced with one of the strings or and the string can be replaced with or A non empty sequence of operations for the string s will be called if the following two conditions are met after performing all operations the string becomes s again no string except for s will occur more than once during the operations At the same time the string s can occur exactly twice before the start of the operations and after performing all operations Now we are ready to move on to the problem statement You have a set of strings that is initially empty Then each of q queries adds another string t i to the set or removes the string t i from the set After each query you need to output the minimum and maximum size of a correct sequence of operations in which each word occurs at least once The choice of the initial string s is up to you ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nstruct N{\n\tN*to[4];\n\tint cnt=0,mn[4][4],mx[4][4];\n\tN(){\n\t\trep(i,4)to[i]=0;\n\t\trep(i,4)rep(j,4)mn[i][j]=inf;\n\t\trep(i,4)rep(j,4)mx[i][j]=-inf;\n\t}\n\tint gmi(int x,int y){\n\t\treturn min(mn[x][y],mn[y][x]);\n\t}\n\tint gma(int x,int y){\n\t\treturn max(mx[x][y],mx[y][x]);\n\t}\n\tvoid upd(){\n\t\tcnt=0;\n\t\trep(i,4)cnt+=to[i]->cnt;\n\t\trep(i,4){\n\t\t\tint cs=0,mis=0,mas=0;\n\t\t\tint x=i,y=i;\n\t\t\trep(_,4){\n\t\t\t\tint z=(y+1);\n\t\t\t\tif(z==4)z=0;\n\t\t\t\t\n\t\t\t\tcs+=to[y]->cnt;\n\t\t\t\tif(cs==cnt){\n\t\t\t\t\tmn[i][y]=mis+to[y]->gmi(x,y);\n\t\t\t\t\tmx[i][y]=mas+to[y]->gma(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tmn[i][y]=inf;\n\t\t\t\t\tmx[i][y]=-inf;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmis+=to[y]->gmi(x,z);\n\t\t\t\tmas+=to[y]->gma(x,z);\n\t\t\t\tchmin(mis,inf);\n\t\t\t\tchmax(mas,-inf);\n\t\t\t\tx=y;y=z;\n\t\t\t}\n\t\t}\n\t\trep(i,4)rep(j,4)chmin(mn[i][j],inf);\n\t\trep(i,4)rep(j,4)chmax(mx[i][j],-inf);\n\t}\n};\nconst int nmax=20;\nconst int qmax=100010;\nconst int smax=(nmax+1)*qmax;\nN buf[smax];\nint bufused=0;\nN* nn(){\n\treturn buf+bufused++;\n}\n\nvoid add(N*&cur,int i,const string&s){\n\t{\n\t\tN*tmp=nn();\n\t\t*tmp=*cur;\n\t\tcur=tmp;\n\t}\n\tif(i==si(s)){\n\t\tcur->cnt^=1;\n\t}else{\n\t\tint k=s[i]-\'a\';\n\t\tadd(cur->to[k],i+1,s);\n\t\tcur->upd();\n\t}\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tN* root;\n\t{\n\t\tvc<N*> ls(n+1);\n\t\trep(i,n+1)ls[i]=nn();\n\t\trep(i,4)rep(j,4){\n\t\t\tls[n]->mn[i][j]=1;\n\t\t\tls[n]->mx[i][j]=1;\n\t\t}\n\t\tper(i,n){\n\t\t\trep(j,4)ls[i]->to[j]=ls[i+1];\n\t\t\tls[i]->upd();\n\t\t}\n\t\troot=ls[0];\n\t}\n\trep(_,q){\n\t\tadd(root,0,readString());\n\t\tint tot=root->cnt;\n\t\tint mn=inf,mx=-inf;\n\t\tN*cur=root;\n\t\trep(lv,n){\n\t\t\tassert(cur->cnt==tot);\n\t\t\t//0-1-2-3\n\t\t\t{\n\t\t\t\tint mis=0,mas=0;\n\t\t\t\trep(y,4){\n\t\t\t\t\tint x=(y+3)%4,z=(y+1)%4;\n\t\t\t\t\tmis+=cur->to[y]->gmi(x,z);\n\t\t\t\t\tmas+=cur->to[y]->gma(x,z);\n\t\t\t\t\tchmin(mis,inf);\n\t\t\t\t\tchmax(mas,-inf);\n\t\t\t\t}\n\t\t\t\tchmin(mn,mis);\n\t\t\t\tchmax(mx,mas);\n\t\t\t}\n\t\t\trep(y,4){\n\t\t\t\tint z=(y+1)%4;\n\t\t\t\tif(cur->to[y]->cnt+cur->to[z]->cnt==cur->cnt){\n\t\t\t\t\tchmin(mn,cur->to[y]->gmi(z,z)+cur->to[z]->gmi(y,y));\n\t\t\t\t\tchmax(mx,cur->to[y]->gma(z,z)+cur->to[z]->gma(y,y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool upd=false;\n\t\t\trep(y,4){\n\t\t\t\tif(cur->to[y]->cnt==cur->cnt){\n\t\t\t\t\tcur=cur->to[y];\n\t\t\t\t\tupd=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!upd)break;\n\t\t}\n\t\tif(mn<=mx)print(mn,mx);\n\t\telse print(-1);\n\t}\n\t/*{\n\t\tN* cur=root;\n\t\tcur=cur->to[0];\n\t\tdmp(cur->mx[3][1]);\n\t\tdmp(cur->mx[1][3]);\n\t\tdmp(cur->mn[3][1]);\n\t\tdmp(cur->mn[1][3]);\n\t\tdmp(cur->to[1]->mn[1][2]);\n\t\tdmp(cur->to[2]->mn[1][3]);\n\t\tdmp(cur->to[3]->mn[2][3]);\n\t}*/\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']",,,"['data structures', 'dp']",3500,"D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Willy-nilly, Crack, Into Release .json",https://codeforces.com//blog/entry/115133,There are two ways to approach this problem Let s start with a solution that does not involve associations with known images Consider a cyclic sequence of strings that satisfies the condition of the problem Consider the longest common prefix of all the strings in this sequence It is not very interesting to us since by definition it does not change with the operations There are two cases Either the sequence of operations has a length of when we perform some action and then immediately cancel it with a second action This case is only possible if there are no more than two important strings in the set In this case the required condition can be easily checked in time Otherwise our sequence consists of more than two operations and this is much more like a cycle Let s say for example that the first non constant character in the sequence of strings initially equals Then after the first change it will be equal to either or Note that after this the first character will no longer be able to immediately turn into since the only way to do this is to cancel the operation but this is only possible in the first case Thus the first character will be required to go around the cycle This cycle can be divided into four segments based on the value of the first character of the string In each of these segments we are interested in the sequence of operations that transforms the string with the suffix into a string that matches the original in the prefix but its suffix is where and the pair of characters is good With the help of a not very complicated analysis of cases we can see that for each prefix we are interested in groups of paths that connect strings whose characters except for the suffix being considered match and these paths visit all important strings with the prefix being considered Within each group of paths we are interested in the minimum and maximum path respectively Note that these values can be easily calculated using dynamic programming We can calculate all these states in time Then we need to iterate over the length of the common prefix of all the strings and answer the query in time So far we can only calculate the states of interest to us in some galactic time But this is not entirely scary Let s say for example that when we add or remove one string from the set of important strings only states change since only the states responsible for the prefixes of the added deleted string will change To some extent this is reminiscent of a segment tree or rather a quadtree We just need to figure out how to get rid of the term in the asymptotic complexity But this is also simple Let s notice that if there are no strings with the given prefix in the set of important strings then the states responsible for this prefix will depend only on the length of the remaining suffix and all these values can be precomputed in time Thus we store a trie with strings from the queries in each node of which we store the state of the dynamic programming and in case we need the values of the dynamic programming from non existent trie nodes during recalculation we can replace them with precomputed values Time complexity The author s code is not very complicated but if you suddenly want to understand it I warn you that it uses several hacks of questionable justification For example instead of dynamic programming states only really useful ones are stored there The combinatorial structure is used to simplify the support of simultaneous maximum and minimum values and much more I think that it will be especially useful for beginners to familiarize themselves with how to simplify their lives in implementing combinatorial problems Now let s turn to the geometric interpretation of the problem Imagine a square with a size of In its corners we can draw squares with sizes of each Let s say that strings starting with the character go to the upper left square strings starting with the character go to the upper right the character corresponds to the lower right corner and the character corresponds to the lower left Then we can divide the four resulting squares into four parts each in the same way and divide the strings by corners already by the second character and so on In the end each string is associated with an integer point with coordinates from the interval We also have lines from the drawn squares which are naturally divided into vertical and horizontal segments of length each This picture is useful because it depicts a graph whose vertices correspond to the strings being considered and its edges connect pairs of strings that are obtained from each other by means of one move Thus looking at the picture much of the structure of simple cycles in the problem being considered becomes clear and obvious and with the help of such a picture it is much easier to describe the transitions in the dynamic programming and not get confused 
https://codeforces.com//contest/1753/problem/A1,1601075,A1,1753A1,1753,A1. Make Nonzero Sum  easy version ,You are given an array a 1 a 2 ldots a n consisting of integers 1 and 1 You have to build a partition of this array into the set of segments l 1 r 1 l 2 r 2 ldots l k r k with the following property Denote the alternating sum of all elements of the i th segment as s i s i a l i a l i 1 a l i 2 a l i 3 ldots pm a r i For example the alternating sum of elements of segment 2 4 in array 1 0 1 1 1 equals to 0 1 1 2 The sum of s i over all segments of partition should be equal to zero Note that each s i does have to be equal to zero this property is about sum of s i over all segments of partition The set of segments l 1 r 1 l 2 r 2 ldots l k r k is called a of the array a of length n if 1 l 1 le r 1 l 2 le r 2 ldots l k le r k n and r i 1 l i 1 for all i 1 2 ldots k 1 In other words each element of the array must belong to exactly one segment You have to build a partition of the given array with properties described above or determine that such partition does not exist Note that it is required to minimize the number of segments in the partition ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    if (n % 2) {\n        std::cout << -1 << ""\\n"";\n        return;\n    }\n    \n    std::vector<std::array<int, 2>> ans;\n    for (int i = 0; i < n; i += 2) {\n        if (a[i] == a[i + 1]) {\n            ans.push_back({i, i + 1});\n        } else {\n            ans.push_back({i, i});\n            ans.push_back({i + 1, i + 1});\n        }\n    }\n    \n    std::cout << ans.size() << ""\\n"";\n    for (auto [x, y] : ans) {\n        std::cout << x + 1 << "" "" << y + 1 << ""\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']",,,"['constructive algorithms', 'dp', 'greedy']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A1. Make Nonzero Sum  easy version .json,https://codeforces.com//blog/entry/108336,If the sum of all elements of the array is odd the partitions does not exist because the partition does not affect the parity of the sum Otherwise the answer exists Let s build such construction As the sum of all elements is even is even too Consider pairs of elements with indices Consider the pair If add the segment to the answer In this case the alternating sum of elements of this segment will be equal to Otherwise we will add two segments to the answer and The sum of the first segment is and the sum of the second segment is The sum of two sums will be equal to zero So the sum of all alternating sums will be equal to zero 
https://codeforces.com//contest/1979/problem/A,2684279,A,1979A,1979,A. Guess the Maximum,Alice and Bob came up with a rather strange game They have an array of integers a 1 a 2 ldots a n Alice chooses a certain integer k and tells it to Bob then the following happens Bob chooses two integers i and j 1 le i j le n and then finds the maximum among the integers a i a i 1 ldots a j If the obtained maximum is than k Alice wins otherwise Bob wins Help Alice find the maximum k at which she is guaranteed to win ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));const int MAXN=5e5+5;int n,a[MAXN];void solve(){\tcin>>n;\tfor(int i=1;i<=n;i++) cin>>a[i];\tint ans=1e9;\tfor(int i=1;i<n;i++) ans=min(ans,max(a[i],a[i+1]));\tcout<<ans-1<<\'\\n\';}int main(){\tios::sync_with_stdio(false);\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}']",,,"['brute force', 'greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Guess the Maximum.json,https://codeforces.com//blog/entry/130213,SolutionLet be the maximum among the numbers Notice that there always exists such that and or Therefore we can assume that Bob always chooses the pair of numbers and as and Therefore you need to consider the maximums in pairs of adjacent elements and take the minimum among them Let be the found minimum then it is obvious that the answer is equal to 
https://codeforces.com//contest/759/problem/E,89814,E,759E,759,E. Byteland coins,There are types of coins in Byteland Conveniently the denomination of the coin type divides the denomination of the coin type the denomination of the coin type equals tugrick The ratio of the denominations of coin types and equals It is known that for each there are at most coin types of denomination Byteasar has coins of type with him and he needs to pay exactly tugricks It is known that Byteasar never has more than coins with him Byteasar want to know how many ways there are to pay exactly tugricks Two ways are different if there is an integer such that the amount of coins of type differs in these two ways As all Byteland citizens Byteasar wants to know the number of ways modulo ,"['#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, ""/stack:16777216"")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <assert.h>\n#include <time.h>\n#include <complex.h>\n\n\n#include <fstream>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<Int, Int> PII;\n\nconst int INF = 1000000000;\nconst int MAX = 300007;\nconst int MAXD = 20;\nconst int MOD = 1000000007;\n\nconst int BASE = 1000*1000*1000;\n\nVI read(string s)\n{\n    VI a;\n    for (int i=(int)s.length(); i>0; i-=9)\n        if (i < 9)\n            a.push_back (atoi (s.substr (0, i).c_str()));\n        else\n            a.push_back (atoi (s.substr (i-9, 9).c_str()));\n    return a;\n}\n\nint div(VI & a, int b)\n{\n    if (b == 1)\n    {\n        return 0;\n    }\n        \n    \n    if (b == BASE)\n    {\n        int carry = a[0];\n        if (SZ(a) > 0)\n        {\n            a.erase(a.begin());\n        }\n        return carry;\n    }\n    \n    int carry = 0;\n    for (int i=(int)a.size()-1; i>=0; --i) {\n        long long cur = a[i] + carry * 1ll * BASE;\n        a[i] = int (cur / b);\n        carry = int (cur % b);\n    }\n    while (a.size() > 1 && a.back() == 0)\n        a.pop_back();\n    return carry;\n}\n\nVI A[MAX];\nVI C;\nint a[MAX];\nVI B;\n\nint dp[2][MAX];\nint b[MAX];\n\n\nint main()\n{\n    //freopen(""in.txt"" , ""r"" , stdin);\n    //freopen(""out.txt"" , ""w"" , stdout);\n    \n    int n;\n    cin >> n;\n    FOR(i,1,n)\n    {\n        scanf(""%d"", &a[i]);\n    }\n\n    \n    \n    FOR(i,0,n)\n    {\n        scanf(""%d"", &b[i]);\n    }\n    \n    string s;\n    cin >> s;\n    VI num = read(s);\n    FOR(i,1,n)\n    {\n        B.push_back(div(num , a[i]));\n    }\n    if (SZ(num) > 1)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    B.push_back(num[0]);\n    \n    int sz = b[0] + 1;\n    int prev = 0;\n    int next = 1;\n    FOR(i,0,sz)\n    {\n        dp[prev][i] = 1;\n    }\n    \n    FOR(i,0,n - 1)\n    {\n        VI t;\n        int idd = 0;\n        for(int j = B[i]; j < sz; j += a[i + 1])\n        {\n            dp[next][idd ++] = dp[prev][j];\n        }\n        if (idd == 0)\n        {\n            cout << 0 << endl;\n            return 0;\n        }\n        sz = idd;\n        swap(prev , next);\n        int x = b[i + 1];\n        \n        FOR(j,0,sz + b[i + 1])\n        {\n            dp[next][j] = 0;\n            if (j) dp[next][j] = dp[next][j - 1];\n            if (j < sz)\n            {\n                dp[next][j] += dp[prev][j];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n            if (j - x - 1 >= 0)\n            {\n                dp[next][j] += MOD - dp[prev][j - x - 1];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n        }\n        swap(prev , next);\n        sz += x;\n        \n    }\n    \n    if (B[n - 1] >= sz)\n    {\n        cout << 0 << endl;\n    }\n    else\n    {\n        cout << dp[prev][B[n - 1]] << endl;\n    }\n        \n    \n    \n    return 0;\n}\n']",,,"['dp', 'math']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Byteland coins.json,https://codeforces.com//blog/entry/49946,Let s calculate DP pref x number of ways to pay x tugriks using only pref first types Of course x can be very big but we will store DP only for those x which are not bigger than the sum of all the coins of first pref types and can lead to answer x k D m D where D is the last coin denomination Every next layer of this DP can be calculated in O szi time using prefix sums where sz is the size of the new layer Now all that remains is to calculate some info about m D to know what DP elemnts we are interested in We should represent m in a form of i 1nci Di To find ci we should successively divide m by all ai ci will be the reminders All the divisions can be done in time if we will not divide by 1 
https://codeforces.com//contest/1436/problem/E,772600,E,1436E,1436,E. Complicated Computations,In this problem MEX of a certain array is the smallest integer not contained in this array Everyone knows this definition including Lesha But Lesha loves MEX so he comes up with a new problem involving MEX every day including today You are given an array a of length n Lesha considers all the subarrays of the initial array and computes MEX for each of them Then Lesha computes MEX of the obtained numbers An array b is a subarray of an array a if b can be obtained from a by deletion of several possible none or all elements from the beginning and several possibly none or all elements from the end In particular an array is a subarray of itself Lesha understands that the problem is very interesting this time but he doesn t know how to solve it Help him and find the MEX of MEXes of all the subarrays ,"['//#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\n#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include ""debug-template.hpp""\n#endif\n\nusing namespace std;\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tvector<int> last(n + 2), mex(n + 2);\n\tint N = 1;\n\twhile (N <= n + 2) {\n\t\tN *= 2;\n\t}\n\tvector<int> d(N + N);\n\tauto update = [&](int u, int x) {\n\t\td[u += N] = x;\n\t\tfor (u >>= 1; u; u >>= 1) {\n\t\t\td[u] = min(d[u + u], d[u + u + 1]);\n\t\t}\n\t};\n\tauto query = [&](int l, int r) {\n\t\tl += N, r += N + 1;\n\t\tint ret = 1e9;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tret = min(ret, d[l]);\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tret = min(ret, d[r - 1]);\n\t\t\t}\n\t\t\tl = l + 1 >> 1, r >>= 1;\n\t\t}\n\t\treturn ret;\n\t};\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] == 1) {\n\t\t\tif (last[1] + 1 < i) {\n\t\t\t\tmex[1] = 1;\n\t\t\t}\n\t\t} else if (query(1, a[i] - 1) > last[a[i]]) {\n\t\t\tmex[a[i]] = 1;\n\t\t}\n\t\tlast[a[i]] = i;\n\t\tupdate(a[i], i);\n\t}\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tif (mex[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tif (last[i] < n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (query(1, i - 1) > last[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tcout << i << endl;\n\t\treturn 0;\n\t}\n\tcout << n + 2 << endl;\n\treturn 0;\n}\n']",,,"['binary search', 'data structures', 'two pointers']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Complicated Computations.json,https://codeforces.com//blog/entry/84024,Let s iterate over the answer Let the current answer be then we can get it only when there are no subarrays whose MEX is Note that we need to check the MEX of the subarrays that are between all occurrences of This can be done for example using a segment tree processing its occurrences in order A number for which MEX is not found will be the answer 
https://codeforces.com//contest/1492/problem/E,905860,E,1492E,1492,E. Almost Fault-Tolerant Database,You are storing an integer array of length m in a database To maintain internal integrity and protect data the database stores n copies of this array Unfortunately the recent incident may have altered the stored information in every copy in the database It s believed that the incident altered at most two elements in every copy You need to recover the original array based on the current state of the database In case there are multiple ways to restore the array report any If there is no array that differs from every copy in no more than two positions report that as well ,"['#include <bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n\nll MOD = (ll)1000000007;\nvector<vector<int>> nums;\nvector<int> test;\nvector<map<int, int>> ct;\nvector<vector<pair<int, int>>> ctsort;\n\nbool check() {\n    // cout << ""Checking "";\n    // for(int i = 0; i < test.size(); i++) cout << test[i] << \' \';\n    for(int i = 0; i < nums.size(); i++) {\n        int x = 0;\n        for(int j = 0; j < test.size(); j++) {\n            if(test[j] != nums[i][j]) x++;\n        }\n        if(x > 2) return false;\n    }\n    // cout << ""...good!\\n"";\n    return true;\n}\n\nbool rec(int i, int s) {\n    if(s < 0) return false;\n    if(i == -1) {\n        return check();\n    }\n    for(int j = 0; j < ctsort[i].size(); j++) {\n        test[i] = ctsort[i][j].second;\n        if(rec(i-1, s-ctsort[i][j].first)) return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t, m, n;\n    ll k, ans = 0;\n    string s1, s2;\n    bool sad = false;\n    cin >> m >> n;\n    nums.resize(m);\n    ct.resize(n);\n    ctsort.resize(n);\n    test.resize(n);\n    for(int i = 0; i < m; i++) {\n        nums[i].resize(n);\n        for(int j = 0; j < n; j++) {\n            cin >> nums[i][j];\n            ct[j][nums[i][j]]++;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        for(pair<int, int> p : ct[i]) {\n            ctsort[i].push_back({m - p.second, p.first});\n        }\n        sort(ctsort[i].begin(), ctsort[i].end());\n    }\n    // for(int i = 0; i < n; i++) {\n    //     for(int j = 0; j < ctsort[i].size(); j++) {\n    //         cout << ctsort[i][j].second << \' \' << ctsort[i][j].first << "" | "";\n    //     }\n    //     cout << \'\\n\';\n    // }\n    if(rec(n-1, 2*m)) {\n        cout << ""Yes\\n"";\n        for(int i = 0; i < n; i++) cout << test[i] << \' \';\n    }\n    else cout << ""No\\n"";\n}']",,,"['brute force', 'constructive algorithms', 'dfs and similar', 'greedy', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Almost Fault-Tolerant Database.json,https://codeforces.com//blog/entry/87792,Let s look at the first array Every possible answer if there is any should not differ from this array in more than positions So we should try to change at most positions in the first array to find a consistent answer Let s look at the other arrays We can ignore each other array that differ with the first array in no more than positions In particular if every array doesn t differ in more than position we can just print the first array as an answer If an array differs in or more positions then no answer exists Suppose that we selected an array with or diffs This means that we must change or positions respectively in the first array to reduce it to diffs We have or ways to do this respectively and can go through all the options After changing we should look at all arrays again and make changes in the first array again if required but no more than in positions in total in a recursive backtracking manner If we don t get an answer we should go back and try another option The time complexity is with a decent constant If allowed number of diffs is can you solve problem in time If allowed number of diffs is can you solve problem in time 
https://codeforces.com//contest/1017/problem/B,205992,B,1017B,1017,B. The Bits,Rudolf is on his way to the castle Before getting into the castle the security staff asked him a question Given two binary numbers a and b of length n How many different ways of swapping two digits in a only in a not b so that bitwise OR of these two numbers will be changed In other words let c be the bitwise OR of a and b you need to find the number of ways of swapping two bits in a so that bitwise OR will not be equal to c Note that binary numbers can contain leading zeros so that length of each number is exactly n Bitwise OR is a binary operation A result is a binary number which contains a one in each digit if there is a one in at least one of the two numbers For example 01010 2 10011 2 11011 2 Well to your surprise you are not Rudolf and you don t need to help him ldots You are the security staff Please find the number of ways of swapping two bits in a so that bitwise OR will be changed ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nstring a,b;\nll ans = 0;\nint n;\nll co[4];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    cin >> a >> b;\n    F0R(i,n) {\n        co[2*(a[i]-\'0\')+(b[i]-\'0\')] ++;\n    }\n    //F0R(i,4) cout << co[i] << "" "";\n    //cout << ""\\n"";\n    cout << co[3]*co[0]+co[2]*co[1]+co[2]*co[0];\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']",,,"['implementation', 'math']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\B. The Bits.json,https://codeforces.com/blog/entry/61081,Let txy be the number of indexes i such that ai x and bi y The answer is t00 t10 t00 t11 t01 t10 
https://codeforces.com//contest/1497/problem/A,925004,A,1497A,1497,A. Meximization,You are given an integer n and an array a 1 a 2 ldots a n You should reorder the elements of the array a in such way that the sum of textbf MEX on prefixes i th prefix is a 1 a 2 ldots a i is maximized Formally you should find an array b 1 b 2 ldots b n such that the sets of elements of arrays a and b are equal it is equivalent to array b can be found as an array a with some reordering of its elements and sum limits i 1 n textbf MEX b 1 b 2 ldots b i is maximized textbf MEX of a set of nonnegative integers is the minimal nonnegative integer such that it is not in the set For example textbf MEX 1 2 3 0 textbf MEX 0 1 2 4 5 3 ,"['#pragma GCC optimize(""Ofast"")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n;\n        cin >> n;\n        vector<ll> a(n);\n        for (int i = 0; i < n; ++i) cin >> a[i];\n        sort(all(a));\n        vector<ll> b = {a[0]};\n        for (int i = 1; i < n; ++i) if (a[i] != a[i - 1]) b.eb(a[i]);\n        for (int i = 1; i < n; ++i) if (a[i] == a[i - 1]) b.eb(a[i]);\n        ll sum = 0;\n        vector<int> g(n + 5);\n        int mex = 0;\n        for (int i = 0; i < n; ++i) {\n            if (b[i] < g.size()) ++g[b[i]];\n            while (g[mex]) ++mex;\n            sum += mex;\n        }\n        for (int i = 0; i < n; ++i) cout << b[i] << "" "";\n        cout << \'\\n\';\n    }\n}\n']",,,"['brute force', 'data structures', 'greedy', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Meximization.json,https://codeforces.com//blog/entry/88677,To maximize the sum of on prefixes we will use a greedy algorithm Firstly we put all unique elements in increasing order to get maximal on each prefix It is easy to see that replacing any two elements after that makes both and sum of less In the end we put all elements that are not used in any order because will not change and will still be maximal 
https://codeforces.com//contest/614/problem/A,45526,A,614A,614,A. Link Cut Tree,Programmer Rostislav got seriously interested in the Link Cut Tree data structure which is based on Splay trees Specifically he is now studying the procedure Unfortunately Rostislav is unable to understand the definition of this procedure so he decided to ask programmer Serezha to help him Serezha agreed to help if Rostislav solves a simple task and if he doesn t then why would he need Splay trees anyway Given integers and you need to print all powers of number within range from to However Rostislav doesn t want to spent time doing this as he got interested in playing a network game called Agar with Gleb Help him ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define MP make_pair\n#define PB push_back\n#define AA first\n#define BB second\n#define OP begin()\n#define ED end()\n#define SZ size()\n#define cmin(x,y) x=min(x,y)\n#define cmax(x,y) x=max(x,y)\n#define NAME """"\n#define UsingFile 0\nconst LL MOD = 1000000007;\nint main(){\n    if(UsingFile)freopen(NAME"".in"",""r"",stdin);\n    if(UsingFile)freopen(NAME"".out"",""w"",stdout);\n    int i,j,_T;\n    LL l,r,k;\n    while(cin>>l>>r>>k){\n    \tLL tmp=1;\n    \tint flag=0;\n    \twhile(tmp<=r){\n    \t\tif(tmp>=l&&tmp<=r)\n    \t\t\tcout<<tmp<<"" "",flag=1;\n    \t\tif(tmp>r/k)break;\n    \t\ttmp*=k;\n    \t}\n    \tif(!flag)cout<<-1;\n    \tcout<<""\\n"";\n    }\n    return 0;\n}']",,,"['brute force', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Link Cut Tree.json,https://codeforces.com//blog/entry/22832,You had to print all numbers of form kx for non negative integers x that lie with the range l r A simple cycle works start with 1 k0 go over all powers that do not exceed r and print those which are at least l One should be careful with 64 bit integer overflows consider the test l 1 r 1018 k 109 the powers will be 1 109 1018 and the next power is 1027 which does not fit in a standard integer type 
https://codeforces.com//contest/876/problem/B,128565,B,876B,876,B. Divisiblity of Differences,You are given a multiset of integers You should select exactly of them in a such way that the difference between any two of them is divisible by or tell that it is impossible Numbers can be repeated in the original multiset and in the multiset of selected numbers but number of occurrences of any number in multiset of selected numbers should not exceed the number of its occurrences in the original multiset ,"['#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\n\n\nint main() {\n#ifdef __APPLE__\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n\n    int n, k, m;\n    scanf(""%d %d %d"", &n, &k, &m);\n    vector<int> a(n);\n    map<int, vector<int>> q;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", &a[i]);\n        q[a[i] % m].push_back(a[i]);\n    }\n    for (auto it : q) {\n        if (it.second.size() >= k) {\n            printf(""Yes\\n"");\n            for (int i = 0; i < k; ++i)\n                printf(""%d "", it.second[i]);\n            return 0;\n        }\n    }\n    printf(""No"");\n\n    return 0;\n}\n']",,,"['implementation', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Divisiblity of Differences.json,https://codeforces.com//blog/entry/55233,If is divisible by then and have same reminder when divided by Let s divide number to groups by reminder by modulo and if there is a group with size at least print numbers from it 
https://codeforces.com//contest/342/problem/E,3442,E,342E,342,E. Xenia and Tree,Xenia the programmer has a tree consisting of nodes We will consider the tree nodes indexed from 1 to We will also consider the first node to be initially painted red and the other nodes to be painted blue The between two tree nodes and is the number of edges in the shortest path between and Xenia needs to learn how to quickly execute queries of two types paint a specified blue node in red calculate which red node is the closest to the given one and print the shortest distance to the closest red node Your task is to write a program which will execute the described queries ,"['#define LOCAL\n\n/** ` Micro Mezzo Macro Flation -- Overheated Economy ., **/\n\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (n____=int(n),i=0;i<n____;++i)\n#define FOR_C_N(i, a, b) for (b____=int(b),i=a;i<b____;++i)\n#define DWN_C_N(i, b, a) for (a____=int(a),i=b-1;i>=a____;--i)\n#define REP_1_C_N(i, n) for (n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (a____=int(a),i=b;i>=a____;--i)\n\n#define ECH(it, A) for (typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define DO(n) while(n--)\n#define DO_C(n) int n____ = n; while(n____--)\n#define TO(i, a, b) int s_=a<b?1:-1,b_=b+s_;for(int i=a;i!=b_;i+=s_)\n#define TO_1(i, a, b) int s_=a<b?1:-1,b_=b;for(int i=a;i!=b_;i+=s_)\n#define SQZ(i, j, a, b) for (int i=int(a),j=int(b)-1;i<j;++i,--j)\n#define SQZ_1(i, j, a, b) for (int i=int(a),j=int(b);i<=j;++i,--j)\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, X) fP(ALL(A), X) // != A.end()\n#define CTN(T, x) (T.fP(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n\n#define Rush int T____; RD(T____); DO(T____)\n#pragma comment(linker, ""/STACK:36777216"")\n//#pragma GCC optimize (""O2"")\n#define Ruby system(""ruby main.rb"")\n#define Haskell system(""runghc main.hs"")\n#define Pascal system(""fpc main.pas"")\n\ntypedef long long LL;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VD;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef set<LL> SL;\ntypedef set<DB> SD;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef map<LL, int> MLI;\ntypedef map<DB, int> MDI;\ntypedef map<int, bool> MIB;\ntypedef map<string, bool> MSB;\ntypedef map<LL, bool> MLB;\ntypedef map<DB, bool> MDB;\ntypedef pair<int, int> PII;\ntypedef pair<int, bool> PIB;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\ntypedef set<PII> SII;\ntypedef map<PII, int> MPIII;\ntypedef map<PII, bool> MPIIB;\n\n/** I/O Accelerator **/\n\n/* ... :"" We are I/O Accelerator ... Use us at your own risk ;) ... "" .. */\n\ntemplate<class T> inline void RD(T &);\ntemplate<class T> inline void OT(const T &);\n\ninline int RD(){ int x; RD(x); return x;}\ntemplate<class T> inline T& _RD(T &x){ RD(x); return x;}\ninline void RC(char &c){scanf("" %c"", &c);}\ninline char RC(){ char x; RC(x); return x;}\ninline void RS(char *s){scanf(""%s"", s);}\n\ntemplate<class T0, class T1> inline void RD(T0 &x0, T1 &x1){RD(x0), RD(x1);}\ntemplate<class T0, class T1, class T2> inline void RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);}\ntemplate<class T0, class T1> inline void OT(T0 &x0, T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(T0 &x0, T1 &x1, T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\n\n\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){\n    while (!Q.empty()) Q.pop();\n}\n\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){\n    while (!Q.empty()) Q.pop();\n}\n\ntemplate<class T> inline void CLR(T &A){A.clear();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2){FLC(A0), FLC(A1), FLC(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3){FLC(A0), FLC(A1), FLC(A2), FLC(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4), FLC(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4), FLC(A5), FLC(A6);}\n\ntemplate<class T> inline void SRT(T &A){sort(ALL(A));}\ntemplate<class T, class C> inline void SRT(T &A, C B){sort(ALL(A), B);}\n\n/** Add - On **/\n\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = 3.14159265358979323846264; //M_PI;\n\n// <<= ` 0. Daily Use .,\n\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (b>a) a=b;}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(min(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\nint Ceil(int x, int y){return (x - 1) / y + 1;}\n\n// <<= ` 1. Bitwise Operation .,\ninline bool _1(int x, int i){return x & 1<<i;}\ninline bool _1(LL x, int i){return x & 1LL<<i;}\ninline LL _1(int i){return 1LL<<i;}\n//inline int _1(int i){return 1<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n//inline int _U(int i){return _1(i) - 1;};\n\n\ntemplate<class T> inline T low_bit(T x) {\n    return x & -x;\n}\n\ntemplate<class T> inline T high_bit(T x) {\n    T p = low_bit(x);\n    while (p != x) x -= p, p = low_bit(x);\n    return p;\n}\n\ninline int count_bits(int x){\n    x = (x & 0x55555555) + ((x & 0xaaaaaaaa) >> 1);\n    x = (x & 0x33333333) + ((x & 0xcccccccc) >> 2);\n    x = (x & 0x0f0f0f0f) + ((x & 0xf0f0f0f0) >> 4);\n    x = (x & 0x00ff00ff) + ((x & 0xff00ff00) >> 8);\n    x = (x & 0x0000ffff) + ((x & 0xffff0000) >> 16);\n    return x;\n}\n\ninline int count_bits(LL x){\n    x = (x & 0x5555555555555555LL) + ((x & 0xaaaaaaaaaaaaaaaaLL) >> 1);\n    x = (x & 0x3333333333333333LL) + ((x & 0xccccccccccccccccLL) >> 2);\n    x = (x & 0x0f0f0f0f0f0f0f0fLL) + ((x & 0xf0f0f0f0f0f0f0f0LL) >> 4);\n    x = (x & 0x00ff00ff00ff00ffLL) + ((x & 0xff00ff00ff00ff00LL) >> 8);\n    x = (x & 0x0000ffff0000ffffLL) + ((x & 0xffff0000ffff0000LL) >> 16);\n    x = (x & 0x00000000ffffffffLL) + ((x & 0xffffffff00000000LL) >> 32);\n    return x;\n}\n\nint reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\nLL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\n// <<= ` 2. Modular Arithmetic Basic .,\n\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int pow(int a, int b){\n    int c = 1;\n    while (b) {\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T>\ninline int pow(T a, int b){\n    T c(1);\n    while (b) {\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIA(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int sum(int a, int b, int MOD){\n    a += b; if (a >= MOD) a -= MOD;\n    return a;\n}\n\ninline int phi(int n){\n    int res = n;\n    for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n// <<= \'9. Comutational Geometry .,\n\nstruct Po; struct Line; struct Seg;\n\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\nstruct Po{\n    DB x, y;\n    Po(DB _x = 0, DB _y = 0):x(_x), y(_y){}\n\n    friend istream& operator >>(istream& in, Po &p){return in >> p.x >> p.y;}\n    friend ostream& operator <<(ostream& out, Po p){return out << ""("" << p.x << "", "" << p.y << "")"";}\n\n    friend bool operator ==(Po, Po);\n    friend bool operator !=(Po, Po);\n    friend Po operator +(Po, Po);\n    friend Po operator -(Po, Po);\n    friend Po operator *(Po, DB);\n    friend Po operator /(Po, DB);\n\n    bool operator < (const Po &rhs) const{return sgn(x, rhs.x) < 0 || sgn(x, rhs.x) == 0 && sgn(y, rhs.y) < 0;}\n    Po operator-() const{return Po(-x, -y);}\n    Po& operator +=(Po rhs){x += rhs.x, y += rhs.y; return *this;}\n    Po& operator -=(Po rhs){x -= rhs.x, y -= rhs.y; return *this;}\n    Po& operator *=(DB k){x *= k, y *= k; return *this;}\n    Po& operator /=(DB k){x /= k, y /= k; return *this;}\n\n    DB length_sqr(){return sqr(x) + sqr(y);}\n    DB length(){return sqrt(length_sqr());}\n\n    DB atan(){\n        return atan2(y, x);\n    }\n\n    void input(){\n        scanf(""%lf %lf"", &x, &y);\n    }\n};\n\nbool operator ==(Po a, Po b){return sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0;}\nbool operator !=(Po a, Po b){return sgn(a.x - b.x) != 0 || sgn(a.y - b.y) != 0;}\nPo operator +(Po a, Po b){return Po(a.x + b.x, a.y + b.y);}\nPo operator -(Po a, Po b){return Po(a.x - b.x, a.y - b.y);}\nPo operator *(Po a, DB k){return Po(a.x * k, a.y * k);}\nPo operator *(DB k, Po a){return a * k;}\nPo operator /(Po a, DB k){return Po(a.x / k, a.y / k);}\n\nstruct Line{\n    Po a, b;\n    Line(Po _a = Po(), Po _b = Po()):a(_a), b(_b){}\n    Line(DB x0, DB y0, DB x1, DB y1):a(Po(x0, y0)), b(Po(x1, y1)){}\n    Line(Seg);\n\n    friend ostream& operator <<(ostream& out, Line p){return out << p.a << ""-"" << p.b;}\n};\n\nstruct Seg{\n    Po a, b;\n    Seg(Po _a = Po(), Po _b = Po()):a(_a), b(_b){}\n    Seg(DB x0, DB y0, DB x1, DB y1):a(Po(x0, y0)), b(Po(x1, y1)){}\n    Seg(Line l);\n\n    friend ostream& operator <<(ostream& out, Seg p){return out << p.a << ""-"" << p.b;}\n    DB length(){return (b - a).length();}\n};\n\nLine::Line(Seg l):a(l.a), b(l.b){}\nSeg::Seg(Line l):a(l.a), b(l.b){}\n\n#define innerProduct dot\n#define scalarProduct dot\n#define dotProduct dot\n#define outerProduct det\n#define crossProduct det\n\ninline DB dot(DB x1, DB y1, DB x2, DB y2){return x1 * x2 + y1 * y2;}\ninline DB dot(Po a, Po b){return dot(a.x, a.y, b.x, b.y);}\ninline DB dot(Po p0, Po p1, Po p2){return dot(p1 - p0, p2 - p0);}\ninline DB dot(Line l1, Line l2){return dot(l1.b - l1.a, l2.b - l2.a);}\ninline DB det(DB x1, DB y1, DB x2, DB y2){return x1 * y2 - x2 * y1;}\ninline DB det(Po a, Po b){return det(a.x, a.y, b.x, b.y);}\ninline DB det(Po p0, Po p1, Po p2){return det(p1 - p0, p2 - p0);}\ninline DB det(Line l1, Line l2){return det(l1.b - l1.a, l2.b - l2.a);}\n\ntemplate<class T1, class T2> inline DB dist(T1 x, T2 y){return sqrt(dist_sqr(x, y));}\n\ninline DB dist_sqr(Po a, Po b){return sqr(a.x - b.x) + sqr(a.y - b.y);}\ninline DB dist_sqr(Po p, Line l){Po v0 = l.b - l.a, v1 = p - l.a; return sqr(fabs(det(v0, v1))) / v0.length_sqr();}\ninline DB dist_sqr(Po p, Seg l){\n    Po v0 = l.b - l.a, v1 = p - l.a, v2 = p - l.b;\n    if (sgn(dot(v0, v1)) * sgn(dot(v0, v2)) <= 0) return dist_sqr(p, Line(l));\n    else return min(v1.length_sqr(), v2.length_sqr());\n}\n\ninline DB dist_sqr(Line l, Po p){return dist_sqr(p, l);}\ninline DB dist_sqr(Seg l, Po p){return dist_sqr(p, l);}\n\ninline DB dist_sqr(Line l1, Line l2){\n    if (sgn(det(l1, l2)) != 0) return 0;\n    return dist_sqr(l1.a, l2);\n}\ninline DB dist_sqr(Line l1, Seg l2){\n    Po v0 = l1.b - l1.a, v1 = l2.a - l1.a, v2 = l2.b - l1.a; DB c1 = det(v0, v1), c2 = det(v0, v2);\n    return sgn(c1) != sgn(c2) ? 0 : sqr(min(fabs(c1), fabs(c2))) / v0.length_sqr();\n}\n\nbool isIntersect(Seg l1, Seg l2){\n\n    //if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b) return true;\n\n    return\n        min(l1.a.x, l1.b.x) <= max(l2.a.x, l2.b.x) &&\n        min(l2.a.x, l2.b.x) <= max(l1.a.x, l1.b.x) &&\n        min(l1.a.y, l1.b.y) <= max(l2.a.y, l2.b.y) &&\n        min(l2.a.y, l2.b.y) <= max(l1.a.y, l1.b.y) &&\n    sgn( det(l1.a, l2.a, l2.b) ) * sgn( det(l1.b, l2.a, l2.b) ) <= 0 &&\n    sgn( det(l2.a, l1.a, l1.b) ) * sgn( det(l2.b, l1.a, l1.b) ) <= 0;\n\n}\n\ninline DB dist_sqr(Seg l1, Seg l2){\n    if (isIntersect(l1, l2)) return 0;\n    else return min(dist_sqr(l1.a, l2), dist_sqr(l1.b, l2), dist_sqr(l2.a, l1), dist_sqr(l2.b, l1));\n}\n\ninline bool isOnExtremePoint(const Po &p, const Seg &l){\n    return p == l.a || p == l.b;\n}\n\ninline bool isOnseg(const Po &p, const Seg &l){\n\n    //if (p == l.a || p == l.b) return false;\n\n    return sgn(det(p, l.a, l.b)) == 0 &&\n        sgn(l.a.x, p.x) * sgn(l.b.x, p.x) <= 0 && sgn(l.a.y, p.y) * sgn(l.b.y, p.y) <= 0;\n}\n\ninline Po intersect(const Line &l1, const Line &l2){\n    return l1.a + (l1.b - l1.a) * (det(l2.a, l1.a, l2.b) / det(l2, l1));\n}\n\n// perpendicular foot\ninline Po intersect(const Po & p, const Line &l){\n    return intersect(Line(p, p + Po(l.a.y - l.b.y, l.b.x - l.a.x)), l);\n}\n\ninline Po rotate(Po p, DB alpha, Po o = Po()){\n    p.x -= o.x, p.y -= o .y;\n    return Po(p.x * cos(alpha) - p.y * sin(alpha), p.y * cos(alpha) + p.x * sin(alpha)) + o;\n}\n\n// <<= \' A. Random Event ..\n\ninline int rand32(){return (bool(rand() & 1) << 30) | (rand() << 15) + rand();}\ninline int random32(int l, int r){return rand32() % (r - l + 1) + l;}\ninline int random(int l, int r){return rand() % (r - l + 1) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return rand() % 2;}\n\n// <<= \' 0. I/O Accelerator interface .,\n\ntemplate<class T> inline void RD(T &x){\n    //cin >> x;\n    //scanf(""%d"", &x);\n    char c; for (c = getchar(); c < \'0\'; c = getchar()); x = c - \'0\'; for (c = getchar(); c >= \'0\'; c = getchar()) x = x * 10 + c - \'0\';\n    //char c; c = getchar(); x = c - \'0\'; for (c = getchar(); c >= \'0\'; c = getchar()) x = x * 10 + c - \'0\';\n}\n\ntemplate<class T> inline void OT(const T &x){\n    printf(""%d\\n"", x);\n}\n\n/* .................................................................................................................................. */\n\nconst int N = 100009, M = N * 2;\n\nint hd[N], prd[M], suc[M], to[M];\n// Adjcent List .. .\nint size[N], head[N], F[N], D[N], Hid[N];\n// Vertex .. .\nint n, nn;\n\n#define black(x) H[x].B[1]\n\n#define lx (x<<1)\n#define rx (lx|1)\n#define y (x>>1)\n\nstruct Heap{\n\n    VI B; int *H, *P;\n    int n;\n\nprivate:\n\n    inline int A(int x){return B[H[x]];}\n\n    void Swap(int a, int b){\n        swap(H[a], H[b]);\n        P[H[a]] = a, P[H[b]] = b;\n    }\n\n    inline void Up(int x){\n        while (A(y) > A(x)){\n            Swap(x, y), x = y;\n        }\n    }\n\n    inline void Down(int x){\n        int h = x; while (true){\n            if (lx <= n && A(lx) < A(h)) h = lx;\n            if (rx <= n && A(rx) < A(h)) h = rx;\n            if (h == x) break;\n            Swap(h, x), x = h;\n        }\n    }\n\npublic:\n\n    void Build(){\n        n = SZ(B); H = new int[n], P = new int[n]; --n;\n        FOR_1(i, 0, n) H[i] = P[i] = i; DWN_1(i, n>>1, 1) Down(i);\n    }\n\n    void Update(int x, int v){\n        if (B[x] > v) B[x] = v, Up(P[x]);\n        else B[x] = v, Down(P[x]);\n    }\n\n    int top(){\n        return A(1);\n    }\n\n} H[N];\n\n#undef y\n\n#define root 1, 0, n-1\n#define m ((l+r)>>1)\n#define lc lx, l, m\n#define rc rx, m+1, r\n\n#define Update(x) ml[x] = min(ml[lx], d(l, m+1) + ml[rx]), mr[x] = min(mr[rx], d(m, r) + mr[lx])\n#define Upleaf(x) ml[x] = mr[x] = h.top()\n\nstruct Interval_Tree{\n\n    VI id; int *ml, *mr;\n    int n, _x, offset;\n\nprivate:\n\n    int d(int l, int r){\n        return r - l;\n    }\n\n#define h H[id[l]]\n    void _B(int x, int l, int r){\n        if (l == r) ml[x] = mr[x] = INF;\n        else _B(lc), _B(rc), ml[x] = mr[x] = INF;\n    }\n\n    void _M(int x, int l, int r){\n        if (l == r) Upleaf(x);\n        else {if (_x <= m) _M(lc); if (m < _x) _M(rc); Update(x);}\n    }\n\n    int _MinL(int x, int l, int r){\n        if (l == r) return ml[x];\n        else return _x <= m ? _MinL(lc) : min(_MinL(rc), mr[lx] + d(m, _x));\n    }\n\n    int _MinR(int x, int l, int r){\n        if (l == r) return mr[x];\n        else return _x <= m ? min(_MinR(lc), d(_x, m+1) + ml[rx]) : _MinR(rc);\n    }\n\n#undef h\n\npublic:\n\n    int d(int x){\n        return d(0, D[x] - offset);\n    }\n\n    void Build(){\n        n = SZ(id); offset = D[id[0]]; int t=1; while(t<n) t<<=1; t<<=1;\n        ml = new int[t], mr = new int[t],  _B(root);\n    }\n\n    void Modify(int x){\n        _x = D[x] - offset, _M(root);\n    }\n\n    int MinR(int x){\n        _x = D[x] - offset; return _MinR(root);\n    }\n\n    int MinL(int x){\n        _x = D[x] - offset; return _MinL(root);\n    }\n\n    int MinL(){return ml[1];}\n\n} T[N];\n\n#undef Update\n\ninline void del(int x){\n    if (x == hd[to[x^1]]) prd[hd[to[x^1]] = suc[x]] = 0;\n    else suc[prd[suc[x]] = prd[x]] = suc[x];\n}\n\n#define TRA(i, x) for(int i=hd[x];i;i=suc[i])\n#define u q[i]\n#define v to[ii]\n\nint q[N]; void bfs(){\n    n = 0, q[n++] = 1; REP(i, n) TRA(ii, u) if(!F[v])\n        q[n++] = v, F[v] = u, D[v] = D[u] + 1, del(ii^1);\n\n    DWN(i, n, 0){\n        size[u] = 1; TRA(ii, u)\n            size[u] += size[v];\n    }\n}\n\nvoid hld(){\n    REP(i, n) if (!head[u]){\n        int x = u, y; while (true){\n            T[u].id.PB(x); y = 0; head[x] = u; TRA(ii, x){\n                if(!y || size[v] > size[y]) y = v;\n            }\n            if (!y) break;\n            x = y;\n        }\n    }\n}\n\nvoid init(){\n\n    DWN(i, n, 0){\n\n        int cnt = 1; H[u].B.PB(INF);\n\n        TRA(ii, u) if(head[v] != head[u])\n            Hid[v]=++cnt, H[u].B.PB(INF);\n\n        H[u].Build(); if (head[u] == u)  // is path head ? ..\n            T[u].Build();\n    }\n}\n\n#undef u\n#undef v\n\nvoid Up(int& x){\n    T[head[x]].Modify(x), x = head[x];\n}\n\nvoid Modify(int u){\n\n    if (black(u)) H[u].Update(1, 0);\n    else H[u].Update(1, INF);\n\n    Up(u); int v = F[u]; while (v){\n        H[v].Update(Hid[u], T[u].MinL() + 1);\n        Up(v), v = F[u = v];\n    }\n}\n\nint Query(int u){\n\n    if (!black(u)) return 0;\n\n    int res = INF, path = 0, t; while (u){\n        t = min(T[head[u]].MinL(u), T[head[u]].MinR(u));\n        checkMin(res, t + path); if (!t) break; // Cut .. -2s..\n        path += T[head[u]].d(u) + 1;\n        u = F[head[u]];\n    }\n    return res == INF ? -1 : res;\n}\n\nint vvv[N];\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""r"", stdin);\n#endif\n    int Q; RD(n, Q);\n    FOR_C(i, 2, n << 1){\n        RD(to[i], to[i|1]);\n        prd[hd[to[i^1]]] = i, suc[i] = hd[to[i^1]], hd[to[i^1]] = i, ++i;\n        prd[hd[to[i^1]]] = i, suc[i] = hd[to[i^1]], hd[to[i^1]] = i;\n    }\n\n\n\n    REP_1(i, n) H[i].B.PB(-INF); // offset .. .\n\n\n\n    bfs(); hld(); init(); // heavy light decomposition .. .\n\n\n        Modify(1);\nvvv[1] = 1;\n    DO(Q){\n        if (RD()==2) {\n                OT(Query(RD()));\n        }\n        else {\n            int ttt  = RD ();\n            if (vvv[ttt] == 0)\n                Modify(ttt);\n            vvv[ttt] = 1;\n        }\n    }\n}\n']",,,"['data structures', 'divide and conquer', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Xenia and Tree.json,https://codeforces.com/blog/entry/8800,The problem can be solved in different ways The most easy idea is sqrt optimization Split all queries into blocks Each block we will process separately Before processing each block we should calculate minimum distances from every node to the closest red node using bfs To answer the query we should update this value by shortest distances to red nodes in current block The solution becomes simple Every queries we make simple bfs and for every node WE calculate value the shortest distance to some red node from node Then to answer the query of type 2 you should calculate where every red node which becomes red in current block of length Distance between two nodes can be got using preprocessing for lca 
https://codeforces.com//contest/2039/problem/F1,3044246,F1,2039F1,2039,F1. Shohag Loves Counting  Easy Version ,For an integer array a of length n define f k as the greatest common divisor GCD of the maximum values of all subarrays text of length k For example if the array is 2 1 4 6 2 then f 3 operatorname gcd operatorname max 2 1 4 operatorname max 1 4 6 operatorname max 4 6 2 operatorname gcd 4 6 6 2 An array is good if f i neq f j is satisfied over all pairs 1 le i lt j le n Shohag has an integer m Help him count the number modulo 998 244 353 of non empty good arrays of arbitrary length such that each element of the array is an integer from 1 to m text An array d is a subarray of an array c if d can be obtained from c by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n;mint dp[N]; vi dv[N];mint mut[N];mint mu[N];void Main() {\tcin >> n;\tL(i, 1, n) dp[i] = mut[i] = 0;\tmint ans = 0;\tR(i, n, 1) {\t\t// L(j, 1, n) if(__gcd(i, j) < j) {\t\t// \tdp[__gcd(i, j)] += dp[j] * 2;\t\t// \tans += dp[j] * 2;\t\t// }\t\tfor(int d : dv[i]) {\t\t\tmint qwq = 0;\t\t\tfor(int nd : dv[i / d]) qwq += mu[nd] * mut[d * nd];\t\t\tqwq -= dp[d];\t\t\t// cout << i <<\' \'<<d<<""inc "" << qwq.x << \' \' << mut[d].x << \' \' << mut[d * 2].x << endl;\xa0\t\t\tqwq *= 2;\t\t\tans += qwq;\t\t\tdp[d] += qwq;\t\t\tfor(auto s : dv[d]) {\t\t\t\tmut[s] += qwq;\t\t\t}\t\t}\t\tdp[i] += 1;\t\tans += 1;\t\tfor(auto j : dv[i]) mut[j] += 1;\t\t// L(j, 1, n) cout << dp[j].x << \' \';\t\t// cout << endl;\t}\tcout << ans.x << \'\\n\';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint mx = 1e6;\tL(i, 1, mx)\t\tL(j, 1, mx / i)\t\t\tdv[i * j].pb(i);\tL(i, 1, mx)\t\tmu[i] = (i == 1);\tL(i, 1, mx)\t\tL(j, 2, mx / i)\t\t\tmu[i * j] -= mu[i];\t// cout << ""mu = "" << mu[2].x << endl;\tint t; cin >> t; while(t--) Main();\treturn 0;}']",,,"['combinatorics', 'dp', 'math', 'number theory']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F1. Shohag Loves Counting  Easy Version .json,https://codeforces.com//blog/entry/136523,Let be the sequence of length subarray maximums of the array Then is just the adjacent maximum sequence of Also let be the GCD of the elements of Then notice that every element of is also divisible by That is divides For the array to be good must be different for all So and divides This means if the length of the array is then Now consider a non decreasing sequence of integers of length such that for all Then the length subarray maximums of are just the last elements of So is the GCD of the last elements of Then for to be different for all all the elements of must be distinct So the condition for to be good is that the elements are distinct and all suffix GCDs are distinct as well Next the question is how many permutations of this increasing sequence is good as well To count this lets start from is just Now consider We need to put in the sequence such that the adjacent maximum sequence of becomes For this we clearly have ways and Now consider We need to put in the sequence such that the adjacent maximum sequence of becomes For this we again have ways because can be inserted in places before or after Similarly for all other we have ways to insert it putting it before or after So the total number of good permutations of is So our problem reduces to the following Select a length such that Count the number of strictly increasing sequences of length such that all suffix GCDs are distinct Multiply the answer by Sum up the answer for all valid For a fixed let s count the number of strictly increasing sequences of length such that all suffix GCDs are distinct Let be the number of strictly increasing sequences of length such that the starting element is and the GCD of the elements is Now iterate from to Then the transition is to iterate over the next suffix GCD such that divides and and then add to Here is the sum of all for all Another way to look at the transition is that for a fixed we iterate over all and if then we add to But doing everything like this would still be which is too slow Notice that all are the divisors of Here the main difficulty is that we need update at the index over all but it is hard to track the exact gcd but what s easier is to track the multiple of the gcd So for each let s say we know the sum of all over all such that divides So this sums up all such that divides Then using inclusion exclusion on the divisors of we can get the sum of all for all such that is exactly This will take time for each where is the number of divisors of And once we calculate the for some and then before transitioning to we can add the value of to all divisors of to get the value of faster in the future To keep track of this we can use a separate array So for a fixed the time complexity is And we need to do this for all from to So the overall time complexity is We actually allowed this to pass in F1 We can make the time complexity much better with a simple modification in the dp Note that we don t need to use the length of array in the dp state As we need to sum up after multiplying by at the end we can modify the dp to directly store the sum of So we can just multiply the dp by during each transition So the time complexity becomes This is very fast for F1 
https://codeforces.com//contest/414/problem/E,7960,E,414E,414,E. Mashmokh s Designed Problem,After a lot of trying Mashmokh designed a problem and it s your job to solve it You have a tree with vertices Each vertex has a unique index from 1 to The root of has index For each vertex of this tree you are given a list of its children in a specific order You must perform three types of query on this tree find distance the number of edges in the shortest path between and given and disconnect from its father and connect it to its th ancestor more formally let s denote the path from to the root by so that and is root disconnect from its father and connect it to vertex must be added to the end of the child list of vertex in the vertex sequence produced by calling function dfs root find the latest vertex that has distance from the root The pseudo code of function dfs v ls v list of children of vertex v its i th element is ls v i its size is size ls v sequence result empty sequence void dfs vertex now add now to end of result for int i 1 i size ls v i i 1 loop from i 1 to i size ls v dfs ls v i ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(s) int((s).size())\n#define len(s) int((s).size())\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n#if _WIN32 || __WIN32__\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n#define next _next\n#define prev _prev\n#define rank _rank\n#define hash _hash\n#define y0 yy0\n#define y1 yy1\n#define link _link\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef unsigned long long ullong;\ntypedef unsigned long long lint;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(double(1));\nconst int N = int(1e5) + 100;\n\nstruct node {\n\t\n\tint ver, val, minVal, maxVal, add;\n\tint h, sz, p, l, r;\n\t\n\tnode() {\n\t\tminVal = inf;\n\t\tmaxVal = -inf;\n\t\tsz = 0;\n\t}\n\t\n\tnode(int ver, int val) {\n\t\tthis->ver = ver;\n\t\tthis->val = minVal = maxVal = val;\n\t\tadd = 0;\n\t\th = (rand() << 16) | rand();\n\t\tsz = 1;\n\t\tp = l = r = 0;\n\t}\n\t\n};\n\nint sz, root;\nint first[N], last[N];\nvi sons[N];\nnode d[5 * N];\n\ninline void push(int v) {\n\tif (v == 0 || d[v].add == 0) {\n\t\treturn;\n\t}\n\td[v].val += d[v].add;\n\td[v].minVal += d[v].add;\n\td[v].maxVal += d[v].add;\n\tif (d[v].l > 0) {\n\t\td[d[v].l].add += d[v].add;\n\t}\n\tif (d[v].r > 0) {\n\t\td[d[v].r].add += d[v].add;\n\t}\n\td[v].add = 0;\n}\t\n\ninline void calc(int v) {\n\tpush(v);\n\tpush(d[v].l);\n\tpush(d[v].r);\n\td[v].sz = d[d[v].l].sz + d[d[v].r].sz + 1;\n\td[v].minVal = min(d[v].val, min(d[d[v].l].minVal, d[d[v].r].minVal));\n\td[v].maxVal = max(d[v].val, max(d[d[v].l].maxVal, d[d[v].r].maxVal));\n\td[v].p = 0;\n\tif (d[v].l > 0) {\n\t\td[d[v].l].p = v;\n\t}\n\tif (d[v].r > 0) {\n\t\td[d[v].r].p = v;\n\t}\n}\n\nint merge(int l, int r) {\n\tpush(l);\n\tpush(r);\n\tif (l == 0) {\n\t\treturn r;\n\t}\n\tif (r == 0) {\n\t\treturn l;\n\t}\n\tint res;\n\tif (d[l].h > d[r].h) {\n\t\td[l].r = merge(d[l].r, r);\n\t\tres = l;\n\t}\n\telse {\n\t\td[r].l = merge(l, d[r].l);\n\t\tres = r;\n\t}\n\tcalc(res);\n\treturn res;\n}\n\nvoid dfs(int v, int ch = 0) {\n\td[++sz] = node(v, ch);\n\troot = merge(root, sz);\n\tfirst[v] = sz;\n\tfor (int i = 0; i < sz(sons[v]); ++i) {\n\t\tdfs(sons[v][i], ch + 1);\n\t\td[++sz] = node(v, ch);\n\t\troot = merge(root, sz);\n\t}\n\td[++sz] = node(v, ch);\n\troot = merge(root, sz);\n\tlast[v] = sz;\n}\n\ninline int getNum(int v) {\n\tint res = d[d[v].l].sz + 1;\n\twhile (d[v].p > 0) {\n\t\tint pv = d[v].p;\n\t\tif (d[pv].r == v) {\n\t\t\tres += d[d[pv].l].sz + 1;\n\t\t}\n\t\tv = pv;\n\t}\n\treturn res;\n}\n\ninline int getPos(int v) {\n\treturn getNum(first[v]);\n}\n\ninline int getVal(int v, int num) {\n\tpush(v);\n\tif (d[d[v].l].sz + 1 == num) {\n\t\treturn d[v].val;\n\t}\n\tif (d[d[v].l].sz + 1 > num) {\n\t\treturn getVal(d[v].l, num);\n\t}\n\telse {\n\t\treturn getVal(d[v].r, num - d[d[v].l].sz - 1);\n\t}\n}\n\ninline int getVal(int v) {\n\treturn getVal(root, getNum(first[v]));\n}\n\nvoid splitSize(int v, int sz, int &l, int &r) {\n\tpush(v);\n\tif (v == 0) {\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\tif (d[d[v].l].sz + 1 <= sz) {\n\t\tsplitSize(d[v].r, sz - d[d[v].l].sz - 1, d[v].r, r);\n\t\tl = v;\n\t}\n\telse {\n\t\tsplitSize(d[v].l, sz, l, d[v].l);\n\t\tr = v;\n\t}\n\tcalc(v);\n}\n\ninline int getDist(int v, int u) {\n\tint l = getPos(v), r = getPos(u);\n\tif (l > r) {\n\t\tswap(l, r);\n\t}\n\tint p1, p2, p3;\n\tsplitSize(root, r, p1, p3);\n\tsplitSize(p1, l - 1, p1, p2);\n\tint res = d[p2].minVal;\n\troot = merge(p1, merge(p2, p3));\n\treturn getVal(v) + getVal(u) - 2 * res;\n}\n\ninline int findKth(int v, int k) {\n\tpush(v);\n\tif (v == 0) {\n\t\treturn -1;\n\t}\n\tif (d[v].val == k) {\n\t\tint res = findKth(d[v].r, k);\n\t\tif (res == -1) {\n\t\t\tres = d[v].ver;\n\t\t}\n\t\treturn res;\n\t}\n\tpush(d[v].r);\n\tif (d[v].r > 0 && d[d[v].r].minVal <= k && d[d[v].r].maxVal >= k) {\n\t\treturn findKth(d[v].r, k);\n\t}\n\treturn findKth(d[v].l, k);\n}\n\nvoid write(int v) {\n\tpush(v);\n\tif (v == 0) {\n\t\treturn;\n\t}\n\twrite(d[v].l);\n\tcerr << ""("" << d[v].ver << "", "" << d[v].val << "") "";\n\twrite(d[v].r);\n}\n\ninline void move(int v, int k) {\n\tint h = getVal(v);\n\tint p1, p2, p3;\n\tsplitSize(root, getPos(v) - 1, p1, p2);\n\tint pv = findKth(p1, h - k);\n\tsplitSize(p2, getNum(last[v]), p2, p3);\n\td[p2].add -= (k - 1);\n\tpush(p2);\n\troot = merge(p1, p3);\n\tsplitSize(root, getNum(last[pv]) - 1, p1, p3);\n\td[++sz] = node(pv, h - k);\n\tp2 = merge(p2, sz);\n\troot = merge(p1, merge(p2, p3));\n}\n\nint main() {\n\tint n, m;\n\tscanf(""%d %d"", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint sz;\n\t\tscanf(""%d"", &sz);\n\t\tfor (int j = 0; j < sz; ++j) {\n\t\t\tint cur;\n\t\t\tscanf(""%d"", &cur);\n\t\t\t--cur;\n\t\t\tsons[i].pb(cur);\n\t\t}\n\t}\n\tsz = root = 0;\n\tdfs(0);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tif (t == 1) {\n\t\t\tint v, u;\n\t\t\tscanf(""%d %d"", &v, &u);\n\t\t\t--v;\n\t\t\t--u;\n\t\t\tprintf(""%d\\n"", getDist(v, u));\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == 2) {\n\t\t\tint v, h;\n\t\t\tscanf(""%d %d"", &v, &h);\n\t\t\t--v;\n\t\t\tmove(v, h);\n\t\t\tcontinue;\n\t\t}\n\t\tint k;\n\t\tscanf(""%d"", &k);\n\t\tprintf(""%d\\n"", findKth(root, k) + 1);\n\t}\n\treturn 0;\n}\n']",,,['data structures'],3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Mashmokh s Designed Problem.json,https://codeforces.com//blog/entry/11470,Let s define the dfs order of a tree as the sequence created by calling function dfs root We ll build another sequence from a dfs order by replacing each vertex in dfs order by 1 and inserting a 1 after the last vertex of its subtree Note that all vertices of a particular subtree are a continuous part of dfs order of that tree Also note that for each vertex if the 1 corresponding to it is the th element of sequence then s distance from root which we ll denote by height of is equal to sum of elements Suppose we can perform the following operations on such sequence For each find sum of the elements For each find the biggest so that sum of elements of the sequence equals Using these two operations we can find LCA of two vertices and so since distance of and equals to we can answer the second query Also the third query can be answered using the second operation described above As for the first query it cuts a continuous part of sequence and insert it in another place This operation can be done using implicit treap Also we can use the treap as a segment tree to store the following values for each vertex Then using these values the operations described above can be done All of these operation can be done in Sum of the elements in its subtree each vertex in the treap has a value equal to 1 or 1 since it corresponds to an element of the sequence Let s write the values of each vertex in the subtree of in the order they appear in the sequence Then lets denote sum of the first numbers we wrote as and call elements of ps prefix sums of the subtree of Then we store the maximum number amongst the prefix sums Also we ll store the minimum number amongst prefix sums 
https://codeforces.com//contest/1921/problem/F,2427796,F,1921F,1921,F. Sum of Progression,You are given an array a of n numbers There are also q queries of the form s d k For each query q find the sum of elements a s a s d cdot 2 dots a s d cdot k 1 cdot k In other words for each query it is necessary to find the sum of k elements of the array with indices starting from the s th taking steps of size d multiplying it by the serial number of the element in the resulting sequence ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nll a[N],sm[317][N],dp[317][N];\nvoid solve(/**/){\n    ll n,q,sq;\n    cin>>n>>q;\n    sq=sqrt(n);\n    for(ll i=1;i<=n;i++) cin>>a[i];\n    for(ll d=1;d<=sq;d++){\n        for(ll i=n;i>=1;i--){\n            if(i+d>n) dp[d][i]=sm[d][i]=a[i];\n            else{\n                ll j=i+d;\n                sm[d][i]=sm[d][j]+a[i];\n                dp[d][i]=dp[d][j]+sm[d][i];\n            }\n        }\n    }\n    while(q--){\n        ll s,d,k;\n        cin>>s>>d>>k;\n        if(d<=sq){\n            ll j=s+d*k;\n            ll ans=dp[d][s];\n            if(j<=n){\n                ans-=dp[d][j];\n                ans-=sm[d][j]*k;\n            }\n            cout<<ans<<\' \';\n        }else{\n            ll ans=0;\n            for(ll i=0;i<k;i++) ans+=a[s+d*i]*(i+1);\n            cout<<ans<<\' \';\n        }\n    }\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']",,,"['brute force', 'data structures', 'dp', 'implementation', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Sum of Progression.json,https://codeforces.com//blog/entry/124757,The key idea is that we know how to calculate the sum for fast we need to calculate all prefix sums and for then take the difference between the th and th of and subtract the difference between the th and th multiplied by This way queries with step will be processed in time where is the total amount of queries with step 1 But this idea can be generalized to the following we can precalculate all the prefix sums and all the prefix sums with multiplication by index for every in time and then process all queries with step in time However for all other queries we can process a single query in time because the difference between consecutive elements in the resulting sequence is greater than Combining these two ideas we get a solution with a time complexity Setting we get a solution with a time complexity The model solution fixes the value of which is equal to Interestingly this solution can be generalized to calculate the sums 
https://codeforces.com//contest/1569/problem/D,1103182,D,1569D,1569,D. Inconvenient Pairs,There is a city that can be represented as a square grid with corner points in 0 0 and 10 6 10 6 The city has n vertical and m horizontal streets that goes across the whole city i e the i th vertical streets goes from x i 0 to x i 10 6 and the j th horizontal street goes from 0 y j to 10 6 y j All streets are bidirectional Borders of the city are streets as well There are k persons staying the p th person at point x p y p so either x p equal to some x i or y p equal to some y j or both Let s say that a pair of persons form an if the shortest path from one person to another going only by streets is than the Manhattan distance between them Calculate the number of inconvenient pairs of persons pairs x y and y x are the same pair Let s recall that Manhattan distance between points x 1 y 1 and x 2 y 2 is x 1 x 2 y 1 y 2 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\n\nvoid solve() {\n    int N, M, K; cin >> N >> M >> K;\n    set<int> st[2];\n    F0R(i, N) {\n        int X; cin >> X; st[0].ins(X);\n    }\n    F0R(i, M) {\n        int X; cin >> X; st[1].ins(X);\n    }\n\n    map<int, int> cnt[2];\n    map<pi, int> cnt2[2];\n    st[0].ins(-1); st[1].ins(-1);\n    F0R(i, K) {\n        int X, Y; cin >> X >> Y;\n        if (!st[0].count(X)) {\n            auto it = --(st[0].lb(X));\n            cnt[0][*it]++;\n            cnt2[0][{*it, Y}]++;\n        }\n        if (!st[1].count(Y)) {\n            auto it = --(st[1].lb(Y));\n            cnt[1][*it]++;\n            cnt2[1][{*it, X}]++;\n        }\n    }\n    ll ans = 0;\n    F0R(i, 2) {\n        trav(a, cnt[i]) {\n            ll cur = a.s; ans += cur * (cur - 1) / 2;\n            //dbg(i, a.f, a.s);\n        }\n        trav(a, cnt2[i]) {\n            ll cur = a.s; ans -= cur * (cur - 1) / 2;\n        }\n    }\n    cout << ans << nl;\n\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']",,,"['binary search', 'data structures', 'implementation', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Inconvenient Pairs.json,https://codeforces.com//blog/entry/94721,Firstly let s look at some point Let s find closest to it vertical and horizontal lines We will name the closest vertical lines from left and right as and and and as closest horizontal lines So and we can also note that either or Now let s note that if for some other point either or then to reach from we must go reach either or or or so the shortest distance will be strictly greater than the Manhattan distance If neither nor then we can show that it s always possible to find the shortest path equal to the Manhattan distance As a result for each point we should find the number of points such that and or The exception here is when lies on the same line as so we should not count such points We can note that since either or there is no such point that and simultaneously so we can calculate the pairs by and coordinates independently Let s focus on coordinates to calculate for coordinates we can just swap all coordinates Let s sort all points by coordinate To get rid of the case when points and lies on the same vertical street we can group them by coordinate and process by group since we sorted by groups are just segments There are no problems with the case when points lie on the same horizontal street since then and there are no other with If we store for each horizontal line the number of point inside the interval then when we need for point calculate the number of points with and we can just ask for value assigned to because and are consecutive elements in the array So we go through each group two times first collecting answer then updating values in appropriate s Note that we can calculate and with binary search using built in functions The resulting complexity is 
https://codeforces.com//contest/2014/problem/D,2892476,D,2014D,2014,D. Robert Hood and Mrs Hood,Robin s brother and mother are visiting and Robin gets to choose the start day for each visitor All days are numbered from 1 to n Visitors stay for d continuous days all of those d days must be between day 1 and n inclusive Robin has a total of k risky jobs planned The i th job takes place between days l i and r i inclusive for 1 le i le k If a job takes place on any of the d days the visit overlaps with this job the length of overlap is unimportant Robin wants his brother s visit to overlap with the maximum number of and his mother s the minimum Find suitable start days for the visits of Robin s brother and mother If there are multiple suitable days choose the earliest one ,"[""#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, d, k;PII a[N];vector<int> e[N];void solve(){    cin >> n >> d >> k;    for (int i = 1; i <= n; i++)        e[i].clear();    for (int i = 1; i <= k; i++)    {        int l, r;        cin >> l >> r;        e[l].push_back(r);    }    priority_queue<int, vector<int>, greater<int>> q;    PII ans;    for (int i = 1; i <= d; i++)    {        for (auto to : e[i])            q.push(to);    }    ans = {q.size(), -1};    PII ans2 = {ans.first, 1};    for (int i = 2; i <= n - d + 1; i++)    {        while (!q.empty() && q.top() < i)            q.pop();        for (auto to : e[i + d - 1])            q.push(to);        ans = max(ans, {(int)q.size(), -i});        ans2 = min(ans2, {(int)q.size(), i});    }    cout << -ans.second << ' ' << ans2.second << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}""]",,,"['brute force', 'data structures', 'greedy', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Robert Hood and Mrs Hood.json,https://codeforces.com/blog/entry/134093,Since the number of days n is capped we can check all possible start day x in range 1 n d 1 so that the duration of d days would fit We would like to find the number of overlapped jobs for each value of x A job between days li and ri would overlap with the visit if the start day x satisfies li d 1 x ri Naively this range update could be potentially O n which is too slow However noting the start and end each job update could be done in 2 operations We add 1 at li d 1 and 1 at ri 1 and after all jobs are recorded we will take a prefix sum to work out the number of overlapped jobs for each x When li d 1 drops below 1 we simply use 1 to avoid lower values which are not being considered for x The time complexity is O n Note Robin s risky jobs are generally deemed illegal by the Sheriff of Nottingham Robert is practical and helpful Like all good parents Mrs Hood is a worrier 
https://codeforces.com//contest/909/problem/D,142270,D,909D,909,D. Colorful Points,You are given a set of points on a straight line Each point has a color assigned to it For point its neighbors are the points which don t have any other points between them and Each point has at most two neighbors one from the left and one from the right You perform a sequence of operations on this set of points In one operation you delete all points which have a neighbor point of a different color than the point itself Points are deleted simultaneously i e first you decide which points have to be deleted and then delete them After that you can perform the next operation etc If an operation would not delete any points you can t perform it How many operations will you need to perform until the next operation does not have any points to delete ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+5;\n\nint l[maxn],r[maxn],n,ans;\nchar s[maxn];\nvector<int> q,q2;\nbool vis[maxn];\n\ninline bool chk(int i){return (l[i]&&s[l[i]]!=s[i])||(r[i]<=n&&s[r[i]]!=s[i]);}\ninline void clr(int i){r[l[i]]=r[i],l[r[i]]=l[i];}\n\nint main()\n{\n\tscanf(""%s"",s+1),n=strlen(s+1);\n\tr[0]=1,l[n+1]=n,vis[0]=vis[n+1]=1;\n\tfor(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;\n\tfor(int i=1;i<=n;i++)if(chk(i))\n\t\tq.push_back(i),vis[i]=1;\n\twhile(!q.empty())\n\t{\n\t\t++ans;\n\t\tfor(auto i:q)q2.push_back(l[i]),q2.push_back(r[i]),clr(i);\n\t\tq.clear();\n\t\tfor(auto i:q2)if(i&&i<=n&&!vis[i]&&chk(i))\n\t\t\tvis[i]=1,q.push_back(i);\n\t\tq2.clear();\n\t}\n\treturn printf(""%d"",ans),0;\n}']",,,"['data structures', 'greedy', 'implementation']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Colorful Points.json,https://codeforces.com//blog/entry/56666,We can simulate the process described in the problem step by step but this is too slow a straightforward simulation iterate over all points when deciding which ones to delete has an complexity and takes too long A solution with better complexity is required Let s consider continuous groups of points of same color Any points inside a group are safe during the operation only points at the border of a group are deleted except for the leftmost point of the leftmost group and the rightmost point of the rightmost group if these groups have more than one point So if current group sizes are from left to right group sizes after performing the first operation are after the second operation and so on This process continues until at least one of the groups disappears completely at which point its adjacent groups may get merged if they are of the same color This way multiple operations can be simulated at once Find the number of operations that are required for at least one group to disappear Update group sizes after this number of operations Remove empty groups Merge adjacent groups of the same color One update done this way requires time During such an update at least one point from each group is deleted so at least points are removed If is the initial number of points we can remove at most points in total Therefore running time of the algorithm is 
https://codeforces.com//contest/1328/problem/B,573968,B,1328B,1328,B. K-th Beautiful String,For the given integer n n 2 let s write down all the strings of length n which contain n 2 letters and two letters in alphabetical order Recall that the string s of length n is lexicographically less than string t of length n if there exists such i 1 le i le n that s i t i and for any j 1 le j i s j t j The lexicographic comparison of strings is implemented by the operator in modern programming languages For example if n 5 the strings are the order does matter It is easy to show that such a list of strings will contain exactly frac n cdot n 1 2 strings You are given n n 2 and k 1 le k le frac n cdot n 1 2 Print the k th string from the list ,"[""// clang-format off\n// powered by c++11\n// by Isaunoya\n#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i=(x);i<=(y);++i)\n#define Rep(i,x,y) for(register int i=(x);i>=(y);--i)\nusing namespace std;using db=double;using ll=long long;\nusing uint=unsigned int;using ull=unsigned long long;\nusing pii=pair<int,int>;\n#define Tp template\n#define fir first\n#define sec second\nTp<class T>void cmax(T&x,const T&y){if(x<y)x=y;}Tp<class T>void cmin(T&x,const T&y){if(x>y)x=y;}\n#define all(v) v.begin(),v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\nTp<class T>void sort(vector<T>&v){sort(all(v));}Tp<class T>void reverse(vector<T>&v){reverse(all(v));}\nTp<class T>void unique(vector<T>&v){sort(all(v)),v.erase(unique(all(v)),v.end());}inline void reverse(string&s){reverse(s.begin(),s.end());}\nconst int SZ=1<<23|233;\nstruct FILEIN{char qwq[SZ],*S=qwq,*T=qwq,ch;\n#ifdef __WIN64\n#define GETC getchar\n#else\ninline char GETC(){return(S==T)&&(T=(S=qwq)+fread(qwq,1,SZ,stdin),S==T)?EOF:*S++;}\n#endif\ninline FILEIN&operator>>(char&c){while(isspace(c=GETC()));return*this;}inline FILEIN&operator>>(string&s){s.clear();while(isspace(ch=GETC()));if(!~ch)return*this;s=ch;while(!isspace(ch=GETC())&&~ch)s+=ch;return*this;}\ninline FILEIN&operator>>(char*str){char*cur=str;while(*cur)*cur++=0;cur=str;while(isspace(ch=GETC()));if(!~ch)return*this;*cur=ch;while(!isspace(ch=GETC())&&~ch)*++cur=ch;*++cur=0;return*this;}\nTp<class T>inline void read(T&x){bool f=0;while((ch=GETC())<48&&~ch)f^=(ch==45);x=~ch?(ch^48):0;while((ch=GETC())>47)x=x*10+(ch^48);x=f?-x:x;}\ninline FILEIN&operator>>(int&x){return read(x),*this;}inline FILEIN&operator>>(ll&x){return read(x),*this;}inline FILEIN&operator>>(uint&x){return read(x),*this;}inline FILEIN&operator>>(ull&x){return read(x),*this;}\ninline FILEIN&operator>>(double&x){read(x);bool f=x<0;x=f?-x:x;if(ch^'.')return*this;double d=0.1;while((ch=GETC())>47)x+=d*(ch^48),d*=.1;return x=f?-x:x,*this;}\n}in;\nstruct FILEOUT{const static int LIMIT=1<<22;char quq[SZ],ST[233];int sz,O,pw[233];\nFILEOUT(){set(7);rep(i,pw[0]=1,9)pw[i]=pw[i-1]*10;}~FILEOUT(){flush();}\ninline void flush(){fwrite(quq,1,O,stdout),fflush(stdout),O=0;}\ninline FILEOUT&operator<<(char c){return quq[O++]=c,*this;}inline FILEOUT&operator<<(string str){if(O>LIMIT)flush();for(char c:str)quq[O++]=c;return*this;}\ninline FILEOUT&operator<<(char*str){if(O>LIMIT)flush();char*cur=str;while(*cur)quq[O++]=(*cur++);return*this;}\nTp<class T>void write(T x){if(O>LIMIT)flush();if(x<0){quq[O++]=45;x=-x;}do{ST[++sz]=x%10^48;x/=10;}while(x);while(sz)quq[O++]=ST[sz--];}\ninline FILEOUT&operator<<(int x){return write(x),*this;}inline FILEOUT&operator<<(ll x){return write(x),*this;}inline FILEOUT&operator<<(uint x){return write(x),*this;}inline FILEOUT&operator<<(ull x){return write(x),*this;}\nint len,lft,rig;void set(int l){len=l;}inline FILEOUT&operator<<(double x){bool f=x<0;x=f?-x:x,lft=x,rig=1.*(x-lft)*pw[len];return write(f?-lft:lft),quq[O++]='.',write(rig),*this;}\n}out;\n#define int long long\nstruct Math{\nvector<int>fac,inv;int mod;\nvoid set(int n,int Mod){fac.resize(n+1),inv.resize(n+1),mod=Mod;rep(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;inv[n]=qpow(fac[n],mod-2);Rep(i,n-1,0)inv[i]=inv[i+1]*(i+1)%mod;}\nint qpow(int x,int y){int ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}int C(int n,int m){if(n<0||m<0||n<m)return 0;return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint gcd(int x,int y){return!y?x:gcd(y,x%y);}int lcm(int x,int y){return x*y/gcd(x,y);}\n}math;\n// clang-format on\nsigned main(){\n\t//code begin.\n\tint _;\n\tin >> _;\n\twhile(_ --) {\n\t\tint n , k;\n\t\tin >> n >> k;\n\t\tk --;\n\t\tint pos1 = n - 2, pos2 = n - 1, cnt = 1;\n\t\twhile(k) {\n\t\t\tif(k < cnt) {\n\t\t\t\tpos2 -= k;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tpos1 --;\n\t\t\tk -= cnt;\n\t\t\tcnt ++;\n\t\t}\n\t\trep(i , 0 , n - 1) {\n\t\t\tif(i == pos1 || i == pos2) {\n\t\t\t\tout << 'b' ;\n\t\t\t}\n\t\t\telse \n\t\t\t\tout << 'a' ;\n\t\t}\n\t\tout << '\\n';\n\t}\n\treturn 0;\n\t//code end.\n}\n""]",,,"['binary search', 'brute force', 'combinatorics', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. K-th Beautiful String.json,https://codeforces.com//blog/entry/75246,Let s try to find the position of the leftmost occurrence of iterate over all positions from to If then this is the required position of the leftmost occurrence of Then the position of rightmost occurrence is so we can print the answer Otherwise let s decrease by remove all strings which have the leftmost at the current position and proceed to the next position It is obvious that in such a way we consider all possible strings in lexicographic order 
https://codeforces.com//contest/1854/problem/E,2119351,E,1854E,1854,E. Game Bundles,Rishi is developing games in the 2D metaverse and wants to offer game bundles to his customers Each game has an associated enjoyment value A game bundle consists of a subset of games whose total enjoyment value adds up to 60 Your task is to choose k games where 1 leq k leq 60 along with their respective enjoyment values a 1 a 2 dots a k in such a way that exactly m distinct game bundles can be formed ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst int d=60;\n\nll m;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid dorzuc(vll &wek, int dod)\n{\n\tfor (int i=d; i>=dod; i--)\n\t\twek[i]+=wek[i-dod];\n}\n\nint los(int a, int b)\n{\n\treturn a+rand()%(b-a+1);\n}\n\nvi zbi;\n\nvoid check(vll &wek)\n{\n\tif (wek[d]>m)\n\t\treturn;\n\tll ile=zbi.size();\n\tvector<pll> jakie;\n\tll s=wek[d];\n\twhile(s<m)\n\t{\n\t\tint g=0;\n\t\tfor (int i=0; i<d/2; i++)\n\t\t\tif (s+wek[i]<=m && wek[i]>wek[g])\n\t\t\t\tg=i;\n\t\tll moge=(m-s)/wek[g];\n\t\tile+=moge;\n\t\ts+=moge*wek[g];\n\t\tjakie.push_back({d-g, moge});\n\t}\n\t//~ debug() << imie(ile);\n\tif (ile<=d)\n\t{\n\t\tfor (pll i : jakie)\n\t\t\tfor (int j=0; j<i.second; j++)\n\t\t\t\tzbi.push_back(i.first);\n\t\tvll now(d+1);\n\t\tnow[0]=1;\n\t\tfor (int i : zbi)\n\t\t\tdorzuc(now, i);\n\t\tassert(now[d]==m);\n\t\tprintf(""%d\\n"", (int)zbi.size());\n\t\tfor (int i : zbi)\n\t\t\tprintf(""%d "", i);\n\t\tprintf(""\\n"");\n\t\texit(0);\n\t}\n}\n\nint main()\n{\n\tscanf(""%lld"", &m);\n\tfor (int p=1; 1; p++)\n\t{\n\t\t//~ debug() << ""proba "" << p;\n\t\tvll dp(d+1);\n\t\tdp[0]=1;\n\t\tzbi.clear();\n\t\tint lim=los(1, 29);\n\t\tfor (int h=1; h<=60; h++)\n\t\t{\n\t\t\tcheck(dp);\n\t\t\t//~ int x=los(1, 29);\n\t\t\tint x=los(1, lim);\n\t\t\tzbi.push_back(x);\n\t\t\tdorzuc(dp, x);\n\t\t}\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'dp', 'greedy', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Game Bundles.json,https://codeforces.com//blog/entry/118540,SolutionWe describe a randomized solution that solves the problem for up to and with some additional care may be able to solve also up to We decided to give the problem with the smaller constraint to make the problem more accessible and because there may be some rare cases below for which our solution is too slow even though we could not find any We don t know any provably correct solution if you have one we would be curious to see it We expect to see many different solutions for this problem Main idea Choose suitably the values that belong to and then find in by solving a backpack like problem Let us describe more precisely the main idea Assume that are fixed and they satisfy For any let be the number of subsets so that If we can find some values so that then by setting for we have found a valid solution to the problem There are two main difficulties How can we find How should we choose Since it is important to get a good intuitive understanding of the computational complexity of the algorithm let us say now that we will choose and accordingly These values are flexible the solution would still work with and for example We will say something more about the choice of these values when we will describe how shall be chosen The backpack problem to find The naive way to find would be to try all of them There are possible ways up to order which does not matter Since this number is which is too much to fit in the time limit To speed up the process we will do as follows Partition randomly into two sets of size We iterate over all possible and over all possible and check whether the sum of one choice from the first group and one choice from the second group yields the result This is a standard optimization for the subset sum problem What is its complexity It can be implemented in linear time in the size of the two groups we have to iterate over which have size Notice that in this faster way we will not visit all the possible choices because we are assuming that exactly half of them belong to and exactly half of them belong to This is not a big deal because with sufficiently high probability we will find a solution in any case The choice of It remains to decide how we should select The following choice works Approximately the first values are set equal to Five additional values are chosen randomly from so that the total sum stays below One should repeat the whole process until a solution is found Some intuition on the construction The choice of may seem arbitrary let us try to justify it The goal is to generate a set of values that are simultaneously random enough and with size smaller but comparable to These two conditions are necessary to expect that the backpacking problem finds a solution with high enough probability If then and these numbers have size comparable to if is comparable to This observation explains why we start with approximately ones The issue is that we need some flexibility in the process as we may need to repeat it many times this flexibility is provided by the addition of some additional random elements which don t change the magnitude of the values but that modify them as much as possible if we added a large number it would not affect many and thus it would not be very useful 
https://codeforces.com//contest/1922/problem/C,2433276,C,1922C,1922,C. Closest Cities,There are n cities located on the number line the i th city is in the point a i The coordinates of the cities are given in ascending order so a 1 a 2 dots a n The distance between two cities x and y is equal to a x a y For each city i let s define the city j as the city such that the distance between i and j is not greater than the distance between i and each other city k For example if the cities are located in points 0 8 12 15 20 then the closest city to the city 1 is the city 2 the closest city to the city 2 is the city 3 the closest city to the city 3 is the city 4 the closest city to the city 4 is the city 3 the closest city to the city 5 is the city 4 The cities are located in such a way that for every city the closest city is unique For example it is impossible for the cities to be situated in points 1 2 3 since this would mean that the city 2 has two closest cities 1 and 3 both having distance 1 You can travel between cities Suppose you are currently in the city x Then you can perform one of the following actions travel to any other city y paying a x a y coins travel to the city which is the closest to x paying 1 coin You are given m queries In each query you will be given two cities and you have to calculate the minimum number of coins you have to spend to travel from one city to the other city ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include ""debug.h""  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& ai : a) { cin >> ai; }\n    vector<int> b(n), c(n);\n    for (int i = 1; i < n; i += 1) {\n      if (i == 1 or a[i] - a[i - 1] < a[i - 1] - a[i - 2]) {\n        b[i] = a[i] - a[i - 1] - 1;\n      }\n      b[i] += b[i - 1];\n    }\n    for (int i = n - 2; i >= 0; i -= 1) {\n      if (i == n - 2 or a[i + 1] - a[i] < a[i + 2] - a[i + 1]) {\n        c[i] = a[i + 1] - a[i] - 1;\n      }\n      c[i] += c[i + 1];\n    }\n    int m;\n    cin >> m;\n    for (int i = 0, x, y; i < m; i += 1) {\n      cin >> x >> y;\n      x -= 1;\n      y -= 1;\n      int ans = abs(a[x] - a[y]);\n      cout << ans - (x < y ? b[y] - b[x] : c[y] - c[x]) << ""\\n"";\n    }\n  }\n}']",,,"['greedy', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Closest Cities.json,https://codeforces.com//blog/entry/124890,Important observation the answer will not change if you are allowed to move only to adjacent cities It is true because if you move to a non adjacent city you can split the path to that city into parts without increasing its cost So the shortest way from to consider the case is to move from city to city for coin if it s possible or for if it s not Then move from city to city for coin if it s possible or for coins if it s not And so on until we reach the city Now let s calculate two arrays and is equal to the minimum amount of coins to reach the city from city from left to right is equal to the minimum amount of coins to reach the city from city from right to left Both of these arrays can be precalculated just like the arrays of prefix sums are calculated For example and so on Here denotes the cheapest way to travel between two adjacent cities and Then the cheapest way between two cities and can be calculated in the same way as the sum on subarray is calculated for the prefix sum array There are two cases If then the answer is If then the answer is 
https://codeforces.com//contest/1843/problem/F1,1972496,F1,1843F1,1843,F1. Omsk Metro  simple version ,As is known Omsk is the capital of Berland Like any capital Omsk has a well developed metro system The Omsk metro consists of a certain number of stations connected by tunnels and between any two stations there is exactly one path that passes through each of the tunnels no more than once In other words the metro is a tree To develop the metro and attract residents the following system is used in Omsk Each station has its own weight x in 1 1 If the station has a weight of 1 then when the station is visited by an Omsk resident a fee of 1 burle is charged If the weight of the station is 1 then the Omsk resident is rewarded with 1 burle Omsk Metro currently has only one station with number 1 and weight x 1 Every day one of the following events occurs You are a friend of Alex so your task is to answer Alex s questions daggerSubsegment continuous sequence of elements ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m,q;\nint dmx[N],dmn[N];\nint emx[N],emn[N];\nint val[N];\nvoid solve()\n{\n\tn=read();\tint cnt=1;\n\temn[1]=0;\temx[1]=1;\n\tdmn[1]=0;\tdmx[1]=1;\n\tval[1]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tchar opt;\n\t\tcin>>opt;\n\t\tif(opt==\'+\')\n\t\t{\n\t\t\tint x=read();\tint y=++cnt;\tint z=read();\n\t\t\tval[y]=val[x]+z;\n\t\t\tdmn[y]=min(dmn[x],val[y]);\n\t\t\tdmx[y]=max(dmx[x],val[y]);\n\t\t\t\n\t\t\temn[y]=min(emn[x],val[y]-dmx[y]);\n\t\t\temx[y]=max(emx[x],val[y]-dmn[y]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=read();\tint y=read();\tint z=read();\n\t\t\tif(emn[y]<=z&&z<=emx[y])\tputs(""YES"");\n\t\t\telse\tputs(""NO""); \n\t\t}\n\t}\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}\n']",,,"['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'math', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F1. Omsk Metro  simple version .json,https://codeforces.com//blog/entry/117468,Let be the maximal sum on the path subsegment the minimal sum on the path subsegment Then it is said that a subsegment with sum exists if and only if Proof Let us fix the subsegment with the minimum sum and the subsegment with the maximum sum Now we want to go from the first segment to the second one by consecutively removing or adding elements from the ends of the segment Note that due to the fact that for each such action the sum on the segment will change by exactly In other words no matter how we go from one segment to another the sum will remain a discretely continuous value Then since this function takes values of the minimum and maximum sum it also takes all values from the segment between them by the intermediate value theorem Thus the set of all possible sums on the subsegments is the interval of integers between the minimum and maximum sum from which the original assumption follows Now we have turned the problem down to finding the subsegment with the minimum and maximum sum on the path in the tree Let be the maximum sum on the subsegment on the path from to the maximum sum on the suffix of the path from to the ancestor of vertex its weight Then Thus we have learned to calculate the necessary values for a vertex immediately at the moment of its addition which allows us to solve the problem online but it is not required in the problem itself The values for the minimum are counted in the same way Total complexity 
https://codeforces.com//contest/358/problem/E,3808,E,358E,358,E. Dima and Kicks,Dima is a good person In fact he s great But all good things come to an end Seryozha is going to kick Dima just few times For this reason he divides the room into unit squares Now the room is a rectangle consisting of unit squares For the beginning Seryozha put Dima in a center of some square Then he started to kick Dima it is known that he kicks Dima at least once Each time when Dima is kicked he flyes up and moves into one of four directions up left right down On each move Dima passes unit of the length in the corresponding direction Seryozha is really kind so he kicks Dima in such way that Dima never meets the walls in other words Dima never leave the room s space Seryozha is also dynamic character so Dima never flies above the same segment connecting a pair of adjacent squares twice Seryozha kicks Dima for a long time but Dima is not vindictive Dima writes Dima marked all squares in which he was staying or above which he was flying Thanks to kicks Dima does not remember the value so he asks you to find all possible values which matches to the Dima s records ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define FI first\n#define SE second\n#define MP make_pair\n#define PII pair<int,int>\n#define flt double\n#define INF (0x3f3f3f3f)\n#define MaxN 1020300\n#define MaxNode 1020304\n#define MD 1000000007\n#define UPD(a,b) { a = max(a,(b)); }\n\nconst int pi[] = {0,1,0,-1};\nconst int pj[] = {1,0,-1,0};\n\nint n,m,A[1111][1111],u[1111][1111],l[1111][1111],vis[1111][1111];\nint can[6];\nPII q[MaxN];\n\nint main() {\n\t//freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);\n\tcin >> n >> m;\n\tFill(A,0);\n\tFor(i,1,n) For(j,1,m) scanf(""%d"",&A[i][j]);\n\tFill(vis,0); int cnt = 0; \n\tFor(i,1,n) For(j,1,m) if (!vis[i][j] && A[i][j] == 1) {\n\t\t++cnt;\n\t\tint hd = 0, tl = 1;\n\t\tvis[i][j] = true; q[1] = MP(i,j);\n\t\twhile (hd < tl) {\n\t\t\tPII vex = q[++hd];\n\t\t\tFor(p,0,3) {\n\t\t\t\tint ni = vex.FI + pi[p], nj = vex.SE + pj[p];\n\t\t\t\tif (!vis[ni][nj] && ni && nj && ni <= n && nj <= m && A[ni][nj] == 1) {\n\t\t\t\t\tvis[ni][nj] = true;\n\t\t\t\t\tq[++tl] = MP(ni,nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt > 1) {\n\t\tputs(""-1""); return 0;\n\t}\n\tint odd = 0,GCD = 0;\n\tFor(i,1,n) For(j,1,m) {\n\t\tif (!A[i][j]) {\n\t\t\tl[i][j] = u[i][j] = 0; continue ;\n\t\t}\n\t\tl[i][j] = l[i][j - 1] + 1;\n\t\tu[i][j] = u[i - 1][j] + 1;\n\t\tFill(can,0);\n\t\tint sm = 0;\n\t\tFor(p,0,3) {\n\t\t\tint ni = i + pi[p], nj = j + pj[p];\n\t\t\tif (A[ni][nj]) can[p] = true;\n\t\t\tsm += can[p];\n\t\t}\n\t\tif (sm == 2 && ((can[0] && can[2]) || (can[1] && can[3]))) continue ;\n\t\todd += sm & 1;\n\t\tGCD = __gcd(GCD,l[i][j] - 1);\n\t\tGCD = __gcd(GCD,u[i][j] - 1);\n\t}\n\tif (GCD <= 1 || (odd != 0 && odd != 2)) {\n\t\tputs(""-1""); return 0;\n\t}\n\tFor(i,2,max(n,m)) if (GCD % i == 0) printf(""%d "",i); puts("""");\n\treturn 0;\n}\n']",,,"['brute force', 'dsu', 'graphs', 'implementation']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Dima and Kicks.json,https://codeforces.com/blog/entry/9334,The first thing to understand is that the answer is the divisor of maximal length sequence of standing one by one ones Let s iterate trough this number Now we should check the table knowing the value of Let s find the most left of ones and choose from them the most top Let it be then after each step Dima can appear inly in cells which look like Let such cells are the vertexes of the graph And sequences of ones the ribs We will build the graph We should check that there are no additional ones in table We should also check if the graph is connected and has en Euler s path The value of K is the next answer under the all conditions The correct implementation will have the complexity In reality it will be never achieved 
https://codeforces.com//contest/1606/problem/B,1163613,B,1606B,1606,B. Update Files,Berland State University has received a new update for the operating system Initially it is installed only on the 1 st computer Update files should be copied to all n computers The computers are not connected to the internet so the only way to transfer update files from one computer to another is to copy them using a patch cable a cable connecting two computers directly Only one patch cable can be connected to a computer at a time Thus from any computer where the update files are installed they can be copied to some other computer in exactly one hour Your task is to find the minimum number of hours required to copy the update files to all n computers if there are only k patch cables in Berland State University ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tint f=1;char c;x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=200005;\n\nvoid solve()\n{\n\tll n,k;\n\treadint(n),readint(k);\n\tll u=1,s=1,c=0;\n\tif(s>=n){printf(""%lld\\n"",c);return;}\n\tfor(;u<=k;u*=2)\n\t{\n\t\ts+=u,++c;\n\t\tif(s>=n){printf(""%lld\\n"",c);return;}\n\t}\n\tprintf(""%lld\\n"",c+(n-s+k-1)/k);\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Update Files.json,https://codeforces.com//blog/entry/96454,Let be the current number of computers with the update already installed initially it is Then in hour we can increase by From here we can see that the value of will double for the first few hours and then when it becomes greater than it will begin to increase by exactly The process when the number of computers doubles can be modeled using a loop because the number of doublings does not exceed And after that we have to increase the answer by to take the number of additions of into account Note that computing should be done without using fractional data types to calculate in integers you should divide by using integer division this will work provided that both and are non negative and If you use real numbers this may cause precision issues 
https://codeforces.com//contest/1941/problem/C,2523369,C,1941C,1941,C. Rudolf and the Ugly String,Rudolf has a string s of length n Rudolf considers the string s to be ugly if it contains the substring dagger or the substring otherwise the string s will be considered beautiful For example are ugly strings while are beautiful strings Rudolf wants to shorten the string s by removing some characters to make it beautiful The main character doesn t like to strain so he asks you to make the string beautiful by removing the minimum number of characters He can remove characters from positions in the string not just from the beginning or end of the string dagger String a is a substring of b if there exists a segment of characters in string b equal to a ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n ; cin >> n ;\n    string s ; cin >> s ;\n    int ans = 0 ;\n    if( s.size() >= 3 )\n    FOR( i , s.size() - 2 ){\n    \tif( s[ i ] == \'p\' && s[ i + 1 ] == \'i\' && s[ i + 2 ] == \'e\' ){\n    \t\tans ++ ; continue ; \n\t\t}\n\t\tif( s[ i ] == \'m\' && s[ i + 1 ] == \'a\' && s[ i + 2 ] == \'p\' ){\n    \t\tans ++ ; \n    \t\tif( i + 3 < s.size() && s[ i + 3 ] != \'p\' ){\n    \t\t\ti += 2 ; \n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << ""\\n"" ; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']",,,"['dp', 'greedy', 'strings']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Rudolf and the Ugly String.json,https://codeforces.com//blog/entry/127018,To solve this problem you need to find all occurrences of the substrings in the string and remove the middle character in each of them This way you will remove the minimum number of characters to ensure that the string does not contain the substrings and 
https://codeforces.com//contest/434/problem/B,9713,B,434B,434,B. Nanami s Digital Board,Nanami is an expert at playing games This day Nanami s good friend Hajime invited her to watch a game of baseball Unwilling as she was she followed him to the stadium But Nanami had no interest in the game so she looked around to see if there was something that might interest her That s when she saw the digital board at one end of the stadium The digital board is pixels in height and pixels in width every pixel is either light or dark The pixels are described by its coordinate The th pixel of the th line is pixel The board displays messages by switching a combination of pixels to light and the rest to dark Nanami notices that the state of the pixels on the board changes from time to time At certain times certain pixels on the board may switch from light to dark or from dark to light Nanami wonders what is the area of the biggest light block such that a specific pixel is on its side A light block is a sub rectangle of the board in which all pixels are light Pixel belongs to a side of sub rectangle with and as its upper left and lower right vertex if and only if it satisfies the logical condition or and or or and Nanami has all the history of changing pixels also she has some questions of the described type can you answer them ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\nint n, m, q;\nconst int MAX_N = 1000 + 10;\nint a[MAX_N][MAX_N];\n\nstruct TR {\n\tbool flip, swap;\n\tint n;\n\n\tTR() {\n\t}\n\n\tTR(bool f, bool s, int n) :\n\t\t\tflip(f), swap(s), n(n) {\n\t}\n\n\tvoid trans(int&r, int&c) {\n\t\tif (swap) {\n\t\t\tstd::swap(r, c);\n\t\t}\n\t\tif (flip) {\n\t\t\tr = n - 1 - r;\n\t\t}\n\t}\n};\n\nstruct Board {\n\tint a[MAX_N][MAX_N], n, m;\n\tint up[MAX_N][MAX_N]; //r,c\n\tTR tr;\n\n\tvoid init(int n, int m, TR tr) {\n\t\tthis->n = n, this->m = m;\n\t\tthis->tr = tr;\n\t}\n\n\tvoid set(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t}\n\n\tvoid reset(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t\tprocessCol(c);\n\t}\n\n\tvoid processCol(int c) {\n\t\tup[0][c] = a[0][c];\n\t\tfor (int r = 1; r < n; ++r) {\n\t\t\tif (a[r][c] == 1) {\n\t\t\t\tup[r][c] = up[r - 1][c] + 1;\n\t\t\t} else {\n\t\t\t\tup[r][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid doit() {\n\t\tfor (int c = 0; c < m; ++c) {\n\t\t\tprocessCol(c);\n\t\t}\n\t}\n\n\tint ask(int r, int c) {\n\t\ttr.trans(r, c);\n//\t\tcout << r << "" "" << c << endl;\n\t\t//at row r, above it ,contain column c\n\t\t//min at left\n\t\tstatic int what[MAX_N];\n\t\twhat[c] = up[r][c];\n\t\tfor (int i = c - 1; i >= 0; --i) {\n\t\t\twhat[i] = min(what[i + 1], up[r][i]);\n\t\t}\n\t\tfor (int i = c + 1; i < m; ++i) {\n\t\t\twhat[i] = min(what[i - 1], up[r][i]);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint R = c;\n\t\tfor (int i = c; i >= 0; --i) {\n\t\t\twhile (R + 1 < m && what[R + 1] >= what[i])\n\t\t\t\t++R;\n\t\t\tans = max(ans, what[i] * (R - i + 1));\n\t\t}\n\t\tint L = c;\n\t\tfor (int i = c; i < m; ++i) {\n\t\t\twhile (L > 0 && what[L - 1] >= what[i])\n\t\t\t\t--L;\n\t\t\tans = max(ans, what[i] * (i - L + 1));\n\t\t}\n\t\treturn ans;\n\t}\n} D[4];\n\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tscanf(""%d"", a[i] + j);\n\t\t}\n\t}\n\tD[0].init(n, m, TR(false, false, n));\n\tD[1].init(n, m, TR(true, false, n));\n\tD[2].init(m, n, TR(false, true, m));\n\tD[3].init(m, n, TR(true, true, m));\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\tD[i].set(r, c, a[r][c]);\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < D[i].m; ++c) {\n\t\t\tD[i].processCol(c);\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tint op;\n\t\tscanf(""%d"", &op);\n\t\tif (op == 1) {\n\t\t\tint r, c;\n\t\t\tscanf(""%d%d"", &r, &c), --r, --c;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tD[i].reset(r, c, 1 - a[r][c]);\n\t\t\t}\n\t\t\ta[r][c] = 1 - a[r][c];\n\t\t} else {\n\t\t\tint r, c;\n\t\t\tscanf(""%d%d"", &r, &c), --r, --c;\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tans = max(ans, D[i].ask(r, c));\n\t\t\t}\n\t\t\tprintf(""%d\\n"", ans);\n\t\t}\n\t}\n}\n']",,,"['divide and conquer', 'dp', 'dsu', 'implementation', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Nanami s Digital Board.json,https://codeforces.com//blog/entry/12397,Consider a similar problem find the maximum light block of the whole board Constraints to this problem are the same as the original problem but with no further operations A brute force idea would be to enumerate all four edges of the block checking can be done with two dimensional prefix sums so the time complexity is Obviously it would receive a TLE verdict Why should we enumerate all four edges Let s enumerate the lower and upper edge and now our problem is only one dimensional which can be easily solved in time Now our complexity is still not fast enough Let s try to enumerate the lower edge only and now what we have is an array denoting the maximum height of each column To be specific suppose the lower edge is row then is the maximum value such that are all light If we choose columns and as the left and right edge then the area of the maximum light block with these three sides fixed would be Let what if we enumerate and find the leftmost and the rightmost To be more specific we enumerate a column and let the height of this column be the height of the block Now we want to stretch the left and right sides of the block so we re looking for the leftmost column such that Similarly look for the rightmost column then the maximum light block with its lower edge and a point in the upper edge fixed would be This approach can be optimized with disjoint set unions abbr DSU Imagine that initially the array is empty Let s add the elements of one by one from the largest to the smallest Maintain two DSUs and denote them as and When we add an element set the father of as in so that will be skipped during the find operation of DSU Similarly set the father of as in Simply find the root of in and and we would have and Now this problem can be solved in quasi quadratic time We can actually further optimize it to quadratic time using monotonic queues but we ll not talk about it here Let s go back to the original problem Suppose there are no modifications operations only contain queries Then we could simply maintain the array of every row and similarly maintain and arrays Use the approach described above to achieve quasi linear time for the answering of a query Now consider modifications Modification of a single pixel only changes the values of positions of the arrays So modifications can be handled in linear time The total complexity for the algorithm is where is the inverse of the Ackermann function which is often seen in the analysis of the time complexity of DSUs Solution 6712937 6713016 
https://codeforces.com//contest/1957/problem/C,2603601,C,1957C,1957,C. How Does the Rook Move ,You are given an n times n chessboard where you and the computer take turns alternatingly to place white rooks black rooks on the board respectively While placing rooks you have to ensure that no two rooks attack each other Two rooks attack each other if they share the same row or column A valid move is placing a rook on a position r c such that it doesn t attack any other rook You start first and when you make a valid move in your turn placing a white rook at position r c the computer will mirror you and place a black rook at position c r in its turn If r c then the computer can t mirror your move and skips its turn You have already played k moves with the computer the computer tries to mirror these moves too and you must continue playing the game until there are no valid moves remaining How many different final configurations are possible when you continue the game after the k moves It is guaranteed that the k moves and the implied computer moves are valid Since the answer may be large print it modulo 10 9 7 Two configurations are considered different if there exists a coordinate r c which has a rook in one configuration but not in the other the color of the rook on the coordinate is different ,"['/*在发觉那一天 在那一天潮汛泛上高筑城墙时间请将一切证明*/#include<bits/stdc++.h>using namespace std;const int maxn=500005,mod=1000000007;int n,m,T,ans,flg,tot;int a[maxn],fac[maxn],nfac[maxn],inv[maxn],mul[maxn];inline int C(int a,int b){\treturn a<b? 0:1ll*fac[a]*nfac[b]%mod*nfac[a-b]%mod;}int main(){\tmul[0]=1;\tfor(int i=1;i<maxn;i++)\t\tmul[i]=(mul[i-1]+mul[i-1])%mod;\tfac[0]=fac[1]=inv[1]=nfac[0]=nfac[1]=1;\tfor(int i=2;i<maxn;i++)\t\tfac[i]=1ll*fac[i-1]*i%mod,inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod,nfac[i]=1ll*nfac[i-1]*inv[i]%mod;\tscanf(""%d"",&T);\twhile(T--){\t\tans=flg=0;\t\tscanf(""%d%d"",&n,&m),tot=n;\t\tfor(int i=1,x,y;i<=m;i++)\t\t\tscanf(""%d%d"",&x,&y),tot-=(x!=y),tot--;\t\tans=0;\t\tfor(int i=0;i*2<=tot;i++)\t\t\tans=(ans+1ll*C(tot,i+i)*C(i+i,i)%mod*fac[i])%mod;\t\tprintf(""%d\\n"",ans);\t}\treturn 0;}']",,,"['combinatorics', 'dp', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. How Does the Rook Move .json,https://codeforces.com//blog/entry/128716,There are essentially two types of moves Placing a rook at some This reduces the number of free rows and columns available by Placing a rook at some where The computer now mirrors this by placing a rook at blocking rows and along with columns and So the number of free rows and columns is reduced by First we account for the moves played earlier and count the number of free columns rows remaining to place rooks in and call it Notice that the order of removing rows columns doesn t affect the final configuration of rooks and hence only the count of rows matters to determine the number of final configurations We can use a dynamic programming approach where represents the number of final configurations when rows and columns are left Since the order of removing rows columns is unimportant let s start by removing the last row or column When removing the last row or column in an grid we have two options We place a rook resulting in the deletion of only the last row and column leaving an grid The number of final configurations in this case are given by Alternatively we can place a rook at or for any After this move both the th and the th rows and columns are deleted leaving an grid This contributes to Overall we compute for all with the base case of Our final answer is 
https://codeforces.com//contest/1864/problem/C,2181266,C,1864C,1864,C. Divisor Chain,You are given an integer x Your task is to reduce x to 1 To do that you can do the following operation select a divisor d of x then change x to x d i e reduce x by d We say that d is a divisor of x if d is an positive integer and there exists an integer q such that x d cdot q There is an additional constraint you select the same value of d For example for x 5 the following scheme is because 1 is selected more than twice 5 xrightarrow 1 4 xrightarrow 1 3 xrightarrow 1 2 xrightarrow 1 1 The following scheme is however a valid one 5 xrightarrow 1 4 xrightarrow 2 2 xrightarrow 1 1 Output any scheme which reduces x to 1 with at most 1000 operations It can be proved that such a scheme always exists ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvi pom;\nvi wyn;\n\nvoid solve(int n, int x)\n{\n\tif (n==1)\n\t\treturn;\n\t//~ debug() << n << "" "" << x;\n\tif (n&1)\n\t\tpom.push_back(x);\n\twyn.push_back(x);\n\tsolve(n/2, x*2);\n}\n\nvoid test()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\twyn.clear();\n\tpom.clear();\n\t\n\tsolve(n, 1);\n\t\n\t//~ reverse(pom.begin(), pom.end());\n\treverse(wyn.begin(), wyn.end());\n\tfor (int i : wyn)\n\t\tpom.push_back(i);\n\twyn=pom;\n\t//~ debug() << imie(wyn);\n\t\n\tprintf(""%d\\n"", (int)wyn.size()+1);\n\tprintf(""%d"", n);\n\tfor (int i : wyn)\n\t{\n\t\tn-=i;\n\t\tprintf("" %d"", n);\n\t}\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']",,,"['bitmasks', 'constructive algorithms', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Divisor Chain.json,https://codeforces.com//blog/entry/119772,TutorialLet us divide the task into two steps on each step we will use each divisor at most once For convenience let us denote as the largest value such that holds The two steps are as follows Reduce to Given any integer we can see that its lowest significant bit is a divisor of If has more than one bit we can repeatedly subtract the value corresponding to the lowest significant bit of When finally has only one bit finish the first step In this step we have only used each significant bit of at most once Reduce to We can find a way to reduce to by using each bit exactly once Formally if then and is a divisor of Thus by subtracting in order we reach from by using each bit from the th bit to the st bit exactly once As a result we can reduce to by using each power of at most twice once from the first step once from the second step Since we used each bit at most twice the time complexity for solving one test case is Due to the lenient constraints some solutions with time complexity should pass as well as long as they fit into the operations limit 
https://codeforces.com//contest/1627/problem/B,1262391,B,1627B,1627,B. Not Sitting,Rahul and Tina are looking forward to starting their new year at college As they enter their new classroom they observe the seats of students are arranged in a n times m grid The seat in row r and column c is denoted by r c and the distance between two seats a b and c d is a c b d As the class president Tina has access to k buckets of pink paint The following process occurs First Tina chooses exactly k seats in the classroom to paint with pink paint One bucket of paint can paint exactly one seat After Tina has painted k seats in the previous step Rahul chooses where he sits He will not choose a seat that has been painted pink due to his hatred of the colour pink After Rahul has chosen his seat Tina chooses a seat for herself She can choose any of the seats painted or not other than the one chosen by Rahul Rahul wants to choose a seat such that he sits as close to Tina as possible However Tina wants to sit as far away from Rahul as possible due to some complicated relationship history that we couldn t fit into the statement Now Rahul wonders for k 0 1 dots n cdot m 1 if Tina has k buckets of paint how close can Rahul sit to Tina if both Rahul and Tina are aware of each other s intentions and they both act as strategically as possible Please help satisfy Rahul s curiosity ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nint T;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tint n,m;\n\t\tscanf(""%d%d"",&n,&m);\n\t\tvector<tuple<int,int,int> >v;\n\t\trep(i,0,n-1)rep(j,0,m-1){\n\t\t\tv.eb(max({i+j,n-1-i+m-1-j,n-1-i+j,i+m-1-j}),i,j);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\teach(x,v)printf(""%d "",get<0>(x));\n\t\tputs("""");\n\t}\n\treturn 0;\n}']",,,"['games', 'greedy', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Not Sitting.json,https://codeforces.com//blog/entry/99067,Let s denote Rahul s seat as and Tina s seat as Notice that the in the distance between their seats and are independent of each other i e both the coordinate and coordinate of Tina s seat are independent From the answer to the hint above we can see that the optimal seat for Tina in a dimensional classroom is one of the edge seats and combining this with the previous observation means that the optimal seat for Tina is always one of the corner seats Since Rahul chooses seats optimally he will know that Tina will choose one of the corner seats so he will choose a seat such that the maximum distance from it to one of the corner seats is minimised As Tina also chooses which seats to paint optimally the best strategy for her is to paint the seats with minimum maximum distance to one of the corner seats pink We can implement this by calculating for each seat the maximum distance to one of the corner seats from it and storing these values in an array After sorting this array in non decreasing order we can simply print the first values of the array as the th value of the array indexed is the optimal answer for This can be implemented in time per test case 
https://codeforces.com//contest/416/problem/E,8299,E,416E,416,E. President s Path,Good old Berland has cities and roads Each road connects a pair of distinct cities and is bidirectional Between any pair of cities there is at most one road For each road we know its length We also know that the President will soon ride along the Berland roads from city to city Naturally he will choose one of the shortest paths from to but nobody can say for sure which path he will choose The Minister for Transport is really afraid that the President might get upset by the state of the roads in the country That is the reason he is planning to repair the roads in the possible President s path Making the budget for such an event is not an easy task For all possible distinct pairs find the number of roads that lie on at least one shortest path from to ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 500 + 10;\nconst int INF = 1000000000LL;\n\nint n;\nint a[N][N];\nlong long f[N][N];\nlong long minv[N], cnt[N];\nvector<pair<int, int> > adj[N];\n\nvoid solve()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tfor(int j = 0; j < n; ++ j) {\n\t\t\tf[i][j] = INF;\n\t\t}\n\t\tf[i][i] = 0;\n\t}\n\tint m;\n\tint u, v, l;\n\tcin >> m;\n\tfor(int i = 0; i < m; ++ i) {\n\t\tscanf(""%d%d%d"", &u, &v, &l);\n\t\t-- u, -- v;\n\t\tadj[u].push_back(make_pair(v, l));\n\t\tadj[v].push_back(make_pair(u, l));\n\t\tf[u][v] = f[v][u] = min(f[u][v], (long long)l);\n\t}\n\n\tfor(int k = 0; k < n; ++ k) {\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\tfor(int j = 0; j < n; ++ j) {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][k] + f[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int j = 1; j < n; ++ j) {\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\tminv[i] = INF;\n\t\t\tcnt[i] = 1;\n\t\t\tforeach(it, adj[i]) {\n\t\t\t\tint v = it->first;\n\t\t\t\tint tmp = it->second + f[v][j];\n\t\t\t\tif (tmp < minv[i]) {\n\t\t\t\t\tminv[i] = tmp;\n\t\t\t\t\tcnt[i] = 1;\n\t\t\t\t} else if (tmp == minv[i]) {\n\t\t\t\t\t++ cnt[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < j; ++ i) {\n\t\t\tif (f[i][j] == INF) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor(int k = 0; k < n; ++ k) {\n\t\t\t\tif (f[i][j] - f[i][k] == minv[k]) {\n\t\t\t\t\tret += cnt[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[i][j] = ret;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++ i)\n\t\tfor(int j = i + 1; j < n; ++ j) {\n\t\t\tprintf(""%d "", a[i][j]);\n\t\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n']",,,"['dp', 'graphs', 'shortest paths']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. President s Path.json,https://codeforces.com//blog/entry/12277,Let s look at the graph given to us in the example We need to count the count of the edges on all the shortest paths between each pair of vertices Let s do something easier first instead of counting all the edges we will count only those which have the destination vertex on its side For example here are the edges belonging to shortest paths from 4 to 2 which are connected to vertex 2 Let s denote this number like this number of edges which go into vertex on some shortest path from to In the given example Let s also denote the set it is a set of the vertices which belong to at least one shortest path from to For example With these two variables it can be seen that the answer for vertices and will be In other words the answer for vertices and will be equal to the sum of for all vertices which belong to any shortest path from to So the only thing left is to calculate these and Both of them can be easily calculated if you have minimum distances between all pairs of vertices And these distances can be calculated using the Floyd Warshall So the full solution is Calculate minimum distances between all pairs of vertices using Floyd Warshall algorithm Count Simply iterate over all source vertices and all edges For each edge check whether any of its ends belong to any shortest path from source Calculate the answer Let s have three loops to iterate over the vertices First two vertices are those for which we re calculating the answer Third vertex is the vertex which should belong to any shortest path basically we re checking whether belongs to If belongs to any shortest path from to then we add to the answer Each step has a complexity Submission 6607257 P S Please feel free to let me know about any typos errors etc using the private messages 
https://codeforces.com//contest/1067/problem/D,242830,D,1067D,1067,D. Computer Game,Ivan plays some computer game There are n quests in the game Each quest can be upgraded once this increases the reward for its completion Each quest has 3 parameters a i b i p i reward for completing quest before upgrade reward for completing quest after upgrade a i b i and probability of successful completing the quest Each second Ivan can try to complete one quest and he will succeed with probability p i In case of success Ivan will get the reward and opportunity to upgrade any one quest not necessary the one he just completed In case of failure he gets nothing Quests after completing Ivan has t seconds He wants to maximize expected value of his total gain after t seconds Help him to calculate this value ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 120000;\n\nint n;\nll t;\n\nld p[MAXN];\nll a[MAXN];\nvector<pair<ld, ld> > vv;\nld br[MAXN];\n\nld eps1 = 1e-12;\n\nbool bad(pair<ld, ld> a, pair<ld, ld> b, pair<ld, ld> c) {\n\treturn (b.second - a.second) / (a.first - b.first) >= (c.second - b.second) / (b.first - c.first);\n}\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\tscanf(""%d%lld"", &n, &t);\n\tld b = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tll B;\n\t\tscanf(""%lld%lld%Lf"", a + i, &B, p + i);\n\t\tb = max(b, B * p[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (p[i] != 0) {\n\t\t\tvv.emplace_back(1 - p[i], b - p[i] * a[i]);\n\t\t}\n\t}\n\tif (vv.size() == 0) {\n\t\tcout << 0 << ""\\n"";\n\t\treturn 0;\n\t}\n\tsort(ALL(vv));\n\treverse(ALL(vv));\n\tvector<pair<ld, ld>> st;\n\tfor (auto p: vv) {\n\t\tif (!st.empty() && abs(st.back().first - p.first) <= eps1) {\n\t\t\tif (st.back().second < p.second)\n\t\t\t\tcontinue;\n\t\t\tst.pop_back();\n\t\t}\n\t\twhile (st.size() >= 2 && bad(st[st.size() - 2], st[st.size() - 1], p))\n\t\t\tst.pop_back();\n\t\tst.push_back(p);\n\t}\n\tld k = 0;\n\tint now = 0;\n\tfor (int i = 0; i + 1 < st.size(); ++i)\n\t\tbr[i] = (st[i + 1].second - st[i].second) / (st[i].first - st[i + 1].first);\n\tll tmpt = t;\n\twhile (t) {\n\t\twhile (now + 1 < st.size() && br[now] <= k)\n\t\t\t++now;\n\t\tvector<pair<ld, ld>> go;\n\t\tgo.push_back(st[now]);\n\t\tfor (int i = 0; i < 40; ++i)\n\t\t\tgo.emplace_back(go.back().first * go.back().first, go.back().second * (1 + go.back().first));\n\t\tfor (int i = go.size() - 1; i >= 0; --i) {\n\t\t\tif ((1ll << i) <= t && (now + 1 == st.size() || go[i].first * k + go[i].second <= br[now])) {\n\t\t\t\tt -= (1ll << i);\n\t\t\t\tk = go[i].first * k + go[i].second;\n\t\t\t}\n\t\t}\n\t\tif (t) {\n\t\t\tk = go[0].first * k + go[0].second;\n\t\t\t--t;\n\t\t}\n\t}\n\tcout << tmpt * b - k << ""\\n"";\n\treturn 0;\n}\n\n\n']",,,"['dp', 'greedy', 'math', 'probabilities']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Computer Game.json,https://codeforces.com/blog/entry/62688,Let s denote as Independent of our strategy we cannot get more than in one second in expected value But if we could upgrade one quest we would upgrade the quest which maximizes and then try to complete only this quest each second thus getting to expected value each second Therefore our strategy looks like this try to complete quests in some order once we complete one quest we will always get to expected value each second This observation leads to DP solution Once we have one quest completed we already know what we will get so interesting states are only those in which no quests are completed yet Then it is not important what quests we tried to complete before the only important parameter is remaining time If we succeed then we will get as a reward and for remaining seconds we will get each second otherwise we get nothing and now only seconds left This solution works in time which is too slow We can slightly rewrite the formula for transition Now we can see that we take maximum value of functions in point We can build convex hull on these lines thus getting solution But that s not all We can actually prove that or after some substitutions and simplifications This we will prove by actual meaning of Take optimal solution for seconds and do the same for seconds except that we don t have last second so we will just drop our action But we can t gain more than in one second so this drop cannot decrease answer more than Thus the inequality is proven This means that we only move right along over convex hull so for each line there will be consecutive seconds in which we are using that line If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster Let s start with learning how to make many DP transitions when we are staying on one line for the whole time It is more clear using first formula for DP transition we don t have max now because we already know which line to use We can see that to get vector from vector we can apply linear transformation i e multiply by some matrix To apply it times just use binary exponentiation to get th power of transition matrix To determine how long we actually have to stay on given line we will use binary search on answer We know for which value of we should move to the next line and we know that increases with each second so we can try to stay on given line for some time and see if we should actually change the line This is already solution but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time Final complexity is 
https://codeforces.com//contest/1099/problem/A,278501,A,1099A,1099,A. Snowball,Today s morning was exceptionally snowy Meshanya decided to go outside and noticed a huge snowball rolling down the mountain Luckily there are two stones on that mountain Initially snowball is at height h and it has weight w Each second the following sequence of events happens snowball s weights increases by i where i is the current height of snowball then snowball hits the stone if it s present at the current height then snowball moves one meter down If the snowball reaches height zero it stops There are exactly two stones on the mountain First stone has weight u 1 and is located at height d 1 the second one u 2 and d 2 respectively When the snowball hits either of two stones it loses weight equal to the weight of that stone If after this snowball has negative weight then its weight becomes zero but the snowball continues moving as before Find the weight of the snowball when it stops moving that is it reaches height 0 ,"['#include <bits/stdc++.h>\n#define endl \'\\n\'\n\n//#pragma GCC optimize (""O3"")\n//#pragma GCC target (""sse4"")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nint w, h;\nint d1, d2, u1, u2;\n\nvoid read()\n{\n\tcin >> w >> h;\n\tcin >> u1 >> d1;\n\tcin >> u2 >> d2;\n}\n\nvoid solve()\n{\n\twhile(h)\n\t{\n\t\tw += h;\n\t\tif(h == d1) w -= u1, chkmax(w, 0); \n\t\tif(h == d2) w -= u2, chkmax(w, 0); \n\t\th--;\n\t}\n\n\tcout << w << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Snowball.json,https://codeforces.com/blog/entry/64331,This problem can be solved in many ways we will tell you one of them Let s just iterate through all the heights of from to Inside the loop we have to add to the weight of snowball and then check whether there is a stone at this height If there is then you need to check whether weight of snowball is more than weight of the stone If more then subtract the weight of the stone from weight of snowball if not then assign the weight of snowball value 0 Code ism OK tutorial 
https://codeforces.com//contest/1586/problem/C,1147383,C,1586C,1586,C. Omkar and Determination,Consider a grid in which some cells are empty and some cells are filled Call a cell in this grid if starting at that cell you can exit the grid by moving up and left through only empty cells This includes the cell itself so all filled in cells are not exitable Note that you can exit the grid from any leftmost empty cell cell in the first column by going left and from any topmost empty cell cell in the first row by going up Let s call a grid if given only which cells are exitable we can exactly determine which cells are filled in and which aren t You are given a grid a of dimensions n times m i e a grid with n rows and m columns You need to answer q queries 1 leq q leq 2 cdot 10 5 Each query gives two integers x 1 x 2 1 leq x 1 leq x 2 leq m and asks whether the subgrid of a consisting of the columns x 1 x 1 1 ldots x 2 1 x 2 is determinable ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q;\nstring S[1000005];\nint dat[1000005];\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\trep(i, n) cin >> S[i];\n\t\n\trep1(i, n - 1) rep1(j, m - 1) dat[j] += S[i - 1][j] == \'X\' && S[i][j - 1] == \'X\';\n\trep1(i, m - 1) dat[i] += dat[i - 1];\n\t\n\tcin >> q;\n\trep(i, q) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif(dat[l - 1] == dat[r - 1]) printf(""YES\\n"");\n\t\telse printf(""NO\\n"");\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'dp', 'greedy', 'implementation', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Omkar and Determination.json,https://codeforces.com//blog/entry/96072,First notice that in a determinable grid for any cell it can t be that both the cell above it and the cell to its left are filled If that were the case then the cell wouldn t be exitable regardless of whether it was filled or not and so we couldn t determine whether it was filled Now notice that in any grid with the above property namely that from each cell you can move either up or to the left into an empty cell or both every empty cell must be exitable just keep moving either up or to the left whichever is possible until you exit the grid It follows that for any grid satisfying that property given only which cells are exitable starting from the outermost cells you will be able to determine that the nonexitable cells are filled which implies that the next cells satisfy the property which further implies that the nonexitable ones there are filled and so on This allows you to determine the entire grid since the exitable cells are obviously empty Therefore a grid being determinable is equivalent to all of its cells having an empty cell immediately above and or to the left of it You can check this for arbitrary subgrids by precomputing two dimensional prefix sums of the cells that violate this property then checking whether the sum for a given subgrid is This solution is The actual problem only asked for subgrids that contained every row which allows for a somewhat simpler implementation 
https://codeforces.com//contest/1715/problem/B,1513950,B,1715B,1715,B. Beautiful Array,Stanley defines the beauty of an array a of length n which contains as follows sum limits i 1 n left lfloor frac a i k right rfloor which means that we divide each element by k round it down and sum up the resulting values Stanley told Sam the integer k and asked him to find an array a of n non negative integers such that the beauty is equal to b and the sum of elements is equal to s Help Sam find any of the arrays satisfying the conditions above ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(""%d"",&x);\n\treturn x;\n}\ntypedef long long ll;\nint n,k,b;\nll s;\nll a[100005];\nvoid solve(){\n\tn=in(),k=in(),b=in();scanf(""%lld"",&s);\n\tfor(int i=1;i<=n;i++)a[i]=0;\n\ta[1]=(ll)k*b;s-=a[1];\n\tif(s<0){\n\t\tputs(""-1"");\n\t\treturn;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tll v=min((ll)k-1,s);\n\t\ts-=v;a[i]+=v;\t\n\t}\n\tif(s!=0){\n\t\tputs(""-1"");\n\t\treturn;\t\n\t}\n\tfor(int i=1;i<=n;i++)printf(""%lld "",a[i]),a[i]=0;\n\tputs("""");\n}\nint main(){\n\tint t=in();\n\twhile(t--)solve();\n\treturn 0;\n}']",,,"['constructive algorithms', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Beautiful Array.json,https://codeforces.com//blog/entry/104261,To start with the sum of the numbers in the array cannot be less than where is the number by which we divide and is beauty It is important that Let s assume that is not true Consider the sum of divisible parts of numbers in the array it obviously does not exceed thus the sum of remainders is at least which means that at least one of the numbers remainders is which is impossible by definition of the remainder That way we got the criteria for the existence of the answer If there does exist an answer then we can use the following algorithm Assign to any of the cells of the array Iterate over all the cells including the cell from the previous item and add to the current cell where is the current sum of the elements 
https://codeforces.com//contest/822/problem/D,112701,D,822D,822,D. My pretty girl Noora,In Pavlopolis University where Noora studies it was decided to hold beauty contest Miss Pavlopolis University Let s describe the process of choosing the most beautiful girl in the university in more detail The contest is held in several stages Suppose that exactly girls participate in the competition initially All the participants are divided into equal groups participants in each group Furthermore the number is chosen arbitrarily i e on every stage number can be different Within each group the jury of the contest compares beauty of the girls in the format each with each In this way if group consists of girls then comparisons occur Then from each group the most beautiful participant is selected Selected girls enter the next stage of the competition Thus if girls were divided into groups participants in each group then exactly participants will enter the next stage The contest continues until there is exactly one girl left who will be Miss Pavlopolis University But for the jury this contest is a very tedious task They would like to divide the girls into groups in each stage so that the total number of pairwise comparisons of the girls is as few as possible Let be the minimal total number of comparisons that should be made to select the most beautiful participant if we admit girls to the first stage The organizers of the competition are insane They give Noora three integers and and ask the poor girl to calculate the value of the following expression However since the value of this expression can be quite large the organizers ask her to calculate it modulo If Noora can calculate the value of this expression the organizers promise her to help during the beauty contest But the poor girl is not strong in mathematics so she turned for help to Leha and he turned to you ,"['#include <bits/stdc++.h>\n\nconst int MOD = 1E9 + 7;\n\nstd::vector <int> prime;\nbool is_nonprime[5100000];\nint f[5100000];\n\nint main () {\n\tfor (int i = 2; i <= 5000000; ++i) {\n\t\tif (!is_nonprime[i]) {\n\t\t\tprime.push_back (i);\n\t\t\tf[i] = 1LL * i * (i - 1) / 2 % MOD;\n\t\t}\n\t\tfor (int j = 0; i * prime[j] <= 5000000 && j < prime.size (); ++j) {\n\t\t\tis_nonprime[i * prime[j]] = true;\n\t\t\tf[i * prime[j]] = (f[i] + (1LL * prime[j] * (prime[j] - 1) / 2 % MOD) * i % MOD) % MOD;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n\tint T, L, R;\n\tscanf (""%d%d%d"", &T, &L, &R);\n\tint mul = 1, ans = 0;\n\tfor (int i = L; i <= R; ++i) {\n//\t\tprintf (""%d\\n"", f[i]);\n\t\tans = (ans + 1LL * mul * f[i] % MOD) % MOD;\n\t\tmul = (1LL * mul * T) % MOD;\n\t}\n\tprintf (""%d\\n"", ans);\n}\n\n']",,,"['brute force', 'dp', 'greedy', 'math', 'number theory']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. My pretty girl Noora.json,https://codeforces.com//blog/entry/53068?locale=en,Suppose we have already calculated Then calculating the value of the expression is easy Consider process of calculating Suppose we found optimal answer Represent this answer as sequence of integers on the first stage we will divide girls into groups of participants on the second stage into groups of participants and so on Let us prove that all should be prime Suppose some is a composite number Then it can be decomposed into two numbers In addition let girls are admitted to the th stage Then on current th stage comparisons will occur But if we divide this stage into two new stages then number of comparisons is So we proved that all should be prime Then it s easy to write DP which will be calculated by transition from the state to the states given by dividing current state by prime divisors For solving this task we can use Eratosthenes sieve Total complexity is same as complexity of Eratosthenes sieve In addition you can prove the fact that we should split the girls into groups by prime numbers in the order of their increasing This optimization significantly accelerates the algorithm 
https://codeforces.com//contest/1181/problem/B,359261,B,1181B,1181,B. Split a Number,Dima worked all day and wrote down on a long paper strip his favorite number n consisting of l digits Unfortunately the strip turned out to be so long that it didn t fit in the Dima s bookshelf To solve the issue Dima decided to split the strip into two non empty parts so that each of them contains a integer without leading zeros After that he will compute the sum of the two integers and write it down on a new strip Dima wants the resulting integer to be as small as possible because it increases the chances that the sum will fit it in the bookshelf Help Dima decide what is the minimum sum he can obtain ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nvector<int> stv(string s) {\n\treverse(s.begin(), s.end());\n\tvector<int> r;\n\tfor(char c : s)\n\t\tr.push_back(c-\'0\');\n\treturn r;\n}\n\nvector<int> add(vector<int> a, vector<int> b) {\n\tvector<int> c(max(a.size(), b.size()));\n\tfor(int i=0; i<c.size(); ++i) {\n\t\tif(i<a.size())\n\t\t\tc[i]+=a[i];\n\t\tif(i<b.size())\n\t\t\tc[i]+=b[i];\n\t\tif(c[i]<=9)\n\t\t\tcontinue;\n\t\tif(i+1>=c.size())\n\t\t\tc.push_back(0);\n\t\tc[i+1]+=c[i]/10;\n\t\tc[i]%=10;\n\t}\n\treverse(c.begin(), c.end());\n\treturn c;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint l;\n\tstring n;\n\tcin >> l >> n;\n\tvector<int> p;\n\tfor(int i=1; i<l; ++i)\n\t\tif(n[i]^\'0\')\n\t\t\tp.push_back(i);\n\tvector<int> ans;\n\tint nt=0;\n\tfor(int pi : p) {\n\t\tif(nt>9||pi<l/2)\n\t\t\tcontinue;\n\t\tvector<int> va=stv(n.substr(0, pi)), vb=stv(n.substr(pi)), vc=add(va, vb);\n\t\t/*\n\t\tfor(int i : va)\n\t\t\tcout << i << "" "";\n\t\tcout << endl;\n\t\tfor(int i : vb)\n\t\t\tcout << i << "" "";\n\t\tcout << endl;\n\t\tfor(int i : vc)\n\t\t\tcout << i << "" "";\n\t\tcout << endl;\n\t\t*/\n\t\tif(!ans.size()||ans.size()>vc.size()||ans.size()==vc.size()&&ans>vc)\n\t\t\tans=vc;\n\t\t++nt;\n\t}\n\treverse(p.begin(), p.end());\n\tnt=0;\n\tfor(int pi : p) {\n\t\tif(nt>9||pi>l/2)\n\t\t\tcontinue;\n\t\tvector<int> va=stv(n.substr(0, pi)), vb=stv(n.substr(pi)), vc=add(va, vb);\n\t\tif(!ans.size()||ans.size()>vc.size()||ans.size()==vc.size()&&ans>vc)\n\t\t\tans=vc;\n\t\t++nt;\n\t}\n\tfor(int ai : ans)\n\t\tcout << ai;\n}']",,,"['greedy', 'implementation', 'strings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Split a Number.json,https://codeforces.com//blog/entry/67727,Suppose that the number doesn t contain any zeros that is we can split it at any point Than it is easy to show that it is enough to check only the following cuts if the length of the number is and if the length of the number is Some intuition behind this it s not optimal to make inbalanced cuts Because the sum is at least And in case the maximum is large already we could have built a more optimal answer if we would make a cut in a less inbalanced way One can also examine not only possible cuts but rather different options around the center this way solution is a bit easier to proof In case we have zeros the solution is mostly the same we just simply need to consider the closest valid cut to the left from center and closest valid cut to the right And take a minimum of them One can note that in the solution above we need to add and compare long integers One could have used a programming language in which they are already implemented Python Java or implemented the required functions themselves The number can be simply stored as a sequence of digits from least important digit to the most important It s simple to implement the summation and comparing of such integers 
https://codeforces.com//contest/698/problem/D,65779,D,698D,698,D. Limak and Shooting Points,Bearland is a dangerous place Limak can t travel on foot Instead he has magic teleportation stones Each stone can be used The th stone allows to teleport to a point Limak can use stones There are monsters in Bearland The th of them stands at The given points are pairwise distinct After each teleportation Limak can shoot an arrow in some direction An arrow will hit the first monster in the chosen direction Then both an arrow and a monster disappear It s dangerous to stay in one place for long so Limak can shoot only one arrow from one place A monster should be afraid if it s possible that Limak will hit it How many monsters should be afraid of Limak ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint k,n,ax[N],ay[N],px[N],py[N];\nvector<PII> vec[N];\nmap<PII,int> hs;\nVI pr[10][N];\nint sht[N],vis[N];\nint gcd(int x,int y) { return x?gcd(y%x,x):y; }\nbool dfs(int rm,VI c) {\n/*\tputs(""-----state begin-----"");\n\tprintf(""%d\\n"",rm);\n\tfor (auto v:c) printf(""%d "",v); puts("""");\n\trep(i,0,n) printf(""%d "",sht[i]); puts("""");\n\trep(i,0,k) printf(""%d "",vis[i]); puts("""");\n\tputs(""-----state end-----"");*/\n\tif (SZ(c)==0) return 1;\n\tif (SZ(c)>rm) return 0;\n\tfor (auto v:c) {\n\t\tsht[v]=1;\n\t\trep(j,0,k) if (!vis[j]&&SZ(pr[j][v])<=7) {\n\t\t\tvis[j]=1;\n\t\t\tbool val=1;\n\t\t\tset<int> d(all(c)); d.erase(v);\n\t\t\tfor (auto pp:pr[j][v]) {\n//\t\t\t\tprintf(""%d %d %d\\n"",j,v,pp);\n\t\t\t\tif (sht[pp]) {\n\t\t\t\t\tval=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td.insert(pp);\n\t\t\t\tif (SZ(d)>rm) {\n\t\t\t\t\tval=0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (val) {\n\t\t\t\tif (dfs(rm-1,VI(all(d)))) return 1;\n\t\t\t}\n\t\t\tvis[j]=0;\n\t\t}\n\t\tsht[v]=0;\n\t}\n\treturn 0;\n}\nint main() {\n\tscanf(""%d%d"",&k,&n);\n\trep(i,0,k) scanf(""%d%d"",ax+i,ay+i);\n\trep(i,0,n) scanf(""%d%d"",px+i,py+i);\n\trep(z,0,k) {\n\t\trep(j,0,n+1) vec[j].clear();\n\t\ths.clear();\n\t\tint tot=0;\n\t\trep(j,0,n) {\n\t\t\tint x=px[j]-ax[z];\n\t\t\tint y=py[j]-ay[z];\n\t\t\tint d=gcd(x,y);\n\t\t\td=abs(d);\n\t\t\tx/=d; y/=d;\n\t\t\tif (!hs.count(mp(x,y))) hs[mp(x,y)]=tot++;\n\t\t\tvec[hs[mp(x,y)]].pb(mp(d,j));\n\t\t}\n\t\trep(i,0,tot) {\n\t\t\tsort(all(vec[i]));\n\t\t\tVI v;\n\t\t\tfor (auto p:vec[i]) {\n\t\t\t\tpr[z][p.se]=v;\n//\t\t\t\tprintf(""%d "",p.se);\n\t\t\t\tv.pb(p.se);\n\t\t\t}\n//\t\t\tputs("""");\n\t\t}\n//\t\tputs(""----"");\n\t}\n\tint ret=0;\n\trep(i,0,n) {\n\t\tmemset(sht,0,sizeof(sht));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(k,VI{i}))ret++;\n\t}\n\tprintf(""%d\\n"",ret);\n}\n']",,,"['brute force', 'geometry', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Limak and Shooting Points.json,https://codeforces.com//blog/entry/46148,Spoiler There are places and monsters For each of places let s sort monsters by angle Thanks to that for each pair place monster we will be able to know which monsters don t allow us do directly hit this monster from this place Let s iterate over monsters and for each of them independently check if it can be hit We want to get the complexity or We fixed a monster We want it to be hit in some moment So let s iterate over places considering which place will eventually hit a monster We fixed a place which will hit Thanks to the preprocessing sorting by angle at the beginning we are able to check if the fixed place can directly hit While we can t hit directly we find any blocking monster it may be e g the first monster in this direction looking from the fixed place Let s call it If we want to succeed then some place must hit Iterate over which place will hit Again check if it can directly hit now If yes then mark this place as used and as killed and go back to checking but with monster killed and thus not blocking us anymore Otherwise find any monster in this direction and again iterate over a place to hit it in the future While checking if a monster may be directly hit by some place remember that some monsters may be already killed and thus they don t block anything The above should give you the rough understanding of the solution Let s talk about the details and the implementation Iterate over a monster to check and over permutations of places Create a recursive function rec int monster to kill list int permutation Take the first place from the list and remove it for ever from the list This will be a place to eventually kill monster to kill maybe not now While there are any alive monsters between the fixed place and monster to kill choose any of those alive monsters and run rec that monster permutation Don t treat permutation as the order of teleportation stones to use It s only the order in which we take them from some stack list It only allows us to nicely simulate iterating over a place from which we want to get rid of some blocking monster Some words about the correctness Is it possible that the described solution isn t able to find a way to kill a monster while there exists a way In such a way there is some place from which Limak will hit the monster We simulated iterating over such a place We can t hit directly at the beginning only if there are some blocking monsters between the place and the monster Each of them must be hit from some place We don t assume anything about the order of monsters or about the order of places from which we hit In the optimal way every monster initially blocking us must be hit in some moment by some place so we can and must iterate over a place from which it will be hit If there are some new blocking monsters then again in the optimal way some place hits it and we iterate over it 
https://codeforces.com//contest/797/problem/E,103032,E,797E,797,E. Array Queries,is an array of positive integers all of which are not greater than You have to process queries to this array Each query is represented by two numbers and Several operations are performed in each query each operation changes to There operations are applied until becomes greater than The answer to the query is the number of performed operations ,"[""// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e5 + 5, sq = 330, mod = (int) 0;\nint dp[sq + 2][N], a[N];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tfor (int j = 0; j < n; ++j)\n\t\tcin >> a[j];\n\tfor (int jump = 1; jump <= sq; ++jump) {\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tint nxt = j + a[j] + jump;\n\t\t\tif (nxt >= n) {\n\t\t\t\tdp[jump][j] = 1;\n\t\t\t} else {\n\t\t\t\tdp[jump][j] = dp[jump][nxt] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint res = 0, pos, k;\n\t\tcin >> pos >> k;\n\t\t--pos;\n\t\tif (k <= sq) {\n\t\t\tcout << dp[k][pos] << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\twhile (pos < n) {\n\t\t\t++res;\n\t\t\tpos = pos + a[pos] + k;\n\t\t}\n\t\tcout << res << '\\n';\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n""]",,,"['brute force', 'data structures', 'dp']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Array Queries.json,https://codeforces.com//blog/entry/51588,There are two possible solutions in time First of them answers each query using simple iteration changes to for each query until becomes greater than as stated in the problem But it is too slow Second solution precalculates answers for each and if then else But this uses memory and can be done in time Now we can notice that if then second solution will use only time and memory and if then first solution will do not more than operations on each query So we can combine these two solutions Time complexity 
https://codeforces.com//contest/906/problem/C,140846,C,906C,906,C. Party,Arseny likes to organize parties and invite people to it However not only friends come to his parties but friends of his friends friends of friends of his friends and so on That s why some of Arseny s guests can be unknown to him He decided to fix this issue using the following procedure At each step he selects one of his guests who pairwise introduces all of his friends to each other After this action any two friends of become friends This process is run until all pairs of guests are friends Arseny doesn t want to spend much time doing it so he wants to finish this process using the minimum number of steps Help Arseny to do it ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint t,n,m,u,v,g[30],ret,rew,mark[30],f[30],pa[30][30];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nvoid dfs(int S,int u,int v) {\n\tif (v>=ret) return;\n\tif (u==n) {\n\t\tbool suc=1;\n\t\tint ff=-1;\n\t\trep(i,0,n) if (S&(1<<i)) {\n\t\t\tif (ff==-1) ff=find(i); else {\n\t\t\t\tif (find(i)!=ff) {\n\t\t\t\t\tsuc=0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ((g[i]&S)==0) { suc=0; break; }\n\t\t}\n\t\tif (suc) {\n\t\t\tret=v,rew=S;\n\t\t}\n\t} else {\n\t\trep(i,0,n) pa[u][i]=f[i];\n\t\tint su=find(u);\n\t\trep(i,0,n) if (g[u]&S&(1<<i)) f[find(i)]=su;\n\t\tdfs(S|(1<<u),u+1,v+1);\n\t\trep(i,0,n) f[i]=pa[u][i];\n\t\tdfs(S,u+1,v);\n\t}\n}\nvoid dfs(int u) {\n\tmark[u]=0;\n\trep(v,0,n) if ((g[u]&(1<<v))&&mark[v]) dfs(v);\n\tprintf(""%d "",u+1);\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\t--u; --v;\n\t\tg[u]|=(1<<v); g[v]|=(1<<u);\n\t}\n\tif (m==n*(n-1)/2) {\n\t\tputs(""0"");\n\t\treturn 0;\n\t}\n\tret=n+1;\n\trep(i,0,n) g[i]|=(1<<i),f[i]=i;\n\tdfs(0,0,0);\n\tprintf(""%d\\n"",ret);\n\trep(i,0,n) if (rew&(1<<i)) {\n\t\tmark[i]=1;\n\t}\n\trep(i,0,n) if (mark[i]) {\n\t\tdfs(i);\n\t\treturn 0;\n\t}\n}\n']",,,"['bitmasks', 'brute force', 'dp', 'graphs']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Party.json,https://codeforces.com//blog/entry/56601,Let s formulate and prove several facts 1 If we change an call order the result doesn t change Let s consider two vertices which are called consecutively If they are not connected by edge then regardless of the order we get that at the end neighbours of each vertex form a clique If they are connected then independently on the order we get clique from 2 vertices and all neighbours of them 2 If graph is a tree it s sufficient to take as an answer all its vertices except leaves Indeed if we consider any 2 tree vertices we get that all vertices on the way between them are in the answer Each vertex reduces on 1 the distance between those 2 it means that the distance between them is 1 3 Let s select from source graph spanning tree that has the largest number of leaves One can say that we can use all vertices except leaves as an answer Obviously from point 2 that after all our operations with such set graph will become complete Let s show that it is minimal number of vertices Let we selected some set of vertices that is the answer Then subgraph of given graph built on the selected set of vertices should be connected otherwise between connected component can t appear the edge and graph can t be complete Also each of vertices that isn t in an answer should have at least one of neighbours selected otherwise it is impossible to add new edge to it Now let s select a spanning tree in selected set it s possible because our set is connected and add non selected vertices into the tree as leafs Then we see that our selected can be represented as spanning tree in the initial graph in which all selected vertices are all non leaf vertices and possibly some leafs but leafs can be obviously removed from the selected set by proved above So one of optimal answers can be described as set of non leaf vertices of spanning tree with minimal possible number of non leaves and as a consequence with maximal possible number of leaves QED 4 Implementation It is necessary to implement an algorithm that should work for or faster or with worse asymptotic but with non asymptotical optimization One of possible solutions is following Let contain any subset of vertices as a bit mask for example mask of a subset containing vertices will be equal to Then for subset with mask vertex is in set iff is not equal to 0 here is a bitwise AND Let for each vertex be a mask of subset of vertices containing vertex and it s neighbours Array can be calculated easily Then let be 1 for some mask iff subset coded by is connected Array can be calculated in by the following algorithm for all vertices let vertices be enumerated in 0 indexation is assigned to 1 for all other masks should be equal to 0 then go through all masks in increasing order by a simple cycle let be current mask in the cycle if then go to the next iteration of cycle otherwise let be vertices of subset coded by Then mask for as bitwise OR is a mask coding a subset of vertices containing vertices of mask and their neighbours Then for each vertex in subset of mask we assign to be 1 The described algorithm works in it can be proved by induction that at the end for mask iff is a code of connected subset of vertices But how to find an answer Notice that mask is a code of good for our purposes subset iff and For each mask we can check if it s good in time having an array calculated the answer is a good mask with minimal possible number of elements in the corresponding set 
https://codeforces.com//contest/1658/problem/D1,1344625,D1,1658D1,1658,D1. 388535  Easy Version ,Marin and Gojou are playing hide and seek with an array Gojou initially performs the following steps First Gojou chooses 2 integers l and r such that l leq r Then Gojou makes an array a of length r l 1 which is a permutation of the array l l 1 ldots r Finally Gojou chooses a secret integer x and sets a i to a i oplus x for all i where oplus denotes the bitwise XOR operation Marin is then given the values of l r and the final array a She needs to find the secret integer x to win Can you help her Note that there may be multiple possible x that Gojou could have chosen Marin can find any possible x that could have resulted in the final value of a ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint a[500005],c[500005];\nset <int> s;\ninline void cov(int l,int r)\n{\n\twhile(s.lower_bound(l)!=s.end()&&*s.lower_bound(l)<=r)\n\t\ts.erase(s.lower_bound(l));\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tint n=r-l+1;\n\t\ts.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\ts.insert(a[i]);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint now=0;\n\t\t\tfor(int j=16;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(r&(1<<j))\n\t\t\t\t{\n\t\t\t\t\tif(a[i]&(1<<j));\n\t\t\t\t\telse now^=(1<<j);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(a[i]&(1<<j)) cov(now,now+(1<<j)-1),now+=(1<<j);\n\t\t\t\telse cov(now+(1<<j),now+(2<<j)-1);\n\t\t\t}\n\t\t}\n\t\tcout << *s.begin() << ""\\n"";\n\t}\n\treturn 0;\n}']",,,"['bitmasks', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D1. 388535  Easy Version .json,https://codeforces.com//blog/entry/101302,Let s look at the binary representation of numbers from to Let us look at the th bit only maybe we will get a sequence like Notice that the number of zeroes equals the number of ones in a prefix only when the length of the prefix is a multiple of Otherwise there will be more zeros than ones So we will count the number of flipped and unflipped bits for each bit position If the number of ones is greater than the number of zeros the th bit of must be If the number of zeros is greater than the number of ones the th bit of must be If the number of ones is equal to the number of zeros that th bit of can either be or However if the number of ones is equal to the number of zeros we can assign the th bit anything we like The rough sketch of the proof is that if is inside then is also inside 
https://codeforces.com//contest/1834/problem/A,1970546,A,1834A,1834,A. Unit Array,Given an array a of length n which elements are equal to 1 and 1 Let s call the array a if the following conditions are held at the same time a 1 a 2 ldots a n ge 0 a 1 cdot a 2 cdot ldots cdot a n 1 In one operation you can select an arbitrary element of the array a i and change its value to the opposite In other words if a i 1 you can assign the value to a i 1 and if a i 1 then assign the value to a i 1 Determine the minimum number of operations you need to perform to make the array a good It can be shown that this is always possible ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvoid mermermer()\n{\n\tint n;\n\tcin >> n;\n\tint x=0,y=0;\n\twhile(n--)\n\t{\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t==1) ++x;\n\t\telse ++y;\n\t}\n\tint ans=0;\n\twhile(!(x-y>=0&&y%2==0)) --y,++x,++ans;\n\tcout << ans << ""\\n"";\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) mermermer();\n\treturn 0;\n}\n//bu pa kun nan!!!']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Unit Array.json,https://codeforces.com//blog/entry/117384,First let s make the sum of the array elements To do this we just need to change some to The number of such replacements can be calculated using a formula or explicitly simulated After that there are two possible situations either the product of all elements is equal to or the product of all elements is equal to In the first case we don t need to do anything else In the second case we need to replace one more with note that in this case the sum will remain 
https://codeforces.com//contest/803/problem/C,104508,C,803C,803,C. Maximal GCD,You are given positive integer number You should create such sequence of positive numbers that their sum is equal to and greatest common divisor is maximal Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them If there is no possible sequence then output ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    ll n, k;\n    scanf(""%lld%lld"", &n, &k);\n    if (k > (ll)1e8)\n    {\n        printf(""-1\\n"");\n        return 0;\n    }\n    ll b = n / (k * (k + 1) / 2);\n    if (b == 0)\n    {\n        printf(""-1\\n"");\n        return 0;\n    }\n    ll r = 1;\n    for (ll x = 1; x * x <= n; x++)\n    {\n        if (n % x != 0) continue;\n        if (x <= b && x > r) r = x;\n        if (n / x <= b && n / x > r) r = n / x;\n    }\n    for (int i = 1; i < k; i++)\n        printf(""%lld "", r * i);\n    n -= r * k * (k - 1) / 2;\n    printf(""%lld\\n"", n);\n\n    return 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Maximal GCD.json,https://codeforces.com//blog/entry/51768,Notice that GCD of the resulting sequence is always a divisor of Now let s iterate over all divisors up to Current divisor is One of the ways to retrieve resulting sequence is to take their sum is The last number is You should check if is the sum of arithmetic progression its equal to Don t forget that you should consider and if you check divisors up to Take maximum of possible divisors or output if there were no such divisors Overall complexity 
https://codeforces.com//contest/900/problem/A,138314,A,900A,900,A. Find Extra One,You have distinct points on a plane none of them lie on axis Check that there is a point after removal of which the remaining points are located on one side of the axis ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,a,b;\n\nint main()\n{\n    scanf(""%d"",&n);\n    a=0;b=0;\n    for (int i=1;i<=n;i++)\n    {\n        int x,y;scanf(""%d%d"",&x,&y);\n        if (x>0) a++; else b++;\n    }\n    if (a>1&&b>1) puts(""No\\n""); else puts(""Yes\\n"");\n    return 0;\n}\n']",,,"['geometry', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Find Extra One.json,https://codeforces.com//blog/entry/56294,Count number of points located on left and right side of the axis Answer will be if number of points of one of the sets is smaller than two otherwise Time complexity 
https://codeforces.com//contest/1771/problem/B,1688878,B,1771B,1771,B. Hossam and Friends,Hossam makes a big party and he will invite his friends to the party He has n friends numbered from 1 to n They will be arranged in a queue as follows 1 2 3 ldots n Hossam has a list of m pairs of his friends that don t know each other Any pair not present in this list are friends A subsegment of the queue starting from the friend a and ending at the friend b is a a 1 a 2 ldots b A subsegment of the queue is called when all pairs of that segment are friends Hossam wants to know how many pairs a b there are 1 le a le b le n such that the subsegment starting from the friend a and ending at the friend b is good ,"[""#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\n\n// вправо, вниз, влево, вверх\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\n// ход конем\n//int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n//int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::system_clock::now().time_since_epoch().count());\nint rndInteger (int l, int r) {\n    return uniform_int_distribution<int> (l, r)(rnd);\n}\n\nconst int MOD = (int) 998244353;\nconst int N = (int) 1e6 + 7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T;\n    cin >> T;\n    while(T--) {\n        int n, m;\n        cin >> n >> m;\n        vector<int> L(n + 1, 0);\n        for (int i = 0; i < m; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(x > y) swap(x, y);\n            L[y] = max(L[y], x);\n        }\n\n        int cur = 0;\n        ll ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            cur = max(cur, L[i]);\n            ans += i - cur;\n        }\n        cout << ans << '\\n';\n    }\n\n    return 0;\n}\n""]",,,"['binary search', 'constructive algorithms', 'dp', 'two pointers']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Hossam and Friends.json,https://codeforces.com//blog/entry/110092,Just in non friends pairs Let s calculate minimum non friend for all people So we can t start subsegment in and finish it righter Let s process people from right to left and calculate the rightmost positions there subsegment can end Initially Then we go to just do and add to answer 
https://codeforces.com//contest/1092/problem/F,271425,F,1092F,1092,F. Tree with Maximum Cost,You are given a tree consisting exactly of n vertices Tree is a connected undirected graph with n 1 edges Each vertex v of this tree has a value a v assigned to it Let dist x y be the distance between the vertices x and y The distance between the vertices is the number of edges on the simple path between them Let s define the cost of the tree as the following value firstly let s fix some vertex of the tree Let it be v Then the cost of the tree is sum limits i 1 n dist i v cdot a i Your task is to calculate the of the tree if you can choose v arbitrarily ,"['#include<cstdio>\n#include<vector>\nusing namespace std;\nvector<int>e[200001];\nlong long dp0[200001],s[200001];\nlong long a[200001];\nvoid dfs0(int x,int lt){\n    s[x]=a[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs0(y,x);\n        dp0[x]+=dp0[y]+s[y];\n        s[x]+=s[y];\n    }\n}\nlong long an;\nvoid dfs(int x,int lt,long long v){\n    if(v+dp0[x]>an)an=v+dp0[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs(y,x,v+dp0[x]-dp0[y]-s[y]*2+s[1]);\n    }\n}\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++)scanf(""%lld"",&a[i]);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(""%d%d"",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs0(1,1);\n    dfs(1,1,0);\n    printf(""%lld\\n"",an);\n    return 0;\n}\n']",,,"['dfs and similar', 'dp', 'trees']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Tree with Maximum Cost.json,https://codeforces.com//blog/entry/63961,Firstly let s calculate the answer let it be for some fixed vertex Let this vertex be the vertex Just run simple and calculate the result using the formula from the problem statement Also let s calculate the sum of values let the sum in the subtree of the vertex be in each subtree of the given tree if its root is the vertex It can be easily done with simple dynamic programming And now the magic part let s apply the technique which is called at least we called it so Let s maintain the correct values in subtrees at each step of our algorithm How will values and the answer change if we will go through the edge The following sequence of changes will change all values correctly Firstly it can be seen that will decrease by because the distance to each vertex in this subtree will decrease by one then will decrease by because we change the root of the tree we need this step to maintain the correct values then will increase by because the distance to each vertex in this subtree will increase by one and then will increase by because we change the root of the tree we need this step to maintain the correct values So we can recalculate all the values we need if we go through the edge So now we can write another one to try to update the answer for each vertex as a root as the chosen vertex 
https://codeforces.com//contest/2037/problem/F,3030274,F,2037F,2037,F. Ardent Flames,There are n enemies in a line The i th enemy from the left has health h i and is currently at position x i Xilonen has an attack damage of m and you are ready to defeat the enemies with her Xilonen has a powerful ground stomp attack you select an integer p and position Xilonen there p can be any integer position including a position with an enemy currently Afterwards for each attack she deals m damage to an enemy at position p if there are any m 1 damage to enemies at positions p 1 and p 1 m 2 damage to enemies at positions p 2 and p 2 and so on Enemies that are at least a distance of m away from Xilonen take no damage from attacks Formally if there is an enemy at position x she will deal max 0 m p x damage to that enemy each hit Over all possible p output the minimum number of attacks Xilonen must perform to defeat at least k enemies If it is impossible to find a p such that eventually at least k enemies will be defeated output 1 instead Note that an enemy is considered to be defeated if its health reaches 0 or below ,"['#include <bits/stdc++.h>\xa0#define int long long#define fi first#define se second\xa0const int N = 1e6 + 5;const int K = 1e2 + 5;const int mod = 998244353;\xa0#define all(v) (v).begin(), (v).end()#define pii pair<int, int> \xa0using namespace std;\xa0mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());\xa0int t, n, m, k, h[N], x[N];priority_queue<int, vector<int>, greater<int>> q;\xa0signed main() {    ios_base::sync_with_stdio(0);    cin.tie(0);        if(ifstream(""file.inp"")){    \tfreopen(""file.inp"", ""r"", stdin);    \tfreopen(""file.out"", ""w"", stdout);    }        cin >> t;    while(t--) {    \tcin >> n >> m >> k;    \tfor(int i = 1; i <= n; i++) cin >> h[i];    \tfor(int i = 1; i <= n; i++) cin >> x[i];    \tint l = 1, r = 1e18, mid, res = -1;    \twhile(l <= r) {    \t\tmid = l + r >> 1;    \t\tvector<pii> s;    \t\tfor(int i = 1; i <= n; i++) {    \t\t\tint c = m - (h[i] / mid + (h[i] % mid != 0));    \t\t\ts.push_back({max(x[i] - c, x[i] - m), min(x[i] + c, x[i] + m)});    \t\t}    \t\tsort(all(s));    \t\t// if(mid == 1) for(auto &x : s) cout << x.fi << \' \' << x.se << \'\\n\';    \t\twhile(q.size()) q.pop();    \t\tbool check = 0;    \t\tfor(int i = 0; i < n; i++) {    \t\t\tq.push(s[i].se);    \t\t\tif(q.size() > k) q.pop();    \t\t\tif(s[i].fi <= q.top() && q.size() == k) {    \t\t\t\tcheck = 1;    \t\t\t\tbreak;    \t\t\t}    \t\t}    \t\tif(!check) {    \t\t\tl = mid + 1;    \t\t}    \t\telse {    \t\t\tr = mid - 1;    \t\t\tres = mid;    \t\t}    \t}    \tcout << res << \'\\n\';    }        return 0;}\xa0// tuntun']",,,"['binary search', 'data structures', 'math', 'sortings', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Ardent Flames.json,https://codeforces.com//blog/entry/135533,Let s perform binary search on the minimum number of hits to kill at least k enemies How do we check if a specific answer is possible Let s consider a single enemy for now If its health is hi and we need to kill it in at most q attacks then we need to be doing at least hiq damage per attack to this enemy If this number is greater than m then obviously we cannot kill this enemy in at most q attacks as the maximum damage Xilonen can do is m damage per hit Otherwise we can model the enemy as a valid interval where we can place Xilonen Specifically the inequality m p x hiq must be satisfied Now that we have modeled each enemy as an interval the problem is reduced to finding whether or not there exists a point on at least k intervals This is a classic problem that can be approached by a sweep line algorithm sorting the events of intervals starting and ending by time and adding 1 to your counter when an interval starts and subtracting 1 to your counter when an interval ends Note that the maximum possible answer to any setup with a solution is max hi 109 so if we cannot kill at least k enemies in 109 attacks then we can just output 1 as our answer The total time complexity is O nlog n log max hi 
https://codeforces.com//contest/1729/problem/F,1538787,F,1729F,1729,F. Kirei and the Linear Function,Given the string s of decimal digits of length n A substring is a sequence of consecutive characters of a string The substring of this string is defined by a pair of indexes with its left and right ends So each pair of indexes l r where 1 le l le r le n corresponds to a substring of the string s We will define as v l r the numeric value of the corresponding substring leading zeros are allowed in it For example if n 7 s then v 1 3 100 v 2 3 0 and v 2 7 3004 You are given n s and an integer w 1 le w n You need to process m queries each of which is characterized by 3 numbers l i r i k i 1 le l i le r i le n 0 le k i le 8 The answer to the ith query is such a pair of substrings of length w that if we denote them as L 1 L 1 w 1 and L 2 L 2 w 1 then L 1 ne L 2 that is the substrings are different the remainder of dividing a number v L 1 L 1 w 1 cdot v l i r i v L 2 L 2 w 1 by 9 is equal to k i If there are many matching substring pairs then find a pair where L 1 is as small as possible If there are many matching pairs in this case then minimize L 2 Note that the answer may not exist ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 9;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\n\n\nstruct mint {\n    int x;\n    mint() : x(0) {}\n    mint(int x) : x((x % mod + mod) % mod) {}\n    mint operator -() const { return mint(0) - *this;}\n    mint operator ~() const { return mint(1) / *this;}\n    mint& operator +=(const mint& a) { if((x += a.x) >= mod) x -= mod; return *this;}\n    mint& operator -=(const mint& a) { if((x += mod - a.x) >= mod) x -= mod; return *this;}\n    mint& operator *=(const mint& a) { x = x * a.x % mod; return *this;}\n    mint& operator /=(const mint& a) { x = x * a.pow(mod-2).x % mod; return *this;}\n    mint operator +(const mint& a) const { return mint(*this) += a;}\n    mint operator -(const mint& a) const { return mint(*this) -= a;}\n    mint operator *(const mint& a) const { return mint(*this) *= a;}\n    mint operator /(const mint& a) const { return mint(*this) /= a;}\n    mint pow(int t) const { mint ret(1), pw = mint(*this); while(t){ if(t & 1) ret *= pw; pw *= pw; t /= 2;} return ret;}\n    bool operator <(const mint& a) const { return x < a.x;}\n    bool operator ==(const mint& a) const { return x == a.x;}\n    bool operator !=(const mint& a) const { return x != a.x;}\n    friend istream& operator >>(istream& is, mint& p) { return is >> p.x; }\n    friend ostream& operator <<(ostream& os, mint p){ return os << p.x; }\n};\n\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n\n    int w, q;\n    cin >> w >> q;\n\n    mint x = 0;\n\n    rep(i,0,w)\n    {\n        x = x * 10 + (s[i] - \'0\');\n    }\n\n    vvi g(9);\n\n    fr(i, 0, n - w)\n    {\n        g[x.x].pb(i);\n\n        if(i + w < n)\n        {\n            x = x * 10 + (s[i + w] - \'0\');\n            x -= mint(s[i] - \'0\') * mint(10).pow(w);\n        }\n    }\n\n\n    vector<mint> pre(n + 1);\n\n    rep(i,0,n)\n    {\n        pre[i + 1] = pre[i] * 10 + (s[i] - \'0\');\n    }\n    \n    \n    while(q--)\n    {\n        int l, r, k;\n        cin >> l >> r >> k;\n\n        mint z = pre[r] - pre[l - 1];\n\n        pii res = {n, n};\n\n        rep(i,0,9)\n        {\n            rep(j,0,9)\n            {\n                if(mint(i) * z + j == mint(k))\n                {\n                    //deb(i, j);\n\n                    if(i == j)\n                    {\n                        if(sz(g[i]) > 1)\n                        {\n                            mini(res, pii(g[i][0], g[i][1]));\n                        }\n                    }\n                    else\n                    {\n                        if(sz(g[i]) && sz(g[j]))\n                        {\n                            mini(res, pii(g[i][0], g[j][0]));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(res.fi == n)\n        {\n            cout << ""-1 -1"" << endl;\n        }\n        else\n        {\n            cout << res.fi + 1 << \' \' << res.se + 1 << endl;\n        }\n    }\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']",,,"['hashing', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Kirei and the Linear Function.json,https://codeforces.com//blog/entry/106916,Note that the remainder of dividing a number by is equal to the remainder of dividing its sum of digits by This is easy to check because the number of digits is representable as a polynomial and gives a remainder of when divided by for any Let s count an array of prefix sums of digits for the string Now knowing we can pre calculate for each remainder modulo all possible Also for each query we can easily find the remainder of dividing by using all the same prefix sums Let s iterate over the remainder of the number when dividing by Knowing it we can easily find the remainder of the number when divided by as modulo Now using each pair of remainers let s try to update the answer then the minimum index from the pre calculated array will act as and the next largest will act as if such exist then the minimum indexes from the pre calculated array will act as and This solution works for or for 
https://codeforces.com//contest/982/problem/C,183673,C,982C,982,C. Cut  em all ,You re given a tree with n vertices Your task is to determine the maximum possible number of edges that can be removed in such a way that all the remaining connected components will have even size ,"['#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#define rep(i,n) for(int i=1;i<=n;++i)\n#define pb push_back\nusing namespace std;\n\nvector<int> g[210000];\nint son[210000];\nint n,ans;\n\nvoid dfs(int x,int pre)\n{\n\tson[x]=1;\n\tfor(auto i:g[x])\n\tif (i!=pre)\n\t{\n\t\tdfs(i,x);\n\t\tson[x]=son[x]+son[i];\n\t\tif (son[i]%2==0) ans++;\n\t}\n}\n\nint main()\n{\n\tcin>>n;\n\tans=0;\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y; \n\t\tscanf(""%d%d"",&x,&y);\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\n\tdfs(1,0);\n\n\tif (son[1]%2!=0){ puts(""-1""); return 0; }\n\tcout<<ans<<endl;\n}\n']",,,"['dfs and similar', 'dp', 'graphs', 'greedy', 'trees']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Cut  em all .json,https://codeforces.com//blog/entry/59551,Note that if there is an edge that can be removed we can do it without any problem Let s consider such edge that in one of the obtained subtrees it is impossible to delete more anything else and its removal is possible What happens if we delete it in the tree Relative to the other end of the edge the odd even balance of the subtree has not changed which means that the edge has not been affected by further deletions Which means if we remove it the answer will be better This is followed by a greedy solution in dfs we count the size of the subtree for each vertex including the current vertex and if it is even then the edge from the parent if it exists can be removed 
https://codeforces.com//contest/1551/problem/D2,1055224,D2,1551D2,1551,D2. Domino  hard version ,There s a table of n times m cells n rows and m columns The value of n cdot m is even A domino is a figure that consists of two cells having a common side It may be horizontal one of the cells is to the right of the other or vertical one of the cells is above the other You need to place frac nm 2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical The dominoes cannot overlap and must fill the whole table ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nconst int N = 105;\n\nvector<int> dx = {1,-1,0,0},dy = {0,0,1,-1};\n\nint can[N][N][26];\n\nint _runtimeTerror_()\n{\n    int n,m,k;\n    cin >> n >> m >> k;\n    vector<vector<char>> ans(n,vector<char>(m));\n    for(int i=0;i<n;++i)\n        for(int j=0;j<m;++j)\n            for(int k=0;k<26;++k)\n                can[i][j][k] = 0;\n\n    auto assign = [&](int x,int y,int c)\n    {\n        ans[x][y] = char(c + \'a\');\n        for(int i=0;i<4;++i)\n        {\n            int u = x + dx[i],v = y + dy[i];\n            if(u >= 0 && u < n && v >= 0 && v < m)\n                can[u][v][c] = 1;\n        }\n    };\n    auto get = [&](vector<pair<pii,pii>> &a)\n    {\n        for(auto &[u,v]:a)\n        {\n            vector<int> cant(26,0);\n            auto [x,y] = u;\n            auto [xx,yy] = v;\n            for(int i=0;i<26;++i)\n                cant[i] = can[x][y][i] || can[xx][yy][i];\n            for(int i=0;i<26;++i)\n            {\n                if(cant[i] == 0)\n                {\n                    assign(x,y,i);\n                    assign(xx,yy,i);\n                    break;\n                }\n            }\n        }\n    };\n    vector<pair<pii,pii>> a;\n    if(n % 2 == 0 && m % 2 == 0)\n    {\n        if(k % 2 == 0)\n        {\n            cout << ""YES\\n"";\n            for(int i=0;i<n;i+=2)\n            {\n                for(int j=0;j<m;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n        }\n        else\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n    }\n    else if(n % 2 == 1 && m % 2 == 0)\n    {\n        k -= m/2;\n        if(k >= 0 && k % 2 == 0)\n        {\n            for(int j=0;j<m;j+=2)\n            {\n                a.push_back({{n-1,j},{n-1,j+1}});\n            }\n            for(int i=0;i<n-1;i+=2)\n            {\n                for(int j=0;j<m;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n            cout << ""YES\\n"";\n        }\n        else\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n    }\n    else if(n % 2 == 0 && m % 2 == 1)\n    {\n        if(k % 2 == 0 && k <= n * m / 2 - n / 2)\n        {\n            cout << ""YES\\n"";\n            for(int i=0;i<n;i+=2)\n                a.push_back({{i,m-1},{i+1,m-1}});\n            for(int i=0;i<n;i+=2)\n            {\n                for(int j=0;j<m-1;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n        }\n        else\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n    }\n    get(a);\n    for(int i=0;i<n;++i)\n    {\n        for(int j=0;j<m;++j)\n            cout << ans[i][j];\n        cout << ""\\n"";\n    }\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']",,,"['constructive algorithms', 'implementation', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D2. Domino  hard version .json,https://codeforces.com//blog/entry/93149,Suppose and are even A necessary and sufficient condition of existence of the answer is that is even Let s prove the sufficient condition If the count of the horizontal dominoes is even then we can combine them and vertical dominoes to blocks of size the number of the vertical dominoes is even too if is even If and are even we can fill the table with these blocks The description of the locations of the dominoes may be printed as follows consider the table is a chessboard where a cell is a block of two dominoes Consider the leftmost topmost cell of the board is black If a cell of the board is black let s mark one of the dominoes of the block with the letter and the other one with the letter If a cell of the board is white let s mark one of the dominoes of the block with the letter and the other one with the letter There will be no situation that some two cells of the table are marked with one letter but belong to different dominoes Let s prove the necessary condition The number of cells in a column is even so the number of cells that belong to vertical dominoes is even because cells of each vertical domino may be either belong to the column or not belong at the same time So the number of cells that belong to horizontal dominoes is even Let s cross out all cells that belong to vertical dominoes and let s find the leftmost column having cells that haven t been crossed out It s the leftmost column with such cells so the pairwise cells of the non crossed out cells belong to the column to the right of the found one The number of such cells in the right column is equal to the number of found cells so it s even and the number of found horizontal dominoes is even too Let s cross out the found cells and the pairwise cells The number of non crossed out cells in the right column will be even The number of crossed out horizontal dominoes will be even too Let s repeat this procedure until all the dominoes will be crossed out In every step we have crossed out the even number of horizontal dominoes hence the total count of horizontal dominoes is even Suppose is odd hence is even In this case every column contains an odd number of cells whereas the number of cells that belong to vertical dominoes is even So the number of cells that belong to horizontal dominoes is odd Consider the leftmost column and find a cell of it that belongs to a horizontal domino it must be found because the number of such cells is odd so it isn t equal to Let s find the pairwise cell and cross out both cells Currently the two columns will have an even number of non crossed out cells Let s repeat the procedure until all columns will have even non crossed out cells We will cross out cells and dominoes So the necessary condition is that the number of horizontal dominoes is at least Let s extend the necessary condition with the following condition the value of is even Consider the table that we ve become after the previous procedure where each column has exactly one crossed out cell Let s start the procedure we ve done in the case of even both and The procedure can be started on our table because each column of the table has an even number of non crossed out cells As a result of the procedure we will cross out an even count of horizontal dominoes so the value of is even Let s build an answer if the conditions and is even are met Let s place in the topmost row horizontal dominoes and mark their cells as follows the first domino will be marked with the second one with the third one with and so on As the result the region of rows and columns will be unfilled Both values are even and the value of is even too So let s fill the region as if it s a separate table having even numbers of rows and columns As it was proved above it s possible to do The set of letters used for the region and set of the letters used for the topmost row don t have common elements so there will be no cells that are marked with one letter but belong to different dominoes The case of odd hence is even is similar to the previous one let s transpose the table it will have rows and columns swap the values of and solve the case above and transpose the table back to have rows and columns 
https://codeforces.com//contest/1900/problem/D,2348161,D,1900D,1900,D. Small GCD,Let a b and c be integers We define function f a b c as follows Order the numbers a b c in such a way that a le b le c Then return gcd a b where gcd a b denotes the greatest common divisor GCD of integers a and b So basically we take the gcd of the 2 smaller values and ignore the biggest one You are given an array a of n elements Compute the sum of f a i a j a k for each i j k such that 1 le i j k le n More formally compute sum i 1 n sum j i 1 n sum k j 1 n f a i a j a k ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint n, a[80005], f[100005], g[100005];\nlong long ans;\nstd::vector <int> fac[100005];\nvoid solve(){\n\tscanf(""%d"", &n); ans = 0ll;\n\tfor(int i = 1; i <= 100000; ++i) f[i] = g[i] = 0;\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tstd::sort(a + 1, a + n + 1);\n\tlong long tmp = 0ll;\n\tfor(int i = 1; i <= n; ++i){\n\t\tans += tmp;\n\t\tfor(auto v : fac[a[i]]){\n\t\t\tf[v] = g[v];\n\t\t\tfor(auto u : fac[a[i] / v]) if(u != 1) f[v] -= f[v * u];\n\t\t\ttmp += 1ll * v * f[v];\n\t\t}\n\t\tfor(auto v : fac[a[i]]) ++g[v];\n\t}\n\tprintf(""%lld\\n"", ans);\n\treturn ;\n}\nint main(){\n\tfor(int i = 1; i <= 100000; ++i) for(int j = i; j <= 100000; j += i) fac[j].push_back(i);\n\tfor(int i = 1; i <= 100000; ++i) std::reverse(fac[i].begin(), fac[i].end()); \n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']",,,"['bitmasks', 'brute force', 'dp', 'math', 'number theory']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Small GCD.json,https://codeforces.com//blog/entry/122677,Solution part 1We calculate from to For some we can first calculate the number of triples that have a value of function that is an integer multiple of and then from it subtract Because of the previous hint the subtractions will be quite fast Now the question is how to calculate the number of triples that have a value of function that is an integer multiple of 
https://codeforces.com//contest/949/problem/A,163628,A,949A,949,A. Zebras,Oleg writes down the history of the days he lived For each day he decides if it was good or bad Oleg calls a non empty sequence of days a if it starts with a bad day ends with a bad day and good and bad days are alternating in it Let us denote bad days as and good days as Then for example sequences of days are zebras while sequences are not Oleg tells you the story of days he lived in chronological order in form of string consisting of and Now you are interested if it is possible to divide Oleg s life history into several each of which is a zebra and the way it can be done Each day must belong to exactly one of the subsequences For each of the subsequences days forming it must be ordered chronologically Note that subsequence does not have to be a group of consecutive days ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define Se second\n#define Fi first\n\nvector <int> Vp[2];\nchar in[200050];\n\nint prv[200050];\nint nxt[200050];\nbool dchk[200050];\nint main() {\n\tint N, i;\n\tscanf(""%s"", in + 1);\n\tN = strlen(in + 1);\n\n\tfor (i = 1; i <= N; i++) Vp[in[i] - \'0\'].push_back(i);\n\tif (Vp[0].size() <= Vp[1].size()) return !printf(""-1\\n"");\n\n\tfor (i = 0; i < Vp[1].size(); i++) {\n\t\tint t1 = Vp[0][i], t2 = Vp[1][i];\n\t\tif (t1 > t2) return !printf(""-1\\n"");\n\n\t\tnxt[t1] = t2;\n\t}\n\tfor (i = 0; i < Vp[1].size(); i++) {\n\t\tint t1 = Vp[0][Vp[0].size() - Vp[1].size() + i], t2 = Vp[1][i];\n\t\tif (t1 < t2) return !printf(""-1\\n"");\n\t\tnxt[t2] = t1;\n\t}\n\n\tvector <vector<int>> Va;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (dchk[i]) continue;\n\n\t\tvector <int> Vu;\n\t\tVu.push_back(i);\n\t\twhile (nxt[Vu.back()]) Vu.push_back(nxt[Vu.back()]);\n\t\tVa.push_back(Vu);\n\t\tfor (auto it : Vu) dchk[it] = true;\n\t}\n\n\tprintf(""%d\\n"", (int)Va.size());\n\tfor (auto it : Va) {\n\t\tprintf(""%d "", (int)it.size());\n\t\tfor (auto it2 : it) printf(""%d "", it2);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}']",,,['greedy'],1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Zebras.json,https://codeforces.com//blog/entry/58291,Simple greedy works here Let s go from left to right and assign each element to some subsequence At each moment we have two types of already built subsequences zebras 0 010 01010 and almost zebras 01 0101 010101 If next element of the string is 1 we should add it to some zebra making it almost zebra If there are no zebras at this moment it s impossible to divide string into zebra subsequences If next element of the string is 0 we should add it so some almost zebra making it simple zebra If there are no almost zebra s now just create new zebra consisting of this 0 If there are no almost zebra s at the end answer exists and built zebras satisfy all requirements otherwise there is no answer Find answer minimizing length of longest subsequence Find answer minimizing number of subsequences 
https://codeforces.com//contest/297/problem/B,2860,B,297B,297,B. Fish Weight,It is known that there are fish species in the polar ocean numbered from to They are sorted by non decreasing order of their weight which is a positive number Let the weight of the th type of fish be then holds Polar bears Alice and Bob each have caught some fish and they are guessing who has the larger sum of weight of the fish he she s caught Given the type of the fish they ve caught determine whether it is possible that the fish caught by Alice has a total weight than Bob s In other words does there exist a sequence of weights not necessary integers such that the fish caught by Alice has a strictly larger total weight ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint a[4444444], b[4444444];\n\nint main() {\n  int n, m, k;\n  scanf(""%d %d %d"", &n, &m, &k);\n  for (int i=0;i<n;i++) scanf(""%d"", a+i);\n  for (int i=0;i<m;i++) scanf(""%d"", b+i);\n  sort(a, a+n);\n  sort(b, b+m);\n  int ok = 0;\n  if (n > m) ok = 1; else {\n    for (int i=0;i<n;i++)\n      if (a[i] > b[m-n+i]) ok = 1;\n  }\n  if (ok) printf(""YES\\n"");\n  else printf(""NO\\n"");\n  return 0;\n}\n']",,,"['constructive algorithms', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Fish Weight.json,https://codeforces.com//blog/entry/7437,First we sort and in non increasing order We claim that the answer is YES if and only if exists is lexicographically larger than If is not lexicographcally larger than that means for every That implies for every fish Alice has there is a corresponding fish Bob has and is as heavy as Alice s Let be the smallest index such that We can amplify the gap between and as large as we want to make Alice wins 
https://codeforces.com//contest/671/problem/D,60095,D,671D,671,D. Roads in Yusland,Mayor of Yusland just won the lottery and decided to spent money on something good for town For example repair all the roads in the town Yusland consists of intersections connected by bidirectional roads One can travel from any intersection to any other intersection using only these roads There is only one road repairing company in town named RC company Company s center is located at the intersection RC company doesn t repair roads you tell them Instead they have workers at some intersections who can repair only some specific paths The th worker can be paid coins and then he repairs on a path from to some that from to intersection Mayor asks you to choose the cheapest way to hire some subset of workers in order to repair all the roads in Yusland It s allowed that some roads will be repaired more than once If it s impossible to repair all roads print ,"['#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 311111\n\n#define TASK ""1""\n\nusing namespace std;\n\nvector<int> v[N], ch[N];\nvector<pair<int, int> > z[N];\nint n, m;\n\nint d[N];\n\n\nvoid dfs(int x, int pr, int de) {\n\td[x] = de;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tint to = v[x][i];\n\t\tif (to != pr) {\n\t\t\tdfs(to, x, de + 1);\n\t\t\tch[x].pb(to);\n\t\t}\n\t}\n}\n\n\nlong long dp[N];\n\nset<pair<long long, int > > Q[N];\nlong long ad[N];\nint bad = 0;\n\nvoid calc(int x) {\n\tif (ch[x].size() == 0) {\n\t\tad[x] = 0;\n\t\tfor (int i = 0; i < z[x].size(); i++) Q[x].insert(mp(z[x][i].S, z[x][i].F));\n\t\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\t\tif (Q[x].size() == 0) {\n\t\t\tbad = 1;\n\t\t\tdp[x] = 0;\n\t\t} else {\n\t\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < ch[x].size(); i++) calc(ch[x][i]);\n\tlong long sum = 0;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tsum += dp[ch[x][i]];\n\t}\n\tint la = -1;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tad[ch[x][i]] += sum - dp[ch[x][i]];\n\t\tif (la == -1 || Q[ch[x][i]].size() > Q[la].size()) la = ch[x][i];\n\t}\n\n\tfor (int i = 0; i < ch[x].size(); i++) if (ch[x][i] != la) {\n\t\tint u = ch[x][i];\n\t\tfor (auto it = Q[u].begin(); it != Q[u].end(); ++it) {\n\t\t\tlong long cost = (*it).F + ad[u] - ad[la];\n\t\t\tQ[la].insert(mp(cost, (*it).S));\n\t\t}\n\t}\n\tfor (int i = 0; i < z[x].size(); i++) {\n\t\tlong long cost = z[x][i].S + sum - ad[la];\n\t\tQ[la].insert(mp(cost, z[x][i].F));\n\t}\n\tswap(Q[la], Q[x]);\n\tad[x] = ad[la];\n\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\tif (Q[x].size() == 0) {\n\t\tbad = 1;\n\t\tdp[x] = 0;\n\t} else {\n\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t}\n}\n\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK"".in"",""r"",stdin);\t\n\t\tfreopen(TASK"".out"",""w"",stdout);\n\t#endif\t\t\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(0, 0, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, co;\n\t\tscanf(""%d%d%d"", &x, &y, &co);\n\t\tx--;\n\t\ty--;\n\t\tif (d[x] < d[y]) swap(x, y);\n\n\t\tz[x].pb(mp(d[y], co));\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tcalc(v[0][i]);\n\t\tans += dp[v[0][i]];\n\t}\n\tif (bad) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}']",,,"['data structures', 'dp', 'greedy']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Roads in Yusland.json,https://codeforces.com//blog/entry/44821,I want to thank GlebsHP i originally came up with another problem similar to it GlebsHP suggested to use this one in stead of it Let s look for a optimal subset of paths paths may intersect To prevent from this let s change the problem litte bit A worker can repair all nodes between and some where is in the path between and with cost also paths must not intersect In this way we will never find better solution from original problem and we can express optimal subset in original problem without any path intersections in new problem Let s keep a array keeps minimum cost to cover all edges in subtree of node also the edge between and How to find answer of some Let s choose a worker which is in the subtree of and is a parent of node Then if we choose this worker answer must be where is child of a node in the path from to for all s Of course we have to exclude nodes chosen as and in the path from to since we will cover them with th worker We will construct a segment tree by dfs travel times so that for all nodes workers which start his path in subtree of this node can be reached by looking a contiguous segment in tree In node segment will keep values what will be equal to if we choose this worker to cover path between and We will travel our tree with dfs in each after we calculated node s children dp s we will update our segment in following way add all workers to segment where with value sum of node s children dp s For all workers equal to we must delete it from segment this is assigning to it The only thing we didn t handle is what to do with workers under this node Imagine all updates in subtree of node where is a child of node We have to increase all of them by sum of node s children dp s After applying all of this operations answer will be minimum value of workers start their path from a node in subtree of in segment tree Overall complexity will be Please look at the code to be more clear 
https://codeforces.com//contest/1337/problem/A,594573,A,1337A,1337,A. Ichihime and Triangle,Ichihime is the current priestess of the Mahjong Soul Temple She claims to be human despite her cat ears These days the temple is holding a math contest Usually Ichihime lacks interest in these things but this time the prize for the winner is her favorite cookies Ichihime decides to attend the contest Now she is solving the following problem You are given four positive integers a b c d such that a leq b leq c leq d Your task is to find three integers x y z satisfying the following conditions a leq x leq b b leq y leq c c leq z leq d There exists a triangle with a positive non zero area and the lengths of its three sides are x y and z Ichihime desires to get the cookie but the problem seems too hard for her Can you help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t; \n    cin >> t;\n    while(t--)\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n    \n        cout << b << "" "" << c << "" "" << c << ""\\n"";\n    }\n\n    return 0;\n}']",,,"['constructive algorithms', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Ichihime and Triangle.json,https://codeforces.com//blog/entry/76099,There are many possible solutions one of them is to always output You can easily prove that always satisfies the requirements 
https://codeforces.com//contest/1973/problem/A,2652010,A,1973A,1973,A. Chess For Three,Three friends gathered to play a few games of chess together In every game two of them play against each other The winner gets 2 points while the loser gets 0 and in case of a draw both players get 1 point each Note that the same pair of players could have played any non negative number of times possibly zero It is also possible that no games were played at all You ve been told that their scores after all the games were played were p 1 p 2 and p 3 Additionally it is guaranteed that p 1 leq p 2 leq p 3 holds Find the maximum number of draws that could have happened and print it If there isn t any way to obtain p 1 p 2 and p 3 as a result of a non negative number of games between the three players print 1 instead ,"['#include<bits/stdc++.h>using namespace std;int main(){    int T,a[3];scanf(""%d"",&T);while(T--){        scanf(""%d%d%d"",&a[0],&a[1],&a[2]);        if(!((a[0]+a[1]+a[2])&1)){            int ans=0;            while(a[1]&&a[2])                a[1]--,a[2]--,sort(a,a+3),ans++;            printf(""%d\\n"",ans);        }        else puts(""-1"");    }    return 0;}']",,,"['brute force', 'dp', 'implementation', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Chess For Three.json,https://codeforces.com//blog/entry/129556,Solution After each round sum of players scores increases by 2 so if the sum is odd answer is Now as the hints suggest you can try all possible combinations of and with three for loops and check for each combination whether it could result in scores and Specifically it must hold that and the same two conditions for and analogously Now you can find the biggest value of over all valid choices and print it as the answer The time complexity is Implementation in Python 261998440 Bonus There exists an solution with simpler implementation Claim The answer is min Let s prove this if then it s possible that players and played and draws with player after which there can t happen any additional draws in the game if that means so player can first play draws with player Note that if sum is even then will also be even so player can play draws with each of players and thus adding up his score to exactly Finally players and can play draws anong them after which their scores become and respectively Thus it is possible that all rounds played ended with draws making answer equal to Implementation in C 261998652 
https://codeforces.com//contest/1841/problem/E,1962594,E,1841E,1841,E. Fill the Matrix,There is a square matrix consisting of n rows and n columns of cells both numbered from 1 to n The cells are colored white or black Cells from 1 to a i are black and cells from a i 1 to n are white in the i th column You want to place m integers in the matrix from 1 to m There are two rules each cell should contain at most one integer black cells should not contain integers The of the matrix is the number of such j that j 1 is written in the same row in the next column as j in the neighbouring cell to the right What s the maximum possible beauty of the matrix ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << "" ""; cout << v[i];\n    }\n    cout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\ntemplate<typename T>\nstruct SegT {\nprivate:\n    int sz; vector<T> node;\n    T init_c;\n    function<T(T, T)> f;\npublic:\n    SegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        int n = v.size();\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n        rep(i, n) {\n            node[i + sz - 1] = v[i];\n        }\n        per(i, sz - 1) {\n            node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n    SegT(int n, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n    }\n    void update(int k, T a) {\n        k += sz - 1;\n        node[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            node[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0)r = sz;\n        if (r <= a || b <= l)return init_c;\n        else if (a <= l && r <= b)return node[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(vl, vr);\n        }\n    }\n    //k以上でf(x,node[y+sz-1])をtrueにするような最小のy\n    int searchloc(int le, T x, function<bool(T, T)> comp) {\n        int  k = le + sz - 1;\n        if (comp(x, node[k]))return le;\n        x = f(x, node[k]);\n        while (k > 0) {\n            int mem = k;\n            k = (k - 1) / 2;\n            if (2 * k + 1 == mem) {\n                if (comp(x, node[2 * k + 2])) {\n                    k = 2 * k + 2; break;\n                }\n                x = f(x, node[2 * k + 2]);\n            }\n        }\n        if (k == 0)return sz;\n        while (k < sz - 1) {\n            if (comp(x, node[2 * k + 1])) {\n                k = 2 * k + 1;\n            }\n            else {\n                x = f(x, node[2 * k + 1]);\n                k = 2 * k + 2;\n            }\n        }\n        return k - (sz - 1);\n    }\n\n};\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    rep(i, n)cin >> a[i];\n    auto f = [&](P a, P b) {\n        return max(a, b);\n    };\n    vector<P> ori(n);\n    rep(i, n)ori[i] = { a[i],i };\n    SegT<P> st(ori, { -1,-1 }, f);\n    vector<P> ps;\n    function<void(int, int, int)> dfs = [&](int l, int r, int d) {\n        if (l >= r)return;\n        P p = st.query(l, r);\n        int m = p.second;\n        if (a[m] < d) {\n            ps.push_back({ r - l,d - a[m] });\n        }\n        dfs(l, m, a[m]);\n        dfs(m + 1, r, a[m]);\n    };\n    dfs(0, n, n);\n    sort(all(ps), greater<P>());\n    ll ans = 0;\n    ll k; cin >> k;\n    rep(i, ps.size()) {\n        ll c = ps[i].second;\n        ll len = ps[i].first;\n        if (k <= c*len) {\n            ll d = k / len;\n            ans += (len - 1) * d;\n            ll r = k % len;\n            if (r > 0)ans += r - 1;\n            break;\n        }\n        else {\n            ans += (len - 1) * c;\n            k -= c * len;\n        }\n    }\n    //cout << ""ans is "";\n    cout << ans << ""\\n"";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}']",,,"['data structures', 'greedy', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Fill the Matrix.json,https://codeforces.com//blog/entry/117262,Notice that the rows of the matrix are basically independent When we fill the matrix with integers the values from the rows are just added together Moreover in a single row the segments of white cells separated by black cells are also independent in the same way And how to solve the problem for one segment of white cells Obviously put the numbers one after another Placing a non zero amount of integers will yield the result of Thus the answer is where is the number of used segments We know that the sum of is just So it becomes So the problem asks us to minimize the number of used segments In order to use the smallest number of segments we should pick the longest ones We only have to find them In the worst case there are segments of white cells in the matrix However we can store them in a compressed form Since their lengths are from to we can calculate how many segments of each length there are Look at the matrix from the bottom to the top First there are some fully white rows Then some black cell appears and splits the segment of length into two segments Maybe more if there are more black cells in that row After that the split segments behave independently of each other Let s record these intervals of rows each segment exists at So let some segment exist from row to row What does that mean This segment appeared because of some split at row At row some black cell appeared that split the segment in parts If we knew the for the segment we could ve saved the information about it during the event at row So we need a data structure that can support the following operations find a segment that covers cell erase a segment insert a segment Additionally that data structure should store a value associated with a segment Thus let s use a map For a segment which is a pair of integers store another integer the bottommost row this segment exists Make events for each column Sort them and process in a non increasing order During the processing of the event find the segment this black cell splits Save the information about this segment Then remove it and add two new segments or less if some are empty the one to the left and the one to the right At the end for each length from to we will have the number of segments of such length In order to fill them with integers start with the longest segments and use as many of each length as possible So while having more integers to place and segments of length you can use of segments Overall complexity per testcase 
https://codeforces.com//contest/800/problem/A,103095,A,800A,800,A. Voltage Keepsake,You have devices that you want to use simultaneously The th device uses units of power per second This usage is continuous That is in seconds the device will use units of power The th device currently has units of power stored All devices can store an arbitrary amount of power You have a single charger that can plug to any single device The charger will add units of power per second to a device This charging is continuous That is if you plug in a device for seconds it will gain units of power You can switch which device is charging at any arbitrary unit of time including real numbers and the time it takes to switch is negligible You are wondering what is the maximum amount of time you can use the devices until one of them hits units of power If you can use the devices indefinitely print Otherwise print the maximum amount of time before any one device hits power ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\n\nstruct Input {\n\tint n, p;\n\tint a[N], b[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> p)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d%d"", &a[i], &b[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tld ans;\n\t\n\tvoid write () {\n\t\tif (ans == -1) {\n\t\t\tputs(""-1"");\n\t\t\treturn;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\n\t\tbool check (ld x) {\n\t\t\tld sum = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tsum += max<ld>(0, a[i] * x - b[i]);\n\t\t\t}\n\t\t\treturn p * x > sum;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tll sum = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\tif (sum <= p) {\n\t\t\t\tans = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tld l = 0, r = 1e18;\n\t\t\tforn (i, 100) {\n\t\t\t\tld md = (l + r) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\tl = md;\n\t\t\t\t} else {\n\t\t\t\t\tr = md;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (l + r) / 2;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + "".in"").c_str(), ""r"", stdin);\n//\t\tfreopen((problemname + "".out"").c_str(), ""w"", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n']",,,"['binary search', 'greedy']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Voltage Keepsake.json,https://codeforces.com//blog/entry/51598,First let s deal with the infinite case If the supply of power is at least as big as the sum of demands we can keep all devices alive indefinitely Otherwise let s binary search for the result We can do binary search since if we can keep all devices alive for E seconds we can keep it alive for any time less than E seconds Since all usage charging is continuous we can think about it as splitting up the charge amount For each device and a fixed time T we can compute the rate that we need to charge it so that the device always has positive power Well it uses ai power per second so it uses a total of T ai power It currently has bi power so we need Xi max 0 T ai bi units of power This means we need Xi T units of power per second to this device So we just need to check that If so then it is possible to keep the devices alive for T seconds and we can use this to continue our binary search Since we are binary searching on doubles it is useful to just do it for a fixed number of steps We can approximate the max answer is somewhere around 1014 and we need a precision of 10 4 so we need approximately iterations 
https://codeforces.com//contest/1605/problem/C,1182996,C,1605C,1605,C. Dominant Character,Ashish has a string s of length n containing only characters and He wants to find the length of the smallest substring which satisfies the following conditions Length of the substring is 2 occurs strictly more times in this substring than occurs strictly more times in this substring than Ashish is busy planning his next Codeforces round Help him solve the problem A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ,"['// Problem: C. Dominant Character\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nchar s[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tscanf(""%s"",s+1);\n\t\tbool flg=0;\n\t\tfor(int i=1; i<n; ++i) if(s[i]==\'a\'&&s[i+1]==\'a\')\n\t\t{\n\t\t\tflg=1;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tputs(""2"");\n\t\t\tcontinue;\n\t\t}\n\t\tint len=n+5;\n\t\tfor(int i=1; i<=n; ++i) if(s[i]==\'a\')\n\t\t{\n\t\t\tint sa=0,sb=0,sc=0;\n\t\t\tfor(int j=i; j<=i+10&&j<=n; ++j)\n\t\t\t{\n\t\t\t\tif(s[j]==\'a\') ++sa;\n\t\t\t\telse if(s[j]==\'b\') ++sb;\n\t\t\t\telse ++sc;\n\t\t\t\tif(j>i&&sa>sb&&sa>sc)\n\t\t\t\t{\n\t\t\t\t\tlen=min(len,j-i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(len>n) puts(""-1"");\n\t\telse printf(""%lld\\n"",len);\n\t}\n\treturn 0;\n}']",,,"['brute force', 'greedy', 'implementation', 'strings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Dominant Character.json,https://codeforces.com//blog/entry/96866, The following are all the possible minimal substrings there aren t that many which satisfy the given conditions Any other string that satisfies the condition contains at least one of these as a substring and hence is not the optimal substring for the answer If a substring exists which satisfies the given conditions then the length of the shortest such substring is at most Otherwise the solution does not exist Let us consider that the solution exists We will try to prove this by breaking this into the following cases There exist two such whose distance is less than or equal to where distance is the absolute difference of their indices In this case where there are two such whose distance is less than then either these two are present consecutive or there is only one single letter between these two All these minimal substrings are and which satisfies all the given conditions Hence we can say that the shortest length of such substring that satisfies the given conditions is at most in this case There exists no two such whose distance is less than or equal to In this case all the consecutive occurrences of are present at a distance at least Then in order for the number of to be bigger than that of and the string must look like Let us define as a block Now if there is any block consisting of different characters or then the substring will satisfy all the given conditions and hence the minimal length will be Notice that there must be at least one block of and atleast one block of otherwise will not be in a majority Hence there must exist 2 consecutive blocks equal to and or and in the string otherwise all blocks would be of the same character Hence we can pick the substring or which satisfies the given conditions The minimal length is therefore in this case Therefore we can say that the shortest length of such substring that satisfies the given conditions is at most in this case Thus it suffices to only check all substrings of length up to and find the smallest among them that satisfies the given conditions or report that it does not exist 
https://codeforces.com//contest/877/problem/D,130131,D,877D,877,D. Olya and Energy Drinks,Olya loves energy drinks She loves them so much that her room is full of empty cans from energy drinks Formally her room can be represented as a field of cells each cell of which is empty or littered with cans Olya drank a lot of energy drink so now she can run meters per second Each second she chooses one of the four directions up down left or right and runs from to meters in this direction Of course she can only run through empty cells Now Olya needs to get from cell to cell How many seconds will it take her if she moves optimally It s guaranteed that cells and are empty These cells can coincide ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long  LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define F first\n#define S second\ninline int read(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == \'-\')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - \'0\';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar(\'0\'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar(\'-\');\n\t}\n\twrite(a); puts("""");\n}\n#include<string>\nconst int N=1005;\nint n,m,k,sx,sy,tx,ty,l,r,bs[N*N*4],s1[4]={0,0,1,-1},s2[4]={1,-1,0,0};\nbool vis[N][N][4];\npair<int,int> zz,zs,que[N*N*4];\nchar ch[N][N];\nint main(){\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++)scanf(""\\n%c"",&ch[i][j]);\n\t}\n\tcin>>sx>>sy>>tx>>ty;\n\tque[r=1]=mp(sx,sy); for(int i=0;i<4;i++)vis[sx][sy][i]=1;\n\twhile(l<r){\n\t\tzs=que[++l];\n\t\tif(zs==mp(tx,ty)){\n\t\t\twriteln(bs[l]); return 0;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tzz=zs;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tzz.F+=s1[i]; zz.S+=s2[i];\n\t\t\t\tif(zz.F&&zz.S&&zz.F<=n&&zz.S<=m&&!vis[zz.F][zz.S][i]&&ch[zz.F][zz.S]==\'.\'){\n\t\t\t\t\tvis[zz.F][zz.S][i]=1;\n\t\t\t\t\tque[++r]=zz;\n\t\t\t\t\tbs[r]=bs[l]+1;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t}\n\t}\n\tputs(""-1"");\n}']",,,"['data structures', 'dfs and similar', 'graphs', 'shortest paths']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Olya and Energy Drinks.json,https://codeforces.com//blog/entry/55362,Note that can find right answer but works in It s too slow We ll store all not visited cells in For each row and column we ll make own Now it s easy to find all not visited cell which is reachable from vertex in where is number of this cells Then summary it works in 
https://codeforces.com//contest/1601/problem/A,1157777,A,1601A,1601,A. Array Elimination,You are given array a 1 a 2 ldots a n consisting of non negative integers Let s define operation of elimination with integer parameter k 1 leq k leq n as follows Choose k distinct array indices 1 leq i 1 i 2 ldots i k le n Calculate x a i 1 a i 2 ldots a i k where denotes the bitwise AND operation notes section contains formal definition Subtract x from each of a i 1 a i 2 ldots a i k all other elements remain untouched Find all possible values of k such that it s possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k It can be proven that exists at least one possible k for any array a Note that you ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[200005], c[35];\nint gcd(int x, int y)\n{\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nvoid solve()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%d"", &a[i]);\n\tmemset(c, 0, sizeof(c));\n\trep(i, n) rep(j, 30) if(a[i] >> j & 1) c[j] ++;\n\tint r = 0;\n\trep(i, 30) r = gcd(r, c[i]);\n\trep1(i, n) if(r % i == 0) printf(""%d "", i); printf(""\\n"");\n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']",,,"['bitmasks', 'greedy', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Array Elimination.json,https://codeforces.com//blog/entry/95865,Let s note that in one destruction for any bit we either change all th non zero bits into zero bits or nothing changes So the number of th non zero bits in the array either decreases by or doesn t change In the end all these numbers will be equal to So to be able to destruct the array the number of th non zero bits in the array should be divisible by for all bits Let s prove that it is enough to destruct the array Let s make operations with non zero AND while we can make them In the end there is at least one non zero element if we have not destructed the array So there is at least one bit for which the number of th non zero bits in the array is non zero so this number is at least because it is divisible by So we can select numbers with th non zero bit to the next operation and make the new destruction which is impossible So the resulting solution is for each bit let s find the number of array s elements with non zero th bit Let s find all common divisors of these numbers Time complexity is where upper limit on all numbers in the array 
https://codeforces.com//contest/1203/problem/F2,388109,F2,1203F2,1203,F2. Complete the Projects  hard version , Polycarp is a very famous freelancer His current rating is r units Some very rich customers asked him to complete some projects for their companies To complete the i th project Polycarp needs to have at least a i units of rating after he completes this project his rating will change by b i his rating will increase or decrease by b i b i can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Polycarp can choose the order in which he completes projects Furthermore he can even skip some projects altogether To gain more experience and money of course Polycarp wants to choose the subset of projects and the order in which he will complete them so he has enough rating before starting each project and has non negative rating after completing each project Your task is to calculate the maximum possible size of such subset of projects ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Project {\n\tint a, b;\n};\n\nvoid maximize(int &a, int b) {\n\tif (a < b) a = b;\n}\n\nint main() {\n\tint n, r;\n\tcin >> n >> r;\n\t\n\tvector<Project> pos, neg;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (b >= 0) {\n\t\t\tpos.push_back({a, b});\n\t\t} else {\n\t\t\tneg.push_back({a, -b});\n\t\t}\n\t}\n\n\tsort(begin(pos), end(pos), [](const Project &x, const Project &y) { return x.a < y.a; });\n\tint res = 0;\n\tfor (auto it : pos) {\n\t\tif (r >= it.a) {\n\t\t\tr += it.b;\n\t\t\t++res;\n\t\t}\n\t}\n\n\tsort(begin(neg), end(neg), [](const Project &x, const Project &y) { return x.a - x.b > y.a - y.b; });\n\tvector< vector<int> > dp(neg.size() + 1, vector<int>(r + 1, -1));\n\tdp[0][r] = 0;\n\tfor (int i = 0; i < neg.size(); ++i) {\n\t\tfor (int j = 0; j <= r; ++j) if (dp[i][j] >= 0) {\n\t\t\tif (j >= max(neg[i].a, neg[i].b)) {\n\t\t\t\tmaximize(dp[i + 1][j - neg[i].b], dp[i][j] + 1);\n\t\t\t}\n\t\t\tmaximize(dp[i + 1][j], dp[i][j]);\n\t\t}\n\t}\n\tcout << res + *max_element(begin(dp[neg.size()]), end(dp[neg.size()])) << endl;\n}']",,,"['dp', 'greedy']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F2. Complete the Projects  hard version .json,https://codeforces.com//blog/entry/69108,To view the main idea of the problem read the editorial of easy version The only difference is that for non negative we don t need to print if we cannot take the project we just need to skip it because we cannot take it at all And for negative we need to write the knapsack dynamic programming to take the maximum possible number of projects we need to consider them in order of their sorting Dynamic programming is pretty easy means that we consider projects and our current rating is and the value of dp is the maximum number of negative projects we can take If the current project is the th negative project in order of sorting we can do two transitions and if then we can make the transition And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer 
https://codeforces.com//contest/484/problem/D,16631,D,484D,484,D. Kindergarten,In a kindergarten the children are being divided into groups The teacher put the children in a line and associated each child with his or her integer charisma value Each child should go to exactly one group Each group should be a nonempty segment of consecutive children of a line A group s is the maximum difference of charisma of two children in the group in particular if the group consists of one child its sociability equals a zero The teacher wants to divide the children into some number of groups in such way that the total of the groups is maximum Help him find this value ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nconst int MAXN = 1000010;\nint a[MAXN];\ni64 dp[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    scanf(""%d"", &N);\n    forn(i, N) scanf(""%d"", &a[i]);\n    dp[0] = dp[1] = 0;\n    int extr = 0;\n    bool ismin = true, ismax = true;\n    for (int i = 1; i < N; ++i) {\n        if (a[i] == a[i - 1]) {\n            extr = i - 1;\n            ismin = ismax = true;\n        }\n        if (a[i] < a[i - 1] && ismin) {\n            extr = i - 1;\n            ismax = true;\n            ismin = false;\n        }\n        if (a[i] > a[i - 1] && ismax) {\n            extr = i - 1;\n            ismin = true;\n            ismax = false;\n        }\n        dp[i + 1] = abs(a[i] - a[extr]) + dp[extr];\n        dp[i + 1] = max(dp[i + 1], abs(a[i] - a[extr + 1]) + dp[extr + 1]);\n    }\n    cout << dp[N] << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']",,,"['data structures', 'dp', 'greedy']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Kindergarten.json,https://codeforces.com//blog/entry/14592,Let us note that in optimal answer any segment that making a group contains their minimum and maximum values on borders Otherwise it will be better to split this segment to two other segments Another note that is every segment in optimal solution is strictly monotonic increasing or decreasing Paying attention to the interesting points in sequence which making local maximums i e local minimums and point adjacent to them Solve the problem by dynamic programming is the answer in the prefix To calculate we need to look at no more than three previous interesting points and to previous Total time complexity is 
https://codeforces.com//contest/1093/problem/F,270227,F,1093F,1093,F. Vasya and Array,Vasya has got an array consisting of n integers and two integers k and len in addition All numbers in the array are either between 1 and k inclusive or equal to 1 The array is good if there is no segment of len consecutive numbers Vasya will replace each 1 with some number from 1 to k inclusive in such a way that the resulting array is good Tell him the number of ways to do this replacement Since the answer may be large print it modulo 998244353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nconst int maxk = 100 + 5;\nconst int mod = 998244353;\nint a[maxn], to[maxk][maxn];\nint dp[maxk][maxn], s[maxk][maxn], offset[maxk];\n\nint main() {\n    int n, k, l; scanf(""%d%d%d"", &n, &k, &l);\n    for (int i = 1; i <= n; ++i) scanf(""%d"", &a[i]);\n    if (l == 1) {\n        puts(""0"");\n        return 0;\n    }\n    --l;\n    for (int i = 1; i <= k; ++i) {\n        int last = n;\n        for (int j = n; j >= 1; --j) {\n            to[i][j] = last;\n            if (a[j] != -1 && a[j] != i) last = j - 1;\n        } \n    }\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        // for (int j = 0; j <= k; ++j) printf(""s[%d][%d] = %d\\n"", j, i, s[j][i]);\n        for (int j = 0; j <= k; ++j) (offset[j] += s[j][i]) %= mod;\n        // for (int j = 0; j <= k; ++j) printf(""offset[%d] = %d\\n"", j, offset[j]);\n        for (int j = 0; j <= k; ++j) (dp[j][i] += offset[j]) %= mod;\n        if (i == n) break;\n        int sum = 0;\n        for (int j = 0; j <= k; ++j) (sum += dp[j][i]) %= mod;\n        for (int j = 1; j <= k; ++j) {\n            // printf(""dp[%d][%d] = %d\\n"", j, i, dp[j][i]);\n            int way = (sum + mod - dp[j][i]) % mod;\n            if (a[i + 1] != -1 && a[i + 1] != j) continue;\n            int g = min(to[j][i + 1], i + 1 + l - 1);\n            // printf(""i = %d j = %d way = %d to = %d\\n"", i, j, way, g);\n            (s[j][i + 1] += way) %= mod;\n            (s[j][g + 1] += mod - way) %= mod;\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= k; ++i) (ans += dp[i][n]) %= mod;\n    printf(""%d\\n"", ans);\n    return 0;\n}\n\n']",,,['dp'],2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Vasya and Array.json,https://codeforces.com/blog/entry/63877,Let s try dynamic programming approach to this problem Let be the number of ways to replace all with numbers from to in such a way that array is good and the last number of that array is Let Then initially it s if equals to or However we could include incorrect states such that segment consist of the same value It happens when as we should have at least elements segment has all its elements either equal to or If both of these conditions hold then you should subtract all the bad states from The number of them is 
https://codeforces.com//contest/736/problem/C,82053,C,736C,736,C. Ostap and Tree,Ostap already settled down in Rio de Janiero suburb and started to grow a tree in his garden Recall that a tree is a connected undirected acyclic graph Ostap s tree now has vertices He wants to paint some vertices of the tree black such that from any vertex there is at least one black vertex at distance no more than between two vertices of the tree is the minimum possible number of edges of the path between them As this number of ways to paint the tree can be large Ostap wants you to compute it modulo Two ways to paint the tree are considered different if there exists a vertex that is painted black in one way and is not painted in the other one ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(""%d\\n"",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(""%d\\n"",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld ""%I64d""\n#else\n#define lld ""%lld""\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');c==\'-\'?(sg=-1,x=0):(x=c-\'0\');\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gn(long double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gs(char *s){scanf(""%s"",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\nconst int mo=1e9+7;\nint qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n,k;\n\n// manually set n = number of vertices \n// vertex index from 1 to n\n// first call tree_init();\n// ae(u,v) only one direction\n\nconst int TREE_MAXV=3000+5;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pre[TREE_MAXV];\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpre[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\nvoid readedge(){\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;gn(x);gn(y);\n\t\tae(x,y);ae(y,x);\n\t}\n}\n\n\nint f[111][33][33];\nvoid dp(int u){\n\tint h[33][33];\n\tint h2[33][33];\n\tint deg=0;\n\tmemset(h,0,sizeof(h));\n\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\tif(deg==0){\n\t\t\tdeg++;\n\t\t\trep(j,0,k+3)rep(t,0,k+3)h[j][t]=f[e[i].v][j][t];\n\t\t}else{\n\t\t\tcl(h2);\n\t\t\trep(j,0,k+3)rep(t,0,k+3)if(h[j][t])\n\t\t\t\trep(jj,0,k+3)rep(tt,0,k+3)if(f[e[i].v][jj][tt]){\n\t\t\t\t\tint qian=min(jj,j);\n\t\t\t\t\tint xu=k+2;\n\t\t\t\t\tif(t!=k+2){\n\t\t\t\t\t\tif(jj+2>t)upmin(xu,t);\n\t\t\t\t\t}\n\t\t\t\t\tif(tt!=k+2){\n\t\t\t\t\t\tif(j+2>tt)upmin(xu,tt);\n\t\t\t\t\t}\n\t\t\t\t\tupmo(h2[qian][xu],1ll*h[j][t]*f[e[i].v][jj][tt]);\n\t\t\t\t}\n\t\t\trep(j,0,k+3)rep(t,0,k+3)h[j][t]=h2[j][t];\n\t\t\tdeg++;\n\t\t}\n\t}\n\tif(deg){\n\t\trep(j,0,k+3)rep(t,1,k+3){\n\t\t\t//white\n\t\t\tint xu=k+2;\n\t\t\tif(j+1>k)xu=k;\n\t\t\tif(t!=k+2)xu=min(xu,t-1);\n\t\t\tint qian=min(k+2,j+1);\n\t\t\tif(xu>=0)upmo(f[u][qian][xu],h[j][t]);\n\n\t\t\t//black\n\t\t\tupmo(f[u][0][k+2],h[j][t]);\n\t\t}\n\t}else{\n\t\tf[u][0][k+2]=1;\n\t\tf[u][k+2][k]=1;\n\n\t}\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tint _time_jc=clock();\n#endif\n\ttree_init();\n\tgn(n);gn(k);\n\treadedge();\n\tbfs(1);\n\tfor (int i=n-1;i>=0;i--){\n\t\tdp(qu[i]);\n\t}\n\tint ans=0;\n\trep(i,0,k+3)upmo(ans,f[1][i][k+2]);\n\tprintf(""%d\\n"",ans);\n#ifdef JCVB\n\tdebug(""time: %d\\n"",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n']",,,"['dp', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Ostap and Tree.json,https://codeforces.com//blog/entry/48659,First of all thanks to albert96 and GlebsHP for their help with the tutorial of this problem Secondly sorry for being late Problem can be solved by the method of dynamic programming Let dp v i j be the number of possibilities to color subtree of vertex v in such a way that the closest black vertex is on depth i and the closest white vertex on depth j we also store dp v 1 j and dp v i 1 in the cases where there are no black and white vertexes in diapason k of v respectively In order to connect two subtrees we can check all pairs i j in both subtrees by brute force algorithm Then let we have pair a c in the first subtree and pair b d in the second one If min a c max b d k then we update value of current vertex Complexity of the algorithm O n k 4 which is acceptable for this particular problem n the number of vertexes k 4 brute force search of pairs a b c d 
https://codeforces.com//contest/476/problem/A,15273,A,476A,476,A. Dreamoon and Stairs,Dreamoon wants to climb up a stair of steps He can climb or steps at each move Dreamoon wants the number of moves to be a multiple of an integer What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition ,"['//BISM ILLAHHIRRAHMANNI RRAHIM\n\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iterator>\n#include <utility>\nusing namespace std;\n\ntemplate< class T > T _abs(T n) { return (n < 0 ? -n : n); }\ntemplate< class T > T _max(T a, T b) { return (!(a < b) ? a : b); }\ntemplate< class T > T _min(T a, T b) { return (a < b ? a : b); }\ntemplate< class T > T sq(T x) { return x * x; }\n\n#define ALL(p) p.begin(),p.end()\n#define MP(x, y) make_pair(x, y)\n#define SET(p) memset(p, -1, sizeof(p))\n#define CLR(p) memset(p, 0, sizeof(p))\n#define MEM(p, v) memset(p, v, sizeof(p))\n#define CPY(d, s) memcpy(d, s, sizeof(s))\n#define READ(f) freopen(f, ""r"", stdin)\n#define WRITE(f) freopen(f, ""w"", stdout)\n#define SZ(c) (int)c.size()\n#define PB(x) push_back(x)\n#define ff first\n#define ss second\n#define i64 long long\n#define ld long double\n#define pii pair< int, int >\n#define psi pair< string, int >\n#define vi vector< int >\n\nconst double EPS = 1e-9;\nconst int INF = 0x7f7f7f7f;\n\nint dp[10010][13],m;\nbool vis[10010][13];\n\nint dfs(int n,int md) {\n    //cout<<n<<\' \'<<md<<\'\\n\';\n    if(!n) return md?100000000:0;\n    if(vis[n][md]) return dp[n][md];\n    vis[n][md]=1;\n    int r=dfs(n-1,(md+1)%m);\n    if(n>1) r=min(r,dfs(n-2,(md+1)%m));\n    return dp[n][md]=1+r;\n}\n\n\nint main() {\n\t//READ(""in.txt"");\n\t//WRITE(""out.txt"");\n\tint n;\n\tcin>>n>>m;\n\tint t=dfs(n,0);\n\tif(t>n) t=-1;\n\tcout<<t<<\'\\n\';\n\treturn 0;\n}\n']",,,"['implementation', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Dreamoon and Stairs.json,https://codeforces.com//blog/entry/14256,We can show that the maximum number of moves possible is n and minimal moves needed is so the problem equals to determine the minimal integer that is a multiple of m in the range One way to find the minimal number which is a multiple of m and greater than or equal to a number x is we can compare this number to the upper bound n to determine if there is a valid solution Although best practice is O 1 O n enumeration of each possible number of moves would also work time complexity O 1 sample code 8212169 explanation of sample code The can be calculated in the following c code if a is non negative and b is positive a b 1 b Because in c is integral division so a b 1 b would result in Let a div a b b mod a b db m Which means if otherwise div a b 1 b d 1 Can be translated to if otherwise div a b 1 b div a b 1 Which matches the value of 
https://codeforces.com//contest/416/problem/B,8296,B,416B,416,B. Art Union,A well known art union called Kalevich is Alive manufactures objects d art pictures The union consists of painters who decided to organize their work as follows Each painter uses only the color that was assigned to him The colors are distinct for all painters Let s assume that the first painter uses color 1 the second one uses color 2 and so on Each picture will contain all these colors Adding the th color to the th picture takes the th painter units of time Order is important everywhere so the painters work is ordered by the following rules Each picture is first painted by the first painter then by the second one and so on That is after the th painter finishes working on the picture it must go to the th painter if each painter works on the pictures in some order first he paints the first picture then he paints the second picture and so on each painter can simultaneously work on at most one picture However the painters don t need any time to have a rest as soon as the th painter finishes his part of working on the picture the picture immediately becomes available to the next painter Given that the painters start working at time 0 find for each picture the time when it is ready for sale ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 100000;\n\nint n, m;\nint f[N][10];\nint g[N][10];\n\nvoid solve()\n{\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; ++ i) {\n\t\tfor(int j = 0; j < n; ++ j) {\n\t\t\tscanf(""%d"", &f[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++ i) {\n\t\tg[i + 1][0] = g[i][0] + f[i][0];\n\n\t\tfor(int j = 1; j < n; ++ j) {\n\t\t\tg[i + 1][j] = max(g[i + 1][j - 1] + f[i][j], g[i][j] + f[i][j]);\n\t\t}\n\n\t\tprintf(""%d "", g[i + 1][n - 1]);\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n']",,,"['brute force', 'dp', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Art Union.json,https://codeforces.com//blog/entry/12277,All we need is to iterate over all painters and for each painter to iterate over all pictures In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier Submission 6606994 
https://codeforces.com//contest/416/problem/D,8298,D,416D,416,D. Population Size,Polycarpus develops an interesting theory about the interrelation of arithmetic progressions with just everything in the world His current idea is that the population of the capital of Berland changes over time like an arithmetic progression Well or like multiple arithmetic progressions Polycarpus believes that if he writes out the population of the capital for several consecutive years in the sequence then it is convenient to consider the array as several arithmetic progressions written one after the other For example sequence can be considered as a sequence of three arithmetic progressions and which are written one after another Unfortunately Polycarpus may not have all the data for the consecutive years a census of the population doesn t occur every year after all For this reason some values of may be unknown Such values are represented by number For a given sequence which consists of positive integers and values find the minimum number of arithmetic progressions Polycarpus needs to get To get the progressions need to be written down one after the other Values may correspond to an arbitrary positive integer and the values must be equal to the corresponding elements of sought consecutive record of the progressions Let us remind you that a finite sequence is called an arithmetic progression if the difference of any two consecutive elements in it is constant By definition any sequence of length 1 is an arithmetic progression ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 200000 + 10;\n\nint n;\nlong long a[N];\n\nint getNext(int st)\n{\n    long long tmp = st;\n    vector<pair<long long, int> > vec;\n    for( ; tmp < n && vec.size() < 2; tmp ++) {\n        if (a[tmp] > 0) {\n            vec.push_back(make_pair(a[tmp], tmp));\n        }\n    }\n    if (vec.size() != 2) return n;\n\n    long long v1 = vec[0].first, t1 = vec[0].second;\n    long long v2 = vec[1].first, t2 = vec[1].second;\n    if ((v2 - v1) % (t2 - t1) == 0) {\n        long long d = (v2 - v1) / (t2 - t1);\n        tmp = v1;\n        int flag = true;\n        for(int i = t1 - 1; i >= st; -- i) {\n            tmp -= d;\n            if (tmp <= 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            st = t2;\n            tmp = v2;\n            for( ; st < n && tmp > 0; ) {\n                if (a[st] > 0 && a[st] != tmp) break;\n                ++ st;\n                tmp += d;\n            }\n            return st;\n        }\n    }\n    return t2;\n}\n\nvoid solve()\n{\n    cin >> n;\n    for(int i = 0; i < n; ++ i) {\n        scanf(""%I64d"", a + i);\n    }\n    int ret = 0;\n    int tmp = 0;\n    for( ; tmp != n; ) {\n        ++ ret;\n        tmp = getNext(tmp);\n    }\n    cout << ret << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n']",,,"['greedy', 'implementation', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Population Size.json,https://codeforces.com//blog/entry/12277,One thing to notice for this problem is that if we cover some interval with a progression then it will better at least no worse to include as many elements to the right of it as possible So the solution is to greedy find the leftmost number not covered by a progression start a new progression with that number the interval covered by that progression will be of size 1 and then try to extend this interval to the right as far as possible Repeat this step until all the numbers are covered One thing you should pay attention to is which numbers can be covered by one arithmetic progression for example If there are no fixed numbers in the interval then we can cover it with one progression If there is only one non fixed number in the interval then we can cover this interval with one progression If there are more than one non fixed numbers in the interval then we can calculate the parameters of the progression start value and difference All non fixed numbers should match those parameters Difference should be integer If the progression is ascending and there are some non fixed numbers in the beginning then those numbers should match positive numbers in the progression Same way if the progression is descending then we can include numbers from the right side only while matching progression term is positive Submission 6607174 
https://codeforces.com//contest/1181/problem/D,359263,D,1181D,1181,D. Irrigation,Misha was interested in water delivery from childhood That s why his mother sent him to the annual Innovative Olympiad in Irrigation IOI Pupils from all Berland compete there demonstrating their skills in watering It is extremely expensive to host such an olympiad so after the first n olympiads the organizers introduced the following rule of the host city selection The host cities of the olympiads are selected in the following way There are m cities in Berland wishing to host the olympiad they are numbered from 1 to m The host city of each next olympiad is determined as the city that hosted the olympiad the number of times before If there are several such cities the city with the index is selected among them Misha s mother is interested where the olympiad will be held in some specific years The only information she knows is the above selection rule and the host cities of the first n olympiads Help her and if you succeed she will ask Misha to avoid flooding your house ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=5e5;\nint n, m, q, c[mxN];\nset<int> s;\nar<ll, 2> a[2*mxN];\nvector<int> tr[mxN+1];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> m >> q;\n\tfor(int i=0, a; i<n; ++i)\n\t\tcin >> a, ++c[a-1];\n\tfor(int i=0; i<m; ++i) {\n\t\tif(c[i])\n\t\t\ts.insert(i);\n\t\ttr[c[i]].push_back(i);\n\t}\n\ts.insert(m);\n\tint jj=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tint la=-1;\n\t\tauto it=s.begin();\n\t\twhile(it!=s.end()) {\n\t\t\tif(*it-la-1)\n\t\t\t\ta[jj++]={*it-la-1, la+1};\n\t\t\tla=*it;\n\t\t\t++it;\n\t\t}\n\t\tfor(int u : tr[i])\n\t\t\ts.erase(u);\n\t}\n\tfor(int i=1; i<jj; ++i)\n\t\ta[i][0]+=a[i-1][0];\n\twhile(q--) {\n\t\tll k;\n\t\tcin >> k, k-=n+1;\n\t\tif(k>=a[jj-1][0]) {\n\t\t\tk-=a[jj-1][0];\n\t\t\tcout << k%m+1 << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tint p=lower_bound(a, a+jj, ar<ll, 2>{k, m})-a;\n\t\tll ss=p?a[p-1][0]:0;\n\t\tcout << k-ss+a[p][1]+1 << ""\\n"";\n\t}\n}']",,,"['binary search', 'data structures', 'implementation', 'sortings', 'trees', 'two pointers']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Irrigation.json,https://codeforces.com//blog/entry/67727,Let s solve all the queries simultaneously For this purpose sort them all in increasing order Sort all the countries based on the number of hosted competitions in the first years see picture How this diagram changes after several more years of the competition The cells are filled from lower rows to the higher while inside one row we order cells based on the country number Let s fill this table from bottom upwards For the queries which won t be replied in the current row it is not important in which order the cells in the current row are colored only the quantity is important So for such queries we can simply accumulate the number of already painted cells so far Now let s discuss the queries which need to be answered in the current row If we subtract from the query parameter the number of cells painted in previous rows then we simply need to return the th element in this set So in other words we need to add countries in the set and sometimes compute th element in it One can use cartesian tree treap or a segment tree to do that It may also turn out that after we fill all the diagram there are some questions unanswered yet In this case we can notice that all the subsequent rows look like the whole set of countries So the answer is simply the remainder of modulo Since we only need to consider at most lines until the diagram is filled up the solution works in 
https://codeforces.com//contest/622/problem/C,47917,C,622C,622,C. Not Equal on a Segment,You are given array with integers and queries The th query is given with three integers For the th query find any position so that ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nVI d[SIZE];\nint a[SIZE],nxt[SIZE];\nint main(){\n    map<PII,int>H;\n    DRII(n,m);\n    REP(i,n){\n        DRI(x);\n        a[i+1]=x;\n        d[x].PB(i+1);\n    }\n    for(int i=n-1;i>0;i--){\n        if(a[i+1]!=a[i])nxt[i]=i+1;\n        else nxt[i]=nxt[i+1];\n    }\n    while(m--){\n        DRIII(l,r,x);\n        int it1=lower_bound(ALL(d[x]),l)-d[x].begin();\n        int it2=lower_bound(ALL(d[x]),r+1)-d[x].begin();\n        if(it2-it1==r-l+1)puts(""-1"");\n        else printf(""%d\\n"",a[l]==x?nxt[l]:l);\n    }\n    return 0;\n}\n']",,,"['data structures', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Not Equal on a Segment.json,https://codeforces.com//blog/entry/23442,This problem is a simplified version of the problem suggested by Mohammad Nematollahi Deemo This problem can be solved differently For example you can use some data structures or sqrt decomposition technique But it is not required We expected the following simple solution from the participants Let s preprocess the following values the position of the first element to the left from the th element such that Now to answer to the query we should check if then we have the answer Otherwise we should check the position C solution Complexity 
https://codeforces.com//contest/1472/problem/C,854353,C,1472C,1472,C. Long Jumps,Polycarp found under the Christmas tree an array a of n elements and instructions for playing with it At first choose index i 1 leq i leq n starting position in the array Put the chip at the index i on the value a i While i leq n add a i to your score and move the chip a i positions to the right i e replace i with i a i If i n then Polycarp ends the game For example if n 5 and a 7 3 1 2 3 then the following game options are possible Polycarp chooses i 1 Game process i 1 overset 7 longrightarrow 8 The score of the game is a 1 7 Polycarp chooses i 2 Game process i 2 overset 3 longrightarrow 5 overset 3 longrightarrow 8 The score of the game is a 2 a 5 6 Polycarp chooses i 3 Game process i 3 overset 1 longrightarrow 4 overset 2 longrightarrow 6 The score of the game is a 3 a 4 3 Polycarp chooses i 4 Game process i 4 overset 2 longrightarrow 6 The score of the game is a 4 2 Polycarp chooses i 5 Game process i 5 overset 3 longrightarrow 8 The score of the game is a 5 3 Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nll a[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        for(int i = n; i >= 1; i--)\n            if(i + a[i] <= n)\n                a[i] += a[i + a[i]];\n        ll ans = 0;\n        for(int i = 1; i <= n; i++)\n            ans = max(ans, a[i]);\n        cout << ans << ""\\n"";\n    }\n    return 0;\n}\n']",,,"['dp', 'graphs']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Long Jumps.json,https://codeforces.com//blog/entry/86406,Let be the result of the game if we chose as the starting position Let s look at some starting position After making a move from it we will get points and move to the position continuing the same game This means that by choosing the position we can assume that we will get a result more than if we chose the position Formally Let s calculate all the results of and store them in an array Let s start iterating through the positions from the end then being in the position we will know for all Using the formula above we can calculate in one operation It remains only to choose the maximum of all such values 
https://codeforces.com//contest/321/problem/B,3264,B,321B,321,B. Ciel and Duel,Fox Ciel is playing a card game with her friend Jiro Jiro has cards each one has two attributes Attack or Defense and Fox Ciel has cards each one has these two attributes too It s known that position of all Ciel s cards is Attack Now is Ciel s battle phase Ciel can do the following operation many times Choose one of her cards This card mustn t be chosen before If Jiro has no alive cards at that moment he gets the damage equal to s strength Otherwise Ciel needs to choose one Jiro s alive card then If s position is Attack then s strength s strength must hold After this attack card dies and Jiro gets the damage equal to s strength s strength If s position is Defense then s strength s strength must hold After this attack card dies but Jiro gets no damage Ciel can end her battle phase at any moment so she can use not all her cards Help the Fox to calculate the maximal sum of damage Jiro can get ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//template<class Flow = int, class Cost = int>\ntypedef int Flow;\ntypedef int Cost;\n\nstruct MinCostFlow {\n\tstruct Edge {\n\t\tint t;\n\t\tFlow f;\n\t\tCost c;\n\t\tEdge*next, *rev;\n\t\tEdge(int _t, Flow _f, Cost _c, Edge*_next) :\n\t\t\t\tt(_t), f(_f), c(_c), next(_next) {\n\t\t}\n\t};\n\n\tvector<Edge*> E;\n\n\tint addV() {\n\t\tE.push_back((Edge*) 0);\n\t\treturn E.size() - 1;\n\t}\n\n\tEdge* makeEdge(int s, int t, Flow f, Cost c) {\n\t\treturn E[s] = new Edge(t, f, c, E[s]);\n\t}\n\n\tvoid addEdge(int s, int t, Flow f, Cost c) {\n\t\tEdge*e1 = makeEdge(s, t, f, c), *e2 = makeEdge(t, s, 0, -c);\n\t\te1->rev = e2, e2->rev = e1;\n\t}\n\n\tpair<Flow, Cost> minCostFlow(int vs, int vt, bool maxFlow) { //flow,cost\n\t\tint n = E.size();\n\t\tFlow flow = 0;\n\t\tCost cost = 0;\n//\t\tconst Cost MAX_COST = numeric_limits<Cost>::max();\n//\t\tconst Flow MAX_FLOW = numeric_limits<Flow>::max();\n\t\tconst Cost MAX_COST = ~0U >> 1;\n\t\tconst Flow MAX_FLOW = ~0U >> 1;\n\t\tfor (;;) {\n\t\t\tvector<Cost> dist(n, MAX_COST);\n\t\t\tvector<Flow> am(n, 0);\n\t\t\tvector<Edge*> prev(n);\n\t\t\tvector<bool> inQ(n, false);\n\t\t\tqueue<int> que;\n\n\t\t\tdist[vs] = 0;\n\t\t\tam[vs] = MAX_FLOW;\n\t\t\tque.push(vs);\n\t\t\tinQ[vs] = true;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front();\n\t\t\t\tCost c = dist[u];\n\t\t\t\tque.pop();\n\t\t\t\tinQ[u] = false;\n\t\t\t\tfor (Edge*e = E[u]; e; e = e->next)\n\t\t\t\t\tif (e->f > 0) {\n\t\t\t\t\t\tCost nc = c + e->c;\n\t\t\t\t\t\tif (nc < dist[e->t]) {\n\t\t\t\t\t\t\tdist[e->t] = nc;\n\t\t\t\t\t\t\tprev[e->t] = e;\n\t\t\t\t\t\t\tam[e->t] = min(am[u], e->f);\n\t\t\t\t\t\t\tif (!inQ[e->t]) {\n\t\t\t\t\t\t\t\tque.push(e->t);\n\t\t\t\t\t\t\t\tinQ[e->t] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (maxFlow) {\n\t\t\t\tif (dist[vt] == MAX_COST)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (dist[vt] >= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tFlow by = am[vt];\n\t\t\tint u = vt;\n\t\t\tflow += by;\n\t\t\tcost += by * dist[vt];\n\t\t\twhile (u != vs) {\n\t\t\t\tEdge*e = prev[u];\n\t\t\t\te->f -= by;\n\t\t\t\te->rev->f += by;\n\t\t\t\tu = e->rev->t;\n\t\t\t}\n\t\t}\n\n\t\treturn make_pair(flow, cost);\n\t}\n};\n\nconst int MAX_N = 100 + 10;\nint n, m;\nstring how[MAX_N];\nint A[MAX_N], B[MAX_N];\nint ia[MAX_N], ib[MAX_N];\n\nint notKillAll() {\n\tMinCostFlow net;\n\tint vs = net.addV(), vt = net.addV();\n\tfor (int i = 0; i < n; ++i) {\n\t\tia[i] = net.addV();\n\t\tnet.addEdge(vs, ia[i], 1, 0);\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tib[i] = net.addV();\n\t\tnet.addEdge(ib[i], vt, 1, 0);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t//j attack i\n\t\t\tif (B[j] > A[i] && how[i] == ""ATK"") {\n\t\t\t\tnet.addEdge(ia[i], ib[j], 1, -(B[j] - A[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -net.minCostFlow(vs, vt, false).second;\n}\n\nint killAll() {\n\tMinCostFlow net;\n\tint vs = net.addV(), vt = net.addV();\n\t//m>n!\n\tfor (int i = 0; i < m; ++i) {\n\t\tia[i] = net.addV();\n\t\tnet.addEdge(vs, ia[i], 1, 0);\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tib[i] = net.addV();\n\t\tnet.addEdge(ib[i], vt, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t//j attack i\n\t\t\tif (i < n) {\n\t\t\t\tif (how[i] == ""ATK"") {\n\t\t\t\t\tif (B[j] >= A[i])\n\t\t\t\t\t\tnet.addEdge(ia[i], ib[j], 1, -(B[j] - A[i]));\n\t\t\t\t} else {\n\t\t\t\t\tif (B[j] > A[i])\n\t\t\t\t\t\tnet.addEdge(ia[i], ib[j], 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//directly attack\n\t\t\t\tnet.addEdge(ia[i], ib[j], 1, -B[j]);\n\t\t\t}\n\t\t}\n\t}\n\tpair<int, int> ret = net.minCostFlow(vs, vt, true);\n\tif (ret.first == m)\n\t\treturn -ret.second;\n\treturn 0;\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> how[i] >> A[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> B[i];\n\t}\n\tint ans = notKillAll();\n\tif (m > n)\n\t\tans = max(ans, killAll());\n\tcout << ans << endl;\n\treturn 0;\n}\n']",,,"['dp', 'flows', 'greedy']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Ciel and Duel.json,https://codeforces.com//blog/entry/8192,We have 3 solutions to this problem 1 greedy There are 2 cases we killed all Jiro s cards or not If we are not killed all of Jiro s cards then If we kill all Jiro s card Then for all DEF cards we consider it from lower strength to higher if its strength is L then we find a card of Ciel with strength more than L If there are many we choose one with lowest strength Then we can know if we can kill all DEF cards And then we choose x cards with highest strength of Ciel try to kill Jiro s remain card Note that if we could kill all ATK cards the order doesn t matter the total damage will be sum of strength of Ciel s remain card sum of strength of Jiro s remain card 2 DP Above solution looks complicated can we solve it with few observation Yes we can The only observation is that There always exist an optimal solution that If Ciel s two card X s strength Y s strength and X Y attacks on A and B with the same position then A s strength B s strength We already use this observation in above solution Then what can we do Yes we can sort all Ciel s card all ATK card of Jiro all DEF card of Jiro Let s DP pCiel pATK pJiro killAll be the state that next unconsidered card of Ciel Jiro s ATk Jiro s DEF are pCiel pATK pJiro and killAll 1 if and only if we assume at the end we can kill all Jiro s card Then we have 4 choice 3 MinCostMaxFlow Well what if we want to solve this problem with no observation Ok if you are good at construct flow algorithm it s an easy thing to solve this by flow Please see my solution for details It just considered the matching relationship 
https://codeforces.com//contest/1293/problem/B,519783,B,1293B,1293,B. JOE is on TV ,Our dear Cafe s owner JOE Miller will soon take part in a new game TV show 1 vs n The game goes in rounds where in each round the host asks JOE and his opponents a common question All participants failing to answer are eliminated The show ends when only JOE remains we assume that JOE never answers a question wrong For each question JOE answers if there are s s 0 opponents remaining and t 0 le t le s of them make a mistake on it JOE receives displaystyle frac t s dollars and consequently there will be s t opponents left for the next question JOE wonders what is the maximum possible reward he can receive in the best possible scenario Yet he has little time before show starts so can you help him answering it instead ,['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    double ans = 0;\n    for (int i = 1; i <= n; ++i) ans += 1.0 / i;\n    cout << setprecision(12) << fixed << ans << endl;\n    return 0;\n}\n'],,,"['combinatorics', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. JOE is on TV .json,https://codeforces.com//blog/entry/73051,This is a greedy problem with the optimal scenario being each question eliminating a single opponent It is easy to see that we will want each question to eliminate one opponent only since after each elimination the ratio will be more and more rewarding as lowers overtime as a result each elimination should have the lowest possible i e so more opponents would have their rewards increased Time complexity is 
https://codeforces.com//contest/1996/problem/G,2778594,G,1996G,1996,G. Penacony,On there exists n houses and n roads There exists a road between house i and i 1 for all 1 leq i leq n 1 and a road between house n and house 1 All roads are bidirectional However due to the crisis on Penacony the overseeing family has gone into debt and may not be able to maintain all roads There are m pairs of friendships between the residents of Penacony If the resident living in house a is friends with the resident living in house b there must be a path between houses a and b through maintained roads What is the minimum number of roads that must be maintained ,"['/**   - dwuy -\xa0\u3000\u3000\u3000\u3000\u3000 ／＞\u3000   フ\u3000\u3000\u3000\u3000\u3000 | \u3000_\u3000 _|\u3000 \u3000\u3000\u3000 ／`ミ _x ノ\u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\u3000\u3000\u3000 /\u3000  ヽ\u3000\u3000 ?\u3000／￣|\u3000\u3000 |\u3000|\u3000|\u3000| (￣ヽ＿_ヽ_)_)\u3000＼二つ\xa0**/#include <bits/stdc++.h>\xa0#define fastIO ios_base::sync_with_stdio(false); cin.tie(NULL)#define file(a) freopen(a"".inp"",""r"",stdin); freopen(a"".out"", ""w"",stdout)#define fi first#define se second#define endl ""\\n""#define len(s) (int)((s).size())#define MASK(k)(1LL<<(k))#define TASK ""test""#define int long long\xa0using namespace std;\xa0typedef tuple<int, int, int> tpiii;typedef pair<double, double> pdd;typedef pair<int, int> pii;typedef long long ll;\xa0const long long OO = 1e18;const int MOD = 1e9 + 7;const int INF = 1e9;const int MX = 500005;\xa0struct Node{    int val;    int sum;     Node(int _val=0, int _sum=0){        val=_val;        sum=_sum;    }}; struct SMT{ /// just a SegMent Tree    int n;    vector<Node> tree;     SMT(int _n=0): n(_n) {        tree.assign(n*4+5, Node());    }     void update(int l, int r, int id, int u, int v, int val){        if (l>v || r<u) return;        if (l>=u && r<=v){            int _id= id<<1;            tree[id].val+=val;            if (tree[id].val==0){                if (l!=r) tree[id].sum = tree[_id].sum + tree[_id|1].sum;                else tree[id].sum=0;            }            else tree[id].sum = r-l+1;            return;        }        int mid = (l+r)>>1;        int _id = id<<1;        update(l, mid, _id, u, v, val);        update(mid+1, r, _id|1, u, v, val);        if (tree[id].val==0) tree[id].sum = tree[_id].sum+tree[_id|1].sum;    }     void update(int u, int v, int val){        update(1, n, 1, u, v, val);    }};\xa0int n, m, k, q;string s, t;int a[MX];int b[MX];vector<int> G[MX];vector<int> rG[MX];\xa0void solve(){    cin >> n >> m;    for(int i=1; i<=n + n; i++) G[i].clear(), rG[i].clear();    for(int i=1; i<=m; i++){        int u, v;        cin >> u >> v;        G[u].push_back(v);        G[v].push_back(u);    }        int ans = n;    int cur = 0;    SMT smt(n + n + 5);    for(int u=1; u<=n; u++){        for(int v: G[u]) if(v > u) smt.update(u, v - 1, 1), rG[u].push_back(v);    }    ans = min(ans, smt.tree[1].sum);    // cout << smt.tree[1].sum << endl;    for(int i=n+1; i<=n+n; i++){        int u = i - n;        for(int v: rG[u]){            smt.update(u, v - 1, -1);            // cout << "" + "" << u << \' \' << v << endl;        }\xa0        // cout << smt.tree[1].sum << endl;        for(int v: G[u]) if(v >= u? v : v + n < i){            smt.update(v >= u? v : v + n, i - 1, 1);            // cout << (v >= u? v : v + n) << \' \' << i - 1 << "" - "" << 1 << endl;            rG[v >= u? v : v + n].push_back(i);        }        ans = min(ans, smt.tree[1].sum);        // cout << "" "" << i << \' \' << u << ""   "" << smt.tree[1].sum << endl;    }    cout << ans << endl;}\xa0int32_t main(){    fastIO;    //file(TASK);\xa0    int q;    cin >> q;    while(q--){        solve();    }\xa0    return 0;}\xa0\xa0\xa0']",,,"['brute force', 'data structures', 'graphs', 'greedy', 'hashing']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\G. Penacony.json,https://codeforces.com//blog/entry/131528,There are two configurations to satisfy every friendship a b activate all the roads from a a 1 b or b n 1 a Let s fix a road we deactivate Say it goes from i i 1 Observe that the configuration for all friendships is fixed to one of the two cases For example if a i b then we must use the second configuration We can try fixing every road and taking the minimum of number of roads This can be done with sweep line Once we reach i a for any friendship we toggle to the second configuration Once we reach b we toggle back to the first We can track maintained roads by performing a range addition on a lazy propagated segment tree for each point covered by the current configuration The number of roads required is n minus the number of occurrences of zeroes in the segment tree which can be tracked with Counting Minimums in a Segment Tree 
https://codeforces.com//contest/1876/problem/G,2251951,G,1876G,1876,G. Clubstep,There is an extremely hard video game that is one of Chaneka s favourite video games One of the hardest levels in the game is called Clubstep Clubstep consists of n parts numbered from 1 to n Chaneka has practised the level a good amount so currently her familiarity value with each part i is a i After this Chaneka can do several possibly zero attempts on Clubstep In each attempt she dies on one of the n parts If an attempt dies on part p that means it only successfully passes through every part k for all 1 leq k leq p 1 and it does not reach any part k for all p 1 leq k leq n An attempt that dies on part p takes p seconds It is known that Chaneka improves much more on the part she dies on than anything else It is also known that during an attempt Chaneka does not get to practise that much on the parts she does not reach So the effect of an attempt that dies on part p is as follows Chaneka s familiarity value with part p increases by 2 Chaneka s familiarity value with each part k for all 1 leq k leq p 1 increases by 1 There will be q questions For the j th question you are given three integers l j r j and x j Then you are asked to find out the in seconds for Chaneka to make it such that the familiarity value for every part p l j leq p leq r j is at least x j Note that each question is independent so the attempt Chaneka does on a question does not affect the familiarity values of any other questions ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    std::vector<int> f(2 * q);\n    std::vector<i64> val(2 * q);\n    int tot = q;\n    std::iota(f.begin(), f.end(), 0);\n    \n    std::vector<i64> ans(q);\n    std::vector<std::vector<std::pair<int, int>>> add(n);\n    std::vector<std::vector<int>> del(n);\n    for (int i = 0; i < q; i++) {\n        int l, r, x;\n        std::cin >> l >> r >> x;\n        l--, r--;\n        add[r].emplace_back(x, i);\n        del[l].push_back(i);\n    }\n    \n    auto find = [&](auto self, int x) -> int {\n        if (f[x] == f[f[x]]) {\n            return f[x];\n        }\n        auto y = self(self, f[x]);\n        val[x] += val[f[x]];\n        f[x] = y;\n        return f[x];\n    };\n    \n    auto get = [&](i64 x) {\n        find(find, x);\n        i64 ans = val[x];\n        if (x != f[x]) {\n            ans += val[f[x]];\n        }\n        return ans;\n    };\n    \n    auto merge = [&](int &x, int y) {\n        int z = tot++;\n        f[x] = z;\n        f[y] = z;\n        x = z;\n    };\n    \n    std::map<int, int> mp;\n    for (int i = n - 1; i >= 0; i--) {\n        for (auto [x, j] : add[i]) {\n            if (mp.contains(x)) {\n                merge(mp[x], j);\n            } else {\n                mp[x] = j;\n            }\n        }\n        for (auto it = mp.upper_bound(a[i]); it != mp.end(); it = mp.erase(it)) {\n            auto [x, j] = *it;\n            int y = (x + a[i]) / 2;\n            val[j] += 1LL * (i + 1) * (x - y);\n            if (mp.contains(y)) {\n                merge(mp[y], j);\n            } else {\n                mp[y] = j;\n            }\n        }\n        for (auto j : del[i]) {\n            ans[j] = get(j);\n        }\n    }\n    \n    for (int i = 0; i < q; i++) {\n        std::cout << ans[i] << ""\\n"";\n    }\n    \n    return 0;\n}\n']",,,"['binary search', 'brute force', 'data structures', 'greedy', 'trees']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\G. Clubstep.json,https://codeforces.com//blog/entry/121200,Let s try to solve a single query in It is clear that in the optimal strategy we do not want to do any attempts that die on parts to the left of or to the right of There are two cases If then we can ignore index and solve the query for If then it is optimal to do attempts that die on part This takes seconds and will make all indices from to increase by After doing that it is equivalent to ignoring index and solving the query for For now let s ignore and focus on For some pair there are two cases it can recurse into We mainly care about the second case since it is the only one that contributes to the total time For some pair of a query we can turn it into where is the rightmost index with For some pair with we can see it as the pair recursing immediately to where is the rightmost index with We want to maintain all important pairs that are needed to answer all queries Two pairs with the same values of and that comes from different queries can be treated as the same pair Let s imagine a process to calculate all important pairs To do this we iterate from to while maintaining all of the current important values of including the ones not bigger than Each iteration we just modify the values of from the previous iteration For each we first add new values of for all queries with this current value of Then the important pairs for this value of are all current values of that are greater than And those values of are the values of which will get updated changed into for the next iteration If more than one value of updates into the same value they merge and the number of values decreases Using the logic of the process above it can be obtained that the total number of important pairs is Notice that the number of important pairs is about equal to the number of updates to the value of in all iterations Let s calculate the total number of updates Instead of looking at the values of that we maintain let s sort those values and look at the gaps between adjacent values For a value of the value of lies in one of the gaps Then that gap and all gaps located to the right of it in the number line will get updated The gap that contains can change arbitrarily but each gap that is to the right of that gap will have its length divided by either floored or ceilinged This means each gap can only have updates before having a length of Then its length can get ceilinged multiple times before getting floored to When its length becomes the two values at the endpoints of the gap will merge It may look like there can be many updates because a length of can be ceilinged multiple times However for every gap having its length divided by in an iteration the case where a length of gets ceilinged cannot happen on two adjacent gaps so if there are gaps updated that particular case can only happen on gaps That means the total number of updates is about two times the total number of times a gap gets its length decreased plus the total number of gaps that contains Therefore the total number of important pairs is Knowing that we can calculate all important pairs quickly using a stack and a priority queue The stack maintains the current values of that have already been updated at least once The priority queue only maintains new values of that have not been updated yet In each iteration we only process several values at the top of the stack and at the top of the priority queue then each of those gets pushed into the stack with their new values without changes in their order The total number of operations in the stack is equal to the number of important pairs but the total number of changes in the priority queue is only equal to the number of queries So the total complexity of this is While calculating all important pairs we can simultaneously construct a tree of pairs where the parent of each pair is its corresponding pair We can solve each query using a simple binary lifting in the tree but that would be too slow since there are vertices Instead we can do a DFS traversal from the root while maintaining a stack of the values of in the DFS recursion Solving a query in a vertex is just doing a binary search in the stack So the total complexity of answering all queries is Time complexity 
https://codeforces.com//contest/759/problem/C,89812,C,759C,759,C. Nikita and stack,Nikita has a stack A stack in this problem is a data structure that supports two operations Operation puts an integer on the top of the stack and operation deletes the top integer from the stack i e the last added If the stack is empty then the operation does nothing Nikita made operations with the stack but forgot them Now Nikita wants to remember them He remembers them one by one on the th step he remembers an operation he made th In other words he remembers the operations in order of some permutation After each step Nikita wants to know what is the integer on the top of the stack after performing the operations he have already remembered in the corresponding order Help him ,"['#include <cstdio>\n#include <algorithm>\n\nconst int o = 1 << 17;\n\nusing namespace std;\n\nstruct node {\n\tint sum, min;\n} IT[1 << 18];\nint a[100001];\n\nint main() {\n\tint i, j, k, l, n, t;\n\tscanf(""%d"", &n);\n\twhile (n--) {\n\t\tscanf(""%d%d"", &i, &j);\n\t\tif (j) {\n\t\t\tscanf(""%d"", &k);\n\t\t\ta[i] = k;\n\t\t\tl = i + o;\n\t\t\tIT[l].sum = 1;\n\t\t\twhile (l >>= 1) {\n\t\t\t\tIT[l].sum = IT[l << 1].sum + IT[l << 1 | 1].sum;\n\t\t\t\tIT[l].min = min(IT[l << 1].min, IT[l << 1].sum + IT[l << 1 | 1].min);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tl = i + o;\n\t\t\tIT[l].sum = -1;\n\t\t\twhile (l >>= 1) {\n\t\t\t\tIT[l].sum = IT[l << 1].sum + IT[l << 1 | 1].sum;\n\t\t\t\tIT[l].min = min(IT[l << 1].min, IT[l << 1].sum + IT[l << 1 | 1].min);\n\t\t\t}\n\t\t}\n\t\tl = 1;\n\t\tt = IT[1].sum - 1;\n\t\tif (IT[1].min > t) {\n\t\t\tputs(""-1"");\n\t\t\tcontinue;\n\t\t}\n\t\twhile (l < o) {\n\t\t\tif (IT[l << 1].sum + IT[l << 1 | 1].min > t) l = l << 1;\n\t\t\telse {\n\t\t\t\tt -= IT[l << 1].sum;\n\t\t\t\tl = l << 1 | 1;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", a[l - o]);\n\t}\n}']",,,"['binary search', 'data structures']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Nikita and stack.json,https://codeforces.com//blog/entry/49946,Hint 1 look at the operations in the reverse order Let s count the balance for each prefix i e the difference between the number of push x operations and the number of pop operations Hint 2 Now we have to find the first operation that makes balance positive This can be done using segment tree Solution Let s reverse the order of operations Now we can see that on the top of the stack will be the first integer added with push x such that the number of pop operations and the number of push x operations before this operation is equal if there is one Let s keep for each position a value called balance the number of push x operations minus the number of pop operations before and including this position To find the answer we should find the first position with posivive balance When we add an operation we should add 1 or 1 to all posisions starting with the position of the operation depending on the type of the operation To cope with the operations quickly we can store the balance in a segment tree The addition is done with lazy propogation finding the first position with positive balance can be done in two ways First way is to perform binary search on the answer and then query the segment tree for maximim on some prefix The compexity is per query then The other way is to walk down the tree always moving to the leftmost son with positive maximum When we reach the leaf the position of this leaf is the answer The complexity is per query 
https://codeforces.com//contest/1471/problem/A,855308,A,1471A,1471,A. Strange Partition,You are given an array a of length n and an integer x You can perform the following operation as many times as you would like possibly zero replace two adjacent elements of the array by their sum For example if the initial array was 3 6 9 in a single operation one can replace the last two elements by their sum yielding an array 3 15 or replace the first two elements to get an array 9 9 Note that the size of the array decreases after each operation The of an array b b 1 ldots b k is defined as sum i 1 k left lceil frac b i x right rceil which means that we divide each element by x round it up to the nearest integer and sum up the resulting values For example if x 3 and the array is 4 11 6 the beauty of the array is equal to left lceil frac 4 3 right rceil left lceil frac 11 3 right rceil left lceil frac 6 3 right rceil 2 4 2 8 Please determine the minimum and the maximum beauty you can get by performing some operations on the original array ,"['// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - \'0\', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + \'0\');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\nint main() {\n  int T=read();\n  while(T--){\n    int n=read(),k=read();\n    ll ans1=0,ans2=0;\n    rep(i,1,n){\n      int x=read();\n      ans1+=(x+k-1)/k;\n      ans2+=x;\n    }\n    ans2=(ans2+k-1)/k;\n    printf(""%lld %lld\\n"",ans2,ans1);\n  }\n  return 0;\n}']",,,"['greedy', 'math', 'number theory']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Strange Partition.json,https://codeforces.com//blog/entry/86464,Note that It means that the maximal sum is attained if we do not apply any operations and the minimal one is attained if we replace all the element with a single one equal to the sum of all elements 
https://codeforces.com//contest/1862/problem/E,2177632,E,1862E,1862,E. Kolya and Movie Theatre,Recently Kolya found out that a new movie theatre is going to be opened in his city soon which will show a new movie every day for n days So on the day with the number 1 le i le n the movie theatre will show the premiere of the i th movie Also Kolya found out the schedule of the movies and assigned the entertainment value to each movie denoted by a i However the longer Kolya stays without visiting a movie theatre the larger the decrease in entertainment value of the next movie That decrease is equivalent to d cdot cnt where d is a predetermined value and cnt is the number of days since the last visit to the movie theatre It is also known that Kolya managed to visit another movie theatre a day before the new one opened the day with the number 0 For example if d 2 and a 3 2 5 4 6 then by visiting movies with indices 1 and 3 cnt value for the day 1 will be equal to 1 0 1 and cnt value for the day 3 will be 3 1 2 so the total entertainment value of the movies will be a 1 d cdot 1 a 3 d cdot 2 3 2 cdot 1 5 2 cdot 2 2 Unfortunately Kolya only has time to visit Help him create a plan to visit the cinema in such a way that the total entertainment value of all the movies he visits is maximized ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY long long\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e18)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,m,d,a[MAXN];\npriority_queue<TY> q;\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tTY ans=0,sum=0;\n\t\twhile(!q.empty())q.pop();\n\t\tn=qr();m=qr();d=qr();\n\t\tFor(i,1,n){\n\t\t\ta[i]=qr();\n\t\t\tif(a[i]>0){\n\t\t\t\tif(q.size()<m||-q.top()<a[i]){\n\t\t\t\t\tq.push(-a[i]);sum+=a[i];\n\t\t\t\t\tif(q.size()>m)sum-=-q.top(),q.pop();\n\t\t\t\t}\n\t\t\t}ans=max(ans,sum-i*d);\n\t\t}qw(ans,\'\\n\');\n\t}\n    return 0;\n}']",,,"['constructive algorithms', 'data structures', 'greedy']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Kolya and Movie Theatre.json,https://codeforces.com//blog/entry/119715,Let s notice that if we visit the cinema on days with numbers the total entertainment value of the visited movies will be equal to Thus it is sufficient to iterate over the day when Kolya will visit the cinema for the last time and maintain the maximum non negative elements on the prefix This can be done for example using std multiset The total complexity of the solution will be 
https://codeforces.com//contest/22/problem/B,100,B,22B,22,B. Bargaining Table,Bob wants to put a new bargaining table in his office To do so he measured the office room thoroughly and drew its plan Bob s office room is a rectangular room meters Each square meter of the room is either occupied by some furniture or free A bargaining table is rectangular and should be placed so that its sides are parallel to the office walls Bob doesn t want to change or rearrange anything that s why all the squares that will be occupied by the table should be initially free Bob wants the new table to sit as many people as possible thus its perimeter should be maximal Help Bob find out the maximum possible perimeter of a bargaining table for his office ,"[""#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main(){\n   \n    int n,m;\n    cin>>n>>m;\n    int a[50][50];\n    int b[50][50];\n    char ch;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            cin>>ch;\n            a[i][j]=ch-'0';\n            b[i][j]=a[i][j];\n        }\n    }\n    for(int i=1; i<m; i++){\n        b[0][i]+=b[0][i-1];\n    }\n    for(int i=1; i<n; i++){\n        b[i][0]+=b[i-1][0];\n    }\n    for(int i=1; i<n; i++){\n        for(int j=1; j<m; j++){\n            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n        }\n    }\n    int mx=0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            for(int x=i; x<n; x++){\n                for(int y=j; y<m; y++){\n                    int t=b[x][y];\n                    if(i-1>=0){\n                        t-=b[i-1][y];\n                    }\n                    if(j-1>=0){\n                        t-=b[x][j-1];\n                    }\n                    if(i-1>=0 && j-1>=0){\n                        t+=b[i-1][j-1];\n                    }\n                    if(t==0){\n                        mx=max(mx,2*(x-i+1+y-j+1));\n                    }\n                }\n            }\n        }\n    }\n    cout<<mx;\n    return 0;\n}""]",,,"['brute force', 'dp']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Bargaining Table.json,https://codeforces.com//blog/entry/507,In this problem one should find the maximal perimeter of a rectangle that contains no 1 Define these rectangles correct To solve a problem you are to check each possible rectangle for correctness and calculate its perimeter The easiest way to check all rectangles is using 6 nested cycles Using 4 of them you fix the coordinates while other 2 will look for 1 So the complexity is O n m 3 It seems slow but those who wrote such a solution says that it hasn t any problems with TL One may interest in much faster solution Using simple DP solution one can get a solution with an O n m 2 complexity It s clear that rectangle with coordinates x1 y1 x2 y2 is correct if and only if rectangles x1 y1 x2 1 y2 and x1 y1 x2 y2 1 are correct and board x2 y2 0 So each of rectangles can be checked in O 1 and totally there will be O n m 2 operations 
https://codeforces.com//contest/195/problem/B,1420,B,195B,195,B. After Training,After a team finished their training session on Euro football championship Valeric was commissioned to gather the balls and sort them into baskets Overall the stadium has balls and baskets The baskets are positioned in a row from left to right and they are numbered with numbers from to correspondingly The balls are numbered with numbers from to Valeric decided to sort the balls in the order of increasing of their numbers by the following scheme He will put each new ball in the basket with the least number of balls And if he s got several variants he chooses the basket which stands closer to the middle That means that he chooses the basket for which is minimum where is the number of the basket If in this case Valeric still has multiple variants he chooses the basket with the minimum number For every ball print the number of the basket where it will go according to Valeric s scheme Note that the balls are sorted into baskets in the order of increasing numbers that is the first ball goes first then goes the second ball and so on ,"['#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstruct compare\n{\n    int M;\n\n    compare(int M = 0) : M(M) {}\n\n    bool operator()(int a, int b) const\n    {\n        return abs(M + 1 - 2 * a) < abs(M + 1 - 2 * b);\n    }\n};\n\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N, M;\n    cin >> N >> M;\n    vi order(M);\n    for (int i = 0; i < M; i++)\n        order[i] = i + 1;\n    stable_sort(order.begin(), order.end(), compare(M));\n    for (int i = 0; i < N; i++)\n        cout << order[i % M] << \'\\n\';\n\n    return 0;\n}\n']",,,"['data structures', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. After Training.json,https://codeforces.com//blog/entry/4699,In this problem you should carefully implement the given process Firstly note that ball number will be in the same basket as ball number Therefore it is enough to distribute first balls It can be done using two pointers from the middle Alternately put one ball to the left and to the right and shift pointers In only case you should shift left pointer twice in the first moment of time if is odd 
https://codeforces.com//contest/1788/problem/E,1767775,E,1788E,1788,E. Sum Over Zero,You are given an array a 1 a 2 ldots a n of n integers Consider S as a set of segments satisfying the following conditions Each element of S should be in form x y where x and y are integers between 1 and n inclusive and x leq y No two segments in S intersect with each other Two segments a b and c d intersect if and only if there exists an integer x such that a leq x leq b and c leq x leq d For each x y in S a x a x 1 ldots a y geq 0 The length of the segment x y is defined as y x 1 f S is defined as the sum of the lengths of every element in S In a formal way f S sum x y in S y x 1 Note that if S is empty f S is 0 What is the maximum f S among all possible S ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n    int x;\n    scanf(""%d"",&x);\n    return x;\n}\nconst int N=2e5+5;\nint n;\nll s[N],a[N];\nint c[N],f[N];\nvoid add(int p,int v){\n    for(int i=p;i<=n;i+=i&-i)c[i]=max(c[i],v);\n}\nint get(int p){\n    int mx=-1e9;\n    for(int i=p;i;i-=i&-i)mx=max(mx,c[i]);\n    return mx;\n}\nint main(){\n    n=in();\n    for(int i=1;i<=n;i++)s[i]=s[i-1]+in(),a[i]=s[i];\n    sort(a,a+n+1);\n    for(int i=0;i<=n;i++)s[i]=lower_bound(a,a+n+1,s[i])-a+1;\n    n++;\n    for(int i=1;i<=n;i++)c[i]=-1e9;\n    add(s[0],0);\n    for(int i=1;i<n;i++){\n        f[i]=get(s[i])+i;\n        f[i]=max(f[i],f[i-1]);\n        add(s[i],f[i]-i);\n    }\n    cout<<f[n-1]<<endl;\n    return 0;\n}']",,,"['data structures', 'dfs and similar', 'dp']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Sum Over Zero.json,https://codeforces.com//blog/entry/112584,Denote as the prefix sum of For a segment to be an element of should be satisfied Let s denote as the maximum value of the sum of length of segment smaller than in Segment is smaller than if If there is no segment ending at If there is segment in By summing up With this dp we get an solution Now let s try to speed up the dp transition using segment tree First use coordinate compression on since we only see whether one prefix sum is bigger than the other We will maintain a segment tree that stores in position Let s find in order of We can solve by range query on a segment tree So we can solve in for each The entire problem is solved in There is an alternative solution that maintains pair monotonically with a set This solution also runs in 
https://codeforces.com//contest/141/problem/C,747,C,141C,141,C. Queue,In the Main Berland Bank people stand in a queue at the cashier everyone knows his her height and the heights of the other people in the queue Each of them keeps in mind number how many people who are taller than him her and stand in queue in front of him After a while the cashier has a lunch break and the people in the queue seat on the chairs in the waiting room in a random order When the lunch break was over it turned out that nobody can remember the exact order of the people in the queue but everyone remembers his number Your task is to restore the order in which the people stood in the queue if it is possible There may be several acceptable orders but you need to find any of them Also you need to print a possible set of numbers the heights of people in the queue so that the numbers are correct ,"[""#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair< int, int > PRII;\ntypedef pair< double ,double > PRDD;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\n\n#define Size(a) ((int)a.size())\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\n#define x first\n#define y second\n#define p_b push_back\n#define m_p make_pair\n#define oo 1000000000\n#define eps 1e-12\nconst double pi = acos(-1.0);\n\n#define maxn 3000 + 10\n\nint n;\nstruct Peo\n{\n\tstring s;\n\tint a,b;\n}p[maxn];\n\ninline bool cmp( Peo i, Peo j ) { return i.a < j.a; }\n\nint main()\n{\n    int i,j;\n    \n\tcin>>n;\n\tfor( i = 1 ; i <= n ; ++i )\n\t\tcin>>p[i].s>>p[i].a;\n\tsort(p+1,p+n+1,cmp);\n\t\n\tfor( i = 1 ; i <= n ; ++i )\n\t\t{\n\t\t\tif( p[i].a < i )\n\t\t\t\t{\n\t\t\t\t\tfor( j = 1 ; j < i ; ++j )\n\t\t\t\t\t\tif( p[j].b >= i-p[i].a )\n\t\t\t\t\t\t\t++p[j].b;\n\t\t\t\t\tp[i].b = i-p[i].a;\n\t\t\t\t}\n\t\t\telse break;\n\t\t}\n\tif( i > n )\n\t\t{\n\t\t\tfor( i = 1 ; i <= n ; ++i )\n\t\t\t\tcout<<p[i].s<<' '<<p[i].b<<endl;\n\t\t}\n\telse cout<<-1<<endl;\n\t\t\n\treturn 0;\n}\n""]",,,"['constructive algorithms', 'greedy', 'sortings']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Queue.json,https://codeforces.com//blog/entry/3571,Let s sort the pairs namei ai by ascending of ai If there is an index i 0 i n that ai i then answer is 1 Otherwise the answer exists We will iterate through the array of sorted pairs from left to right with supporting of vector of results res Let on the current iteration ai n i then we must transfer the current man in the position ai It can be done in C with one line res insert res begin a i man 
https://codeforces.com//contest/992/problem/B,191472,B,992B,992,B. Nastya Studies Informatics,Today on Informatics class Nastya learned about GCD and LCM see links below Nastya is very intelligent so she solved all the tasks momentarily and now suggests you to solve one of them as well We define a pair of integers if and where denotes the greatest common divisor of and and denotes the least common multiple of and You are given two integers and You are to find the number of pairs of integers such that Note that pairs and are considered different if ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nT gcd(T a, T b) {\n\tT t;\n\twhile (a) {\n\t\tt = a;\n\t\ta = b % a;\n\t\tb = t;\n\t}\n\treturn b;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tll l, r, x, y;\n\tcin >> l >> r >> x >> y;\n\n\tset<ll> d;\n\tfor (ll i=1; i*i<=y; i++) {\n\t\tif (y % i == 0) {\n\t\t\td.insert(i);\n\t\t\td.insert(y / i);\n\t\t}\n\t}\n\n\tll c = 0;\n\n\tfor (ll a : d) {\n\t\tfor (ll b : d) {\n\t\t\tll g = gcd(a, b);\n\t\t\tif (g == x && a*b/g == y && l <= a && a <= r && l <= b && b <= r)\n\t\t\t\tc++;\n\t\t}\n\t}\n\n\tcout << c;\n}']",,,"['math', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Nastya Studies Informatics.json,https://codeforces.com/blog/entry/60083,Let s consider some suitable pair As we can present number as and number as where we know that and Let s consider too that from the restriction from the problem we surely know the restriction for and that is Let s remember we know that because is is Then we can get Dividing by Now if answer equals 0 Else as is surely less than we can just sort out all possible pairs of divisors such that and then to check that and are in the getting above restrictions Complexity of this solution is 
https://codeforces.com//contest/1895/problem/B,2305456,B,1895B,1895,B. Points and Minimum Distance,You are given a sequence of integers a of length 2n You have to split these 2n integers into n pairs each pair will represent the coordinates of a point on a plane Each number from the sequence a should become the x or y coordinate of exactly one point Note that some points can be equal After the points are formed you have to choose a path s that starts from one of these points ends at one of these points and visits all n points at least once The length of path s is the sum of distances between all adjacent points on the path In this problem the distance between two points x 1 y 1 and x 2 y 2 is defined as x 1 x 2 y 1 y 2 Your task is to form n points and choose a path s in such a way that the length of path s is minimized ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<int> A(N*2);\n\trep(i,0,N*2) cin>>A[i];\n\tSo(A);\n\tint ans=0;\n\trep(i,1,N*2) if(i!=N) ans+=A[i]-A[i-1];\n\tcout<<ans<<""\\n"";\n\trep(i,0,N) cout<<A[i]<<"" ""<<A[i+N]<<""\\n"";\n}']",,,"['greedy', 'math', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Points and Minimum Distance.json,https://codeforces.com//blog/entry/122034,Since the order of does not matter let s sort them for convenience Let s treat the resulting path as two one dimensional paths one path and one path The length of the path is equal to the sum of lengths of these two paths If we fix which integers are coordinates and which integers are coordinates it s quite easy to see that it is optimal to place both and in sorted order the length of the path visiting both and should be at least and sorting gives exactly that result the same with coordinates Okay then how do we choose which integers are coordinates and which integers are coordinates The total length of the path will be equal to one of the minimums will be equal to the value of one of the maximums will be equal to the value of so we need to consider the remaining minimum and maximum The minimum coordinate of any type should be less than or equal to at least elements Similarly the maximum coordinate should be greater than or equal to at least elements So the second minimum the minimum which is not is at most the second maximum is at least and the length of the path is at least And it is possible to reach this bound take the first values in as coordinates and the last values as coordinates 
https://codeforces.com//contest/1543/problem/D2,1038889,D2,1543D2,1543,D2. RPD and Rap Sheet  Hard Version ,Every decimal number has a base k equivalent The individual digits of a base k number are called k its Let s define the k itwise XOR of two k its a and b as a b bmod k The k itwise XOR of two base k numbers is equal to the new number formed by taking the k itwise XOR of their corresponding k its The k itwise XOR of two decimal numbers a and b is denoted by a oplus k b and is equal to the decimal representation of the k itwise XOR of the base k representations of a and b All further numbers used in the statement below are in decimal unless specified You have hacked the criminal database of Rockport Police Department RPD also known as the Rap Sheet But in order to access it you require a password You don t know it but you are quite sure that it lies between 0 and n 1 inclusive So you have decided to guess it Luckily you can try at most n times without being blocked by the system But the system is adaptive Each time you make an incorrect guess it changes the password Specifically if the password before the guess was x and you guess a different number y then the system changes the password to a number z such that x oplus k z y Guess the password and break into the system ,"['// Problem: D1. RPD and Rap Sheet (Easy Version)\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/D1\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nint n,k;\nint f(int x,int y)//减\n{\n\tint res=0,base=1;\n\twhile(x||y)\n\t{\n\t\tres+=(x%k+k-y%k)%k*base;\n\t\tbase*=k;\n\t\tx/=k,y/=k;\n\t}\n\treturn res;\n}\nint g(int x,int y)//加\n{\n\tint res=0,base=1;\n\twhile(x||y)\n\t{\n\t\tres+=(x%k+y%k)%k*base;\n\t\tbase*=k;\n\t\tx/=k,y/=k;\n\t}\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tn=read(),k=read();\n\t\tint s=0;\n        bool t=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t{\n\t\t\tint cur;\n            if(t) cur=g(f(0,i),s);\n            else cur=g(i,s);\n\t\t\tprintf(""%lld\\n"",cur);\n\t\t\tfflush(stdout);\n\t\t\ts=f(cur,s),t^=1;//s-cur\n\t\t\tif(read()==1) break;\n\t\t\t//如果i是0，会变成ixor s\n            //printf(""*%lld\\n"",s);\n\t\t}\n\t}\n\treturn 0;\n}']",,,"['brute force', 'constructive algorithms', 'interactive', 'math']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D2. RPD and Rap Sheet  Hard Version .json,https://codeforces.com//blog/entry/92582,Note It is strongly recommended to read the proofs also to completely understand why the solutions work The solutions described for the easy version won t work here because the general itwise operation does not satisfy self inverse property i e In this whole solution we will work in base only and we will convert the numbers to decimal only for I O purpose Notice that any property which is satisfied by its will also be satisfied by base numbers since a base number is nothing but a concatenation of its When we make an incorrect guess the system changes the password to such that Let s denote the th it of by Expanding this according to the definition of itwise XOR for all individual its So let s define another itwise operation Then Now let s extend the solutions of the Easy Version for this version Method 1Before moving to the solution let s see some properties of the operation over its Property 1 Proof Property 2 Proof Solution Let denote the th query Then if is even and if is odd Let s see why this works Claim If the original password was after queries the password becomes if is even and if is odd ProofLet s prove this by induction Base Case So after st query the password becomes Case 1 is evenInduction hypothesis Let the current password after queries be Inductive step is odd So the th query is The new password will be by Property 2 Case 2 is oddInduction hypothesis Let the current password after queries be Inductive step is even So the th query is The new password will be by Property 1 Hence proved by induction Now notice that after queries the password will become if is even or if is odd which will be equal to the th query Hence the problem will be solved after exactly queries Since the problem will be solved after at most queries Method 2Again let s denote the th query by Then Let s see why this works Claim If the original password was after queries the password will be ProofLet s prove this by induction Base Case After the st query which is the password will be Induction hypothesis Let the password after queries be Inductive Step The th query is After queries the password will becomes Hence proved by induction Now notice that after queries the password will become which will be equal to the th query Hence the problem will be solved after exactly queries Since the problem will be solved after at most queries But we are not done yet This solution is which will time out The solution for this isn t as simple as what we did for the Easy version because the operation is neither associative nor commutative So it s time to explore some more properties of these operations Property 3 Proof Property 4 Proof Now let s try to simplify our queries by Property 3 by Property 4 See the pattern You can generalize the th query as if is odd if is even So we will maintain a prefix Negative XOR whose value after queries will be Then if is odd if is even Then update Notes Both the operations and can be implemented naively by converting the decimal numbers to base finding the itwise XOR of the base numbers and finally converting it back to decimal The time complexity for each of these operations will be At any stage the maximum number that we could be dealing with will be non negative and will not exceed as the itwise operations do not add extra its This fits well within the limits of which is The total time complexity of the solution will be 
https://codeforces.com//contest/864/problem/D,124136,D,864D,864,D. Make a Permutation ,Ivan has an array consisting of elements Each of the elements is an integer from to Recently Ivan learned about permutations and their lexicographical order Now he wants to change replace number of elements in his array in such a way that his array becomes a i e each of the integers from to was encountered in his array exactly once If there are multiple ways to do it he wants to find the permutation among them Thus minimizing the number of changes has the first priority lexicographical minimizing has the second priority In order to determine which of the two permutations is lexicographically smaller we compare their first elements If they are equal compare the second and so on If we have two permutations and then is lexicographically smaller if where is the first index in which the permutations and differ Determine the array Ivan will obtain after performing all the changes ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint n;\nint a[200010];\nint b[200010];\nint c[200010];\nint d[200010];\nint e[200010];\nint ans[200010];\nint main()\n{\n\tmemset(c,0,sizeof c);\n\tmemset(e,0,sizeof e);\n\tscanf(""%d"",&n);\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(""%d"",&a[i]);\n\t\tb[i]=a[i];\n\t\tc[a[i]]++;\n\t}\n\tsort(b+1,b+n+1);\n\tint m=unique(b+1,b+n+1)-b-1;\n\tprintf(""%d\\n"",n-m);\n\tint j=1;\n\tint k=0;\n\tfor(i=1;i<=n;i++)\n\t\tif(!c[i])\n\t\t\td[++k]=i;\n\tfor(i=1;i<=n;i++)\n\t\tif(!e[a[i]])\n\t\t{\n\t\t\tif(c[a[i]]==1)\n\t\t\t{\n\t\t\t\tc[a[i]]--;\n\t\t\t\te[a[i]]=1;\n\t\t\t\tans[i]=a[i];\n\t\t\t}\n\t\t\telse if(d[j]<a[i])\n\t\t\t{\n\t\t\t\tans[i]=d[j++];\n\t\t\t\tc[a[i]]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\te[a[i]]=1;\n\t\t\t\tans[i]=a[i];\n\t\t\t\tc[a[i]]--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i]=d[j++];\n\t\t\tc[a[i]]--;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tprintf(""%d "",ans[i]);\n\treturn 0;\n}']",,,"['greedy', 'implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Make a Permutation .json,https://codeforces.com//blog/entry/54765,We will use an array where we will store how many times the numbers from to met in the given array Put all numbers that never occur in the array in a vector we must add this numbers in the array to make a permutation We will add numbers from in ascending order because we want to get lexicographically minimal permutation Let is a pointer on the current number which we need to add on the current move Initially We will iterate through the array Let the current number equals to If we move to the next number in the array If we added not all numbers from and or there already was on the prefix of the array to check it we can use for example boolean array then we put in the current position decrease on one increase and answer on one If we do not change anything on that step we mark that already was on the prefix of the array After that we move to the next number in array 
https://codeforces.com//contest/486/problem/B,17060,B,486B,486,B. OR in Matrix,Let s define logical as an operation on two logical values i e values that belong to the set that is equal to if either or both of the logical values is set to otherwise it is We can define logical of three or more logical values in the same manner where is equal to if some otherwise it is equal to Nam has a matrix consisting of rows and columns The rows are numbered from to columns are numbered from to Element at row and column is denoted as All elements of are either 0 or 1 From matrix Nam creates another matrix of the same size using formula is of all elements in row and column of matrix Nam gives you matrix and challenges you to guess matrix Although Nam is smart he could probably make a mistake while calculating matrix since size of can be large ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 110\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nchar map[maxn][maxn];\nint nRow,nCol,a[maxn][maxn];\nvoid read()\n{\n    cin>>nRow>>nCol;\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            map[i][j]=\'1\';\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n        {\n            scanf(""%d"",&a[i][j]);\n            if(!a[i][j])\n            {\n                for(int k=1;k<=nRow;++k)\n                    map[k][j]=\'0\';\n                for(int k=1;k<=nCol;++k)\n                    map[i][k]=\'0\';\n            }\n        }\n}\nvoid print()\n{\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            if(a[i][j])\n            {\n                int s=0;\n                for(int k=1;k<=nRow;++k)\n                    s+=map[k][j]-\'0\';\n                for(int k=1;k<=nCol;++k)\n                    s+=map[i][k]-\'0\';\n                if(!s)\n                {\n                    printf(""NO\\n"");\n                    return ;\n                }\n            }\n    printf(""YES\\n"");\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            printf(""%c%c"",map[i][j],j<nCol?\' \':\'\\n\');\n}\nint main()\n{\n    read();\n    print();\n    return 0;\n}\n']",,,"['greedy', 'hashing', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. OR in Matrix.json,https://codeforces.com//blog/entry/14678,Hint of this problem is presented in its statement where is equal to if some otherwise it is equal to To solve this problem do 3 following steps Complexity We can implement this algorithm in but it s not neccesary since 
https://codeforces.com//contest/1774/problem/G,1697948,G,1774G,1774,G. Segment Covering,ChthollyNotaSeniorious gives DataStructures a number axis with m distinct segments on it Let f l r be the number of ways to choose an even number of segments such that the union of them is exactly l r and g l r be the number of ways to choose an odd number of segments such that the union of them is exactly l r ChthollyNotaSeniorious asked DataStructures q questions In each query ChthollyNotaSeniorious will give DataStructures two numbers l r and now he wishes that you can help him find the value f l r g l r modulo 998 244 353 so that he wouldn t let her down ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint n, m;\npii a[N];\npii b[N];\nint cntBad[N];\nint par[N][LOG];\nint h[N];\n\nint up(int v, int dh) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((dh >> k) & 1)\n\t\t\tv = par[v][k];\n\treturn v;\n}\nint LCA(int v, int u) {\n\tif (h[v] > h[u]) swap(v, u);\n\tu = up(u, h[u] - h[v]);\n\tif (v == u) return v;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (par[v][k] != par[u][k]) {\n\t\t\tv = par[v][k];\n\t\t\tu = par[u][k];\n\t\t}\n\t}\n\treturn par[v][0];\n}\nbool isPar(int v, int u) {\n\treturn h[v] <= h[u] && up(u, h[u] - h[v]) == v;\n}\n\nint solve(int l, int r) {\n\tint v = lower_bound(a, a + n, mp(l, -1)) - a;\n\tif (v == n || a[v].first != l) return 0;\n\tint u = lower_bound(b, b + n, mp(r, -1)) - b;\n\tif (u == n || b[u].first != r) return 0;\n\teprintf(""go %d %d\\n"", v, u);\n\tif (cntBad[v] != cntBad[u]) return 0;\n\tif (u < v) return 0;\n\tif (v == u) return -1;\n\tif (LCA(v, v + 1) <= u) return 0;\n\tif (isPar(u, v)) return -1;\n\tif (isPar(u, v + 1)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d%d"", &a[i].first, &a[i].second);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (m > 0 && a[i].first == b[m - 1].first) continue;\n\t\twhile(m > 0 && a[i].second <= b[m - 1].second) m--;\n\t\tb[m++] = a[i];\n\t}\n\tn = m;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = b[i];\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""(%d %d)\\n"", a[i].first, a[i].second);\n\tfor (int i = 1; i < n; i++) {\n\t\tassert(a[i - 1].first < a[i].first);\n\t\tassert(a[i - 1].second < a[i].second);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = mp(a[i].second, a[i].first);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tcntBad[i] = cntBad[i - 1];\n\t\tif (a[i].first > a[i - 1].second) cntBad[i]++;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tpar[i][k] = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = lower_bound(a, a + n, mp(a[i].second + 1, -1)) - a;\n\t\tif (v == n) continue;\n\t\tif (cntBad[v] != cntBad[i]) continue;\n\t\teprintf(""par[%d] = %d\\n"", i, v);\n\t\tpar[i][0] = v;\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t\th[i] = h[par[i][0]] + 1;\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tpar[v][k + 1] = par[par[v][k]][k];\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tint ans = solve(l, r);\n\t\tif (ans < 0) ans += 998244353;\n\t\tprintf(""%d\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']",,,"['brute force', 'combinatorics', 'constructive algorithms', 'data structures', 'dp', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Segment Covering.json,https://codeforces.com//blog/entry/110184,SolutionThis picture shows what the segments eventually are like For we can find the lowest such that and construct a tree by linking such and Then the LCA of and will be where the answer becomes 0 So we can get the answer of quickly by simply finding the LCA of two segments the segment starting with if no segment starts with the answer is and the first segment whose is greater than if it do not intersect with the previous segment the answer is And find the segment ending with If it is on the path of the two segments the answer will be Else the answer will be 
https://codeforces.com//contest/1076/problem/C,253927,C,1076C,1076,C. Meme Problem,Try guessing the statement from this picture You are given a non negative integer d You have to find two non negative real numbers a and b such that a b d and a cdot b d ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 1e5 + 7;\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint d;\n\nvoid solve(){\n\tcin >> d;\n\tif(d == 1 || d == 2 || d == 3){\n\t\tputs(""N"");\n\t\treturn;\n\t}\n\t\n\tlong double delta = d * d - 4.0 * d;\n\tlong double b = (d - sqrt(delta)) / 2.0;\n\tlong double a = d - b;\n\tprintf(""Y %.12Lf %.12Lf\\n"", a, b);\n}\n\nint main(){\n//\tios_base::sync_with_stdio(false);\n//\tcin.tie(NULL);\n//\tcout.tie(NULL);\n\n\tint cases;\n\tcin >> cases;\n\twhile(cases--)\n\t\tsolve();\n\treturn 0;\n}\n']",,,"['binary search', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Meme Problem.json,https://codeforces.com/blog/entry/63151,To solve this problem we need to use some math and solve the equation on the paper If then and transforms to or Then where So if then or if there is no answer Since values are small calculating answer in was enough all we need to do is just output answer with sufficient number of digits after the decimal point 
https://codeforces.com//contest/519/problem/E,23227,E,519E,519,E. A and B and Lecture Rooms,The University where A and B study is a set of rooms connected by corridors Overall the University has rooms connected by corridors so that you can get from any room to any other one by moving along the corridors The rooms are numbered from to Every day and B write contests in some rooms of their university and after each contest they gather together in the same room and discuss problems A and B want the distance from the rooms where problems are discussed to the rooms where contests are written to be equal The distance between two rooms is the number of edges on the shortest path between them As they write contests in new rooms every day they asked you to help them find the number of possible rooms to discuss problems for each of the following days ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint n, m, niv[N], p[19][N], nrnod[N];\nvector<int> v[N];\n\nvoid df(int nod, int pp) {\n\n    nrnod[nod] = 1;\n\n    for(vector<int>::iterator it = v[nod].begin(); it != v[nod].end(); ++it) if(*it != pp) {\n        niv[*it] = niv[nod] + 1;\n        p[0][*it] = nod;\n        df(*it, nod);\n\n        nrnod[nod] += nrnod[*it];\n    }\n}\n\nint lca(int a, int b) {\n    if(niv[a] > niv[b])\n        swap(a, b);\n\n    int k;\n    for(k = 18; k >= 0; --k)\n        if(niv[b] - (1<<k) >= niv[a])\n            b = p[k][b];\n\n    for(k = 18; k >= 0; --k)\n    if(p[k][a] != p[k][b]) {\n        a = p[k][a];\n        b = p[k][b];\n    }\n\n    if(a == b)\n        return a;\n    return p[0][a];\n}\n\nint par(int nr, int nod) {\n    int k;\n\n    for(k = 18; k >= 0; --k)\n    if((1<<k) <= nr) {\n        nr -= (1<<k);\n        nod = p[k][nod];\n    }\n\n    return nod;\n}\n\nint main() {\n    int i, j;\n    //freopen(""ttt"", ""r"", stdin);\n\n    cin >> n;\n    for(i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    df(1, 0);\n    for(i = 1; i < 19; ++i)\n        for(j = 1; j <= n; ++j)\n            p[i][j] = p[i - 1][p[i - 1][j]];\n\n    cin >> m;\n\n    for(i = 1; i <= m; ++i) {\n        int lc, a, b;\n        cin >> a >> b;\n\n        if(a == b) {\n            cout << n << ""\\n"";\n            continue;\n        }\n\n        lc = lca(a, b);\n\n        int sum = niv[a] + niv[b] - 2 * niv[lc];\n\n        if(sum % 2 == 1) {\n            cout << ""0\\n"";\n            continue;\n        }\n        else {\n            sum /= 2;\n            if(niv[a] > niv[b])\n                swap(a, b);\n\n\n            int nod = par(sum, b);\n\n            int nrel = nrnod[nod];\n\n            if(nod == lc) {\n                nrel = n;\n                nrel -= nrnod[par(sum - 1, a)];\n            }\n            nrel -= nrnod[par(sum - 1, b)];\n\n            cout << nrel << ""\\n"";\n        }\n    }\n\n    return 0;\n}\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dp', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. A and B and Lecture Rooms.json,https://codeforces.com/blog/entry/16687,In this problem we have to answer to the following queries on tree for given pairs of vertices your program should output number of eqidistand vertices from them Let s denote dist a b as distance between vertices a and b LCA a b as lowest common ancestor of vertices a and b depth a as distance between root of the tree and vertex a size a as size of subtree of vertex a On each picture green nodes are equidistant nodes blue nodes nodes from query Preprocessing Read edges of tree and build data structure for LCA it is more convenient to use binary raise becase we will use it further for other purposes Complexity O NlogN Queries We have to consider several cases for each query 1 a b In that case answer is n 2 dist a b is odd Then answer is 0 3 dist a l dist b l where l LCA a b Find children of l which are ancestors of a and b let s denote them as aa and bb Answer will be n size aa size bb 4 All other cases Assume that depth a depth b Then using binary raise find dist a b 2 th ancestor of a let s denote it as p1 dist a b 2 1 th ancestor of vertex a denote it as p2 Answer will be size p1 size p2 Complexity O logN for each query O MlogN for all queries 
https://codeforces.com//contest/1158/problem/C,343488,C,1158C,1158,C. Permutation recovery,Vasya has written some permutation p 1 p 2 ldots p n of integers from 1 to n so for all 1 leq i leq n it is true that 1 leq p i leq n and all p 1 p 2 ldots p n are different After that he wrote n numbers next 1 next 2 ldots next n The number next i is equal to the minimal index i j leq n such that p j p i If there is no such j let s let s define as next i n 1 In the evening Vasya went home from school and due to rain his notebook got wet Now it is impossible to read some written numbers Permutation and some values next i are completely lost If for some i the value next i is lost let s say that next i 1 You are given numbers next 1 next 2 ldots next n maybe some of them are equal to 1 Help Vasya to find such permutation p 1 p 2 ldots p n of integers from 1 to n that he can write it to the notebook and all numbers next i which are not equal to 1 will be correct ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Testcase {\n  int N;\n  vector<int> nxt;\n  vector<VI> graph;\n  vector<int> vis;\n  vector<int> order;\n\n  bool Topo(int v) {\n    vis[v] = 1;\n    for (int s : graph[v]) {\n      debug(v, s);\n      if (vis[s] == 1) { return false; }\n      if (vis[s] == 0) {\n        if (!Topo(s)) { return false; }\n      }\n    }\n    vis[v] = 2;\n    order.PB(v);\n    return true;\n  }\n\n  void Run() {\n    cin >> N;\n    nxt.resize(N);\n    for (int &v : nxt) { cin >> v; --v; }\n\n    graph.resize(N + 1);\n\n    vector<int> max_stack{N};\n    for (int i = N - 1; i >= 0; --i) {\n      const int where = nxt[i];\n      if (where >= 0) {\n        graph[i].PB(where);\n        while (max_stack.back() < where) {\n          graph[max_stack.back()].PB(i);\n          max_stack.pop_back();\n        }\n      }\n\n      max_stack.PB(i);\n    }\n    for (int i = 0; i < N; ++i) {\n      graph[i].PB(N);\n    }\n\n    vis.resize(N + 1);\n\n    for (int i = 0; i <= N; ++i) {\n      if (!vis[i]) {\n        if (!Topo(i)) {\n          cout << ""-1\\n"";\n          return;\n        }\n      }\n    }\n\n    vector<int> answer(N + 1);\n    int val = N;\n    for (int x : order) {\n      answer[x] = val--;\n    }\n\n    for (int i = 0; i < N; ++i) {\n      cout << answer[i] + 1 << "" "";\n    }\n    cout << ""\\n"";\n  }\n};\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int T;\n  cin >> T;\n\n  for (int i = 0; i < T; ++i) {\n    Testcase().Run();\n  }\n}\n\n']",,,"['constructive algorithms', 'data structures', 'dfs and similar', 'graphs', 'greedy', 'math', 'sortings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Permutation recovery.json,https://codeforces.com/blog/entry/66993?locale=en,Note that if there are indices i j for which the values nexti and nextj are defined and i j nexti nextj are satisfied then there is no answer Suppose that this is not true and there exists permutation p1 p2 pn Note that since j nexti we get that pi pj otherwise nexti would not be the minimum position in which the number is greater than pi But then pj pi pnexti so nextj is not the minimum position for j Contradiction Now we prove that if for any pair of indices i j such condition is not satisfied then the permutation always exists First let s get rid of nexti 1 If nexti 1 let s say nexti i 1 Note that for any pair i j the condition i j nexti nextj is still not satisfied since nexti i 1 cannot take part in such inequality Consider the following rooted tree with n 1 vertices the vertex with index n 1 will be the root and the ancestor of the vertex with index i will be nexti Since it is always i nexti we get the rooted tree Let s run the depth first search algorithm dfs from the vertex n 1 in this tree In this case we will bypass the sons of each vertex in order from the smaller number to the larger one Let s make some global variable timer n 1 Each time we come to the vertex i we will make pi timer and reduce timer by 1 Note that p1 p2 pn will form a permutation of numbers from 1 to n We prove that this permutation is the answer First of all for all i due to nexti was the ancestor of i we ll go there early and so pnexti pi Let i j nexti We need to prove that we will come to the vertex j later than to the vertex i Note that then the vertex nexti will be a descendant of j in the tree because if you start go from j by next you cannot jump over nexti because otherwise there is an index x for which the inequality i x nexti nextx is satisfied But such pair of indexes i x cannot exist We ll get to j later because the son of nexti which is the ancestor of j will be j and thus i That is we understood what is the criterion of the answer and learned how to quickly build an answer if this criterion is satisfied But we still need to check that this criterion is satisfied This can be done by some simple linear algorithm But we will do this let s make an algorithm for constructing the answer without checking the criterion and find the permutation p Now using the stack and the standard algorithm we find the nexti values for it If they match the given nexti then we have found the answer otherwise let s say that there is no answer If the criterion is satisfied we will find the answer and if not satisfied after checking p we will say there are no answers 
https://codeforces.com//contest/461/problem/B,13281,B,461B,461,B. Appleman and Tree,Appleman has a tree with vertices Some of the vertices at least one are colored black and other vertices are colored white Consider a set consisting of edges of Appleman s tree If Appleman deletes these edges from the tree then it will split into parts Note that each part will be a tree with colored vertices Now Appleman wonders what is the number of sets splitting the tree in such a way that each resulting part will have exactly one black vertex Find this number modulo ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int MAX_N = int(1e5) + 10;\nconst int MOD = int(1e9) + 7;\n\nvoid addIt(int&x, int c) {\n\tx += c;\n\tif (x >= MOD)\n\t\tx -= MOD;\n}\n\nvector<int> E[MAX_N];\nint col[MAX_N];\nint n;\n\nint dp[MAX_N][2]; //white, black\n\nvoid dfs(int u, int par) {\n//\tfor (auto v : E[u])\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint v = *e;\n\t\tif (v != par) {\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n\tvector<int> am(2, 0);\n\tam[col[u]] = 1;\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint v = *e;\n\t\tif (v != par) {\n\t\t\tint*ch = dp[v];\n\t\t\tvector<int> nam(2, 0);\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t//link\n\t\t\t\t\tif (i + j < 2)\n\t\t\t\t\t\taddIt(nam[i + j], 1LL * am[i] * ch[j] % MOD);\n\t\t\t\t\t//cut\n\t\t\t\t\tif (j == 1)\n\t\t\t\t\t\taddIt(nam[i], 1LL * am[i] * ch[j] % MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t\tam = nam;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 2; ++i) {\n\t\tdp[u][i] = am[i];\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint p;\n\t\tscanf(""%d"", &p);\n\t\tE[i].push_back(p), E[p].push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(""%d"", col + i);\n\t}\n\tdfs(0, -1);\n\tcout << dp[0][1] << endl;\n}\n']",,,"['dfs and similar', 'dp', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Appleman and Tree.json,https://codeforces.com/blog/entry/13568,Fill a DP table such as the following bottom up The recursion pseudo code is folloing The answer is DP root 1 UPD The above code calculate the DP table while regarding that the vertex v is white x v 0 in the foreach loop After that the code thinks about the color of vertex v and whether we cut the edge connecting vertex v and its parent or not in if x v 1 DP v 1 DP v 0 else DP v 0 DP v 1 
https://codeforces.com//contest/607/problem/B,43759,B,607B,607,B. Zuma,Genos recently installed the game Zuma on his phone In Zuma there exists a line of gemstones the th of which has color The goal of the game is to destroy all the gemstones in the line as quickly as possible In one second Genos is able to choose exactly one continuous substring of colored gemstones that is a palindrome and remove it from the line After the substring is removed the remaining gemstones shift to form a solid line again What is the minimum number of seconds needed to destroy the entire line Let us remind that the string or substring is called if it reads same backwards or forward In our case this means the color of the first gemstone is equal to the color of the last one the color of the second gemstone is equal to the color of the next to last and so on ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 500;\n\nint n;\nint a[maxn + 5];\nint dp[maxn + 5][maxn + 5];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tscanf(""%d"", &n);\n\tREP(i, 0, n) scanf(""%d"", a + i);\n\tREP(i, 0, n + 1) dp[i][i] = 0;\n\tREP(l, 1, n + 1)\n\t\tREP(i, 0, n - l + 1)\n\t\t{\n\t\t\tint j = i + l;\n\t\t\tdp[i][j] = oo;\n\t\t\tif (a[i] == a[j - 1]) dp[i][j] = dp[i + 1][j - 1];\n\t\t\tREP(k, i, j - 1)\n\t\t\t\tif (a[i] == a[k]) chkmin(dp[i][j], dp[i + 1][k] + dp[k + 1][j] + 1);\n\t\t}\n\tprintf(""%d\\n"", dp[0][n] + 1);\n\treturn 0;\n}\n']",,,['dp'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Zuma.json,https://codeforces.com//blog/entry/22256,We use dp on contiguous ranges to calculate the answer Let D i j denote the number of seconds it takes to collapse some range i j Let us work out a transition for this definition Consider the left most gemstone This gemstone will either be destroyed individually or as part of a non singular range In the first case we destroy the left most gemstone and reduce to the subproblem i 1 j In the second case notice that the left most gemstone will match up with some gemstone to its right We can iterate through every gemstone with the same color as the left most let k be the index of this matching gemstone and reduce to two subproblems i 1 k 1 and k 1 j We can reduce to the subproblem i 1 k 1 because we can just remove gemstones i and k with the last removal of i 1 k 1 We must also make a special case for when the first two elements in a range are equal and consider the subproblem i 2 j 
https://codeforces.com//contest/1099/problem/F,278506,F,1099F,1099,F. Cookies,Mitya and Vasya are playing an interesting game They have a rooted tree with n vertices and the vertices are indexed from 1 to n The root has index 1 Every other vertex i ge 2 has its p i and vertex i is called a of vertex p i There are some cookies in every vertex of the tree there are x i cookies in vertex i It takes exactly t i time for Mitya to eat cookie in vertex i There is also a chip which is initially located in the root of the tree and it takes l i time to move the chip along the edge connecting vertex i with its parent Mitya and Vasya take turns playing Mitya goes first Mitya moves the chip from the vertex where the chip is located to one of its children Vasya can remove an edge from the vertex where the chip is located to one of its children Vasya can also decide to skip his turn Mitya can stop the game at any his turn Once he stops the game he moves the chip up to the root eating some cookies along his way Mitya can decide how many cookies he would like to eat in every vertex on his way The total time spent on descend ascend and eating cookies should not exceed T Please note that in the end of the game the chip is always located in the root of the tree Mitya can not leave the chip in any other vertex even if he has already eaten enough cookies he must move the chip back to the root and every move from vertex v to its parent takes l v time Find out what is the maximum number of cookies Mitya can eat regardless of Vasya s actions ,"['#include <bits/stdc++.h>\n#define endl \'\\n\'\n\n//#pragma GCC optimize (""O3"")\n//#pragma GCC target (""sse4"")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\nconst int MAXV = (int)1e6 + 42;\n\nint64_t tr[4 * MAXN];\nint64_t cnt[4 * MAXN];\n\nvoid add(int pos, int64_t cnt, int64_t val, int l, int r, int idx)\n{\n\tif(pos < l || pos > r) return;\n\tif(l == r)\n\t{\n\t\ttr[idx] += val * cnt;\n\t\t::cnt[idx] += cnt;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) >> 1;\n\tadd(pos, cnt, val, l, mid, 2 * idx + 1);\n\tadd(pos, cnt, val, mid + 1, r, 2 * idx + 2);\n\n\ttr[idx] = tr[2 * idx + 1] + tr[2 * idx + 2];\n\t::cnt[idx] = ::cnt[2 * idx + 1] + ::cnt[2 * idx + 2];\n}\n\nint64_t query(int64_t X, int l, int r, int idx)\n{\n\tif(l == r) \n\t{\n\t\tint64_t can = min(cnt[idx], X / l);\n\t\treturn can;\n\t}\n\n\tint mid = (l + r) >> 1;\n\tif(tr[2 * idx + 1] <= X) return cnt[2 * idx + 1] + query(X - tr[2 * idx + 1], mid + 1, r, 2 * idx + 2);\n\treturn query(X, l, mid, 2 * idx + 1);\n}\n\nint64_t T;\n\nvoid add(int64_t cnt, int64_t v) { add(v, cnt, v, 1, MAXV, 0); }\nvoid rem(int64_t cnt, int64_t v) { add(v, -cnt, v, 1, MAXV, 0); }\nint64_t query(int64_t I) { return query(I, 1, MAXV, 0); }\n\nint n;\nint x[MAXN], t[MAXN];\nvector<pair<int, int64_t> > adj[MAXN];\n\nvoid read()\n{\n\tcin >> n >> T;\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tfor(int i = 1; i <= n; i++) cin >> t[i];\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tint par;\n\t\tint64_t l;\n\t\tcin >> par >> l;\n\t\tadj[par].pb({i, l});\n\t}\n}\n\nint64_t value[MAXN];\n\nvoid dfs1(int u, int64_t Len = 0)\n{\n\tadd(x[u], t[u]);\n\tvalue[u] = query(T - 2ll * Len);\n\n\tfor(auto e: adj[u])\n\t\tdfs1(e.first, Len + e.second);\n\n\trem(x[u], t[u]);\n}\n\nint64_t dfs2(int u)\n{\n\tint64_t ret = value[u];\n\tvector<int64_t> lis;\n\tfor(auto e: adj[u])\n\t\tlis.pb(dfs2(e.first));\n\n\tif(!lis.empty())\n\t{\n\t\tsort(ALL(lis));\n\t\tlis.pop_back();\n\t\tif(!lis.empty())\n\t\t\tchkmax(ret, lis.back());\t\t\t\n\t}\n\n\treturn ret;\n}\n\nvoid solve()\n{\n\tdfs1(1);\n\t\n\tint64_t answer = value[1];\n\tfor(auto e: adj[1])\n\t\tchkmax(answer, dfs2(e.first));\n\t\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dp', 'games', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Cookies.json,https://codeforces.com/blog/entry/64331,If Mitya moves the chip to vertex during the game and then moves it back to the root he will have exactly time to eat cookies Let s denote the maximum number of cookies he can eat during this time by Let s first focus on what to do next assuming we have already computed We can use DFS to compute the maximum number of cookies Mitya can eat if he finishes the game in the subtree of vertex vertex itself included Let and be the indices of two children of vertex with maximum value among its children It s simple to compute In case vertex is a leaf since we can not move any further In case vertex is a root of the tree we have two choices either stop the game or go to the child with the maximum value of which means in this case Otherwise if we re in the vertex Vasya can remove an edge to any child of vertex and clearly he would remove the one with maximum value of meaning he would remove the edge from to This means because we can also decide to stop the game in vertex The only thing left now is how to compute values efficiently We can do it with another DFS while traversing the tree for vertex we maintain the pairs for all vertices on the path from the root to vertex Clearly Mitya would prefer to eat the cookies that he can eat quickly so we maintain these vertices ordered by in increasing order and to compute the answer for vertex we just eat the cookies from fastest to slowest until we run out of time To do it efficiently one can use their favourite data structure BIT Segment Tree Treap while traversing the tree which leads to solution 
https://codeforces.com//contest/1304/problem/F2,540883,F2,1304F2,1304,F2. Animal Observation  hard version ,k Gildong loves observing animals so he bought two cameras to take videos of wild animals in a forest The color of one camera is red and the other one s color is blue Gildong is going to take videos for n days starting from day 1 to day n The forest can be divided into m areas numbered from 1 to m He ll use the cameras in the following way On every odd day 1 st 3 rd 5 th bring the red camera to the forest and record a video for 2 days On every even day 2 nd 4 th 6 th bring the blue camera to the forest and record a video for 2 days If he starts recording on the n th day with one of the cameras the camera records for only one day Each camera can observe k consecutive areas of the forest For example if m 5 and k 3 he can put a camera to observe one of these three ranges of areas for two days 1 3 2 4 and 3 5 Gildong got information about how many animals will be seen in each area on each day Since he would like to observe as many animals as possible he wants you to find the best way to place the two cameras for n days ,"['#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N , M , K , dp[53][20003] , sum[503][20003];\n\nint main(){\n\tcin>>N>>M>>K;\n\tfor(int i = 1 ; i <= N ; ++i)\n\t\tfor(int j = 1; j <= M ; ++j){\n\t\t\tcin>>sum[i][j]; sum[i][j] += sum[i][j -1 ];\n\t\t}\n\tmemset(dp , -0x1f , sizeof(dp));\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) dp[1][i] = sum[1][i + K - 1] - sum[1][i - 1] + sum[2][i + K - 1] - sum[2][i - 1];\n\tfor(int i = 2 ; i <= N ; ++i){\n\t\tdeque < int > q;\n\t\tfor(int j = 1 ; j <= K && j <= M - K + 1 ; ++j){\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][j] + sum[i][j - 1]) q.pop_back();\n\t\t\tq.push_back(j);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] + sum[i][q.front() - 1] - sum[i][j - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j + K <= M - K + 1){\n\t\t\t\tint t = j + K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][t] + sum[i][t - 1]) q.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tq.clear();\n\t\tfor(int j = 1 ; j <= M - K + 1 && j <= K ; ++j){\n\t\t\tint t = M - K + 2 - j;\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\tq.pop_back();\n\t\t\tq.push_back(t);\n\t\t}\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] - sum[i][q.front() + K - 1] + sum[i][j + K - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j - K > 0){\n\t\t\t\tint t = j - K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\t\tq.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tfor(int j = 1 ; j <= M - K + 1; ++j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j + K <= M - K + 1) dp[i][j + K] = max(dp[i][j + K] , mx + sum[i][j + K + K - 1] - sum[i][j + K - 1]);\n\t\t}\n\t\tmx = 0;\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j - K > 0) dp[i][j - K] = max(dp[i][j - K] , mx + sum[i][j - 1] - sum[i][j - K - 1]);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j)\n\t\t\tdp[i][j] += sum[i + 1][j + K - 1] - sum[i + 1][j - 1];\n\t}\n\tint mx = 0;\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) mx = max(mx , dp[N][i]);\n\tcout << mx;\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'greedy']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F2. Animal Observation  hard version .json,https://codeforces.com//blog/entry/73934,We can further advance the idea we used in F1 to reduce the time complexity Let s generalize all three cases we discussed in F1 Let s make a lazy segment tree supporting range addition update and range maximum query Each node represents the maximum value of minus the sum of the animals appearing on the th day in the intersected area in the corresponding interval Then we can add to the maximum value of the segment tree to determine For the th day we insert in the respective index of the segment tree for all initially Now to determine for each we want to subtract from the segment tree for all But it is infeasible to do this and add them back for every single s that has intersected areas Here we can use sliding window technique to improve it To determine we can manually subtract the first elements of from the segment tree like above Let s assume that we re done with determining When we move on to determining we can see that is no longer in the range and thus should be added back to the segment tree Precisely all s where is within range are affected by this and must be added with Similarly is now in the range and thus should be subtracted from all s where is within range Each range update takes time and this happens only two times for determining each The initial work takes time but it happens only once for each day Therefore it takes time for each day and time in total It turns out that it s even possible without the segment tree Of course is intended to pass so you don t really need to implement this to solve the problem Instead of segment tree we ll use monotonic queue structure the core idea for convex hull trick to have the values in decreasing order from front to back If you don t know what monotonic queue is make sure you understand it first You can read about it here We ll do basically the same thing we did for solution but there are two major differences First we ll slide the window two times one from left to right and the other one from right to left Second we ll only consider the values where the range of their indices intersects with the window but only a part of them We ll see how it works when sliding the window from left to right then we can also do it in reverse direction We ll only consider all where is within range In other words we only consider it when the intersected area is a prefix of the window This means when we re about to determine in fact the actual value will be is inserted into the queue and is removed from the queue Now let s see how the real values in the queue are changed while sliding the window Since we ll only add the same value to all elements in the queue every time we slide the window the order of the elements won t be changed thus maintaining the monotone queue structure However we don t actually need to perform the add action simply because we can always calculate it in time by calculating the sum of the animals between the index of that element inclusive and the window exclusive So to the real value at the front of the queue we can add to determine The exact same thing can be done in the reversed way too Now let s take back the prefix and suffix max we discussed in F1 so that we can check the cases when they do not intersect We can see that each of these operations can be done in for each day Therefore the whole process is performed in time 
https://codeforces.com//contest/679/problem/B,61895,B,679B,679,B. Bear and Tower of Cubes,Limak is a little polar bear He plays by building towers from blocks Every block is a cube with positive integer length of side Limak has infinitely many blocks of each side length A block with side has volume A tower consisting of blocks with sides has the total volume Limak is going to build a tower First he asks you to tell him a positive integer the required total volume of the tower Then Limak adds new blocks greedily one by one Each time he adds the biggest block such that the total volume doesn t exceed Limak asks you to choose not greater than Also he wants to maximize the number of blocks in the tower at the end however he still behaves greedily Secondarily he wants to maximize Can you help Limak Find the maximum number of blocks his tower can have and the maximum that results this number of blocks ,"['#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#define pli pair<long long,int>\nusing namespace std;\nint D[1010000], res, T[1010000], P[1010000];\nlong long m;\npli Get(long long m){\n    if(m<=1000000){\n        return pli(P[m],T[m]);\n    }\n    double tt = pow((double)m,1.0/3);\n    long long K = (long long)(tt+0.5);\n    while(K*K*K>m) K--;\n    pli t1 = Get(m-K*K*K);\n    pli t2 = Get(3*K*K - 3*K);\n    if(t1.second >= t2.second){\n        return pli(K*K*K + t1.first, t1.second + 1);\n    }\n    return pli((K-1)*(K-1)*(K-1) + t2.first, t2.second + 1);\n}\nint main(){\n    int i, pv = 1;\n    for(i=1;i<=1000000;i++){\n        while(i>=(pv+1)*(pv+1)*(pv+1))pv++;\n        D[i] = 1 + D[i-pv*pv*pv];\n    }\n    scanf(""%lld"",&m);\n    for(i=1;i<=1000000;i++){\n        T[i] = max(D[i],T[i-1]);\n        if(T[i]==D[i])P[i]=i;\n        else P[i] = P[i-1];\n    }\n    pli tp = Get(m);\n    printf(""%d %lld\\n"",tp.second,tp.first);\n}\n']",,,"['binary search', 'dp', 'greedy']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Bear and Tower of Cubes.json,https://codeforces.com//blog/entry/45310,Let s find the maximum that Then it s optimal to choose that the first block will have side or Let s see why We want to first maximize the number of blocks we can get with new limit Secondarily we want to have the biggest initial You can analyze the described above cases and see that the first block with side must be a worse choice than It s because we start with smaller and we are left with smaller The situation for even smaller side of the first block would be even worse Now you can notice that the answer will be small From of magnitude after one block we get of magnitude So from we go to which means that the answer is The exact maximum answer turns out to be The intended solution is to use the recursion and brutally check both cases taking and taking where is maximum that It s so fast that you can even find in increasing by one code1 
https://codeforces.com//contest/1499/problem/C,928251,C,1499C,1499,C. Minimum Grid Path,Let s say you are standing on the XY plane at point 0 0 and you want to reach point n n You can move only in two directions to the i e horizontally and in the direction that increase your x coordinate or i e vertically and in the direction that increase your y coordinate In other words your path will have the following structure initially you choose to go to the right or up then you go some distance in the chosen direction distances can be chosen independently after that you change your direction from right to up or from up to right and repeat the process You don t like to change your direction too much so you will make no more than n 1 direction changes As a result your path will be a polygonal chain from 0 0 to n n consisting of n line segments where each segment has positive integer length and vertical and horizontal segments alternate Not all paths are equal You have n integers c 1 c 2 dots c n where c i is the cost of the i th segment Using these costs we can define the as the sum of lengths of the segments of this path multiplied by their cost i e if the path consists of k segments k le n then the cost of the path is equal to sum limits i 1 k c i cdot length i segments are numbered from 1 to k in the order they are in the path Find the path of the minimum cost and print its cost ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll C[101010];\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%d"", &N);\n\t\tfor(int i = 1; i <= N; i++) scanf(""%lld"", &C[i]);\n\t\tll s0 = C[1], mn0 = C[1];\n\t\tll s1 = C[2], mn1 = C[2];\n\t\tll ans = (C[1] + C[2]) * N;\n\n\t\tfor(int i = 3; i <= N; i++) {\n\t\t\tif(i & 1) {\n\t\t\t\ts0 += C[i]; mn0 = min(mn0, C[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 += C[i]; mn1 = min(mn1, C[i]);\n\t\t\t}\n\t\t\tans = min(ans, s0 + mn0 * (N - (i + 1) / 2) + s1 + mn1 * (N - i / 2));\n\t\t}\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\treturn 0;\n}']",,,"['brute force', 'data structures', 'greedy', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Minimum Grid Path.json,https://codeforces.com//blog/entry/88812,Suppose we decided to make exactly turns or in other words our path will consist of exactly segments Since we should finish at point and vertical and horizontal segments alternates then it means that and From the other side we should minimize But it means that we can minimize and independently How to minimize if we know that and It s easy to prove that it s optimal to assign all except minimum and assign to this minimum the remaining part In other words to calculate the optimal path consisting of segments we need to know the sum of on odd and even positions among and also minimum among odd and even positions Then we can drive out the answer as a quite easy formula Finally we should iterate over all from to and find the minimum answer among all variants It s easy to recalculate sums and minimums when we make transition form to Complexity is 
https://codeforces.com//contest/1921/problem/A,2427791,A,1921A,1921,A. Square,A square of positive strictly greater than 0 area is located on the coordinate plane with sides parallel to the coordinate axes You are given the coordinates of its corners in random order Your task is to find the area of the square ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll a=inf,b=-inf,c=inf,d=-inf,x,y;\n    for(ll i=1;i<=4;i++){\n        cin>>x>>y;\n        a=min(a,x);\n        b=max(b,x);\n        c=min(c,y);\n        d=max(d,y);\n    }\n    cout<<(b-a)*(d-c);\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']",,,"['greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Square.json,https://codeforces.com//blog/entry/124757,There are many ways to solve this problem the simplest way is as follows Let s find the minimum and maximum coordinate among all the corners of the square The difference of these coordinates will give us the length of the square side After that we can calculate the area of the square as 
https://codeforces.com//contest/2026/problem/A,2985128,A,2026A,2026,A. Perpendicular Segments,You are given a coordinate plane and three integers X Y and K Find two line segments AB and CD such that the coordinates of points A B C and D are integers 0 le A x B x C x D x le X and 0 le A y B y C y D y le Y the length of segment AB is at least K the length of segment CD is at least K segments AB and CD are if you draw lines that contain AB and CD they will cross at a right angle Note that it s necessary for segments to intersect Segments are perpendicular as long as the lines they induce are perpendicular ,"[""#include <bits/stdc++.h>using namespace std;\xa0void solve(){\tint X, Y, K;\tcin >> X >> Y >> K;\tint B = min(X, Y);\tcout << 0 << ' ' << 0 << ' ' << B << ' ' << B << '\\n';\tcout << B << ' ' << 0 << ' ' << 0 << ' ' << B << '\\n';}\xa0int main(){\tios_base::sync_with_stdio(false), cin.tie(nullptr);\tint T;\tcin >> T;\twhile(T--) solve();}""]",,,"['constructive algorithms', 'geometry', 'greedy', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Perpendicular Segments.json,https://codeforces.com//blog/entry/135680,Let s look at all segments with a fixed angle between them and the X axis Let s take the shortest one with integer coordinates and length at least as Let s say that a bounding box of has width and height It s easy to see that a bounding box of segment will have width at least and height at least since the shortest segment will be just the segment rotated at ninety degrees So in order to fit both segments and both and should be at most But if both and then what is the longest segment that can fit in such a bounding box The answer is to set then the length In such a way we found out that must not exceed but if then we can always take the following two segments and where They are perpendicular fit in the allowed rectangle and have length exactly 
https://codeforces.com//contest/400/problem/B,6824,B,400B,400,B. Inna and New Matrix of Candies,Inna likes sweets and a game called the Candy Matrix Today she came up with the new game Candy Matrix 2 Reload The field for the new game is a rectangle table of size Each line of the table contains one cell with a dwarf figurine one cell with a candy the other cells of the line are empty The game lasts for several moves During each move the player should choose and shout Let s go After that all the dwarves from the chosen lines start to move to the right During each second each dwarf goes to the adjacent cell that is located to the right of its current cell The movement continues until one of the following events occurs some dwarf in one of the chosen lines is located in the rightmost cell of his row some dwarf in the chosen lines is located in the cell with the candy The point of the game is to transport all the dwarves to the candy cells Inna is fabulous as she came up with such an interesting game But what about you Your task is to play this game optimally well Specifically you should say by the given game field what minimum number of moves the player needs to reach the goal of the game ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint n, m;\nchar s[1010][1010];\nint main()\n{\n    scanf(""%d %d\\n"", &n, &m);\n    set<int> z;\n    for (int i=0;i<n;++i)\n    {\n        gets(s[i]);\n        int G=-1, S=-1;\n        for (int j=0;j<m;++j) if (s[i][j]==\'G\') G=j; else if (s[i][j]==\'S\') S=j;\n        if (S<G) { puts(""-1""); return 0; }\n        z.insert(S-G);\n    }\n    printf(""%d\\n"", int(z.size()));\n    return 0;\n}\n']",,,"['brute force', 'implementation', 'schedules']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Inna and New Matrix of Candies.json,https://codeforces.com//blog/entry/10755,In the final version of statement we must choose all lines we haven t finish already If it is a string where we have answer Otherwise the answer is the number of distinct distances as one step kills all distances of the minimal length 
https://codeforces.com//contest/1619/problem/E,1234626,E,1619E,1619,E. MEX and Increments,Dmitry has an array of n non negative integers a 1 a 2 dots a n In one operation Dmitry can choose any index j 1 le j le n and increase the value of the element a j by 1 He can choose the same index j multiple times For each i from 0 to n determine whether Dmitry can make the mathrm MEX of the array equal to exactly i If it is possible then determine the minimum number of operations to do it The mathrm MEX of the array is equal to the minimum non negative integer that is not in the array For example the mathrm MEX of the array 3 1 0 is equal to 2 and the array 3 3 1 4 is equal to 0 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,n,a[200005],l,palju,k,eel;\nvector<ll> v;\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n;\n        v.resize(0);\n        for(int i=0; i<n; i++) cin>>a[i];\n        sort(a,a+n);\n        l=0; k=0; palju=0;\n        eel=0;\n        for(int i=0; i<=n; i++){\n            if(eel!=-1) if(i!=0){\n                if(v.size()) eel+=i-1-v[v.size()-1],v.pop_back();\n                else eel=-1;\n            }\n            else eel=0;\n            while(k<n && a[k]==i) palju++,k++,v.push_back(i);\n            if(eel==-1) cout<<eel<<"" "";\n            else cout<<eel+palju<<"" "";\n            palju=0;\n        }\n        cout<<""\\n"";\n    }\n}\n']",,,"['constructive algorithms', 'data structures', 'dp', 'greedy', 'implementation', 'math', 'sortings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. MEX and Increments.json,https://codeforces.com//blog/entry/98159,First let s sort the array Then we will consider its elements in non decreasing order To make MEX equal to you need to increase all zeros To make MEX at least you first need to make MEX at least and then if the number is missing in the array you need to get it If there are no extra values less than then this and all subsequent MEX values cannot be obtained Otherwise you can use the maximum of the extra array values To do this you can use a data structure such as a stack If an element occurs more than once in the array put its extra occurrences on the stack 
https://codeforces.com//contest/213/problem/E,1591,E,213E,213,E. Two Permutations,Rubik is very keen on number permutations A with length is a sequence consisting of different numbers from 1 to Element number of this permutation will be denoted as Furik decided to make a present to Rubik and came up with a new problem on permutations Furik tells Rubik two number permutations permutation with length and permutation with length Rubik must give an answer to the problem how many distinct integers exist such that sequence of length is a subsequence of Sequence is a of sequence if there are such indices that where is the length of sequence and is the length of sequence You are given permutations and help Rubik solve the given problem ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\nconst int maxn = 222222;\n\nunsigned long long p4423[maxn];\n\n#define IX(l, r) (((l) + (r)) | ((l) != (r)))\n\nstruct State {\n    unsigned long long hashValue;\n    int count;\n\n    void assign(int value) {\n        if (value == 0) {\n            hashValue = 0;\n            count = 0;\n        } else {\n            hashValue = value;\n            count = 1;\n        }\n    }\n\n    void assign(const State &l, const State &r) {\n        hashValue = p4423[r.count] * l.hashValue + r.hashValue;\n        count = l.count + r.count;\n    }\n};\n\nState states[maxn * 2];\n\nint n, m;\nint a[maxn], b[maxn];\nint pos[maxn];\n\nvoid update(int l, int r, int p, int v)\n{\n    if (l == r) {\n        if (p == l) {\n            states[IX(l, r)].assign(v);\n        }\n        return;\n    }\n    int m = l + r >> 1;\n    if (p <= m) {\n        update(l, m, p, v);\n    }\n    if (p > m) {\n        update(m + 1, r, p, v);\n    }\n    states[IX(l, r)].assign(states[IX(l, m)], states[IX(m + 1, r)]);\n}\n\nint main()\n{\n    p4423[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        p4423[i] = p4423[i-1] * 4423;\n    }\n    scanf(""%d%d"", &n, &m);\n    unsigned long long targetHash = 0, ones = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(""%d"", a + i);\n        targetHash = targetHash * 4423 + a[i];\n        ones = ones * 4423 + 1;\n    }\n    for (int i = 0; i < m; i++) {\n        scanf(""%d"", b + i);\n        pos[b[i]] = i;\n    }\n    for (int i = 1; i < n; i++) {\n        update(0, m - 1, pos[i], i);\n    }\n    int ret = 0;\n    for (int i = n; i <= m; i++) {\n        update(0, m - 1, pos[i], i);\n        assert(states[IX(0, m - 1)].count == n);\n        if (states[IX(0, m - 1)].hashValue == targetHash) {\n            ret ++;\n        }\n        targetHash += ones;\n        update(0, m - 1, pos[i - n + 1], 0);\n    }\n    printf(""%d\\n"", ret);\n}\n']",,,"['data structures', 'hashing', 'strings']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Two Permutations.json,https://codeforces.com//blog/entry/4982,For given two permutation we will make two another by next transformation New A A i i where New A news permutation A given permutation Lets we get two permutation A and B Now our problem is next how many sub arrays of length n are equals to firs permutation Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element wise equal Further solution hashes but we will use not only modulo 2 64 we will use some big modulos but they must be smaller then 2 32 1 Lets step i 1000003 i Lets F A num 1 step 1 num 2 step 2 num n step n where num i number of the element A i in sorted array If we will compare arrays we can use this function But it can be very big so we will count it by modulos So now our problem is to calculate F function to every subarray Lets look what will change after adding deleting some elent from set some element from num array willnot change and some will become grater after adding and become lower after deleting So we must use some interval tree to recount our F function We need to know sum of step i on some interval of added numbers and count of elements on some interval Uses this information we can simply recount out function Also we must remember that after adding element with coeficinet step i where i n and deleting some previos element our function will become grater that we need So we will multiple hash of first array by 1000003 to avoid this issue 
https://codeforces.com//contest/1506/problem/C,935561,C,1506C,1506,C. Double-ended Strings,You are given the strings a and b consisting of lowercase Latin letters You can do any number of the following operations in any order if a 0 the length of the string a is greater than zero delete the first character of the string a that is replace a with a 2 a 3 ldots a n if a 0 delete the last character of the string a that is replace a with a 1 a 2 ldots a n 1 if b 0 the length of the string b is greater than zero delete the first character of the string b that is replace b with b 2 b 3 ldots b n if b 0 delete the last character of the string b that is replace b with b 1 b 2 ldots b n 1 Note that after each of the operations the string a or b may become empty For example if a and b then you can apply the following sequence of operations delete the first character of the string a Rightarrow a and b delete the first character of the string b Rightarrow a and b delete the first character of the string b Rightarrow a and b delete the last character of the string a Rightarrow a and b delete the last character of the string b Rightarrow a and b For the given strings a and b find the minimum number of operations for which you can make the strings a and b equal Note that empty strings are also equal ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint main(int argc, char** argv) {\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring a,b;\n\t\tcin >> a >> b;\n\t\tint ans=1e9;\n\t\tfor(int l=0;l<=20;l++)\n\t\t{\n\t\t\tstring A="""",B="""";\n\t\t\tfor(int i=0;i<(int)a.size()+1-l;i++)\n\t\t\t{\n\t\t\t\tA="""";\n\t\t\t\tfor(int j=i;j<=i+l-1;j++) A+=a[j];\n\t\t\t\tfor(int i=0;i<(int)b.size()+1-l;i++)\n\t\t\t\t{\n\t\t\t\t\tB="""";\n\t\t\t\t\tfor(int j=i;j<=i+l-1;j++) B+=b[j];\n\t\t\t\t\tif(A==B) ans=min(ans,(int)a.size()+(int)b.size()-l-l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']",,,"['brute force', 'implementation', 'strings']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Double-ended Strings.json,https://codeforces.com//blog/entry/89007,Regarding to the small constraints in this problem you could iterate over how many characters were removed by each type of operation If characters at the beginning and characters at the end are removed from the string then the substring remains where is the length of the string There is also a fast solution to this problem using dynamic programming 
https://codeforces.com//contest/272/problem/B,2623,B,272B,272,B. Dima and Sequence,Dima got into number sequences Now he s got sequence consisting of positive integers Also Dima has got a function which can be defined with the following recurrence Dima wonders how many pairs of indexes are there such that Help him count the number of such pairs ,"['#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,n,m) for(int i = (int)n; i <= (int)m; i++)\n#define FOD(i,n,m) for(int i = (int)n; i >= (int)m; i--)\n\ntypedef long long i64;\ntypedef pair<int, int> PI;\n\n#define sz(v) ((i64)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define bit(n) (1LL<<(i64)(n))\n#define each(i,v) for(__typeof((v).begin()) i = (v).begin(); i != (v).end(); i++)\n\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n\ntemplate<class T> void fmax(T &a, T b) { if (a < b) a = b; }\ntemplate<class T> void fmin(T &a, T b) { if (a > b) a = b; }\n\nint n;\nlong long w[33];\n\nint main() {\n\tcin >> n;\n\trep(i,n) {\n\t\tint x, a = 0;\n\t\tcin >> x;\n\t\trep(j,31) if (x & (1 << j)) a++;\n\t\tw[a]++;\n\t}\n\tlong long a = 0;\n\trep(i,33) a += w[i] * (w[i] - 1) / 2;\n\tcout << a << endl;\n}\n\n']",,,"['implementation', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Dima and Sequence.json,https://codeforces.com//blog/entry/6625,First of all f i is number of ones in binary presentation of number We will repair all numbers to functions of them Now we have to find number of pairs of equal numbers Lets Q i number of numbers with i bits the answer will be sum of values Q i Q i 1 2 for all i 
https://codeforces.com//contest/1873/problem/B,2221680,B,1873B,1873,B. Good Kid,Slavic is preparing a present for a friend s birthday He has an array a of n digits and the present will be the product of all these digits Because Slavic is a good kid who wants to make the biggest product possible he wants to add 1 to exactly one of his digits What is the maximum product Slavic can make ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\n\nvoid solve(){\n    int n; cin >> n;\n    vi a(n); read(a);\n    int mn = *min_element(all(a));\n    for(auto &i: a){\n        if(i == mn){\n            i++;\n            break;\n        }\n    }\n    int ans = 1;\n    for(auto &i: a)ans *= i;\n    cout << ans << ""\\n"";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']",,,"['brute force', 'greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\B. Good Kid.json,https://codeforces.com//blog/entry/120634,Just brute force all possibilties for the digit to increase and check the product each time The complexity is per testcase You can make it faster if you notice that it s always optimal to increase the smallest digit why but it wasn t necessary to pass 
https://codeforces.com//contest/1341/problem/B,599359,B,1341B,1341,B. Nastya and Door,On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length k k ge 3 Nastya was very confused by this present so she decided to break the door throwing it on the mountains Mountains are described by a sequence of heights a 1 a 2 dots a n in order from left to right k le n It is guaranteed that neighboring heights are not equal to each other that is a i ne a i 1 for all i from 1 to n 1 Peaks of mountains on the segment l r from l to r are called indexes i such that l i r a i 1 a i and a i a i 1 It is worth noting that the boundary indexes l and r for the segment For example if n 8 and a 3 1 4 1 5 9 2 6 then the segment 1 8 has only two peaks with indexes 3 and 6 and there are no peaks on the segment 3 6 To break the door Nastya throws it to a segment l l k 1 of consecutive mountains of length k 1 le l le n k 1 When the door touches the peaks of the mountains it breaks into two parts after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains and so on Formally the number of parts that the door will break into will be equal to p 1 where p is the number of peaks on the segment l l k 1 Nastya wants to break it into as many pieces as possible Help her choose such a segment of mountains l l k 1 that the number of peaks on it is maximum If there are several optimal segments Nastya wants to find one for which the value l is minimal Formally you need to choose a segment of mountains l l k 1 that has the maximum number of peaks Among all such segments you need to find the segment that has the minimum possible value l ,"['#include <bits/stdc++.h>\n\nint A[210000];\nint P[210000];\nint pre[210000];\n\nint main() {\n    int T; scanf(""%d"", &T);\n    while (T--) {\n        int N, K;\n        scanf(""%d%d"", &N, &K);\n        for (int i = 0; i < N; ++i)\n            scanf(""%d"", &A[i]);\n        for (int i = 1; i < N - 1; ++i)\n            P[i] = (A[i] > A[i - 1] && A[i] > A[i + 1]);\n        for (int i = 1; i <= N; ++i) pre[i] = pre[i - 1] + P[i - 1];\n        int maxi = 0;\n        for (int i = 0; i + K - 1 < N; ++i)\n            if (pre[maxi + K - 1] - pre[maxi + 1] < pre[i + K - 1] - pre[i + 1])\n                maxi = i;\n        printf(""%d %d\\n"", pre[maxi + K - 1] - pre[maxi + 1] + 1, maxi + 1);\n    }\n}\n']",,,"['greedy', 'implementation']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Nastya and Door.json,https://codeforces.com//blog/entry/76479,Let s make an array consisting of and such that it shows whether the position is a peak on the whole segment To do this we will go through the indices from to and if the conditions and are true then we write in a new array at position After that we calculate the prefix sum in the new array Now the number of peaks in the segment is calculated as so we find out how many peaks in the desired segment not including the boundaries of the segment It remains only to go through all from to and find the leftmost such that as much as possible 
https://codeforces.com//contest/1686/problem/A,1410458,A,1686A,1686,A. Everything Everywhere All But One,You are given an array of n integers a 1 a 2 ldots a n After you watched the amazing film Everything Everywhere All At Once you came up with the following operation In one operation you choose n 1 elements of the array and replace each of them with their arithmetic mean which doesn t have to be an integer For example from the array 1 2 3 1 we can get the array 2 2 2 1 if we choose the first three elements or we can get the array frac 4 3 frac 4 3 3 frac 4 3 if we choose all elements except the third Is it possible to make all elements of the array equal by performing a finite number of such operations ,"['/********************************************************************************************************************\n*                                                                                                                   *\n*   lmqzzz : ILS 21 - 24                                                                                            *\n*                                                                                                                   *\n*                                                                                                                   *\n*       lllllll                                                                                                     *\n*       l:::::l                                                                                                     *\n*       l:::::l                                                                                                     *\n*       l:::::l                                                                                                     *\n*        l::::l    mmmmmmm    mmmmmmm      qqqqqqqqq   qqqqqzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz    *\n*        l::::l  mm:::::::m  m:::::::mm   q:::::::::qqq::::qz:::::::::::::::zz:::::::::::::::zz:::::::::::::::z     *\n*        l::::l m::::::::::mm::::::::::m q:::::::::::::::::qz::::::::::::::z z::::::::::::::z z::::::::::::::z      *\n*        l::::l m::::::::::::::::::::::mq::::::qqqqq::::::qqzzzzzzzz::::::z  zzzzzzzz::::::z  zzzzzzzz::::::z       *\n*        l::::l m:::::mmm::::::mmm:::::mq:::::q     q:::::q       z::::::z         z::::::z         z::::::z        *\n*        l::::l m::::m   m::::m   m::::mq:::::q     q:::::q      z::::::z         z::::::z         z::::::z         *\n*        l::::l m::::m   m::::m   m::::mq:::::q     q:::::q     z::::::z         z::::::z         z::::::z          *\n*        l::::l m::::m   m::::m   m::::mq::::::q    q:::::q    z::::::z         z::::::z         z::::::z           *\n*       l::::::lm::::m   m::::m   m::::mq:::::::qqqqq:::::q   z::::::zzzzzzzz  z::::::zzzzzzzz  z::::::zzzzzzzz     *\n*       l::::::lm::::m   m::::m   m::::m q::::::::::::::::q  z::::::::::::::z z::::::::::::::z z::::::::::::::z     *\n*       l::::::lm::::m   m::::m   m::::m  qq::::::::::::::q z:::::::::::::::zz:::::::::::::::zz:::::::::::::::z     *\n*       llllllllmmmmmm   mmmmmm   mmmmmm    qqqqqqqq::::::qzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz     *\n*                                                   q:::::q                                                         *\n*                                                   q:::::q                                                         *\n*                                                  q:::::::q                                                        *\n*                                                  q:::::::q                                                        *\n*                                                  q:::::::q                                                        *\n*                                                  qqqqqqqqq                                                        *\n*                                                                                                                   *\n********************************************************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define          int    long long\n\n#define           fi    first\n#define           se    second\n#define           pb    push_back\n#define           ep    emplace\n#define           eb    emplace_back\n#define           lb    lower_bound\n#define           ub    upper_bound\n#define       all(x)    x.begin(), x.end()\n#define      rall(x)    x.rbegin(), x.rend()\n#define   uniquev(v)    v.resize(unique(all(v)) - v.begin())\n#define     mem(f,x)    memset(f , x , sizeof(f))\n#define        sz(x)    (int32_t)(x).size()\n#define   rep(i,a,b)    for(int i = a ; i <= b ; i++)\n#define  repp(i,a,b)    for(int i = a ; i < b ; i++)\n#define   per(i,a,b)    for(int i = a ; i >= b ; i--)\n#define  perr(i,a,b)    for(int i = a ; i > b ; i--)\n#define          mxx    *max_element\n#define          mnn    *min_element\n#define    cntbit(x)    __builtin_popcountll(x)\n#define      MASK(x)    ( 1ll << (x) )\n#define          Yes    cout << ""Yes""\n#define          YES    cout << ""YES""\n#define           No    cout << ""No""\n#define           NO    cout << ""NO""\n#define           AA    cout << ""Alice""\n#define           BB    cout << ""Bob""\n\ntemplate <typename T> inline void read (T &x) { bool b = 0; char c; while (!isdigit (c = getchar()) && c != \'-\'); if (c == \'-\') { c = getchar(); b = 1; } x = c - 48; while (isdigit(c = getchar())) {x = x * 10 + (c - 48); } if (b) { x=-x; } }\ntemplate <typename T> inline T min(const T &a, const T &b, const T &c) { return min(a, min(b, c)); }\ntemplate <typename T> inline T max(const T &a, const T &b, const T &c) { return max(a, max(b, c)); }\ntemplate <typename T, typename U> inline void mini(T &a, const U &b) { if(a > b) a = b; }\ntemplate <typename T, typename U> inline void maxi(T &a, const U &b) { if(a < b) a = b; }\n\ntypedef           long double    ld;\ntypedef             long long    ll;\ntypedef       const long long    cll;\ntypedef             const int    cint;\ntypedef        pair<int, int>    ii;\ntypedef  tuple<int, int, int>    iii;\ntypedef         pair<ii, int>    piii;\ntypedef         pair<int, ii>    ipii;\ntypedef         pair<ll, int>    li;\ntypedef          pair<ll, ll>    pll;\ntypedef           vector<int>    vi;\ntypedef            vector<ll>    vll;\ntypedef            vector<vi>    vvi;\ntypedef           vector<vll>    vvl;\ntypedef            vector<ii>    vii;\ntypedef           vector<iii>    viii;\ntypedef           vector<vii>    vvii;\ntypedef           vector<vii>    vvii;\ntypedef         array<int, 3>    ar3;\ntypedef         array<int, 4>    ar4;\ntypedef         array<int, 5>    ar5;\n\nconstexpr   long double PI  =  acos( -1 );\nconstexpr  long double eps  =  1e-9;\nconstexpr     int32_t base  =  277;\nconstexpr     int16_t dr[]  =  {1, 0, -1, 0};\nconstexpr     int16_t dc[]  =  {0, -1, 0, 1};\nconstexpr      int64_t MOD  =  1e9 + 7;\nconstexpr     int32_t MAXN  =  1e6 + 10;\n\nint a[MAXN];\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    rep(i, 1, n) cin >> a[i];\n    ld s = 0;\n    rep(i, 1, n) s += a[i];\n    s /= n;\n    rep(i, 1, n) if(ld(a[i]) == s)\n    {\n        YES;\n        return;\n    }\n    NO;\n}\n\nvoid init()\n{\n\n}\n\n/// TASK\n/// -----------------------------\n#define TASK ""C""\n///------------------------------\n\nvoid gentest()\n{\n    if (fopen(TASK "".inp"", ""r""))\n        freopen(TASK "".inp"",""w"",stdout);\n    srand(time(0));\n//    int n = 0;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    if (fopen(TASK "".inp"", ""r"")) {\n        freopen(TASK "".inp"", ""r"", stdin);\n        freopen(TASK "".out"", ""w"", stdout);\n    }\n//    gentest();\n//    return 0;\n//    init();\n    int32_t TT = 1;\n    cin >> TT;\n    for(int32_t TTT = 1 ; TTT <= TT ; TTT++)\n    {\n        solve();\n        cout << \'\\n\';\n    }\n\n}\n']",,,['greedy'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Everything Everywhere All But One.json,https://codeforces.com//blog/entry/103198,Suppose that we did one operation and not all numbers are equal Let s say that we have numbers and number now with In the next operation we have two options to make operation with numbers or with of and one If we go with the first option we will still have of and one numbers won t change If we go with the second option we will have one number and numbers where So we again are in a state where we have copies of one number and one different number So if after the first operation not all numbers are equal they will never be all equal Therefore it s enough to check each possible operation in which can be clearly optimized to And go watch the movie Everything Everywhere All At Once it s fantastic 
https://codeforces.com//contest/148/problem/B,880,B,148B,148,B. Escape,The princess is going to escape the dragon s cave and she needs to plan it carefully The princess runs at miles per hour and the dragon flies at miles per hour The dragon will discover the escape after hours and will chase the princess immediately Looks like there s no chance to success but the princess noticed that the dragon is very greedy and not too smart To delay him the princess decides to borrow a couple of bijous from his treasury Once the dragon overtakes the princess she will drop one bijou to distract him In this case he will stop pick up the item return to the cave and spend hours to straighten the things out in the treasury Only after this will he resume the chase again from the very beginning The princess is going to run on the straight The distance between the cave and the king s castle she s aiming for is miles How many bijous will she need to take from the treasury to be able to reach the castle If the dragon overtakes the princess at exactly the same moment she has reached the castle we assume that she reached the castle before the dragon reached her and doesn t need an extra bijou to hold him off ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint main()\n{\n    int i,j,k;\n    double v1,v2,t,f,c;\n    cin>>v1>>v2>>t>>f>>c;\n    if (dblcmp(v1-v2)>=0)\n    {\n        puts(""0"");\n        return 0;\n    }\n    double x=0,y=0;\n    int ans=0;\n    x+=v1*t;\n    while (dblcmp(x-c)<0)\n    {\n        double d=x-y;\n        double s=d/(v2-v1);\n        x+=v1*s;\n        y+=v2*s;\n        if (dblcmp(x-c)>=0)\n        {\n            printf(""%d\\n"",ans);\n            return 0;\n        }\n        ans++;\n        x+=v1*(f+y/v2);\n        y=0;\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n        ']",,,"['implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Escape.json,https://codeforces.com//blog/entry/3819,In this problem it was enough to simulate the sequence of events that happen on the line between the cave and the castle My solution focused on two types of evens the dragon is in the cave and sets off after the princess and the dragon and the princess are at the same coordinate in this case it s enough to keep track of time and princess coordinate no need to store dragon s one The first type of event happens for the first time at time T when the princess coordinate is If at this time she has already reached the castle no bijous are needed Otherwise we can start iterating The time between events of first and second type equals the princess coordinate at the moment of first event divided by Adjust the princess coordinate by the distance she will cover during this time and check whether she reached the castle again If she didn t she ll need a bijou increment the number of bijous required The second part of the loop processes the return of the dragon i e the transition from second type of event to the first one The time between the events equals princess new coordinate divided by the dragon s speed plus the time of straightening things out in the treasury Adjust princess coordinate again and return to the start of the loop you don t need to check whether the princess reached the castle at this stage since it doesn t affect the return value The complexity of the algorithm can be estimated practically the number of loop iterations will be maximized when dragon s speed and distance to the castle are maximum and the rest of parameters are minimum This results in about 150 bijous and the same number of iterations You ll also need to check for the case separately the dragon can be old and fat and lazy and he might never catch up with the princess 
https://codeforces.com//contest/786/problem/E,99631,E,786E,786,E. ALT,ALT is a planet in a galaxy called Encore Humans rule this planet but for some reason there s no dog in their planet so the people there are sad and depressed Rick and Morty are universal philanthropists and they want to make people in ALT happy ALT has cities numbered from to and bidirectional roads numbered from to One can go from any city to any other city using these roads There are two types of people in ALT Guardians A guardian lives in a house alongside a road and guards the road Citizens A citizen lives in a house inside a city and works in an office in another city Every person on ALT is either a guardian or a citizen and there s exactly one guardian alongside each road Rick and Morty talked to all the people in ALT and here s what they got There are citizens living in ALT Citizen number lives in city number and works in city number Every day each citizen will go through all roads along the shortest path from his home to his work A citizen will be happy if and only if either he himself has a puppy himself or all of guardians along his path to his work has a puppy he sees the guardian s puppy in each road and will be happy A guardian is always happy You need to tell Rick and Morty the minimum number of puppies they need in order to make all people in ALT happy and also provide an optimal way to distribute these puppies ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=100100;\nVI e[N];\nmap<int,int> id[N];\nint dep[N],p[N][20],g[N][20],n,m,u,v,tot;\n#define LOGN 17\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) v=p[v][i];\n\tif (u==v) return u;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) u=p[u][i],v=p[v][i];\n\treturn p[u][0];\n}\n\nconst int inf=0x20202020;\nint vis[N*20];\ntypedef int flowt;\nnamespace flow {\n\tconst int M=2010000,N=2010000;\n\tint y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\n\tflowt f[M];\n\tint S,T,tot,Tn;\n\tvoid init(int s,int t,int tn) {\n\t\ttot=1; assert(tn<N);\n\t\trep(i,0,tn) fst[i]=0;\n\t\tS=s;T=t;Tn=tn;\n\t}\n\tvoid add(int u,int v,flowt c1,flowt c2=0) {\n\t\ttot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\n\t\ttot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\n\t}\n\tflowt sap() {\n\t\tint u=S,t=1;flowt flow=0;\n\t\trep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\n\t\tq[0]=T;dis[T]=0;pre[S]=0;\n\t\trep(i,0,t) {\n\t\t\tint u=q[i];\n\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (dis[y[j]]>dis[u]+1&&f[j^1]) \n\t\t\t\tq[t++]=y[j],dis[y[j]]=dis[u]+1;\n\t\t}\n\t\trep(i,0,Tn) gap[dis[i]]++;\n\t\twhile (dis[S]<=Tn) {\n\t\t\twhile (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\n\t\t\tif (c[u]) {\n\t\t\t\tpre[y[c[u]]]=c[u]^1;\n\t\t\t\tu=y[c[u]];\n\t\t\t\tif (u==T) {\n\t\t\t\t\tflowt minf=inf;\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\n\t\t\t\t\tflow+=minf;u=S;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(--gap[dis[u]])) break;\n\t\t\t\tint mind=Tn;\n\t\t\t\tc[u]=fst[u];\n\t\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind) \n\t\t\t\t\tmind=dis[y[j]],c[u]=j;\n\t\t\t\tdis[u]=mind+1;\n\t\t\t\tgap[dis[u]]++;\n\t\t\t\tif (u!=S) u=y[pre[u]];\n\t\t\t}\n\t\t}\n\t\tq[0]=T; vis[T]=1; t=1;\n\t\trep(i,0,t) {\n\t\t\tint u=q[i];\n\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (!vis[y[j]]&&f[j^1]) q[t++]=y[j],vis[y[j]]=1;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nvoid dfs(int u,int f) {\n\tp[u][0]=f; dep[u]=dep[f]+1;\n\tif (f) {\n\t\tg[u][0]=id[f][u];\n\t}\n\trep(i,1,LOGN) {\n\t\tp[u][i]=p[p[u][i-1]][i-1];\n\t\tif (p[u][i]!=0) {\n\t\t\tg[u][i]=tot++;\n\t\t\tflow::add(g[u][i],g[u][i-1],inf);\n\t\t\tflow::add(g[u][i],g[p[u][i-1]][i-1],inf);\n\t\t}\n\t}\n\tfor (auto v:e[u]) if (v!=f) {\n\t\tdfs(v,u);\n\t}\n}\nvoid add(int u,int w,int c) {\n\tint x=dep[u]-dep[w];\n\tper(i,0,LOGN) if ((1<<i)<=x) {\n\t\tflow::add(c,g[u][i],inf);\n\t\tint d=x-(1<<i);\n\t\tper(j,0,LOGN) if (d&(1<<j)) u=p[u][j];\n\t\tflow::add(c,g[u][i],inf);\n\t\tbreak;\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\tflow::init(0,0,0);\n\trep(i,1,n) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t\tid[u][v]=id[v][u]=m+i;\n\t}\n\ttot=m+n;\n\tdfs(1,0);\n\tflow::T=tot; flow::Tn=tot+1;\n\trep(i,1,n) flow::add(m+i,tot,1);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\tflow::add(0,i+1,1);\n\t\tint w=lca(u,v);\n\t\tadd(u,w,i+1); add(v,w,i+1);\n\t}\n\tprintf(""%d\\n"",flow::sap());\n\tVI r;\n\trep(i,1,m+1) if (vis[i]) r.pb(i);\n\tprintf(""%d"",SZ(r)); for (auto u:r) printf("" %d"",u); puts("""");\n\tr.clear();\n\trep(i,1,n) if (!vis[m+i]) r.pb(i);\n\tprintf(""%d"",SZ(r)); for (auto u:r) printf("" %d"",u); puts("""");\n}\n']",,,"['data structures', 'flows', 'graphs', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. ALT.json,https://codeforces.com//blog/entry/51163,If and were smaller We construct a bipartite graph For each citizen we consider a vertex in the first part and for each guardian in the tree we consider a vertex in the second part We put an edge between vertex from first part and from second part if and only if path to contains edge Answer to the problem is vertex cover of this graph Time complexity But now that and are great we can t use this approach We will instead build a DAG Like above For each citizen we consider a vertex in the first part and for each guardian in the tree we consider a vertex in the second part Consider the data structure that is used to find LCA of two vertices in the tree keeping th ancestor of each vertex for each We will use that to build the graph For each vertex in the tree and we consider a vertex in the tree this vertex is We ll build a flow network For each we put an edge from to the vertex corresponding to edge guardian connecting and its parent with capacity For each we put an edge from to with capacity and one to with capacity Then for each citizen like the algorithm we used to find the LCA of and when we re going up from a vertex to its th parent we put an edge from vertex corresponding to citizen to with capacity Finally we consider a vertex as source and and sink For each citizen we put an edge from to vertex corresponding to him her with capacity And for each guardian put an edge from vertex corresponding to this edge to with capacity It can be shown that the answer to the original problem is maximum flow of this network Also certificate can be found using a DFS it s exactly like finding a certificate vertex cover in maximum matching approach Since the network contains levels cuts from to with all edges with capacity equal to the total time complexity is where is the number of edges in the network which is so Time complexity 
https://codeforces.com//contest/1519/problem/C,971588,C,1519C,1519,C. Berland Regional,Polycarp is an organizer of a Berland ICPC regional event There are n universities in Berland numbered from 1 to n Polycarp knows all competitive programmers in the region There are n students the i th student is enrolled at a university u i and has a programming skill s i Polycarp has to decide on the rules now In particular the number of members in the team Polycarp knows that if he chooses the size of the team to be some integer k each university will send their k strongest with the highest programming skill s students in the first team the next k strongest students in the second team and so on If there are fewer than k students left then the team can t be formed Note that there might be universities that send zero teams The strength of the region is the total skill of the members of all present teams If there are no teams present then the strength is 0 Help Polycarp to find the strength of the region for each choice of k from 1 to n ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> U(N);\n    vector<int64_t> S(N);\n\n    for (auto &u : U) {\n        cin >> u;\n        u--;\n    }\n\n    for (auto &s : S)\n        cin >> s;\n\n    vector<vector<int64_t>> choices(N + 1);\n\n    for (int i = 0; i < N; i++)\n        choices[U[i]].push_back(S[i]);\n\n    vector<int64_t> skill(N + 1, 0);\n\n    for (int u = 0; u < N; u++) {\n        sort(choices[u].begin(), choices[u].end());\n        int len = int(choices[u].size());\n        vector<int64_t> prefix_sum(len + 1, 0);\n\n        for (int i = 0; i < len; i++)\n            prefix_sum[i + 1] = prefix_sum[i] + choices[u][i];\n\n        for (int k = 1; k <= len; k++)\n            skill[k] += prefix_sum[len] - prefix_sum[len % k];\n    }\n\n    for (int k = 1; k <= N; k++)\n        cout << skill[k] << (k < N ? \' \' : \'\\n\');\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['brute force', 'data structures', 'greedy', 'number theory', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Berland Regional.json,https://codeforces.com//blog/entry/90212,There are two important observations to make The first one is that you can calculate the answers for each university independently of each other and sum them up to obtain the true answer The second one is that if there are students in an university then that university can only contribute to answers for from to So if we learn to calculate the contribution of the th university for some fixed in then we will be able to iterate over all possible for each university and get the solution in where is the number of students in the th university To achieve it you have to gather the sum of the maximum number of students that can form full teams of size That must be the highest number less than or equal to that is divisible by so Sort the students of each university precalculate partial sums and now you are free to add the prefix sum of that number of students to the answer for Overall complexity per testcase 
https://codeforces.com//contest/1401/problem/D,704916,D,1401D,1401,D. Maximum Distributed Tree,You are given a tree that consists of n nodes You should label each of its n 1 edges with an integer in such way that satisfies the following conditions each integer must be greater than 0 the product of all n 1 numbers should be equal to k the number of 1 s among all n 1 integers must be minimum possible Let s define f u v as the sum of the numbers on the simple path from node u to node v Also let sum limits i 1 n 1 sum limits j i 1 n f i j be a of the tree Find the maximum possible distribution index you can get Since answer can be too large print it modulo 10 9 7 In this problem since the number k can be large the result of the prime factorization of k is given instead ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MAX = 1e5, MOD = 1e9+7;\nint n, m;\nvi adj[MAX];\nll p[MAX], s[MAX], contrib[MAX];\n\nvoid dfs(int u=0, int p=-1) {\n\ts[u]=1;\n\tfor(int v : adj[u]) {\n\t\tif(v==p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v, u);\n\t\ts[u]+=s[v];\n\t}\n\tcontrib[u]=s[u]*(n-s[u]);\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tadj[i].clear();\n\t\t}\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v, --u, --v;\n\t\t\tadj[u].pb(v);\n\t\t\tadj[v].pb(u);\n\t\t}\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tsort(p, p+m);\n\t\tdfs();\n\t\tsort(contrib+1, contrib+n);\n\t\tll ans=0;\n\t\tfor(int i=n-1; i>0; i--) {\n\t\t\tll pp=1;\n\t\t\tif(i>n-1-m) {\n\t\t\t\tpp=p[i-1-max(n-1-m, 0)];\n\t\t\t}\n\t\t\tif(i==n-1) {\n\t\t\t\tfor(int j=n-1; j<m; j++) {\n\t\t\t\t\tpp=pp*p[j]%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += pp*contrib[i]%MOD;\n\t\t}\n\t\tcout << ans%MOD << ""\\n"";\n\t}\n\n\treturn 0;\n}']",,,"['dfs and similar', 'dp', 'greedy', 'implementation', 'math', 'number theory', 'sortings', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Maximum Distributed Tree.json,https://codeforces.com//blog/entry/81700,Let s define as the product of the number of vertices belonging to each of the two components divided when the edge is removed from the tree and as the number on edge Now a distribution index is equal to Now there are two cases In this case we have to label to distinct edges because we have to minimize the number of s And to maximize distribution index we can label a larger to the edge in which is larger because the following holds For four positive integers Let s suppose Then the equation can be written as follows Because we proved it And label to the remaining edges In this case we can make no s exist out of integers and some of number would be composite And to maximize distribution index we can label the product of largest to the edge in which is largest and label the remaining to the remaining edges in the same way as case because the following holds For five positive integers Substituting in the above equation we can find the equation is same as before So we proved it After filling in the edge calculate it and find the answer Time complexity 
https://codeforces.com//contest/746/problem/F,85374,F,746F,746,F. Music in Car,Sasha reaches the work by car It takes exactly minutes On his way he listens to music All songs in his playlist go one by one after listening to the th song Sasha gets a pleasure which equals The th song lasts for minutes Before the beginning of his way Sasha turns on some song and then he listens to the songs one by one at first the song then the song then the song number and so on He listens to songs until he reaches the work or until he listens to the last song in his playlist Sasha can listen to each song to the end or In the second case he listens to the song for integer number of minutes at least half of the song s length Formally if the length of the song equals minutes Sasha listens to it for no less than minutes then he immediately switches it to the next song if there is such For example if the length of the song which Sasha wants to listen to equals minutes then he should listen to it for at least minutes if the length of the song equals minutes then he should listen to it for at least minutes It takes no time to switch a song Sasha wants to listen no more than songs If the last listened song plays for less than half of its length then Sasha doesn t get pleasure from it and that song is not included to the list of listened songs It is not allowed to skip songs A pleasure from a song does not depend on the listening mode for the th song this value equals Help Sasha to choose such and no more than songs for listening to get the maximum pleasure Write a program to find the maximum pleasure Sasha can get from the listening to the songs on his way to the work ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)501*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n,w,k,a[N],t[N],ans;\nmultiset <ll> s,p;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>w>>k;\n    for(int i=0;i<n;i++)cin>>a[i];\n    for(int i=0;i<n;i++)cin>>t[i];\n    for(ll i=0,j=0,time=0,res=0;i<n;i++)\n    {\n    \twhile(j<n)\n    \t{\n    \t\tll now=time;\n    \t\tif((ll)s.size()<w)now+=(t[j]+1)/2;\n    \t\telse if(t[j]>(*s.begin()))now+=(t[j]+1)/2+((*s.begin())-((*s.begin())+1)/2);\n    \t\telse now+=t[j];\n    \t\t\n\t\t\tif(now>k)break;\n    \t\t\n    \t\tif((ll)s.size()<w)s.insert(t[j]);\n    \t\telse if(t[j]>(*s.begin()))p.insert(*s.begin()),s.erase(s.begin()),s.insert(t[j]);\n    \t\telse p.insert(t[j]);\n    \t\t\n\t\t\ttime=now;res+=a[j];j++;\n\t\t}\n\t\tans=max(ans,res);\n\t\t\n\t\tif(j<=i){j=i+1;continue;}\n\t\tres-=a[i];\n\t\tif(t[i]<*s.begin())p.erase(p.find(t[i])),time-=t[i];\n\t\telse \n\t\t{\n\t\t\ts.erase(s.find(t[i]));\n\t\t\ttime-=(t[i]+1)/2;\n\t\t\tif(p.size())\n\t\t\t{\n\t\t\t\tauto it=p.end();it--;\n\t\t\t\ts.insert(*it);\n\t\t\t\ttime-=(*it-(*it+1)/2);\n\t\t\t\tp.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n    return 0;\n}']",,,"['data structures', 'greedy', 'two pointers']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Music in Car.json,https://codeforces.com//blog/entry/49160,This problem can be solved with help of two pointers We will store two sets set with songs with full time and set with songs with partly time How to move left and right pointers and recalculate current answer Let left end of the current segment is and right end of the segment is Let the set of songs with partly time is and with full time In this sets we will store pairs time of listening each song and it number Right end we will move in the following way if we can add partly song and we have enough time to listen it we take it also add this song to and add to time and add to the answer In the other case we have two cases First we add current song as full song second we add current song as partly song Here we need to choose case with less with the total time Also here we need to correctly add song to sets and update total time and the answer If total time became more than we are not allowed to move Now we need to update global answer with the current value of answer Left end we will move in the following way if we took song as full song we delete it from subtract from total time length of this song In the other case we delete it from and subtract from the total time the After that we try to take some song from If the size of is 0 we can not do that If we done it we need to change total time on the songs on the current segment 
https://codeforces.com//contest/818/problem/C,112247,C,818C,818,C. Sofa Thief,Yet another round on DecoForces is coming Grandpa Maks wanted to participate in it but someone has stolen his precious sofa And how can one perform well with such a major loss Fortunately the thief had left a note for Grandpa Maks This note got Maks to the sofa storehouse Still he had no idea which sofa belongs to him as they all looked the same The storehouse is represented as matrix Every sofa takes two neighbouring by some side cells No cell is covered by more than one sofa There can be empty cells Sofa is standing to the left of sofa if there exist two such cells and that is covered by and is covered by Sofa is standing to the top of sofa if there exist two such cells and that is covered by and is covered by Right and bottom conditions are declared the same way Also some sofa can be both to the top of another sofa and to the bottom of it The same is for left and right conditions The note also stated that there are sofas to the left of Grandpa Maks s sofa to the right to the top and to the bottom Grandpa Maks asks you to help him to identify his sofa It is guaranteed that there is no more than one sofa of given conditions Output the number of Grandpa Maks s sofa If there is no such sofa that all the conditions are met for it then output ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\n#define x1 fjkljklx1\n#define y1 fjkljkly1\n#define x2 fjkljklx2\n#define y2 fjkljkly2\nint d , n , m;\nint x1[ N ] , x2[ N ] , y1[ N ] , y2[ N ];\nint cntl , cntr , cntt , cntb;\nvoid init(){\n  cin >> d >> n >> m;\n  for( int i = 0 ; i < d ; i ++ )\n    cin >> x1[ i ] >> y1[ i ] >> x2[ i ] >> y2[ i ];\n  cin >> cntl;\n  cin >> cntr;\n  cin >> cntt;\n  cin >> cntb;\n}\nint cl[ N ] , cr[ N ] , ct[ N ] , cb[ N ];\nvoid solve(){\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { x1[ i ] , i } );\n      v.push_back( { x2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // left xa < xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cl[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cl[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cr[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cr[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { y1[ i ] , i } );\n      v.push_back( { y2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // top ya < yb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          ct[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            ct[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cb[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cb[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  for( int i = 0 ; i < d ; i ++ )\n    if( cl[ i ] == cntl and\n        cr[ i ] == cntr and\n        ct[ i ] == cntt and\n        cb[ i ] == cntb ){\n      cout << i + 1 << endl;\n      return;\n    }\n  cout << -1 << endl;\n}\nint main(){\n  init();\n  solve();\n}\n']",,,"['brute force', 'implementation']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Sofa Thief.json,https://codeforces.com/blog/entry/52991,Coordinates don t exceed so it s possible to use sweep line method to solve the problem Let s calculate value separately for each side I will show the algorithm for left side and all the others will be done similarly Let be the number of sofas which has smaller of their coordinates less than or equal to To count that let s firstly increment by one for all sofas and then proceed from left to right and do Now will represent number of sofas to the left of the current one but the sofa itself can also be counted You need to decrement the result by one if The same is for top value but with coordinates insted of For the right and bottom values you should calculate and Then take and The only thing left is to compare values of each sofa with given ones and find the suitable sofa Overall complexity 
https://codeforces.com//contest/1635/problem/F,1304252,F,1635F,1635,F. Closest Pair ,There are n weighted points on the OX axis The coordinate and the weight of the i th point is x i and w i respectively All points have distinct coordinates and positive weights Also x i x i 1 holds for any 1 leq i n The weighted distance between i th point and j th point is defined as x i x j cdot w i w j where val denotes the absolute value of val You should answer q queries where the i th query asks the following Find the weighted distance among all pairs of distinct points among the points in subarray l i r i ,"['// Problem: F. Closest Pair \n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/F\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nint ans[1200003];\nvoid update(int l,int r,int x,int id,int val)\n{\n\tif(l==r) \n\t{\n\t\tans[id]=min(ans[id],val);\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid) update(l,mid,x,id<<1,val);\n\telse update(mid+1,r,x,(id<<1)+1,val);\n\tans[id]=min(ans[(id<<1)],ans[(id<<1)+1]);\n\treturn ;\n}\nint query(int l,int r,int L,int R,int id)\n{\n\tif(L<=l && r<=R) return ans[id];\n\tint mid=(l+r)>>1;\n\tint res=0x3f3f3f3f3f3f3f3f;\n\tif(L<=mid) res=min(res,query(l,mid,L,R,id<<1));\n\tif(R>=mid+1) res=min(res,query(mid+1,r,L,R,(id<<1)+1));\n\treturn res;\n}\nstruct node\n{\n\tint l,id;\n};\nvector<node> e[300003];\nint Ans[300003],a[300003],w[300003];\nsigned main()\n{\n\tmemset(ans,0x3f,sizeof(ans));\n\tint n=read(),m=read();\n\tfor(int i=1; i<=n; ++i) a[i]=read(),w[i]=read();\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\tint l=read(),r=read();\n\t\te[r].push_back((node){l,i});\n\t}\n\tstack<int> stk;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\twhile(!stk.empty())\n\t\t{\n\t\t\tint A=stk.top();\n\t\t\tupdate(1,n,A,1,(a[i]-a[A])*(w[i]+w[A]));\n\t\t\tif(w[A]>w[i])//i更优\n\t\t\t\tstk.pop();\n\t\t\telse break;\n\t\t}\n\t\tstk.push(i);\n\t\tfor(node j:e[i])\n\t\t\tAns[j.id]=query(1,n,j.l,i,1);\n\t}\n\tfor(int i=1; i<=m; ++i) printf(""%lld\\n"",Ans[i]);\n\treturn 0;\n}']",,,"['data structures', 'greedy']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Closest Pair .json,https://codeforces.com//blog/entry/100153,First of all let s solve the problem for the whole array Define as the biggest satisfying and and as the smallest satisfying and Then we consider pairs of points and for each In conclusion the closest pair the pair with the minimum weighted distance must be among them Proof Assume that is the closest pair and If holds then must holds otherwise would obviously be a better pair Similarly if holds then must holds otherwise would obviously be a better pair The lemma above also applies to range queries by the exact same proof So now we first need to find and for each this could be simply done with a stack Then imagine we draw lines between the endpoints of each pair and the problem could be reduced to given weighted segments for each query find the one with the minimum weight that is totally covered by This is actually a classic problem which could be solved by sweep line trick any data structure able to maintain prefix minimum with single point updates like BIT or segment tree Total Complexity 
https://codeforces.com//contest/1796/problem/E,1802549,E,1796E,1796,E. Colored Subgraphs,Monocarp has a tree consisting of n vertices He is going to select some vertex r and perform the following operations on each vertex v from 1 to n set d v equal to the distance from v to r the number of edges on the shortest path color v some color A coloring satisfies two conditions for each pair of vertices of the same color v u there exists a path from v to u that only visits vertices of the same color for each pair of vertices of the same color v u d v neq d u Note that Monocarp can choose any amount of different colors he wants to use For each used color he then counts the number of vertices of this color The of the tree is the minimum of these numbers What can be the maximum cost of the tree ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nvector<int> e[200005];\nint f[200005],FA[200005];\nmultiset<int> S,sf[200005];\nint ans;\nvoid mv(int u,int v)\n{\n\tif(f[u]==f[v]+1)\n\t{\n\t\tif(sf[u].size()>1)\n\t\t{\n\t\t\tf[u]=(*++sf[u].begin())+1;\n\t\t\tS.erase(S.find(f[u]-1));\n\t\t}\n\t\telse f[u]=1;\n\t}\n\telse S.erase(S.find(f[v]));\n\tsf[u].erase(sf[u].find(f[v]));\n\tFA[u]=v,FA[v]=0;\n\tsf[v].insert(f[u]);\n\tif(*sf[v].begin()==f[u])\n\t{\n\t\tif(sf[v].size()>1)\n\t\t\tS.insert(*++sf[v].begin());\n\t}\n\telse S.insert(f[u]);\n\tf[v]=(*sf[v].begin())+1;\n}\nvoid dfs2(int u,int fa)\n{\n\tif(S.size()) ans=max(ans,min(f[u],*S.begin()));\n\telse ans=max(ans,f[u]);\n\tfor(auto v:e[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tmv(u,v),dfs2(v,u),mv(v,u);\n\t}\n}\nvoid dfs1(int u,int fa)\n{\n\tFA[u]=fa;\n\tvector<int> ss;\n\tfor(auto v:e[u])\n\t\tif(v!=fa) dfs1(v,u),ss.push_back(f[v]);\n\tsort(ss.begin(),ss.end());\n\tif(ss.size()) f[u]=ss[0]+1;\n\telse f[u]=1;\n\tfor(auto t:ss) sf[u].insert(t);\n\tfor(int i=1;i<ss.size();i++) S.insert(ss[i]);\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tS.clear();\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0;i<=n;i++) e[i].clear(),sf[i].clear(),f[i]=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tcin >> u >> v;\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tans=0;\n\t\tdfs1(1,0);\n\t/*\tfor(int i=1;i<=n;i++) cout << f[i] << "" "";\n\t\tcout << ""\\n"";\n\t\tmv(1,2);\n\t\tfor(int i=1;i<=n;i++) cout << f[i] << "" "";\n\t\tcout << ""\\n"";*/\n\t\tdfs2(1,0);\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}\n/*\n1\n4\n1 2\n2 3\n3 4\n*/']",,,"['dfs and similar', 'dp', 'games', 'greedy', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Colored Subgraphs.json,https://codeforces.com//blog/entry/113408,Let s start by choosing a vertex naively Iterate over all vertices and try each of them Root the tree by and observe what the conditions become for each is just the depth of each vertex Well then the only case when the connected subgraph of vertices of the same color has all values of distinct is when they form a vertical path in the tree So the problem becomes the following Split the tree into some vertical paths in such a way that the shortest path is as long as possible Let s try greedy I guess Start the paths from the leaves and propagate them up Consider some vertex with at least two children All children have some paths leading up to them We d love to continue them all with but we can t do that We can only continue one path and cut the rest Pretty easy to see that the path to continue is the shortest path available It s at least as optimal as any other path Do that from the lowest vertices up and you got yourself a working greedy Also don t forget to stop all paths in root since you can t continue any of them further up Let s make this greedy more formal Every time we update the answer is with a path that is the shortest in every vertex lower than the current one not the shortest in the current one So we want to propagate the shortest child up and update the answer with the remaining children Updating the answer means just taking the minimum of values Thus we can actually ignore all children except the second shortest in each vertex Just don t forget to treat the root properly Now we can actually solve the problem in for a fixed You can just find two minimums in each vertex Well now that we can solve the problem for a single root let s try rerooting to solve for all of them There are solutions in but I found the solution in the neatest The constraints are low enough to allow it For each vertex maintain a multiset of lengths of vertical paths from its children I chose to store nothing in the leaves that only makes the implementation cleaner In order to update the vertex from its child you can take the minimum element in the child s set and add to it If it s empty the child is a leaf return Additionally store a multiset of the second minimums of all vertices that have at least two children In order to update the answer with the current root find the minimum of that multiset and the shortest path from the root To achieve you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it It is kind of messy but it should still perform better Overall complexity or per testcase 
https://codeforces.com//contest/1498/problem/A,939722,A,1498A,1498,A. GCD Sum,The text gcdSum of a positive integer is the gcd of that integer with its sum of digits Formally text gcdSum x gcd x text sum of digits of x for a positive integer x gcd a b denotes the greatest common divisor of a and b the largest integer d such that both integers a and b are divisible by d For example text gcdSum 762 gcd 762 7 6 2 gcd 762 15 3 Given an integer n find the smallest integer x ge n such that text gcdSum x 1 ,"['#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\ninline int gcd(re int x,re int y){return y?gcd(y,x%y):x;}\ninline bool check(re int x){\n\tre int y=x,s=0;\n\twhile(x)s+=x%10,x/=10;\n\tif(gcd(y,s)>1)return 1;\n\treturn 0;\n}\nsigned main(){\n\tt=read();\n\twhile(t--){\n\t\tn=read();\n\t\twhile(!check(n))++n;\n\t\tprintf(""%lld\\n"",n);\n\t}\n}\n']",,,"['brute force', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. GCD Sum.json,https://codeforces.com//blog/entry/89137,Therefore for the input n we can simply check which one of n n 1 and n 2 has its gcd sum 1 and print the lowest of them 
https://codeforces.com//contest/848/problem/B,120617,B,848B,848,B. Rooter s Song,On a Cartesian coordinate plane lies a rectangular stage of size represented by a rectangle with corners and It can be seen that no collisions will happen before one enters the stage On the sides of the stage stand dancers The th of them falls into one of the following groups stands at moves in positive direction upwards stands at moves in positive direction rightwards According to choreography the th dancer should stand still for the first milliseconds and then start moving in the specified direction at unit per millisecond until another border is reached It is guaranteed that no two dancers have the same group position and waiting time at the same time When two dancers collide i e are on the same point at some time when both of them are moving they immediately exchange their moving directions and go on Dancers stop when a border of the stage is reached Find out every dancer s stopping position ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nmap <int, int> Mx;\nint ch(int x) {\n\tif (Mx.count(x)) return Mx[x];\n\tint t = Mx.size();\n\treturn Mx[x] = t + 1;\n}\n\nmap <pair<int, pii>, int> Mch;\nvector <pii> Vin[200050];\n\nint ans[200050][2];\nint main() {\n\tint N, W, H, i, j;\n\tscanf(""%d %d %d"", &N, &W, &H);\n\tfor (i = 1; i <= N; i++) {\n\t\tint t1, t2, t3;\n\t\tscanf(""%d %d %d"", &t1, &t2, &t3);\n\t\tint x = ch(t3 - t2);\n\t\tVin[x].emplace_back(t1, t2);\n\n\t\tMch[mp(x, pii(t1, t2))] = i;\n\t}\n\n\tfor (i = 1; i <= Mx.size(); i++) {\n\t\tsort(all(Vin[i]), [](pii a, pii b) {\n\t\t\tif (a.first != b.first) return a.first == 2;\n\t\t\telse if (a.first == 2) return a.second > b.second;\n\t\t\telse return a.second < b.second;\n\t\t});\n\t\t\n\t\tvector <pii> Va;\n\t\tfor (auto it : Vin[i]) if (it.first == 1) Va.emplace_back(it.second, H);\n\t\tfor (auto it : Vin[i]) if (it.first == 2) Va.emplace_back(W, it.second);\n\n\t\tfor (j = 0; j < Vin[i].size(); j++) {\n\t\t\tint x = Mch[mp(i, Vin[i][j])];\n\t\t\tans[x][0] = Va[j].first, ans[x][1] = Va[j].second;\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) printf(""%d %d\\n"", ans[i][0], ans[i][1]);\n\treturn 0;\n}']",,,"['constructive algorithms', 'data structures', 'geometry', 'implementation', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Rooter s Song.json,https://codeforces.com//blog/entry/54233,Move every dancer units backwards in the first place that is to for the vertical moving group and for the horizontal moving group Then start the time making everyone start moving immediately Notice that if two dancers collide before any other collision happens then they have the same values for their initial positions Furthermore after a collision the two dancers keep having the same and also with the same relative orders of and Also after a collision the union of all dancers tracks will be the same as if they went through each other and no collision happened at all see the figure for sample 1 to get a general idea on this Therefore divide dancers into groups by and collisions will happen within groups only Dancers in the same group will move on the same line a line of slope and however collisions take place they will keep current relative order of and It s proved before that in each group dancers exiting positions is the same as if no collision happened at all namely for initially vertical dancers and for initially horizontal ones For each group find out all such positions Sort all dancers according to their initial values and sort these positions in the direction of to then Match the sorted dancers to these sorted positions and obtain the answers for all dancers This solution works in 
https://codeforces.com//contest/689/problem/B,64398,B,689B,689,B. Mike and Shortcuts,Recently Mike was very busy with studying for exams and contests Now he is going to chill a bit by doing some sight seeing in the city City consists of intersections numbered from to Mike starts walking from his house located at the intersection number and goes along some sequence of intersections Walking from intersection number to intersection requires units of energy The spent by Mike to visit a sequence of intersections is equal to units of energy Of course walking would be boring if there were no shortcuts A is a special path that allows Mike walking from one intersection to another requiring only unit of energy There are exactly shortcuts in Mike s city the of them allows walking from intersection to intersection but not in the opposite direction thus there is exactly one shortcut starting at each intersection Formally if Mike chooses a sequence then for each satisfying and Mike will spend instead of walking from the intersection to intersection For example if Mike chooses a sequence he spends exactly units of total energy walking around them Before going on his adventure Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home Formally for each Mike is interested in finding minimum possible total energy of some sequence ,"['#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 200100;\n\n\n\nint n, a[N], D[N], viz[N];\nqueue<int> q;\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""a.in"", ""r"", stdin);\n    freopen(""a.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n;\n    FOR(i,1,n) {\n        cin >> a[i];\n    }\n    q.push(1);\n    viz[1] = 1;\n    while(!q.empty()) {\n        int x = q.front();\n        q.pop();\n        if (!viz[x + 1] && x + 1 <= n) {\n            viz[x + 1] = 1;\n            D[x + 1] = D[x] + 1;\n            q.push(x + 1);\n        }\n        if (!viz[x - 1] && x - 1 >= 1) {\n            viz[x - 1] = 1;\n            D[x - 1] = D[x] + 1;\n            q.push(x - 1);\n        }\n        if (!viz[a[x]] && a[x] != x) {\n            viz[a[x]] = 1;\n            D[a[x]] = D[x] + 1;\n            q.push(a[x]);\n        }\n    }\n    FOR(i,1,n) {\n        cout << D[i] << "" "";\n    }\n    return 0;\n}']",,,"['dfs and similar', 'graphs', 'greedy', 'shortest paths']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Mike and Shortcuts.json,https://codeforces.com//blog/entry/45912,We can build a complete graph where the cost of going from point i to point j if i j if ai j and 1 if ai j The we can find the shortest path from point 1 to point i One optimisation is using the fact that there is no need to go from point i to point j if j s i j i 1 j i 1 so we can add only edges i i 1 i i 1 i s i with cost 1 and then run a bfs to find the shortest path for each point i You can also solve the problem by taking the best answer from left and from the right and because ai ai 1 then we can just iterate for each i form 1 to n and get the best answer from left and maintain a deque with best answer from right 
https://codeforces.com//contest/1895/problem/C,2305457,C,1895C,1895,C. Torn Lucky Ticket,A ticket is a non empty string of digits from 1 to 9 A ticket is such a ticket that it has an even length the sum of digits in the first half is equal to the sum of digits in the second half You are given n ticket pieces s 1 s 2 dots s n How many pairs i j for 1 le i j le n are there such that s i s j is a ticket Note that it s possible that i j Here the operator denotes the concatenation of the two strings For example if s i is and s j is then s i s j is ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    //cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<string> S(N);\n\trep(i,0,N) cin>>S[i];\n\tauto f=[&](int a,string S) -> int {\n\t\tint K=0;\n\t\trep(i,0,S.size()){\n\t\t\tif(i<a) K+=S[i]-\'0\';\n\t\t\telse K-=S[i]-\'0\';\n\t\t}\n\t\treturn K;\n\t};\n\tll ans=0;\n\tfor(int len=2;len<=10;len+=2){\n\t\tvector<map<int,int>> m(6);\n\t\trep(i,0,N){\n\t\t\treverse(all(S[i]));\n\t\t\tm[S[i].size()][f(len/2,S[i])]++;\n\t\t}\n\t\trep(i,0,N){\n\t\t\treverse(all(S[i]));\n\t\t\tint v=f(len/2,S[i]);\n\t\t\tint a=len-(int)S[i].size();\n\t\t\tif(1<=a&&a<=5) ans+=m[a][v];\n\t\t}\n\t}\n\tcout<<ans<<""\\n"";\n}']",,,"['brute force', 'dp', 'hashing', 'implementation', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Torn Lucky Ticket.json,https://codeforces.com//blog/entry/122034,There is an obvious approach iterate over the first part the second part and check the sum In order to improve it let s try to get rid of the second iteration Consider the case where the first part is longer or equal than the second part So we still iterate over the first part in However instead of iterating over the exact second part let s just iterate over its length Now we know the total length of the parts but not their sums of digits Hmm not exactly By fixing the longer part we actually know what the required sum of each half should be It s fully inside the first part However this first part also contains some digits that belong to the second half So if the sum of the second part was the total sum of the second half would be these digits plus Let be the total length of the ticket the length of the fixed first part plus the fixed length of the second part Let be the sum of the first digits of the first part and be the sum of its remaining digits Then Rewrite into Thus we just know what should be the sum of the second half And every ticket part that is exactly of the fixed length and has sum exactly will form a lucky ticket with the fixed part So we have to precalculate which is the number of ticket parts that have length and sum and use that structure to speed up the solution The mirror case where the second part is strictly longer than the first part can be handled similarly Overall complexity 
https://codeforces.com//contest/1954/problem/F,2586696,F,1954F,1954,F. Unique Strings,Let s say that two strings a and b are if you can get the string b by cyclically shifting string a For example the strings and are equal while and are not You are given a binary string s of length n Its first c characters are s and its last n c characters are s In one operation you can replace one with Calculate the number of unique strings you can get using no more than k operations Since the answer may be too large print it modulo 10 9 7 ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0\xa0\xa0#include <utility>\xa0namespace atcoder {\xa0namespace internal {\xa0// @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;}\xa0// Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;\xa0    // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\xa0    // @return m    unsigned int umod() const { return _m; }\xa0    // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay\xa0        // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }};\xa0// @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;}\xa0// Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n);\xa0// @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};\xa0    // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;\xa0    while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\xa0        // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b\xa0        auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};}\xa0// Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0\xa0#include <cassert>#include <numeric>#include <type_traits>\xa0namespace atcoder {\xa0namespace internal {\xa0#ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>;\xa0template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type;\xa0template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type;\xa0template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type;\xa0#else\xa0template <class T> using is_integral = typename std::is_integral<T>;\xa0template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type;\xa0#endif\xa0template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\xa0template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\xa0template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0#include <cassert>#include <numeric>#include <type_traits>\xa0#ifdef _MSC_VER#include <intrin.h>#endif\xa0namespace atcoder {\xa0namespace internal {\xa0struct modint_base {};struct static_modint_base : modint_base {};\xa0template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\xa0}  // namespace internal\xa0template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;\xa0  public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\xa0    static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\xa0    unsigned int val() const { return _v; }\xa0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\xa0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\xa0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\xa0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }\xa0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\xa0  private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;};\xa0template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;\xa0  public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\xa0    dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\xa0    unsigned int val() const { return _v; }\xa0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\xa0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\xa0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\xa0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }\xa0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\xa0  private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\xa0using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>;\xa0namespace internal {\xa0template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\xa0template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\xa0template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\xa0template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0using namespace atcoder;\xa0//using mint=modint998244353;using mint=modint1000000007;\xa0template<int mod>struct nCr{    vector<static_modint<mod>> fac,inv,ifac;    void calc(int n){        fac.resize(n+1),inv.resize(n+1),ifac.resize(n+1);        fac[0]=inv[1]=ifac[0]=1;        for(int i=1; i<=n; ++i) fac[i]=fac[i-1]*static_modint<mod>::raw(i);        for(int i=2; i<=n; ++i) inv[i]=inv[mod%i]*static_modint<mod>::raw(mod-mod/i);        for(int i=1; i<=n; ++i) ifac[i]=ifac[i-1]*inv[i];    }    static_modint<mod> C(int n, int m){        if(m<0||m>n) return 0;        return fac[n]*ifac[m]*ifac[n-m];    }};\xa0nCr<1000000007> de;\xa0void ahcorz(){    int n,c,k; cin >> n >> c >> k;    de.calc(n+1);    vv(mint,dp,n+1,n+1);    dp[1][1]=1;    rep(i,2,n+1) rep(j,2,n+1){        dp[i][j]=dp[i][j-1]+dp[i-1][j-1];        if(j-1-c>=1) dp[i][j]-=dp[i-1][j-1-c];    }    per(i,n,0) rep(j,1,n+1) dp[i][j]+=dp[i+1][j];    vc<mint> dp2(n+1);    rep(m,1,n+1) if(n%m==0){        rep(m+1) if(i*(n/m)<=c+k) dp2[m]+=de.C(m,i);        rep(i,1,m+1) if(m+1-i<=c) dp2[m]-=(m+1-i)*dp[iceil(n-c-k,n/m)][i];        bug(m,dp2[m].val());    }    rep(m,1,n+1) if(n%m==0){        rep(i,1,m) if(m%i==0) dp2[m]-=dp2[i];    }    mint res;    rep(m,1,n+1) res+=dp2[m]/m;    print(res.val());}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}']",,,"['combinatorics', 'dp', 'math']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Unique Strings.json,https://codeforces.com//blog/entry/128421,What s common in all strings we can get each string has no more than ones and at least consecutive ones So let s loosen up our constraints a little and just calculate the number of strings with no more than ones and at least consecutive ones i e this block of ones can be anywhere can even start at the end and continue at the beginning Let s name such strings as Note that the number of unique good strings is exactly equal to the answer of the initial task since we can shift each good string and make it start from the block of ones How to calculate the number of good strings Using Burnside s lemma Since the group of transformations is just a group of cyclic shifts we can calculate the answer as following where is the number of or the number of strings that won t change after a cyclical shift by characters Note that if the string doesn t change while shifting by characters then it means that for all Further investigation reveals that all characters will be split into exactly groups and each group will contain exactly equal characters It means that if then since in both cases we ll get exactly the same group division So we can rewrite the answer as following where is the number of cyclic shifts with and can be easily counted So it s time to calculate for some divisor of It s not hard to see that if then the first characters of will uniquely define the whole string So it s enough to work with only a prefix of length remembering that each character will be copied times Remember that a good string is a string with at most ones and since each character will be copied times we can place at most ones in our prefix or at least zeroes Also since a good string has consecutive ones our prefix should also have consecutive ones including the case where the ones go cyclically starting at the end of the prefix In case if then the whole prefix should consist of ones and it s either possible if or impossible if In case we need to calculate the number of good prefixes that can be described as the cyclic strings of length that has no more than ones and contains consecutive ones Instead of good prefixes let s calculate bad prefixes and subtract them from all possible prefixes prefixes are just strings with at most ones and there are such strings prefixes are cyclic strings with at most ones where all blocks of ones have length less than In order to calculate bad prefixes let s precalc the following dp is the number of strings of length with where all blocks of ones have length less than and the last character of the string is Why did we use the number of zeroes in the state and why did we add the last zero in Because it will help us to calculate dp fast Now if we have value we can add a block of ones and zero to the end of the string and update the value in Note that we are updating a segment of row from to with value we can do it in So we can precalc the whole dp in time Now it s time to calculate the number of bad strings if we iterate over the length of the prefix of ones length of the suffix of ones and the number of zeroes in between we ll get where is the number of ones on prefix is the number of ones on suffix and is the number of zeroes in the middle part Since each bad string will look like ones middle part ending at ones you can place in the middle part at least zeroes and at most zeroes If we play a little with the sum we can simplify it in the following way where is the sum of dp on the row from to and you can take it in if you precalc prefix sums of dp prefixes are just and since can be calculated in the total complexity of is The resulting complexity is that looks like just 
https://codeforces.com//contest/1846/problem/E1,1999905,E1,1846E1,1846,E1. Rudolf and Snowflakes  simple version ,One winter morning Rudolf was looking thoughtfully out the window watching the falling snowflakes He quickly noticed a certain symmetry in the configuration of the snowflakes And like a true mathematician Rudolf came up with a mathematical model of a snowflake He defined a snowflake as an undirected graph constructed according to the following rules Initially the graph has only one vertex Then more vertices are added to the graph The initial vertex is connected by edges to k new vertices k 1 Each vertex that is connected to only one other vertex is connected by edges to k more new vertices This step should be done The smallest possible snowflake for k 4 is shown in the figure After some mathematical research Rudolf realized that such snowflakes may not have any number of vertices Help Rudolf check if a snowflake with n vertices can exist ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long root_n(long long n, int k)\n{\n\tlong long m = pow(n, (long double)1.0 / k);\n\twhile (pow(m, k) <= n) \n    m++;\n\tm--;\n\treturn m;\n}\n\nvoid solve()\n{\n  long long n;\n\tcin >> n;\n\n\n\tfor (int m = 3; m<65;++m)\n    {\n\t\tlong long k = root_n(n, m-1);\n\t\tif (k < 2) continue;\n\t\t__int128 nn = n;\n\t\tnn *= (k - 1);\n\t\tnn += 1;\n\t\twhile (nn % k == 0) nn /= k;\n\t\tif (nn == 1) {\n\t\t\tcout << ""YES"" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << ""NO"" << endl;\n\treturn;\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n']",,,"['brute force', 'implementation', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E1. Rudolf and Snowflakes  simple version .json,https://codeforces.com//blog/entry/118044,For the current given constraint you can precalculate whether it is possible to obtain each for some To do this we can iterate through all possible and for each of them calculate the values where is such that For this version of problem it is enougth to calculete valuse for Note that the minimum number of snowflake layers is Therefore the calculations start from the value We can store all the obtained values for example in a set Alternatively we can use an array called used and set the value in the array element with the corresponding index for each obtained value It is better to perform this precalculation before iterating through the test cases Then for each test we only need to read the value of and check if we have obtained it in the precalculation described above The time complexity of the solution using a set is The time complexity of the solution using the used array is Here number of test cases 
https://codeforces.com//contest/1538/problem/G,1011927,G,1538G,1538,G. Gift Set,Polycarp has x of red and y of blue candies Using them he wants to make gift sets Each gift set contains either a red candies and b blue candies or a blue candies and b red candies Any candy can belong to at most one gift set Help Polycarp to find the largest number of gift sets he can create For example if x 10 y 12 a 5 and b 2 then Polycarp can make three gift sets In the first set there will be 5 red candies and 2 blue candies In the second set there will be 5 blue candies and 2 red candies In the third set will be 5 blue candies and 2 red candies Note that in this example there is one red candy that Polycarp does not use in any gift set ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nll n,m,i,j,k,t,t1,u,v,a,b,x,y;\nint check(ll c)\n{\n    ll xx=x-a*c;\n    ll yy=y-a*c;\n    if (a==b)\n    {\n        return ((xx>=0)and(yy>=0));\n    }\n    else\n    {\n        if ((xx<0)or(yy<0)) return 0;\n        xx/=(b-a);\n        yy/=(b-a);\n        return (xx+yy>=c);\n    }\n}\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>x>>y>>a>>b;\n        if (a>b) swap(a,b);\n        ll l=0,r=1e9;\n        ll mid;\n        while(l<r)\n        {\n            mid=(l+r)/2;\n            if (check(mid+1)) l=mid+1;\n            else r=mid;\n        }\n        cout<<l<<endl;\n    }\n}\n']",,,"['binary search', 'greedy', 'math', 'ternary search']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Gift Set.json,https://codeforces.com//blog/entry/91637,In this problem we can use a binary search for the answer If we can make sets then we can make sets So we need to come up with the following test whether we can make sets knowing the parameters Let otherwise we will swap them If the answer is Otherwise let s say we want to make sets of the first kind Then we get a system of inequalities Let s express from here We need to check whether these four equations have an intersection in integers If there is then the division into gifts exists 
https://codeforces.com//contest/1360/problem/G,629827,G,1360G,1360,G. A B Matrix,You are given four positive integers n m a b 1 le b le n le 50 1 le a le m le 50 Find any such rectangular matrix of size n times m that satisfies all of the following conditions each row of the matrix contains exactly a ones each column of the matrix contains exactly b ones all other elements are zeros If the desired matrix does not exist indicate this For example for n 3 m 6 a 2 b 1 there exists a matrix satisfying the conditions above begin vmatrix 0 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 end vmatrix ,"['#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < \'0\' || cc > \'9\' ) {  if( cc == \'-\' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= \'0\' && cc <= \'9\' )  cn = cn * 10 + cc - \'0\', cc = getchar() ;\n\treturn cn * flus ;\n}\n#define maxn 205\nint n , m , a, b ; \nsigned main() {\n\tint T = gi() ;\n\twhile( T -- ) {\n\t\tn = gi(), m = gi(), a = gi(), b = gi() ;\n\t\tif( n * a != m * b ) {\n\t\t\tputs(""NO"") ;\n\t\t\tcontinue ;\n\t\t}\n\t\tputs(""YES"") ;\n\t\tint last = 0 ;\n\t\trep( i, 1, n ) {\n\t\t\tint l = last + 1, r = ( last + a ) % m;\n\t\t\tif( l == 0) {\n\t\t\t\trep( j, 1, r ) printf(""1"") ;\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\tprintf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse if(r == 0 ) {\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\trep( j, l, m ) printf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse if( l <= r ) {\n\t\t\t\trep( j, 1, last ) printf(""0"") ;\n\t\t\t\trep( j, last + 1, last + a ) printf(""1"");\n\t\t\t\trep( j, last + a + 1, m ) printf(""0"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep( j, 1, r ) printf(""1"") ;\n\t\t\t\trep( j, r + 1, l - 1 ) printf(""0"");\n\t\t\t\trep( j, l, m ) printf(""1"");\n\t\t\t\tlast = ( last + a ) % m ;\n\t\t\t\tputs("""");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0 ;\n} ']",,,"['constructive algorithms', 'greedy', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. A B Matrix.json,https://codeforces.com//blog/entry/77846,Let s see how the desired matrix looks like Since each row should have exactly ones and each column should have exactly ones the number of ones in all rows should be equal to the number of ones in all columns Thus the desired matrix exists iff or Let s show how to construct the desired matrix if it exists Let s find any number such that where is the remainder of dividing by In the first row of the desired matrix we put the ones at the positions and in the th row we put the ones as in the row but cyclically shifted by to the right 
https://codeforces.com//contest/370/problem/E,4147,E,370E,370,E. Summer Reading,At school Vasya got an impressive list of summer reading books Unlike other modern schoolchildren Vasya loves reading so he read some book each day of the summer As Vasya was reading books he was making notes in the Reader s Diary Each day he wrote the orderal number of the book he was reading The books in the list are numbered starting from 1 and Vasya was reading them in the order they go in the list Vasya never reads a new book until he finishes reading the previous one Unfortunately Vasya wasn t accurate and some days he forgot to note the number of the book and the notes for those days remained empty As Vasya knows that the literature teacher will want to check the Reader s Diary so he needs to restore the lost records Help him do it and fill all the blanks Vasya is sure that he spends at least two and at most five days for each book Vasya finished reading all the books he had started Assume that the reading list contained many books So many in fact that it is impossible to read all of them in a summer If there are multiple valid ways to restore the diary records Vasya prefers the one that shows the maximum number of read books ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int N = 222222;\n\nint lower[N], upper[N];\nint n, a[N], le[N], ri[N];\n\nint main() {\n    \n    scanf(""%d"", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(""%d"", &a[i]);\n    }\n    lower[0] = upper[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        le[i] = n + 1;\n        ri[i] = -1;\n    }\n    \n    int maxNum = -1;\n    \n    for(int i = 1; i <= n; i++) \n        if (a[i]) {\n            if (a[i] < 1 || a[i] > n) {\n                printf(""-1\\n"");\n                return 0;\n            }\n            int x = a[i];\n            le[x] = min(le[x], i);\n            ri[x] = max(ri[x], i);\n            maxNum = max(maxNum, a[i]);\n        }\n    \n    if (maxNum == -1) {\n        if (n < 2) {\n            printf(""-1\\n"");\n        } else {\n            printf(""%d\\n"", n / 2);\n            for(int i = 1; i <= n / 2; i++) {\n                a[i * 2 - 1] = a[i * 2] = i;\n            }\n            if (n % 2 == 1)\n                a[n] = a[n - 1];\n            for(int i = 1; i <= n; i++) {\n                printf(""%d%c"", a[i], i == n ? \'\\n\' : \' \');\n            }\n        }\n        \n        return 0;\n    }\n    \n    for(int i = 1; i <= n; i++) {\n        if (ri[i] == -1) {\n            lower[i] = lower[i - 1] + 2;\n            upper[i] = upper[i - 1] + 5;\n        } else {\n            int tmp = ri[i] - le[i] + 1;\n            if (tmp > 5) {\n                printf(""-1\\n"");\n                return 0;\n            }\n            \n            if (lower[i - 1] >= le[i] || ri[i] - upper[i - 1] > 5) {\n                printf(""-1\\n"");\n                return 0;\n            }\n            \n            lower[i] = max(ri[i], lower[i - 1] + 2);\n            upper[i] = min(le[i] + 4, upper[i - 1] + 5);\n        }\n    }\n    \n    int ans = 0;\n    \n    for(int i = maxNum; i <= n; i++) {\n        if (lower[i] <= n && upper[i] >= n)\n            ans = i;\n    }\n    \n    if (ans == 0) {\n        printf(""-1\\n"");\n        return 0;\n    }\n    \n    printf(""%d\\n"", ans);\n    \n    int nn = n;\n    \n    for(int i = ans; i >= 1; i--) {\n        for(int j = 2; j <= 5; j++) {\n            if (ri[i] != -1 && le[i] < nn - j + 1)\n                continue;\n            int tmp = nn - j;\n            bool flag = true; \n            if (lower[i - 1] <= tmp && tmp <= upper[i - 1]) {\n                for(int k = tmp + 1; k <= nn; k++)\n                    if (a[k] && a[k] != i)\n                        flag = false;\n                if (!flag)\n                    continue;\n                for(int k = tmp + 1; k <= nn; k++)\n                    a[k] = i;\n                nn = tmp;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 1; i <= n; i++) {\n        printf(""%d%c"", a[i], i == n ? \'\\n\' : \' \');\n    }\n    \n    return 0;\n} ']",,,"['dp', 'greedy']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Summer Reading.json,https://codeforces.com//blog/entry/9866,For each book number that is in the sequence find the leftmost and the rightmost position of this number In other words for each such book number we find a segment of positions that should consist of this number If for some pair of numbers there segments intersect it is impossible to construct the answer The same thing happens if some segment has length more than 5 It is reasonable to separately handle the case when all given numbers are zeroes In this case fill in the numbers greedily spending 2 days on each book probably except the last one So we have some blocks of numbers and gaps between them Lets do the following DP each state of DP is described by two values means the number of block lets enumerate them consecutively means how far to the right will this block eventually extend if there is a gap after this block it is possible that we fill some prefix of this gap with the same book number that is in the block It is clear that will not exceed 5 so we actually can describe the state by values which may sound more convenient So the number of states is linear Lets say that is true if it it possible to correctly fill all the gaps that come before the th block under condition that the th block extends to the position and is false otherwise To calculate the value of lets try to extend the th block to the left in all not so many possible ways to replace some number of consecutive zeroes that are in the gap just before the th block Then try to fix where the previous block can actually end fix the state where is true of course To make a transition in DP we should check whether it possible or not to fill the rest of the gap between the th block and the th block Lets say that th block consists of number the th block consists of number and there are still unfilled positions in the gap Than the gap can be correctly filled if and only if If you understand this DP it won t be difficult for you to find out how to construct the answer from it 
https://codeforces.com//contest/1807/problem/D,1838164,D,1807D,1807,D. Odd Queries,You have an array a 1 a 2 dots a n Answer q queries of the following form If we change all elements in the range a l a l 1 dots a r of the array to k will the sum of the entire array be odd Note that queries are and do not affect future queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ld double\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define line cout << \'\\n\'\n\n#define sz(v) ((int)(v).size())\nconst double pi = 3.1415926535897932384626433832795;\n\nconst long long mod = 998244353;\nconst long long inf = 9099999999999999999;\nconst long long nmax = 4e5 + 100;\nconst long double eps = 1e-9;\n\nrandom_device rd;\nmt19937 rnd(rd());\n//rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n//int MAGIC = rnd();\n\nvoid runtimeerror() {\n  int n, q;\n  cin >> n >> q;\n  vector <int> arr(n);\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n  vector <int> pref(n + 1);\n  for (int i = 0; i < n; i++)\n    pref[i + 1] = pref[i] + arr[i];\n  while (q--) {\n    int l, r, k;\n    cin >> l >> r >> k;\n    if ((pref[n] - (pref[r] - pref[l - 1]) + k * (r - l + 1)) & 1) cout << ""YES"";\n    else cout << ""NO"";\n    line;\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n\n  //  freopen(""input.txt"", ""r"", stdin);\n  //  freopen(""output.txt"", ""w"", stdout);\n\n  ll t = 1;\n    cin >> t;\n  while (t--)\n    runtimeerror();\n\n  //  cout << ""WINNER"";\n  // i\'m stupid man\n}']",,,"['data structures', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\D. Odd Queries.json,https://codeforces.com//blog/entry/114143,Note that for each question the resulting array is So the sum of the elements of the new array after each question is We can compute and in time by precomputing the sum of all prefixes and suffixes or alternatively by using the prefix sums technique So we can find the sum each time in per question and just check if it s odd or not The time complexity is 
https://codeforces.com//contest/226/problem/C,1852,C,226C,226,C. Anniversary,There are less than 60 years left till the 900 th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci Of course such important anniversary needs much preparations Dima is sure that it ll be great to learn to solve the following problem by the Big Day You re given a set consisting of numbers let s consider all its element subsets for each such subset let s find the largest common divisor of Fibonacci numbers with indexes determined by the subset elements Among all found common divisors Dima is interested in the largest one Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence where for Dima has more than half a century ahead to solve the given task but you only have two hours Count the residue from dividing the sought largest common divisor by ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n// }}}\n// #defines {{{\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define SZ(x) ((int)(x).size())\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define PER1(i,a,b) for(int i=(b);i>=(a);i--)\n#define RI(x) scanf(""%d"",&x)\n#define DRI(x) int x;RI(x)\n#define RII(x,y) scanf(""%d%d"",&x,&y)\n#define DRII(x,y) int x,y;RII(x,y);\n#define RIII(x,y,z) scanf(""%d%d"",&x,&y,&z)\n#define DRIII(x,y,z) int x,y,z;RIII(x,y,z);\n#define CASET int ___T,cas=1;scanf(""%d"",&___T);while(___T--)\n#define CASEN0(n) int cas=1;while(scanf(""%d"",&n)!=EOF&&n)\n#define CASEN(n) int cas=1;while(scanf(""%d"",&n)!=EOF)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define SEP(x) ((x)?\'\\n\':\' \')\n#define F first\n#define S second\ntypedef pair<int,int> PII;\ntypedef long long LL;\n// }}}\n\nint mod;\ninline int add(int a,int b){\n    a+=b;if(a>=mod)a-=mod;return a;\n}\ninline int mul(int a,int b){\n    return (b*(LL)a)%mod;\n}\nstruct XD{\n    LL x[2][2];\n    XD(){MS0(x);}\n    XD operator*(const XD& b)const{\n        XD c;\n        REP(i,2)REP(j,2)REP(k,2)c.x[i][k]=add(c.x[i][k],mul(x[i][j],b.x[j][k]));\n        return c;\n    }\n};\nint fib(LL x){\n    if(x<=2)return 1%mod;\n    XD a,m;\n    a.x[0][0]=a.x[1][1]=1;\n    m.x[0][0]=m.x[0][1]=m.x[1][0]=1;\n    x-=2;\n    while(x){\n        if(x%2)a=a*m;\n        m=m*m;\n        x/=2;\n    }\n    return add(a.x[0][0],a.x[0][1]);\n}\nLL l,r;\nLL k;\ninline bool f(LL x){\n    return r/x-(l+x-1)/x+1>=k;\n}\nint main(){\n    RI(mod);\n    scanf(""%I64d%I64d"",&l,&r);\n    scanf(""%I64d"",&k);\n    /*\n    //  For challenge.\n    long long ll=1,rr=r;\n    while(ll<rr){\n        long long mm=(ll+rr+1)/2;\n        if(r/mm-(l+mm-1)/mm+1>=k)ll=mm;\n        else rr=mm-1;\n    }\n    */\n    LL x;\n    LL sr=max((LL)sqrt(r),1LL);\n    LL ans=1;\n    for(x=1;x<=sr;x++){\n        if(f(x))ans=x;\n    }\n    for(x=1;x<=r/sr;x++){\n        LL d=r/x;\n        if(f(d))ans=max(ans,d);\n    }\n    printf(""%d\\n"",fib(ans));\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']",,,"['data structures', 'implementation', 'math', 'matrices', 'number theory']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Anniversary.json,https://codeforces.com/blog/entry/5378,At first let s prove the statement GCD Fn Fm FGCD n m Let s express Fn k using Fn and Fk We ll get the formula Fn k Fk Fn 1 Fk 1 Fn which is easy to prove by induction Then use the derived formula and notice that GCD Fn k Fn GCD Fk Fn Now you are to notice an analogy with Euclidean algorithm and to understand that we ve got necessary equality for GCD of two Fibonacci numbers So our current task is to find in the given set subset of k or at least of k elements with maximal possible GCD To be exactly to find this GCD Let the answer be equal to q Then 1 k 1 must be true Notice that for each summand from left part of inequality O segments exist in which its value is constant Moreover we can find all these segments and values in To be more precise we are intersted in such q that in the point q 1 value of at least one summand changes obviously increases There are also such values Go over all of them and try to use each of them as the answer i e check inequality 1 for each of them and choose maximum from all satisfying numbers The answer always exists as q 1 is true for any input So we ve found index of required Fibonacci number The number itself can be calculated by matrix exponentiation 
https://codeforces.com//contest/525/problem/D,25278,D,525D,525,D. Arthur and Walls,Finally it is a day when Arthur has enough money for buying an apartment He found a great option close to the center of the city with a nice price Plan of the apartment found by Arthur looks like a rectangle consisting of squares of size Each of those squares contains either a wall such square is denoted by a symbol on the plan or a free space such square is denoted on the plan by a symbol Room in an apartment is a maximal connected area consisting of free squares Squares are considered adjacent if they share a common side The old Arthur dream is to live in an apartment where all rooms are rectangles He asks you to calculate minimum number of walls you need to remove in order to achieve this goal After removing a wall from a square it becomes a free square While removing the walls it is possible that some rooms unite into a single one ,"['#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << "" = "" << ccc << endl;\n\n#define\tctrl( xx,yy )\t( xx>=1 and yy>=1 and xx<=m and yy<=n and s[xx][yy]==\'.\' )\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tm,n;\nchar\ts[3000][3000];\nchar\th[3000][3000];\n\nint\tbozuk( int x,int y ){\n\tif( s[x][y]!=\'*\' )\treturn\t0;\n\tif( ctrl( x-1,y ) and ctrl( x-1,y+1 ) and ctrl( x,y+1 ) )\treturn\t1;\n\tif( ctrl( x,y+1 ) and ctrl( x+1,y+1 ) and ctrl( x+1,y ) )\treturn\t1;\n\tif( ctrl( x+1,y ) and ctrl( x+1,y-1 ) and ctrl( x,y-1 ) )\treturn\t1;\n\tif( ctrl( x,y-1 ) and ctrl( x-1,y-1 ) and ctrl( x-1,y ) )\treturn\t1;\n\treturn\t0;\n}\n\nint main(){\n\tcin >> m >> n;\n\tFP( i,1,m )\n\t\tscanf(""%s"",s[i]+1);\n\tqueue< pair<int,int> >\tQ;\n\tFP( i,1,m )\n\t\tFP( j,1,n )\n\t\t\tif( bozuk( i,j ) )\tQ.push( mp(i,j) ),h[i][j]=1;\n\tint\tx,y,xx,yy;\n\twhile( Q.size() ){\n\t\tx = Q.front().st;\n\t\ty = Q.front().nd;\n\t\tQ.pop();\n\t\ts[x][y] = \'.\';\n\t\th[x][y] = 0;\n\t\tFP( i,-1,1 )\n\t\t\tFP( j,-1,1 ){\n\t\t\t\tif( !i and !j )\tcontinue;\n\t\t\t\txx = x+i;\n\t\t\t\tyy = y+j;\n\t\t\t\tif( xx<1 or xx>m or yy<1 or yy>n or h[xx][yy] or !bozuk( xx,yy ) )\tcontinue;\n\t\t\t\tQ.push( mp(xx,yy) ),h[xx][yy] = 1;\n\t\t\t\ts[xx][yy] = \'.\';\n\t\t\t}\n\t}\n\tFP( i,1,m )\n\t\tprintf(""%s\\n"",s[i]+1);\n}\n']",,,"['constructive algorithms', 'data structures', 'graphs', 'greedy', 'shortest paths']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Arthur and Walls.json,https://codeforces.com//blog/entry/17119,To solve this problem we need to observe next fact If in some square whith size 2 2 in given matrix there is exactly one asterisk we must change it on dot That is if in matrix from dots and asterisks is not square 2 2 in which exactly one asterisk and three dots then all maximum size of the area from dots connected by sides represent rectangles Now solve the problem with help of bfs and this fact Iterate on all asterisks in given matrix and if only this asterisk contains in some 2 2 square change this asterisk on dot and put this position in queue Than we need to write standart bfs in which we will change asterisks on dots in all come out 2 2 squares with exactly one asterisk Asymptotic behavior of this solution O n m where n and m sizes of given matrix 
https://codeforces.com//contest/1492/problem/B,905857,B,1492B,1492,B. Card Deck,You have a deck of n cards and you d like to reorder it to a new one Each card has a value between 1 and n equal to p i All p i are pairwise distinct Cards in a deck are numbered from bottom to top i e p 1 stands for the bottom card p n is the top card In each step you pick some integer k 0 take the top k cards from the original deck and place them in the order they are now on top of the new deck You perform this operation until the original deck is empty Refer to the notes section for the better understanding Let s define an as sum limits i 1 n n n i cdot p i Given the original deck output the deck with maximum possible order you can make using the operation above ,"[""#include <bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n\nll MOD = (ll)1000000007;\nvector<ll> nums;\nvector<bool> taken;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t, m, n;\n    ll k, ans = 0, a, b, c, j;\n    string s1, s2;\n    bool sad = false;\n    cin >> t;\n    while(t--) {\n        cin >> n;\n        nums.resize(n);\n        taken.resize(n+1);\n        for(int i = 0; i < n; i++) {\n            cin >> nums[i];\n        }\n        k = n; j = n;\n        for(int i = n-1; i >= 0; i--) {\n            taken[nums[i]] = true;\n            if(nums[i] == k) {\n                for(int z = i; z < j; z++) cout << nums[z] << ' ';\n                j = i;\n            }\n            for(k; k > 0; k--) {\n                if(!taken[k]) break;\n            }\n        }\n        cout << '\\n';\n        vector<ll>().swap(nums);\n        vector<bool>().swap(taken);\n    }\n}""]",,,"['data structures', 'greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Card Deck.json,https://codeforces.com//blog/entry/87792,It s easy to prove that order of a deck differs for different permutations And more than that order of permutation is greater than order of permutation if and only if is lexicographically greater than Since we need to build a lexicographic maximum permutation at each point of time we need to choose such that th element from the top of the original deck is the maximum element in this deck Total complexity is or depending on the implementation 
https://codeforces.com//contest/356/problem/E,3680,E,356E,356,E. Xenia and String Problem,Xenia the coder went to The Olympiad of Informatics and got a string problem Unfortunately Xenia isn t fabulous in string algorithms Help her solve the problem is a sequence of characters where record shows the length of the string of string is string String is a string if it meets the conditions the length of string is odd character occurs exactly once in the string either or substrings and are the same and are Gray strings For example strings are Gray strings and strings are not The of string is the sum of the squares of the lengths of all substrings of string that are Gray strings In other words consider all pairs of values If substring is a Gray string you should add to the beauty Xenia has got string consisting of lowercase English letters She is allowed to replace at most one letter of the string by any other English letter The task is to get a string of maximum beauty ,"['// WRONG ANSWER\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n#include <tuple>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntypedef pair<int, char> change;\n\nstatic char get(\n    const vector<vector<char> > &gray,\n    const vector<vector<map<change, char> > > &changes,\n    int level, int pos, change ch)\n{\n    int side = (1 << level) - 1;\n    int left = pos - side;\n    int right = pos + side;\n    if (ch.first < left || ch.first > right)\n        return gray[level][pos];\n    else\n    {\n        auto p = changes[level][pos].find(ch);\n        if (p == changes[level][pos].end())\n            return 0;\n        else\n            return p->second;\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    string str;\n    int L;\n    cin >> str;\n    L = str.size();\n    int N = 0;\n    while ((1 << (N + 1)) - 1 <= L)\n        N++;\n\n    vector<ll> value(N);\n    for (int i = 0; i < N; i++)\n    {\n        ll len = (1 << (i + 1)) - 1;\n        value[i] = len * len;\n    }\n\n    vector<vector<char> > gray(N, vector<char>(L, \'\\0\'));\n    vector<vector<map<change, char> > > changes(N, vector<map<change, char> >(L));\n    for (int i = 0; i < L; i++)\n    {\n        gray[0][i] = str[i];\n        for (int j = 0; j < 26; j++)\n            if (\'a\' + j != str[i])\n                changes[0][i].insert(make_pair(change(i, \'a\' + j), \'a\' + j));\n    }\n\n    ll score = L;\n    vector<ll> lose(L);\n    vector<vector<ll> > gain(26, vector<ll>(L));\n    for (int i = 1; i < N; i++)\n    {\n        const int side = (1 << i) - 1;\n        const int step = 1 << (i - 1);\n        for (int j = side; j < L - side; j++)\n        {\n            char left = gray[i - 1][j - step];\n            char right = gray[i - 1][j + step];\n            char mid = gray[i - 1][j];\n            gray[i][j] = (left && mid && right\n                && left == right && left != mid) ? str[j] : 0;\n            for (int jump = -step; jump <= step; jump += step)\n            {\n                for (auto cx : changes[i - 1][j + jump])\n                {\n                    const change c = cx.first;\n                    char l2 = get(gray, changes, i - 1, j - step, c);\n                    char m2 = get(gray, changes, i - 1, j, c);\n                    char r2 = get(gray, changes, i - 1, j + step, c);\n                    if (l2 && m2 && r2 && l2 == r2 && l2 != m2)\n                        changes[i][j].insert(make_pair(c, m2));\n                }\n            }\n            if (gray[i][j])\n            {\n                score += value[i];\n                for (int k = j - side; k <= j + side; k++)\n                    lose[k] += value[i];\n            }\n            for (auto cx : changes[i][j])\n                gain[cx.first.second - \'a\'][cx.first.first] += value[i];\n        }\n    }\n\n    ll ans = score;\n    for (int i = 0; i < 26; i++)\n        for (int j = 0; j < L; j++)\n        {\n            ll cur = score - lose[j] + gain[i][j];\n            ans = max(ans, cur);\n        }\n\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']",,,"['dp', 'hashing', 'implementation', 'string suffix structures', 'strings']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Xenia and String Problem.json,https://codeforces.com/blog/entry/9210,During the contest most of participants write the solutions that are very similar to the author s one One of the author s solution uses hashes but there exist solution without it you can see short description of the solution below For each position calculate with hashes the maximal value of such that substring is Gray string Also calculate the maximal value that substring differs from some Gray string in at most one position You can see that If also remember position and letter in the position that differs Gray string and the substring You can see that if we don t need to change letters then the answer for the problem is where So calculate an answer without changes Next iterate through all positions and letters in it What is the new answer for the problem Look at all Gray strings that occurs in our string and touches our fixed position After we change this position the string will not be Gray string anymore so we should subtract the squired length of the string from our answer Look at all Gray strings that differs in exactly fixed position from some substring of the string If we change the letter in the position to the fixed letter all such strings will be added to the answer and we should add their squired lengths Summary with and we need to calculate for each position and letter how the answer differs if we change the letter in the position to the fixed one For that reason we should use offline update on the segment After the values will be calculated we can update our answer with all possible values 
https://codeforces.com//contest/384/problem/A,5717,A,384A,384,A. Coder,Iahub likes chess very much He even invented a new chess piece named Coder A Coder can move and attack one square horizontally or vertically More precisely if the Coder is located at position he can move to or attack positions and Iahub wants to know how many Coders can be placed on an chessboard so that no Coder attacks any other Coder ,"['//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname """"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(""%d"" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(""%d"" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint n;\n\nint main(){\n\t//freopen(fname""in"", ""r"", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\tcin >> n;\n\n\tcout << (n * n / 2) + (n & 1) << ""\\n"";\n\t                        \n\tfor (1, n, i)\n\t{\n\t\tfor (1, n, j)\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\tcout << ""C"";\n\t\t\telse\n\t\t\t\tcout << ""."";\n\t\tcout << ""\\n"";\n\t}\t\t\n    \treturn 0;\n}\n']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Coder.json,https://codeforces.com//blog/entry/10476,Usually when you don t have any idea how to approach a problem a good try is to take some small examples So let s see how it looks for N 1 2 3 4 and 5 With C I noted the coder and with I noted an empty cell By now you should note that answer is N 2 2 when N is even and N 2 1 2 when N is odd Good Generally after you find a possible solution by taking examples you need to prove it then you can code it In order to proof it one needs to do following steps 1 prove you can always build a solution having N 2 2 or N 2 1 2 pieces 2 prove that N 2 2 or N 2 1 2 is maximal number no other bigger solution can be obtained For proof 1 imagine you do coloring like in a chess table The key observation is that by placing all coders on black squares of table no two coders will attack Why Because a piece placed at a black square can attack only a piece placed at a white square Again why Suppose chess table is 1 based Then a square i j is black if and only if i j is even A piece placed at i j can attack i 1 j i 1 j i j 1 or i j 1 The sum of those cells is i j 1 or i j 1 But since i j is even i j 1 and i j 1 are odd hence white cells Depending on parity of N number of black cells is either N 2 2 or N 2 1 2 For N even one can observe that there are equal amount of black and white cells Total number of cells is N 2 so number of black cells is N 2 2 For N odd number of black cells is number of white cells 1 We can imaginary add a white cell to the board Now number of black cells will be also equal to number of white cells so answer is N 2 1 2 2 Two coders attack each other if they are placed at two adjacent cells one black and other one white One needs to prove that adding more than number from 1 will cause this to happen If you place a coder at a white cell you won t be able to place at least one coder at a black cell so in best case you don t win anything by doing this Hence it s optimally to place all coders on same color cells Since cells colored in black are always more or equal to white ones it s always optimally to choose black color But number from 1 is the number of cells having black color Adding one more piece will force you to add it to a white color cell Now you ll have a piece placed at a black colored cell and one placed at an adjacent white colored cell so two coders will attack Hence we can t place more than number from 1 pieces Code http pastie org 8651801 Let s start by saying when array A is sorted 1 is sorted in ascending order when i j and A i A j It is NOT sorted when i j and A i A j 2 is sorted in descending order when i j and A i A j It is NOT sorted when i j and A i A j Iahub can choose 2 indices i j and swap values when A i A j If A i A j he ll ignore operation Hence if he wants to sort all arrays in ascending order he chooses indices i j when i j and perform operation Otherwise in all his operations he uses indices i j such as i j A good operation is when choosing indices i j for ascending order sorting and i j for descending order sorting By doing only good operations after an array is sorted it will stay sorted forever for a sorted array all good operations will be ignored From here we get our first idea use any sorting algorithm you know and sort each array individually When print swaps done by sorting algorithm chosen print them as good operations However sorting each array individually can cause exceeding M M 1 2 operations limit Another possible solution would be after you did an operation to an array to update the operation to all arrays you printed it so it counts to M M 1 2 operations limit making it to all arrays will help sometimes and in worst case it won t change anything However you need to code it very careful in order to make this algorithm pass the time limit Doing this in a contest is not the best idea especially when implementation could be complicated and you have no guarantee it will pass time limit So what else can we do We can think out of box Instead of sorting specific N arrays you can sort all possible arrays of length M Find a sequence of good operations such as anyhow I d choose an array of size M it will get sorted ascending descending I ll show firstly how to do for ascending sorting At position 1 it needs to be minimal element Can we bring minimal element there using good operations Yes Just do 1 2 1 3 1 4 1 M It basically compares element from position 1 to any other element from array When other element has smaller value swap is done After comparing with all M elements minimal value will be at position 1 By now on I ll ignore position 1 and move to position 2 Suppose array starts from position 2 It also needs minimal value from array except value from position 1 which is no longer in array Hence doing 2 3 2 4 2 5 2 M is enough by similar reasons For a position i I need minimal value from array except positions 1 2 i 1 I simply do i i 1 i i 2 i M 1 i M By arriving at position i array will be sorted ascending The algorithm is simply for int i 1 i M i for int j i 1 j M j cout i j n This algorithm does exactly M M 1 2 moves Can you find out how to sort array in descending order Try to think yourself then if you don t get it read next At first position of a descending array it needs to be maximal value Similarly to ascending order we can do 2 1 3 1 4 1 M 1 When I m at a position i and I compare its value to value from position 1 doing operation i 1 checks if A i A 1 If so it swaps A i and A 1 so position 1 will contain now the maximum value so far Similarly to logic from ascending order when I m at position i I need maximum value from array except positions 1 2 i 1 so I do i 1 i i 2 i M i Algorithm is for int i 1 i M i for int j i 1 j M j cout j i n Obviously this does as well M M 1 2 operations worst case All algorithm is about 10 lines of code much better than other solution which requires two manually sorts and also has a chance to exceed TL Code http pastie org 8651809 A good strategy to approach this problem is to think how optimal ordering should look like For this let s calculate for each 2 different cows i and j if cow i needs to be milked before or after cow j As we ll show having this information will be enough to build optimal ordering It is enough to consider only cases when i j case when i j is exactly the opposite of case i j For formality I ll call the optimal ordering permutation and lost milk the cost of permutation So for an optimal permutation P let s take 2 numbers i j and see in which cases i should appear before j in permutation i is before j if P pos1 i P pos2 j and pos1 pos2 otherwise we ll call i is after j We have 4 possible cases 1 A i 0 and A j 0 If we put i before j no additional cost will be added Since j is in right of i and i only adds cost when it finds elements in left of i j won t be affected when processing i When processing j i will be already deleted so it won t affect the cost either Hence we can put i before j and no cost will be added 2 A i 0 and A j 1 Here i and j can appear in arbitrary order in permutation i can be before or after j No matter how we choose them they won t affect each other and cost will remain the same 3 A i 1 and A j 0 As well here i and j can appear in arbitrary order If we choose i first j will be in right of it so cost of permutation will increase by one If we choose j first i will be in left of it so cost of permutation will increase as well No matter what we do in this case cost of permutation increases by 1 4 A i 1 and A j 1 Here i needs to be after j This adds 0 cost Taking i before j will add 1 cost to permutation since j is in right of i Those 4 cases show us how a minimal cost permutation should look In a permutation like this only case 3 contributes to final cost so we need to count number of indices i j such as i j and A i 1 and A j 0 If we show a permutation following all rules exists task reduces to By cases 2 and 3 it follows that in an optimal permutation it only matters order of elements having same value in A We can put firstly all elements having value 0 in A then all elements having value 1 in A We can order elements having value 0 by case 1 and elements having value 1 by case 4 More exactly suppose i1 i2 im and A i1 A i2 A im 0 and j1 j2 jn A j1 A j2 A jn 1 Then a permutation following all rules is i1 i2 im j1 j2 jn This permutation can always be built Hence task reduces to count number of indices i j such as i j and A i 1 and A j 0 We can achieve easily an O N algorithm to do this Let s build an array cnt j number of 0s in range j j 1 N from array A We can easily implement it by going backwards from N to 1 The result is sum of cnt i when A i 1 Code http pastie org 8651813 Our first observation is that if there is a path from 1 1 to N N then the length of path is 2 N 2 Since all paths have length 2 N 2 it follows that if there is at least one path the answer is 2 N 2 and if there isn t the answer is 1 How to prove it Every path from 1 1 to N N has exactly N 1 down directions and exactly N 1 right directions So total length for each path is N 1 N 1 2 N 2 So we reduced our problem to determine if there is at least one path from 1 1 to N N This is the challenging part of this task considering that N 10 9 How would you do it for a decently small N let s say N 10 3 One possible approach would be for each row keep a set of reachable columns We could easily solve this one by doing this if i j denotes element from ith row and jth column then i j is is not reachable if if i j contains a volcano then i j is not reachable Otherwise if at least one of i 1 j and i j 1 is reachable then i j is reachable Otherwise i j is not reachable What s the main problem of this approach It needs to keep track of 10 9 lines and in worst case each of those lines can have 10 9 reachable elements So worst case we need 10 9 10 9 10 18 operations and memory Can we optimize it We can note for beginning that we don t need to keep track of 10 9 lines only m lines are really necessarily We need only lines containing at least one obstacle in worst case when each line contains only one obstacle we need m lines How to solve it this way Suppose line number x contains some obstacles and lines x 1 x 2 x 3 do not contain any obstacle Suppose we calculated set S y cell x y is reachable How would look S1 S2 S3 corresponding to lines x 1 x 2 x 3 For S1 we can reach cell x 1 ymin where ymin is minimal value from set S Then we can also reach ymin 1 ymin 2 N by moving right from x 1 ymin So S1 ymin ymin 1 N How do S2 and S3 look It s easy to see that they ll be as well ymin ymin 1 N So we get following optimization suppose set of lines containing at least one obstacle is L1 L2 Lk We need to run algorithm only for lines L1 L1 1 L2 L2 1 L3 L3 1 Lk Lk 1 It looks like we didn t make anything with this optimization Even if we calculate for m lines each line can still have 10 9 reachable positions So worst case we perform 10 14 operations We need something better for managing information from a line You can note that for a given line y there are a lot of positions having consecutive values There are a lot of positions x y and x y 1 both reachable This should give us following idea what if instead of keeping reachable positions we keep reachable ranges That is for each line x we keep a set of ranges S a b all cells x k with a k b are reachable How many ranges can it be for a line If the line contains m obstacles there are m 1 ranges Suppose for line x all cells are reachable but for line x 1 cells x 1 3 x 1 5 x 1 N 1 are blocked Then the ranges of reachable cells are 1 2 4 4 6 N 2 and N N By now we get worst case m lines and worst case each line having m elements so in worst case we d have to handle m m 10 10 events This may still look too much but happily this bound is over estimated If a line has o obstacles there can be at most o 1 ranges If lines L1 L2 Lk have o1 o2 ok obstacles there ll be at most o1 o2 ok k ranges But o1 o2 ok m and also k is at most m proved above why we re interested in at most m lines so in worst case we get m m 2 m ranges Yaay finally a decent number of states for this problem So we iterate each line we re interested in Let s find set of ranges for this line thinking that all cells from line above are reachable This is easy to do After we get our ranges like all cells from above can be visited let s think how having obstacles above can influence current ranges After adding ranges from above current ranges can t increase obviously they can only decrease remain the same or some of them can become empty So let s take each range a b from current line and see how it will transform after adding ranges from previous line Given range a b it can transform only in a b with a a If a b then obviously range is empty Why second number of range keeps constant Let a smallest reachable column from current line which is in range a b It s enough to check a a as if a b range will be empty It s obviously why we need to keep a smallest value possible a we re interested to keep range as big as possible and as less as we cut from left as big it is Once we ve found a in range a b or a b if range is empty all cells a 1 a 2 b are reachable as well by going right from a so if interval is not empty then second number defining it remains b Next question is how to find a fast enough In order a point a to be reachable on current range it also needs to exist a range on previous line containing it If the range from previous line is pa pb then a needs to follow 3 conditions a minimal such as pa a pb a a What if instead of finding a we find pa pb Then a is max pa a In order a to be as small as possible since a is constant pa needs to be as small as possible So we reduced it to pa minimal pb a a pb a Intervals from previous line are disjoint no 2 intervals cross each other It means that if pb is minimal than pa is minimal too if we increase pb then pa will increase too so it won t be minimal Hence you need to find an interval pa pb such as pb is minimal and pb a Then a is max a pa This is easy to do if we sort all intervals from previous line increasing by second value pb then we binary search for value a Finally after running algorithm for all lines last range from last line has second number N assuming ranges are sorted increasing by second value then there exist a path otherwise there does not exist This algorithm should run O m logm worst case good enough to pass Code http pastie org 8651817 This is kind of task that needs to be break into smaller subproblems that you can solve independently then put them together and get solution Let s define level of a node the number of edges in the path from root to the node Root node 1 is at level 0 sons of root are at level 1 sons of sons of root are at level 2 and so on Now suppose you want to do an operation of type 1 to a node x What nodes from subtree of x will be added val a positive value Obviously x will be first being located at level L Sons of x located at level L 1 will be added val Sons of sons located at level L 2 will be added value val again So nodes from subtree of x located at levels L L 2 L 4 will be added a val and nodes located at levels L 1 L 3 L 5 will be added a val Let s take those values of L modulo 2 All nodes having remainder L modulo 2 will be added a val and nodes having reminder L 1 modulo 2 will be added val In other words for a fixed x at a level L let y a node from subtree of x at level L2 If L and L2 have same parity val will be added to y Otherwise val will be added to y From here we have the idea to split nodes of tree in 2 sets those being located at even level and those being located at odd level What still makes the problem hard to solve The fact that we have a tree If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree problem would be simpler the problem would reduce to add subtract values to all elements of a subarray and query about a current value of an element of array So how can we transform tree to an array such as for a node x all nodes from subtree of x to be a subarray of array The answer is yes We can do this by properties of DFS search Before reading on make sure that you know what is discovery time and finish time in a DFS search Let s build 3 arrays now discover representing nodes in order of their discover times a node is as before in discover as it has a small discover time begin for a node in which time it was discovered and end what s last time of a discovered node before this node finishes For a subtree of x all nodes in the subtree are nodes in discover from position begin x to end x Example suppose you have tree 1 5 1 6 6 7 6 4 4 2 4 3 Discover is 1 5 6 7 4 2 3 begin is 1 6 7 5 2 3 4 end is 7 6 7 7 2 7 4 What s subtree of node 6 elements of discover from position begin 6 to end 6 In this case from 3 to 7 so elements 6 7 4 2 3 You can see it s correct and take more examples if you want Now we reduced problem to you re given an array A you can perform 2 operations 1 increase all elements from a range x y to a value val val can be negative to treat subtractions 2 what s current value of an element from position pos Those who solved Iahub and Xors from my last round CF 198 should probably say they saw something similar before If you didn t solve problem before I encourage you to do it after you solve this one it uses a similar idea to what will follow now Also if you don t know Fenwick trees please read them before moving on An alternative would be for this task using segment trees with lazy update but I see this one more complicated than needed I ll use now a not so common approach when dealing with data structures Instead of keeping in a node the result like you usually do I ll keep just an auxiliary information So what algorithm proposed does Let A an array initially with all elements 0 When you need to update range x y with value val you simply do A x val and A y 1 val When you need to answer a query about position pos you output A 1 A 2 A pos Implemented brute force you get O 1 per update and O N per query However these both are operations supported by a Fenwick tree so you can get O logN per operation It may not be very clear why this algorithm works Let s take a closer look an update needs to add value val only to range x y When you query a position pos let s see if algorithm handles it correctly 1 pos x In this case result must not be affected by my update Since pos x and I only updated 2 values with indices x when doing A 1 A 2 A pos it won t matter at all I did that update at least not for this query 2 x pos y Here for a pos I need to add value val only once We add it only at A x in this way it will be counted once and it will be considered for each elements from range x y since an element at position p from range x y has p x in A 1 A 2 A p I ll have to consider A x 3 pos y Here I don t have to consider the query But it would be considered when processing A x But if I add to A y 1 value val I ll just cancel the value previously added Code actually we use just one Fenwick tree instead of 2 can you think why it works http pastie org 8651824 
https://codeforces.com//contest/724/problem/D,74853,D,724D,724,D. Dense Subsequence,You are given a string consisting of lowercase English letters and the integer One should choose some symbols from the given string so that any contiguous subsegment of length has at least one selected symbol Note that here we choose positions of symbols not the symbols themselves Then one uses the chosen symbols to form All symbols from the chosen position should be used but we are allowed to rearrange them in any order Formally we choose a subsequence of indices The selected sequence must meet the following condition for every such that there must be at least one selected index that belongs to the segment i e there should exist a from to such that Then we take any permutation of the selected indices and form a new string Find the lexicographically smallest string that can be obtained using this procedure ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nchar s[N];\nint m,v[30],n;\n\nint gao(int c) {\n\tint pre=-1,cand=-1,ret=0;\n\trep(i,0,n) {\n\t\tif (s[i]<\'a\'+c) pre=i,cand=i;\n\t\tif (s[i]==\'a\'+c) cand=i;\n\t\tif (i-pre==m) {\n\t\t\tif (cand>pre) {\n\t\t\t\tret++; pre=cand;\n\t\t\t} else return -1;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(""%d"",&m);\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\trep(i,0,n) v[s[i]-\'a\']++;\n\trep(i,0,26) {\n\t\tint c=gao(i);\n\t\tif (c!=-1) {\n\t\t\trep(j,0,i) rep(k,0,v[j]) putchar(\'a\'+j);\n\t\t\trep(k,0,c) putchar(\'a\'+i);\n\t\t\tputs("""");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(0);\n}\n']",,,"['data structures', 'greedy', 'strings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Dense Subsequence.json,https://codeforces.com//blog/entry/47644,It is not hard to see that if we choose some subset of the letters then to achieve lexicographically smallest string you must first write all of the letters then all of the letters b and so on Let s assume that the string in the answer consists only of the letters Then it should be as small of them as possible to get lexicographically smallest string We can check whether it is enough to take only the letters to meet the requirement on the density of the indices in each subsegment of length it has to be at least one letter If this is true we can find the minimum number of letters which will satisfy the density requirement using the greedy algorithm every time we will take the rightmost letter which is separated from the previous one by no more than positions If this is not true then the answer must contain some other letters except for This means that we need to take as much letters as possible So we can take all of them because adding any additional letter will not affect the density requirement Then do the same with the letter bearing in mind that all of the letters is already taken If the letters is not enough then take all of the letters all of the letters and proceed to the next letter and so on 
https://codeforces.com//contest/1997/problem/F,2784499,F,1997F,1997,F. Chips on a Line,You have n chips and you are going to place all of them in one of x points numbered from 1 to x There can be multiple chips in each point After placing the chips you can perform the following four operations in any order any number of times choose a chip in point i ge 3 remove it and place two chips one in i 1 one in i 2 choose two chips in adjacent points i and i 1 remove them and place a new chip in i 2 choose a chip in point 1 and move it to 2 choose a chip in point 2 and move it to 1 Note that the coordinates of the chips you place during the operations cannot be less than 1 but can be greater than x Denote the of chip placement as the number of chips which can be present on the line after you perform these operations starting from the placement you ve chosen For example the of placing two chips in points 3 and one chip in point 5 is 2 because you can reduce the number of chips to 2 as follows choose a chip in point 3 remove it place a chip in 1 and another chip in 2 choose the chips in points 2 and 3 remove them and place a chip in 4 choose the chips in points 4 and 5 remove them and place a chip in 6 You are given three integers n x and m Calculate the number of placements of exactly n chips in points from 1 to x having cost equal to m and print it modulo 998244353 Two placements are considered different if the number of chips in some point differs between these placements ,"['#include <bits/stdc++.h>//#define int li#define f first#define s second\xa0using namespace std;using li = long long;using ld = long double;const int MOD = 998244353;const int N = 1005;\xa0int dp[N][55 * N];\xa0int add(int x, int y){    x += y;\xa0    return (x >= MOD ? x - MOD : x);}\xa0int mul(int x, int y){    return x * 1ll * y % MOD;}\xa0int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);\xa0    int n, x, m;    cin >> n >> x >> m;\xa0    vector <int> F = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};\xa0    dp[0][0] = 1;\xa0    for(int i = 0; i < x; i++)    {        for(int k = 0; k < n; k++)            for(int s = F[i] * k; s >= k; s--)                if(dp[k][s])                    dp[k + 1][s + F[i]] = add(dp[k + 1][s + F[i]], dp[k][s]);    }\xa0    while(F.back() < 1e6)        F.push_back(F.back() + F[F.size() - 2]);\xa0    int ans = 0;\xa0    for(int i = 0; i <= 55 * n; i++)    {        int cur = i, c = 0;\xa0        for(int j = F.size() - 1; j >= 0; j--)            if(cur >= F[j])            {                cur -= F[j];                c++;            }\xa0        if(c == m)            ans = add(ans, dp[n][i]);    }\xa0    cout << ans;}']",,,"['brute force', 'combinatorics', 'dp', 'greedy', 'math']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Chips on a Line.json,https://codeforces.com//blog/entry/132154,The operations described in the statement are kinda similar to the identities for Fibonacci numbers so maybe the solution will be connected to them Let s assign each chip placement a weight if chips are placed in points repeating if multiple chips are in the same position the weight of this placement is where is the th Fibonacci number We can show that two placements can be transformed into each other if and only if their weights are identical First of all the operations described in the statement don t change the weight so two placements with different weights cannot be transformed into each other To show how to transform two placements with identical weight into each other let s bring them into canonical form as follows while there is a chip with coordinate convert it into two chips with coordinates and if all remaining chips are in points and move all chips from to After performing this sequence of actions we will transform a placement of chips into the form all chips are in point and the number of these chips is equal to the weight of the placement And since all operations we apply are invertible for every operation there is an operation which rolls it back we can transform any placement to any other placement with the same weight through this canonical form So instead of counting the placements let s group them according to their weights and work with them For every possible weight of a placement which is an integer from to we need to answer two questions Is it true that the minimum cost of a placement of this weight is exactly How many placements with this weight are there The former is simple this is just checking that the minimum number of Fibonacci numbers used to represent an integer is equal to We can precalculate this minimum number of Fibonacci numbers to represent each integer with a simple dynamic programming The latter is a bit more tricky we need to count the number of ways to represent the given number as a sum of exactly Fibonacci numbers from to where the order of these Fibonacci numbers does not matter There are different ways to calculate it the model solution uses a dynamic programming which uses time and memory Let be the number of ways to partition the integer into Fibonacci numbers Initially we will consider the situation when we can t use any Fibonacci numbers so and everything else is And then we will add Fibonacci numbers one by one so first we will update our dynamic programming in such a way that we can only use then only and or and so on Let s show how to update our dynamic programming when we can use a new number in partitions The simple way to do this is as follows for every iterate on the number of new elements we will use and get a partition of integer into numbers However that is too slow Instead let s iterate on the states of our dynamic programming in ascending order of and in each state add at most one element to the partition so increase by At the first glance it only allows us to use one element equal to however when we consider the state we updated it will already store both the partitions which didn t use elements equal to and the partitions which used at least one element equal to which came from the state and by transitioning from to we will expand all these partitions If the previous paragraph is a bit unclear to you you can try viewing it as a three state dynamic programming of the form let be the number of partitions of into Fibonacci numbers from to where we dropped the third state of our dynamic programming in favor of maintaining only one layer and being more memory efficient 
https://codeforces.com//contest/825/problem/D,114547,D,825D,825,D. Suitable Replacement,You are given two strings and consisting of small Latin letters string can also contain characters of string is calculated by following metric Any two letters can be swapped positions these operations can be performed arbitrary number of times over any pair of positions Among all resulting strings you choose the one with the largest number of occurrences of string is this number of occurrences You should replace all characters with small Latin letters in such a way that the of string is maximal ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <array>\n\nvoid run(std::istream &in, std::ostream &out) {\n    std::string s, t;\n    in >> s >> t;\n    std::array<int, 26> statT = {};\n    for (char c : t) {\n        statT[c - \'a\']++;\n    }\n    std::array<int, 26> statS = {};\n    int empty = 0;\n    for (char c : s) {\n        if (c == \'?\') {\n            empty++;\n        } else {\n            statS[c - \'a\']++;\n        }\n    }\n    int k;\n    for (k = 1; ; k++) {\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += std::max(statT[i] * k - statS[i], 0);\n        }\n        if (res > empty) {\n            k--;\n            break;\n        }\n    }\n    std::string res;\n    for (int i = 0; i < 26; i++) {\n        int d = std::max(statT[i] * k - statS[i], 0);\n        res.append(d, \'a\' + i);\n    }\n    size_t pos = 0;\n    for (char& c : s) {\n        if (c == \'?\') {\n            if (pos < res.size()) {\n                c = res[pos];\n                pos++;\n            } else {\n                c = \'a\';\n            }\n        }\n    }\n    out << s << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']",,,"['binary search', 'greedy', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Suitable Replacement.json,https://codeforces.com//blog/entry/53334,Notice that the order of letters doesn t matter at all depends only on amount of each letter Let be the possibility that string will occur in at least times after replacing all signs and after some swaps If is true then is also true That leads to binary search over the answer Let be the amount of letters in and the amount of letters in is the number of signs is true if If some letter appears in less times than needed then replace some signs with it Answer can be restored greedily by replacing signs with the letters needed Overall complexity where is the size of the alphabet 
https://codeforces.com//contest/1083/problem/A,268421,A,1083A,1083,A. The Fair Nut and the Best Path,The Fair Nut is going to travel to the Tree Country in which there are n cities Most of the land of this country is covered by forest Furthermore the local road system forms a tree connected graph without cycles Nut wants to rent a car in the city u and go by a simple path to city v He hasn t determined the path so it s time to do it Note that chosen path can consist of only one vertex A filling station is located in every city Because of strange law Nut can buy only w i liters of gasoline in the i th city We can assume that he has Each road has a length and as soon as Nut drives through this road the amount of gasoline decreases by length Of course Nut can t choose a path which consists of roads where he runs out of gasoline He can buy gasoline in visited city even in and He also wants to find the maximum amount of gasoline that he can have at the end of the path Help him count it ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nvector <pair <int,ll> > graf[nax];\n\nll dfs(int v, int oj)\n{\n\tll ret=tab[v];\n\twyn=max(wyn, tab[v]);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tll w=dfs(i.first, v)-i.second;\n\t\twyn=max(wyn, ret+w);\n\t\tret=max(ret, w+tab[v]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c);\n\t\tgraf[a].push_back({b, c});\n\t\tgraf[b].push_back({a, c});\n\t}\n\tdfs(1, 0);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. The Fair Nut and the Best Path.json,https://codeforces.com/blog/entry/63753?locale=en,Let s write on edge with length number Let sum on the path be sum of amounts of gasoline which can be bought in cities on this path plus sum of the numbers which were written on its edges If we don t run out of gasoline on some path sum on it will be equal to amount of gasoline at the end of way If we run out of gasoline on a path we can start from the next city after the road where it happened and sum on the path won t decrease So there is a path with maximal sum where we don t run out of gasoline This sum is answer to the problem How to find it Let is maximal sum on vertical way which starts in vertex It is not difficult to calculate using values for children of vertex Every way can be divided to two vertical ways so we can calculate answer by turning over which is the highest vertex of a path and taking the two biggest vertical ways which starts from vertex 
https://codeforces.com//contest/1954/problem/F,2586696,F,1954F,1954,F. Unique Strings,Let s say that two strings a and b are if you can get the string b by cyclically shifting string a For example the strings and are equal while and are not You are given a binary string s of length n Its first c characters are s and its last n c characters are s In one operation you can replace one with Calculate the number of unique strings you can get using no more than k operations Since the answer may be too large print it modulo 10 9 7 ,"['#include<bits/stdc++.h>using namespace std;\xa0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\xa0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\xa0using pii=pair<int,int>;using pll=pair<ll,ll>;\xa0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\xa0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\xa0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\xa0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\xa0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\xa0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\xa0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\xa0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\xa0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << \' \' << p.second;}\xa0#ifdef i_am_noob#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}#else#define bug(...) 777771449#endif\xa0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << \' \';cout << ""\\n"";}template<typename T> void print(T && x) {cout << x << ""\\n"";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\xa0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\xa0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\xa0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\xa0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\xa0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\xa0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\xa0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\xa0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\xa0\xa0\xa0#include <utility>\xa0namespace atcoder {\xa0namespace internal {\xa0// @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;}\xa0// Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;\xa0    // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\xa0    // @return m    unsigned int umod() const { return _m; }\xa0    // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay\xa0        // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }};\xa0// @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;}\xa0// Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n);\xa0// @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};\xa0    // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;\xa0    while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\xa0        // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b\xa0        auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};}\xa0// Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0\xa0#include <cassert>#include <numeric>#include <type_traits>\xa0namespace atcoder {\xa0namespace internal {\xa0#ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>;\xa0template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type;\xa0template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type;\xa0template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type;\xa0#else\xa0template <class T> using is_integral = typename std::is_integral<T>;\xa0template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type;\xa0template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type;\xa0#endif\xa0template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\xa0template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\xa0template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0#include <cassert>#include <numeric>#include <type_traits>\xa0#ifdef _MSC_VER#include <intrin.h>#endif\xa0namespace atcoder {\xa0namespace internal {\xa0struct modint_base {};struct static_modint_base : modint_base {};\xa0template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\xa0}  // namespace internal\xa0template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;\xa0  public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\xa0    static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\xa0    unsigned int val() const { return _v; }\xa0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\xa0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\xa0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\xa0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }\xa0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\xa0  private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;};\xa0template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;\xa0  public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\xa0    dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\xa0    unsigned int val() const { return _v; }\xa0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\xa0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\xa0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\xa0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }\xa0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\xa0  private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\xa0using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>;\xa0namespace internal {\xa0template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\xa0template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\xa0template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\xa0template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\xa0}  // namespace internal\xa0}  // namespace atcoder\xa0using namespace atcoder;\xa0//using mint=modint998244353;using mint=modint1000000007;\xa0template<int mod>struct nCr{    vector<static_modint<mod>> fac,inv,ifac;    void calc(int n){        fac.resize(n+1),inv.resize(n+1),ifac.resize(n+1);        fac[0]=inv[1]=ifac[0]=1;        for(int i=1; i<=n; ++i) fac[i]=fac[i-1]*static_modint<mod>::raw(i);        for(int i=2; i<=n; ++i) inv[i]=inv[mod%i]*static_modint<mod>::raw(mod-mod/i);        for(int i=1; i<=n; ++i) ifac[i]=ifac[i-1]*inv[i];    }    static_modint<mod> C(int n, int m){        if(m<0||m>n) return 0;        return fac[n]*ifac[m]*ifac[n-m];    }};\xa0nCr<1000000007> de;\xa0void ahcorz(){    int n,c,k; cin >> n >> c >> k;    de.calc(n+1);    vv(mint,dp,n+1,n+1);    dp[1][1]=1;    rep(i,2,n+1) rep(j,2,n+1){        dp[i][j]=dp[i][j-1]+dp[i-1][j-1];        if(j-1-c>=1) dp[i][j]-=dp[i-1][j-1-c];    }    per(i,n,0) rep(j,1,n+1) dp[i][j]+=dp[i+1][j];    vc<mint> dp2(n+1);    rep(m,1,n+1) if(n%m==0){        rep(m+1) if(i*(n/m)<=c+k) dp2[m]+=de.C(m,i);        rep(i,1,m+1) if(m+1-i<=c) dp2[m]-=(m+1-i)*dp[iceil(n-c-k,n/m)][i];        bug(m,dp2[m].val());    }    rep(m,1,n+1) if(n%m==0){        rep(i,1,m) if(m%i==0) dp2[m]-=dp2[i];    }    mint res;    rep(m,1,n+1) res+=dp2[m]/m;    print(res.val());}\xa0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}']",,,"['combinatorics', 'dp', 'math']",3100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Unique Strings.json,https://codeforces.com//blog/entry/128421,What s common in all strings we can get each string has no more than ones and at least consecutive ones So let s loosen up our constraints a little and just calculate the number of strings with no more than ones and at least consecutive ones i e this block of ones can be anywhere can even start at the end and continue at the beginning Let s name such strings as Note that the number of unique good strings is exactly equal to the answer of the initial task since we can shift each good string and make it start from the block of ones How to calculate the number of good strings Using Burnside s lemma Since the group of transformations is just a group of cyclic shifts we can calculate the answer as following where is the number of or the number of strings that won t change after a cyclical shift by characters Note that if the string doesn t change while shifting by characters then it means that for all Further investigation reveals that all characters will be split into exactly groups and each group will contain exactly equal characters It means that if then since in both cases we ll get exactly the same group division So we can rewrite the answer as following where is the number of cyclic shifts with and can be easily counted So it s time to calculate for some divisor of It s not hard to see that if then the first characters of will uniquely define the whole string So it s enough to work with only a prefix of length remembering that each character will be copied times Remember that a good string is a string with at most ones and since each character will be copied times we can place at most ones in our prefix or at least zeroes Also since a good string has consecutive ones our prefix should also have consecutive ones including the case where the ones go cyclically starting at the end of the prefix In case if then the whole prefix should consist of ones and it s either possible if or impossible if In case we need to calculate the number of good prefixes that can be described as the cyclic strings of length that has no more than ones and contains consecutive ones Instead of good prefixes let s calculate bad prefixes and subtract them from all possible prefixes prefixes are just strings with at most ones and there are such strings prefixes are cyclic strings with at most ones where all blocks of ones have length less than In order to calculate bad prefixes let s precalc the following dp is the number of strings of length with where all blocks of ones have length less than and the last character of the string is Why did we use the number of zeroes in the state and why did we add the last zero in Because it will help us to calculate dp fast Now if we have value we can add a block of ones and zero to the end of the string and update the value in Note that we are updating a segment of row from to with value we can do it in So we can precalc the whole dp in time Now it s time to calculate the number of bad strings if we iterate over the length of the prefix of ones length of the suffix of ones and the number of zeroes in between we ll get where is the number of ones on prefix is the number of ones on suffix and is the number of zeroes in the middle part Since each bad string will look like ones middle part ending at ones you can place in the middle part at least zeroes and at most zeroes If we play a little with the sum we can simplify it in the following way where is the sum of dp on the row from to and you can take it in if you precalc prefix sums of dp prefixes are just and since can be calculated in the total complexity of is The resulting complexity is that looks like just 
https://codeforces.com//contest/1216/problem/C,416602,C,1216C,1216,C. White Sheet,There is a white sheet of paper lying on a rectangle table The sheet is a rectangle with its sides parallel to the sides of the table If you will take a look from above and assume that the bottom left corner of the table has coordinates 0 0 and coordinate axes are left and bottom sides of the table then the bottom left corner of the white sheet has coordinates x 1 y 1 and the top right x 2 y 2 After that two black sheets of paper are placed on the table Sides of both black sheets are also parallel to the sides of the table Coordinates of the bottom left corner of the first black sheet are x 3 y 3 and the top right x 4 y 4 Coordinates of the bottom left corner of the second black sheet are x 5 y 5 and the top right x 6 y 6 Determine if some part of the white sheet can be seen from the above after the two black sheets are placed The part of the white sheet can be seen if there is at least one point lying the white sheet and of both black sheets ,"['#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\nconst int N=500010;\nconst int M=1000010;\nusing namespace std;\n\nstruct nn{\n\tint xa,xb,ya,yb;\n\tvoid READ(){\n\t\tscanf(""%d%d%d%d"",&xa,&ya,&xb,&yb);\n\t}\n}a[5];\n\nint CV(nn A,nn B){\n\tif(A.xa==B.xa&&A.ya==B.ya&&A.xb==B.xb&&A.yb==B.yb)return 1;\n\treturn 0;\n}\n\nvoid INIT(int i){\n\ta[i].xa=max(a[i].xa,a[1].xa);\n\ta[i].ya=max(a[i].ya,a[1].ya);\n\ta[i].xb=min(a[i].xb,a[1].xb);\n\ta[i].yb=min(a[i].yb,a[1].yb);\n}\n\nint CHK(nn A,nn B){\n\tif(A.xa==B.xa&&A.xb==B.xb)return 1;\n\tif(A.ya==B.ya&&A.yb==B.yb)return 2;\n\treturn 0;\n}\n\nint SOLVE(){\n\tif(CV(a[2],a[1])||CV(a[3],a[1]))return 1;\n\tint na=CHK(a[2],a[1]),nb=CHK(a[3],a[1]);\n\tif(na+nb==0)return 0;\n\tif(na!=nb)return 0;\n\tif(na==2){\n\t\tif(a[2].xa>a[3].xa)swap(a[2],a[3]);\n\t\tif(a[2].xa>a[1].xa||a[3].xb<a[1].xb)return 0;\n\t\tif(a[2].xb>=a[3].xa)return 1;\n\t\treturn 0;\n\t}\n\telse{\n\t\tif(a[2].ya>a[3].ya)swap(a[2],a[3]);\n\t\tif(a[2].ya>a[1].ya||a[3].yb<a[1].yb)return 0;\n\t\tif(a[2].yb>=a[3].ya)return 1;\n\t\treturn 0;\t\n\t}\n}\n\nint main(){\n\trep(i,1,3)a[i].READ();\n\tINIT(2);INIT(3);\n\tif(SOLVE())printf(""NO\\n"");\n\telse printf(""YES\\n"");\n\treturn 0;\n}\n']",,,"['geometry', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. White Sheet.json,https://codeforces.com//blog/entry/69954,There are at least two solution to the problem I ll describe both of them The first solution firstly let s notice that the point we search can have non integer coordinates but if the answer exists then there will be the answer such that its point has at most half integer coordinates So let s multiply all coordinates by two and solve the problem with integer coordinates The second thing is that for some there is only two points we need to check top point with this and bottom point with this The same for some So we can iterate over all possible values of and check if the point lies outside of both black rectangles The same with point Then do the same for points and should be in range and should be in range Time complexity is linear on size of the white rectangle The second solution is most tricky but has the better time complexity Let be the intersection of white rectangle and the first black rectangle the same but with the second black rectangle and be the intersection of and Then it is obvious that the answer exists if and doesn t cover the whole white rectangle Time complexity 
https://codeforces.com//contest/1109/problem/F,298874,F,1109F,1109,F. Sasha and Algorithm of Silence s Sounds,One fine day Sasha went to the park for a walk In the park he saw that his favorite bench is occupied and he had to sit down on the neighboring one He sat down and began to listen to the silence Suddenly he got a question what if in different parts of the park the silence sounds in different ways So it was Let s divide the park into 1 times 1 meter squares and call them and numerate rows from 1 to n from up to down and columns from 1 to m from left to right And now every cell can be described with a pair of two integers x y where x the number of the row and y the number of the column Sasha knows that the level of silence in the cell i j equals to f i j and all f i j form a permutation of numbers from 1 to n cdot m Sasha decided to count how many are there segments of silence Let s take some segment l ldots r Denote S as the set of cells i j that l le f i j le r Then the segment of silence l ldots r is if there is only path between every pair of cells from S path can t contain cells which are not in S In other words set S should look like a tree on a plain Sasha has done this task pretty quickly and called the algorithm algorithm of silence s sounds Time passed and the only thing left from the algorithm is a legend To prove the truthfulness of this story you have to help Sasha and to find the number of segments of silence Two segments l 1 ldots r 1 l 2 ldots r 2 are different if l 1 neq l 2 or r 1 neq r 2 or both at the same time ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=210000;\nstruct node {\n\tnode *s[2],*f;\n\tbool rev;\n\tbool isr() { return !f||(f->s[0]!=this && f->s[1]!=this);}\n\tbool dir() { return f->s[1]==this;}\n\tvoid setc(node *c,int d) { s[d]=c;if (c) c->f=this;}\n\tvoid upd() {\n\n\t}\n\tvoid push() {\n\t\tif (rev) { swap(s[0],s[1]); rep(i,0,2) if (s[i]) s[i]->rev^=1;} rev=0;\n\t}\n}nd[N],*cur;\nstack<node*> sta;\nvoid rot(node *x) {\n\tnode *p=x->f;bool d=x->dir();\n\tif (!p->isr()) p->f->setc(x,p->dir()); else x->f=p->f;\n\tp->setc(x->s[!d],d);x->setc(p,!d);\n\tp->upd();\n}\nvoid splay(node *x) {\n\tnode *q=x;\n\twhile (1) { sta.push(q);if (q->isr()) break; q=q->f; }\n\twhile (!sta.empty()) sta.top()->push(),sta.pop();\n\twhile (!x->isr()) {\n\t\tif (x->f->isr()) rot(x);\n\t\telse if (x->dir()==x->f->dir()) rot(x->f),rot(x);\n\t\telse rot(x),rot(x);\n\t}\n\tx->upd();\n}\nnode *expose(node *x) {\n\tnode *q=NULL;\n\tfor (;x;x=x->f) splay(x),x->s[1]=q,(q=x)->upd();\n\treturn q;\n}\nnode *findr(node *x) {\n\tnode *q=expose(x);\n\twhile (q->s[0]) q=q->s[0];\n\tsplay(q);\n\treturn q;\n}\n\nvoid evert(node *x) { expose(x); splay(x); x->rev^=1; x->push();}\nvoid expose(node *x,node *y) { evert(x); expose(y); splay(x);}\nvoid link(node *x,node *y) {\n//\tprintf(""link %d %d\\n"",x-nd,y-nd);\n\tevert(x); evert(y); x->setc(y,1);}\nvoid cut(node *x,node *y) {\n//\tprintf(""cut %d %d\\n"",x-nd,y-nd);\n\texpose(x,y); x->s[1]=y->f=NULL;}\n\nnamespace segt {\nstruct node {\n\tint fg;\n\tPII s;\n}nd[4*N];\nPII operator + (const PII &a, const PII &b) {\n\tPII c(0,0); c.fi=min(a.fi,b.fi);\n\tif (a.fi==c.fi) c.se+=a.se;\n\tif (b.fi==c.fi) c.se+=b.se;\n\treturn c;\n}\nvoid upd(int p) {\n\tnd[p].s=nd[p+p].s+nd[p+p+1].s;\n}\nvoid setf(int p,int v) {\n\tnd[p].fg+=v;\n\tnd[p].s.fi+=v;\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t\tnd[p].s=mp(0,1);\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nPII query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return query(p+p,l,md,tl,md)+query(p+p+1,md+1,r,md+1,tr);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,int v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n}\n\nconst int M=1010;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint r,c,f[M][M],n;\nPII pos[N];\nVI eg[N];\n\nint main() {\n\tscanf(""%d%d"",&r,&c);\n\tn=r*c;\n\tll ans=0;\n\trep(i,1,r+1) rep(j,1,c+1) {\n\t\tscanf(""%d"",&f[i][j]);\n\t\tpos[f[i][j]]=mp(i,j);\n\t}\n\tint pr=0;\n\tsegt::build(1,1,n);\n\trep(i,1,r*c+1) {\n\t\tif (pr<i) {\n\t\t\tpr=i;\n\t\t\tsegt::modify(1,1,n,i,n,1);\n\t\t}\n\t\twhile (pr<n) {\n\t\t\tint z=pr+1;\n\t\t\tint x=pos[z].fi,y=pos[z].se;\n\t\t\tVI ta;\n\t\t\tvector<node*> cc;\n\t\t\trep(k,0,4) {\n\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\tif (nx>=1&&nx<=r&&ny>=1&&ny<=c&&f[nx][ny]>=i&&f[nx][ny]<z) {\n\t\t\t\t\tta.pb(f[nx][ny]);\n\t\t\t\t\tcc.pb(findr(nd+f[nx][ny]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool succ=1;\n\t\t\trep(k,0,SZ(cc)) rep(j,k+1,SZ(cc)) if (cc[k]==cc[j]) {\n\t\t\t\tsucc=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (succ) {\n\t\t\t\t++pr;\n\t\t\t\tsegt::modify(1,1,n,pr,n,1);\n\t\t\t\trep(k,0,SZ(ta)) {\n\t\t\t\t\tlink(nd+pr,nd+ta[k]);\n\t\t\t\t\teg[ta[k]].pb(pr);\n\t\t\t\t\tsegt::modify(1,1,n,pr,n,-1);\n\t\t\t\t}\n\t\t\t} else break;\n\t\t}\n\t\tPII cc=segt::query(1,1,n,i,pr);\n//\t\tprintf(""gg %d %d\\n"",i,pr);\n//\t\tprintf(""cc %d %d\\n"",cc.fi,cc.se);\n\t\tif (cc.fi==1) ans+=cc.se;\n\t\tsegt::modify(1,1,n,i,n,-1);\n\t\tfor (auto v:eg[i]) {\n\t\t\tsegt::modify(1,1,n,v,n,1);\n\t\t\tcut(nd+i,nd+v);\n\t\t}\n\t}\n\tprintf(""%lld\\n"",ans);\n}\n']",,,"['data structures', 'trees']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Sasha and Algorithm of Silence s Sounds.json,https://codeforces.com//blog/entry/65295,A range a tree if the graph formated by it doen t have any cycle and there is only one connected component in this graph Let s be such minimal position that doen t contain cycles forest It is obvous that Suppose for each we find Then the task now is to count the number of such that graph formated by the range consists of one connected component How to find for each Let s move two pointers and For each moment we store a graph formated by that range If you add to one of the pointers then you should add delete up to edges to the graph Before adding an edge check whether two verticies are in different components not to form a cycle and if they are in one component then it is needed to delete some edges move the first pointer So now we need some structure that can process types of queries online add an edge delete an edge check if two verticies are in one connected component As long as the graph will never have a cycle so it is possible to answer queries using link cut tree for one query It is left to count the number of suitable for each Let s iterate from to and maintain the number of connected components for Then for a fixed you should add to the answer the number of such that and What is going on when we move and add some edge at that moment Let s that edge be and if then you can skip this edge For for which won t change after you add an edge but for two trees merge in one decreases by Let s have a segtree to store then decreasing by is equivalent to adding on a range and the number of on a range is the number of minimums All such queries can be done in The total complexity is 
https://codeforces.com//contest/496/problem/A,19576,A,496A,496,A. Minimum Difficulty,Mike is trying rock climbing but he is awful at it There are holds on the wall th hold is at height off the ground Besides let the sequence increase that is for all from 1 to we will call such sequence a Mike thinks that the track has In other words difficulty equals the maximum distance between two holds that are adjacent in height Today Mike decided to cover the track with holds hanging on heights To make the problem harder Mike decided to remove one hold that is remove one element of the sequence for example if we take the sequence and remove the third element from it we obtain the sequence However as Mike is awful at climbing he wants the final difficulty i e the maximum difference of heights between adjacent holds after removing the hold to be as small as possible among all possible options of removing a hold The first and last holds stay at their positions Help Mike determine the minimum difficulty of the track after removing one hold ,"['#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nint dis[2000];\n\nint main()\n{\n    //freopen(""in.txt"", ""r"", stdin);\n    //freopen(""a.txt"", ""w"", stdout);\n    int n, t, t1, mx = 0;\n    cin >> n;\n    memset(dis, 0, sizeof dis);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> t;\n        if (i>0)    dis[i] = t - t1;\n        if (dis[i] > mx)mx = dis[i];\n        t1 = t;\n    }\n    int mx2 = inf,lo;\n    for (int i = 1; i < n-1; i++)\n    {\n        if (dis[i] + dis[i + 1] < mx2)\n        {\n            mx2 = dis[i] + dis[i + 1];\n            lo = i;\n        }\n    }\n    if (mx2 < mx)cout << mx << endl;\n    else cout << mx2 << endl;\n    //system(""pause"");\n    return 0;\n}']",,,"['brute force', 'implementation', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Minimum Difficulty.json,https://codeforces.com//blog/entry/15208,For every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones print the smallest found answer The solution has complexity It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element whatever is larger thus the difficulty for every option of removing an element can be found in for the total complexity of Any of these solutions or even less efficient ones could pass the tests Challenge suppose we now have to remove exactly arbitrary elements but the first and the last elements have to stay in their places How small the maximal difference between adjacent elements can become Solve this problem assuming the limitations are as follows 
https://codeforces.com//contest/260/problem/D,2468,D,260D,260,D. Black and White Tree,The board has got a painted tree graph consisting of nodes Let us remind you that a non directed graph is called a tree if it is connected and doesn t contain any cycles Each node of the graph is painted black or white in such a manner that there aren t two nodes of the same color connected by an edge Each edge contains its value written on it as a non negative integer A bad boy Vasya came up to the board and wrote number near each node the sum of values of all edges that are incident to this node Then Vasya removed the edges and their values from the board Your task is to restore the original tree by the node colors and numbers ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <initializer_list>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#define DEBUG\n#endif\n\n#define oo 0x3F3F3F3F\n#ifdef DEBUG\n#define cvar(x) cerr << ""<"" << #x << "": "" << x << "">""\n#define evar(x) cvar (x) << endl\ntemplate<class T> void DISP(const char *s, T x, int n) {cerr << ""["" << s << "": ""; for (int i = 0; i < n; ++i) cerr << x[i] << "" ""; cerr << ""]"" << endl;}\n#define disp(x,n) DISP(#x "" to "" #n, x, n)\n#else\n#define cvar(...) ({})\n#define evar(...) ({})\n#define disp(...) ({})\n#endif\n#define fst first\n#define snd second\n#define PB push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef unsigned int uint;\ntypedef long long int64;\ntypedef unsigned long long uint64;\ntypedef long double real;\n\nint64 pow(int64 b, int64 e, int64 m) { int64 t = 1; for (; e; e >>= 1, b = b * b % m) e & 1 ? t = t * b % m : 0; return t; }\ntemplate<class T> inline bool chkmin(T &a, T b) {return a > b ? a = b, true : false;}\ntemplate<class T> inline bool chkmax(T &a, T b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline T sqr(T x) {return x * x;}\ntemplate <typename T> T gcd(T x, T y) {for (T t; x; t = x, x = y % x, y = t); return y; }\n\ntemplate<class edge> struct Graph\n{\n  vector<vector<edge> > adj;\n  Graph(int n) {adj.clear (); adj.resize (n + 5);}\n  Graph() {adj.clear (); }\n  void resize(int n) {adj.resize (n + 5); }\n  void add(int s, edge e){adj[s].push_back (e);}\n  void del(int s, edge e) {adj[s].erase (find (iter (adj[s]), e)); }\n  vector<edge>& operator [](int t) {return adj[t];}\n};\n\nset<pair<int, int>, greater<pair<int, int>>> W, B;\n\nint main ()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""D.in"" , ""r"", stdin);\n\tfreopen(""D.out"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio (false);\n\n\tint n;\n\t\n\tcin >> n;\n\tfor (int i = 1, c, s; i <= n; ++i) {\n\t\tcin >> c >> s;\n\t\tif (c == 0) W.insert(make_pair(s, i));\n\t\telse B.insert(make_pair(s, i));\n\t}\n\tvector<pair<pair<int, int>, int>> ans;\n\n\tpair<int, int> disX, disY;\n\tfor (; !W.empty() && !B.empty(); ) {\n\t\tpair<int, int> x = *W.begin(), y = *B.begin();\n\t\tW.erase(x), B.erase(y);\n\t\t\n\t\tint v = min(x.fst, y.fst);\n\t\tans.push_back(make_pair(make_pair(x.snd, y.snd), v));\n\t\tx.fst -= v, y.fst -= v;\n\t\tif (y.fst || (!x.fst && !y.fst && SZ(W) > SZ(B)))\n\t\t\tB.insert(y), disY = y;\n\t\telse\n\t\t\tW.insert(x), disX = x;\n\t}\n\tfor (auto x : ans)\n\t\tcout << x.fst.fst << "" "" << x.fst.snd << "" "" << x.snd << endl;\n\n\treturn 0; \n}\n']",,,"['constructive algorithms', 'dsu', 'graphs', 'greedy', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Black and White Tree.json,https://codeforces.com//blog/entry/6263,The problem can be solved constructively maintaining the following invariant rule the sum of the white vertices equals to the sum of the black vertices The tree is a bipartite graph so we build bipartite graph with no cycles which will satisfy the conditions of the problem Parts of graph will be black and white vertices On each step we will choose vertex with minimum sum from white and black vertices Then find any vertex of opposite color and add edge with weight and subtract from sum of sum of that is After each step one vertex is deleted That s why there will be no cycles in constructed graph When we delete last vertex of one of colors all other vertices can be joined in any correct way with edges of weight 
https://codeforces.com//contest/1995/problem/C,2772827,C,1995C,1995,C. Squaring,found an array a consisting of integers He likes justice so he wants to make a fair that is make it non decreasing To do that he can perform an on an index 1 le i le n of the array which will replace a i with a i 2 the element at position i with its square For example if a 2 4 3 3 5 3 and chooses to perform an act of justice on i 4 a becomes 2 4 3 9 5 3 What is the minimum number of acts of justice needed to make the array non decreasing ,"['#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/trie_policy.hpp>using namespace std;using namespace __gnu_pbds;typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;#ifndef ONLINE_JUDGE    #include ""debug.h""#else    #define dbg(...) 42    template<typename T>ostream&operator<<(ostream&os,vector<T>&vec){for(signed i=0;i+1<vec.size();++i){os<<vec[i]<<"" "";}if(vec.size()>0)os<<vec.back();return os;}#endif\xa0#define all(x) x.begin(), x.end()#define rall(x) x.rbegin(), x.rend()\xa0template<typename T>istream&operator>>(istream&is,vector<T>&vec){for(T&element:vec){is>>element;}return is;}template<typename T>void chmin(T&x,T y){x=min(x,y);}template<typename T>void chmax(T&x,T y){x=max(x,y);}\xa0#define int int64_t\xa0void test_case(signed ___) {    int n;    cin >> n;    vector<int> ar(n);    cin >> ar;\xa0    int sq = 0;\xa0    auto diff = [&] (int a, int b) {        int mult = 1;        if (a > b) {            swap(a, b);            mult = -1;        }        int res = 0;        while (a < b) {            a *= a;            ++res;        }        return res;    };\xa0    int ans = 0;\xa0    for (int i = 1; i < n; ++i) {        if (ar[i] == 1 && ar[i-1] != 1) {            cout << ""-1\\n"";            return;        }        if (ar[i-1] == 1) continue;        if (ar[i] > ar[i-1]) {            if (sq != 0) {                int d = diff(ar[i-1], ar[i]+1);                sq -= d-1;                sq = max(sq, int64_t(0));            }        }        else {            sq += diff(ar[i-1], ar[i]);        }        ans += sq;    }    cout << ans << ""\\n"";}\xa0signed main(void) {    cin.tie(0)->sync_with_stdio(false);\xa0    signed tt = 1;    cin >> tt;    while (tt--)     test_case(69420);}']",,,"['brute force', 'constructive algorithms', 'greedy', 'implementation', 'math', 'number theory']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Squaring.json,https://codeforces.com//blog/entry/131851,Solution IntegerLet s set to the number of operation we need to apply to index so that But if let s set it to the negative number of times that we can apply the operation to so that still holds Now let s just calculate the prefix sum don t forget to do The sum of values in is the answer 
https://codeforces.com//contest/238/problem/E,2115,E,238E,238,E. Meeting Her,Urpal lives in a big city He has planned to meet his lover tonight The city has junctions numbered from to The junctions are connected by directed streets all the roads have equal length Urpal lives in junction and the date is planned in a restaurant in junction He wants to use public transportation to get to junction There are bus transportation companies At the beginning of every second a bus from the th company chooses a random shortest path between junction and junction and passes through it There might be no path from to In that case no bus will leave from to If a bus passes through a junction where Urpal stands he can get on the bus He can also get o ff the bus at any junction along the path Now Urpal wants to know if it s possible to go to the date using public transportation in a finite amount of time the time of travel is the sum of length of the traveled roads and what is the minimum number of buses he should take in the worst case Note that Urpal doesn t know buses velocity ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 111;\n\nint st, fin, n, m, i, j, k, q, kt;\nint a[N][N], b[N][N][N], g[N][N], ta[N], tb[N], ans[N], v[N];\nvector <int> u[N][N];\n\nint main() {\n//  freopen(""in"", ""r"", stdin);\n//  freopen(""out"", ""w"", stdout);\n  scanf(""%d %d %d %d"", &n, &m, &st, &fin);\n  st--; fin--;\n  memset(a, 0, sizeof(a));\n  for (i=0;i<m;i++) {\n    int qs, qf;\n    scanf(""%d %d"", &qs, &qf);\n    qs--; qf--;\n    a[qs][qf] = 1;\n  }\n  for (i=0;i<n;i++)\n    for (j=0;j<n;j++)\n      if (i == j) g[i][j] = 0; else\n      if (a[i][j]) g[i][j] = 1;\n      else g[i][j] = 424242;\n  for (k=0;k<n;k++)\n    for (i=0;i<n;i++)\n      for (j=0;j<n;j++)\n        if (g[i][k]+g[k][j] < g[i][j]) g[i][j] = g[i][k]+g[k][j];\n  scanf(""%d"", &kt);\n  for (i=0;i<kt;i++) {\n    scanf(""%d %d"", ta+i, tb+i);\n    ta[i]--; tb[i]--;\n    if (g[ta[i]][tb[i]] < 4242) {\n      for (j=0;j<=g[ta[i]][tb[i]];j++) {\n        u[i][j].clear();\n        for (k=0;k<n;k++)\n          if (g[ta[i]][k] == j && g[k][tb[i]] == g[ta[i]][tb[i]]-j) {\n            u[i][j].push_back(k);\n            b[i][j][k] = 1;\n          }\n      }\n    }\n  }\n  for (i=0;i<n;i++) ans[i] = 4242;\n  ans[fin] = 0;\n  int dd = 1, it = 0;\n  while (dd) {\n    dd = 0;\n    it++;\n    for (i=0;i<kt;i++) {\n      if (g[ta[i]][tb[i]] > 4242) continue;\n      v[tb[i]] = ans[tb[i]];\n      for (j=g[ta[i]][tb[i]]-1;j>=0;j--) {\n        int sz = u[i][j].size();\n        for (k=0;k<sz;k++) {\n          int w = u[i][j][k];\n          v[w] = 0;\n          for (q=0;q<n;q++)\n            if (a[w][q] && b[i][j+1][q])\n              if (v[q] > v[w]) v[w] = v[q];\n          if (ans[w] < v[w]) v[w] = ans[w];\n        }\n        if (sz == 1) {\n          int w = u[i][j][0];\n          if (ans[w] == 4242 && v[w] < it) {\n            ans[w] = it;\n            dd = 1;\n          }\n        }\n      }\n    }\n  }\n  printf(""%d\\n"", (ans[st] < 4242) ? (ans[st]) : (-1));\n  return 0;\n}\n']",,,"['dp', 'graphs', 'shortest paths']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Meeting Her.json,https://codeforces.com//blog/entry/5765,Consider a bus passing a shortest path from si to ti There are some points that are necessary to pass in order to obtain a shortest path Firstly we compute them This can be done in O n3 with Floyd Warshall and some processing after that Urpal is sure that a bus from i th company always passes such vertices on his path from si to ti So he can get on a bus from i th company only at vertices the bus surely passes At any moment Urpal s status can be uniquely determined by his position on the map and the bus he s traveling with So we have nk states position bus Our goal is to reach some b state from a a v state which bus v surely passes a source states So let s find all states that can reach a goal state We call such states good states Consider Urpal is at junction x and he s traveling with a bus of type y Let v1 v2 vw be the list of junctions the bus might go on its shortest path from sy to ty And let c1 c2 cl be the list of companies that their bus surely passes junction x excluding y th company For state x y we know we can reach junction b it s a good state if one of the following is true x b the minimum cost of solving the problem will be 0 All states v1 y v2 y and vw y are good states the minimum cost of solving the problem will be the maximum of all these states At least one of states x c1 x c2 or x cl is a good state the minimum cost of solving the problem will be the minimum the good ones plus one At first the only good states we know are states with junction b b Now some new states might have become good states So we add those states to the list of known good states We do this until no state becomes good anymore At the end we print the minimum cost of source states which are good and if they don t exist we print 1 
https://codeforces.com//contest/2025/problem/C,2948773,C,2025C,2025,C. New Game,There s a new game Monocarp wants to play The game uses a deck of n cards where the i th card has exactly one integer a i written on it At the beginning of the game on the first turn Monocarp can take any card from the deck During each subsequent turn Monocarp can take exactly one card that has either the same number as on the card taken on the previous turn or a number that is one greater than the number on the card taken on the previous turn In other words if on the previous turn Monocarp took a card with the number x then on the current turn he can take either a card with the number x or a card with the number x 1 Monocarp can take any card which meets that condition regardless of its position in the deck After Monocarp takes a card on the current turn it is removed from the deck According to the rules of the game the number of distinct numbers written on the cards that Monocarp has taken must not exceed k If after a turn Monocarp cannot take a card without violating the described rules the game ends Your task is to determine the maximum number of cards that Monocarp can take from the deck during the game given that on the first turn he can take any card from the deck ,"['#include <bits/stdc++.h>\xa0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\xa0void solve() {    int n, k;    std::cin >> n >> k;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    std::sort(a.begin(), a.end());        int ans = 0;        for (int i = 0, j = 0; i < n; i++) {        j = std::max(j, i);        while (j + 1 < n && a[j + 1] <= a[j] + 1 && a[j + 1] < a[i] + k) {            j++;        }        ans = std::max(ans, j - i + 1);    }    std::cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']",,,"['binary search', 'brute force', 'greedy', 'implementation', 'sortings', 'two pointers']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. New Game.json,https://codeforces.com//blog/entry/135173,Let s fix the value of the first selected card Then it is optimal to take the cards as follows take all cards with the number then all cards with the number all cards with the number If any of the intermediate numbers are not present in the deck we stop immediately Let s sort the array Then the answer can be found as follows Start at some position and move to the right from it as long as the following conditions are met the difference between the next number and the current one does not exceed otherwise some number between them occurs times and the difference between the next number and is strictly less than otherwise we will take more than different numbers It is easy to notice that as increases the position we reach through this process also increases Therefore we can use two pointers to solve the problem We will maintain a pointer to this position and update the answer at each with the distance between and the pointer Overall complexity for each test case 
https://codeforces.com//contest/1098/problem/E,278464,E,1098E,1098,E. Fedya the Potter,Fedya loves problems involving data structures Especially ones about different queries on subsegments Fedya had a nice array a 1 a 2 ldots a n and a beautiful data structure This data structure given l and r 1 le l le r le n could find the greatest integer d such that d divides each of a l a l 1 a r Fedya really likes this data structure so he applied it to every non empty contiguous subarray of array a put all answers into the array and sorted it He called this array b It s easy to see that array b contains n n 1 2 elements After that Fedya implemented another cool data structure that allowed him to find sum b l b l 1 ldots b r for given l and r 1 le l le r le n n 1 2 Surely Fedya applied this data structure to every contiguous subarray of array b called the result c and sorted it Help Fedya find the lower median of array c Recall that for a sorted array of length k the is an element at position lfloor frac k 1 2 rfloor if elements of the array are enumerated starting from 1 For example the lower median of array 1 1 2 3 6 is 2 and the lower median of 0 17 23 96 is 17 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n\nint n;\nint tab[nax];\n\nll ile[nax];\n\nll m;\n\nvoid rek(int a, int b)\n{\n\tif (a>b)\n\t\treturn;\n\tint s=(a+b)>>1;\n\tvector <pll> l, p;\n\tint x=0;\n\tfor (int i=s; i>=a; i--)\n\t{\n\t\tx=__gcd(x, tab[i]);\n\t\tif (l.empty() || x!=l.back().first)\n\t\t\tl.push_back({x, 0});\n\t\tl.back().second++;\n\t}\n\tx=0;\n\tfor (int i=s; i<=b; i++)\n\t{\n\t\tx=__gcd(x, tab[i]);\n\t\tif (p.empty() || x!=p.back().first)\n\t\t\tp.push_back({x, 0});\n\t\tp.back().second++;\n\t}\n\tfor (pll i : l)\n\t\tfor (pll j : p)\n\t\t\tile[__gcd(i.first, j.first)]+=i.second*j.second;\n\trek(a, s-1);\n\trek(s+1, b);\n}\n\nll brut(ll v)\n{\n\tvll wek;\n\tfor (int i=1; i<nax; i++)\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t\twek.push_back(i);\n\tll ret=0;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=i; j<(int)wek.size(); j++)\n\t\t{\n\t\t\ts+=wek[j];\n\t\t\tif (s>v)\n\t\t\t\tbreak;\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll brut2(ll v)\n{\n\tvll wek;\n\tfor (int i=1; i<nax; i++)\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t\twek.push_back(i);\n\tll ret=0;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=i; j<(int)wek.size(); j++)\n\t\t{\n\t\t\ts+=wek[j];\n\t\t\tif (s>v)\n\t\t\t\tbreak;\n\t\t\tif (wek[j]!=wek[i])\n\t\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll daj(pll v)\n{\n\treturn v.first*v.second;\n}\n\nll sum[nax];\n\nll magiabr(ll lim, ll a, ll m1, ll b, ll m2)\n{\n\tll ret=0;\n\tfor (ll i=1; i<=m1; i++)\n\t\tfor (ll j=1; j<=m2; j++)\n\t\t\tif (i*a+j*b<=lim)\n\t\t\t\tret++;\n\t//~ debug() << imie(ret);\n\treturn ret;\n}\n\nnamespace copypaste\n{\n  void eukl(ll &x, ll &y, ll a, ll b) {\n  if (!a) { x = 0; y = 1; return; }\n  eukl(y, x, b % a, a);\n  x -= y * (b / a);\n}\n\nll euklides(ll y, ll x, ll d)\n{\n\tif (!y)\n\t\treturn d+1;\n\tif (y>=x)\n\t{\n\t\tll dz=y/x;\n\t\tll ile=d*(d+1)/2;\n\t\treturn euklides(y%x, x, d)+dz*ile;\n\t}\n\telse\n\t{\n\t\tll ile=(d*y+x-1)/x;\n\t\tll sum=(d+1)*(ile+1)+1+d/x+((ile*x)/y-d);\n\t\treturn sum-euklides(x, y, ile);\n\t}\n}\n\nll main2(ll a, ll b, ll c)\n{\n\t//~ ll a, b, c;\n\t//~ scanf(""%lld%lld%lld"", &a, &b, &c);\n\tif (a>c || b>c)\n\t{\n\t\t//~ printf(""%lld\\n"", 1+c/a+c/b);\n\t\treturn 1+c/a+c/b;\n\t\t//~ return 0;\n\t}\n\tll g=__gcd(a, b);\n\tc/=g;\n\ta/=g;\n\tb/=g;\n\tll x, y;\n\teukl(x, y, a, b);\n\tx*=(c%a);\n\ty*=(c%a);\n\tx+=(c/a);\n\tassert(x*a+b*y==c);\n\t\n\tif (x<0)\n\t{\n\t\tll ile=(-x-1)/b;\n\t\tx+=ile*b;\n\t\ty-=ile*a;\n\t}\n\tif (x>=0)\n\t{\n\t\tll ile=x/b+1;\n\t\tx-=ile*b;\n\t\ty+=ile*a;\n\t}\n\t\n\tassert(x*a+b*y==c);\n\tassert(x<0);\n\tassert(x+b>=0);\n\t\n\tll p=c/b;\n\t\n\tll wyn=x*(p+1);\n\twyn-=euklides(b, a, y-p-1);\n\twyn+=euklides(b, a, y);\n\t\n\treturn wyn;\n\t//~ printf(""%lld\\n"", wyn);\n\t//~ return 0;\n}\n}//copy\n\nll trzesienie(ll a, ll b, ll c) {\n\tif (c<0) return 0;\n\tif (a>b) swap(a, b);\n\tll p=c/b;\n\tll k=b/a;\n\tll d=(c-p*b)/a;\n\treturn trzesienie(b-k*a, a, c-a*(k*p+d+1))+(p+1)*(d+1)+k*p*(p+1)/2;\n}\n\nll eukl(ll lim, ll a, ll b)\n{\n\tif (lim<0)\n\t\treturn 0;\n\treturn trzesienie(a, b, lim);\n\t//~ if (!a)\n\t\t//~ return lim/b+1;\n\t//~ if (!b)\n\t\t//~ return lim/a+1;\n\t//~ ll ret=0;\n\t//~ for (ll i=0; i*a<=lim; i++)\n\t//~ {\n\t\t//~ for (ll j=0; j*b<=lim; j++)\n\t\t\t//~ if (i*a+j*b<=lim)\n\t\t\t\t//~ ret++;\n\t//~ }\n\t//~ return ret;\n}\n\nll magia(ll lim, ll a, ll x, ll b, ll y)\n{\n\tlim-=a+b;\n\tif (lim<0)\n\t\treturn 0;\n\tif (lim>=(x-1)*a+(y-1)*b)\n\t\treturn x*y;\n\t//~ return eukl(lim, a, x, b, y);\n\treturn eukl(lim, a, b)-eukl(lim-x*a, a, b)-eukl(lim-y*b, a, b)+eukl(lim-x*a-y*b, a, b);\n}\n\nll licz(ll v)\n{\n\t//~ return brut(v);\n\tll ret=0;\n\tfor (int i=1; i<nax; i++)\n\t{\n\t\tif (!ile[i])\n\t\t\tcontinue;\n\t\tll w=min(ile[i], v/i);\n\t\tret+=w*(2*ile[i]-w+1)/2;\n\t}\n\t//~ return ret+brut2(v);\n\tvector<pll> wek;\n\tfor (int i=1; i<nax; i++)\n\t\tif (ile[i])\n\t\t\twek.push_back({i, ile[i]});\n\tint r=wek.size();\n\tint w=0;\n\tll trz=0;\n\tsum[0]=0;\n\tfor (int i=0; i<r; i++)\n\t\tsum[i+1]=sum[i]+wek[i].second;\n\t//~ debug() << ""jade "" << v << "" "" << wek;\n\tfor (int i=0; i<r; i++)\n\t{\n\t\tw=max(w, i);\n\t\tif (w==i)\n\t\t\ttrz=0;\n\t\twhile(w+1<r && trz+daj(wek[w+1])<=v)\n\t\t{\n\t\t\tw++;\n\t\t\ttrz+=daj(wek[w]);\n\t\t}\n\t\tif (w+1!=r)\n\t\t\tret+=magia(v-trz, wek[i].first, wek[i].second, wek[w+1].first, wek[w+1].second);\n\t\t//~ debug() << ""kurwa "" << i << "" "" << w << ""    "" << trz;\n\t\tll ter=trz;\n\t\tfor (int j=w; j>i; j--)\n\t\t{\n\t\t\tter-=daj(wek[j]);\n\t\t\tif (ter+daj(wek[j])+daj(wek[i])<=v)\n\t\t\t{\n\t\t\t\tret+=wek[i].second*(sum[j+1]-sum[i+1]);\n\t\t\t\t//~ debug() << ""hurt "" << wek[i].second*(sum[j+1]-sum[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret+=magia(v-ter, wek[i].first, wek[i].second, wek[j].first, wek[j].second);\n\t\t}\n\t\t\n\t\tif (i+1!=r)\n\t\t\ttrz-=daj(wek[i+1]);\n\t}\n\t//~ assert(ret==brut(v));\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\trek(1, n);\n\t//~ for (int i=1; i<nax; i++)\n\t\t//~ if (ile[i])\n\t\t\t//~ debug() << i << "" "" << ile[i];\n\tll pom=n*(n+1LL)/2;\n\tm=(pom*(pom+1))/2;\n\tm=(m+1)/2;\n\tdebug() << imie(m);\n\tll bsa=1;\n\tll bsb=0;\n\tfor (int i=1; i<nax; i++)\n\t\tbsb+=i*ile[i];\n\t//~ debug() << imie(bsb);\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb)>>1;\n\t\tif (licz(bss)>=m)\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\tprintf(""%lld\\n"", bsa);\n\treturn 0;\n}\n']",,,"['binary search', 'implementation', 'math', 'number theory']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Fedya the Potter.json,https://codeforces.com/blog/entry/64331,There are different values of gcd because if we fix the left bound of a segment and iterate right bound from left bound to the end the gcd stays unchanged or decreases in two or more times We can get a compressed version of array if we compress equal consecutive elements in to pair We can use segment tree to find all segments of equal elements Let s estimate how many segments in array have sum less or equals some If size of array had been small we could have done the 2 pointers technique to do that Unfortunately size of array is However array has a lot of equal elements So the solution is to process a group of equal elements in a fast way Let s fix bounds and in array assume is a sum of elements beetwen and after we have a group of elements with size after we have a group of elements with size Then it is easy to see that our task is to find out how many pairs of integers satisfy the condition This is a standard task where we need to calculate all integer points under a line that can be done with the euclidean algorithm Here the example of a plot of this function To find the median element we can use a binary search with the above function 
https://codeforces.com//contest/2014/problem/C,2892475,C,2014C,2014,C. Robin Hood in Town,There are n people living in the town Just now the wealth of the i th person was a i gold But guess what The richest person has found an extra pot of gold More formally find an a j max a 1 a 2 dots a n change a j to a j x where x is a non negative integer number of gold found in the pot If there are multiple maxima it can be any one of them A person is unhappy if their wealth is of the average wealth text If of the total population n are unhappy Robin Hood will appear by popular demand Determine the minimum value of x for Robin Hood to appear or output 1 if it is impossible text The average wealth is defined as the total wealth divided by the total population n that is frac sum a i n the result is a real number ,"[""#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, m, a[N];void solve(){    cin >> n;    for (int i = 1; i <= n; i++)        cin >> a[i];    sort(a + 1, a + 1 + n);    int l = 0, r = 1e18, ans = -1;    auto check = [&](int x)    {        int sum = x;        for (int i = 1; i <= n; i++)            sum += a[i];        a[n] += x;        int cnt = 0;        for (int i = 1; i <= n; i++)            if (a[i] * 2 * n < sum)                cnt++;        a[n] -= x;        return cnt > n / 2;    };    while (l <= r)    {        int mid = l + r >> 1;        if (check(mid))            r = mid - 1, ans = mid;        else            l = mid + 1;    }    cout << ans << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}""]",,,"['binary search', 'greedy', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Robin Hood in Town.json,https://codeforces.com/blog/entry/134093,If we sort the wealth in increasing order then the j th person must be unhappy for Robin to appear where j n 2 1 if 1 indexing or j n 2 if 0 indexing We need aj s x2 n where s is the original total wealth before x gold from the pot was added Rearranging the equation gives x 2 n aj s Because x is a non negative integer we arrive at the answer max 0 2 n aj s 1 Of course this problem can also be solved by binary search with two caveats First one needs to be careful to avoid comparison between integer and float types as rounding errors could create issues You can always avoid division by 2n by multiplying it out Second one needs to pick the upper limit carefully to ensure it is large enough Note that 2 n max a can serve as the upper limit for the binary search for x because that would push the average to be strictly above 2 max a and everyone except the one with the pot of gold would be unhappy There are 2 edge cases n 1 2 where the condition for Robin can never be reached because the richest person will always be happy at least in this problem though perhaps not IRL ChatGPT struggled to identify these edge cases so it was tempting to leave at least one hidden Following testing we decided to give both in samples to reduce frustration Note Wealth inequality is better measured by the Gini coefficient which is too involved for this problem Our criterion is a crude approximation for the Gini coefficient and is equivalent to setting the mean to median ratio a well known indicator for inequality to 2 For a random distribution this ratio is close to 1 Interestingly this ratio for UK salary distribution is around 1 2 so no Robin yet 
https://codeforces.com//contest/1759/problem/A,1648489,A,1759A,1759,A. Yes-Yes ,You talked to Polycarp and asked him a question You know that when he wants to answer yes he repeats many times in a row Because of the noise you only heard part of the answer some substring of it That is if he answered then you could hear but you couldn t or Determine if it is true that the given string s is a substring of repeated many times in a row ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nvoid solve(){\n    string s;\n    cin >> s;\n    char c = s[0];\n    if(c != \'Y\' and c != \'e\' and c != \'s\') {\n        cout << ""NO"" << endl;\n        return;\n    }\n    for(int i = 1; i < s.size(); ++i) {\n        string str = ""Yes"";\n        int j = 0;\n        for(j = 0; j < 3; ++j) {\n            if(str[j] == s[i - 1]) break;\n        }\n        j = (j + 1) % 3;\n        if(s[i] != str[j]) {\n            cout << ""NO"" << endl;\n            return;\n        }\n    }\n    cout << ""YES"" << endl;\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']",,,"['implementation', 'strings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Yes-Yes .json,https://codeforces.com//blog/entry/109254,Note that it is enough to consider the string where is written times since and our substring has size Then we just use the built in function to find out if our string is a substring of the string 
https://codeforces.com//contest/1692/problem/H,1429122,H,1692H,1692,H. Gambling,Marian is at a casino The game at the casino works like this Before each round the player selects a number between 1 and 10 9 After that a dice with 10 9 faces is rolled so that a random number between 1 and 10 9 appears If the player guesses the number correctly their total money is doubled else their total money is halved Marian predicted the future and knows all the numbers x 1 x 2 dots x n that the dice will show in the next n rounds He will pick three integers a l and r l leq r He will play r l 1 rounds rounds between l and r inclusive In each of these rounds he will guess the same number a At the start before the round l he has 1 dollar Marian asks you to determine the integers a l and r 1 leq a leq 10 9 1 leq l leq r leq n such that he makes the most money at the end Note that during halving and multiplying there is no rounding and there are no precision errors So for example during a game Marian could have money equal to dfrac 1 1024 dfrac 1 128 dfrac 1 2 1 2 4 etc any value of 2 t where t is an integer of any sign ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""H""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        cin >> a;\n        map<int, vector<int>> pos;\n        for(int i = 0; i < n; ++i)\n            pos[a[i]].push_back(i);\n        int bal = -n - 1, left = 0, right = 0, ans = 0;\n        for(auto [c, v] : pos) {\n            int cur = 0, mn = n + 1, mx = -n - 1, prev = 0, curl = 0, l = 0, r = 0;\n            for(auto i : v) {\n                cur += prev - i;\n                prev = i;\n                if (cur < mn) {\n                    mn = cur;\n                    curl = i;\n                }\n                cur++;\n                if (mx < cur - mn) {\n                    mx = cur - mn;\n                    l = curl;\n                    r = i;\n                }\n                prev = i + 1;\n            }\n            if (mx > bal) {\n                left = l;\n                right = r;\n                ans = c;\n                bal = mx;\n            }\n        }\n        cout << ans << \' \' << left + 1 << \' \' << right + 1 << endl;\n    }\n}']",,,"['data structures', 'dp', 'greedy', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\H. Gambling.json,https://codeforces.com//blog/entry/103883,There are several solutions Here is one If we fix the value of then let s make a new array as follows if and otherwise Then the total amount of money earned will just be so we only need to maximize In other words we need to find the maximum sum of a subarray This is a standard problem that can be solved using segment tree Note that we need to iterate over all values of of which there are possibilities So we have to update elements of the segment tree times and query once for each which means overall the solution runs in 
https://codeforces.com//contest/976/problem/C,179787,C,976C,976,C. Nested Segments,You are given a sequence of one dimensional segments numbered through Your task is to find two distinct indices and such that segment lies within segment Segment lies within segment iff and Print indices and If there are multiple answers print any of them If no answer exists print ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\npii in[300050];\nint u[300050];\n\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tu[i] = i;\n\t\tscanf(""%d %d"", &in[i].first, &in[i].second);\n\t}\n\tsort(u + 1, u + N + 1, [](int a, int b) {\n\t\tif (in[a].first != in[b].first) return in[a].first < in[b].first;\n\t\telse return in[a].second > in[b].second;\n\t});\n\n\tint mxp = u[1];\n\tfor (i = 2; i <= N; i++) {\n\t\tif (in[u[i]].second <= in[mxp].second) return !printf(""%d %d\\n"", u[i], mxp);\n\t\telse mxp = u[i];\n\t}\n\treturn !printf(""-1 -1\\n"");\n}']",,,"['greedy', 'implementation', 'sortings']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Nested Segments.json,https://codeforces.com//blog/entry/59195,Let s sort segments firstly by their left border in increasing order and in case of equal by their right border in decreasing order If there is any valid pair then the inner segment will always go after the outer one Now you can go from left to right keep the maximum right border of processed segments and compare it to the current segment Overall complexity 
https://codeforces.com//contest/1367/problem/F1,650998,F1,1367F1,1367,F1. Flying Sort  Easy Version ,You are given an array a of n integers You can perform the following operations on array elements choose any index i 1 le i le n and move the element a i to the of the array choose any index i 1 le i le n and move the element a i to the of the array For example if n 5 a 4 7 2 3 9 then the following sequence of operations can be performed after performing the operation of the first type to the second element the array a will become 7 4 2 3 9 after performing the operation of the second type to the second element the array a will become 7 2 3 9 4 You can perform operations of any type any number of times in any order Find the minimum total number of operations of the first and second type that will make the a array sorted in non decreasing order In other words what is the minimum number of operations that must be performed so the array satisfies the inequalities a 1 le a 2 le ldots le a n ,"[""#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nvoid f()\n{\n\tint n;\n\tcin >> n;\n\tint dp[n + 1] = {0};\n\tint arr[n + 1];\n\tarr[0] = -5;\n\tvector<int> comp;\n\tfl(i,1,n + 1)\n\t{\n\t\tcin >> arr[i];\n\t\tcomp.pb(arr[i]);\n\t}\n\tsort(comp.begin(), comp.end());\n\tcomp.resize(unique(comp.begin(), comp.end()) - comp.begin());\n\tfl(i,1,n + 1)\n\t{\n\t\tarr[i] = upper_bound(comp.begin(), comp.end(),arr[i]) - comp.begin();\n\t}\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 0;\n\t}\n\tint ans = 0;\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 1;\n\t\tfl(j,0,i)\n\t\t{\n\t\t\tif(arr[j] + 1 ==  arr[i])\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i],dp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tans = max(ans,dp[i]);\n\t}\n\tcout << n - ans << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}""]",,,"['dp', 'greedy', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F1. Flying Sort  Easy Version .json,https://codeforces.com//blog/entry/78864,Let s replace each number ai with the number of unique numbers less than ai For example the array a 3 7 1 2 1 3 will be replaced by 2 3 0 1 0 2 Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array a is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let dp i be the maximum length of a subsequence ending in position i To calculate it we will find the closest past position which also has the value a i and the position with value a i 1 lower numbers cannot be used since a i 1 must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
https://codeforces.com//contest/1787/problem/I,1756752,I,1787I,1787,I. Treasure Hunt,Define the of a sequence b 1 b 2 ldots b c as the maximum value of sum limits i 1 q b i sum limits i s t b i where q s t are all integers and s q or t leq q Note that b i 0 when i 1 or i c sum limits i s t b i 0 when s t For example when b 1 2 3 we may have q 0 s 3 t 2 so the value is 0 0 0 And when b 1 2 3 we have q s t 2 so the value is 1 2 3 You are given a sequence a of length n determine the sum of the of all non empty subsegments a l a l 1 ldots a r 1 leq l leq r leq n of the sequence a Print the answer modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(), (a).end()\nconst int mod = 998244353;\nconst int MAXN = 500005;\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint &v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0)\n\t\t\tval += mod;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const mint &a) { return os << a.val; }\n\tfriend bool operator==(const mint &a, const mint &b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint &operator+=(const mint &m) {\n\t\tif ((val += m.val) >= mod)\n\t\t\tval -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &m) {\n\t\tif ((val -= m.val) < 0)\n\t\t\tval += mod;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &m) {\n\t\tval = (lint)val * m.val % mod;\n\t\treturn *this;\n\t}\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1;\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1)\n\t\t\t\tans *= a;\n\t\treturn ans;\n\t}\n\tmint inv() const { return ipow(*this, mod - 2); }\n\tmint &operator/=(const mint &m) { return (*this) *= m.inv(); }\n\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n\toperator int64_t() const { return val; }\n};\n\ntemplate <typename T> struct fenwick {\n\tarray<T, 2> tree[MAXN], total;\n\tint thres;\n\tvoid add(int x, array<T, 2> v) {\n\t\ttotal[0] += v[0];\n\t\ttotal[1] += v[1];\n\t\tfor (int i = x + 1; i < thres + 3; i += i & -i) {\n\t\t\ttree[i][0] += v[0];\n\t\t\ttree[i][1] += v[1];\n\t\t}\n\t}\n\tarray<T, 2> query(int x) {\n\t\tarray<T, 2> ret = {T(0), T(0)};\n\t\tfor (int i = x + 1; i; i -= i & -i) {\n\t\t\tret[0] += tree[i][0];\n\t\t\tret[1] += tree[i][1];\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid clear() {\n\t\ttotal = {T(0), T(0)};\n\t\tfor (int i = 0; i < thres + 3; i++)\n\t\t\ttree[i] = total;\n\t}\n};\n\nfenwick<mint> bit;\nvector<pi> a, b;\n\ntemplate <typename T> T merge(vector<int> &L, vector<int> &R) {\n\ta.resize(sz(L));\n\tb.resize(sz(R));\n\t{\n\t\tlint sum = 0, pmaxsum = -1e18;\n\t\tlint cur = 0, opt = -1e18;\n\t\tfor (int i = 0; i < sz(L); i++) {\n\t\t\tsum += L[i];\n\t\t\tpmaxsum = max(pmaxsum, sum);\n\t\t\tcur = max(cur, 0ll) + L[i];\n\t\t\topt = max(opt, cur);\n\t\t\ta[i] = pi{pmaxsum, opt};\n\t\t}\n\t}\n\t{\n\t\tlint sum = 0, pmaxsum = -1e18;\n\t\tlint cur = 0, opt = -1e18;\n\t\tfor (int i = 0; i < sz(R); i++) {\n\t\t\tsum += R[i];\n\t\t\tpmaxsum = max(pmaxsum, sum);\n\t\t\tcur = max(cur, 0ll) + R[i];\n\t\t\topt = max(opt, cur);\n\t\t\tb[i] = pi{pmaxsum, opt};\n\t\t}\n\t}\n\tT ret = T(0);\n\t{\n\t\tint p = 0;\n\t\tvector<lint> vect;\n\t\tfor (int j = 0; j < sz(b); j++) {\n\t\t\tvect.push_back(b[j][0]);\n\t\t}\n\t\tsort(all(vect));\n\t\tvect.resize(unique(all(vect)) - vect.begin());\n\t\tvector<int> comp(sz(b));\n\t\tfor (int i = 0; i < sz(b); i++) {\n\t\t\tcomp[i] = lower_bound(all(vect), b[i][0]) - vect.begin();\n\t\t}\n\t\tbit.thres = sz(vect);\n\t\tint lo;\n\t\tfor (int i = 0; i < sz(a); i++) {\n\t\t\twhile (p < sz(b) && b[p][1] < a[i][1]) {\n\t\t\t\tbit.add(comp[p], {T(1), T(b[p][0])});\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret += T(p) * T(a[i][0]);\n\t\t\tif (i == 0 || a[i - 1][1] - a[i - 1][0] != a[i][1] - a[i][0]) {\n\t\t\t\tlo = lower_bound(all(vect), a[i][1] - a[i][0]) - vect.begin();\n\t\t\t}\n\t\t\tauto sol1 = bit.query(lo - 1);\n\t\t\tauto sol2 = bit.total;\n\t\t\tret += (sol2[1] - sol1[1]) + T(a[i][1] - a[i][0]) * (sol1[0]);\n\t\t}\n\t\tbit.clear();\n\t}\n\t{\n\t\tswap(a, b);\n\t\tint p = 0;\n\t\tvector<lint> vect;\n\t\tfor (int j = 0; j < sz(b); j++) {\n\t\t\tvect.push_back(b[j][0]);\n\t\t}\n\t\tsort(all(vect));\n\t\tvect.resize(unique(all(vect)) - vect.begin());\n\t\tbit.thres = sz(vect);\n\t\tvector<int> comp(sz(b));\n\t\tfor (int i = 0; i < sz(b); i++) {\n\t\t\tcomp[i] = lower_bound(all(vect), b[i][0]) - vect.begin();\n\t\t}\n\t\tint lo;\n\t\tfor (int i = 0; i < sz(a); i++) {\n\t\t\twhile (p < sz(b) && b[p][1] <= a[i][1]) {\n\t\t\t\tbit.add(comp[p], {T(1), T(b[p][0])});\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret += T(p) * T(a[i][0]);\n\t\t\tif (i == 0 || a[i - 1][1] - a[i - 1][0] != a[i][1] - a[i][0]) {\n\t\t\t\tlo = lower_bound(all(vect), a[i][1] - a[i][0]) - vect.begin();\n\t\t\t}\n\t\t\tauto sol1 = bit.query(lo - 1);\n\t\t\tauto sol2 = bit.total;\n\t\t\tret += (sol2[1] - sol1[1]) + T(a[i][1] - a[i][0]) * (sol1[0]);\n\t\t}\n\t\tbit.clear();\n\t}\n\treturn ret;\n}\n\ntemplate <typename T> T solve(int s, int e, vector<int> &a) {\n\tif (s == e)\n\t\treturn T(a[s]);\n\tvector<int> L, R;\n\tint m = (s + e) / 2;\n\tfor (int i = m; i >= s; i--)\n\t\tL.push_back(a[i]);\n\tfor (int i = m + 1; i <= e; i++)\n\t\tR.push_back(a[i]);\n\tT ret = merge<T>(L, R);\n\treturn ret + solve<T>(s, m, a) + solve<T>(m + 1, e, a);\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tauto maxhap = [&](vector<lint> &a) {\n\t\tint n = sz(a);\n\t\tmint ret = 0;\n\t\tvector<int> l(n, -1), r(n, n);\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twhile (sz(stk) && a[stk.back()] < a[i]) {\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t\tif (sz(stk))\n\t\t\t\t\tl[i] = stk.back();\n\t\t\t\tstk.push_back(i);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\twhile (sz(stk) && a[stk.back()] <= a[i]) {\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t\tif (sz(stk))\n\t\t\t\t\tr[i] = stk.back();\n\t\t\t\tstk.push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret += mint(r[i] - i) * mint(i - l[i]) * mint(a[i]);\n\t\t}\n\t\treturn ret;\n\t};\n\n\tint tc;\n\tcin >> tc;\n\twhile (tc--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &x : a)\n\t\t\tcin >> x;\n\t\tmint ans = solve<mint>(0, n - 1, a);\n\t\tfor (int i = 0; i < n;) {\n\t\t\tif (a[i] >= 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i;\n\t\t\tvector<lint> v;\n\t\t\twhile (j < n && a[j] < 0) {\n\t\t\t\tv.push_back(a[j++]);\n\t\t\t}\n\t\t\tans -= maxhap(v);\n\t\t\ti = j;\n\t\t}\n\t\tvector<lint> b(n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tb[i] = b[i - 1] + a[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans -= mint(n - i + 1) * mint(b[i]);\n\t\t}\n\t\tans -= mint(b[n]);\n\t\tans += maxhap(b);\n\t\tcout << ans << ""\\n"";\n\t}\n}\n']",,,"['data structures', 'divide and conquer', 'two pointers']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\I. Treasure Hunt.json,https://codeforces.com//blog/entry/112009,First we observe that Proof We can proof it by contradiction Define as Suppose when hits the maximum value If otherwise So the above observation is always correct So we can divide the problem into two parts and For it s easy to solve it by using a stack to calculate the prefix maximum value and then calculate the answer And for consider divide and conquer For a part let Define as We want to calculate the sum of satisfied Obviously and it s easy to calculate above four value in the time complexity of We can use binary search to calculate the maximum value So the problem can be solved in the time complexity of But it s not good enough We can solve it in the time complexity of based on the following theorem Define as is non decreasing Proof Actually if we extend the first theorem we will find or If so When we add an element at the back of the sequence If and become at the same time So since Otherwise if while So the theorem always holds in this circumstance If so the theorem holds too Because of the theorem we can replace binary search by two pointers So the final time complexity is 
https://codeforces.com//contest/229/problem/D,1893,D,229D,229,D. Towers,The city of D consists of towers built consecutively on a straight line The height of the tower that goes th from left to right in the sequence equals The city mayor decided to rebuild the city to make it In a city all towers are are arranged in non descending order of their height from left to right The rebuilding consists of performing several perhaps zero operations An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower In other words we can take the tower that stands th and put it on the top of either the th tower if it exists or the th tower of it exists The height of the resulting tower equals the sum of heights of the two towers that were put together After that the two towers can t be split by any means but more similar operations can be performed on the resulting tower Note that after each operation the total number of towers on the straight line decreases by 1 Help the mayor determine the minimum number of operations required to make the city beautiful ,"['/*\n * d.cpp\n *\n *  Created on: 2012-10-1\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = 5000 + 10;\nconst int INF = ~0U >> 1;\n\nint h[MAX_N], n, S[MAX_N];\nint dp[MAX_N][MAX_N]; //k,i\nint val[MAX_N];\nint perm[MAX_N];\n\nbool cmp(int a, int b) {\n\treturn val[a] < val[b];\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> h[i];\n\t}\n//\tn = 5000;\n//\tfor (int i = 0; i < n; ++i) {\n//\t\th[i] = i + 1;\n//\t}\n\tpartial_sum(h, h + n, S);\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tdp[1][i] = S[i];\n\t}\n\tfor (int k = 2; k <= n; ++k) {\n\t\t//dpk,j+Sj\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (dp[k - 1][j] != INF) {\n\t\t\t\tval[j] = dp[k - 1][j] + S[j];\n\t\t\t\tperm[cnt++] = j;\n\t\t\t}\n\t\t}\n\t\tsort(perm, perm + cnt, cmp);\n\t\tint at = 0, mx = -1;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\twhile (at < cnt && val[perm[at]] <= S[j]) {\n\t\t\t\tmx = max(mx, perm[at]);\n\t\t\t\t++at;\n\t\t\t}\n\t\t\tif (mx == -1) {\n\t\t\t\tdp[k][j] = INF;\n\t\t\t} else {\n\t\t\t\tdp[k][j] = S[j] - S[mx];\n\t\t\t}\n\t\t}\n\t\tif (dp[k][n - 1] == INF)\n\t\t\tbreak;\n\t}\n\tfor (int i = n; i >= 0; --i) {\n\t\tif (dp[i][n - 1] != INF) {\n\t\t\tcout << n - i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n']",,,"['dp', 'greedy', 'two pointers']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Towers.json,https://codeforces.com//blog/entry/5437,Let s calculate the dynamics d i k the minimal possible height of the last tower that we can obtain by merging the first left towers into at least towers Assume we already have calculated the dynamics values for the first towers Now we iterate over the all possible tower intervals say the sum in the pending interval is equal to Now we find the greatest such that d i k is not greater than Then we update the value of d j k 1 to the minimum of and d j k 1 Notice that when increases the values d i k do not decrease Because of that we can iterate over intervals in the decreasing value of and corresponding can be found using a single pointer over values of d i k When we arrive in the position during the dynamics some of the d j k values are updated but some are still not Using the same observation that along with the increasing of the values d j k do not decrease as well we can make a single run over the values of in the decreasing order and update the dynamics values as follows d j k min d j k d j k 1 This is done in the beginning of the dynamics iteration In the end we can find the greatest for which there exists an answer among the values of d n k The answer to the problem then is The complexity of the solution is Sample solution http pastie org 4897515 archived copy 
https://codeforces.com//contest/483/problem/B,15994,B,483B,483,B. Friends and Presents,You have two friends You want to present each of them several positive integers You want to present numbers to the first friend and numbers to the second friend Moreover you want all presented numbers to be distinct that also means that no number should be presented to both friends In addition the first friend does not like the numbers that are divisible without remainder by prime number The second one does not like the numbers that are divisible without remainder by prime number Of course you re not going to present your friends numbers they don t like Your task is to find such minimum number that you can form presents using numbers from a set Of course you may choose not to present some numbers at all A positive integer number greater than 1 is called if it has no positive divisors other than 1 and itself ,"['#include <bits/stdc++.h>\nusing namespace std;\nlong long a, b, x, y;\n\nlong long ok(long long n) {\n    long long oa = n / x;\n    long long ob = n / y;\n    long long oab = n / x / y;\n\n    long long com = n - oa - ob + oab;\n    long long ca = n - oa;\n    long long cb = n - ob;\n    return ca >= a && cb >= b && ca + cb - com >= a + b;\n}\n\nint main() {\n    cin >> a >> b >> x >> y;\n    long long l = max(a, b), r = 1e13;\n    while(l < r) {\n        long long m = (l + r) >> 1;\n        if(!ok(m)) l = m + 1;\n        else r = m;\n    }\n    cout << r << endl;\n    return 0;\n}']",,,"['binary search', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Friends and Presents.json,https://codeforces.com//blog/entry/14417,Problem author s solution is using binary search First you can notice that if you can make presents with numbers then you can make presents with numbers too Let be the function returning true or false is it right that you can make presents with numbers Let be the number of numbers divisible by the number of numbers divisible by and number of numbers divisible by and by as soon as and are primes it is equivalent to divisibility by Then to first friend at first we shold give numbers and to second friend numbers Then we must check could we give all other numbers divisible neither by nor by 
https://codeforces.com//contest/777/problem/B,95270,B,777B,777,B. Game of Credit Cards,After the fourth season Sherlock and Moriary have realized the whole foolishness of the battle between them and decided to continue their competitions in peaceful game of Credit Cards Rules of this game are simple each player bring his favourite digit credit card Then both players name the digits written on their cards one by one If two digits are not equal then the player whose digit is smaller gets a flick knock in the forehead usually made with a forefinger from the other player For example if Sherlock s card is and Moriarty s card has number first Sherlock names and Moriarty names so Sherlock gets a flick Then they both digit so no one gets a flick Finally Sherlock names while Moriarty names and gets a flick Of course Sherlock will play honestly naming digits one by one in the order they are given while Moriary as a true villain plans to cheat He is going to name his digits in some other order however he is not going to change the overall number of occurences of each digit For example in case above Moriarty could name and get no flicks at all or he can name and to give Sherlock two flicks Your goal is to find out the minimum possible number of flicks Moriarty will get no one likes flicks and the maximum possible number of flicks Sherlock can get from Moriarty Note that these two goals are different and the optimal result may be obtained by using different strategies ,"[""#include <bits/stdc++.h>\n#define REP(i, a, b) for (register int i = a; i <= b; ++i)\n#define PER(i, a, b) for (register int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n\ninline LL read() {\n\tLL x = 0; int ch = getchar(), f = 1;\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x * f;\n}\n\nint n, cnts[10], cntm[10], ta[10], tb[10];\nstring s;\nint main(){\n\tcin >> n;\n\tcin >> s;\n\tREP(i, 0, n - 1) cnts[s[i] - '0']++;\n\tcin >> s;\n\tREP(i, 0, n - 1) cntm[s[i] - '0']++;\n\t\n\tmemcpy(ta, cnts, sizeof cnts);\n\tmemcpy(tb, cntm, sizeof cntm);\n\n\tint j = 0, ans1 = 0;\n\tREP(i, 0, 9){\n\t\tj = i;\n\t\twhile (ta[i]){\n\t\t\tint dt = min(ta[i], tb[j]);\n\t\t\tta[i] -= dt; tb[j] -= dt;\n\t\t\tif (j == 9 && tb[j] == 0) break;\n\t\t\tif (tb[j] == 0) ++j;\n\t\t}\n\t\tans1 += ta[i];\n\t}\n\n\tmemcpy(ta, cnts, sizeof cnts);\n\tmemcpy(tb, cntm, sizeof cntm);\n\t\n\tint ans2 = 0;\n\tREP(i, 0, 9){\n\t\tj = i + 1;\n\t\twhile (j <= 9 && ta[i]){\n\t\t\tint dt = min(ta[i], tb[j]);\n\t\t\tta[i] -= dt; tb[j] -= dt;\n\t\t\tans2 += dt;\n\t\t\tif (j == 9 && tb[j] == 0) break;\n\t\t\tif (tb[j] == 0) ++j;\n\t\t}\n\t}\n\n\tcout << ans1 << endl << ans2 << endl;\n\treturn 0;\n}""]",,,"['data structures', 'dp', 'greedy', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Game of Credit Cards.json,https://codeforces.com//blog/entry/50670,First we want to consider a strategy that minimizes the amount of flicks Moriarty will receive from Sherlock This is similar to loosing as few rounds as possible He can use digit can be used to not loose against digit digit to not loose against digits and and so on Thus Moriarty should try all digits from to and greedily apply them to Sherlock s digits they can beat If the maximum number of rounds Moriarty can not loose is the answer for the first question is For the second question we need to count the maximum number of rounds Moriarty can win Now digit is useless digit wins against digit digit wins against digits and and so on Thus Moriarty should consider his digits from to and greedily use them to digits they can beat 
https://codeforces.com//contest/1848/problem/E,2046242,E,1848E,1848,E. Vika and Stone Skipping,In Vika s hometown Vladivostok there is a beautiful sea Often you can see kids skimming stones This is the process of throwing a stone into the sea at a small angle causing it to fly far and bounce several times off the water surface Vika has skimmed stones many times and knows that if you throw a stone from the shore perpendicular to the coastline with a force of f it will first touch the water at a distance of f from the shore then bounce off and touch the water again at a distance of f 1 from the previous point of contact The stone will continue to fly in a straight line reducing the distances between the points where it touches the water until it falls into the sea Formally the points at which the stone touches the water surface will have the following coordinates f f f 1 f f 1 f 2 f f 1 f 2 ldots 1 assuming that 0 is the coordinate of the shoreline Once while walking along the embankment of Vladivostok in the evening Vika saw a group of guys skipping stones across the sea launching them from the same point with different forces She became interested in what is the maximum number of guys who can launch a stone with their force f i so that all f i are and all n stones touched the water at the point with the coordinate x assuming that 0 is the coordinate of the shoreline After thinking a little Vika answered her question After that she began to analyze how the answer to her question would change if she multiplied the coordinate x by some positive integers x 1 x 2 x q which she picked for analysis Vika finds it difficult to cope with such analysis on her own so she turned to you for help Formally Vika is interested in the answer to her question for the coordinates X 1 x cdot x 1 X 2 X 1 cdot x 2 X q X q 1 cdot x q Since the answer for such coordinates can be quite large find it modulo M ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int N = 1 << 22;\n\nvector<int> pr;\nint lpd[N], cnt[N], inv[N], cnt2;\nint x, q, mod;\nint mul(int x, int y) {return ((1ll * x) * y) % mod;}\nint Pow(int x, int y) {int res = 1; for (; y; x = mul(x, x), y >>= 1) if (y & 1) res = mul(res, x); return res;}\n\nint val, zero;\n\nvoid ins(int p) {\n    if (p == 2) {\n        cnt2++;\n        return;\n    }\n    int val2 = 1, zero2 = 0;\n    int tmp = cnt[p] + 1;\n    while (tmp % mod == 0) tmp /= mod, zero2++;\n    val2 = tmp % mod;\n    val = mul(val, inv[val2]), zero -= zero2;\n    cnt[p]++;\n    tmp = cnt[p] + 1;\n    val2 = 1, zero2 = 0;\n    while (tmp % mod == 0) tmp /= mod, zero2++;\n    val2 = tmp % mod;\n    val = mul(val, val2), zero += zero2;\n}\n\nvoid frank() {\n    memset(lpd, -1, sizeof lpd);\n    for (int i = 2; i < N; ++i) {\n        if (lpd[i] == -1) lpd[i] = i, pr.pb(i);\n        for (auto p: pr) {\n            if (p * i >= N) break;\n            lpd[p * i] = p;\n            if (i % p == 0) break;\n        }\n    }\n    cin >> x >> q >> mod;\n    inv[1] = 1;\n    for (int i = 2; i < N; ++i) inv[i] = mul(inv[mod % i], mod - mod / i);\n    val = 1, zero = 0;\n    for (auto p: pr) {\n        if (p * p > x) break;\n        while (x % p == 0) {\n            ins(p);\n            x /= p;\n        }\n    }\n    if (x >= N) val = mul(val, 2);\n    else if(x > 1) ins(x);\n    while (q--) {\n        cin >> x;\n        while (x > 1) {\n            int p = lpd[x];\n            ins(p);\n            x /= p;\n        }\n        cout << (zero ? 0 : val) << ""\\n"";\n    }\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while (t--) {\n        frank();\n    }\n}']",,,"['brute force', 'implementation', 'math', 'number theory']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Vika and Stone Skipping.json,https://codeforces.com//blog/entry/118333,The key observation is that the answer for coordinate is the number of odd divisors of Let s prove this Let s see how far a pebble will fly with force which touches the water times If is even then where In this case the condition is necessary which is equivalent to If is odd then where Thus the necessary condition is equivalent to Therefore for each odd divisor of the number we can uniquely associate one of the decomposition options and hence the number of possible answers is exactly equal to the number of different odd divisors in the factorization of the number Using this observation it is easy to obtain the answer We will maintain the power of each prime number in the current coordinate The answer is the product of powers In order to quickly understand how these quantities change we will pre calculate the factorization of all numbers from to Then the query can be processed by quickly recalculating the powers using the pre calculated factorizations 
https://codeforces.com//contest/279/problem/C,2703,C,279C,279,C. Ladder,You ve got an array consisting of integers Also you ve got queries the th query is described by two integers Numbers define a subsegment of the original array that is the sequence of numbers For each query you should check whether the corresponding segment is a ladder A is a sequence of integers such that it first doesn t decrease then doesn t increase In other words there is such integer that the following inequation fulfills Note that the non decreasing and the non increasing sequences are also considered ladders ,"['#pragma comment(linker, ""/STACK:256000000"")\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <stdio.h>\n#include <set>\n#include <map>\n#include <stack>\n#include <fstream>\n#include <deque>\n#include <list>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n\n#define SZ(a) (int(a.size()))\n#define MEM(a, val) memset(a, val, sizeof(a))\n#define MP(a, b) make_pair(a, b)\n#define PB(a) push_back(a)\n#define ALL(a) a.begin(), a.end()\n#define REP(i, n) for(int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))\n#define SQR(a) ((a) * (a))\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef long double dbl;\ntypedef pair<int, int> pii ;\ntypedef vector<int> vint;\ntypedef vector<LL> vLL;\n\nconst int nmax = 100009;\n\nint F1[nmax], F2[nmax];\nint a[nmax];\n\nvoid update(int F[nmax], int i, int val) {\n    for (; i < nmax; i = 2 * i - (i & (i - 1)))\n        F[i] += val;\n}\n\nint get(int F[nmax], int i) {\n    int ans = 0;\n    for (; i > 0; i = i & (i - 1))\n        ans += F[i];\n    return ans;\n}\n\nint main()\n{\n#ifdef _DEBUG\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n    //freopen(""input.txt"", ""r"", stdin);freopen(""output.txt"", ""w"", stdout);\n#endif\n    int n, m;\n    scanf(""%d %d"", &n, &m);\n    REP(i, n) {\n        scanf(""%d"", &a[i]);\n        if (i > 0 && a[i] > a[i - 1])\n            update(F1, i, 1);\n        if (i > 0 && a[i] < a[i - 1])\n            update(F2, i, 1);\n    }\n    REP(step, m) {\n        int L, R;\n        scanf(""%d %d"", &L, &R);\n        --L;\n        --R;\n        int l = L, r = R + 1;\n        while (l < r -1) {\n            int mid = (l + r) / 2;\n            if (get(F2, mid) - get(F2, L) == 0)\n                l = mid;\n            else\n                r = mid;\n        }\n        if (get(F1, R) - get(F1, l) == 0)\n            printf(""Yes\\n"");\n        else\n            printf(""No\\n"");\n    }\n    return 0;\n}\n']",,,"['dp', 'implementation', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Ladder.json,https://codeforces.com//blog/entry/95148,Let s calculate two arrays before answering queries is the smallest index such that is nonincreasing and is the largest index such that is nondecreasing Then for each query we can take and and compare them The answer is Yes iff In other words we are checking if the largest nondecreasing segment from and largest nonincreasing segment from are intersecting To calculate go over from to and maintain largest nonincreasing suffix For do the same in reverse Code 
https://codeforces.com//contest/1183/problem/C,363543,C,1183C,1183,C. Computer Game,Vova is playing a computer game There are in total n turns in the game and Vova really wants to play all of them The initial charge of his laptop battery i e the charge before the start of the game is k During each turn Vova can choose what to do If the current charge of his laptop battery is strictly greater than a Vova can and then the charge of his laptop battery will decrease by a if the current charge of his laptop battery is strictly greater than b b a Vova can his laptop and then the charge of his laptop battery will decrease by b if the current charge of his laptop battery is less than or equal to a and b at the same time then Vova cannot do anything and loses the game Vova wants to complete the game Vova can complete the game if after each of n turns the charge of the laptop battery is Vova has to play Among all possible ways to complete the game Vova wants to choose the one where the number of turns when he is the possible It is possible that Vova cannot complete the game at all Your task is to find out the possible number of turns Vova can make the or report that Vova cannot complete the game You have to answer q independent queries ,"['#include <stdio.h>\n\n#define lli long long int\n\nint main() {\n\tlli q, k, n, a, b, mini, sisa, delta, ans;\n\tscanf(""%lld"", &q);\n\twhile (q--) {\n\t\tscanf(""%lld %lld %lld %lld"", &k, &n, &a, &b);\n\t\tmini = n * b;\n\t\tans = -1;\n\t\tif (k > mini) {\n\t\t\tsisa = k - mini - 1;\n\t\t\tdelta = a - b;\n\t\t\tans = sisa / delta;\n\t\t\tif (n < ans)\n\t\t\t\tans = n;\n\t\t}\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\treturn 0;\n}']",,,"['binary search', 'math']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Computer Game.json,https://codeforces.com//blog/entry/68003,Firstly about the problem description Vova really needs to i e play Exactly turns Among all possible ways to do it he need choose one where the number of turns when he this is the first type turn is Suppose the answer is Then the charge of the battery after turns will be If this value is greater than then the answer is Otherwise we need to replace some turns when Vova with turns when Vova The charge of the battery will increase by avfter one replacement We have to obtain with some replacements The number of turns to do it is equals to where is divided by rounded up If then the answer is Otherwise the answer is 
https://codeforces.com//contest/1453/problem/D,821025,D,1453D,1453,D. Checkpoints,Gildong is developing a game consisting of n stages numbered from 1 to n The player starts the game from the 1 st stage and should beat the stages in increasing order of the stage number The player wins the game after beating the n th stage There is at most one checkpoint on each stage and there is always a checkpoint on the 1 st stage At the beginning of the game only the checkpoint on the 1 st stage is activated and all other checkpoints are deactivated When the player gets to the i th stage that has a checkpoint that checkpoint is activated For each try of a stage the player can either beat the stage or fail the stage If they beat the i th stage the player is moved to the i 1 st stage If they fail the i th stage the player is moved to the most recent checkpoint they activated and they have to beat the stages after that checkpoint again For example assume that n 4 and the checkpoints are on the 1 st and 3 rd stages The player starts at the 1 st stage If they fail on the 1 st stage they need to retry the 1 st stage because the checkpoint on the 1 st stage is the most recent checkpoint they activated If the player beats the 1 st stage they re moved to the 2 nd stage If they fail it they re sent back to the 1 st stage again If they beat both the 1 st stage and the 2 nd stage they get to the 3 rd stage and the checkpoint on the 3 rd stage is activated Now whenever they fail on the 3 rd stage or the 4 th stage after beating the 3 rd stage they re sent back to the 3 rd stage If they beat both the 3 rd stage and the 4 th stage they win the game Gildong is going to build the stages to have equal difficulty He wants you to find any series of stages and checkpoints using at most 2000 stages where the expected number of tries over all stages is exactly k for a player whose probability of beating each stage is exactly cfrac 1 2 ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nvector<int>ans;\nint _;\nll n;\nll f[100];\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(_);\n    f[1]=2;\n    F(i,2,59)f[i]=f[i-1]*2+2;\n\twhile(_--){\n\t\tread(n);\n\t\tif(n&1){\n\t\t\tcout<<-1<<\'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\tans.clear();\n\t\tD(i,59,1){\n\t\t\twhile(n>=f[i]){\n\t\t\t\tn-=f[i];\n\t\t\t\tans.PB(1);\n\t\t\t\tF(j,1,i-1)ans.PB(0);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.size()<<\'\\n\';\n\t\tRep(y,ans)cout<<y<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n    return 0;\n}']",,,"['brute force', 'constructive algorithms', 'greedy', 'math', 'probabilities']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Checkpoints.json,https://codeforces.com//blog/entry/85288,As already explained in the notes and is quite obvious the expected number of tries to beat stage with a checkpoint where stage also has a checkpoint or is the end of the game is What if stage doesn t have a checkpoint and stage has a checkpoint We can think of it like this It takes tries in expectation to get to stage and the player needs to add one more try trying times in total But this also has a probability of to succeed so the expected number of tries to actually get to stage is multiplied by making it in total This can be extended indefinitely Let s say is the expected number of tries to beat consecutive stages with only one checkpoint at the beginning If we extend it to consecutive stages it takes tries If this is not intuitive we can always use Monte Carlo method to simulate how many tries each takes The general term for this sequence is and it is introduced in OEIS A000918 with a similar example As each checkpoint makes the stages after that checkpoint independent of the previous stages we can just add up appropriate s to make it equal to Using means we append the stages in form where the number of s is As every term of the sequence is even the answer is if is odd Otherwise we can show that there always exists an answer for all even There are two simple strategies to make it with at most stages The first strategy is to greedily take the greatest where is the remaining number then append and subtract it from This works because either can be exactly or we can use once and repeat the process with The worst case for this strategy is to use all of and another which sums up to total of stages Another strategy is to use and if bit indexed is Since there can be at most bits the worst case for this strategy is still far less than Time complexity 
https://codeforces.com//contest/283/problem/A,2740,A,283A,283,A. Cows and Sequence,Bessie and the cows are playing with sequences and need your help They start with a sequence initially containing just the number 0 and perform operations Each operation is one of the following Add the integer to the first elements of the sequence Append an integer to the end of the sequence And hence the size of the sequence increases by 1 Remove the last element of the sequence So the size of the sequence decreases by one Note that this operation can only be done if there are at least two elements in the sequence After each operation the cows would like to know the average of all the numbers in the sequence Help them ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nlng val[210000];\nlng add[210000];\nlng sum;\nint n;\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tn=1;\n\t\n\tint tc;\n\tcin>>tc;\n\tforn(qqq,tc){\n\t\tint t;\n\t\tscanf(""%d"",&t);\n\t\tif(t==1){\n\t\t\tint a,x;\n\t\t\tscanf(""%d%d"",&a,&x);\n\t\t\t--a;\n\t\t\tadd[a]+=x;\n\t\t\tsum+=(a+1LL)*x;\n\t\t}else if(t==2){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tval[n]=x;\n\t\t\tadd[n]=0;\n\t\t\tsum+=x;\n\t\t\t++n;\n\t\t}else if(t==3){\n\t\t\t--n;\n\t\t\tsum-=val[n]+add[n];\n\t\t\tadd[n-1]+=add[n];\n\t\t}else exit(12);\n\t\tprintf(""%.15lf\\n"",1.*sum/n);\n\t}\n\n\treturn 0;\n}']",,,"['constructive algorithms', 'data structures', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Cows and Sequence.json,https://codeforces.com//blog/entry/7037,If you know some math you can actually solve this problem in You can show that the answer is p 1 where n is the number of positive integers i less than to n with gcd i n 1 To prove this we first show that there is always at least one primitive root for all primes p This is a fairly well known result so I won t prove it here but you can find many proofs online So now assume g is a primitive root Then the set g g2 gp 1 is congruent to the set 1 2 p 1 Furthermore its not hard to show that gi is a primitive root if and only if gcd i p 1 1 try it hence our formula p 1 n can be computed by getting the prime factors of n since so this gives us our algorithm 
https://codeforces.com//contest/706/problem/B,67824,B,706B,706,B. Interesting drink,Vasiliy likes to rest after a hard work so you may often meet him in some bar nearby As all programmers do he loves the famous drink which can be bought in different shops in the city It s known that the price of one bottle in the shop is equal to coins Vasiliy plans to buy his favorite drink for consecutive days He knows that on the th day he will be able to spent coins Now for each of the days he want to know in how many different shops he can buy a bottle of ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int , int> pi;\ntypedef pair< int , pi> pii;\n\nconst int INF = ~0U >> 1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n\tint ret = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % Mod)\n\t\tif (x & 1) ret = 1ll * ret * a % Mod;\n\treturn ret;\n}\n\nconst int N = 100000 + 10;\n\nint n, a[N], q, x;\n\nint main() {\n\tscanf(""%d"", &n);\n\trep(i, 0, n) scanf(""%d"", a + i);\n\tsort(a, a + n);\n\tscanf(""%d"", &q);\n\trep(i, 0, q) {\n\t\tscanf(""%d"", &x);\n\t\tprintf(""%d\\n"", upper_bound(a, a + n, x) - a);\n\t}\n}']",,,"['binary search', 'dp', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Interesting drink.json,https://codeforces.com//blog/entry/46510,Consider c x the number of stores in which the price per drink is x We calculate this array prefix sum Then the following options 1 If the current amount of money m is larger than the size of the array with the prefix sums than answer is n 2 Otherwise the answer is c m Time Complexity O n q 
https://codeforces.com//contest/1141/problem/F1,316175,F1,1141F1,1141,F1. Same Sum Blocks  Easy ,You are given an array of integers a 1 a 2 dots a n A is a sequence of contiguous consecutive elements a l a l 1 dots a r 1 le l le r le n Thus a block is defined by a pair of indices l r Find a set of blocks l 1 r 1 l 2 r 2 dots l k r k such that They do not intersect i e they are disjoint Formally for each pair of blocks l i r i and l j r j where i neq j either r i l j or r j l i For each block the sum of its elements is the same Formally a l 1 a l 1 1 dots a r 1 a l 2 a l 2 1 dots a r 2 dots a l k a l k 1 dots a r k The number of the blocks in the set is maximum Formally there does not exist a set of blocks l 1 r 1 l 2 r 2 dots l k r k satisfying the above two requirements with k k Write a program to find such a set of blocks ,"[""#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nconst ll MAXN = 2000;\n\nll n, a[MAXN], pr[MAXN];\nmap<ll, vector< pair<ll, ll> >  > mp;\n\nbool cmp(pair<ll, ll> a, pair<ll, ll> b){\n    return a.second < b.second;\n}\n\nvector<pair<ll, ll> > get_ans(vector<pair<ll, ll> > & v){\n    sort(v.begin(), v.end(), cmp);\n    vector<pair<ll, ll> > ans;\n    ll len = -20;\n\n    for(int i = 0; i < v.size(); ++i){\n        if(v[i].first > len){\n            len = v[i].second;\n            ans.pb(v[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n        pr[i] = pr[i-1] + a[i];\n    }\n\n    for(int i = 1; i <= n; ++i){\n        for(int j = i; j <= n; ++j){\n            mp[pr[j] - pr[i-1]].pb({i, j});\n        }\n    }\n\n    ll ans = 0;\n    vector<pair<ll, ll> > vans;\n\n    for(auto i : mp){\n        vector<pair<ll, ll> > v = (i).second;\n        vector<pair<ll, ll> > cur = get_ans(v);\n        if(cur.size() > ans){\n            ans = cur.size();\n            vans = cur;\n        }\n    }\n\n    cout << ans << '\\n';\n    for(auto i : vans){\n        cout << i.first << ' ' << i.second << '\\n';\n    }\n\n    return 0;\n}\n""]",,,['greedy'],1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F1. Same Sum Blocks  Easy .json,https://codeforces.com//blog/entry/66062,Let s x the same sum of blocks in the answer Obviously x can be represented as a sum of some adjacent elements of a i e x a l a l 1 a r for some l and r Iterate over all possible blocks in O n2 and for each sum store all the blocks You can use map int vector pair int int to store blocks grouped by a sum You can do it with the following code Note that blocks are sorted by the right end in each group After it you can independently try each group there are O n2 of them and find the maximal disjoint set of blocks of a group You can do it greedily each time taking into the answer segment with the smallest right end Since in each group they are ordered by the right end you can find the required maximal disjoint block set with one pass Let s assume pp is the current group of blocks they are ordered by the right end then the following code constructs the maximal disjoint set Choose the maximum among maximal disjoint sets for the groups 
https://codeforces.com//contest/516/problem/C,22479,C,516C,516,C. Drazil and Park,Drazil is a monkey He lives in a circular park There are trees around the park The distance between the th tree and st trees is the distance between the th tree and the first tree is The height of the th tree is Drazil starts each day with the The morning run consists of the following steps Drazil chooses two different trees He starts with climbing up the first tree Then he climbs down the first tree runs around the park in one of two possible directions to the second tree and climbs on it Then he finally climbs down the second tree But there are always children playing around some consecutive trees Drazil can t stand children so he can t choose the trees close to children He even can t stay close to those trees If the two trees Drazil chooses are th and th we can estimate the energy the takes to him as Since there are children on exactly one of two arcs connecting and the distance between trees and is uniquely defined Now you know that on the th day children play between th tree and th tree More formally if children play around the trees with indices from range otherwise they play around the trees with indices from Please help Drazil to determine which two trees he should choose in order to consume the most energy since he wants to become fit and cool looking monkey and report the resulting amount of energy for each day ,"['#include <iostream>\nusing namespace std;\nconst int MAX = 200005;\nlong long h[MAX], d[MAX], sum[MAX], n;\nstruct node\n{\n\tlong long mx1, mx2, mx3;\n} seg[4 * MAX];\nnode merge(node x, node y)\n{\n\tnode ans;\n\tans.mx1 = max(x.mx1, y.mx1);\n\tans.mx2 = max(x.mx2, y.mx2);\n\tans.mx3 = max(x.mx3, y.mx3);\n\tans.mx3 = max(ans.mx3, x.mx1 + y.mx2);\n\treturn ans;\n}\nvoid build(int v = 1, int s = 0, int e = n)\n{\n\tif (e - s < 2)\n\t{\n\t\tseg[v].mx1 = 2 * h[s] - sum[s];\n\t\tseg[v].mx2 = 2 * h[s] + sum[s];\n\t\tseg[v].mx3 = -1000000000000000LL;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2;\n\tbuild(2 * v, s, mid);\n\tbuild(2 * v + 1, mid, e);\n\tseg[v] = merge(seg[2 * v], seg[2 * v + 1]);\n}\nnode get(int l, int r, int v = 1, int s = 0, int e = n)\n{\n\tif (l <= s && e <= r)\n\t\treturn seg[v];\n\tif (e <= l || r <= s)\n\t{\n\t\tnode x;\n\t\tx.mx1 = x.mx2 = x.mx3 = -1000000000000000LL;\n\t\treturn x;\n\t}\n\tint mid = (s + e) / 2;\n\tnode x = get(l, r, 2 * v, s, mid);\n\tnode y = get(l, r, 2 * v + 1, mid, e);\n\treturn merge(x, y);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\t::n = 2 * n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i];\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> h[i];\n\tfor (int i = n; i < 2 * n; i++)\n\t{\n\t\th[i] = h[i - n];\n\t\td[i] = d[i - n];\n\t}\n\tfor (int i = 1; i <= 2 * n; i++)\n\t\tsum[i] = sum[i - 1] + d[i - 1];\n\tbuild();\n\twhile (q--)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif (r < l)\n\t\t\tr += n;\n\t\tl--;\n\t\tint len = n - (r - l);\n\t\tcout << get(r, r + len).mx3 << ""\\n"";\n\t}\n\treturn 0;\n}\n']",,,['data structures'],2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Drazil and Park.json,https://codeforces.com/blog/entry/16468,There are many methods for this problem I ll only explain the one that I used Let s split a circle at some point for example between 1 and n and draw a picture twice i e 1 2 3 n 1 2 3 n thus changing the problem from a circle to a line Remember that if two trees Drazil chooses are x and y the energy he consumes is dx dx 1 dy 1 2 hx hy Now rewrite this formula to d1 d2 dy 1 2 hy 2 hx d1 d2 dx 1 Denote d1 d2 dk 1 2 hk as Rk and denote 2 hk d1 d2 dk 1 as Lk When a query about range a b comes The range a b is where Drazil can choose but not the range where the children are playing it s equivalent to querying the maximum value of Lu Rv where u and v are in a b and u v Another important thing is that Lu Rv always bigger than Lv Ru when u v So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up However there is a special case u v but we can handle it by making RMQ find the two maximum values Time Complexity O n m 
https://codeforces.com//contest/2033/problem/A,2975317,A,2033A,2033,A. Sakurako and Kosuke,Sakurako and Kosuke decided to play some games with a dot on a coordinate line The dot is currently located in position x 0 They will be taking turns and On the i th move the current player will move the dot in some direction by 2 cdot i 1 units Sakurako will always be moving the dot in the negative direction whereas Kosuke will always move it in the positive direction In other words the following will happen Sakurako will change the position of the dot by 1 x 1 now Kosuke will change the position of the dot by 3 x 2 now Sakurako will change the position of the dot by 5 x 3 now cdots They will keep on playing while the absolute value of the coordinate of the dot does not exceed n More formally the game continues while n le x le n It can be proven that the game will always end Your task is to determine who will be the one who makes the last turn ,"['#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/rope>\xa0using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;\xa0// /*//                                                //////////**DEFINES - START**//////////\xa0#define ret return#define fi first#define se second#define mp make_pair#define all(x) x.begin(), x.end()#define be(x) x.begin()#define en(x) x.end()#define sz(x) ll(x.size())#define for0(i, n) for (ll   i = 0; i < (n); ++i)#define for1(i, n) for (ll   i = 1; i < (n); ++i)#define rfor0(i, n) for (ll   i = (n) - 1; i >= 0; --i)#define rfor1(i, n) for (ll   i = (n) - 1; i >= 1; --i)#define rep(i, a, n) for (ll   i = a; i < ll(n); ++i)#define rrep(i, a, n) for (ll   i = a - 1; i >= ll(n); --i)#define popcount __builtin_popcount#define popcountll __builtin_popcountll#define fastIO() ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);#define con continue#define pb push_back#define pob pop_back#define deb(x) cout << (#x) << "" is "" << (x) << endl#define ins insert#define len(s) (s).length()#define gi greater<int>()#define gll greater<ll  >()#define gstr greater<string>()#define gpll greater<pair<ll  , ll  >>()#define rast(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))#define rev reverse#define ub upper_bound#define lb lower_bound#define bs binary_search#define rs resize#define last(a) a.back()#define co count#define ba(a) a.back()#define um unordered_map#define rsun(a) a.resize(unique(a.begin(), a.end())-a.begin())#define endl \'\\n\'#ifdef OG_Matveychick1bool local = true;#elsebool local = false;#endif\xa0//                                                \\\\\\\\\\\\\\\\\\\\**DEFINES - END**\\\\\\\\\\\\\\\\\\\\// */\xa0// /*//                                                //////////**TYPEDEFS - START**//////////\xa0typedef vector<int> vi;typedef vector<vi> vvi;typedef vector<char> vc;typedef pair<int, int> pii;typedef vector<pii> vpii;typedef vector<string> vs;typedef long long ll;typedef unsigned long long ull;typedef vector<ull> vull;typedef pair<ll, ll> pll;typedef vector<ll> vll;typedef vector<pll> vpll;typedef pair<double, double> pdd;typedef double ld;typedef double D;typedef vector<ld> vld;typedef vector<pair<ld, ld>>        vpld;typedef string str;typedef set<ll> sll;typedef set<int> si;typedef set<str> ss;typedef set<pii> spii;typedef multiset<int> msi;typedef multiset<ll> msll;typedef multiset<str> mss;typedef multiset<pii> mspii;typedef multiset<pll> mspll;typedef map<str, str> mps;typedef map<int, int> mpi;typedef map<ll, ll> mpll;typedef map<int, vi> mpvi;typedef map<int, vll> mpvll;typedef map<char, int> mpci;typedef multimap<ll, ll> mmpll;typedef multimap<str, str> mmps;typedef multimap<int, int> mmpi;typedef vector<vector<int>> vvi;typedef vector<vector<ll>> vvll;typedef vector<vector<long double>> vvld;typedef vector<vvi> vvvi;typedef vector<vector<char>> vvc;typedef vector<vs> vvs;typedef vector<D> vD;typedef set<pair<ll, ll>>        spll;typedef pair<ull, ull> pull;typedef vector<pull> vpull;typedef vector<bool> vb;typedef vector<vb> vvb;typedef set<char> sc;typedef queue<int> qi;typedef queue<ll> qll;typedef queue<bool> qb;typedef vector<sll> vsll;typedef queue<pair<ll, ll>>        qpll;typedef vector<vector<pair<int, int>>>        vvpii;typedef vector<vector<pair<ll, ll>>>        vvpll;typedef vector<spll> vspll;typedef multiset<char> msc;typedef queue<str> qs;typedef vector<set<int>> vsi;typedef priority_queue<ll> pqll;typedef vector<vsll> vvsll;typedef pair<ld, ld> pld;typedef vector<vvll> vvvll;typedef set<ld> sld;typedef vector<vpld> vvpld;typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_set;typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_multiset;\xa0//                                                \\\\\\\\\\\\\\\\\\\\**TYPEDEFS - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// /*//                                                //////////**CONSTANTS - START**//////////\xa0constexpr long double pi = 3.141592653589793238462643383279;const ll mod1 = 1e9 + 7;const ll mod2 = 998244353;const ll MAXLL = 9223372036854775807;//const ll MAXINT = 2147483647;const long double eps = 1e-9;\xa0//                                                \\\\\\\\\\\\\\\\\\\\**CONSTANTS - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// /*//                                                //////////**TEMPLATES - START**//////////\xa0\xa0template<typename T>istream &operator>>(istream &in, vector<T> &a) {    for (T &i : a) in >> i;    return in;}\xa0template<typename T1, typename T2>istream &operator>>(istream &in, pair<T1, T2> &a) {    in >> a.fi >> a.se;    return in;}\xa0template<typename T1, typename T2>ostream &operator<<(ostream &out, pair<T1, T2> &a) {    out << a.fi << "" "" << a.se;    return out;}\xa0template<typename T1, typename T2>istream &operator>>(istream &in, vector<pair<T1, T2>>\xa0&a) {    for (        pair<T1, T2> &i            : a)        in >> i.fi >> i.                se;    return            in;}\xa0template<typename T>ostream &operator<<(ostream &out, const vector<T> &a) {    for (auto i : a) {        out << i << "" "";    }    return out;}\xa0template<typename T1, typename T2>ostream &operator<<(ostream &out, vector<pair<T1, T2>>\xa0&a) {    for (        pair<T1, T2> i            : a)        out << i.fi << "" "" << i.se <<            endl;    return            out;}\xa0template<typename T1>ostream &operator<<(ostream &out, vector<vector<T1>> &a) {    for (vector<T1> i : a) {        for (T1 j : i) out << j << "" "";        out << endl;    }    return out;}\xa0template<typename T1, typename T2>inline T1 min(T1 a, T2 b) {    b = (T1) b;    return a > b ? b : a;}\xa0template<typename T1, typename T2>inline T1 max(T1 a, T2 b) {    b = (T1) b;    return a > b ? a : b;}\xa0template<typename T1, typename T2>inline void amin(T1 &a, T2 b) {    a = min(a, b);}\xa0template<typename T1, typename T2>inline void amax(T1 &a, T2 b) {    a = max(a, b);}\xa0\xa0//                                                \\\\\\\\\\\\\\\\\\\\**TEMPLATES - END**\\\\\\\\\\\\\\\\\\\\// */\xa0\xa0// This bear is a good alternative to duck!!!/*    ????      ??????  ??????????????????? ????????????????  ??????   ???????????  ??????  ???????????? ?? ??????????????????   ??????????????? ?   ?????????????????   ???????   ???    ??    ????  ??????????     ????     ?? ???   ???????????? ?????  ???????????????????? ????????   ??  ??????? ???????         ????? */\xa0\xa0double getTime() {    return clock() / (double) CLOCKS_PER_SEC;}\xa0\xa0mt19937_64 rn(chrono::steady_clock::now().time_since_epoch().count());//mt19937_64 rn(4);\xa0ll rnd(ll l, ll r) {    ll a = rn() % (r - l + 1) + l;    return a;}\xa0void solve();\xa0ll T = 1;\xa0signed main(int argc, char **argv) {    setlocale(LC_ALL, ""RUS"");    fastIO()    cout.precision(12);    cout << fixed;    if (local && argc == 1) {        freopen(""input.txt"", ""r"", stdin);//        freopen(""002.out"", ""w"", stdout);    }    cin >> T;    while (T--) {        solve();    }    if (local && argc == 1) {        cout << endl << fixed << ""time = "" << getTime();    }    return 0;}\xa0\xa0/*    ___        __              __   ______          __        _____ __             __          __  __   /   | _____/ /___  ______ _/ /  / ____/___  ____/ /__     / ___// /_____ ______/ /______   / / / /__  ________  / /| |/ ___/ __/ / / / __ `/ /  / /   / __ \\/ __  / _ \\    \\__ \\/ __/ __ `/ ___/ __/ ___/  / /_/ / _ \\/ ___/ _ \\ / ___ / /__/ /_/ /_/ / /_/ / /  / /___/ /_/ / /_/ /  __/   ___/ / /_/ /_/ / /  / /_(__  )  / __  /  __/ /  /  __//_/  |_\\___/\\__/\\__,_/\\__,_/_/   \\____/\\____/\\__,_/\\___/   /____/\\__/\\__,_/_/   \\__/____/  /_/ /_/\\___/_/   \\___/*/\xa0\xa0\xa0\xa0void solve() {    ll n;    cin >> n;    cout << (n % 2 ? ""Kosuke"" : ""Sakurako"") << endl;}']",,,"['constructive algorithms', 'implementation', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Sakurako and Kosuke.json,https://codeforces.com//blog/entry/135520,For this task we could just brute force the answer by repeatedly adding or substracting the odd numbers from the initial position This would result in time complexity This is sufficient enough 
https://codeforces.com//contest/1393/problem/B,693071,B,1393B,1393,B. Applejack and Storages,This year in Equestria was a year of plenty so Applejack has decided to build some new apple storages According to the advice of the farm designers she chose to build two storages with non zero area one in the shape of a square and another one in the shape of a rectangle which possibly can be a square as well Applejack will build the storages using planks she is going to spend exactly one plank on each side of the storage She can get planks from her friend s company Initially the company storehouse has n planks Applejack knows their lengths The company keeps working so it receives orders and orders the planks itself Applejack s friend can provide her with information about each operation For convenience he will give her information according to the following format x the storehouse received a plank with length x x one plank with length x was removed from the storehouse it is guaranteed that the storehouse had some planks with length x Applejack is still unsure about when she is going to order the planks so she wants to know if she can order the planks to build rectangular and square storages out of them after every event at the storehouse Applejack is busy collecting apples and she has completely no time to do the calculations so she asked you for help We remind you that all four sides of a square are equal and a rectangle has two pairs of equal sides ,"['#include <bits/stdc++.h>\nusing namespace std;\n\npriority_queue <int> pq, buang;\nint n, q, a, a1, a2, a3, ct[100010];\nchar c;\n\ninline void buy(int x) {\n\tif (ct[x] > 0) buang.push(ct[x]);\n\tct[x]++;\n\tpq.push(ct[x]);\n}\n\ninline void sell(int x) {\n\tbuang.push(ct[x]);\n\tct[x]--;\n\tif (ct[x] > 0) pq.push(ct[x]);\n}\n\ninline void reset() {\n\twhile (!buang.empty() && pq.top() == buang.top()) {\n\t\tpq.pop();\n\t\tbuang.pop();\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a;\n\t\tbuy(a);\n\t}\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> c >> a;\n\t\tif (c == \'+\') buy(a);\n\t\telse sell(a);\n\t\treset();\n\t\tif (!pq.empty()) {\n\t\t\ta1 = pq.top();\n\t\t\tpq.pop();\n\t\t}\n\t\treset();\n\t\tif (!pq.empty()) {\n\t\t\ta2 = pq.top();\n\t\t\tpq.pop();\n\t\t}\n\t\treset();\n\t\tif (!pq.empty()) {\n\t\t\ta3 = pq.top();\n\t\t\tpq.pop();\n\t\t}\n\t\tif (a1 >= 4 && ((a1-4)/2 + a2/2 + a3/2) >= 2) {\n\t\t\tcout << ""YES\\n"";\n\t\t} else {\n\t\t\tcout << ""NO\\n"";\n\t\t}\n\t\tif (a1 > 0) pq.push(a1);\n\t\tif (a2 > 0) pq.push(a2);\n\t\tif (a3 > 0) pq.push(a3);\n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'data structures', 'greedy', 'implementation']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Applejack and Storages.json,https://codeforces.com//blog/entry/81161,Let s maintain the array in it we are going to store the number of planks for each length Let s note that to be able to build a square and a rectangle we need to have four planks of the same length and also two pairs of planks of the same length To check it we can maintain two values and Then you will be able to build a square and a rectangular storage if and The first constraint satisfies the requirement about a square you should have planks of some length and the second constraint satisfies the requirement about a rectangle two pairs of the same length should be used and also two pairs are already used in the square 
https://codeforces.com//contest/956/problem/C,168081,C,956C,956,C. Riverside Curio,Arkady decides to observe a river for consecutive days The river s water level on each day is equal to some real value Arkady goes to the riverside each day and makes a mark on the side of the channel at the height of the water level but if it coincides with a mark made before no new mark is created The water does not wash the marks away Arkady writes down the number of marks strictly above the water level each day on the th day this value is equal to Define as the number of marks strictly under the water level on the th day You are to find out the minimum possible sum of over all days There are no marks on the channel before the first day ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 100100;\nint n;\nint a[N];\nint b[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = a[i] + 1;\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = max(b[i], b[i - 1]);\n\tfor (int i = n - 2; i >= 0; i--)\n\t\tb[i] = max(b[i], b[i + 1] - 1);\n\t\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans += b[i] - a[i] - 1;\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']",,,"['data structures', 'dp', 'greedy', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Riverside Curio.json,https://codeforces.com//blog/entry/58544,First note that d i d i 1 m i 1 m i 0 or 1 The only condition is that d i 0 For each day from 2 to n greedily choose 0 Now at some day i in the future maybe d i turns out to be negative In this case we need to go back and change our choice from 0 to 1 on exactly d i days What happens if I change the choice for day j i from 0 to 1 I get a 1 to all d k s t j k i So it s easy to see that if I need to overturn a choice I should do so for the latest day on which I made a 0 choice That means that every time I make a 0 choice I can just push the index in a stack and anytime when d i 0 I can pop from the stack exactly d i times and add i stack top 1 to the answer Link 36588535 
https://codeforces.com//contest/1535/problem/E,1005286,E,1535E,1535,E. Gold Transfer,You are given a rooted tree Each vertex contains a i tons of gold which costs c i per one ton Initially the tree consists only a root numbered 0 with a 0 tons of gold and price c 0 per ton There are q queries Each query has one of two types Add vertex i where i is an index of query as a son to some vertex p i vertex i will have a i tons of gold with c i per ton It s guaranteed that c i c p i For a given vertex v i consider the simple path from v i to the root We need to purchase w i tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy x tons of gold in some vertex v the remaining amount of gold in it decreases by x of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst int LOG = 19;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int q, a0, c0;\n  cin >> q >> a0 >> c0;\n  vector<int> A(1), C(1);\n  A[0] = a0;\n  C[0] = c0;\n  int N = 1;\n  vector<int> d(1, 0);\n  vector<int> P(1, -1);\n  vector<vector<int>> pp(LOG, vector<int>(1, -1));\n  vector<int> id(q + 1, -1);\n  id[0] = 0;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 1){\n      id[i + 1] = N;\n      int p, a, c;\n      cin >> p >> a >> c;\n      p = id[p];\n      P.push_back(p);\n      A.push_back(a);\n      C.push_back(c);\n      int d2 = d[p] + 1;\n      d.push_back(d2);\n      pp[0].push_back(p);\n      for (int j = 0; j < LOG - 1; j++){\n        if (pp[j][N] == -1){\n          pp[j + 1].push_back(-1);\n        } else {\n          pp[j + 1].push_back(pp[j][pp[j][N]]);\n        }\n      }\n      N++;\n    }\n    if (t == 2){\n      int v, w;\n      cin >> v >> w;\n      v = id[v];\n      if (A[v] == 0){\n        cout << 0 << ' ' << 0 << endl;\n      } else {\n        int p = v;\n        for (int j = LOG - 1; j >= 0; j--){\n          int p2 = pp[j][p];\n          if (p2 != -1){\n            if (A[p2] > 0){\n              p = p2;\n            }\n          }\n        }\n        int D = d[v] - d[p];\n        int ans1 = 0;\n        long long ans2 = 0;\n        for (int j = D; j >= 0; j--){\n          int v2 = v;\n          for (int k = 0; k < LOG; k++){\n            if ((j >> k & 1) == 1){\n              v2 = pp[k][v2];\n            }\n          }\n          int a = min(A[v2], w);\n          ans1 += a;\n          ans2 += (long long) C[v2] * a;\n          w -= a;\n          A[v2] -= a;\n          if (w == 0){\n            break;\n          }\n        }\n        cout << ans1 << ' ' << ans2 << endl;\n      }\n    }\n  }\n}""]",,,"['binary search', 'data structures', 'dp', 'greedy', 'interactive', 'trees']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Gold Transfer.json,https://codeforces.com//blog/entry/91481,Note that for each vertex So if we consider a path from some vertex to the closer you are to the cheaper the cost In other words it s always optimal to choose the highest vertex on the path with Suppose we can find such vertex for a given How many times we will repeat this search operation If we need to buy tons and has tons then it s optimal to buy tons in After we buy tons either becomes or becomes Since for each vertex can become equal to zero at most once and since after is zero we stop buying then there will be searches in total The next question is how to find efficiently for a given Consider the path from to some vertex Since we prefer to buy from higher vertices all empty vertices on this path will form some prefix of it possibly empty prefix So we can make some sort of binary search to find the first non empty vertex But instead of binary search we will use binary lifting technique If we know for each which vertex on the path from to on distance from then we can efficiently jump up the path Let s firstly jump at distance if then we jump too high let s not jump But if then we can safely jump or Now we know that we don t need a second jump so we try jump and so on In other words using binary lifting we can find the highest vertex with in steps Also we can calculate array for vertex right after we add vertex to the tree since and The resulting complexity is 
https://codeforces.com//contest/1469/problem/F,847531,F,1469F,1469,F. Power Sockets, Define a chain a chain of length 1 is a single vertex a chain of length x is a chain of length x 1 with a new vertex connected to the end of it with a single edge You are given n chains of lengths l 1 l 2 dots l n You plan to build a tree using some of them Each vertex of the tree is either white or black The tree initially only has a white root vertex All chains initially consist only of white vertices You can take one of the chains and connect any of its vertices to any white vertex of the tree with an edge The chain becomes part of the tree Both endpoints of this edge become black Each chain can be used no more than once Some chains can be left unused The distance between two vertices of the tree is the number of edges on the shortest path between them If there is at least k white vertices in the resulting tree then the value of the tree is the distance between the root and the k th closest white vertex What s the minimum value of the tree you can obtain If there is no way to build a tree with at least k white vertices then print ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nconstexpr int inf = 1e9, N = 5e5;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n, k;\n    std::cin >> n >> k;\n    std::vector<int> l(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> l[i];\n    }\n    std::sort(l.begin(), l.end(), std::greater<>());\n    int a[N]{};\n    a[0] = 1;\n    a[1] = -1;\n    int ans = inf;\n    int total = 0;\n    for (int i = 0, j = 0; i < N - 1; ++i) {\n        total += a[i];\n        a[i + 1] += a[i];\n        if (total + a[i + 1] >= k) {\n            ans = std::min(ans, i + 1);\n        }\n        while (a[i] > 0 && j < n) {\n            int u = (l[j] - 1) / 2;\n            int v = l[j] - 1 - u;\n            a[i + 2]++;\n            a[i + 2 + u]--;\n            a[i + 2]++;\n            a[i + 2 + v]--;\n            a[i]--;\n            total--;\n            j++;\n        }\n    }\n    if (ans == inf) {\n        ans = -1;\n    }\n    std::cout << ans << ""\\n"";\n    return 0;\n}']",,,"['binary search', 'data structures', 'greedy']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Power Sockets.json,https://codeforces.com//blog/entry/86082,At first let s realize that the tree structure doesn t matter that much What we actually need is the array such that it stores the number of white vertices on depth Initially and all other are zero If you take a chain and attach it to some vertex on depth then the number of vertices on depth decreases by Also the added vertices update some other counts So far it s extremely unclear what to begin with Let s start by introducing some greedy ideas For each let s find the most optimal tree using exactly chains and update the answer with each of them First it s always optimal to attach a chain with its middle vertex Just consider the changes in the white vertices counts Second for each it s always optimal to take the longest chains to use If not the longest are used then you can replace any of them and there will be more white vertices It would be nice if we were able to just add another chain to the tree for to get the tree for However that s not always the case But we can still attempt it and show that the optimal answer was achieved somewhere in the process Let s show that it s always optimal to attach a new chain to the closest white vertex So there are basically two cases there is not enough white vertices yet and there is enough What happens if there is not enough vertices and we pick the closest one to attach a chain to If there are still not enough vertices then we ll just continue Otherwise we ll have to show that the answer can t get any smaller by rearranging something Consider what the answer actually is Build a prefix sum array over then the answer is the shortest prefix such that its prefix sum is greater or equal to So we put the th chain to the closest white vertex at depth It decreases by and increases and further by or Every chain we have put to this point was attached to a vertex at depth less or equal to the answer otherwise we could ve rearranged it and obtain the answer before The optimal answer can be neither nor also because we could ve rearranged Thus the answer is at least and every single chain we have put was packed as tightly as possible below that depth The second case works similarly We could ve obtained the optimal answer before So the answer is below and we can do nothing about that Or the optimal answer is ahead of us so putting the chain at can decrease it as much or stronger as any other choice Thus updating the answer on every iteration will give us the optimal result Now we are done with the greedy time to implement it I chose the most straightforward way We basically have to maintain a data structure that can add on range get the value of a cell and find the shortest prefix with sum at least That can be easily done with segtree Overall complexity 
https://codeforces.com//contest/1991/problem/D,2781504,D,1991D,1991,D. Prime XOR Coloring,You are given an undirected graph with n vertices numbered from 1 to n There is an edge between vertices u and v if and only if u oplus v is a prime number where oplus denotes the bitwise XOR operator Color all vertices of the graph using the minimum number of colors such that no two vertices directly connected by an edge have the same color ,"['/** *    author:  tourist *    created: 28.07.2024 10:43:20**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    if (n <= 5) {      cout << n / 2 + 1 << \'\\n\';      for (int i = 0; i < n; i++) {        cout << (i + 3) / 2 << "" \\n""[i == n - 1];      }    } else {      cout << 4 << \'\\n\';      for (int i = 0; i < n; i++) {        cout << i % 4 + 1 << "" \\n""[i == n - 1];      }    }  }  return 0;}']",,,"['bitmasks', 'constructive algorithms', 'graphs', 'greedy', 'math', 'number theory']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Prime XOR Coloring.json,https://codeforces.com//blog/entry/132021,For n 6 the minimum number of colors is always 4 Proof First we can show that the number of colors cannot be less than 4 This is because vertices 1 3 4 and 6 form a clique meaning they are all connected so they must have different colors Next we can provide a construction where the number of colors is 4 For the i th vertex assign the color imod4 1 This ensures that any two vertices of the same color have a difference that is a multiple of 4 so their XOR is a multiple of 4 which is not a prime number For n 6 the example provides the coloring for all cases n 1 A valid coloring is 1 n 2 A valid coloring is 1 2 n 3 A valid coloring is 1 2 2 n 4 A valid coloring is 1 2 2 3 n 5 A valid coloring is 1 2 2 3 3 
https://codeforces.com//contest/1888/problem/C,2278990,C,1888C,1888,C. You Are So Beautiful,You are given an array of integers a 1 a 2 ldots a n Calculate the number of of this array 1 leq l leq r leq n such that The array b a l a l 1 ldots a r occurs in the array a as a exactly once In other words there is exactly one way to select a set of indices 1 leq i 1 i 2 ldots i r l 1 leq n such that b j a i j for all 1 leq j leq r l 1 ,"['#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<map>\ntypedef long long ll;\nconst int maxn=2e5+5;\nint t;\nint n;\nint a[maxn],fir[maxn],las[maxn];\nstd::map<int,bool>apr;\nsigned main(){\n\tscanf(""%d"",&t);\n\tfor(int wc=1;wc<=t;wc++){\n\t\tapr.clear();\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i),fir[i]=(!apr[a[i]]),apr[a[i]]=true;\n\t\tapr.clear(),las[n+1]=0;\n\t\tfor(int i=n;i;i--)las[i]=las[i+1]+(!apr[a[i]]),apr[a[i]]=true;\n\t\tll ans=0;\n\t\tfor(int i=1;i<=n;i++)ans+=fir[i]*las[i];\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n//namespace burningContract\n']",,,['data structures'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. You Are So Beautiful.json,https://codeforces.com//blog/entry/121621,Note that a subarray suits us if al is the leftmost occurrence of the number al in the array and ar is the rightmost occurrence of the number ar in the array Let s create an array br filled with zeros and set br 1 if ar is the rightmost occurrence of the number ar in the array this can be done using sets or dictionaries Now we need to consider all suitable left boundaries and see how many suitable right boundaries we have on the suffix either by precomputing a suffix sum or by simply maintaining a variable while traversing from left to right 
https://codeforces.com//contest/1794/problem/E,1808459,E,1794E,1794,E. Labeling the Tree with Distances,You are given an unweighted tree of n vertices numbered from 1 to n and a list of n 1 integers a 1 a 2 ldots a n 1 A tree is a connected undirected graph without cycles You will use each element of the list to label one vertex No vertex should be labeled twice You can label the only remaining unlabeled vertex with any integer A vertex x is called if it is possible to do this labeling so that for each vertex i its label is the distance between x and i The distance between two vertices s and t on a tree is the minimum number of edges on a path that starts at vertex s and ends at vertex t Find all good vertices ,"['#include <algorithm>\n#include <array>\n#include <iostream>\n#include <random>\n#include <set>\n#include <vector>\n#include <chrono>\nusing namespace std;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == \'-\')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nconst int P = 1e9 + 7;\n\ntypedef array<int, 10> Hash;\n \nHash operator*(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = 1LL * u[i] * v[i] % P;\n  return t;\n}\n\nHash operator+(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + v[i]) % P;\n  return t;\n}\n\nHash operator-(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] - v[i] + P) % P;\n  return t;\n}\n \nHash Base;\n \nHash mult_base(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (1LL * u[i] * Base[i]) % P;\n  return t;\n}\n\nHash add_one(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + 1) % P;\n  return t;\n}\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n \nint gen_base() {\n  static uniform_int_distribution<int> d(258, P - 1);\n  int b = d(rng);\n  return b % 2 == 0 ? b - 1 : b;\n}\n\nconst int N = 2e5;\n\nHash sub[N];\nvector<int> g[N];\n\nvoid dfs1(int p, int i) {\n  for (int j : g[i])\n    if (p != j) {\n      dfs1(i, j);\n      sub[i] = sub[i] + sub[j];\n    }\n  sub[i] = add_one(mult_base(sub[i]));\n}\n\nHash root[N];\n\nvoid dfs2(int p, int i, Hash up) {\n  root[i] = sub[i] + mult_base(up);\n  Hash all = up;\n  for (int j : g[i])\n    if (p != j)\n      all = all + sub[j];\n  for (int j : g[i])\n    if (p != j) {\n      Hash tmp = add_one(mult_base(all - sub[j]));\n      dfs2(i, j, tmp);\n    }\n}\n\nint main() {\n  for (int i = 0; i < 10; i++)\n    Base[i] = gen_base();\n  static int c[N];\n  int n = read();\n  for (int i = 0; i < n - 1; i++)\n    c[read()]++;\n  for (int h = 0; h < n - 1; h++) {\n    int i = read() - 1, j = read() - 1;\n    g[i].push_back(j), g[j].push_back(i);\n  }\n  dfs1(-1, 0);\n  Hash h;\n  fill(h.begin(), h.end(), 0);\n  dfs2(-1, 0, h);\n  Hash rn, pw;\n  for (int i = 0; i < 10; i++)\n    rn[i] = 0, pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    while (c[i]--)\n      rn = rn + pw;\n    pw = mult_base(pw);\n  }\n  set<Hash> ok;\n  for (int i = 0; i < 10; i++)\n    pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    ok.insert(pw + rn);\n    pw = mult_base(pw);\n  }\n  vector<int> ans;\n  for (int i = 0; i < n; i++)\n    if (ok.count(root[i]))\n      ans.push_back(i);\n  printf(""%d\\n"", (int) ans.size());\n  sort(ans.begin(), ans.end());\n  for (int i : ans)\n    printf(""%d "", i + 1);\n  printf(""\\n"");\n  return 0;\n}']",,,"['data structures', 'dp', 'greedy', 'hashing', 'implementation', 'trees']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Labeling the Tree with Distances.json,https://codeforces.com//blog/entry/113500,First count the number of occurrences of each element in the list Let these numbers be Then compute the polynomial hash of the array that is where is the base of the hash Because the tree is unweighted there are only possible values to write in the unlabeled vertex all integers between and Including this extra number the hash has possibilities for each Now let s compute the same hash for each vertex of the tree That is for each vertex count how many vertices are at distances and if these numbers are compute the value To compute these values efficiently we will use rerooting dynamic programming We will make two DFS In the first one compute the parent of each node and the hash of each node only considering the nodes in its subtree For each vertex if we call this hash then In the second one which must be performed after the first one for each vertex compute the hash of the parent of considering the nodes which are not in the subtree of vertex If we call this hash then where is the parent of Now observe that With these hashes we can compute the good vertices A vertex will be good if and only if for some Doing a two pointers algorithm with the two sorted lists and is enough to find for each if there is a number on the other list equal to it To make the solution pass it is advisable to use hashing with multiple modules or just one big modulo Intended complexity 
https://codeforces.com//contest/889/problem/C,133720,C,889C,889,C. Maximum Element,One day Petya was solving a very interesting problem But although he used many optimization techniques his solution still got Time limit exceeded verdict Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of positive integers was too slow Desperate Petya decided to use a somewhat unexpected optimization using parameter so now his function contains the following code int fast max int n int a int ans 0 int offset 0 for int i 0 i n i if ans a i ans a i offset 0 else offset offset 1 if offset k return ans return ans That way the function iteratively checks array elements storing the intermediate maximum and if after consecutive iterations that maximum has not changed it is returned as the answer Now Petya is interested in fault rate of his function He asked you to find the number of permutations of integers from to such that the return value of his function on those permutations is not equal to Since this number could be very big output the answer modulo ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\n\nll rev(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = rev(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll f[MAXN];\nll fct[MAXN];\nll rfct[MAXN];\n\nll cnk(int x, int y) {\n    return fct[x + y] * rfct[x] % MOD * rfct[y] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    rfct[n] = rev(fct[n]);\n    for (int i = n; i > 0; --i) {\n        rfct[i - 1] = (rfct[i] * i) % MOD;\n    }\n    \n    ll mulall = 1;\n    ll ans = fct[n - 1];\n\n\n    ll sum = 0;\n    f[0] = 1;\n    sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        sum = (sum + f[i - 1]) % MOD;\n        ll cf = sum * mulall % MOD;\n        ans += cf * fct[n - 1] % MOD * rfct[i] % MOD;\n        ans %= MOD;\n        mulall = (mulall * i) % MOD;\n        f[i] = (rev(mulall) * cf) % MOD;\n        if (i >= k) {\n            sum = (sum - f[i - k] + MOD) % MOD;\n        }\n    }\n\n    cout << (fct[n] - ans + MOD) % MOD;\n}']",,,"['dp', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Maximum Element.json,https://codeforces.com//blog/entry/55734,You asked to find the number of permutations p of length n such that exists index i such that pi n pi is greater than any pj for j in 1 i 1 and greater then any pj for j in i 1 i k We will call such permutations good Define D n as number of good permutations that have pn n Notice that if k n then D n 0 Let w be a permutations such that wn n If index of element n 1 is lesser than n k then w is good Otherwise if n 1 index is j j n k then because there are less then k elements between n 1 and n w could be good only if i from the definition would be lesser than j In that case permutation w1 wj would form a good permutation of length j of some numbers with wj being the maximum Therefore the following equation is correct Which can be computed in O n2 or in O n rewritten in the form and using prefix sums for values The answer is than calculated as follows Complexity O n 
https://codeforces.com//contest/1204/problem/B,392652,B,1204B,1204,B. Mislove Has Lost an Array,Mislove had an array a 1 a 2 cdots a n of n positive integers but he has lost it He only remembers the following facts about it The number of different numbers in the array is not less than l and is not greater than r For each array s element a i either a i 1 or a i is even and there is a number dfrac a i 2 in the array For example if n 5 l 2 r 3 then an array could be 1 2 2 4 4 or 1 1 1 1 2 but it couldn t be 1 2 2 4 8 because this array contains 4 different numbers it couldn t be 1 2 2 3 3 because 3 is odd and isn t equal to 1 and it couldn t be 1 1 2 2 16 because there is a number 16 in the array but there isn t a number frac 16 2 8 According to these facts he is asking you to count the minimal and the maximal possible sums of all elements in an array ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, l, r;\nint arr[1002];\nint arr2[1002];\nint ans1, ans2;\n\nint main(){\n    scanf(""%d %d %d"", &n, &l, &r);\n    for(int i=0; i<=n; i++) arr[i] = 1, arr2[i] = (1<<(r-1));\n    for(int i=n-l+2; i<=n; i++) arr[i] = arr[i-1] * 2;\n    for(int i=1; i<=r; i++) arr2[i] = (1<<(i-1));\n    for(int i=1; i<=n; i++) ans1+=arr[i], ans2+=arr2[i];\n    printf(""%d %d"", ans1, ans2);\n}\n']",,,"['greedy', 'math']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Mislove Has Lost an Array.json,https://codeforces.com/blog/entry/69244,Any array that satisfies statements conditions contains only powers of two from to where so the minimal sum is achieved when we take powers of two from to and set the other elements equal to the maximal sum is achieved when we take powers of two from to and set the other elements equal to 
https://codeforces.com//contest/1632/problem/D,1278698,D,1632D,1632,D. New Year Concert,New Year is just around the corner which means that in School 179 preparations for the concert are in full swing There are n classes in the school numbered from 1 to n the i th class has prepared a scene of length a i minutes As the main one responsible for holding the concert Idnar knows that if a concert has k scenes of lengths b 1 b 2 ldots b k minutes then the audience will get bored if there exist two integers l and r such that 1 le l le r le k and gcd b l b l 1 ldots b r 1 b r r l 1 where gcd b l b l 1 ldots b r 1 b r is equal to the greatest common divisor GCD of the numbers b l b l 1 ldots b r 1 b r To avoid boring the audience Idnar can ask any number of times possibly zero for the t th class 1 le t le k to make a new scene d minutes in length where d can be Thus after this operation b t is equal to d Note that t and d can be different for each operation For a sequence of scene lengths b 1 b 2 ldots b k let f b be the minimum number of classes Idnar has to ask to change their scene if he wants to avoid boring the audience Idnar hasn t decided which scenes will be allowed for the concert so he wants to know the value of f for each non empty prefix of a In other words Idnar wants to know the values of f a 1 f a 1 a 2 ldots f a 1 a 2 ldots a n ,"['#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\n\nint gcd(int x,int y){\n    return __gcd(x,y);\n}\n\nint n, a[202000], g[202000][18];\n\nbool check(int las,int n){\n    int p=n, now=a[n];\n    while (1){\n        int orgp=p;\n        for (int j=17;j>=0;--j)\n            if (p-(1<<j)>=0){\n                if (g[p][j]%now==0){\n                    p-=1<<j;\n                }\n            }\n        p=max(p,las);\n        int l=n-orgp+1, r=n-p;\n        if (l<=now&&now<=r) return 1;\n        if (p==las) return 0;\n        now=gcd(now,a[p]);\n    }\n}\n\nint main(){\n    cin>>n;\n    int las=0, ans=0;\n    for (int i=1;i<=n;++i){\n        scanf(""%d"",&a[i]);\n        g[i][0]=a[i];\n        for (int j=1;j<=17;++j){\n            if (i-(1<<j)>=0) g[i][j]=gcd(g[i][j-1],g[i-(1<<j-1)][j-1]);\n        }\n        int fl=check(las,i);\n        if (fl){\n            ++ans; las=i;\n        }\n        printf(""%d "",ans);\n    }\n    puts("""");\n}']",,,"['binary search', 'data structures', 'greedy', 'math', 'number theory', 'two pointers']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. New Year Concert.json,https://codeforces.com//blog/entry/99442,Read the hints above Let s find all of the bad segments For a fixed let s find the largest that has This can be done with binary search and a sparse table segment tree If then the segment is bad If we change into a big prime no new bad segments will appear And all bad segments that have inside of them will disappear So we have to find the minimum number of points to cover all of them This is a standard problem which can be solved greedily choose the segment with the smallest delete all segments that have in them and repeat In our case this is easy to do because our segments are not nested Time complexity with a sparse table where is the maximum value of Notes There are many different modifications to the previous solution some of them use two pointers since segments are not nested and some of them update the answer on the fly while searching for the bad segments Using a segment tree and two pointers you can get the complexity You can also use the fact that for a prefix there at most different suffix values This leads to another way to find the bad segments 
https://codeforces.com//contest/1536/problem/E,1007473,E,1536E,1536,E. Omkar and Forest,Omkar s most recent follower Ajit has entered the Holy Forest Ajit realizes that Omkar s forest is an n by m grid 1 leq n m leq 2000 of some non negative integers Since the forest is blessed by Omkar it satisfies some special conditions For any two adjacent sharing a side cells the absolute value of the difference of numbers in them is at most 1 If the number in some cell is strictly larger than 0 it should be strictly greater than the number in of the cells adjacent to it Unfortunately Ajit is not fully worthy of Omkar s powers yet He sees each cell as a 0 or a If a cell is labeled as 0 then the number in it must equal 0 Otherwise the number in it can be any nonnegative integer Determine how many different assignments of elements exist such that these special conditions are satisfied Two assignments are considered different if there exists at least one cell such that the numbers written in it in these assignments are different Since the answer may be enormous find the answer modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,mod=1e9+7;\nll n,m,ans,c1,c2;\nchar s[N][N];\nint read()\n{\n\tint res=0,fl=0; char a=getchar();\n\twhile(a<\'0\'||a>\'9\') fl|=a==\'-\',a=getchar();\n\twhile(a>=\'0\'&&a<=\'9\') res=res*10+a-\'0\',a=getchar();\n\treturn fl? -res:res;\n}\nll ksm(ll di,ll mi) {ll res=1; for(;mi;mi>>=1,di=di*di%mod) if(mi&1) res=res*di%mod; return res;}\n//ll c(ll a,ll b) {return a>=b? jc[a]*jv[b]%mod*jv[a-b]%mod:0;}\nint main()\n{\n\tint i,j,t=read();\n\twhile(t--)\n\t{\n\t\tn=read(),m=read(),c1=0,c2=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(scanf(""%s"",s[i]+1),j=1;j<=m;j++) if(s[i][j]==\'#\') c1++; else c2++;\n\t\tcout<<(ksm(2,c1)+mod-1+(!!c2))%mod<<\'\\n\';\n\t}\n\treturn 0;\n}']",,,"['combinatorics', 'graphs', 'math', 'shortest paths']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Omkar and Forest.json,https://codeforces.com//blog/entry/91520,SolutionImagine picking some subset of and making them Then there is exactly one way to make all the remaining positive integers To see why imagine multisource BFS with all as the sources After the BFS each will be equal to the minimum distance from itself to any cell Difference between adjacent cells will be at most Proof can be shown by contradiction if two cells with difference existed then the larger of these cells is not labeled with the shortest distance to a source since the distance from the smaller cell will be a better choice Because of the nature of BFS we can also ensure the second condition is also satisfied since the only cells that have no neighbor strictly smaller will be the source cells This is the only valid assignment because if we make any number larger there will exist a pair of cells with difference If we try to make any number smaller there will exist a cell with positive karma that has no strictly smaller neighbor If we let equal to the frequency of in the input then the answer is Keep in mind of the special case where the input is all in which case you have to subtract This is because a possible arrangement must contain at least one cell with karma of Obviously the solution runs in time 
https://codeforces.com//contest/1743/problem/G,1590322,G,1743G,1743,G. Antifibonacci Cut,Let s define the sequence of Fibonacci strings as follows f 0 is f 1 is f i is f i 1 f i 2 for i 1 denotes the concatenation of two strings So for example f 2 is f 3 is f 4 is For a given string s let s define g s as the number of ways to cut it into several any number possibly even just one strings such that none of these strings are Fibonacci strings For example if s is g s 3 since there are three ways to cut it You are given a sequence of strings s 1 s 2 dots s n Calculate g s 1 g s 1 s 2 dots g s 1 s 2 ldots s n Since these values can be huge print them modulo 998244353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nstd::vector<int> fib{1, 2};\n\nint get(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    auto it = std::prev(std::upper_bound(fib.begin(), fib.end(), n));\n    return get(n - *it);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    for (int i = 0; i < 30; i++) {\n        fib.push_back(fib[fib.size() - 2] + fib.back());\n    }\n    \n    int n;\n    std::cin >> n;\n    \n    Z dp = 1, sum = 1;\n    std::vector<std::pair<int, Z>> suf;\n    \n    auto add = [&](int x) {\n        Z ndp = sum - dp;\n        std::vector<std::pair<int, Z>> nsuf;\n        \n        if (x) {\n            nsuf.push_back({1, dp});\n        }\n        for (auto [l, v] : suf) {\n            if (x == get(l)) {\n                nsuf.emplace_back(l + 1, v);\n                if (std::binary_search(fib.begin(), fib.end(), l + 1)) {\n                    ndp -= v;\n                }\n            }\n        }\n        std::swap(suf, nsuf);\n        dp = ndp;\n        \n        sum += ndp;\n    };\n    \n    for (int i = 0; i < n; i++) {\n        std::string s;\n        std::cin >> s;\n        \n        for (auto c : s) {\n            add(c - \'0\');\n        }\n        std::cout << dp << ""\\n"";\n    }\n    \n    \n    return 0;\n}']",,,"['bitmasks', 'combinatorics', 'constructive algorithms', 'data structures', 'dp', 'hashing', 'math']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Antifibonacci Cut.json,https://codeforces.com//blog/entry/108153,The first idea that comes to mind is running some sort of dynamic programming the number of ways to cut the string consisting of the first characters When we calculate we need to take the sum of the previous values of and then subtract for every such that the string from the th character inclusive to the th character non inclusive is a Fibonacci string Unfortunately there are two main issues with this solution firstly we cannot store the array in memory and secondly we have to search for the Fibonacci strings ending in a certain index quickly something like Aho Corasick could work with a less strict memory limit but right now we cannot use it We will try to resolve both of these issues with the following approach while we process the characters we will maintain the list of tuples such that the string from the th character to the current one is a prefix of some Fibonacci string How do we maintain them Every Fibonacci string except for is a prefix of So all Fibonacci strings we are interested in except for again are prefixes of the same long Fibonacci string Suppose a tuple represents some index such that the string from the th character to the current one is a prefix of that long Fibonacci string Each time we append a character we filter this list of tuples by trying to check if this new character matches the next character in the prefix if it does not the tuple is discarded For the tuples that represent the prefixes equal to Fibonacci strings we need to subtract the value of from the new value we are trying to calculate checking if a prefix is a Fibonacci string is easy we just need to check its length How do we check that if we add a character or it is still a prefix There are two ways to do this either generate the first characters of the long Fibonacci string or represent the current prefix as the sum of Fibonacci strings such that for every the condition holds i e the Fibonacci strings we split the current prefix into are arranged in descending order and there is no pair of equal or adjacent by index Fibonacci strings in the split This representation is very similar to writing an integer in Zeckendorf system The next character in the prefix depends on whether belongs to this split if it belongs it is the last string in the split so we need to append to transform into otherwise we need to append Okay so now we can solve the problem in time where is the total length of the strings in the input and is the size of the list of tuples we discussed earlier This actually works since it looks like the size of the list of tuples is bounded as Unfortunately we don t have a strict mathematical proof of this we checked this by brute force with up to so it definitely works under the constraints of the problem 
https://codeforces.com//contest/1313/problem/D,546724,D,1313D,1313,D. Happy New Year,Being Santa Claus is very difficult Sometimes you have to deal with difficult situations Today Santa Claus came to the holiday and there were m children lined up in front of him Let s number them from 1 to m Grandfather Frost knows n spells The i th spell gives a candy to every child whose place is in the L i R i range Each spell can be used at most once It is also known that if all spells are used each child will receive at most k candies It is not good for children to eat a lot of sweets so each child can eat no more than one candy while the remaining candies will be equally divided between his or her Mom and Dad So it turns out that if a child would be given an even amount of candies possibly zero then he or she will be unable to eat any candies and will go sad However the rest of the children who received an odd number of candies will be happy Help Santa Claus to know the maximum number of children he can make happy by casting some of his spells ,"['#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-\'0\',ch=getchar();\n\treturn f?x:-x;\n}\nint L[100010],R[100010],U[200010],u;\nint f[200010][1<<8|1];\nstd::vector<int>v[200010];\nint MX[1<<8|1],par[1<<8|1],pos[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(""in.in"",""r"",stdin);\n\t//freopen(""out.out"",""w"",stdout);\n#endif\n\tint n=gi(),____=gi(),___=gi();\n\tfor(int i=1;i<=n;++i)L[i]=gi(),R[i]=gi()+1,U[++u]=L[i],U[++u]=R[i];\n\tstd::sort(U+1,U+u+1);u=std::unique(U+1,U+u+1)-U-1;\n\tfor(int i=1;i<=n;++i)L[i]=std::lower_bound(U+1,U+u+1,L[i])-U;\n\tfor(int i=1;i<=n;++i)R[i]=std::lower_bound(U+1,U+u+1,R[i])-U-1;\n\tfor(int i=1;i<=n;++i)for(int j=L[i];j<=R[i];++j)v[j].push_back(i);\n\tmemset(f,-63,sizeof f);\n\tfor(int i=0;i<1<<8;++i)par[i]=__builtin_parity(i);\n\tf[0][0]=0;\n\tmemset(pos,-1,sizeof pos);\n\tfor(int i=0;i<u;++i){\n\t\tint o=v[i].size();\n\t\tmemset(MX,-63,sizeof MX);\n\t\tfor(int j=0;j<1<<o;++j){\n\t\t\tint S=0;\n\t\t\tfor(int k=0;k<o;++k)if((j>>k&1)&&R[v[i][k]]>i)S|=1<<k;\n\t\t\tif(par[j]&&f[i][j]>=0)f[i][j]+=U[i+1]-U[i];\n\t\t\tMX[S]=std::max(MX[S],f[i][j]);\n\t\t}\n\t\tint old=0;\n\t\tfor(int j=0;j<v[i].size();++j)pos[v[i][j]]=-1;\n\t\tfor(int j=0;j<v[i+1].size();++j)pos[v[i+1][j]]=j;\n\t\tfor(int j=0;j<o;++j)if(~pos[v[i][j]])old|=1<<pos[v[i][j]];\n\t\tint O=v[i+1].size();\n\t\tfor(int j=0;j<1<<o;++j){\n\t\t\tif(MX[j]>=0){\n\t\t\t\tint nS=0;\n\t\t\t\tfor(int k=0;k<o;++k)\n\t\t\t\t\tif((j>>k&1)&&R[v[i][k]]>i)\n\t\t\t\t\t\tnS|=1<<pos[v[i][k]];\n\t\t\t\tint E=((1<<O)-1)^old;\n\t\t\t\tfor(int k=E;;k=(k-1)&E){\n\t\t\t\t\tf[i+1][k|nS]=std::max(f[i+1][k|nS],MX[j]);\n\t\t\t\t\tif(!k)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"",f[u][0]);\n\treturn 0;\n}\n']",,,"['bitmasks', 'dp', 'implementation']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Happy New Year.json,https://codeforces.com//blog/entry/74146,We wil use scanline to solve this problem For all segments we add event of its beginning and end Let s maintain where is number of events that we have already processed is mask of bits where in some bit means that segment corresponding to this bit is taken How to move from one coordinate to another For all masks we can count number of bits and if it is odd we should add distance between to points to value of this How to add new segment As we know at one point can be at most segments so when we add segment we can find free bit and create match to this segment After this operation we also should change some values of Deleting of the segments is similar to adding As you may notice only th lay is needed to calculate th lay so we can use only additional memory Total complexity 
https://codeforces.com//contest/1594/problem/D,1135637,D,1594D,1594,D. The Number of Imposters,Theofanis started playing the new online game called Among them However he always plays with Cypriot players and they all have the same name Andreas the most common name in Cyprus In each game Theofanis plays with n other players Since they all have the same name they are numbered from 1 to n The players write m comments in the chat A comment has the structure of i j c where i and j are two distinct integers and c is a string 1 le i j le n i neq j c is either or The comment means that player i said that player j has the role c An imposter always lies and a crewmate always tells the truth Help Theofanis find the maximum possible number of imposters among all the other Cypriot players or determine that the comments contradict each other see the notes for further explanation Note that each player has exactly role either or ,"['#include <bits/stdc++.h>\nusing namespace std;\nint fa[500005],vis[500005],sz[500005];\ninline int ff(int x)\n{\n\tif(fa[x]==x) return x;\n\treturn fa[x]=ff(fa[x]);\n}\nint n;\ninline void merge(int x,int y)\n{\n\tx=ff(x),y=ff(y);\n\tif(x==y) return ;\n\tsz[x]+=sz[y],fa[y]=x;\n}\nsigned main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tfor(int i=1;i<=n+n;i++) fa[i]=i,vis[i]=0;\n\t\tfor(int i=1;i<=n;i++) sz[i]=1;\n\t\tfor(int i=n+1;i<=n+n;i++) sz[i]=0;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tstring k;\n\t\t\tcin >> x >> y >> k;\n\t\t\tif(k[0]==\'c\')\n\t\t\t{\n\t\t\t\tmerge(x,y);\n\t\t\t\tmerge(x+n,y+n);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmerge(x+n,y);\n\t\t\t\tmerge(x,y+n);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(ff(i)==ff(i+n))\n\t\t\t{\n\t\t\t\tans=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ff(i)]||fa[i]!=i) continue;\n\t\t\tans+=max(sz[ff(i)],sz[ff(i+n)]);\n\t\t\tvis[ff(i)]=1,vis[ff(i+n)]=1;\n\t\t}\n\t\tcout << ans << ""\\n""; \n\t}\n\treturn 0;\n}']",,,"['constructive algorithms', 'dfs and similar', 'dp', 'dsu', 'graphs']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. The Number of Imposters.json,https://codeforces.com//blog/entry/95525,If person said in a comment that person is a then and belong to the same team either imposters or crewmates If person said in a comment that person is an then and belong to different teams Solution You can build a graph and check if all its components are bipartite If person said that is an imposter then we add an edge from to If person said that is a crewmate then we add an edge from to a fake node and from the same fake node to For each component we check if it s bipartite and take the maximum from the two colours If a component is not bipartite then the answer is Solution We can build the graph in the other way If and are in the same team then we add edge with weight otherwise with weight Then you can use dfs and colour the nodes either or maintaining the property that 
https://codeforces.com//contest/2005/problem/D,2874764,D,2005D,2005,D. Alter the GCD,You are given two arrays a 1 a 2 ldots a n and b 1 b 2 ldots b n You must perform the following operation choose any indices l and r such that 1 le l le r le n swap a i and b i for all i such that l leq i leq r Find the maximum possible value of text gcd a 1 a 2 ldots a n text gcd b 1 b 2 ldots b n after performing the operation exactly once Also find the number of distinct pairs l r which achieve the maximum value ,"[""#include <bits/stdc++.h>using namespace std;\xa0int sir[2][200001] , prefix[2][200001] , sufix[2][200002];pair < pair <int , int> , int > stiva[2][2048];\xa0inline void Solve (){    int lungime;    cin >> lungime;\xa0    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[0][indice]; prefix[0][indice] = __gcd(prefix[0][indice - 1] , sir[0][indice]); }    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[1][indice]; prefix[1][indice] = __gcd(prefix[1][indice - 1] , sir[1][indice]); }\xa0    sufix[0][lungime + 1] = sufix[1][lungime + 1] = 0;    for (int indice = lungime ; indice ; indice--)        { sufix[0][indice] = __gcd(sufix[0][indice + 1] , sir[0][indice]); }    for (int indice = lungime ; indice ; indice--)        { sufix[1][indice] = __gcd(sufix[1][indice + 1] , sir[1][indice]); }\xa0    int maxim = -1;    int64_t aparitii = 0;    for (int dreapta = 1 ; dreapta <= lungime ; dreapta++)    {        int ramas = 1;        stiva[0][++stiva[0][0].second] = {{prefix[0][dreapta - 1] , sir[0][dreapta]} , dreapta};        stiva[0][1].first.second = __gcd(stiva[0][1].first.second , sir[0][dreapta]);\xa0        for (int indice = 2 ; indice <= stiva[0][0].second ; indice++)        {            stiva[0][indice].first.second = __gcd(stiva[0][indice].first.second , sir[0][dreapta]);            if (stiva[0][indice].first == stiva[0][ramas].first)                { stiva[0][ramas].second = stiva[0][indice].second; }            else                { stiva[0][++ramas] = stiva[0][indice]; }        }\xa0        stiva[0][0].second = ramas;                ramas = 1;        stiva[1][++stiva[1][0].second] = {{prefix[1][dreapta - 1] , sir[1][dreapta]} , dreapta};        stiva[1][1].first.second = __gcd(stiva[1][1].first.second , sir[1][dreapta]);\xa0        for (int indice = 2 ; indice <= stiva[1][0].second ; indice++)        {            stiva[1][indice].first.second = __gcd(stiva[1][indice].first.second , sir[1][dreapta]);            if (stiva[1][indice].first == stiva[1][ramas].first)                { stiva[1][ramas].second = stiva[1][indice].second; }            else                { stiva[1][++ramas] = stiva[1][indice]; }        }\xa0        stiva[1][0].second = ramas;\xa0        int indice_1 = stiva[0][0].second , indice_2 = stiva[1][0].second;        while (indice_1)        {            const int urmatorul_1 = (indice_1 == 1 ? 0 : stiva[0][indice_1 - 1].second);            const int urmatorul_2 = (indice_2 == 1 ? 0 : stiva[1][indice_2 - 1].second);            const int candidat_1 = __gcd(sufix[0][dreapta + 1] , __gcd(stiva[0][indice_1].first.first , stiva[1][indice_2].first.second));            const int candidat_2 = __gcd(sufix[1][dreapta + 1] , __gcd(stiva[1][indice_2].first.first , stiva[0][indice_1].first.second));            if (candidat_1 + candidat_2 > maxim) { maxim = candidat_1 + candidat_2; aparitii = min(stiva[0][indice_1].second , stiva[1][indice_2].second) - max(urmatorul_1 , urmatorul_2); }            else if (candidat_1 + candidat_2 == maxim) { aparitii += min(stiva[0][indice_1].second , stiva[1][indice_2].second) - max(urmatorul_1 , urmatorul_2); }            if (urmatorul_1 == urmatorul_2) { indice_1--; indice_2--; }            else if (urmatorul_1 < urmatorul_2) { indice_2--; }            else { indice_1--; }        }    }\xa0    cout << maxim << ' ' << aparitii << '\\n';\xa0    stiva[0][0].second = stiva[1][0].second = 0;}\xa0int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);\xa0    int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }\xa0    return 0;}""]",,,"['binary search', 'brute force', 'data structures', 'divide and conquer', 'implementation', 'number theory']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Alter the GCD.json,https://codeforces.com/blog/entry/133869,Full SolutionLet be the maximal value of Finding the maximal sum of s Let s define and as the s of the th prefixes of and respectively Then for each index such that is a divisor of so either or the same holds for This means that there are at most different values in each of and The same holds for suffixes Now let s assume we have fixed the s of and after the operation as and Now let s consider the shortest of the longest prefixes of and having and respectively If the swapped range has intersection with that prefix we can just not swap the intersection as it cannot worsen the answer The same holds for the suffix This means that the swapped range should be inside the middle part left between that prefix and suffix But the first and last elements of the middle part have to be changed because they didn t allow us to take longer prefix or suffix So the part that has to be swapped is that middle part Then we can see that the only sufficient lengths of the longest prefixes and suffixes are the places where one of them i e in array or changes i e is a sufficient prefix if or because otherwise we would have taken longer prefix So we can brute force through the sufficient prefixes and suffixes the number of each is at most All we are left with is calculating the s of the middle parts to update the answer which can be done with sparse table Now let s brute force through the sufficient prefixes Assume we are considering the prefix ending at This means the left border of the range will start at Then we can brute force the right border starting from In each iteration we keep s of the range and update the answer To proceed to the next one we only need to update the s with the next numbers of and Finding the number of ways Let s fix the s of and and compute and which shows the number of ways to get the fixed s in the interval without swapping a range if the number of ways to get the fixed s in the interval with a range started swapping but not ended yet if the number of ways to get the fixed s in the interval with an already swapped range if In all s we assume we don t swap and Then we calculate the with starting from In each iteration we check if the pair is sufficient or no we consider them swapped if If it is not sufficient we don t do anything Otherwise After the calculations the answer is But we have to subtract from the answer if not swapping any range gives the expected sum of s because we counted that case once in and times when adding to We also check the swaps of prefixes separately Finally the only thing left is to brute force through the s of and in a smart way As and are not swapped the s of the arrays should be their divisors Then it is enough to brute force through the divisors of only the of as the other is derieved from their sum And since has at most to be precise divisors the solution will be fast enough actually there are way too few cases when the derieved of is actually a divisor of Finalizing But this solution is not fast enough when all s are because they have divisors but in order to find them we need to do checks It means that the time complexity is which is slow To handle this we can write another slower solution which doesn t depend on One of them is the following solution working in but comes from which is actually amortized and faster Slow SolutionWe brute force through the left border and then through the right border of the swapping range keeping its and checking each of them The reason we need this slow solution is that now we can use it for But for bigger s the first solution will work because there are at most such s So the time complexity for them will be for the sum of the s and for the number of ways For the small s the time complexity will be See the formal proof below Formal ProofLet s say there are s equal to We know that Then the time complexity will be Time complexity It is actually a very rough estimation with amortized 
https://codeforces.com//contest/1467/problem/E,858756,E,1467E,1467,E. Distinctive Roots in a Tree,You are given a tree with n vertices Each vertex i has a value a i associated with it Let us root the tree at some vertex v The vertex v is called a if the following holds in all paths that start at v and end at some other node all the values encountered are distinct Two different paths may have values in common but a single path must have all distinct values Find the number of in the tree ,"['// author: xay5421\n// created: Fri Jan  8 22:33:36 2021\n#include<bits/stdc++.h>\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,K=20;\nint n,tt,a[N],id[N],ind,dep[N],tin[N],tou[N],cf[N],fa[N][K];\nint pp,lnk[N],nxt[N*2],to[N*2];\nvoid ae(int k1,int k2){to[++pp]=k2,nxt[pp]=lnk[k1],lnk[k1]=pp;}\nvoid dfs(int k1,int k2){\n\ttin[k1]=++ind,fa[k1][0]=k2,dep[k1]=dep[k2]+1;\n\trep(i,1,K-1)fa[k1][i]=fa[fa[k1][i-1]][i-1];\n\tfor(int i=lnk[k1];i;i=nxt[i])if(to[i]!=k2)dfs(to[i],k1);\n\ttou[k1]=ind;\n}\nint jump(int k1,int k2){\n\tfor(int i=K-1;i>=0;--i)if(k2>>i&1)k1=fa[k1][i];\n\treturn k1;\n}\nvoid sol(vector<int>v){\n\tif(SZ(v)==1)return;\n\tsort(v.begin(),v.end(),[&](int k1,int k2){return tin[k1]<tin[k2];});\n\t++tt;\n\tif(tin[v.back()]<=tou[v[0]]){\n\t\trep(i,1,SZ(v)-2){\n\t\t\tif(tin[v[i+1]]<=tou[v[i]]){\n\t\t\t\tputs(""0"");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tvector<int>son;\n\t\trep(i,1,SZ(v)-1){\n\t\t\tint k1=v[i];\n\t\t\tk1=jump(k1,dep[k1]-dep[v[0]]-1);\n\t\t\tson.push_back(k1);\n\t\t}\n\t\tsort(son.begin(),son.end());\n\t\tson.erase(unique(son.begin(),son.end()),son.end());\n\t\tif(SZ(son)>1){\n\t\t\tputs(""0"");\n\t\t\texit(0);\n\t\t}\n\t\tfor(const auto&x:son){\n\t\t\t++cf[tin[x]],--cf[tou[x]+1];\n\t\t}\n\t\trep(i,1,SZ(v)-1)--cf[tin[v[i]]],++cf[tou[v[i]]+1];\n\t}else{\n\t\trep(i,0,SZ(v)-2){\n\t\t\tif(tin[v[i+1]]<=tou[v[i]]){\n\t\t\t\tputs(""0"");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\t++cf[1],--cf[n+1];\n\t\trep(i,0,SZ(v)-1)--cf[tin[v[i]]],++cf[tou[v[i]]+1];\n\t}\n}\nint main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\tscanf(""%d"",&n);\n\trep(i,1,n)scanf(""%d"",&a[i]),id[i]=i;\n\trep(i,1,n-1){\n\t\tint k1,k2;\n\t\tscanf(""%d%d"",&k1,&k2);\n\t\tae(k1,k2),ae(k2,k1);\n\t}\n\tdfs(1,0);\n\tsort(id+1,id+1+n,[&](int k1,int k2){return a[k1]<a[k2];});\n\tfor(int i=1,j;i<=n;i=j){\n\t\tj=i+1;\n\t\twhile(j<=n&&a[id[i]]==a[id[j]])++j;\n\t\tvector<int>v;\n\t\trep(k,i,j-1)v.push_back(id[k]);\n\t\tsol(v);\n\t}\n\tint ans=0;\n\trep(i,1,n)cf[i]+=cf[i-1],ans+=cf[i]==tt;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']",,,"['data structures', 'dfs and similar', 'dp', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Distinctive Roots in a Tree.json,https://codeforces.com//blog/entry/86566,Root the tree arbitrarily Consider any node Let us remove from the tree and examine the trees that will be created in the resultant forest Let s say that a particular tree was attached to through node Further let s say that this tree has some node satisfying Then clearly if any distinctive root exists it must be in this component because if it were in any other component then when you root the tree at that node you will get a path from the root containing both and Let us add a directed edge from to signifying that all distinctive roots must be in this particular component Once we have repeated this for all nodes we now have a set of directed edges All distinctive roots must have each of these edges pointing to it We can check this for all nodes using the rerooting technique Link cut tree or difference array works as well Note In order to check the number of nodes which occur in a subtree do a pre order traversal of the tree Create a map which maps a value to the dfs in times of all nodes that satisfy Now two lower bounds on this shall tell us the number of occurrences in the subtree in logarithmic time Also with this information you can also calculate the number of times occurs in the tree attached to s parent 
https://codeforces.com//contest/1277/problem/D,495584,D,1277D,1277,D. Let s Play the Words ,Polycarp has n binary words A word called binary if it contains only characters and For example these words are binary and Polycarp wants to offer his set of n binary words to play a game words In this game players name words and each next word starting from the second must start with the last character of the previous word The first word can be any For example these sequence of words can be named during the game Word reversal is the operation of reversing the order of the characters For example the word after the reversal becomes the word after the reversal becomes Probably Polycarp has such a set of words that there is no way to put them in the order correspondent to the game rules In this situation he wants to reverse some words from his set so that the final set of n words still contains words i e all words are unique there is a way to put all words of the final set of words in the order so that the final sequence of n words is consistent with the game rules Polycarp wants to reverse minimal number of words Please help him ,"['#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(t_, t){\n    int n;cin>>n;\n    vector<int> n01,n00,n10,n11;\n    vector<string> s01,s10;\n    reps(i,n){\n      string s;\n      cin>>s;\n      if(s[0] == \'0\'){\n        if(s[s.size()-1] == \'0\'){\n          n00.push_back(i);\n        }else{\n          n01.push_back(i);\n          s01.push_back(s);\n        }\n      }else{\n        if(s[s.size()-1] == \'0\'){\n          n10.push_back(i);\n          s10.push_back(s);\n        }else{\n          n11.push_back(i);\n        }\n      }\n    }\n    if(n01.size() == 0 && n10.size() == 0 && n00.size() > 0 && n11.size() > 0){\n      cout<<-1<<endl;\n      continue;\n    }\n    if(n01.size() > n10.size()){\n      vector<int> tmp = n01;\n      n01 = n10;\n      n10 = tmp;\n      vector<string> tmps = s01;\n      s01 = s10;\n      s10 = tmps;\n    }\n    set<string> used;\n    rep(i, n01.size()){\n      reverse(all(s01[i]));\n      used.insert(s01[i]);\n    }\n    cout<<(n10.size() - n01.size())/2<<endl;\n    int count = 0;\n    int i = 0;\n    while(count < (n10.size() - n01.size())/2){\n      if(used.count(s10[i]) > 0){\n        i++;\n        continue;\n      }\n      cout<<n10[i]<<"" "";\n      count++;\n      i++;\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}\n']",,,"['data structures', 'hashing', 'implementation', 'math']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Let s Play the Words .json,https://codeforces.com//blog/entry/72239,For a concrete set of words it s not hard to find a criteria for checking if there is a correct order of arrangement of words for playing a game Let s call such sets of words correct Firstly the set of words is correct if the number of words like 0 1 and the number of words like 1 0 differ by no more than 1 Secondly it s correct if the number of words like 0 0 or like 1 1 is zero because they have the same characters at the beginning and at the ending and we can insert them in any position And finally if words of both kinds 0 0 and 1 1 are present and there is at least one word like 0 1 or 1 0 It can be easily proved if we note that this problem is equivalent to the Euler traversal of a directed graph with two nodes But let s prove it without resorting to graph theory if there are words of both kinds 0 0 and 1 1 but there is no words of kinds 0 1 and 1 0 starting from a word of one kind you can t go to a word of another kind Consequently if words of both kinds 0 0 and 1 1 are present there should be at least one word like 0 1 or 1 0 is a necessary condition of the problem if the number of words like 0 1 and the number of words like 1 0 differ by no more than 1 we can call them alternately starting with a kind that is larger If these numbers are equal we can start with any kind And we can insert words of kind 0 0 and 1 1 at any suitable moment Reversals only affect the mutual number of lines of the kind 0 1 and 1 0 Therefore immediately while reading the input data we can check the necessary condition first item above Without loss of generality we may assume that the number of words like 0 1 equals n01 and like 1 0 equals n10 Also we assume that n01 n10 1 Remember that all words in the current set are unique Let s prove that we can always choose some words of kind 0 1 and reverse them so that n01 n10 1 and at the result all words would still be unique In fact the set of words of kind n10 has no more than n10 such words that after the reversing the word will turn into an existing one because it will become of type 1 0 and there are only n10 such words And it means that there is no less than n01 n10 words which we can reverse and get still unique word So we can choose any n01 n10 1 of them Thus after checking of the necessary condition first item above we need to reverse just n01 n10 1 words of kind that is larger which reversals aren t duplicates 
https://codeforces.com//contest/1389/problem/G,686128,G,1389G,1389,G. Directing Edges,You are given an undirected connected graph consisting of n vertices and m edges k vertices of this graph are special You have to direct each edge of this graph or leave it undirected If you leave the i th edge undirected you pay w i coins and if you direct it you don t have to pay for it Let s call a vertex if it is reachable from each special vertex along the edges of the graph if an edge is undirected it can be traversed in both directions After you direct the edges of the graph possibly leaving some of them undirected you receive c i coins for each saturated vertex i Thus your total profit can be calculated as sum limits i in S c i sum limits j in U w j where S is the set of saturated vertices and U is the set of edges you leave undirected For each vertex i calculate the maximum possible profit you can get if you have to make the vertex i saturated ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 300300;\nint n, m, k;\nvector<int> g[N];\nvector<pii> G[N];\nint cntSpec[N];\nll sumVal[N];\nint h[N];\nint minH[N];\nint root;\nint ed[N][3];\nbool isBridge[N];\nint myComp[N];\nll val[N];\nmap<pii, ll> dp;\nint deg[N];\nll ans[N];\nint q[2 * N];\nint topQ;\n\nint getOther(int id, int v) {\n\treturn ed[id][0] ^ ed[id][1] ^ v;\n}\n\nvoid dfs1(int v) {\n//\teprintf(""dfs1 %d %d\\n"", v, h[v]);\n\tminH[v] = h[v];\n\tfor (int id : g[v]) {\n\t\tint u = getOther(id, v);\n\t\tif (h[u] != -1) {\n\t\t\tif (h[u] != h[v] - 1)\n\t\t\t\tminH[v] = min(minH[v], h[u]);\n\t\t\tcontinue;\n\t\t}\n\t\th[u] = h[v] + 1;\n\t\tdfs1(u);\n\t\tcntSpec[v] += cntSpec[u];\n//\t\tsumVal[v] += sumVal[u];\n\t\tminH[v] = min(minH[v], minH[u]);\n\t\tif (minH[u] > h[v] && cntSpec[u] > 0) {\n\t\t\tisBridge[id] = 1;\n\t\t}\n\t}\n}\nvoid dfsComp(int v) {\n\tmyComp[v] = k;\n\tval[k] += sumVal[v];\n\tfor (int id : g[v]) {\n\t\tif (isBridge[id]) continue;\n\t\tint u = getOther(id, v);\n\t\tif (myComp[u] == -1)\n\t\t\tdfsComp(u);\n\t}\n}\n\nvoid solve(int v) {\n\tif (deg[v] == 1) {\n\t\tpii u = mp(-1, -1);\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(v, w))) {\n\t\t\t\tsum += dp[mp(v, w)];\n\t\t\t} else {\n\t\t\t\tu = e;\n\t\t\t}\n\t\t}\n\t\tif (u.first != -1) {\n\t\t\tint w = u.first;\n\t\t\tsum = max(0LL, sum - u.second);\n\t\t\tdp[mp(w, v)] = sum;\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else if (deg[v] == 0) {\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tsum += dp[mp(v, w)];\n\t\t}\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(w, v))) continue;\n\t\t\tdp[mp(w, v)] = max(0LL, sum - dp[mp(v, w)] - e.second);\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else throw;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx--;\n\t\troot = x;\n\t\tcntSpec[x]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &sumVal[i]);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(""%d"", &ed[i][2]);\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\tg[v].push_back(i);\n\t\tg[u].push_back(i);\n\t}\n\tk = 0;\n\tfor (int i = 0; i < n; i++)\n\t\th[i] = -1;\n\th[root] = 0;\n\tdfs1(root);\n\t/*\n\tfor (int i = 0; i < m; i++)\n\t\teprintf(""%d"", (int)isBridge[i]);\n\teprintf(""\\n"");\n\t*/\n\tfor (int v = 0; v < n; v++)\n\t\tmyComp[v] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (myComp[v] != -1) continue;\n\t\tdfsComp(v);\n\t\tk++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!isBridge[i]) continue;\n\t\tint v = myComp[ed[i][0]], u = myComp[ed[i][1]];\n\t\tassert(v != u);\n\t\tG[v].push_back(mp(u, ed[i][2]));\n\t\tG[u].push_back(mp(v, ed[i][2]));\n\t}\n\n\tif (k == 1) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(""%lld "", val[0]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tdeg[v] = (int)G[v].size();\n\t\tif (deg[v] <= 1) q[topQ++] = v;\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tsolve(q[i]);\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tans[v] = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint u = e.first;\n\t\t\tans[v] += dp[mp(v, u)];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%lld "", ans[myComp[i]]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']",,,"['dfs and similar', 'dp', 'graphs', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Directing Edges.json,https://codeforces.com//blog/entry/80809,Suppose we want to calculate the maximum profit for some vertex in Let s try to find out how it can be done and then optimize this process so we don t have to run it times First of all we have to find the bridges and biconnected components in our graph Why do we need them Edges in each biconnected component can be directed in such a way that it becomes a strongly connected component so we don t have to leave these edges undirected it is never optimal Furthermore for each such component either all vertices are saturated or no vertex is saturated Let s build a tree where each vertex represents a biconnected component of the original graph and each edge represents a bridge We can solve the problem for this tree and then the answer for some vertex of the original graph is equal to the answer for the biconnected component this vertex belongs to Okay now we have a problem on tree Let s implement the following dynamic programming solution root the tree at the vertex we want to find the answer for and for each vertex calculate the value of the maximum profit we can get for the subtree of vertex if it should be reachable by all special vertices from its subtree Let s analyze how we can calculate these values Suppose we have a vertex with children we have already calculated the values for the children and we want to calculate First of all since the vertex is going to be saturated we will get the profit from it so we initialize with Then we should decide whether we want to get the profit from the children of vertex Suppose the edge leading from to has weight If we want to take the profit from the subtree of we usually have to make this edge undirected so both vertices are saturated thus we get as profit or we could leave this edge directed from to so the vertex is saturated and is not and get as the profit But sometimes we can gain the profit from the vertex and its subtree without leaving the edge undirected if all special vertices belong to the subtree of we can just direct this edge from to and there is no reason to choose the opposite direction or leave the edge undirected Similarly if all special vertices are outside of this subtree there s no reason to direct the edge from to So if one of this conditions is met we can get the full profit from the subtree of without leaving the edge undirected Okay let s summarize it We can calculate as where is either if one of the aforementioned conditions is met we don t have to leave the edge undirected if we want to saturate both vertices or otherwise Now we have an solution Let s optimize it to Root the tree at vertex and calculate the dynamic programming as if is the root Then we shall use technique to recalculate the dynamic programming for all other vertices we will try each vertex as the root of the tree and is the answer for the vertex if it is the root The rerooting technique works as follows let s run DFS from the initial root of the tree and when we traverse an edge by starting or finishing a recursive call of DFS we move the root along the edge so if we call is the current root if it has some child we move the root to the same moment when we call and when the call of ends the root moves back to Okay the only thing that s left is to describe how we move the root If the current root is and we want to move it to a vertex adjacent to then we have to change only the values of and first of all since is no longer a child of we have to subtract the value that was added to while we considered vertex then we have to make the child of vertex so we add the profit we can get from the vertex to It can be done in so our solution runs in though with a very heavy constant factor 
https://codeforces.com//contest/1722/problem/C,1524435,C,1722C,1722,C. Word Game,Three guys play a game first each person writes down n distinct words of length 3 Then they total up the number of points as follows if a word was written by one person that person gets 3 points if a word was written by two people each of the two gets 1 point if a word was written by all nobody gets any points In the end how many points does each player have ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint t,n,a[200005];\nstring s[4][200005];\nsigned main()\n{\n\tcin>>t;\n\tmap<string,int>cnt;\n\twhile(t--)\n\t{\n\t\tcnt.clear();\n\t\tcin>>n;\n\t\tfor(int i=1;i<=3;i++)for(int j=1;j<=n;j++)cin>>s[i][j],cnt[s[i][j]]++;\n\t\tfor(int i=1;i<=3;i++)\n\t\t{\n\t\t\tint ans=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint x=cnt[s[i][j]];\n\t\t\t\tif(x==1)ans+=3;\n\t\t\t\telse if(x==2)ans++;\n\t\t\t\telse ;\n\t\t\t}\n\t\t\tprintf(""%d "",ans);\n\t\t}\n\t\tprintf(""\\n"");\n\t}\n \treturn 0;\n}']",,,"['data structures', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV4\C. Word Game.json,https://codeforces.com//blog/entry/106478,You need to implement what is written in the statement To quickly check if a word is written by another guy you should store some or Python dictionary and increment every time you see a new string in the input Then you should iterate through each guy find the number of times their word appears and update their score The complexity is per testcase 
https://codeforces.com//contest/1775/problem/A1,1730872,A1,1775A1,1775,A1. Gardener and the Capybaras  easy version ,Kazimir Kazimirovich is a Martian gardener He has a huge orchard of binary balanced apple trees Recently Casimir decided to get himself three capybaras The gardener even came up with their names and wrote them down on a piece of paper The name of each capybara is a non empty line consisting of letters and Denote the names of the capybaras by the lines a b and c Then Casimir wrote the nonempty lines a b and c in a row without spaces For example if the capybara s name was and then the string the gardener wrote down would look like The gardener remembered an interesting property either the string b is lexicographically not smaller than the strings a and c at the same time or the string b is lexicographically not greater than the strings a and c at the same time In other words either a le b and c le b are satisfied or b le a and b le c are satisfied or possibly both conditions simultaneously Here le denotes the lexicographic less than or equal to for strings Thus a le b means that the strings must either be equal or the string a must stand earlier in the dictionary than the string b For a more detailed explanation of this operation see Notes section Today the gardener looked at his notes and realized that he cannot recover the names because they are written without spaces He is no longer sure if he can recover the original strings a b and c so he wants to find any triplet of names that satisfy the above property ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tstring s; cin>>s;\n\t\t\n\t\tbool done=false;\n\t\trep(x,1,sz(s)-1) if (s[x]==\'a\'){\n\t\t\tcout<<s.substr(0,x)<<"" a ""<<s.substr(x+1,sz(s)-x-1)<<endl;\n\t\t\tdone=true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (!done) cout<<s[0]<<"" ""<<s.substr(1,sz(s)-2)<<"" ""<<s[sz(s)-1]<<endl;\n\t}\n}\n']",,,"['brute force', 'constructive algorithms', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A1. Gardener and the Capybaras  easy version .json,https://codeforces.com//blog/entry/111286,To solve this problem it was enough just to consider all options of splitting the string into three substrings and there are only ways to do it 
https://codeforces.com//contest/1437/problem/E,775843,E,1437E,1437,E. Make It Increasing,You are given an array of n integers a 1 a 2 a n and a set b of k distinct integers from 1 to n In one operation you may choose two integers i and x 1 le i le n x can be any integer and assign a i x This operation can be done only if i does not belong to the set b Calculate the minimum number of operations you should perform so the array a is increasing that is a 1 a 2 a 3 dots a n or report that it is impossible ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int INF = (int)1e9 + (int)1e8;\nconst int N = 500500;\nint a[N];\nint c[N];\nint n;\n\nint solve(int L, int R) {\n\t/*\n\teprintf(""solve\\n"");\n\tfor (int i = L; i <= R; i++)\n\t\teprintf(""%d "", a[i]);\n\teprintf(""\\n"");\n\t*/\n\tif (a[L] > a[R]) return N;\n\tint len = R - L;\n\tfor (int i = 0; i < len; i++)\n\t\tc[i] = INF;\n\tc[0] = 0;\n\tfor (int i = L + 1; i < R; i++) {\n\t\tif (a[i] < a[L] || a[i] > a[R]) continue;\n\t\tint p = upper_bound(c, c + len, a[i]) - c;\n\t\tc[p] = a[i];\n\t}\n\tint ans = len - 1;\n\twhile(c[ans] == INF) ans--;\n\treturn len - 1 - ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint k;\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\ta[i] += n - i;\n\t}\n\ta[0] = 0;\n\ta[n + 1] = INF - 2;\n\tn += 2;\n\tint ans = 0;\n\tint lst = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tans += solve(lst, x);\n\t\tif (ans >= N) {\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tlst = x;\n\t}\n\tans += solve(lst, n - 1);\n\tif (ans >= N) {\n\t\tprintf(""-1\\n"");\n\t} else {\n\t\tprintf(""%d\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'data structures', 'dp', 'implementation']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Make It Increasing.json,https://codeforces.com//blog/entry/84149,First let s solve the problem without blocked positions Let s look at the array Obviously if strictly increases then does not decrease and vice versa Now we have to find the maximum number of positions in the array that can be left unchanged And you can always choose an integer that will not break the non decreasing array for the rest of positions This problem can be solved in by analogy with the largest increasing subsequence but now you can take equal elements Now you can realize that the segments between two blocked positions do not depend on each other and the initial problem can be solved as the problem described above All that remains is to check that all blocked positions do not break the strict array increment 
https://codeforces.com//contest/1606/problem/E,1163616,E,1606E,1606,E. Arena,There are n heroes fighting in the arena Initially the i th hero has a i health points The fight in the arena takes place in several rounds At the beginning of each round each alive hero deals 1 damage to all other heroes Hits of all heroes occur simultaneously Heroes whose health is less than 1 at the end of the round are considered killed If exactly 1 hero remains alive after a certain round then he is declared the winner Otherwise there is no winner Your task is to calculate the number of ways to choose the initial health points for each hero a i where 1 le a i le x so that there is no winner of the fight The number of ways can be very large so print it modulo 998244353 Two ways are considered different if at least one hero has a different amount of health For example 1 2 1 and 2 1 1 are different ,"['#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\ntemplate<typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n,x;\nll pw[505][505],C[505][505],d[505][505];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nint main(){\n\tn=readint(); x=readint();\n\tfor(int i=1;i<=x;i++){\n\t\tpw[i][0]=1;\n\t\tfor(int j=1;j<=n;j++) pw[i][j]=pw[i][j-1]*i%cys;\n\t}\n\tfor(int i=0;i<=n;i++) C[i][0]=1;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=i;j++) C[i][j]=mod(C[i-1][j]+C[i-1][j-1]);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=x;j++){\n\t\t\tif(j<=i-1){\n\t\t\t\td[i][j]=pw[j][i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=0;k<=i;k++){\n\t\t\t\tif(k==i-1) continue;\n\t\t\t\tif(k==i) d[i][j]=(d[i][j]+pw[i-1][k])%cys;\n\t\t\t\telse d[i][j]=(d[i][j]+C[i][k]*pw[i-1][k]%cys*d[i-k][j-i+1])%cys;\n\t\t\t}\n//\t\t\tcout<<""test ""<<i<<\' \'<<j<<\' \'<<d[i][j]<<endl;\n\t\t}\n\t}\n\tprintf(""%lld\\n"",d[n][x]);\n\treturn 0;\n}']",,,"['combinatorics', 'dp', 'math']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Arena.json,https://codeforces.com//blog/entry/96454,Let s calculate the following dynamic programming the number of ways to choose the initial health if there are heroes still alive and they already received damage Let s iterate over the number of heroes that will survive after the next round Then we have to make a transition to the state where the minimum of the maximum allowed health and plus the damage done in this round It remains to understand with what coefficient we should make this transition in dynamic programming This coefficient is equal to the number of ways to choose which of the living heroes will die in this round multiplied by the number of ways to choose health for these heroes because their health is greater than so that they are still alive at the moment but not more than so that they are guaranteed to die in this round Of course we don t make any transitions from the states where since they represent the fights that have already finished The answer is the sum of all for every 
https://codeforces.com//contest/1830/problem/F,1942560,F,1830F,1830,F. The Third Grace,You are given n intervals and m points on the number line The i th intervals covers coordinates l i r i and the i th point is on coordinate i and has coefficient p i Initially all points are not activated You should choose a subset of the m points to activate For each of n interval we define its as 0 if there are no activated points in the interval the coefficient of the activated point with the within it otherwise Your task is to maximize the sum of the costs of all intervals by choosing which points to activate ,"['#include ""bits/stdc++.h""\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define ar array\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing pi = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nconst int INFi = 2e9;\nconst ll INF = 2e18;\n\nstruct Line {\n    ll k, b;\n\n    ll get(ll x) { return k * x + b; }\n\n    // returns the x-intercept of intersection ""strictly"" larger than T\n    ll cross_after(Line &L, ll T) {\n        assert(L.get(T) >= get(T));\n        if (L.k >= k) return INF;\n        if (L.b >= b) return (L.b - b + (k - L.k)) / (k - L.k);\n        return (L.b - b + 1) / (k - L.k);\n    }\n\n    Line(ll k_ = 0, ll b_ = INF) : k(k_), b(b_) {}\n};\n\nstruct KineticSegTree { // min kinetic segment tree\n    struct Node {\n        Line best;\n        ll melt;\n        ar<ll, 2> upd; // upd[0] - heaten, upd[1] - add x\n\n        Node() : best(), melt(INF), upd({0, 0}) {}\n    };\n\n    ll T;\n    int n;\n    vector<Node> t;\n\n    void apply(int v, ar<ll, 2> x) {\n        t[v].upd[0] += x[0];\n        t[v].upd[1] += x[1];\n        t[v].best.b += x[0] * t[v].best.k + x[1];\n        t[v].melt -= x[0];\n    }\n\n    bool IsBetter(Line &a, Line &b) {\n        ll l = a.get(T), r = b.get(T);\n        if (l != r)\n            return l < r;\n        return a.k < b.k;\n    }\n\n    void pull(int v) {\n        Line A = t[v << 1].best;\n        Line B = t[v << 1 | 1].best;\n        t[v].melt = min(t[v << 1].melt, t[v << 1 | 1].melt);\n        if (IsBetter(B, A)) swap(A, B);\n        t[v].best = A;\n        t[v].melt = min(t[v].melt, A.cross_after(B, T));\n    }\n\n    void init(vector<Line> &l, ll TT = 0) {\n        n = l.size();\n        T = TT;\n        t.resize(n * 4);\n        init(1, 0, n, l);\n    }\n\n    void init(int v, int l, int r, vector<Line> &lines) {\n        if (l + 1 == r) {\n            t[v].best = lines[l];\n            return;\n        }\n        init(v << 1, l, (l + r) >> 1, lines);\n        init(v << 1 | 1, (l + r) >> 1, r, lines);\n        pull(v);\n    }\n\n    void push(int v) {\n        if (!t[v].upd[0] && !t[v].upd[1]) return;\n        apply(v << 1, t[v].upd);\n        apply(v << 1 | 1, t[v].upd);\n        t[v].upd[0] = t[v].upd[1] = 0;\n    }\n\n    void propagate(int v) {\n        if (t[v].melt > 0) return;\n        push(v);\n        propagate(v << 1);\n        propagate(v << 1 | 1);\n        pull(v);\n    }\n\n    ll get(int v, int l, int r, int lq, int rq) {\n        if (rq <= l || r <= lq) return INF;\n        if (lq <= l && r <= rq) {\n            return t[v].best.get(T);\n        }\n        push(v);\n        return min(get(v << 1, l, (l + r) >> 1, lq, rq), get(v << 1 | 1, (l + r) >> 1, r, lq, rq));\n    }\n\n    ll get(int lq, int rq) {\n        return get(1, 0, n, lq, rq);\n    }\n\n    void upd(int v, int l, int r, int lq, int rq, ar<ll, 2> &x) {\n        if (rq <= l || r <= lq) return;\n        if (lq <= l && r <= rq) {\n            apply(v, x);\n            propagate(v);\n            return;\n        }\n        push(v);\n        upd(v << 1, l, (l + r) >> 1, lq, rq, x);\n        upd(v << 1 | 1, (l + r) >> 1, r, lq, rq, x);\n        pull(v);\n    }\n\n    void upd(int lq, int rq, ar<ll, 2> x) {\n        upd(1, 0, n, lq, rq, x);\n    }\n\n    void heaten(int lq, int rq, ll x) {\n        upd(lq, rq, {x, 0});\n    }\n\n    void add(int lq, int rq, ll x) {\n        upd(lq, rq, {0, x});\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int m;\n    cin >> m;\n    vi l(n), r(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i];\n    }\n    vector<Line> a(m + 1, {0, 0});\n    for (int i = 1; i <= m; ++i) {\n        cin >> a[i].k;\n        a[i].k *= -1;\n    }\n    KineticSegTree kst;\n    kst.init(a, 0);\n    vi ord(n);\n    iota(all(ord), 0);\n    sort(all(ord), [&](const int &i, const int &j) { return r[i] < r[j]; });\n    int j = 0;\n    for (int i = 1; i <= m; ++i) {\n        ll ans = kst.get(0, i);\n        kst.add(i, i + 1, ans);\n        while (j < n && r[ord[j]] == i) {\n            kst.heaten(l[ord[j]], r[ord[j]] + 1, 1);\n            j++;\n        }\n    }\n    cout << -kst.get(0, m + 1) << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n     cin >> t;\n    rep(_, t) {\n        solve();\n    }\n    return 0;\n}']",,,"['data structures', 'dp']",3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. The Third Grace.json,https://codeforces.com//blog/entry/116527,SolutionLet be the maximum sum of costs of activated points that are over all states that has point activated When we transition from to we need to add the cost contributed by point The number of ranges where point is the largest coordinate within it are the ranges which satisfy So we have where is the number of ranges which satisfy Now we note that With some work we can get calculate this in But this will be too slow let s try to speed this up Let us define We have Our goal is to go from implictly storing to As looks like a linear function w r t we can try to use convex hull data structures to maintain it Let s figure out how relates to We need to subtract the number of ranges with and add the number of ranges with and This corresponds to and differing by amortized suffix increment updates Also note that is non decreasing So we want to support the following data structure Initially we have an arrays and that are both initially Handle the following updates 1 m c for all 2 j k for all It is guaranteed that will always be non decreasing 3 i find This can be maintained in a lichao tree in time In each lichao node we need to store the start middle and end indices and their corresponding values respectively This way we can support operations and already To support operation note that in a lichao tree you can use time to push down all lines that covers a certain point refer to https codeforces com blog entry 86731 This way all lines in the li chao tree are in or so you can do lazy updates on both the coordinates of the lines and the values The time complexity is There is another solution that works in that we are unable to optimize further yet Let us flip the array so that the condition is on the activated point with the smallest coordinate Then we have where counts the number of ranges such that Now we want to store the linear function in some sort of data structure so that we can evaluate the maximum value with Unfortunately the value of can change by suffix additions similar to above But since is non increasing here that means the optimal that maximizes decreases when increases That is for and we have two data structures that can get the maximum for respectively We can combine these data structures to make it for by binary searching the point where for all and for all Since querying this data structure takes it takes time to combine two such data structures If we use a segment tree we only need to rebuild different data structures the rest can be handled using lazy tags giving us a time complexity of 
https://codeforces.com//contest/1824/problem/C,1909040,C,1824C,1824,C. LuoTianyi and XOR-Tree,LuoTianyi gives you a tree with values in its vertices and the root of the tree is vertex 1 In one operation you can change the value in one vertex to any non negative integer Now you need to find the minimum number of operations you need to perform to make each path from the root to leaf dagger has a bitwise XOR value of zero dagger A leaf in a rooted tree is a vertex that has exactly one neighbor and is not a root ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n;    std::cin >> n;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }        std::vector<std::vector<int>> adj(n);        for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--, v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        std::vector<int> dp(n), t(n);    std::vector<std::set<int>> s(n);    std::function<void(int, int)> dfs = [&](int x, int p) {        std::map<int, int> cnt;        if (adj[x].size() == 1 && x) {            s[x].insert(0);            dp[x] = 1;        }        for (auto y : adj[x]) {            if (y == p) {                continue;            }            dfs(y, x);            dp[x] += dp[y] + 1;            if (s[x].size() < s[y].size()) {                std::swap(s[x], s[y]);                std::swap(t[x], t[y]);            }            for (auto z : s[y]) {                z ^= t[x] ^ t[y];                if (s[x].count(z)) {                    cnt[z ^ t[x]]++;                } else {                    s[x].insert(z);                }            }        }        if (!cnt.empty()) {            int mx = 0;            for (auto [_, v] : cnt) {                mx = std::max(mx, v);            }            dp[x] -= mx + 1;            s[x].clear();            t[x] = a[x];            for (auto [z, v] : cnt) {                if (v == mx) {                    s[x].insert(z);                }            }        } else {            dp[x] -= 1;            t[x] ^= a[x];        }    };    dfs(0, -1);        int ans = dp[0] + !s[0].count(t[0]);    std::cout << ans << ""\\n"";        return 0;}']",,,"['data structures', 'dfs and similar', 'dp', 'dsu', 'greedy', 'trees']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. LuoTianyi and XOR-Tree.json,https://codeforces.com//blog/entry/116328,Hint Consider a brute force dynamic programming solution and try to optimize it Denote the minimum number of operations needed to make every path from a leaf inside the subtree of u to the root have the xor value of w as fu w Observe that for every u there are only 2 possible different values for fu w This is because if fu w1 fu w2 1 we can use an operation of xor ing au with w1 xor w2 to make all the xor values from w2 to w1 which takes fu w2 1 steps instead of fu w1 Now we only need to calculate minnu minfu w and the set Su of w that makes fu w minimum We have minnv 0 and Sv the xor value from root to v for leaf v It s trivial to calculate minnu Note that Su contains of the numbers appearing the most times in the sets of u s son We can maintain Su using a map and merging it heuristically Consider when merging sets into a new set S If every element of S appears only once in the original sets then we keep S as the result otherwise brute force the whole set S and find the elements appearing the most times For the second situation every element s count of appearance is at least halved those appearing once have 0 and others have 1 afterwards so the number of brute force checking operations is O nlogn 
https://codeforces.com//contest/1691/problem/D,1416260,D,1691D,1691,D. Max GEQ Sum,You are given an array a of n integers You are asked to find out if the inequality max a i a i 1 ldots a j 1 a j geq a i a i 1 dots a j 1 a j holds for all pairs of indices i j where 1 leq i leq j leq n ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, a[N], lg[N];\npii st[20][N];\nbool fl;\n\nstruct node {\n\tll s, pre, suf;\n};\n\npii getmax(int l, int r) {\n\tint k = lg[r - l + 1];\n\treturn max(st[k][l], st[k][r - (1 << k) + 1]);\n}\n\nnode check(int l, int r) {\n\tif(l > r) return node{ 0, 0, 0 };\n\tif(l == r) return (node){ a[l], max(a[l], 0), max(a[l], 0) }; int p = getmax(l, r).se;\n\tnode ls = check(l, p - 1), rs = check(p + 1, r);\n\tnode ret; ret.s = ls.s + rs.s + a[p]; ret.pre = max(ls.pre, ls.s + a[p] + rs.pre); ret.suf = max(rs.suf, rs.s + a[p] + ls.suf);\n\tfl |= ls.suf + rs.pre + a[p] > a[p]; return ret;\n}\n\nvoid solve() {\n\tn = in; rep(i, 1, n) a[i] = in;\n\trep(i, 1, n) st[0][i] = { a[i], i };\n\trep(i, 2, n) lg[i] = lg[i >> 1] + 1;\n\trep(i, 1, lg[n])\n\t\trep(j, 1, n - (1 << i) + 1)\n\t\tst[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);\n\tfl = 0; check(1, n);\n\tputs(fl ? ""NO"" : ""YES"");\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'data structures', 'divide and conquer', 'implementation', 'two pointers']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Max GEQ Sum.json,https://codeforces.com//blog/entry/103212,Let s look at the problem from the perspective of each We want to check whether the sum of the subarrays where is the maximum element exceeds or not Firstly we must find out in which subarrays is the maximum This involves finding the previous greater element index and the next greater element index of which can be done for all indices in using stacks Take these indices as After computing this for every index we ll know that is max in subarrays with starting index and ending index Take which represents the sum of a subarray which starts at index and ends at index where If then giving us Hence at least one of the subarrays or has a sum greater than which implies that one of subarrays has sum greater than so only checking subarrays which start or end at index suffices Therefore for an index we need to check subarrays and subarrays Since we just care if any one of them exceed finding the max of them is enough This reduces to making a range query over the prefix sums and one over the suffix sums The query on prefix sums would look likeWhere returns the max prefix sum in the given range This query can be done using a segment tree in If any of the queries is true then we just have to output NO else output YES With this we get the time complexity of the solution as 
https://codeforces.com//contest/705/problem/A,67572,A,705A,705,A. Hulk,Dr Bruce Banner hates his enemies like others don t As we all know he can barely talk when he turns into the incredible Hulk That s why he asked you to help him to express his feelings Hulk likes the Inception so much and like that his feelings are complicated They have layers The first layer is hate second one is love third one is hate and so on For example if then his feeling is or if it s and if it s and so on Please help Dr Banner ,"['#include ""stdio.h""\n\nint n;\n\nint main(){\n\tscanf(""%d"",&n);\n\tprintf(""I hate"");\n\tfor(int i = 1; i < n; i++){\n\t\tif(i%2==1) printf("" that I love"");\n\t\telse printf("" that I hate"");\n\t}\n\tprintf("" it\\n"");\n}']",,,['implementation'],800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Hulk.json,https://codeforces.com//blog/entry/46450,Just alternatively print I hate that and I love that and in the last level change that to it 
https://codeforces.com//contest/1859/problem/E,2156545,E,1859E,1859,E. Maximum Monogonosity,You are given an array a of length n and an array b of length n The of a segment l r 1 le l le r le n is defined as b l a r b r a l Recall that two segments l 1 r 1 1 le l 1 le r 1 le n and l 2 r 2 1 le l 2 le r 2 le n are non intersecting if one of the following conditions is satisfied r 1 l 2 or r 2 l 1 The length of a segment l r 1 le l le r le n is defined as r l 1 Find the maximum possible sum of costs of non intersecting segments l j r j 1 le l j le r j le n whose total length is equal to k ,"['#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nint a[3005],b[3005];\nint dp[3005][3005][5];\nsigned main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tint n,k; cin>>n>>k;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=1;i<=n;i++) cin>>b[i];\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=3000;j++) for(int l=0;l<5;l++) dp[i][j][l]=-1e18;\n\t\tdp[0][0][0]=0; \n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<=k;j++){\n\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\tif(l==0){\n\t\t\t\t\t\tdp[i][j][0]=max(dp[i][j][0],dp[i-1][j][l]);\n\t\t\t\t\t\tdp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+llabs(a[i]-b[i])*2);\n\t\t\t\t\t\tdp[i][j+1][1]=max(dp[i][j+1][1],dp[i-1][j][l]+a[i]+b[i]);\n\t\t\t\t\t\tdp[i][j+1][2]=max(dp[i][j+1][2],dp[i-1][j][l]+a[i]-b[i]);\n\t\t\t\t\t\tdp[i][j+1][3]=max(dp[i][j+1][3],dp[i-1][j][l]-a[i]+b[i]);\n\t\t\t\t\t\tdp[i][j+1][4]=max(dp[i][j+1][4],dp[i-1][j][l]-a[i]-b[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j+1][l]=max(dp[i][j+1][l],dp[i-1][j][l]);\n\t\t\t\t\t\tif(l==1) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]-a[i]-b[i]);\n\t\t\t\t\t\tif(l==2) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+a[i]-b[i]);\n\t\t\t\t\t\tif(l==3) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]-a[i]+b[i]);\n\t\t\t\t\t\tif(l==4) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+a[i]+b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n][k][0]<<""\\n"";\n\t}\n\treturn 0;\n}\n']",,,"['brute force', 'dp', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Maximum Monogonosity.json,https://codeforces.com//blog/entry/119287,TutorialLet s call the value of a segment Let s write maximum value of segments of total length that end before The obvious way to recalc is the following This works in and is too slow Now let s consider the following instead of getting the absolute value of segment we consider the maximum of the following four combinations We can see that this always gives us the correct answer to the absolute value since we check all of the possibilities Now we can look at out dp states as a table and notice that we recalc over the diagonal we recalc over all states that have the same value of n1 k1 Now for each diagonal we maintain four maximum combinations and when we want to recalc state we just consider all of the four possibilities 
https://codeforces.com//contest/135/problem/A,716,A,135A,135,A. Replacement,Little Petya very much likes arrays consisting of integers where each of them is in the range from to inclusive Recently he has received one such array as a gift from his mother Petya didn t like it at once He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from to inclusive It is to replace a number with itself or to change no number at all After the replacement Petya sorted the array by the numbers non decreasing Now he wants to know for each position what minimum number could occupy it after the replacement and the sorting ,"['#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <memory.h>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define forn( i,n ) for ( int i=0; i<(int)(n); i++ )\n#define foreach( it, a ) for ( __typeof((a).begin()) it = (a).begin(); it != (a).end(); it++ )\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nint n, a[100010];\n\nint main()\n{\n  scanf( ""%d"", &n );\n  forn( i, n ) scanf( ""%d"", &a[i] );\n  sort( a, a+n );\n  if ( a[n-1] == 1 ) a[n-1] = 2; else a[n-1] = 1;\n  sort( a, a+n );\n  forn( i, n ) {\n    if ( i ) printf( "" "" );\n    printf( ""%d"", a[i] );\n  }\n  return 0;\n}']",,,"['greedy', 'implementation', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Replacement.json,https://codeforces.com//blog/entry/3353,If the largest number in our array is equal to 1 then let s replace it with 2 otherwise let s replace it with 1 After that let s sort the array and output it It is easy to see that the array obtained in that way is the one we are looking for 
https://codeforces.com//contest/1707/problem/B,1465654,B,1707B,1707,B. Difference Array,You are given an array a consisting of n non negative integers It is guaranteed that a is sorted from small to large For each operation we generate a new array b i a i 1 a i for 1 le i n Then we sort b from small to large replace a with b and decrease n by 1 After performing n 1 operations n becomes 1 You need to output the only integer in array a that is to say you need to output a 1 ,"['#include <cstdio>\n#include <algorithm>\n\nint t,n,a[100001];\nint main(){\n\tscanf(""%d"",&t);\n\tfor(int fd=1;fd<=t;++fd){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;++i)scanf(""%d"",a+i);\n\t\tint cnt=0;\n\t\tfor(;n>1;){\n\t\t\tint top=0;\n\t\t\tint Old=a[1];\n\t\t\tfor(int i=1;i<n;++i){\n\t\t\t\ta[++top]=a[i+1]-a[i];\n\t\t\t}\n\t\t\tif(cnt)a[++top]=Old,--cnt;\n\t\t\tstd::sort(a+1,a+top+1);\n\t\t\tint p=0;\n\t\t\tfor(int i=1;i<=top;++i)if(!a[i])p=i;\n\t\t\ttop-=p;cnt+=p;\n\t\t\tfor(int i=1;i<=top;++i)a[i]=a[i+p];\n\t\t\tn=top;\n\t\t\t// for(int i=1;i<=n;++i)printf(""%d "",a[i]);putchar(\'\\n\');\n\t\t}\n\t\tif(!n)puts(""0"");\n\t\telse printf(""%d\\n"",a[1]);\n\t}\n}']",,,"['brute force', 'data structures', 'implementation', 'sortings']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Difference Array.json,https://codeforces.com//blog/entry/104930,Let s prove that the brute force solution considering zeros differently can pass Define and it changes when an operation is performed After sorting the array and ignoring s the factis always true And after performing one operation So in each operation you cost time to sort the new array and decrease by at least After the first operation is The complexity is where 
https://codeforces.com//contest/1799/problem/F,1800603,F,1799F,1799,F. Halve or Subtract,You have an array of positive integers a 1 a 2 ldots a n of length n You are also given a positive integer b You are allowed to perform the following operations possibly several times in any order Choose some 1 le i le n and replace a i with lceil frac a i 2 rceil Here lceil x rceil denotes the smallest integer not less than x Choose some 1 le i le n and replace a i with max a i b 0 However you must also follow these rules You can perform at most k 1 operations of type 1 in total You can perform at most k 2 operations of type 2 in total For all 1 le i le n you can perform at most 1 operation of type 1 on element a i For all 1 le i le n you can perform at most 1 operation of type 2 on element a i The of an array is the sum of its elements Find the minimum cost of a you can achieve by performing these operations ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, b, k1, k2;\n    std::cin >> n >> b >> k1 >> k2;\n    \n    i64 sum = 0;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        sum += a[i];\n    }\n    \n    i64 ans = 0;\n    \n    std::sort(a.begin(), a.end(), std::greater());\n    \n    std::vector f(k1 + 1, std::vector<i64>(k2 + 1));\n    int mid = 0;\n    while (mid < n && a[mid] >= b) {\n        mid++;\n    }\n    \n    i64 res = 0;\n    for (int i = 0; i <= k1; i++) {\n        if (i > 0 && i <= mid) {\n            res += a[i - 1] / 2;\n        }\n        int t = std::min(i, mid);\n        i64 v = res;\n        for (int j = 0; j <= k2; j++) {\n            if (j > 0) {\n                if (t + j <= mid) {\n                    v += b;\n                } else if (j <= mid) {\n                    v += std::min(b, (a[t + j - mid - 1] + 1) / 2);\n                }\n            }\n            f[i][j] = v;\n        }\n    }\n    \n    res = 0;\n    for (int i = 0; i <= std::min(k2, n - mid); i++) {\n        if (i > 0) {\n            res += a[mid + i - 1];\n        }\n        i64 v = res;\n        for (int j = 0; j <= std::min(k1, n - i - mid); j++) {\n            if (j > 0) {\n                v += a[mid + i + j - 1] / 2;\n            }\n            ans = std::max(ans, v + f[k1 - j][k2 - i]);\n        }\n    }\n    \n    ans = sum - ans;\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['binary search', 'brute force', 'dp', 'greedy', 'sortings']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Halve or Subtract.json,https://codeforces.com//blog/entry/113321,For convenience let denote and denote First notice that if we apply both operations to some element it will be optimal to apply halving first then subtraction We can prove this with 2 cases In this case and so Since applying either function to a nonnegative integer results in a nonnegative integer Otherwise Then and Since Next suppose there are exactly elements to which we apply both operations Then it will be optimal to apply both operations to the greatest elements in the array This should be somewhat intuitive but here s a proof Suppose there are some such that Suppose we apply both operations to and only one operation to Then applying both operations to and a single operation to instead won t increase the resulting sum We can prove this with two cases We apply to Note that since it s optimal to apply first when applying both operations this case is essentially halve both elements then choose one to apply to And it s better to subtract from the greater element since for We apply to We can analyze this with surprise a few cases Then whichever element we apply both operations to will be and the result will depend only on the other element for so it s better to apply both operations to the greater element If we apply both operations to the greater element we subtract from the sum But applying both operations to the lesser element subtracts from the sum So it s optimal to apply both operations to the greater element And this covers all cases where Let s fix the number of elements we apply both operations to After taking them out we will be left with the smallest elements in the array Suppose we have operations of type 1 left and operations of type 2 left We ll assume otherwise we can apply both operations to more elements Notice that it s optimal to apply our operations to the greatest remaining elements subtracting from a greater element can t decrease the amount we subtract and halving a greater element can t decrease the amount we take away So we re left with elements and we want to choose of them to apply the halving to Let s consider a few cases and try to analyze them Let and suppose we want to apply to one of them and to the other Then it will be optimal to apply to the greater element Then it will be optimal to apply to the smaller element Using this information we can form the final lemma we need for our solution Let Suppose we apply to and and to Then it will not increase the answer to apply to one of or instead There are 4 cases we should consider to prove this lemma Then we should apply to and to the others Then we should apply to and to the others Then we should apply to and to the others Then we should apply to and to the others You can verify that doing this produces the optimal answer And using this lemma we find that the optimal answer has all operations applied to some of the middle elements with all operations applied to the endpoints To summarize the optimal answer will have a form like this assuming is sorted in non increasing order First come some elements to which we apply both operations Second come some elements to which we apply only Third come some elements to which we apply only Fourth come some elements to which we apply only Finally come some elements to which we apply no operations Note that some of these segments may be empty It s easy to verify that it s optimal to use all given operations So if we loop through all possible sizes for the first two segments we can uniquely determine the sizes of the last three Finally using prefix sums to quickly find the sums of elements in a segment we get an solution There is an interesting fact if we will fix the size of the first group and calculate the answer for it the function is convex So the ternary or binary search can be used here to find the minimum in time but it was not necessary 
https://codeforces.com//contest/368/problem/B,4092,B,368B,368,B. Sereja and Suffixes,Sereja has an array consisting of integers The boy cannot sit and do nothing he decided to study an array Sereja took a piece of paper and wrote out integers For each number he wants to know how many distinct numbers are staying on the positions Formally he want to find the number of distinct numbers among Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time Help him find the answer for the described question for each ,"['/*\n * Package: StandardCodeLibrary.Core\n * */\n//引进常用的头文件并使用std名字空间;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//用于减少代码量的宏;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//调试相关的宏;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(""OLE"");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,""r"",stdin)\n#define output(out) freopen(out,""w"",stdout)\n#else\n#define prt(x) cerr<<""第""<<__LINE__<<""行\\t: ""<<#x""\\t=""<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define runtime() cerr<<""Used: ""<<db(clock())/CLOCKS_PER_SEC<<""s""<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//常用数据类型;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//常用常量:int的最大值;lli的最大值;db的误差相关常数;欧拉常数;圆周率;移动向量;取模使用的除数;\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//常用函数:最大最小值更新;数学相关函数;输入和输出;树状数组;并查集;可合并堆;\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ninline lli bin_pow(lli x,lli y){lli z=1;whl(y){if(y&1)z=mod(z*x);x=mod(sqr(x)),y>>=1;}rtn z;}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<"" ""<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?"""":"" "");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));rrep(i,y){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ninline void make_set(vpii& st){rep(i,sz(st))st[i]=mp(i,1);}\ninline int find_set(vpii& st,int x){int y=x,z;whl(y!=st[y].x)y=st[y].x;whl(x!=st[x].x)z=st[x].x,st[x].x=y,x=z;rtn y;}\ninline bool union_set(vpii& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?(st[a].y>st[b].y?st[a].x=b,st[a].y+=st[b].y:st[b].x=a,st[b].y+=st[a].y),true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//初始化;\nstruct Initializer{\n#ifndef DEBUG\nInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n~Initializer(){runtime();}\n#endif\n}initializer;\n\n//非标准;\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx::rope<char> rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tvi a(n);\n\tcin>>a;\n\tsi s;\n\tvi cnt(n);\n\trrep(i,n)\n\t{\n\t\ts.ins(a[i]);\n\t\tcnt[i]=sz(s);\n\t}\n\trep(i,m)\n\t{\n\t\tint l;\n\t\tcin>>l;\n\t\tcout<<cnt[--l]<<endl;\n\t}\n}\n']",,,"['data structures', 'dp']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Sereja and Suffixes.json,https://codeforces.com//blog/entry/9726,We will count value number of different elements on the suffix from For calculation will walk from the end of the array and we count equals to if element has not yet met and otherwise 
https://codeforces.com//contest/1729/problem/D,1538785,D,1729D,1729,D. Friends and the Restaurant,A group of n friends decide to go to a restaurant Each of the friends plans to order meals for x i burles and has a total of y i burles 1 le i le n The friends decide to split their visit to the restaurant into several days Each day some group of friends goes to the restaurant Each of the friends visits the restaurant no more than once that is these groups do not intersect These groups must satisfy the condition that the total budget of each group must be than the amount of burles that the friends in the group are going to spend at the restaurant In other words the sum of all x i values in the group must not exceed the sum of y i values in the group What is the maximum number of days friends can visit the restaurant For example let there be n 6 friends for whom x 8 3 9 2 4 5 and y 5 3 1 4 5 10 Then first and sixth friends can go to the restaurant on the first day They will spend 8 5 13 burles at the restaurant and their total budget is 5 10 15 burles Since 15 ge 13 they can actually form a group friends with indices 2 4 5 can form a second group They will spend 3 2 4 9 burles at the restaurant and their total budget will be 3 4 5 12 burles 12 ge 9 It can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill So the maximum number of groups the friends can split into is 2 Friends will visit the restaurant for a maximum of two days Note that the 3 rd friend will not visit the restaurant at all Output the maximum number of days the friends can visit the restaurant for given n x and y ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    int n;\n    cin >> n;\n\n    vi x(n), y(n);\n\n    rep(i,0,n)\n    {\n        cin >> x[i];\n    }\n\n    rep(i,0,n)\n    {\n        cin >> y[i];\n        y[i] -= x[i];\n    }\n\n\n    sort(all(y), greater<>());\n\n    int ans = 0;\n\n    int j = n - 1;\n\n\n    rep(i,0,n)\n    {\n        while(j > i && y[j] + y[i] < 0)\n        {\n            j--;\n        }\n\n        if(j <= i)\n            break;\n\n        ans++;\n        j--;\n    }\n\n    cout << ans << endl;\n    \n    \n\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']",,,"['greedy', 'sortings', 'two pointers']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Friends and the Restaurant.json,https://codeforces.com//blog/entry/106916,First we sort the friends in descending order of Now for each friend we know the amount of money he lacks or vice versa which he has in excess In order to maximize the number of days it is most advantageous for friends to break into pairs It is the number of groups that matters not the number of people in the group so adding a third person to the pair won t improve the answer in any way Let s solve the problem using two pointers for the richest friend find the first friend from the end such that the sum of their values exceeds the sum of their values Then repeat this for all subsequent friends until the pointers meet If no pair could be formed or none of the friends has a value greater than then the answer is Otherwise print the number of pairs formed 
https://codeforces.com//contest/87/problem/A,457,A,87A,87,A. Trains,Vasya the programmer lives in the middle of the Programming subway branch He has two girlfriends Dasha and Masha who live at the different ends of the branch each one is unaware of the other one s existence When Vasya has some free time he goes to one of his girlfriends He descends into the subway at some time waits the first train to come and rides on it to the end of the branch to the corresponding girl However the trains run with different frequencies a train goes to Dasha s direction every minutes but a train goes to Masha s direction every minutes If two trains approach at the same time Vasya goes toward the direction with the lower frequency of going trains that is to the girl to whose directions the trains go less frequently see the note to the third sample We know that the trains begin to go simultaneously before Vasya appears That is the train schedule is such that there exists a moment of time when the two trains arrive simultaneously Help Vasya count to which girlfriend he will go more often ,"['#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#define mp make_pair\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef long long int64;\ntypedef vector<int> vi;\n\ntemplate<class T> T abs(T x) {return x > 0 ? x : (-x); }\ntemplate<class T> T sqr(T x) {return x * x; }\n\nint64 gcd(int64 x, int64 y) {\n    if (!y) return x;\n    return gcd(y, x % y);\n}\n\nint main()\n{\n    int64 a, b;\n    cin >> a >> b;\n    int64 d = gcd(a, b);\n    d = (a * b) / d;\n    int64 x = d / a;\n    int64 y = d / b;\n    if (a < b)\n        ++y;\n    else\n        ++x;\n    if (x > y) cout << ""Dasha\\n"";\n    else if (x < y) cout << ""Masha\\n"";\n    else cout << ""Equal\\n"";\n    return 0;\n}\n']",,,"['implementation', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Trains.json,https://codeforces.com//blog/entry/2121,This problem can be approached from two sides from a programmer s perspective and a mathematician s one We consider both approaches First let s write some general propositions Let s put on a straight line all the moments of time when the trains arrive We will refer the interval between two successive points to the girl to who the train that matches the right end of the segment is going Also note that the entire picture is periodic with the period equal to lcm a b Vasya will obviously more often visit the girl whose total length of the segments is larger The programming approach is about modeling the process If we need to compare the lengths of two sets of intervals then let s count them We can do it using two pointers Let s see what train comes next add time before the arrival of the train to one of the answers move the pointer and the current time We should stop either when two last trains arrive simultaneously or when arrive a b trains The solution has asymptotic O a b that fits the time limit Don t forget that lcm a b 10 12 i e we need the 64 bit data type The mathematical approach provides us with a more elegant and shorter solution however it takes more thinking It seems obvious that Vasya will more often go to the girl to who trains go more often This fact is almost true Let s try to prove it Let s divide a and b by their gcd from this obviously nothing will change To make it clearer let a b Let s calculate the total length of segments corresponding to the second girl For this we need to take a few facts into consideration 1 All of them do not exceed a 2 All a segments are different due to coprimeness of a and b 3 They all are at least 1 But such a set of intervals is unique it s set of numbers 1 2 a and its length equals Besides the equality is fulfilled when the following condition is met b a 1 Hence the following is true The answer is Equal when a b 1 otherwise Vasya goes more often to the girl to which the trains go more often The key is not to forget to divide a and b by their gcd 
https://codeforces.com//contest/628/problem/B,48824,B,628B,628,B. New Skateboard,Max wants to buy a new skateboard He has calculated the amount of money that is needed to buy a new skateboard He left a calculator on the floor and went to ask some money from his parents Meanwhile his little brother Yusuf came and started to press the keys randomly Unfortunately Max has forgotten the number which he had calculated The only thing he knows is that the number is divisible by You are given a string consisting of digits the number on the display of the calculator after Yusuf randomly pressed the keys Your task is to find the number of substrings which are divisible by A substring can start with a zero A substring of a string is a nonempty sequence of consecutive characters For example if string is then we have four substrings that are divisible by and For the string the answer is three As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n  std::string s;\n  in >> s;\n  int64_t ans = 0;\n  for (int i = 0; i < s.length(); i++) {\n    if (((s[i] - \'0\') % 4) == 0) {\n      ans++;\n    }\n  }\n  for (int i = 0; i + 2 <= s.length(); i++) {\n    int num = (s[i] - \'0\') * 10 + s[i + 1] - \'0\';\n    if (num % 4 == 0) {\n      ans += i + 1;\n    }\n  }\n  out << ans << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']",,,['dp'],1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. New Skateboard.json,https://codeforces.com//blog/entry/43203,This is one of the problems suggested by Bayram Berdiyev bayram Allanur Shiriyev Allanur Bekmyrat Atayev Bekmyrat A The key observation is that the number is divisible by if and only if its last two digits forms a number divisible by So to calculate the answer at first we should count the substrings of length one Now let s consider pairs of consecutive digits If they forms a two digit number that is divisible by we should increase the answer by the index of the right one C solution Complexity 
https://codeforces.com//contest/283/problem/E,2744,E,283E,283,E. Cow Tennis Tournament,Farmer John is hosting a tennis tournament with his cows Each cow has a skill level and no two cows having the same skill level Every cow plays every other cow exactly once in the tournament and each cow beats every cow with skill level lower than its own However Farmer John thinks the tournament will be demoralizing for the weakest cows who lose most or all of their matches so he wants to flip some of the results In particular at different instances he will take two integers and flip all the results between cows with skill level between and inclusive That is for any pair he will change the result of the match on the final scoreboard so if won the match the scoreboard will now display that won the match and vice versa It is possible that Farmer John will change the result of a match multiple times It is not guaranteed that and are equal to some cow s skill level Farmer John wants to determine how balanced he made the tournament results look In particular he wants to count the number of triples of cows for which the final leaderboard shows that cow beats cow cow beats cow and cow beats cow Help him determine this number Note that two triples are considered different if they do not contain the same set of cows i e if there is a cow in one triple that is not in the other ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint tree[1100000];\nint add[1100000];\n\nvoid flip(int l,int r,int a,int b,int k){\n\tif(r<=a || l>=b)\n\t\treturn;\n\tif(l<=a && r>=b){\n\t\ttree[k]=b-a-tree[k];\n\t\tadd[k]^=1;\n\t\treturn;\n\t}\n\tint c=(a+b)/2;\n\tflip(l,r,a,c,k*2+1);\n\tflip(l,r,c,b,k*2+2);\n\ttree[k]=tree[k*2+1]+tree[k*2+2];\n\tif(add[k])\n\t\ttree[k]=b-a-tree[k];\n}\n\nint getsum(int l,int r,int a,int b,int k){\n\tl=max(l,a);\n\tr=min(r,b);\n\tif(r<=l)\n\t\treturn 0;\n\tif(l==a && r==b)\n\t\treturn tree[k];\n\tint c=(a+b)/2;\n\tint t=getsum(l,r,a,c,k*2+1)+getsum(l,r,c,b,k*2+2);\n\tif(add[k])\n\t\tt=r-l-t;\n\treturn t;\n}\n\nvector<int> qu1[110000];\nvector<int> qu2[110000];\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tios_base::sync_with_stdio(false);\n\t\n\tint n,k;\n\tcin>>n>>k;\n\tvector<PII> qus(k);\n\tvector<int> vals(n);\n\tforn(i,n){\n\t\tcin>>vals[i];\n\t}\n\tsort(all(vals));\n\tforn(i,k){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta=lower_bound(all(vals),a)-vals.begin();\n\t\tb=upper_bound(all(vals),b)-vals.begin();\n\t\tqu1[a].pb(b);\n\t\tqu2[b].pb(a);\n\t}\n\t\n\tlng res=1LL*n*(n-1)*(n-2)/6;\n\tforn(i,n){\n\t\tforv(j,qu1[i]){\n\t\t\tflip(i,qu1[i][j],0,n,0);\n\t\t}\n\t\tforv(j,qu2[i]){\n\t\t\tflip(qu2[i][j],i,0,n,0);\n\t\t}\n\t\tint t1=getsum(i+1,n,0,n,0);\n\t\tint t2=getsum(0,i,0,n,0);\n\t\tint s=(n-i-1)-t1+t2;\n\t\tlng t=1LL*s*(s-1)/2;\n\t\t//cout<<s<<\' \'<<t<<endl;\n\t\tres-=t;\n\t}\n\t\n\tcout<<res;\n\n\treturn 0;\n}\n']",,,"['combinatorics', 'data structures', 'math']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Cow Tennis Tournament.json,https://codeforces.com//blog/entry/7037,Here is a full solution to Codeforces 174 div 1 E I find this problem beautiful The first thing to note is that if you interpret the problem as a graph you can compute the answer if you have the degrees i e number of wins of every cow Call three cows unbalanced if the is one cow that beats the other two Note that every three cows is either unbalanced or balanced there are no other configurations of three cows Thus So to count the number of balanced it suffices to count the number of unbalanced But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow If we do this the dumb way this is O MN 2 still way too slow Sort the skill levels of the cows the order of the si doesn t actually matter s1 is lowest skill Now consider an n n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped The grid is initially all zeros and Farmer John s query simply flips a rectangle of the form a b a b and the outdegree wins of cow i is just Number of 1 s in range 1 i 1 Number of 0 s in range i 1 N Number of 1 s in range 1 i 1 N i Number of 1 s in range i 1 N We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval 1 N The seg tree needs to handle queries of the form Flip all numbers 0 1 1 0 in a range a b Query number of 1 s in a range a b 
https://codeforces.com//contest/1399/problem/F,691722,F,1399F,1399,F. Yet Another Segments Subset,You are given n segments on a coordinate axis OX The i th segment has borders l i r i All points x for which l i le x le r i holds belong to the i th segment Your task is to choose the by size the number of segments subset of the given set of segments such that each pair of segments in this subset either non intersecting or one of them lies inside the other one Two segments l i r i and l j r j are non intersecting if they have For example segments 1 2 and 3 4 1 3 and 5 5 are non intersecting while segments 1 2 and 2 3 1 2 and 2 2 are intersecting The segment l i r i lies inside the segment l j r j if l j le l i and r i le r j For example segments 2 2 2 3 3 4 and 2 4 lie inside the segment 2 4 while 2 5 and 1 4 are not You have to answer t independent test cases ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << \'=\' << x << std::endl\n\nconst int MAXN = 3000+5;\n\nint l[MAXN],r[MAXN];\nint n;\nstd::vector<int> S;\nint f[MAXN*2][MAXN*2];\nbool vis[MAXN*2][MAXN*2];\nstd::vector<int> a[MAXN*2];\n\ninline int dp(int l,int r){\n    if(l > r) return f[l][r] = 0;\n    if(f[l][r] != -1) return f[l][r];\n    int &res = f[l][r];\n    res = dp(l+1,r);\n    for(auto x:a[l]){\n        if(x > r) continue;\n        res = std::max(res,dp(l,x)+dp(x+1,r));\n    }\n    res += vis[l][r];\n    return res;\n}\n\ninline void Solve(){\n    scanf(""%d"",&n);S.clear();\n    FOR(i,1,n) scanf(""%d%d"",l+i,r+i),S.pb(l[i]),S.pb(r[i]);\n    std::sort(all(S));S.erase(std::unique(all(S)),S.end());\n    FOR(i,1,n) l[i] = std::lower_bound(all(S),l[i])-S.begin()+1,r[i] = std::lower_bound(all(S),r[i])-S.begin()+1;\n    FOR(i,1,n) a[l[i]].pb(r[i]),vis[l[i]][r[i]] = 1;\n    int M = S.size();\n    FOR(i,0,M+1) FOR(j,0,M+1) f[i][j] = -1;\n    printf(""%d\\n"",dp(1,M));\n    FOR(i,1,n) vis[l[i]][r[i]] = 0;\n    FOR(i,0,(int)S.size()) a[i].clear();\n}\n\nint main(){\n    int T;scanf(""%d"",&T);\n    while(T--) Solve();\n    return 0;\n}\n']",,,"['data structures', 'dp', 'graphs', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\F. Yet Another Segments Subset.json,https://codeforces.com//blog/entry/81082,Firstly let s compress the given borders of segments just renumerate them in such a way that the maximum value is the minimum possible and the relative order of integers doesn t change Pretty standard approach Now let s do recursive dynamic programming This state stores the answer for the segment not necessarily input segment How about transitions Firstly if there is a segment covering the whole segment why don t just take it It doesn t change anything for us The first transition is just skip the current left border and try to take the additional answer from the state The second transition is the following let s iterate over all possible segments starting at we can store all right borders of such segments in some array Let the current segment be If just skip it if then we can t take this segment into the answer because it s out of and if then we can t take it because we considered it already Then we can take two additional answers from and from Don t forger about some corner cases like when or and something like that You can get the answer if you run the calculation from the whole segment What is the time complexity of this solution We obviously have states And the number of transitions is also pretty easy to calculate Let s fix some right border For this right border we consider segments in total Summing up we get transitions So the time complexity is P S I am sorry about pretty tight ML yeah I saw Geothermal got some memory issues because of using map I really wanted to make it 512MB but just forgot to do that 
https://codeforces.com//contest/1205/problem/F,390602,F,1205F,1205,F. Beauty of a Permutation,Define the beauty of a permutation of numbers from 1 to n p 1 p 2 dots p n as number of pairs L R such that 1 le L le R le n and numbers p L p L 1 dots p R are consecutive R L 1 numbers in some order For example the beauty of the permutation 1 2 5 3 4 equals 9 and segments corresponding to pairs are 1 2 5 4 3 1 2 3 4 5 3 4 1 2 5 3 4 Answer q independent queries In each query you will be given integers n and k Determine if there exists a permutation of numbers from 1 to n with beauty equal to k and if there exists output one of them ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\npii h[105][105*107/2];\nint q,N[SZ],K[SZ];\nvector<int> aa[SZ];\nvector<int> qry[105][105*107/2];\nvector<int> ch[SZ];\nint an=0,ty[SZ];\nvector<int> op;\nvoid dfs(int w,int d=0)\n{\n//\tcerr<<w<<""!""<<ty[w]<<"":"";\n//\tfor(auto c:ch[w]) cout<<c<<"","";\n//\tcout<<""\\n"";\n\tif(!ch[w].size())\n\t{\n\t\top.pb(w);\n\t\treturn;\n\t}\n\tif(ty[w]==1)\n\t{\n\t\tvector<int> sb;\n\t\tint s=ch[w].size();\n\t\tfor(int t=1;t<s;t+=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tsb.pb(ch[w][0]);\n\t\tfor(int t=(s-1)-((s-1)&1);t>0;t-=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n\telse\n\t{\n\t\tvector<int> sb;\n\t\tfor(auto r:ch[w]) sb.pb(r);\n\t\tif(d) reverse(sb.begin(),sb.end());\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n}\nvector<int> cons(int n,int p)\n{\n//\tcerr<<n<<"",""<<p<<""\\n"";\n\tan=n;\n\tvector<int> st;\n\tfor(int i=1;i<=n;++i) ty[i]=0,ch[i].clear(),st.pb(i);\n\tint X=1,Y=p;\n\twhile(X!=n)\n\t{\n\t\tpii g=h[X][Y];\n\t\tassert(g.fi!=-1);\n\t\tint y=g.se%2; g.se/=2;\n\t\tint c=g.fi-X+1;\n\t\ttie(X,Y)=g;\n\t\t++an; ty[an]=y; ch[an].clear();\n\t\tfor(int j=1;j<=c;++j)\n\t\t\tch[an].pb(st.back()),st.pop_back();\n\t\treverse(ch[an].begin(),ch[an].end());\n\t\tst.pb(an);\n\t}\n\tassert(Y==n&&st.size()==1);\n\top.clear();\n\tdfs(an);\n\t#ifdef LOCAL\n\t#warning ""LOCAL ON""\n\tassert(op.size()==n);\n\tint sb=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tvector<int> g;\n\t\tfor(int j=i;j<n;++j)\n\t\t{\n\t\t\tg.pb(op[j]);\n\t\t\tsort(g.begin(),g.end());\n\t\t\tbool ok=1;\n\t\t\tfor(int w=0;w<g.size();++w)\n\t\t\t\tok&=g[w]==g[0]+w;\n\t\t\tif(ok) ++sb;\n\t\t}\n\t}\n//\tcerr<<sb<<""?\\n"";\n\tassert(sb==p);\n\t#endif\n\treturn op;\n}\nint main()\n{\n\tscanf(""%d"",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(""%d%d"",N+i,K+i),\n\t\tqry[N[i]][K[i]].pb(i);\n\tfor(int n=1;n<=100;++n)\n\t{\n\tmemset(h,-1,sizeof h);\n\th[n][n]=pii(0,0);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tfor(int j=n*(n+1)/2;j>=0;--j) if(~h[i][j].fi)\n\t\t{\n\t\t\tfor(int c=2;c<=i;++c)\n\t\t\t{\n\t\t\t\th[i-c+1][j+c*(c-1)/2]=pii(i,j*2);\n\t\t\t\tif(c>=4) h[i-c+1][j+1]=pii(i,j*2+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=n*(n+1)/2;j>=0;--j)\n\t\tif(h[1][j].fi!=-1&&qry[n][j].size())\n\t\t{\n\t\t\tauto u=cons(n,j);\n\t\t\tfor(auto r:qry[n][j]) aa[r]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tif(aa[i].size())\n\t\t{\n\t\t\tputs(""YES"");\n\t\t\tfor(auto x:aa[i])\n\t\t\t\tprintf(""%d "",x);\n\t\t\tputs("""");\n\t\t}\n\t\telse\n\t\t\tputs(""NO"");\n}\n']",,,"['constructive algorithms', 'math']",3400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\F. Beauty of a Permutation.json,https://codeforces.com/blog/entry/69158,We will denote if there exists a permutation of length with beauty equal to To begin with it is obvious that the beauty of a permutation of length is at least for indeed you can take each element individually and the entire permutation completely Statement 1 if and then Let be a permutation of length whose beauty is and be a permutation of length whose beauty is equal to Let us build from them a permutation of length whose beauty is We expand in the permutation to and to the rest of the elements greater than add We got a permutation of length Denote it by If is not between then we reverse the first elements and this will be done in a new permutation Now let be between Then what good pairs do we have in There are good pairs among the first elements there are good pairs if you count the first elements in one and we counted the interval from the first elements twice so we counted pairs At the same time this is all pairs because if some good segment contains and then it must contain as well Thus this statement is proved Statement 2 if then either or or exist such that and Show it We will call subsegments consisting of several consecutive numbers in some order Consider some kind of permutation of length of beauty Suppose that We want to show that in the permutation there is some good subsegment of length not equal to or with the following property for any other good subsegment if and intersect then one of them contains the second In this case by analogy with the proof of Proposition 1 we can squeeze the segment into one element obtaining some kind of permutation Then the number of good segments in the entire permutation will be equal to the number of good sub segments on the segment the number of good segments in since we counted the segment twice We will call such a segment Thus if in each permutation there is then the statement is true Suppose that then in the permutation there is a good segment of length not equal to or Let s say he s not very good Then there is another We denote if there exists a permutation of length with beauty equal to To begin with it is obvious that the beauty of a permutation of length is at least for indeed you can take each element individually and the entire permutation completely Statement 1 if and then Let mdash a permutation of length whose beauty is and mdash a permutation of length whose beauty is equal to Let us build from them a permutation of length whose beauty is We expand in the permutation to and to the rest of the elements greater than add We got a permutation of length Denote it by If is not between then we reverse the first elements and this will be done in a new permutation Now let be between Then what good pairs do we have in There are good pairs among the first elements there are good pairs if you count the first elements in one and we counted the interval from the first elements twice so we counted pairs At the same time this is all pairs because if some good segment contains and then it must contain as well Thus this statement is proved Statement 2 if then either or or such that and Show it We will call subsegments consisting of several consecutive numbers in some order Consider some kind of permutation of length of beauty Suppose that We want to show that in the permutation there is some good subsegment of length not equal to or with the following property for any other good subsegment if and intersect then one of them contains the second In this case by analogy with the proof of Proposition 1 we can squeeze the segment into one element obtaining some kind of permutation Then the number of good segments in the entire permutation will be equal to the number of good sub segments on the segment the number of good segments in since we counted the segment twice We will call such a segment Thus if in each permutation there is then the statement is true Let be a good segment that is not very good Then there is a good segment which intersects with but does not contain and is not contained in it The segments and form together segment It is easy to show that each of them is good and the numbers in the segments go monotonously Let us demonstrate this with an example the first segment is the second is Then together they will give the union of three segments As we can see each of these segments is good and also all numbers in the second segment are larger than all numbers in the first all numbers in the third segment are larger than all numbers in the second Let at the moment we have lined up a chain of good segments going consecutively where the union of any several consecutive ones is a good segment as well as all the numbers in more than all the numbers in or vice versa As long as is not equal to the whole segment we will do this since is very good there is a segment that intersects with it but is not contained in it does not contain It is easy to see that thanks to the segment our chain of good segments is extended Now suppose that is the whole segment While there is a segment of length greater than among the segments we will do the same if then we will find the necessary for it then will be split into two smaller good segments At the end of the process we get good segments of length each and the numbers are sorted monotonously Hence the numbers in the permutation were initially sorted monotonously whence the number of good segments is The statement is proved Now the left is easy for each from to we calculate what beauty values can be in a permutation of length using statement storing the corresponding values After that it is easy to answer the request by building a permutation of the desired beauty according to the algorithm with the approval of Asymptotics of With an incredibly small constant up to on this works for 300 ms Challenge improve the asymptotics to works in less than 30 ms 
https://codeforces.com//contest/1101/problem/E,281058,E,1101E,1101,E. Polycarp's New Job,Polycarp has recently got himself a new job He now earns so much that his old wallet can t even store all the money he has Berland bills somehow come in lots of different sizes However all of them are shaped as rectangles possibly squares All wallets are also produced in form of rectangles possibly squares A bill x times y fits into some wallet h times w if either x le h and y le w or y le h and x le w Bills can overlap with each other in a wallet and an infinite amount of bills can fit into a wallet That implies that all the bills Polycarp currently have fit into a wallet if every single one of them fits into it independently of the others Now you are asked to perform the queries of two types x y Polycarp earns a bill of size x times y h w Polycarp wants to check if all the bills he has earned to this moment fit into a wallet of size h times w It is guaranteed that there is at least one query of type 1 before the first query of type 2 and that there is at least one query of type 2 in the input data For each query of type 2 print if all the bills he has earned to this moment fit into a wallet of given size Print otherwise ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nint nq;\n\nvoid run() {\n\tscanf(""%d"",&nq);\n\tint a=0,b=0;\n\tREP(i,nq) {\n\t\tchar kind; scanf("" %c"",&kind);\n\t\tif(kind==\'+\') { int x,y; scanf(""%d%d"",&x,&y); if(x<y) swap(x,y); a=max(a,x); b=max(b,y); }\n\t\tif(kind==\'?\') { int x,y; scanf(""%d%d"",&x,&y); if(x<y) swap(x,y); printf(""%s\\n"",x>=a&&y>=b?""YES"":""NO""); }\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']",,,['implementation'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Polycarp's New Job.json,https://codeforces.com/blog/entry/64483,Let s find the smallest wallet to fit all bills One its side is the maximum side of any bill Now we orient the bills in such a way that their longer side is put against this side of the wallet The second side of the wallet is the maximum of the other sides More formally for set of bills for each the minimum wallet is The minimum wallet fits all sufficient wallets So the solution is maintaining the maximum of all and and checking if and Choose your i o functions wisely Overall complexity 
https://codeforces.com//contest/1380/problem/G,670989,G,1380G,1380,G. Circular Dungeon,You are creating a level for a video game The level consists of n rooms placed in a circle The rooms are numbered 1 through n Each room contains exactly one exit completing the j th room allows you to go the j 1 th room and completing the n th room allows you to go the 1 st room You are given the description of the multiset of n chests the i th chest has treasure value c i Each chest can be of one of two types regular chest when a player enters a room with this chest he grabs the treasure and proceeds to the next room mimic chest when a player enters a room with this chest the chest eats him alive and he loses The player starts in a random room with each room having an equal probability of being chosen The players earnings is equal to the total value of treasure chests he d collected before he lost You are allowed to choose the order the chests go into the rooms For each k from 1 to n place the chests into the rooms in such a way that each room contains one chest k chests are mimics the expected value of players earnings is possible Please note that for each k the placement is chosen independently It can be shown that it is in the form of frac P Q where P and Q are non negative integers and Q ne 0 Report the values of P cdot Q 1 pmod 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N; cin >> N;\n    vi C(N); F0R(i, N) cin >> C[i];\n\n    mi in = inv(mi(N));\n\n    sort(all(C)); reverse(all(C));\n    mi pre[N+1];\n    pre[0] = 0;\n    F0R(i, N) pre[i+1] = pre[i] + C[i];\n\n    FOR(K, 1, N+1) {\n        mi ans = 0;\n        for (int i = 0; i < N; i += K) {\n            ans += (i / K) * (pre[min(i+K, N)] - pre[i]);\n        }\n        ans *= in;\n        cout << ans << "" "";\n    }\n    cout << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['greedy', 'math', 'probabilities']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Circular Dungeon.json,https://codeforces.com//blog/entry/80054,TutorialAt first let s say that the expected value is equal to the average of total earnings over all positions and is equal to the sum of earnings over all positions divided by So we can trasition to minimizing the sum Let s learn how to solve the task for some fixed Fix some arrangement and rotate the rooms so that the last room contains a mimic So now you have regular chests then a single mimic regular chests single mimic regular chests single mimic All and Take a look at some of these intervals of length The last chest in the interval is taken from starting positions the second to last is taken times and so on Now let s find the optimal way to choose Fix some values of Take a look at the smallest of these values and the largest of them Let the values be and If they differ by at least then the smaller result can always be achieved by moving a regular chest from the larger one to the smaller one ProofConsider two sequences of coefficients for both intervals and However if you remove one chest then they will be equal to and If you only consider the difference between the numbers of both sequences then you can see that only coefficient got removed and coefficient was added So you can rearrange the chests in such a way that all chests are assigned to the same value and only the chest that was assigned to becomes assigned to thus decreasing the total value Now we have all set now The only thing left is to assign chests optimally Write down the union of all the coefficient sequences from all the intervals and sort them in the non decreasing order It s easy to show that the chests should be sorted in the non increasing order really classical thing you can try proving that by showing that any other arrangement can easily be improved once again That allows us to write a solution in Sort all the chests in the beginning after that for some multiply the value of the th chest by and sum up the results Finally let s speed this up with prefix sums Notice that the first values are multiplied by the second values by and so on If is not divisible by then the last block just has length smaller than Thus we can calculate the answer for some in And that s equal to Overall complexity 
https://codeforces.com//contest/311/problem/B,3069,B,311B,311,B. Cats Transport,Zxr960115 is owner of a large farm He feeds cute cats and employs feeders There s a straight road across the farm and hills along the road numbered from 1 to from left to right The distance between hill and is meters The feeders live in hill 1 One day the cats went out to play Cat went on a trip to hill finished its trip at time and then waited at hill for a feeder The feeders must take all the cats Each feeder goes straightly from hill 1 to without waiting at a hill and takes all the cats at each hill away Feeders walk at a speed of 1 meter per unit time and are strong enough to take as many cats as they want For example suppose we have two hills and one cat that finished its trip at time 3 at hill 2 Then if the feeder leaves hill 1 at time 2 or at time 3 he can take this cat but if he leaves hill 1 at time 1 he can t take it If the feeder leaves hill 1 at time 2 the cat waits him for 0 time units if the feeder leaves hill 1 at time 3 the cat waits him for 1 time units Your task is to schedule the time leaving from hill 1 for each feeder so that the sum of the waiting time of all cats is minimized ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,p,x,h,t,now,last,d[100010],ti[100010],q[100010];\nlong long f[100010][2],sum[100010];\nint main(){\n    scanf(""%d%d%d"",&n,&m,&p);\n    for(int i=2;i<=n;++i){\n        scanf(""%d"",&d[i]);\n        d[i]+=d[i-1];\n    }\n    for(int i=1;i<=m;++i){\n        scanf(""%d%d"",&x,&ti[i]);\n        ti[i]-=d[x];\n        sum[i]=sum[i-1]+ti[i];\n    }\n    sort(ti+1,ti+m+1);\n    memset(f,63,sizeof(f));\n    f[0][0]=0;\n    for(int e=1;e<=p;++e){\n        last=now;now^=1;\n        h=t=0;q[t]=0; \n        for(int i=1;i<=m;++i){\n            while(h<t&&f[q[h+1]][last]+sum[q[h+1]]-f[q[h]][last]-sum[q[h]]<=(long long)ti[i]*(q[h+1]-q[h]))++h;\n            f[i][now]=f[q[h]][last]+(long long)ti[i]*(i-q[h])-(sum[i]-sum[q[h]]);\n            while(h<t&&(f[q[t]][last]+sum[q[t]]-f[q[t-1]][last]-sum[q[t-1]])/(double)(q[t]-q[t-1]) > (f[i][last]+sum[i]-f[q[t]][last]-sum[q[t]])/(double)(i-q[t]) )--t;\n            q[++t]=i;\n        }\n    }\n    printf(""%I64d\\n"",f[m][now]);\n    return 0;\n} \n']",,,"['data structures', 'dp']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Cats Transport.json,https://codeforces.com//blog/entry/7785,P S I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn t realize some participants were not familiar with such kind of problems so I said it was easy Let a i be the distance from hill 1 to hill i s i a 1 a 2 a i Firstly we sort the cats by Ti a i Then we can divide the cats into P consecutive parts and plan a feeder for each part Dynamic Programming can solve this problem Let f i j indicates the minimum sum of waiting time with i feeders and j cats f i j f i 1 k a j j k s j s k a j j s j f i 1 k s k a j k That s O PM 2 It ll get TLE Let p q if p is better than q then f i 1 p s p a j p f i 1 q s q a j q f i 1 p s p f i 1 q s q a j p q g p g q a j p q So we can use Convex hull trick with a queue Then we get O MP which can pass the problem 
https://codeforces.com//contest/573/problem/A,34310,A,573A,573,A. Bear and Poker,Limak is an old brown bear He often plays poker with his friends Today they went to a casino There are players including Limak himself and right now all of them have bids on the table th of them has bid with size dollars Each player can double his bid any number of times and triple his bid any number of times The casino has a great jackpot for making all bids equal Is it possible that Limak and his friends will win a jackpot ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\nint n;\nint wyn;\nmain(){\n  make(n);\n  R(i,n){\n    int pom;make(pom);\n    while(pom%2 == 0)pom/=2;\n    while(pom%3 == 0)pom/=3;\n    if(i == 0)wyn = pom;\n    else{\n      if(wyn!=pom){\n        puts(""No"");\n        return 0;\n      }\n    }\n  }\n  puts(""Yes"");\n}\n']",,,"['implementation', 'math', 'number theory']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. Bear and Poker.json,https://codeforces.com//blog/entry/20040,Any positive integer number can be factorized and written as 2a 3b 5c 7d We can multiply given numbers by 2 and 3 so we can increase a and b for them So we can make all a and b equal by increasing them to the same big value e g 100 But we can t change powers of other prime numbers so they must be equal from the beginning We can check it by diving all numbers from input by two and by three as many times as possible Then all of them must be equal Alternative solution is to calculate GCD of given numbers Answer is YES iff we can get each number by multiplying GCD by 2 and 3 Otherwise some number had different power of prime number other than 2 and 3 
https://codeforces.com//contest/1704/problem/F,1489129,F,1704F,1704,F. Colouring Game,Alice and Bob are playing a game There are n cells in a row Initially each cell is either red or blue Alice goes first On each turn Alice chooses two neighbouring cells which contain at least one red cell and paints that two cells white Then Bob chooses two neighbouring cells which contain at least one blue cell and paints that two cells white The player who cannot make a move loses Find the winner if both Alice and Bob play optimally Note that a chosen cell can be white as long as the other cell satisfies the constraints ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 17:33:18       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = 200;\n  vector<int> g(N);\n  g[0] = 0;\n  for (int i = 1; i < N; i++) {\n    set<int> s;\n    for (int j = 1; j < i; j++) {\n      int x = g[j - 1];\n      int y = g[i - j - 1];\n      s.insert(x ^ y);\n    }\n    while (s.find(g[i]) != s.end()) {\n      g[i] += 1;\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int nr = 0, nb = 0;\n    for (char c : s) {\n      if (c == \'R\') {\n        nr += 1;\n      } else {\n        nb += 1;\n      }\n    }\n    if (nr > nb) {\n      cout << ""Alice"" << \'\\n\';\n      continue;\n    }\n    if (nr < nb) {\n      cout << ""Bob"" << \'\\n\';\n      continue;\n    }\n    int x = 0;\n    int beg = 0;\n    while (beg < n) {\n      int end = beg;\n      while (end + 1 < n && s[end + 1] != s[end]) {\n        end += 1;\n      }\n      int len = end - beg + 1;\n      while (len >= N) {\n        len -= 34;\n      }\n      x ^= g[len];\n      beg = end + 1;\n    }\n    cout << (x == 0 ? ""Bob"" : ""Alice"") << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'dp', 'games']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\F. Colouring Game.json,https://codeforces.com//blog/entry/105464,First when the number red cells and blue cells are not equal the player who owns a larger numberof his her corresponding cells will win Alice owns red and Bob owns blue His Her strategy can be each time paint one segment of or white until there is none This operation doesn t change the difference between the number of and and will decrease the number of the color of his her opponent Then Alice will only paint and while Bob will only paint or This operation will only decreace his her own number of color so the player who owns more cells of color will certainly win When the number of red cells and blue cells are the same Alice and Bob will play games first on red and blue segments until there is no or and the player who faces this situation will lose Playing games on red and blue segments can be described as the following game each player can take two neighbouring cells which has not be taken yet in his her turn As a result this game becomes equal then we can use SG function to forecast the result This SG function has the following calculating method In order to speed up we can observe that has a cyclic section of length except for the first few elements It can also be proved by verifying the first elements has this cyclic section and this demonstrates that for all kinds of xor combination of the cyclic section leads to this cycle Use Mathematical Induction and we can know this combination will be the the same just add some repeated numbers to the calculation of as the previous th number for the subsequent elements The total time complexity can be reduced to in calculating the SG function 
https://codeforces.com//contest/675/problem/C,60390,C,675C,675,C. Money Transfers,There are banks in the city where Vasya lives they are located in a circle such that any two banks are neighbouring if their indices differ by no more than Also bank and bank are neighbours if No bank is a neighbour of itself Vasya has an account in each bank Its balance may be negative meaning Vasya owes some money to this bank There is only one type of operations available transfer some amount of money from any bank to account in any bank There are no restrictions on the size of the sum being transferred or balance requirements to perform this operation Vasya doesn t like to deal with large numbers so he asks you to determine the minimum number of operations required to change the balance of each bank account to zero It s guaranteed that this is possible to achieve that is the total balance of Vasya in all banks is equal to zero ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e16;\n\nll p[200200], a[200200];\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    p[0] = a[0];\n    for (int i = 1; i < n; i++)\n        p[i] = a[i] + p[i - 1];\n    sort(p, p + n);\n    p[n] = INF;\n    int ans = 0;\n    int i = 0;\n    while (i < n)\n    {\n        int j = i;\n        while (p[j] == p[i])\n            j++;\n        ans = max (ans, j - i);\n        i = j;\n    }\n    cout << n - ans;\n    return 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy', 'sortings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Money Transfers.json,https://codeforces.com//blog/entry/44902,We have array and should make all numbers in it be equal to zero with minimal number of operations Sum of all equals to zero We can divide array into parts of consecutive elements with zero sum If part has length we can use all pairs of neighbours in operations and make all numbers be equal to zero with operations So if we sum number of operations in each part we get where is number of parts We should maximize to get the optimal answer One of the part consists of some prefix and probably some suffix Each of other parts is subarray of Let s calculate prefix sums Each part has zero sum so prefix sums before each part subarray are the same So we can calculate number of occurencies of the most frequent number in prefix sums and answer will be equal to Bonus how to hack solutions with overflow Code 
https://codeforces.com//contest/1406/problem/E,720775,E,1406E,1406,E. Deleting Numbers,There is an unknown integer x 1 le x le n You want to find x At first you have a set of integers 1 2 ldots n You can perform the following operations no more than 10000 times a find how many numbers are multiples of a in the current set a find how many numbers are multiples of a in this set and then delete all multiples of a but x will never be deleted even if it is a multiple of a In this operation a must be greater than 1 a it means that you know that x a This operation can be only performed once Remember that in the operation of type a 1 must hold Write a program that will find the value of x ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl \'\\n\'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\nconst int N = 100100;\nvi primes;\nbool mark[N];\n  int n;\nvoid crivo(){\n\n  for(int i=2;i<=n;i++){\n    if(!mark[i]){\n      if(i<=n)primes.pb(i);\n      for(int j=2*i;j<=n;j+=i)mark[j]=1;\n    }\n  }\n\n}\n\nbool saiu[N];\n\nint askB(int p){\n  if(p > n)return 0;\n  cout <<\'B\' << "" ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\nint askA(int p){\n  if(p > n)return 0;\n  cout << ""A ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\n\nint get(int p){\n  int res=0;\n  for(int i=p;i<=n;i+=p){\n    if(saiu[i])continue;\n    res++;\n    saiu[i] = 1;\n  }\n  return res;\n}\nll getlog(ll x,ll mx){\n  ll r = 1;\n  ll p = x;\n  while(p * x<=mx){\n    p*=x;\n    r++;\n  }\n  return r;\n}\nint elevate(int p,int pwr){\n  int r = 1;\n  for(int i=0;i<pwr;i++)r*=p;\n  return r;\n}\n\nconst int sq = 100;\n\nint P=1;\n#define DB 0\nvoid solve(vi cur){\n  //if(DB)cout <<""ENTREI""<<endl;\n  for(int p : cur){\n    int x = askB(p);\n    if(x!=0){\n\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid=(l+r)/2;\n        int per = askA(P * elevate(p,mid));\n        if(per!=0){\n          res = mid,l = mid + 1;\n        }else r = mid - 1;\n      }\n\n      P*=elevate(p,res);\n    }\n  }\n  \n}\n\nint32_t main(){\n  FASTIO;\n  cin>>n;\n  crivo();\n  \n  vi cur;\n  int fora = 0;\n  int i=0;\n  for(i=0;i<=sz(primes);i++){\n    if(i == sz(primes)){\n      \n    //  if(DB)cout<<""AQUI\\n"";\n\n      solve(cur);\n      break;\n    }\n    cur.pb(primes[i]);\n    int x = askB(primes[i]);\n    int s = get(primes[i]);\n    fora+=x;\n    if(s!=x){\n      solve(cur);\n      break;\n    }\n    if(sz(cur) == sq){\n      \n     // if(DB)cout <<""Aqui ... ""<<sz(cur)<<"" ""<<sq<<endl;\n\n      int A = askA(1);\n      if(A != n-fora){\n        solve(cur);\n        break;\n      }\n      cur.clear();\n    }\n  }\n  if(P == 1){\n    cout <<""C ""<<1<<endl;cout.flush();\n    return 0;\n  }\n  i++;\n  for(;i<sz(primes);i++){\n    int p = primes[i];\n    if(p<=1 || p > n)continue;\n    int per = askA(primes[i] * P);\n    if(per!=0){\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid = (l+r)/2;\n        per = askA(elevate(p,mid) * P);\n        if(per!=0){\n          l = mid + 1;\n          res = mid;\n        }else r = mid - 1;\n      }\n\n\n      P *= elevate(p,res);\n    }\n  }\n\n  cout <<""C ""<<P<<endl;\n  cout.flush();\n  return 0;\n\n}']",,,"['interactive', 'math', 'number theory']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Deleting Numbers.json,https://codeforces.com//blog/entry/82560,If we know what prime factors x has we can find just using bruteforce To find the prime factors we can just do for every prime in ascending order meanwhile calculate the numbers there supposed to be without if it differs with the number the interactor gives then contains the prime factor This way we can find every prime factor except for the smallest one Let be the number of primes no greater than Then we can split the prime numbers into groups After finishing asking a group ask and check if the return value same as it supposed to be without If it s the first time finding it different it means the smallest prime number is in the range then just check every prime numbers in the range by asking After finding the prime factors for each factor ask it can be proved this step will be done around times The total number of operations if around the total time complexity is 
https://codeforces.com//contest/1697/problem/C,1427642,C,1697C,1697,C. awoo's Favorite Problem,You are given two strings s and t both of length n Each character in both string is or In one move you can perform one of the following actions choose an occurrence of in s and replace it with choose an occurrence of in s and replace it with You are allowed to perform an arbitrary amount of moves possibly zero Can you change string s to make it equal to string t ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 18:37:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    vector<int> ns(1, 0);\n    vector<int> nt(1, 0);\n    string cs, ct;\n    for (int i = 0; i < n; i++) {\n      if (s[i] != \'b\') {\n        cs += s[i];\n        ns.push_back(0);\n      } else {\n        ns.back() += 1;\n      }\n      if (t[i] != \'b\') {\n        ct += t[i];\n        nt.push_back(0);\n      } else {\n        nt.back() += 1;\n      }\n    }\n    int sum = 0;\n    bool ok = true;\n    if (cs == ct) {\n      for (int i = 0; i < (int) ns.size() - 1; i++) {\n        sum += ns[i] - nt[i];\n        if (sum > 0 && cs[i] == \'a\') {\n          ok = false;\n          break;\n        }\n        if (sum < 0 && cs[i] == \'c\') {\n          ok = false;\n          break;\n        }\n      }\n    }\n    cout << (ok && cs == ct ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['binary search', 'constructive algorithms', 'data structures', 'greedy', 'implementation', 'strings', 'two pointers']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. awoo's Favorite Problem.json,https://codeforces.com//blog/entry/103835,First check that the counts of all letters are the same in both strings Then consider the following restatement of the moves The letters in the string are stationary Letters and however move around the string The move of the first type moves a letter to the right The move of the second type moves a letter to the left Notice that letters and can never swap with each other Thus if you remove all letters from both strings the remaining strings should be the same Again since letters and can never swap with each other you can deduce where each of these letters should end up after the swaps The first letter a in should be on the position of the first letter in and so on After that we recall that s can only move to the right and s can only move to the left Thus we check that the th occurrence of in is to the left or equal to the th occurrences of in and vice versa for s Finally we can see that this is a sufficient condition Easy to show by construction you can just fix the positions one after another left to right Overall complexity per testcase 
https://codeforces.com//contest/95/problem/E,501,E,95E,95,E. Lucky Country,Petya loves lucky numbers Everybody knows that positive integers are if their decimal representation doesn t contain digits other than and For example numbers are lucky and are not One night Petya was sleeping He was dreaming of being the president of some island country The country is represented by islands connected by two way roads Between some islands there is no road way even through other islands that s why the country is divided into several regions More formally each island belongs to exactly one region there is a path between any two islands located in the same region there is no path between any two islands from different regions A region is lucky if the amount of islands in it is a lucky number As a real president Petya first decided to build a presidential palace Being a lucky numbers fan Petya wants to position his palace in one of the lucky regions However it is possible that initially the country has no such regions In this case Petya can build additional roads between different regions thus joining them Find the minimum number of roads needed to build to create a lucky region ,"['#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=100000+10;\nconst int oo=100000000;\n\nvector<int> e[maxn];\nint que[maxn],qid[maxn];\nbool flag[maxn];\nint cnt[maxn];\nint A[maxn],B[maxn];\nint opt[maxn],tmp[maxn];\nint n,m,t;\n\nint main()\n{\n\tscanf(""%d%d"",&n,&m);\n\tfor (int i=0,a,b;i<m;i++)\n\t{\n\t\tscanf(""%d%d"",&a,&b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (!flag[i])\n\t{\n\t\tint l=1,r=1;\n\t\tque[1]=i;flag[i]=1;\n\t\tfor (;l<=r;l++)\n\t\tfor (int j=0;j<e[que[l]].size();j++)\n\t\tif (!flag[e[que[l]][j]])\n\t\t{\n\t\t\tque[++r]=e[que[l]][j];\n\t\t\tflag[que[r]]=1;\n\t\t}\n\t\tcnt[r]++;\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (cnt[i])\n\t{\n\t\tA[++t]=i;B[t]=cnt[i];\n\t}\n\n\tfor (int i=1;i<=77777;i++) opt[i]=oo;\n\tfor (int i=1;i<=t;i++)\n\t{\n\t\tfor (int j=0;j<=77777;j++) tmp[j]=oo;\n\t\tfor (int j=0;j<A[i];j++)\n\t\t{\n\t\t\tint l=1,r=0;\n\t\t\tfor (int k=j,id=0;k<=77777;k+=A[i],id++)\n\t\t\t{\n\t\t\t\twhile (l<=r && id-qid[l]>B[i]) l++;\n\t\t\t\tif (l<=r) tmp[k]=que[l]+id;\n\t\t\t\twhile (l<=r && opt[k]-id<=que[r]) r--;\n\t\t\t\tque[++r]=opt[k]-id;qid[r]=id;\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<=77777;j++) opt[j]=min(opt[j],tmp[j]);\n\t}\n\n\tint res=n+1;\n\tfor (int i=1;i<=77777;i++)\n\tif (opt[i]<res)\n\t{\n\t\tbool ok=1;\n\t\tfor (int k=i;k;k/=10)\n\t\t\tok&=(k%10==4 || k%10==7);\n\t\tif (ok) res=opt[i];\n\t}\n\tif (res==n+1) printf(""-1\\n"");\n\telse printf(""%d\\n"",res-1);\n}\n']",,,"['dp', 'dsu', 'graphs']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Lucky Country.json,https://codeforces.com//blog/entry/2257,Let A i sorted array of sizes of different connection components C i number of connection components of size A i Sum for all C i A i is equal to N Size of A will be O sqrt N 
https://codeforces.com//contest/1264/problem/C,486703,C,1264C,1264,C. Beautiful Mirrors with queries,Creatnx has n mirrors numbered from 1 to n Every day Creatnx asks exactly one mirror Am I beautiful The i th mirror will tell Creatnx that he is beautiful with probability frac p i 100 for all 1 le i le n Initially only the 1st mirror is a checkpoint It remains a checkpoint all the time Creatnx asks the mirrors one by one starting from the 1 st mirror Every day if he asks i th mirror there are two possibilities The i th mirror tells Creatnx that he is beautiful In this case if i n Creatnx will stop and become happy otherwise he will continue asking the i 1 th mirror next day In the other case Creatnx will feel upset The next day Creatnx will start asking You are given q queries each query is represented by an integer u If the u th mirror isn t a checkpoint then we set it as a checkpoint Otherwise the u th mirror is no longer a checkpoint After each query you need to calculate the expected number of days until Creatnx becomes happy Each of this numbers should be found by modulo 998244353 Formally let M 998244353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353 ;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\n\nint n,q,p,u;\nset<int> hs;\nll f[N],mf[N],imf[N],smf[N],ans;\n\nll query(int l,int r) {\n\treturn (smf[l]-smf[r+1])*imf[r+1]%mod;\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&q);\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",&p);\n\t\tf[i]=100*powmod(p,mod-2)%mod;\n\t}\n\tmf[n+1]=1;\n\timf[n+1]=1;\n\tper(i,1,n+1) {\n\t\tmf[i]=f[i]*mf[i+1]%mod;\n\t\timf[i]=powmod(mf[i],mod-2);\n\t\tsmf[i]=(smf[i+1]+mf[i])%mod;\n\t}\n\ths.insert(1);\n\ths.insert(n+1);\n\tans=query(1,n);\n\trep(i,0,q) {\n\t\tscanf(""%d"",&u);\n\t\tif (hs.count(u)) {\n\t\t\tauto it=hs.find(u);\n\t\t\tauto pit=it,qit=it;\n\t\t\tpit--; qit++;\n\t\t\tans-=query(*pit,*it-1);\n\t\t\tans-=query(*it,*qit-1);\n\t\t\tans+=query(*pit,*qit-1);\n\t\t\ths.erase(u);\n\t\t} else {\n\t\t\ths.insert(u);\n\t\t\tauto it=hs.find(u);\n\t\t\tauto pit=it,qit=it;\n\t\t\tpit--; qit++;\n\t\t\tans+=query(*pit,*it-1);\n\t\t\tans+=query(*it,*qit-1);\n\t\t\tans-=query(*pit,*qit-1);\n\t\t}\n\t\tans%=mod;\n\t\tif (ans<0) ans+=mod;\n\t\tprintf(""%lld\\n"",ans);\n\t}\n}\n']",,,"['data structures', 'probabilities']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Beautiful Mirrors with queries.json,https://codeforces.com/blog/entry/71995,Assuming that currently there are checkpoints the journey becoming happy of Creatnx can be divided to stages where in th stage Creatnx moving from mirror to mirror at position Denote the th stage as These stages are independent so the sum of expected number of days Creatnx spending in each stage will be the answer to this problem When a new checkpoint appear between 2 old checkpoints and stage will be removed from the set of stages and 2 new stages will be added they are and Similarly when a checkpoint between 2 checkpoints and is no longer a checkpoint 2 stages and will be removed from the set of stages and new stage will be added These removed added stages can be fastly retrieved by storing all checkpoints in an ordered data structure such as in C For removed added stages we subtract add its expected number of days from to the current answer We see that when a query occurs the number of stages removed added is small just 3 in total Therefore if we can calculate the expected number of days for an arbitrary stage fast enough we can answer any query in a reasonable time From the solution of problem Beautiful Mirror we know that the expected number of days Creatnx spending in stage is The denominator can be computed by using a prefix product array a common useful trick We prepare an array where After that can be obtained by using 1 division For numerator we also use the same trick An array will be prepare where We have so 
https://codeforces.com//contest/2002/problem/E,2809242,E,2002E,2002,E. Cosmic Rays,Given an array of integers s 1 s 2 ldots s l every second cosmic rays will cause all s i such that i 1 or s i neq s i 1 to be deleted simultaneously and the remaining parts will be concatenated together in order to form the new array s 1 s 2 ldots s l Define the of an array as the number of seconds it takes to become empty You are given an array of integers compressed in the form of n pairs that describe the array left to right Each pair a i b i represents a i copies of b i i e underbrace b i b i cdots b i a i textrm times For each i 1 2 dots n please find the of the sequence described by the first i pairs ,"['#include <bits/stdc++.h>\xa0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\xa0void solve() {    int n;    std::cin >> n;        std::vector<std::pair<int, i64>> stk;    i64 ans = 0;    for (int i = 0; i < n; i++) {        int a, b;        std::cin >> a >> b;                i64 len = 0;        while (!stk.empty() && (a > 0 || stk.back().first == b)) {            if (stk.back().first == b) {                len += stk.back().second;                stk.pop_back();            } else {                i64 t = std::min<i64>(a, stk.back().second);                a -= t;                len += t;                stk.back().second -= t;                if (stk.back().second == 0) {                    stk.pop_back();                }            }        }        ans += a;        len += a;        stk.emplace_back(b, len);        std::cout << ans << "" \\n""[i == n - 1];    }}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']",,,"['brute force', 'data structures', 'dp']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\E. Cosmic Rays.json,https://codeforces.com//blog/entry/132569,The problems asks for the answer for every prefix which hints at an incremental solution To add a new pair to the current prefix we need to somehow process the new block merging with old ones Thus we should use some structure to store the information on the last block over time Namely we use a stack to keep track of all blocks that became the last For each block we keep two values its color and its lifetime the times it takes for the block to disappear When inserting a new block we pop all blocks that would be shadowed by the current one i e with lifetime shorter than the current block and merging blocks with the same When merging two blocks with length and and the maximum lifetime of blocks between them is should hold and the new block will have lifetime For more details please refer to the solution code There also exists solutions using ordered sets or heaps Time complexity 
https://codeforces.com//contest/778/problem/A,95641,A,778A,778,A. String Game,Little Nastya has a hobby she likes to remove some letters from word to obtain another word But it turns out to be pretty hard for her because she is too young Therefore her brother Sergey always helps her Sergey gives Nastya the word and wants to get the word out of it Nastya removes letters in a certain order one after another in this order strictly which is specified by permutation of letters indices of the word We denote the length of word as Note that after removing one letter the indices of other letters don t change For example if and then removals make the following sequence of words Sergey knows this permutation His goal is to stop his sister at some point and continue removing by himself to get the word Since Nastya likes this activity Sergey wants to stop her as late as possible Your task is to determine how many letters Nastya can remove before she will be stopped by Sergey It is guaranteed that the word can be obtained by removing the letters from word ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    string t, p;\n    cin >> t >> p;\n    int L = SZ(t);\n    vector<int> perm(L);\n    for (int i = 0; i < L; i++)\n    {\n        cin >> perm[i];\n        perm[i]--;\n    }\n    int lo = 0;\n    int hi = L;\n    while (hi - lo > 1)\n    {\n        int mid = (lo + hi) / 2;\n        string r = t;\n        for (int i = 0; i < mid; i++)\n            r[perm[i]] = \'_\';\n        int pos = 0;\n        for (char c : p)\n        {\n            while (pos < L && r[pos] != c)\n                pos++;\n            pos++;\n        }\n        if (pos <= L)\n            lo = mid;\n        else\n            hi = mid;\n    }\n    cout << lo << \'\\n\';\n\n    return 0;\n}\n']",,,"['binary search', 'greedy', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\A. String Game.json,https://codeforces.com//blog/entry/50724,In this problem we have to find the last moment of time when has as a subsequence If at some moment of time is a subsequence of then at any moment before is also its subsequence That s why the solution is binary search for the number of moves Nastya makes For binary search for a moment of time we need to check if is a subsequence of We remove and check if is a subsequence greedily 
https://codeforces.com//contest/69/problem/D,373,D,69D,69,D. Dot,Anton and Dasha like to play different games during breaks on checkered paper By the 11th grade they managed to play all the games of this type and asked Vova the programmer to come up with a new game Vova suggested to them to play a game under the code name dot with the following rules On the checkered paper a coordinate system is drawn A dot is initially put in the position A move is shifting a dot to one of the pre selected vectors Also each player can once per game symmetrically reflect a dot relatively to the line Anton and Dasha take turns Anton goes first The player after whose move the distance from the dot to the coordinates origin exceeds loses Help them to determine the winner ,"['#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint x , y , n , d , dx[22] , dy[22] , F[1111][1111] ;\n\ninline int Calc( int x , int y )\n{\n\tif ( x * x + y * y > d * d ) return 1 ;\n\tif ( F[x+500][y+500] != -1 ) return F[x+500][y+500] ;\n\tF[x+500][y+500] = 0 ;\n\tfor ( int i = 0 ; i < n ; i ++ )\n\tif ( Calc( x + dx[i] , y + dy[i] ) == 0 )\n\t\treturn F[x+500][y+500] = 1 ;\n\treturn 0 ;\n}\n\nint main()\n{\n\tcin >> x >> y >> n >> d ;\n\tfor ( int i = 0 ; i < n ; i ++ )\n\t\tcin >> dx[i] >> dy[i] ;\n\tmemset( F , -1 , sizeof( F ) ) ;\n\tbool ret = Calc( x , y ) ;\n\tif ( ret ) {\n\t\tcout << ""Anton"" << endl ;\n\t} else {\n\t\tcout << ""Dasha"" << endl ;\n\t}\n\treturn 0 ;\n}\n']",,,"['dp', 'games']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Dot.json,https://codeforces.com//blog/entry/1571,This game is over because except for a finite number 2 of reflections about the line y x the coordinates are changed to non negative integer and at least one coordinate is changed to a positive number Algorithm for solving this problem is DFS BFS states where the state is a pair of coordinates and two logical variables which denote if the 1 2 player had reflected a point about the line y x Total number of states is obtained by S 4D 2 pairs of coordinates 4 Boolean variables Processing of one state takes O N actions do not forget to try to reflect the point about the line y x if the player had not made it earlier in the game Thereby we have the overall asymptotic O ND 2 which works on C in less than 200ms 
https://codeforces.com//contest/1516/problem/C,963908,C,1516C,1516,C. Baby Ehab Partitions Again,Baby Ehab was toying around with arrays He has an array a of length n He defines an array to be good if there s no way to partition it into 2 subsequences such that the sum of the elements in the first is equal to the sum of the elements in the second Now he wants to remove the minimum number of elements in a so that it becomes a good array Can you help him A sequence b is a subsequence of an array a if b can be obtained from a by deleting some possibly zero or all elements A partitioning of an array is a way to divide it into 2 subsequences such that every element belongs to exactly one subsequence so you must use all the elements and you can t share any elements ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,a[2002],sum,G;\nbitset<200002>B;\nint main(){\n\tn=read(),B[0]=1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=read(),sum+=a[i];\n\t\tB|=(B<<a[i]);\n\t}\n\tif((sum&1)||(!B[sum>>1]))return puts(""0""),0;\n\tG=a[1];\n\tfor(re int i=2;i<=n;++i)G=__gcd(G,a[i]);\n\tfor(re int i=1;i<=n;++i)a[i]/=G;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]&1){\n\t\t\tprintf(""1\\n%d"",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n']",,,"['bitmasks', 'constructive algorithms', 'dp', 'math']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Baby Ehab Partitions Again.json,https://codeforces.com//blog/entry/89846,First of all let s check if the array is already good This can be done with knapsack dp If it is the answer is If it isn t I claim you can always remove one element to make it good and here s how to find it Since the array can be partitioned its sum is even So if we remove an odd element it will be odd and there will be no way to partition it If there s no odd element then all elements are even But then you can divide all the elements by without changing the answer Why Because a partitioning in the new array after dividing everything by is a partitioning in the original array and vice versa We just re scaled everything So while all the elements are even you can keep dividing by until one of the elements becomes odd Remove it and you re done If you want the solution in one sentence remove the element with the smallest possible least significant bit Alternatively for a very similar reasoning you can start by dividing the whole array by its and remove any odd element which must exist because the is but I think this doesn t give as much insight Code link https pastebin com aiknVwkZ 
https://codeforces.com//contest/1881/problem/G,2259908,G,1881G,1881,G. Anya and the Mysterious String,Anya received a string s of length n brought from Rome The string s consists of lowercase Latin letters and at first glance does not raise any suspicions An instruction was attached to the string A palindrome is a string that reads the same from left to right and right to left For example the strings are palindromes while the strings are not A substring l ldots r of string s is a string s l s l 1 ldots s r 1 s r For example the substring 4 ldots 6 of the string is the string A string is called if it contain a substring of length two that is a palindrome For example the strings and are while the strings are not When an integer x is added to the character s i it is replaced x times with the character in the alphabet with being replaced by When an integer x is added to the substring l r of string s it becomes the string s 1 s 2 ldots s l 1 s l x s l 1 x ldots s r 1 x s r x s r 1 ldots s n For example when the substring 2 4 of the string is added with the number 6 the resulting string is After reading the instruction Anya resigned herself to the fact that she has to answer m queries The queries can be of two types Add the number x to the substring l ldots r of string s Determine whether the substring l ldots r of string s is ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,seg[N],lz[N];\nstring s;\nvoid prep(){\n\n}\nvoid dwn (ll id){\n    ll t=lz[id];\n    (lz[id*2]+=lz[id])%=26;\n    (lz[id*2+1]+=lz[id])%=26;\n    (seg[id*2]+=lz[id])%=26;\n    (seg[id*2+1]+=lz[id])%=26;\n    lz[id]=0;\n}\nvoid upds (ll id, ll l, ll r, ll u, ll v, ll val){\n    if (l>v || r<u || l>r || u>v) return;\n    if (u<=l && r<=v){\n        (seg[id]+=val)%=26;\n        (lz[id]+=val)%=26;\n        return;\n    }\n    dwn(id);\n    ll mid=(l+r)/2;\n    upds(id*2,l,mid,u,v,val);\n    upds(id*2+1,mid+1,r,u,v,val);\n    seg[id]=(seg[id*2]+seg[id*2+1])%26;\n}\nll gets (ll id, ll l, ll r, ll u, ll v){\n    if (l>v || r<u || l>r || u>v) return 0;\n    if (u<=l && r<=v) return seg[id];\n    dwn(id);\n    ll mid=(l+r)/2;\n    ll x=gets(id*2,l,mid,u,v);\n    ll y=gets(id*2+1,mid+1,r,u,v);\n    return (x+y)%26;\n}\nstruct bit{\n    ll bit[N];\n    ll m;\n    void upd (ll pos, ll val){\n        for (ll i=pos;i<=m;i+=(i&-i))\n        bit[i]+=val;\n    }\n    ll getp (ll pos){\n        ll r=0;\n        for (ll i=pos;i>=1;i-=(i&-i))\n        r+=bit[i];\n        return r;\n    }\n    ll get (ll l, ll r){\n        if (l>r) return 0;        \n        return getp(r)-getp(l-1);\n    }\n};\nbit x1,x2;\nvoid solve()\n{\n    cin>>n>>q>>s;\n    x1.m=n;\n    x2.m=n;\n    rep(i,1,n) x1.bit[i]=x2.bit[i]=0;\n    rep(id,1,4*n) seg[id]=lz[id]=0;\n    s="".""+s;\n    rep(i,1,n) upds(1,1,n,i,i,s[i]-\'a\');\n    rep(i,1,n-1) if (s[i]==s[i+1]) x1.upd(i,1);\n    rep(i,1,n-2) if (s[i]==s[i+2]) x2.upd(i,1);\n    while (q--){\n        ll ty;\n        cin>>ty;\n        if (ty==1){\n            ll l,r,x;\n            cin>>l>>r>>x;\n            ll p=l-1;\n            if (p>=1){\n                if (p+1<=n && gets(1,1,n,p,p)==gets(1,1,n,p+1,p+1)) x1.upd(p,-1);\n                if (p+2<=n && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,-1);\n            }\n            p=l-2;\n            if (p>=1 && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,-1);\n            p=r+1;\n            if (p<=n){\n                //cout<<p<<"" "";\n                if (p-1>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-1,p-1)) x1.upd(p-1,-1);\n                if (p-2>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,-1);\n            }\n            p=r+2;\n            if (p<=n && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,-1);\n            upds(1,1,n,l,r,x);\n            p=l-1;\n            if (p>=1){\n                if (p+1<=n && gets(1,1,n,p,p)==gets(1,1,n,p+1,p+1)) x1.upd(p,1);\n                if (p+2<=n && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,1);\n            }\n            p=r+1;\n            if (p<=n){\n                if (p-1>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-1,p-1)) x1.upd(p-1,1);\n                if (p-2>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,1);\n            }\n            p=l-2;\n            if (p>=1 && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,1);\n            p=r+2;\n            if (p<=n && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,1);\n        }\n        else{\n            ll l,r;\n            cin>>l>>r;\n            ll p=x1.get(l,r-1);\n            p=max(p,x2.get(l,r-2));\n            if (!p) cout<<""YES"";\n            else cout<<""NO"";\n            cout<<""\\n"";\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}']",,,"['binary search', 'data structures']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Anya and the Mysterious String.json,https://codeforces.com//blog/entry/121327,Let s make two obvious observations about palindromes of length at least Palindromes of length contain a palindrome substring Palindromes of length contain a palindrome substring Now we need to learn how to track only palindromes of length and Let s call an index bad if a palindrome of length starts from it and terrible if a palindrome of length starts from it We will store the bad and terrible indices in a pair of Let s assume that there are no modification queries and we need to check the substring for beauty If there exists a bad index or a terrible index then the substring is not beautiful otherwise it is beautiful This can be checked using binary search on the set Now let s learn how to make modifications Notice that palindromes do not appear or disappear inside a segment but they can appear or disappear at its boundaries Let s use a data structure that can add values on a segment and retrieve a value at a point If such a structure exists we will add to the segment and then process the nearest indices to and the nearest indices to We can describe more precisely which bad and terrible indices should be processed but it does not affect the solution because the number of such indices is still When processing the indices we use point queries and insertion deletion operations in Now we need to implement such a data structure The author suggests using a Fenwick tree on a difference array A segment tree with lazy propagation will also work This gives a solution with time complexity 
https://codeforces.com//contest/246/problem/B,2236,B,246B,246,B. Increase and Decrease,Polycarpus has an array consisting of integers Polycarpus likes it when numbers in an array match That s why he wants the array to have as many equal numbers as possible For that Polycarpus performs the following operation multiple times he chooses two elements of the array he simultaneously increases number by and decreases number by that is executes and The given operation changes exactly two distinct array elements Polycarpus can apply the described operation an infinite number of times Now he wants to know what maximum number of equal array elements he can get if he performs an arbitrary number of such operation Help Polycarpus ,"['#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n\nint a[1000*1000], n;\nint main()\n{\n    scanf(""%d"", &n);\n    int s=0;\n    for (int i=0; i<n; i++) scanf(""%d"", &a[i]), s+=a[i];\n    printf(""%d\\n"", n-(s%n ? 1 : 0));\n    return 0;\n}\n']",,,"['greedy', 'math']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Increase and Decrease.json,https://codeforces.com//blog/entry/5934,Note that you can always get the answer To get this result you should make first equal using the last element as the second element in pair of given operation But after it the whole array could become equal It could happen if the sum of array s elements is divisible by So the answer is or 
https://codeforces.com//contest/1550/problem/C,1045983,C,1550C,1550,C. Manhattan Subarrays,Suppose you have two points p x p y p and q x q y q Let s denote the Manhattan distance between them as d p q x p x q y p y q Let s say that three points p q r form a triple if d p r d p q d q r Let s say that an array b 1 b 2 dots b m is if it is impossible to choose three indices i j k such that the points b i i b j j and b k k form a bad triple You are given an array a 1 a 2 dots a n Calculate the number of subarrays of a A subarray of the array a is the array a l a l 1 dots a r for some 1 le l le r le n Note that according to the definition subarrays of length 1 and 2 are ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        std::vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n        \n        auto isGood = [&](int l, int r) {\n            for (int i = l; i <= r; i++) {\n                for (int j = i + 1; j <= r; j++) {\n                    for (int k = j + 1; k <= r; k++) {\n                        if (a[i] >= a[j] && a[j] >= a[k]) {\n                            return false;\n                        }\n                        if (a[i] <= a[j] && a[j] <= a[k]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            \n            return true;\n        };\n        \n        int ans = 0;\n        for (int i = 0, j = 0; i < n; i++) {\n            while (!isGood(j, i)) {\n                j++;\n            }\n            \n            ans += i - j + 1;\n        }\n        \n        std::cout << ans << ""\\n"";\n    }\n    \n    return 0;\n}']",,,"['brute force', 'geometry', 'greedy', 'implementation']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Manhattan Subarrays.json,https://codeforces.com//blog/entry/92864,Let s figure out criteria for the bad triple It s not hard to prove that the triple is bad iff point lies inside the bounding box of points and In other words if and Now looking at points and we can see that the bad situation may arise only if so we can check only ordered triples Looking closely at inequality we can note that there are two situations where forms a bad triple when either or In other words subarray is bad if and only if it contains either non decreasing subsequence of length or non increasing subsequence of length The final observation is that any sequence of length at least contains either non decreasing or non increasing subsequence of length It s not hard to prove it either brute forcing all possible variants of relative orders on paper or searching remembering the theorem that says it As a result you need to check only subarrays of length at most whichever the way you want The complexity is 
https://codeforces.com//contest/1842/problem/C,1978967,C,1842C,1842,C. Tenzing and Balls,Tenzing has n balls arranged in a line The color of the i th ball from the left is a i Tenzing can do the following operation any number of times select i and j such that 1 leq i j leq a and a i a j remove a i a i 1 ldots a j from the array and decrease the indices of all elements to the right of a j by j i 1 Tenzing wants to know the maximum number of balls he can remove ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:08:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    const int inf = (int) 1e9;\n    vector<int> dp(n + 1, -inf);\n    dp[0] = 0;\n    for (int i = 0; i < n; i++) {\n      int v = dp[a[i]];\n      dp[a[i]] = max(dp[a[i]], dp[0] - i);\n      dp[0] = max(dp[0], v + i + 1);\n    }\n    cout << dp[0] << \'\\n\';\n  }\n  return 0;\n}\n']",,,['dp'],1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Tenzing and Balls.json,https://codeforces.com//blog/entry/117606,TutorialLet us write down the original index of each range we delete Firstly it is impossible to delete ranges and where Secondly if we delete ranges and where we must have deleted range before deleting range Yet the effect of deleting range and then is the same as only deleting Therefore we can assume that in an optimal solution the ranges we delete are all disjoint Therefore we want to find some disjoint range such that and is maximized We can write a DP denotes the minimum number of points we do not delete when considering the subarray We have This dp can be calculated in since we can store for each what the minimum which satisfy 
https://codeforces.com//contest/1654/problem/A,1336998,A,1654A,1654,A. Maximum Cake Tastiness,There are n pieces of cake on a line The i th piece of cake has weight a i 1 leq i leq n The tastiness of the cake is the maximum total weight of two adjacent pieces of cake i e max a 1 a 2 a 2 a 3 ldots a n 1 a n You want to maximize the tastiness of the cake You are allowed to do the following operation at most once doing more operations would ruin the cake Choose a contiguous subsegment a l r of pieces of cake 1 leq l leq r leq n and reverse it The subsegment a l r of the array a is the sequence a l a l 1 dots a r If you reverse it the array will become a 1 a 2 dots a l 2 a l 1 underline a r underline a r 1 underline dots underline a l 1 underline a l a r 1 a r 2 dots a n 1 a n For example if the weights are initially 5 2 1 4 7 3 you can reverse the subsegment a 2 5 getting 5 underline 7 underline 4 underline 1 underline 2 3 The tastiness of the cake is now 5 7 12 while before the operation the tastiness was 4 7 11 Find the maximum tastiness of the cake after doing the operation at most once ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tsort(all(a));\n\tcout << a[n - 1] + a[n - 2] << ""\\n"";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']",,,"['brute force', 'greedy', 'implementation', 'sortings']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\A. Maximum Cake Tastiness.json,https://codeforces.com//blog/entry/100127,SolutionThe answer is the sum of the maximum weights You can always pick the maximum weights if they are and you can flip the subsegment to make them adjacent The result can t be larger because the sum of the weights of any pieces of cake is never greater than the sum of the maximum weights Iterating over all pairs of pieces of cake is enough to get AC but you can solve the problem in by sorting the weights and printing the sum of the last values or even in if you calculate the maximum and the second maximum in linear time Complexity or 
https://codeforces.com//contest/1283/problem/C,504969,C,1283C,1283,C. Friends and Gifts,There are n friends who want to give gifts for the New Year to each other Each friend should give one gift and receive one gift The friend give the gift to himself For each friend the value f i is known it is either f i 0 if the i th friend doesn t know whom he wants to give the gift to or 1 le f i le n if the i th friend wants to give the gift to the friend f i You want to fill in the unknown values f i 0 in such a way that each friend gives one gift and receives one gift and there is friend who gives the gift to himself It is guaranteed that the initial information isn t contradictory If there are several answers you can print any ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\nint inDegree[MAXN];\nint outDegree[MAXN];\n\nvector< int > remain;\n\nvoid add(int U, int V)\n{\n\toutDegree[U]++;\n\tinDegree[V]++;\n}\n\nint main()\n{\n\tscanf(""%d"",&n);\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tscanf(""%d"",&v[i]);\n\n\t\tif( v[i] != 0 ) add( i , v[i] );\n\t}\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tif( inDegree[i] == 0 && outDegree[i] == 0 ) remain.push_back( i );\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tif( inDegree[i] != 0 || outDegree[i] == 0 ) continue;\n\n\t\tint cur = i;\n\n\t\twhile( v[cur] != 0 ) cur = v[cur];\n\n\t\tif( remain.size()%2 == 1 )\n\t\t{\n\t\t\tint V = remain.back();\n\t\t\tremain.pop_back();\n\n\t\t\tv[cur] = V;\n\t\t\tv[ V ] = i;\n\n\t\t\tadd( cur , V );\n\t\t\tadd( V , i );\n\t\t}\n\t\telse v[ cur ] = i, add( cur , i );\n\t}\n\n\tif( remain.size()%2 == 1 )\n\t{\n\t\tint sz = remain.size();\n\n\t\tint A = remain[sz - 1];\n\t\tint B = remain[sz - 2];\n\t\tint C = remain[sz - 3];\n\n\t\tv[A] = B;\n\t\tv[B] = C;\n\t\tv[C] = A;\n\n\t\tadd( A , B );\n\t\tadd( B , C );\n\t\tadd( C , A );\n\n\t\tremain.pop_back();\n\t\tremain.pop_back();\n\t\tremain.pop_back();\n\t}\n\n\twhile( remain.size() > 0 )\n\t{\n\t\tint sz = remain.size();\n\n\t\tint A = remain[sz - 1];\n\t\tint B = remain[sz - 2];\n\n\t\tv[A] = B;\n\t\tv[B] = A;\n\n\t\tadd( A , B );\n\t\tadd( B , A );\n\n\t\tremain.pop_back();\n\t\tremain.pop_back();\n\t}\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tprintf(""%d "",v[i]);\n}']",,,"['constructive algorithms', 'data structures', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Friends and Gifts.json,https://codeforces.com//blog/entry/72592,In this problem we need to print the permutation without fixed points without values but some values are known in advance Let s consider the permutation as a graph We know that the permutation is the set of non intersecting cycles In this problem we are given such a graph but some edges are removed How to deal with it Firstly let s find isolated vertices in the graph Let its number be If then all is ok and we skip the current step If then let s pin this isolated vertex to any vertex to which we can pin it Otherwise and we can create the chine consisting of all isolated vertices Now and we can finally construct the remaining part of the graph We can notice that we have the same number of vertices with zero incoming and zero outcoming degrees And because we got rid of all possible loops in the graph we can match these vertices as we want Time complexity 
https://codeforces.com//contest/1992/problem/E,2748267,E,1992E,1992,E. Novice s Mistake,One of the first programming problems by K1o0n looked like this Noobish Monk has n 1 le n le 100 friends Each of them gave him a 1 le a le 10000 apples for his birthday Delighted with such a gift Noobish Monk returned b 1 le b le min 10000 a cdot n apples to his friends How many apples are left with Noobish Monk K1o0n wrote a solution but accidentally considered the value of n as a string so the value of n cdot a b was calculated differently Specifically when multiplying the string n by the integer a he will get the string s underbrace n n dots n n a text times when subtracting the integer b from the string s the last b characters will be removed from it If b is greater than or equal to the length of the string s it will become empty Learning about this ErnKor became interested in how many pairs a b exist for a given n satisfying the constraints of the problem on which K1o0n s solution gives the correct answer The solution gives the correct answer means that it outputs a string and this string when converted to an integer equals the correct answer i e the value of n cdot a b ,"['#include <bits/stdc++.h>\xa0using namespace std;\xa0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\xa0const int MXN = 2e5 + 5;\xa0mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void _(){\tint n;\tcin >> n;\tstring x = to_string(n);\tvector<array<int, 2>> v;\tfor (int a = 1; a <= 10000; a++)\t{\t\tint len = (int)x.length() * a;\t\tfor (int b = min(10000LL, len - 1); b >= 1 && len - b <= 10; b--)\t\t{\t\t\tint nwlen = len - b;\t\t\tstring nw = """";\t\t\twhile (nw.length() + x.length() <= nwlen) nw += x;\t\t\tint left = nwlen - (int)nw.length();\t\t\tif (left) nw += x.substr(0, left);\t\t\t// cout << nw << \'\\n\';\t\t\tint y = stoll(nw);\t\t\tif (y == n * a - b)\t\t\t{\t\t\t\tv.push_back({a, b});\t\t\t}\t\t}\t}\tcout << v.size() << \'\\n\';\tfor (array<int, 2> &x : v) cout << x[0] << \' \' << x[1] << \'\\n\';}\xa0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\twhile (t--)\t{\t\t_();\t}}']",,,"['brute force', 'constructive algorithms', 'implementation', 'math', 'strings']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Novice s Mistake.json,https://codeforces.com//blog/entry/131461,TutorialNotice that is strictly less than i e it has no more than digits The number of characters in the strange calculation is equal to where is the number of digits in n Let s iterate over the value of and then determine the boundaries and for it such that and Then Let s iterate over all from to To quickly check the strange calculation let s only find its first digits This way we can find all suitable pairs Solution complexity 
https://codeforces.com//contest/1980/problem/E,2679077,E,1980E,1980,E. Permutation of Rows and Columns,You have been given a matrix a of size n by m containing a permutation of integers from 1 to n cdot m A permutation of n integers is an array containing all numbers from 1 to n exactly once For example the arrays 1 2 1 3 5 4 3 2 1 are permutations while the arrays 1 1 100 1 2 4 5 are not A matrix contains a permutation if when all its elements are written out the resulting array is a permutation Matrices 1 2 3 4 1 1 5 3 2 6 4 contain permutations while matrices 2 1 1 2 2 1 2 100 200 do not You can perform one of the following two actions in one operation choose columns c and d 1 le c d le m c ne d and swap these columns choose rows c and d 1 le c d le n c ne d and swap these rows You can perform any number of operations You are given the original matrix a and the matrix b Your task is to determine whether it is possible to transform matrix a into matrix b using the given operations ,"['#include <bits/stdc++.h>using namespace std;\xa0int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n, m; cin >> n >> m;        vector a(n, vector<int>(m)), b(n, vector<int>(m));        for (auto &v: a) for (int &x: v) cin >> x;        for (auto &v: b) for (int &x: v) cin >> x;        map<int, int> ai, aj;        map<int, vector<int>> imp, jmp;        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = a[i][j];                ai[x] = i, aj[x] = j;            }        }        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = b[i][j];                imp[ai[x]].push_back(i), jmp[aj[x]].push_back(j);            }        }        bool ans = true;        for (auto [_, v]: imp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        for (auto [_, v]: jmp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        cout << (ans ? ""YES"" : ""NO"") << ""\\n"";    }}']",,,"['constructive algorithms', 'data structures', 'greedy', 'hashing', 'implementation', 'math', 'matrices', 'sortings']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Permutation of Rows and Columns.json,https://codeforces.com//blog/entry/130135,For each element you can calculate its positions in both matrices You can see that the rearrangement of rows does not affect the column positions of the elements being rearranged Similarly column rearrangement does not affect row positions Since the permutation of rows affects the entire rows for all elements that have the same position row in the original matrix the position row in the resulting matrix must also match Similarly the columns must match In order to check the coincidence of rows and columns let s count 4 arrays the positions of rows and columns in the original and received matrices Then you need to check that for all with the same row value in the original matrix the row values in the resulting matrix are the same Similarly the values of the columns should be the same 
https://codeforces.com//contest/1271/problem/A,495881,A,1271A,1271,A. Suits,A new delivery of clothing has arrived today to the clothing store This delivery consists of a ties b scarves c vests and d jackets The store does not sell single clothing items instead it sells suits of two types a suit of the first type consists of one tie and one jacket a suit of the second type consists of one scarf one vest and one jacket Each suit of the first type costs e coins and each suit of the second type costs f coins Calculate the maximum possible cost of a set of suits that can be composed from the delivered clothing items Note that one item cannot be used in more than one suit though some items may be left unused ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint t, s, v, j, e, f, ans;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> t >> s >> v >> j >> e >> f;\n\tif (e > f) {\n\t\twhile (t && j)\n\t\t\tt--, j--, ans += e;\n\t\twhile (s && v && j)\n\t\t\ts--, v--, j--, ans += f;\n\t}\n\telse {\n\t\twhile (s && v && j)\n\t\t\ts--, v--, j--, ans += f;\n\t\twhile (t && j)\n\t\t\tt--, j--, ans += e;\n\t}\n\tcout << ans;\n}\n']",,,"['brute force', 'greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Suits.json,https://codeforces.com/blog/entry/72247,There are two ways to approach this problem The first way is to iterate on the number of suits of one type that we will compose and calculate the number of suits of the second type we can compose from the remaining items The second way is to use the fact that if then we have to make as many suits of the first type as possible and the opposite is true if So we firstly make the maximum possible number of more expensive suits and use the remaining items to compose cheaper suits 
https://codeforces.com//contest/983/problem/D,183242,D,983D,983,D. Arkady and Rectangles,Arkady has got an infinite plane painted in color 0 Then he draws n rectangles filled with paint with sides parallel to the Cartesian coordinate axes one after another The color of the i th rectangle is i rectangles are enumerated from 1 to n in the order he draws them It is possible that new rectangles cover some of the previous ones completely or partially Count the number of different colors on the plane after Arkady draws all the rectangles ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nconst int M=525000;\nint a[N],b[N],c[N],d[N];\nint n,ans,qx[N*2],qy[N*2];\nint vis[N*2],mx[M],mn[M];\nvector<pair<int,int> > v[N*2];\nset<int> s[M];\nvoid pushup(int k,int l,int r){\n\tif (l!=r){\n\t\tmx[k]=max(mx[k*2],mx[k*2+1]);\n\t\tmn[k]=min(mn[k*2],mn[k*2+1]);\n\t}\n\telse\n\t\tmx[k]=mn[k]=0;\n\tif (s[k].size()){\n\t\tif (vis[*s[k].rbegin()])\n\t\t\tmn[k]=max(mn[k],*s[k].rbegin());\n\t\telse mx[k]=max(mx[k],*s[k].rbegin());\n\t}\n\tif (mx[k]<mn[k])\n\t\tmx[k]=0;\n}\nvoid insert(int k,int l,int r,int x,int y,int v){\n\t//printf(""%d %d %d %d\\n"",l,r,x,y);\n\tif (l==x&&r==y){\n\t\tif (v){\n\t\t\tif (v>0) s[k].insert(v);\n\t\t\telse s[k].erase(-v); \n\t\t}\n\t\tpushup(k,l,r);\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tif (y<=mid) insert(k*2,l,mid,x,y,v);\n\telse if (x>mid) insert(k*2+1,mid+1,r,x,y,v);\n\telse insert(k*2,l,mid,x,mid,v),\n\t\t insert(k*2+1,mid+1,r,mid+1,y,v);\n\tpushup(k,l,r);\n}\nint main(){\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(""%d%d%d%d"",&a[i],&b[i],&c[i],&d[i]);\n\t\tqx[++*qx]=a[i]; qx[++*qx]=c[i];\n\t\tqy[++*qy]=b[i]; qy[++*qy]=d[i];\n\t}\n\tsort(qx+1,qx+*qx+1);\n\tsort(qy+1,qy+*qy+1);\n\t*qx=unique(qx+1,qx+*qx+1)-qx-1;\n\t*qy=unique(qy+1,qy+*qy+1)-qy-1;\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=lower_bound(qx+1,qx+*qx+1,a[i])-qx;\n\t\tc[i]=lower_bound(qx+1,qx+*qx+1,c[i])-qx;\n\t\tb[i]=lower_bound(qy+1,qy+*qy+1,b[i])-qy;\n\t\td[i]=lower_bound(qy+1,qy+*qy+1,d[i])-qy-1;\n\t\tv[a[i]].push_back(make_pair(i,i));\n\t\tv[c[i]].push_back(make_pair(i,-i));\n\t}\n\tfor (int i=1;i<=*qx;i++){\n\t\tfor (int j=0;j<v[i].size();j++)\n\t\t\tinsert(1,1,*qy,b[v[i][j].first],d[v[i][j].first],v[i][j].second);\n\t\tfor (;mx[1];){\n\t\t\tvis[mx[1]]=1; ans++;\n\t\t\tinsert(1,1,*qy,b[mx[1]],d[mx[1]],0);\n\t\t}\n\t}\n\tprintf(""%d"",ans+1);\n}']",,,['data structures'],3300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Arkady and Rectangles.json,https://codeforces.com//blog/entry/59484,First let s compress the coordinates Now all the coordinates are in Now we do scanline on coordinate with segment tree on coordinate Let s talk about segment tree structute In each vertex we store Set of colors which cover the whole segment If color covers a segment we don t push it to it childs Maximal visible color in subtree which isn t in the answer Minimal visible color in subtree For the vertex and can be calculated as If isn t empty and max value in is more than max in children If it s already in the answer or it s less than min in children Otherwise Otherwise If isn t empty Otherwise Now in scanline we Add all the segments starting at this point Remove all the segments ending at this point While isn t we put it into and recalculate everything by readding this segment to tree At the end we know all visible colors and print the number of them Asymptotics is Solution 
https://codeforces.com//contest/1487/problem/F,897752,F,1487F,1487,F. Ones,You are given a positive greater than zero integer n You have to represent n as the sum of integers possibly negative consisting only of ones digits For example 24 11 11 1 1 and 102 111 11 1 1 Among all possible representations you have to find the one that uses the minimum number of ones in total ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    string S; cin >> S;\n    S = ""0"" + S;\n    int N = sz(S);\n    int dp[N][101][2001];\n    F0R(i, N) {\n        F0R(j, 101) F0R(k, 2001) dp[i][j][k] = 1000000;\n    }\n    dp[0][50][1000] = 0;\n    F0R(i, N-1) {\n        F0R(j, 100) {\n            F0R(k, 2000) {\n                ckmin(dp[i][j+1][k+1], dp[i][j][k] + N-i);\n            }\n        }\n        FORd(j, 1, 101) {\n            FORd(k, 1, 2001) {\n                ckmin(dp[i][j-1][k-1], dp[i][j][k]+N-i);\n            }\n        }\n        F0R(j, 101) {\n            F0R(k, 2001) {\n                int nxt = 50 + (j-50)*10 - (S[i+1]-\'0\') + (k-1000);\n                if (nxt < 101 && nxt >= 0) {\n                    ckmin(dp[i+1][nxt][k], dp[i][j][k]);\n                    /*if (i+1 == N-1 && nxt == 56 && k == 1003) {\n                        cout << ""TEST "" << j << "" "" << k << endl;\n                    }*/\n                }\n            }\n        }\n    }\n    int ans = 1000000;\n    F0R(i, 101) F0R(j, 2001) {\n        ckmin(ans, dp[N-1][i][j] + abs(i-50));\n        /*if (dp[N-1][i][j] + abs(i-50) == 20) {\n            cout << i-50 << "" "" << j-1000 << nl;\n        }*/\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']",,,"['dp', 'greedy', 'shortest paths']",2900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Ones.json,https://codeforces.com//blog/entry/87873,Let s build the number from the lowest digit to the highest digit with the following dynamic programming the minimum number of ones if least significant digits are already fixed the carry to the next digit is can be negative there are positive numbers of the form of length greater than or equal to and negative numbers of length greater than or equal to First consider the transitions when we reduce the values of and or Such transitions correspond to the fact that in the optimal answer there were several numbers of length exactly and they should not be considered further If the value of matches the th least significant digit in then we can use transition to th state with the new value of and the number of ones in the answer increased by It remains to estimate what the maximum value of and we need The value of doesn t exceed the total number of numbers that we use in the answer Using at most numbers we can decrease the length of by at least Thus the maximum value of and is at most where n is the length of the number For the value of the condition should be met similarly for a negative value Thus we can assume that the absolute value of doesn t exceed The total complexity of this solution is yet with a high constant factor 
https://codeforces.com//contest/332/problem/B,3360,B,332B,332,B. Maximum Absurdity,Reforms continue entering Berland For example during yesterday sitting the Berland Parliament approved as much as laws each law has been assigned a unique number from 1 to Today all these laws were put on the table of the President of Berland G W Boosch to be signed This time mr Boosch plans to sign laws He decided to choose non intersecting segments of integers from 1 to of length and sign all laws whose numbers fall into these segments More formally mr Boosch is going to choose two integers and sign all laws with numbers lying in the segments and borders are included As mr Boosch chooses the laws to sign he of course considers the public opinion Allberland Public Opinion Study Centre APOSC conducted opinion polls among the citizens processed the results into a report and gave it to the president The report contains the absurdity value for each law in the public opinion As mr Boosch is a real patriot he is keen on signing the laws with the maximum total absurdity Help him ,"['#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <vector>\n#include <stdio.h>\n#include <stack>\n#include <math.h>\nusing namespace std;\n#define ll long long\nconst int N=2e5+9;\nll a[N],n,k,sl[N],sr[N],dp1[N],dp2[N];\nll a1[N],a2[N];\nint main()\n{\n//    freopen(""in.txt"",""r"",stdin);\n    cin>>n>>k;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) sl[i]=sl[i-1]+a[i];\n    for(int i=k;i<=n;i++)\n    if(dp1[i-1]>=sl[i]-sl[i-k])\n    {\n        a1[i]=a1[i-1];\n        dp1[i]=dp1[i-1];\n    }else\n    {\n//        printf(""***%lld***%d\\n"",i-k+1,i);\n        a1[i]=i-k+1;\n        dp1[i]=sl[i]-sl[i-k];\n    }\n    for(int i=n;i>=1;i--) sr[i]=sr[i+1]+a[i];\n\n    for(int i=n-k+1;i>=1;i--)\n    if(dp2[i+1]>sr[i]-sr[i+k])\n    {\n        a2[i]=a2[i+1];\n        dp2[i]=dp2[i+1];\n    }else\n    {\n        a2[i]=i;\n        dp2[i]=sr[i]-sr[i+k];\n    }\n//    for(int i=1;i<=n;i++)\n//    {\n////        printf(""%d: %I64d %I64d %I64d %I64d\\n"",i,dp1[i],a1[i],dp2[i],a2[i]);\n//    }\n    ll ans=0,x,y;\n    for(int i=k;i+1<=n-k+1;i++)\n    if(dp1[i]+dp2[i+1]>ans)\n    {\n        ans=dp1[i]+dp2[i+1];\n        x=a1[i];\n        y=a2[i+1];\n    }\n//    cout<<ans<<endl;\n    cout<<x<<"" ""<<y<<endl;\n    return 0;\n}\n']",,,"['data structures', 'dp', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Maximum Absurdity.json,https://codeforces.com/blog/entry/8447,Let s build the array of partial sums which will permit to find the sum in any segment of the array in Let s iterate through the number the left edge of the leftmost segment in descending order Now we need to find among segments of length starting from position which index is greater than or equal to a segment with the maximum sum Since we search in descending order we can maintain this segment during the transition from to Asymptotics of the solution Code 
https://codeforces.com//contest/1740/problem/D,1611413,D,1740D,1740,D. Knowledge Cards,Pak Chanek a renowned scholar invented a card puzzle using his knowledge In the puzzle you are given a board with n rows and m columns Let r c represent the cell in the r th row and the c th column Initially there are k cards stacked in cell 1 1 Each card has an integer from 1 to k written on it More specifically the i th card of the stack in cell 1 1 has the number a i written on it It is known that no two cards have the same number written on them In other words the numbers written on the cards are a permutation of integers from 1 to k All other cells are empty You need to move the k cards to cell n m to create another stack of cards Let b i be the number written on the i th card of the stack in cell n m You should create the stack in cell n m in such a way so that b i i for all 1 leq i leq k In one move you can remove the from a cell and place it onto an adjacent cell a cell that shares a common side If the target cell already contains one or more cards you place your card You must do each operation while satisfying the following restrictions Each cell other than 1 1 and n m must not have more than one card on it You cannot move a card onto cell 1 1 You cannot move a card from cell n m Given the values of n m k and the array a determine if the puzzle is solvable ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m, k;\n    std::cin >> n >> m >> k;\n    \n    std::vector<int> a(k);\n    for (int i = 0; i < k; i++) {\n        std::cin >> a[i];\n        a[i] = k - a[i];\n    }\n    \n    std::vector<bool> f(k);\n    int siz = 0;\n    for (int i = 0, j = 0; i < k; i++) {\n        while (!f[i]) {\n            f[a[j++]] = true;\n            siz++;\n        }\n        if (siz > n * m - 3) {\n            std::cout << ""TIDAK\\n"";\n            return;\n        }\n        f[i] = false;\n        siz--;\n    }\n    std::cout << ""YA\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'data structures']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\D. Knowledge Cards.json,https://codeforces.com//blog/entry/108567,Let card be the card with number written on it Notice that we must put the cards into the stack in in order from card card card and so on until card The key observation for this problem is that under given constraints if we ignore cells and we can always move any card to either or if and only if there is at least one empty cell We can obtain this by considering the fact that an empty cell can move to any cell and can be used to rotate any square of cells Because if we ignore cells and each cell is a part of a square Moving a desired card to a one of or can be done by firstly moving the empty cell to be adjacent to the desired card and then only doing rotations that simultaneously move the empty cell and the desired card Therefore we can iterate the card in the stack from top to bottom While iterating one should maintain all of the cards in the board that are not in cell or We define those group of cards as active cards Each time we put a move a card out of we add the card to the active cards Before finishing the iteration we will try to move one or more cards from the active cards to as long as there is a card we can move We can maintain the active cards with a priority queue or a set The active cards can be moved around freely if and only if there is at least one empty cell in the grid if we ignore and Therefore to check whether or not we can solve the puzzle we just need to check whether or not there exists a moment where the number of active cards exceed There also exists a solution with a time complexity of just by iterating the positions of each card number but it will not be explained here Time complexity for each test case or 
https://codeforces.com//contest/285/problem/A,2755,A,285A,285,A. Slightly Decreasing Permutations,The decreasing coefficient of permutation is the number of such that You have numbers and Your task is to print the permutation of length with decreasing coefficient ,"['#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint n,d;\nint main()\n{\n\tint i,j,k;\n\tcin>>n>>d;k=n;\n\tfor (i=n;i>=n-d+1;i--)\n\t{\n\t\tprintf(""%d "",i);\n\t\tk--;\n\t}\n\tfor (i=1;i<=k;i++)printf(""%d "",i);\n\tputs("""");\n\treturn 0;\n}']",,,"['greedy', 'implementation']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Slightly Decreasing Permutations.json,https://codeforces.com//blog/entry/7093,As the answer you can print such permutation For example if then the answer is If you should print Such solution can be written in two loops 
https://codeforces.com//contest/417/problem/B,8546,B,417B,417,B. Crash,During the Russian Code Cup programming competition the testing system stores all sent solutions for each participant We know that many participants use random numbers in their programs and are often sent several solutions with the same source code to check Each participant is identified by some unique positive integer and each sent solution is characterized by two numbers the number of different solutions that are sent before the first solution identical to and the number of the participant who is the author of the solution Consequently all identical solutions have the same It is known that the data in the testing system are stored in the chronological order that is if the testing system has a solution with number of the participant with number then the testing system has a solution with number of the same participant stored somewhere before During the competition the checking system crashed but then the data of the submissions of all participants have been restored Now the jury wants to verify that the recovered data is in chronological order Help the jury to do so ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <set>\n\nusing namespace std;\nint m[110000];\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x, k;\n        cin >> x >> k;\n        x++;\n        if (x <= m[k])\n            continue;\n        if (x != m[k] + 1) {\n            cout << ""NO"" << endl;\n            return 0;\n        }\n        m[k] = x;\n    }\n    cout << ""YES"" << endl;\n\n    return 0;\n}']",,,['implementation'],1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Crash.json,https://codeforces.com//blog/entry/11730,Let us create array with elements which is filled with In the cell we will contain the maximal number of the submissions of the participant with identifier We will process submissions in the given order Let us process submission If then the answer is NO else we will update array Solution 6396297 
https://codeforces.com//contest/1809/problem/E,1839365,E,1809E,1809,E. Two Tanks,There are two water tanks the first one fits a liters of water the second one fits b liters of water The first tank has c 0 le c le a liters of water initially the second tank has d 0 le d le b liters of water initially You want to perform n operations on them The i th operation is specified by a single non zero integer v i If v i 0 then you try to pour v i liters of water from the first tank into the second one If v i 0 you try to pour v i liters of water from the second tank to the first one When you try to pour x liters of water from the tank that has y liters currently available to the tank that can fit z more liters of water the operation only moves min x y z liters of water For all pairs of the initial volumes of water c d such that 0 le c le a and 0 le d le b calculate the volume of water in the first tank after all operations are performed ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, a, b;\n    std::cin >> n >> a >> b;\n    \n    std::vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> v[i];\n    }\n    \n    std::vector ans(a + 1, std::vector<int>(b + 1));\n    for (int s = 0; s <= a + b; s++) {\n        int X = std::max(0, s - b);\n        int Y = std::min(a, s);\n        int lo = X, hi = Y;\n        for (int i = n - 1; i >= 0; i--) {\n            lo += v[i];\n            hi += v[i];\n            lo = std::max(lo, X);\n            hi = std::min(hi, Y);\n        }\n        int flo = lo, fhi = hi;\n        for (int i = 0; i < n; i++) {\n            flo = std::max(std::min(flo - v[i], Y), X);\n            fhi = std::max(std::min(fhi - v[i], Y), X);\n        }\n        for (int c = X; c <= Y; c++) {\n            int d = s - c;\n            if (c <= lo) {\n                ans[c][d] = flo;\n            } else if (c >= hi) {\n                ans[c][d] = fhi;\n            } else {\n                ans[c][d] = flo + c - lo;\n            }\n        }\n    }\n    \n    for (int c = 0; c <= a; c++) {\n        for (int d = 0; d <= b; d++) {\n            std::cout << ans[c][d] << "" \\n""[d == b];\n        }\n    }\n    \n    return 0;\n}']",,,"['binary search', 'dp', 'implementation', 'math']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Two Tanks.json,https://codeforces.com//blog/entry/114300,Consider a naive solution Iterate over all pairs and apply all operations The complexity is The constraints obviously imply that it s too much What can we cut from it Well surely will still remain there Both of and also should So we can probably only hope to turn this into Let s try that Notice that no matter what operations are applied never changes You can also peek at the examples and see that the patterns are suspiciously diagonal shaped in the matrix Let s try to solve the problem by fixing and calculating the answer for all values of I will call the fixed variable Consider case where and Here all can fit into both and so we can avoid caring about one restriction on the operations We ll think what to do with large volumes later If there are no operations the answer for each initial is for all from to Now consider an operation for some For nothing changes Actually for all the result of the operation is the same as for Hmm but if the result is the same it will remain the same until the end Same from the other side The answers for and also get merged together To me it kind of looks like a primitive form of DSU on these volume states you merge some prefix of the answers together and merge some suffix of the answers together If the state was merged to either or then it s easy to calculate the actual answer for that state What happens to the remaining states Well since they weren t merged anywhere the operation for them was applied fully if was requested all was poured How to deal with multiple operations then I propose the following idea When applying an operation we only want to know which of the previously non merged states become merged Basically we can squish all previous operations into one just sum up the signed amounts of water Since they all were applied fully to the non merged states it s completely valid After the squish check for the new merges You can actually study the structure of the answers and see that they go like that for some values of and such that It isn t that important but it makes the code easier You can basically calculate the length of the merged prefix the length of the merged suffix then calculate the answer at the end of the prefix in and restore all answers from it We neglected larger values of earlier time to return to them Another kind of limit to each operation is added when extra water doesn t fit in another tank Well it doesn t change that much It only makes more prefix suffix merges To come up with the exact formulas I followed these points Something merges on an operation when any of these holds not enough water in the first tank not enough space in the second tank not enough water in the second tank not enough space in the first tank Replace all with and you get the constraints for prefix and suffix merges Overall complexity 
https://codeforces.com//contest/1383/problem/D,681330,D,1383D,1383,D. Rearrange,Koa the Koala has a matrix A of n rows and m columns Elements of this matrix are distinct integers from 1 to n cdot m each number from 1 to n cdot m appears exactly once in the matrix For any matrix M of n rows and m columns let s define the following The i th row of M is defined as R i M M i1 M i2 ldots M im for all i 1 le i le n The j th column of M is defined as C j M M 1j M 2j ldots M nj for all j 1 le j le m Koa defines S A X Y as the spectrum of A where X is the set of the maximum values in rows of A and Y is the set of the maximum values in columns of A More formally X max R 1 A max R 2 A ldots max R n A Y max C 1 A max C 2 A ldots max C m A Koa asks you to find some matrix A of n rows and m columns such that each number from 1 to n cdot m appears exactly once in the matrix and the following conditions hold S A S A R i A is bitonic for all i 1 le i le n C j A is bitonic for all j 1 le j le m An array t t 1 t 2 ldots t k is called bitonic if it first increases and then decreases More formally t is bitonic if there exists some position p 1 le p le k such that t 1 t 2 ldots t p t p 1 ldots t k Help Koa to find such matrix or to determine that it doesn t exist ,"['/**\n *    author:  tourist\n *    created: 24.07.2020 18:10:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h, w;\n  cin >> h >> w;\n  vector<vector<int>> a(h, vector<int>(w));\n  vector<pair<int, int>> pos(h * w);\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> a[i][j];\n      --a[i][j];\n      pos[a[i][j]] = make_pair(i, j);\n    }\n  }\n  vector<vector<int>> b(h, vector<int>(w, -1));\n  int pi = -1;\n  int pj = -1;\n  vector<pair<int, int>> cells;\n  int ptr = 0;\n  for (int val = h * w - 1; val >= 0; val--) {\n    for (int i = 0; i < h; i++) debug(b[i]);\n    debug(pi, pj, cells);\n    auto& at = pos[val];\n    int vi = at.first;\n    int vj = at.second;\n    bool row_max = true;\n    for (int j = 0; j < w; j++) {\n      row_max &= (a[vi][j] <= val);\n    }\n    bool col_max = true;\n    for (int i = 0; i < h; i++) {\n      col_max &= (a[i][vj] <= val);\n    }\n    debug(val, vi, vj, row_max, col_max);\n    if (row_max && col_max) {\n      b[++pi][++pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    if (row_max) {\n      b[++pi][pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      continue;\n    }\n    if (col_max) {\n      b[pi][++pj] = val;\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    assert(ptr < (int) cells.size());\n    b[cells[ptr].first][cells[ptr].second] = val;\n    ++ptr;\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (j > 0) {\n        cout << "" "";\n      }\n      cout << b[i][j] + 1;\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['brute force', 'constructive algorithms', 'graphs', 'greedy', 'sortings']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Rearrange.json,https://codeforces.com//blog/entry/80562,Let be a matrix of size that is formed by a permutation of elements from to Find the maximum element on each row and column i e the spectrum Now we are going to build the answer adding numbers one by one in decreasing order We start with an empty 2 dimensional matrix both dimensions have length 0 and at the end of each iteration the following invariants will be maintained on the matrix All elements processed are inside of the matrix Each row and column is bitonic The horizontal vertical spectrum of this matrix is a subset of the expected horizontal vertical spectrum In addition we are keeping a queue with all positions in the matrix that doesn t contain any element yet At the end of each iteration the following invariants will be maintained on the queue Let be a position on the queue and a position that contains a value that belongs to the horizontal spectrum in the matrix such that and are in the same row then all positions between and have already an element in the matrix or occur in the queue before Let be a position on the queue and a position that contains a value that belongs to the vertical spectrum in the matrix such that and are in the same column then all positions between and have already an element in the matrix or occur in the queue before M int 0 0 Queue new Queue sides of the matrixx y 0 0 for num in n m 1 if num belongs to the horizontal spectrum Add one row full of 0 in the bottom of the matrix X 1 if num belongs to the vertical spectrum Add one column full of 0 in the right of the matrix Y 1 if num belongs either to the horizontal or to the vertical spectrum Put num in the bottom rightmost position of the matrix M x y num else ax ay pop element from Queue M ax ay num if num belongs to the horizontal spectrum Add all positions in the last row but the last one to the Queue from right to left for py in y 1 1 Queue add x py if num belongs to the vertical spectrum Add all positions in the last column but the last one to the Queue from bottom to top for px in X 1 1 Queue add px y In the end invariants on the matrix guarantee that all elements are placed each row and column consist in a bitonic sequence as required and the spectrums are equal to the expected spectrums Let s prove each invariant on the matrix is kept Clearly on each step a different element is placed on the matrix on an empty position we should only show that the operation doesn t fail with Queue empty Say the current element is so the matrix is filled with elements larger than Now we know that in original matrix there were at least rows with maximums less than t and at least m y columns with maximums less than so there could be at most elements greater or equal than t but there are already On each row and column the first element added is the maximum and then elements are added in each direction starting from it toward each edge since elements are processed from largest to smallest then each row and column is bitonic The first element added on each row and column is the maximum and we only add it if it is part of the expected spectrum Time complexity 
https://codeforces.com//contest/1327/problem/E,571328,E,1327E,1327,E. Count The Blocks,You wrote down all integers from 0 to 10 n 1 padding them with leading zeroes so their lengths are exactly n For example if n 3 then you wrote out A block in an integer x is a consecutive segment of equal digits that cannot be extended to the left or to the right For example in the integer 00027734000 there are three blocks of length 1 one block of length 2 and two blocks of length 3 For all integers i from 1 to n count the number of blocks of length i among the written down integers Since these integers may be too large print them modulo 998244353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nll pw[201000];\nint main() {\n\tscanf(""%d"",&n);\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=pw[i-1]*10%mod;\n\tfor (int i=1;i<=n;i++) {\n\t\tif (i==n) { puts(""10""); continue; }\n\t\tint d=0;\n\t\tif (i<=n-2) d=(d+10*(n-i-1)*9*9*pw[n-i-2])%mod;\n\t\td=(d+2*10*9*pw[n-i-1])%mod;\n\t\tprintf(""%d "",d);\n\t}\n}']",,,"['combinatorics', 'dp', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Count The Blocks.json,https://codeforces.com//blog/entry/75147,Presume that we want to calculate the number of blocks of length len Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks 111 and 0 in integer 11173220 other blocks At first let s calculate the number of blocks of first type We can choose 2 positions of this block at the start of end of the integer Now we can choose 10 digit for this block After that we can chose 9 digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than len so we have only 9 variations of digit in adjacent block Finally the can chose the remaining digit 10 n len 1 ways So the total number of block of first type is 2 cdot 10 cdot 9 cdot 10 n len 1 Now let s calculate the number of blocks of second type We can choose n len 1 positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose 9 2 digits of adjacent block 9 for block to the left and 9 for block to the right Finally the can chose the remaining digit 10 n len 2 ways So the total number of block of second type is n len 1 cdot 10 cdot 9 2 cdot 10 n len 2 That s almost all We have one corner case If len n then we number of blocks is always 10 
https://codeforces.com//contest/1209/problem/G2,411985,G2,1209G2,1209,G2. Into Blocks  hard version ,A sequence of integers is called if its elements are arranged in blocks like in 3 3 3 4 1 1 Formally if two elements are equal everything in between must also be equal Let s define of a sequence as a minimum possible number of elements to change to get a nice sequence However if you change at least one element of value x to value y you must also change all other elements of value x into y as well For example for 3 3 1 3 2 1 2 it isn t allowed to change first 1 to 3 and second 1 to 2 You need to leave 1 s untouched or change them to the same value You are given a sequence of integers a 1 a 2 ldots a n and q updates Each update is of form i x change a i to x Updates are not independent the change stays for the future Print the difficulty of the initial sequence and of the sequence after every update ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 3e5 + 7;\n\nint a[N];\nset <int> q[N];\nint cnt[N];\n\nstruct segm {\n  int l, r, x;\n};\n\nset <segm> e;\n\nbool operator < (const segm &a, const segm &b) {\n  return a.l < b.l;\n}\n\nconst int B = 300;\nconst int BL = B;\n\nint suf[N];\nint max_x[N];\nint jump_r[N];\nint cnt_here[N];\nint sum_here[N];\n\nvector <segm> orz[N];\n\nint w[N];\nint tr[N];\nbool vis[N];\n\nvoid rebuild_block(int l) {\n  l -= l % B;\n  static vector <segm> p;\n  p.clear();\n  for (int i = l; i < l + B && i < N; i++) {\n    if (vis[i]) {\n      p.push_back({i, tr[i], w[i]});\n    }\n  }\n  segm ret;\n  ret.l = 0;\n  ret.r = -1;\n  ret.x = 0;\n  static vector <segm> ans;\n  ans.clear();\n  for (auto c : p) {\n    if (c.l > ret.r) {\n      if (ret.r != -1) {\n        ans.push_back(ret);\n      }\n      ret = c;\n    } else {\n      ret.r = max(ret.r, c.r);\n      ret.x = max(ret.x, c.x);\n    }\n  }\n  if (ret.r != -1) {\n    ans.push_back(ret);\n  }\n  orz[l] = ans;\n  int j = -1;\n  int mx = 0;\n  int r = -1;\n  int sum = 0;\n  for (int i = l; i < l + B && i < N; i++) {\n    while (j + 1 < (int) ans.size() && ans[j + 1].l <= i) {\n      j++;\n      mx = max(mx, ans[j].x);\n      r = max(r, ans[j].r);\n      sum += ans[j].x;\n    }\n    sum_here[i] = sum;\n    cnt_here[i] = j + 1;\n    max_x[i] = mx;\n    jump_r[i] = r;\n  }\n}\n\nvoid del(int x, int i) {\n  int l = *q[x].begin(), r = *prev(q[x].end());\n  vis[l] = false;\n  e.erase({l, r, cnt[x]});\n  cnt[x]--;\n  q[x].erase(i);\n  rebuild_block(l);\n  if (cnt[x]) {\n    int l = *q[x].begin(), r = *prev(q[x].end());\n    vis[l] = true;\n    w[l] = cnt[x];\n    tr[l] = r;\n    e.insert({l, r, cnt[x]});\n    rebuild_block(l);\n  }\n}\n\nvoid add(int x, int i) {\n  if (cnt[x]) {\n    int l = *q[x].begin(), r = *prev(q[x].end());\n    vis[l] = false;\n    e.erase({l, r, cnt[x]});\n    rebuild_block(l);\n  }\n  cnt[x]++;\n  q[x].insert(i);\n  int l = *q[x].begin(), r = *prev(q[x].end());\n  vis[l] = true;\n  w[l] = cnt[x];\n  tr[l] = r;\n  e.insert({l, r, cnt[x]});\n  rebuild_block(l);\n}\n\nint ans() {\n  int vr = -1;\n  int tot = 0;\n  int gao = 0;\n  for (int i = 0; i < 200000; i += B) {\n    if (orz[i].empty()) continue;\n    if (vr <= i) {\n      tot += gao;\n      tot += sum_here[i + BL - 1] - orz[i].back().x;\n      gao = orz[i].back().x;\n      vr = orz[i].back().r;\n    } else {\n      int value = min(vr, i + BL - 1);\n      gao = max(gao, max_x[value]);\n      vr = max(vr, jump_r[value]);\n      if (cnt_here[value] != cnt_here[i + BL - 1]) {\n        tot += gao;\n        tot += sum_here[i + BL - 1] - sum_here[value] - orz[i].back().x;\n        gao = orz[i].back().x;\n        vr = orz[i].back().r;\n      }\n    }\n  }\n  return tot + gao;\n}\n\nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n = 200000, tq = 200000;\n  cin >> n >> tq;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n    q[a[i]].insert(i);\n    cnt[a[i]]++;\n    //add(a[i], i);\n  }\n  for (int i = 0; i < N; i++)  {\n    if (!q[i].empty()) {\n      vis[*q[i].begin()] = true;\n      w[*q[i].begin()] = cnt[i];\n      tr[*q[i].begin()] = *q[i].rbegin();\n      e.insert({*q[i].begin(), *q[i].rbegin(), cnt[i]});\n    }\n  }\n  for (int i = 0; i < N; i += BL) {\n    rebuild_block(i);\n  }\n  cout << n - ans() << \'\\n\';\n  for (int j = 0; j < tq; j++) {\n    int i, x;\n    cin >> i >> x;\n    i--, x--;\n    del(a[i], i);\n    a[i] = x;\n    add(a[i], i);\n    cout << n - ans() << \'\\n\';\n  }\n}\n']",,,['data structures'],3200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G2. Into Blocks  hard version .json,https://codeforces.com/blog/entry/69791,To adjust the solution for many queries we need to create some sophisticated data structure E g we all know that mentioned above 1 on a segment is easily done with a segtree If we maintain for every value the corresponding set of occurrences it s easy to update mentioned above number of occurrences in the first position So what we need to do now We need to dynamically recalculate the sum of minimums and the set segments to calculate minimum can change quite much due to updates You probably also now that we can design a segtree which supports range increments and query minimum number of minimums on the segment In a similar way we can build a structure which returns minimum number of minimums the sum of largest stored counts between minimums Just maintain a few values in each node and do lazy propagation Complexity Code 
https://codeforces.com//contest/1715/problem/E,1513953,E,1715E,1715,E. Long Way Home,Stanley lives in a country that consists of n cities he lives in city 1 There are bidirectional roads between some of the cities and you know how long it takes to ride through each of them Additionally there is a flight between each pair of cities the flight between cities u and v takes u v 2 time Stanley is quite afraid of flying because of watching Sully Miracle on the Hudson recently so he can take at most k flights Stanley wants to know the minimum time of a journey to each of the n cities from the city 1 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(""%d"",&x);\n\treturn x;\n}\nconst int N=1e5+5;\ntypedef long long ll;\nconst ll inf=1e13;\nint n,m,k;\nint lst[N],to[N<<1],len[N<<1],nxt[N<<1],ec;\ninline void ae(int x,int y,int z){\n\tto[++ec]=y,nxt[ec]=lst[x],len[ec]=z,lst[x]=ec;\t\n}\nll dis[N];\nvoid dijkstra(){\n\tpriority_queue<pair<ll,int> > pq;\n\tfor(int i=1;i<=n;i++)pq.push(make_pair(-dis[i],i));\n\twhile(pq.size()){\n\t\tint x=pq.top().second;\n\t\tll d=-pq.top().first;\n\t\tpq.pop();\n\t\tif(d!=dis[x])continue;\n\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\tint y=to[i];\n\t\t\tif(dis[y]>d+len[i]){\n\t\t\t\tdis[y]=d+len[i];\n\t\t\t\tpq.push(make_pair(-dis[y],y));\n\t\t\t}\n\t\t}\n\t}\n}\nll px[N],py[N];\nint q[N],ql,qr;\nbool check(int a,int b,int c){\n\tll v1=(ll)(py[b]-py[a])*(px[c]-px[a]);\n\tll v2=(ll)(py[c]-py[a])*(px[b]-px[a]);\n\treturn v1>=v2;\n}\nll get(int p,int k){\n\treturn py[p]-2*px[p]*k;\n}\nvoid dp(){\t\n\tql=1,qr=0;\n\tfor(int i=1;i<=n;i++){\n\t\tpx[i]=i,py[i]=dis[i]+(ll)i*i;\n\t\twhile(ql<qr&&check(q[qr-1],q[qr],i))qr--;\n\t\tq[++qr]=i;\n\t\twhile(ql<qr&&get(q[ql],i)>=get(q[ql+1],i))ql++;\n\t\tdis[i]=get(q[ql],i)+(ll)i*i;\n\t}\n}\nint main(){\n\tn=in(),m=in(),k=in();\n\twhile(m--){\n\t\tint x=in(),y=in(),z=in();\n\t\tae(x,y,z),ae(y,x,z);\t\n\t}\n\tfor(int i=2;i<=n;i++)dis[i]=inf;\n\tdijkstra();\n\twhile(k--){\n\t\tdp();\n\t\treverse(dis+1,dis+n+1);\n\t\tdp();\n\t\treverse(dis+1,dis+n+1);\n\t\tdijkstra();\n\t}\n\tfor(int i=1;i<=n;i++)printf(""%lld "",dis[i]);\n\treturn 0;\n}\n']",,,"['data structures', 'divide and conquer', 'dp', 'geometry', 'graphs', 'greedy', 'shortest paths']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Long Way Home.json,https://codeforces.com//blog/entry/104261,Let s assume we know the shortest distances from the first vertex to each if we have added no more than edges air travels Let s learn to recalculate the answer for edges First let s update the answer for all the paths ending in an air travel Then we can run Dijkstra to take into account all the paths ending with a usual edge In order to add an air travel we need to update the distance to with all the paths ending with an air travel to To do so we can use Convex Hull Trick since the recalculation formula has the following form array of distances for edges array of distances if the flight goes exactly to the th vertex After that we need to run Dijkstra to update the distances with all the paths not ending with an air travel The resulting asymptotics is 
https://codeforces.com//contest/741/problem/B,83311,B,741B,741,B. Arpa s weak amphitheater and Mehrdad s valuable Hoses,Mehrdad wants to invite some Hoses to the palace for a dancing party Each Hos has some weight and some beauty Also each Hos may have some friends Hoses are divided in some friendship groups Two Hoses and are in the same friendship group if and only if there is a sequence of Hoses such that and are friends for each and and Arpa allowed to use the amphitheater of palace to Mehrdad for this party Arpa s amphitheater can hold at most weight on it Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than and sum of their beauties is as large as possible Along with that from each friendship group he can either invite all Hoses or no more than one Otherwise some Hoses will be hurt Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn t exceed ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,m,v,w[N],b[N],f[N],u,vv;\nint dp[N],pd[N];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&v);\n\trep(i,1,n+1) scanf(""%d"",w+i);\n\trep(i,1,n+1) scanf(""%d"",b+i);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&vv);\n\t\tf[find(u)]=find(vv);\n\t}\n\trep(i,1,n+1) if (find(i)==i) {\n\t\tVI itm; int sw=0,sb=0;\n\t\trep(j,1,n+1) if (find(j)==i) itm.pb(j),sw+=w[j],sb+=b[j];\n\t\trep(j,0,v+1) pd[j]=dp[j];\n\t\tfor (auto p:itm) {\n//\t\t\tprintf(""%d %d\\n"",w[p],b[p]);\n\t\t\trep(j,w[p],v+1) dp[j]=max(dp[j],pd[j-w[p]]+b[p]);\n\t\t}\n\t\trep(j,sw,v+1) dp[j]=max(dp[j],pd[j-sw]+sb);\n//\t\tprintf(""%d %d\\n"",sw,sb);\n//\t\tputs("""");\n//\t\tprintf(""%d\\n"",i);\n\t}\n\tprintf(""%d\\n"",dp[v]);\n}\n']",,,"['dfs and similar', 'dp', 'dsu']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Arpa s weak amphitheater and Mehrdad s valuable Hoses.json,https://codeforces.com//blog/entry/48871,It s a simple knapsack problem Let s solve this version of knapsack problem first we have sets of items each item has value and weight find the maximum value we can earn if we can choose at most one item from each set and the sum of the chosen items must be less than or equal to Let be the max value we can earn if the sum of weights of chosen items is less than or equal to Now iterate on sets one by one and update as follows for each item and for each weight Run dfs and find groups at first The problem is same with above problem each group is some set in above problem just add the whole group as an item to the set that related to this group Time complexity 
https://codeforces.com//contest/1667/problem/B,1373069,B,1667B,1667,B. Optimal Partition,You are given an array a consisting of n integers You should divide a into continuous non empty subarrays there are 2 n 1 ways to do that Let s a l a l 1 ldots a r The value of a subarray a l a l 1 ldots a r is r l 1 if s 0 0 if s 0 r l 1 if s 0 What is the maximum sum of values you can get with a partition ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, dp[500005];\nLL a[500005];\nvector<LL> val;\nstruct fwt\n{\n\tint m, val[500005];\n\tvoid clear(int cm)\n\t{\n\t\tm = cm;\n\t\trep1(i, m) val[i] = -INF; \n\t}\n\tvoid ins(int id, int x)\n\t{\n\t\tfor(id ++; id <= m; id += id & -id) val[id] = max(val[id], x);\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = -INF;\n\t\tfor(id ++; id > 0; id -= id & -id) ret = max(ret, val[id]);\n\t\treturn ret;\n\t}\n}t0, t1;\nvoid solve()\n{\n\tscanf(""%d"", &n);\n\trep1(i, n) scanf(""%lld"", &a[i]);\n\trep1(i, n) a[i] += a[i - 1];\n\tval.clear();\n\trep(i, n + 1) val.push_back(a[i]);\n\tsort(val.begin(), val.end());\n\tval.resize(unique(val.begin(), val.end()) - val.begin());\n\t\n\tt0.clear(n + 1);\n\tt1.clear(n + 1);\n\trep(i, n + 1) {\n\t\tint cur = lower_bound(val.begin(), val.end(), a[i]) - val.begin();\n\t\tif(i == 0) dp[i] = 0;\n\t\telse dp[i] = max(dp[i - 1] - 1, max(t0.query(cur), t1.query(cur) + i));\n\t\tt0.ins(cur, dp[i]);\n\t\tt1.ins(cur + 1, dp[i] - i);\n\t}\n\tprintf(""%d\\n"", dp[n]);\n}\n\nint main()\n{\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']",,,"['data structures', 'dp']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Optimal Partition.json,https://codeforces.com//blog/entry/102013,Let dpi be the answer for the first i elements and v i j the value of the subarray i j With prefix sums it is easy to calculate v i j quickly With this we can get a n2 solution dpi max dpj v j 1 i for j i Lets call a segment winning drawing or losing if the value of it is positive 0 or negative respectively There is an optimal solution if the length of the drawing and losing segments are 1 The task is solvable without this observation but it is harder to implement Proof For a losing segment in the worst case we can get two losing segments with the same total length the same value For a drawing segment with length k if k is even than the answer is the same if we split it into two segments with length k 2 For odd k if the sum in the first k 1 2 or last k 1 2 elements is negative than it is possible to increase the answer otherwise one can split the segment into k 1 2 1 and k 1 2 long segments and the answer for the new partition can t lessen So there is an optimal solution when only winning segments might be longer than 1 It is easy to handle the 1 long segments For each i 1 i n we have to find j 0 j i where v j 1 i 0 and dpj v j 1 i is maximal dp0 0 If we store the prefix sums and assign a permutation according to the prefix sums than we can get all the positions 1 j i where v j 1 i 0 Than v j 1 i i j So when we calculate dpi we should update with dpi i This way finding the optimal j for each i is just a prefix maximum One can solve the problem with Fenwick tree or segment tree Final complexity is O n log n 
https://codeforces.com//contest/1167/problem/F,344635,F,1167F,1167,F. Scalar Queries,You are given an array a 1 a 2 dots a n All a i are pairwise distinct Let s define function f l r as follows let s define array b 1 b 2 dots b r l 1 where b i a l 1 i sort array b in increasing order result of the function f l r is sum limits i 1 r l 1 b i cdot i Calculate left sum limits 1 le l le r le n f l r right mod 10 9 7 i e total sum of f for all subsegments of a modulo 10 9 7 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\n\nll tab[nax];\n\nll wyn;\n\nll drz[nax][2];//0 to z lewej\n\nvoid pisz(int v, ll w, int p)\n{\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tdrz[i][p]=(drz[i][p]+w)%mod;\n}\n\nll czyt(int a, int b, int p)\n{\n\tll ret=0;\n\tfor (int i=b; i; i-=(i&(-i)))\n\t\tret+=drz[i][p];\n\tfor (int i=a-1; i; i-=(i&(-i)))\n\t\tret-=drz[i][p];\n\tret%=mod;\n\tif (ret<0)\n\t\tret+=mod;\n\treturn ret;\n}\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tdod(wyn, tab[i]*i%mod*(n-i+1));\n\tvector <pll> wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back({tab[i], i});\n\tsort(wek.begin(), wek.end());\n\tdebug() << imie(wyn);\n\tfor (pll h : wek)\n\t{\n\t\tint i=h.second;\n\t\tll lew=czyt(1, i-1, 0);\n\t\tll pra=czyt(i+1, n, 1);\n\t\tdod(wyn, lew*(n+1-i)%mod*tab[i]+pra*i%mod*tab[i]);\n\t\tpisz(i, i, 0);\n\t\tpisz(i, n-i+1, 1);\n\t}\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']",,,"['combinatorics', 'data structures', 'math', 'sortings']",2300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Scalar Queries.json,https://codeforces.com/blog/entry/67058,Let s define some functions at first indicator function if is true and otherwise is a number of that and Good observation Another observation Now it s time to transform what we d like to calculate Since transformation of the second sum was standard we ll look at the first sum So we can iterate over and we d like to calculate this two sums fast enough So more transformations So while iterating over we need to make queries of two types set value in position and calculate It can be done by BIT with coordinate compression can be calculated in the same way iterating over in reverse order Result complexity is 
https://codeforces.com//contest/1426/problem/B,741031,B,1426B,1426,B. Symmetric Matrix,Masha has n types of tiles of size 2 times 2 Each cell of the tile contains one integer Masha has an of tiles of each type Masha decides to construct the square of size m times m consisting of the given tiles This square also has to be a and each cell of this square has to be covered with exactly one tile cell and also sides of tiles should be parallel to the sides of the square All placed tiles cannot intersect with each other Also each tile should lie inside the square See the picture in Notes section for better understanding Symmetric with respect to the main diagonal matrix is such a square s that for each pair i j the condition s i j s j i holds I e it is true that the element written in the i row and j th column equals to the element written in the j th row and i th column Your task is to determine if Masha can construct a square of size m times m which is a symmetric matrix and consists of tiles she has Masha can use any number of tiles of each type she has to construct the square Note that she rotate tiles she can only place them in the orientation they have in the input You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl ""\\n""\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<\'(\'<<p.F<< "",""<<p.S<<\')\'; \n}\n\nint _runtimeTerror_()\n{\n    ll n,m;\n    cin>>n>>m;\n    bool f = false;\n    for(int i=1;i<=n;++i)\n    {\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(b==c)\n            f = true;\n    }\n    if(m%2!=0 || !f)\n    {\n        cout<<""NO\\n"";\n    }\n    else\n        cout<<""YES\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']",,,['implementation'],900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\B. Symmetric Matrix.json,https://codeforces.com//blog/entry/83120,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
https://codeforces.com//contest/1697/problem/A,1427640,A,1697A,1697,A. Parkway Walk,You are walking through a parkway near your house The parkway has n 1 benches in a row numbered from 1 to n 1 from left to right The distance between the bench i and i 1 is a i meters Initially you have m units of energy To walk 1 meter of distance you spend 1 unit of your energy You can t walk if you have no energy Also you can restore your energy by and this is the only way to restore the energy When you are sitting you can restore any integer amount of energy you want if you sit longer you restore more energy Note that the amount of your energy m Your task is to find the amount of energy you have to by sitting on benches to reach the bench n 1 from the bench 1 and end your walk You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 18:34:19       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n      int a;\n      cin >> a;\n      s += a;\n    }\n    cout << max(0, s - m) << \'\\n\';\n  }\n  return 0;\n}\n']",,,"['greedy', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\A. Parkway Walk.json,https://codeforces.com//blog/entry/103835,If you have at least units of energy then the answer is because you can just walk to the end Otherwise the answer is because you can just sit on the first bench and then just go Time complexity 
https://codeforces.com//contest/1620/problem/F,1233293,F,1620F,1620,F. Bipartite Array,You are given a permutation p consisting of n integers 1 2 dots n a permutation is an array where each element from 1 to n occurs exactly once Let s call an array a if the following undirected graph is bipartite the graph consists of n vertices two vertices i and j are connected by an edge if i j and a i a j Your task is to find a array of integers a of size n such that a i p i or a i p i or report that no such array exists If there are multiple answers print any of them ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T_vector>\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end = int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\n\nconst int INF = int(1e9) + 5;\n\nstruct state {\n    int high = -INF, low = -INF;\n    int previous = -1, a = 0;\n\n    bool operator<(const state &other) const {\n        if (high != other.high)\n            return high < other.high;\n\n        return low < other.low;\n    }\n\n    pair<state, bool> add(int from, int x) {\n        if (x < low)\n            return {state(), false};\n\n        state sum = *this;\n        sum.previous = from;\n        sum.a = x;\n\n        if (x > high)\n            sum.high = x;\n        else\n            sum.low = x;\n\n        return {sum, true};\n    }\n};\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> P(N);\n\n    for (auto &p : P)\n        cin >> p;\n\n    vector<vector<state>> dp(N + 1);\n    dp[0] = {state()};\n\n    for (int i = 0; i < N; i++) {\n        for (int x : {-P[i], P[i]})\n            for (int j = 0; j < int(dp[i].size()); j++) {\n                state s = dp[i][j];\n                pair<state, bool> result = s.add(j, x);\n\n                if (result.second)\n                    dp[i + 1].push_back(result.first);\n            }\n\n        sort(dp[i + 1].begin(), dp[i + 1].end());\n        vector<state> filtered;\n\n        for (state s : dp[i + 1]) {\n            bool bad = false;\n\n            for (state f : filtered)\n                if (f.low <= s.low && f.high <= s.high)\n                    bad = true;\n\n            if (!bad)\n                filtered.push_back(s);\n        }\n\n        dp[i + 1] = filtered;\n    }\n\n    if (dp.back().empty()) {\n        cout << ""NO"" << \'\\n\';\n        return;\n    }\n\n    cout << ""YES"" << \'\\n\';\n    vector<int> A(N);\n    int index = 0;\n\n    for (int i = N - 1; i >= 0; i--) {\n        state s = dp[i + 1][index];\n        A[i] = s.a;\n        index = s.previous;\n    }\n\n    output_vector(A);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['dp', 'greedy']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Bipartite Array.json,https://codeforces.com//blog/entry/98061,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter 
https://codeforces.com//contest/721/problem/C,73869,C,721C,721,C. Journey,Recently Irina arrived to one of the most famous cities of Berland the Berlatov city There are showplaces in the city numbered from to and some of them are connected by one directional roads The roads in Berlatov are designed in a way such that there cyclic routes between showplaces Initially Irina stands at the showplace and the endpoint of her journey is the showplace Naturally Irina wants to visit as much showplaces as she can during her journey However Irina s stay in Berlatov is limited and she can t be there for more than time units Help Irina determine how many showplaces she may visit during her journey from showplace to showplace within a time not exceeding It is guaranteed that there is at least one route from showplace to showplace such that Irina will spend no more than time units passing it ,"['#include<bits/stdc++.h>\n#define N 5005\nusing namespace std;\n\nint d[N][N],pre[N][N],tot,fst[N],nxt[N],pnt[N],len[N],n,m,t; bool vis[N];\nvoid add(int x,int y,int z){pnt[++tot]=y;len[tot]=z;nxt[tot]=fst[x];fst[x]=tot;}\nvoid dp(int x){\n\tint i,j,y;\n\tif (vis[x]) return; vis[x]=1;\n\t\tif (x==1) d[x][1]=0;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];dp(y);\n\t\tfor (j=1; j<=n; j++)\n\t\t\tif (d[y][j-1]+len[i]<d[x][j]){\n\t\t\t\td[x][j]=d[y][j-1]+len[i]; pre[x][j]=y;\n\t\t\t}\n\t}\n}\nvoid solve(int x,int y){\n\tif (y>1) solve(pre[x][y],y-1);printf(""%d "",x);\n}\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&t);\n\tint i,x,y,z;\n\tfor (i=1; i<=m; i++){\n\t\tscanf(""%d%d%d"",&x,&y,&z);\n\t\tadd(y,x,z);\n\t}\n\tmemset(d,0x3f,sizeof(d));\n\t//cout<<d[0][0]<<endl;\n\tdp(n);\n\tfor (i=n; i; i--) if (d[n][i]<=t) break;\n\t//\tcout<<d[n][i]<<endl;\n\tprintf(""%d\\n"",i);\n\tsolve(n,i);\n\treturn 0;\n}\n']",,,"['dp', 'graphs']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Journey3970.json,https://codeforces.com//blog/entry/47457,Author s solution uses dynamic programming Let be the minimum time required to arrive at the vertex if we visit vertices including vertices and We have a DAG directed acyclic graph so we can compute it recursively and memory constraints were a bit strict in this problem so it s better to use recursion to compute it Let s store the transposed version of the graph if we had an edge in the input we will store Then our function which will compute the answer for will be like that the base of dynamic programming is all other states are equal to 1 If we call then it will work like that if the state we want to compute is incorrect we return a very large integer number any number that is greater than because If the answer for this state has already been calculated then we return it is easy do determine if then it has already been calculated Else we begin to calculate the state Firstly let s put a number greater than into Then look at all the edges beginning in and try to update with the value of is the vertex at the endpoint of current edge is the weight of this edge If this value is less than then we update and store the information that our last update in was from the vertex If we try to go by path which doesn t end in the vertex then we get a value which is greater than that s because that the only value we didn t denote as is So now we have our function let s compute the answer We will iterate on the number of vertices in the path from to in descending order and if then we have found the answer now we iterate on the parent vertices we stored while calculating our until we come to vertex it s important because some participants sent solutions that continued even past vertex and print the answer Time complexity of this solution and mempry complexity 
https://codeforces.com//contest/1679/problem/E,1399040,E,1679E,1679,E. Typical Party in Dorm,You are given a string s of length n which consists of the first 17 lowercase Latin letters a b c ldots p q and question marks And q queries Each query is defined by a set of pairwise distinct lowercase first 17 letters of the Latin alphabet which can be used to replace the question marks in the string s The answer to the query is the sum of the number of distinct substrings that are palindromes over all strings that can be obtained from the original string s by replacing question marks with available characters The answer must be calculated modulo 998 244 353 Two substrings are different when their start and end positions in the string are different So the number of different substrings that are palindromes for the string will be 4 Consider examples of replacing question marks with letters For example from the string when querying a b you can get the strings or but you cannot get the strings or Recall that a palindrome is a string that reads the same from left to right as from right to left ,"['#include<stdio.h>\n#include<iostream>\nusing namespace std;\nconst int mod=998244353,maxn=20,maxl=1005;\nint n,q,m;\nint f[maxn][1<<17],mul[maxn][maxl],imul[maxn][maxl];\nstring s,t;\nint ksm(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1)\n\t\t\tres=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(""%d"",&n),cin>>s,scanf(""%d"",&q),s="" ""+s;\n\tfor(int i=1;i<=n;i++)\n\t\tm+=(s[i]==\'?\');\n\tfor(int i=1;i<=17;i++){\n\t\tmul[i][0]=imul[i][0]=1;\n\t\tint v0=i,v1=ksm(i,mod-2);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tmul[i][j]=1ll*mul[i][j-1]*v0%mod,imul[i][j]=1ll*imul[i][j-1]*v1%mod;\n\t}\n\tfor(int c=1;c<=17;c++){//ji de gai\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint x=i,y=i,S=0,t=0;\n\t\t\twhile(x>=1&&y<=n){\n\t\t\t\tif(s[x]!=\'?\'&&s[y]!=\'?\'&&s[x]!=s[y])\n\t\t\t\t\tbreak;\n\t\t\t\tif(s[x]==\'?\'&&s[y]!=\'?\')\n\t\t\t\t\tS|=(1<<(s[y]-97)),t++;\n\t\t\t\tif(s[x]!=\'?\'&&s[y]==\'?\')\n\t\t\t\t\tS|=(1<<(s[x]-97)),t++;\n\t\t\t\tif(x<y&&s[x]==\'?\'&&s[y]==\'?\')\n\t\t\t\t\tt++;\n//\t\t\t\tprintf(""x=%d y=%d c=%d S=%d t=%d\\n"",x,y,c,S,t);\n\t\t\t\tf[c][S]=(f[c][S]+imul[c][t])%mod;\n\t\t\t\tx--,y++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint x=i,y=i+1,S=0,t=0;\n\t\t\twhile(x>=1&&y<=n){\n\t\t\t\tif(s[x]!=\'?\'&&s[y]!=\'?\'&&s[x]!=s[y])\n\t\t\t\t\tbreak;\n\t\t\t\tif(s[x]==\'?\'&&s[y]!=\'?\')\n\t\t\t\t\tS|=(1<<(s[y]-97)),t++;\n\t\t\t\tif(s[x]!=\'?\'&&s[y]==\'?\')\n\t\t\t\t\tS|=(1<<(s[x]-97)),t++;\n\t\t\t\tif(s[x]==\'?\'&&s[y]==\'?\')\n\t\t\t\t\tt++;\n\t\t\t\tf[c][S]=(f[c][S]+imul[c][t])%mod;\n//\t\t\t\tprintf(""x=%d y=%d c=%d S=%d t=%d\\n"",x,y,c,S,t);\n\t\t\t\tx--,y++;\n\t\t\t}\n\t\t}\n\t\tfor(int len=2,now=1;len<=(1<<17);len<<=1,now<<=1)\n\t\t\tfor(int i=0;i<(1<<17);i+=len)\n\t\t\t\tfor(int j=0;j<now;j++)\n\t\t\t\t\tf[c][i+j+now]=(f[c][i+j+now]+f[c][i+j])%mod;\n\t}\n\twhile(q--){\n\t\tint x,S=0;\n\t\tcin>>t;\n\t\tfor(int i=0;i<t.size();i++)\n\t\t\tS|=(1<<(t[i]-97));\n\t\tprintf(""%d\\n"",1ll*f[t.size()][S]*mul[t.size()][m]%mod);\n\t}\n\treturn 0;\n}\n']",,,"['bitmasks', 'combinatorics', 'dp', 'strings']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Typical Party in Dorm.json,https://codeforces.com//blog/entry/102859,Let us solve the problem initially for a query First we can see that instead of counting the number of palindromes in each possible version of string we can count the number of strings in which a substring would be a palindrome Consider the substring Suppose the set of allowed characters in this query is What would be the effect of the substring on the answer Divide the characters of the substring into pairs first with last second with penultimate and so on If the length of the substring is odd pair the central character with itself Now let s consider each pair separately If two characters of the pair are equal and they are not question marks then this pair does not affect the answer If two characters of the pair are equal and they are question marks then this pair multiplies the answer by where the number of possible characters to replace in this query Let s call the number of such pairs If two characters of the pair are not equal and there is no question mark among them then this substring will never be a palindrome If two characters of a pair are not equal and there is a question mark among them you must check if the letter that is not a question mark belongs to the set if not then this substring will never be a palindrome Those pairs that cause this substring not to be a palindrome will be called Thus we got the number of possible ways to replace question marks in substring with valid characters such that substring a palindrome is or if we have a blocking pair To get the total number of lines in which is a palindrome just multiply the previous value by where is the number of question marks that lie within Thus to get the answer for the substring it is enough Check for blocking pairs if they exist the answer is by definition Otherwise the answer is where and are defined above Let s assign to each possible set of letters a binary mask of size where the size of the alphabet in the problem In the future we will assume that mask and set are the same Consider possible blocking pairs of some substring they are of two kinds If two characters of the pair are not equal and there is no question mark among them then this substring will never be a palindrome and we do not consider it If two characters of the pair are not equal and there is a question mark between them a character that is not a question mark must be in the query for us to consider this substring Thus from the characters in pairs of the second type we can create a set of necessary characters let s call it Next let us note the following fact does not depend on the query because depends only on and and on the number of pairs where both characters are question marks It follows that every substring of the form Or is simply ignored if it has a blocking pair of the first type These substrings will not be mentioned further in the tutorial when we say substrings we automatically mean the one described below Either is characterized by a pair of numbers Consider an arbitrary query how to calculate the answer for it We need to go through all substrings check whether and if so add to the answer The values of and for the substring can be found quickly by knowing the same values for the substring Thus by iterating over the parity of the palindrome length then its center and then its length itself we can quickly find these values for all the substrings Thus our solution has asymptotics so far which is obviously too slow But first let s figure out how to solve the problem if we have fixed Let s create an array of size let s call it For each substring let s add to value What does this give us We will then have in the sum of answers from all the substrings of which is equal to To find the answer in this case we have to sum all where Actually we have reached the asymptotics or But The problem of finding the sum of subset values is a well known one and solves our subproblem for In more detail https codeforces com blog entry 45223Well here we have reached the asymptotics of which is enough Let us return to the original problem First note that we don t have many different just So we create different arrays of size When processing the current substring we add to each of the arrays at position where the index of the current array Thus it is as if we times solved the problem for a fixed We need to take the sum over subsets of from the th array to get the answer The final asymptotic of the solution Applied optimizations in the author s solution Power optimization we will often need different values of numbers from to in powers from to so to remove from the asymptotic a precalculation of these values is used This optimization is necessary to guarantee a full score on the problem Addition optimization we do not need to add a subset to arrays whose index is less than This is since they will not affect the answer in any way Since the sets from which the answer will be taken in this array have fewer elements than they cannot by definition be supersets This optimization is unlikely to have much effect on runtime It is written here for a clearer understanding of the author s solution Modulo optimization The take modulo operation is slower than other operations so it is worth avoiding Here we often use the sum modulo of two numbers that do not exceed so we will replace it by using instead of 
https://codeforces.com//contest/482/problem/C,15990,C,482C,482,C. Game with Strings,You play the game with your friend The description of this game is listed below Your friend creates distinct strings of the same length and tells you all the strings Then he randomly chooses one of them He chooses strings equiprobably i e the probability of choosing each of the strings equals You want to guess which string was chosen by your friend In order to guess what string your friend has chosen you are allowed to ask him questions Each question has the following form What character stands on position in the string you have chosen A string is considered guessed when the answers to the given questions uniquely identify the string After the string is guessed you stop asking questions You do not have a particular strategy so as each question you equiprobably ask about a position that hasn t been yet mentioned Your task is to determine the expected number of questions needed to guess the string chosen by your friend ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int BITS = 17;\nconst int MAX = (1 << BITS) - 1;\n\nint kb[1 << BITS];\n\nconst int N = (1 << 21) + 10;\n\nlong long bad[N];\ndouble f[N];\nchar word[777][777];\n\nint main() {\n  int cnt;\n  scanf(""%d"", &cnt);\n  for (int i = 0; i < cnt; i++) {\n    scanf(""%s"", word[i]);\n  }\n  int n = strlen(word[0]);\n  for (int t = 0; t < (1 << n); t++) {\n    bad[t] = 0;\n  }\n  for (int i = 0; i < cnt; i++) {\n    for (int j = i + 1; j < cnt; j++) {\n      int diff = 0;\n      for (int k = 0; k < n; k++) {\n        if (word[i][k] == word[j][k]) {\n          diff |= (1 << k);\n        }\n      }\n      bad[diff] |= (1LL << i);\n      bad[diff] |= (1LL << j);\n    }\n  }\n  kb[0] = 0;\n  for (int i = 1; i < (1 << BITS); i++) {\n    kb[i] = kb[i & (i - 1)] + 1;\n  }\n  for (int t = (1 << n) - 1; t >= 0; t--) {\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        bad[t ^ (1 << i)] |= bad[t];\n      }\n    }\n    int p = 0;\n    f[t] = 0.0;\n    for (int i = 0; i < n; i++) {\n      if (!(t & (1 << i))) {\n        f[t] += f[t ^ (1 << i)];\n        p++;\n      }\n    }\n    if (p > 0) {\n      f[t] /= p;\n    }\n    f[t] += (kb[bad[t] & MAX] + kb[(bad[t] >> BITS) & MAX] + kb[(bad[t] >> (2 * BITS))]) * 1.0 / cnt;\n  }\n  printf(""%.17lf\\n"", f[0]);\n  return 0;\n}\n']",,,"['bitmasks', 'dp', 'probabilities']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\C. Game with Strings.json,https://codeforces.com//blog/entry/14417,Let s handle all string pairs and calculate the mask which will have 1 bits only in positions in which that strings have the same characters In other words we could not distinguish these strings using positions with submask of mask then we must add in 1 bits in positions This way in we store mask of strings which we could not distinguish using only positions given in mask Using information described above we can easily calculate this dynamics Now when we have array calculated it is not hard to calculate the answer Let s handle some mask Now we should try to make one more question in position which is equal to adding one more 1 bit in in position After that we may guess some strings they are 1 bits in mask s d mask d mask 1 pos Then you have to calculate number of bits in quickly and update the answer Jury s solution 8394918 
https://codeforces.com//contest/1844/problem/G,2009578,G,1844G,1844,G. Tree Weights,You are given a tree with n nodes labelled 1 2 dots n The i th edge connects nodes u i and v i and has an unknown positive integer weight w i To help you figure out these weights you are also given the distance d i between the nodes i and i 1 for all 1 le i le n 1 the sum of the weights of the edges on the simple path between the nodes i and i 1 in the tree Find the weight of each edge If there are multiple solutions print any of them If there are no weights w i consistent with the information print a single integer 1 ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\ninline void read(i64 &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,lc[100005],px[100005],py[100005];\ni64 d[100005],ans[100005],a[100005],c[100005];\nvector<int> bi[100005];\nvector<int> bi2[100005];\nvoid dfs0(int x,int fa)\n{\n\tff(bi2[x],it)if(*it!=fa){\n\t\tint y=px[*it]^py[*it]^x;dfs0(y,*it);\n\t\tans[*it]=d[y]-d[x];\n\t}\n}\nnamespace slpf\n{\n\tint fa[100005],sz[100005],tp[100005],son[100005],dfn[100005],ti,mp[100005],dep[100005];\n\tvoid dfs1(int x,int fa){son[x]=0;slpf::fa[x]=fa;sz[x]=1;ff(bi[x],it)if(*it!=fa){dep[*it]=dep[x]+1;dfs1(*it,x);sz[x]+=sz[*it];if(!son[x]||sz[son[x]]<sz[*it]){son[x]=*it;}}}\n\tvoid dfs2(int x,int t){mp[dfn[x]=++ti]=x;tp[x]=t;if(son[x])dfs2(son[x],t);ff(bi[x],it)if(*it!=fa[x]&&*it!=son[x]){dfs2(*it,*it);} }\n\tint lca(int x,int y){while(tp[x]!=tp[y]){if(dep[tp[x]]<dep[tp[y]])swap(x,y);x=fa[tp[x]];}return mp[min(dfn[x],dfn[y])];}\n};\nvoid solve()\n{\n\tread(n);fz1(i,n-1){int x,y;read(x);read(y);bi[x].push_back(y);bi[y].push_back(x);px[i]=x;py[i]=y;bi2[x].push_back(i);bi2[y].push_back(i);}\n\tslpf::dfs1(1,0);slpf::dfs2(1,1);fz1(i,n-1)read(a[i]),lc[i]=slpf::lca(i,i+1);\n\tfz0k(i,62){\n\t\ti64 lst=0;\n\t\tfz(j,2,n){\n\t\t\ti64 t=a[j-1]-(d[j-1]+d[j]-d[lc[j-1]]*2);\n\t\t\tif(t<0||(t&((1ll<<i)-1))){puts(""-1"");return;}\n\t\t\tt>>=i;\n\t\t\tlst^=(t&1);\n\t\t\tc[j]=(lst<<i);\n\t\t}\n\t\tfz(j,2,n)d[j]+=c[j];\n\t}\n\tfz1(i,n-1)if(d[i]+d[i+1]-2*d[lc[i]]!=a[i]){\n\t\tputs(""-1"");return;\n\t}\n\tdfs0(1,0);\n\tfz1(i,n-1)if(ans[i]<=0){puts(""-1"");return;}\n\tfz1(i,n-1)printf(""%lld\\n"",ans[i]);\n}\nint main()\n{\n\tint t;t=1;//read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']",,,"['bitmasks', 'constructive algorithms', 'data structures', 'dfs and similar', 'implementation', 'math', 'matrices', 'number theory', 'trees']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Tree Weights.json,https://codeforces.com//blog/entry/118128,Let be the sum of the weights of the edges on the path from node to node We know that and for all This is a system of linear equations in variables As should be integers let s first solve this system modulo The term disappears so we just have Starting from this uniquely determines then and so on Now that we know write where is the first bit of We can rewrite our system of equations as which has the same form as the original system Thus we can repeat this process to find giving then and so on Note that each bit of is uniquely determined If a solution exists it satisfies for all so it suffices to repeat this process until we have found the first bits of Finally we check that these bits correspond to a valid solution where all the original weights are positive The time complexity is if the are precomputed Remark This idea is related to the method of Hensel Lifting 
https://codeforces.com//contest/1569/problem/D,1103182,D,1569D,1569,D. Inconvenient Pairs,There is a city that can be represented as a square grid with corner points in 0 0 and 10 6 10 6 The city has n vertical and m horizontal streets that goes across the whole city i e the i th vertical streets goes from x i 0 to x i 10 6 and the j th horizontal street goes from 0 y j to 10 6 y j All streets are bidirectional Borders of the city are streets as well There are k persons staying the p th person at point x p y p so either x p equal to some x i or y p equal to some y j or both Let s say that a pair of persons form an if the shortest path from one person to another going only by streets is than the Manhattan distance between them Calculate the number of inconvenient pairs of persons pairs x y and y x are the same pair Let s recall that Manhattan distance between points x 1 y 1 and x 2 y 2 is x 1 x 2 y 1 y 2 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\n\nvoid solve() {\n    int N, M, K; cin >> N >> M >> K;\n    set<int> st[2];\n    F0R(i, N) {\n        int X; cin >> X; st[0].ins(X);\n    }\n    F0R(i, M) {\n        int X; cin >> X; st[1].ins(X);\n    }\n\n    map<int, int> cnt[2];\n    map<pi, int> cnt2[2];\n    st[0].ins(-1); st[1].ins(-1);\n    F0R(i, K) {\n        int X, Y; cin >> X >> Y;\n        if (!st[0].count(X)) {\n            auto it = --(st[0].lb(X));\n            cnt[0][*it]++;\n            cnt2[0][{*it, Y}]++;\n        }\n        if (!st[1].count(Y)) {\n            auto it = --(st[1].lb(Y));\n            cnt[1][*it]++;\n            cnt2[1][{*it, X}]++;\n        }\n    }\n    ll ans = 0;\n    F0R(i, 2) {\n        trav(a, cnt[i]) {\n            ll cur = a.s; ans += cur * (cur - 1) / 2;\n            //dbg(i, a.f, a.s);\n        }\n        trav(a, cnt2[i]) {\n            ll cur = a.s; ans -= cur * (cur - 1) / 2;\n        }\n    }\n    cout << ans << nl;\n\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']",,,"['binary search', 'data structures', 'implementation', 'sortings', 'two pointers']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\D. Inconvenient Pairs.json,https://codeforces.com//blog/entry/94721,Firstly let s look at some point Let s find closest to it vertical and horizontal lines We will name the closest vertical lines from left and right as and and and as closest horizontal lines So and we can also note that either or Now let s note that if for some other point either or then to reach from we must go reach either or or or so the shortest distance will be strictly greater than the Manhattan distance If neither nor then we can show that it s always possible to find the shortest path equal to the Manhattan distance As a result for each point we should find the number of points such that and or The exception here is when lies on the same line as so we should not count such points We can note that since either or there is no such point that and simultaneously so we can calculate the pairs by and coordinates independently Let s focus on coordinates to calculate for coordinates we can just swap all coordinates Let s sort all points by coordinate To get rid of the case when points and lies on the same vertical street we can group them by coordinate and process by group since we sorted by groups are just segments There are no problems with the case when points lie on the same horizontal street since then and there are no other with If we store for each horizontal line the number of point inside the interval then when we need for point calculate the number of points with and we can just ask for value assigned to because and are consecutive elements in the array So we go through each group two times first collecting answer then updating values in appropriate s Note that we can calculate and with binary search using built in functions The resulting complexity is 
https://codeforces.com//contest/1789/problem/E,1798641,E,1789E,1789,E. Serval and Music Game,Serval loves playing music games He meets a problem when playing music games and he leaves it for you to solve You are given n positive integers s 1 s 2 ldots s n f x is defined as the number of i 1 leq i leq n that exist non negative integers p i q i such that s i p i left lfloor s n over x right rfloor q i left lceil s n over x right rceilFind out sum x 1 s n x cdot f x modulo 998 244 353 As a reminder lfloor x rfloor denotes the maximal integer that is no greater than x and lceil x rceil denotes the minimal integer that is no less than x ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int md = 998244353;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> s(n);\n    for (auto &x: s) cin >> x;\n    vector<int> pref(s[n - 1] + 1);\n    for (auto &x: s) pref[x]++;\n    for (int i = 1; i <= s[n - 1]; ++i) pref[i] += pref[i - 1];\n    ll ans = 0;\n    array<int, 3> current = {-1, -1, 0};\n    for (int x = 1; x <= s[n - 1]; ++x) {\n        int y = s[n - 1] / x;\n        int c = min(1, s[n - 1] % x);\n        if (current[0] != y || current[1] != c) {\n            int result = 0;\n            for (int l = y, r = y + c; l <= s[n - 1]; l += y, r += y + c) {\n                r = min(r, min(s[n - 1], l + y - 1));\n                result += pref[r] - pref[l - 1];\n            }\n            current = {y, c, result};\n        }\n        ans += 1ll * current[2] * x;\n        ans %= md;\n    }\n    cout << ans << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}']",,,"['brute force', 'dp', 'implementation', 'math', 'number theory']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Serval and Music Game.json,https://codeforces.com//blog/entry/113246,Consider the following two cases Case 1 is not a factor of In this case we have Let It can be shown that there are at most different values of The constraint of can be written in the following form For a certain such and do not exist if and only if To prove it we show the contradiction that and we can give a construction of and when that and By observation these are in one of the following intervals We can count the number of these by pre calculating the prefix sums to calculate This case can be solved in time and we will show this fact When there are intervals that need to be considered for a certain Since this part can be solved in time When notice that there are at most intervals that need to be considered for a certain Recall that there are at most different values of in this part so it can be solved in time Case 2 is a factor of In this case we have Let The constraint of becomes To calculate we only need to count the number of multiples of To do this we can first calculate for all in time It is obvious that is a factor of For a certain we can enumerate all the factors of find out the multiples of among them and sum up the times that they occurred in Recall that has at most factors so this takes time This case can be solved in time in total Time complexity solutions can pass all the tests where denotes the sum of all the factors of A well implemented solutions may pass the tests too Bonus Solve this problem in time 
https://codeforces.com//contest/1181/problem/A,359260,A,1181A,1181,A. Chunga-Changa,Soon after the Chunga Changa island was discovered it started to acquire some forms of civilization and even market economy A new currency arose colloquially called chizhik One has to pay in chizhiks to buy a coconut now Sasha and Masha are about to buy some coconuts which are sold at price z chizhiks per coconut Sasha has x chizhiks Masha has y chizhiks Each girl will buy as many coconuts as she can using only her money This way each girl will buy an integer non negative number of coconuts The girls discussed their plans and found that the total number of coconuts they buy can increase or decrease if one of them gives several chizhiks to the other girl The chizhiks can t be split in parts so the girls can only exchange with integer number of chizhiks Consider the following example Suppose Sasha has 5 chizhiks Masha has 4 chizhiks and the price for one coconut be 3 chizhiks If the girls don t exchange with chizhiks they will buy 1 1 2 coconuts However if for example Masha gives Sasha one chizhik then Sasha will have 6 chizhiks Masha will have 3 chizhiks and the girls will buy 2 1 3 coconuts It is not that easy to live on the island now so Sasha and Mash want to exchange with chizhiks in such a way that they will buy the maximum possible number of coconuts Nobody wants to have a debt so among all possible ways to buy the maximum possible number of coconuts find such a way that minimizes the number of chizhiks one girl gives to the other it is not important who will be the person giving the chizhiks ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tll x, y, z;\n\tcin >> x >> y >> z;\n\tcout << (x+y)/z << "" "";\n\tif(x/z+y/z==(x+y)/z)\n\t\tcout << 0;\n\telse\n\t\tcout << min((x/z+1)*z-x, (y/z+1)*z-y);\n}']",,,"['greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Chunga-Changa.json,https://codeforces.com//blog/entry/67727,It s easy to calculate how much coconuts we will buy suppose that all money transferred to a single person this way the number of bought coconuts would be clearly maximal If then the answer is The remaining case is a bit harder Let s notice that there is no need to transfer chizhiks since the one transferring money could have used chizhiks to buy one more coconut herself Also it s optimal to transfer coins such that the remainder modulo of the receiving part will turn to be exactly zero we could have simply transfer less for the same effect So the answer is 
https://codeforces.com//contest/918/problem/A,151492,A,918A,918,A. Eleven,Eleven wants to choose a new name for herself As a bunch of geeks her friends suggested an algorithm to choose a name for her Eleven wants her name to have exactly characters Her friend suggested that her name should only consist of uppercase and lowercase letters More precisely they suggested that the th letter of her name should be uppercase if is a member of Fibonacci sequence and lowercase otherwise The letters in the name are numbered from to Fibonacci sequence is the sequence where As her friends are too young to know what Fibonacci sequence is they asked you to help Eleven determine her new name ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nint f[200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\tcin >> n;\n\tf[1] = f[2] = 1;\n\tfor (int i = 3; i < 20; i++)\n\t\tf[i] = f[i-1] + f[i-2];\n\tfor (int i = 1; i <= n; i++){\n\t\tbool fl = 0;\n\t\tfor (int j = 1; j < 20; j++)\n\t\t\tif (i == f[j])\n\t\t\t\tfl = 1;\n\t\tif (fl)\n\t\t\tcout << ""O"";\n\t\telse\n\t\t\tcout << ""o"";\n\t}\n\tcout << ""\\n"";\n\treturn 0;\n}\n']",,,"['brute force', 'implementation']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Eleven.json,https://codeforces.com/blog/entry/57420,Calculate the first Fibonacci sequence elements where is the greatest integer such that Let be a string consisting of lowercase o letters Then for each perform O The answer is Pseudo code s for i 0 to n 1 s i o x y 1while y n s y 1 O tmp y y y x x tmpprint s Total time complexity 
https://codeforces.com//contest/806/problem/E,105599,E,806E,806,E. Blog Post Rating,It s well known that blog posts are an important part of Codeforces platform Every blog post has a global characteristic changing over time its A newly created blog post s community rating is 0 Codeforces users may visit the blog post page and rate it changing its community rating by 1 or 1 Consider the following model of Codeforces users behavior The th user has his own denoted by an integer When a user visits a blog post page he compares his estimated blog post rating to its community rating If his estimated rating is higher he rates the blog post with 1 thus the blog post s community rating increases by 1 If his estimated rating is lower he rates the blog post with 1 decreasing its community rating by 1 If the estimated rating and the community rating are equal user doesn t rate the blog post at all in this case we ll say that user rates the blog post for 0 In any case after this procedure user closes the blog post page and never opens it again Consider a newly created blog post with the initial community rating of 0 For each of Codeforces users numbered from 1 to his estimated blog post rating is known For each from 1 to inclusive the following question is asked Let users with indices from 1 to visit the blog post page rate the blog post and close the page Each user opens the blog post only after the previous user closes it What could be the maximum possible community rating of the blog post after these visits ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\n#define tm f__k\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nstruct FastSet {\n    int N, lg;\n    VV<ull> seg;\n    FastSet(int N) : N(N) {\n        while (N > 1) {\n            seg.push_back(V<ull>((N+63)/64));\n            N = (N+63)/64;\n        }\n        lg = seg.size();\n    }\n    bool test(int x) const {\n        int D = x/64, R = x%64;\n        return (seg[0][D] & (1ULL<<R)) != 0;\n    }\n    void set(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            seg[i][D] |= (1ULL<<R);\n            x /= 64;\n        }\n    }\n    void clear(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            seg[i][D] &= ~(1ULL<<R);\n            if (i && seg[i-1][x] != 0) {\n                seg[i][D] |= (1ULL<<R);\n            }\n            x /= 64;\n        }\n    }\n    // x以上最小の要素\n    int next(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            if (D == seg[i].size()) break;\n            ull B = seg[i][D]>>R;\n            if (!B) {\n                x = x/64+1;\n                continue;\n            }\n            //find\n            x += bsf(B);\n            for (int j = i-1; j >= 0; j--) {\n                x *= 64;\n                int D = x/64;\n                x += bsf(seg[j][D]);\n            }\n            return x;\n        }\n        return N;\n    }\n    // x以下最大の要素\n    int back(int x) {\n        for (int i = 0; i < lg; i++) {\n            if (x == -1) break;\n            int D = x/64, R = x%64;\n            ull B = seg[i][D]<<(63-R);\n            if (!B) {\n                x = x/64-1;\n                continue;\n            }\n            //find\n            x += bsr(B)-63;\n            for (int j = i-1; j >= 0; j--) {\n                x *= 64;\n                int D = x/64;\n                x += bsr(seg[j][D]);\n            }\n            return x;\n        }\n        return -1;\n    }    \n};\n\ntemplate<class T>\nstruct Fenwick {\n    int N, lg;\n    V<T> seg;\n    Fenwick(int N) : N(N) {\n        seg.resize(N+1);\n        lg = bsr(uint(N));\n        fill(begin(seg), end(seg), T(0));\n    }\n    /// i番目の要素にxを追加する\n    void add(int i, T x) {\n        i++;\n        while (i <= N) {\n            seg[i] += x;\n            i += i & -i;\n        }\n    }\n    /// [0, i)のsum\n    T sum(int i) {\n        T s{0};\n        while (i > 0) {\n            s += seg[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    /// [a, b)のsum\n    T sum(int a, int b) {\n        return sum(b) - sum(a);\n    }\n    /// sum[0, idx) >= xなる最小のidx\n    int sum_lower_bound(T x) {\n        if (x <= 0) return 0;\n        int res = 0;\n        for (int len = 1<<lg; len >= 1; len /= 2) {\n            if (res + len <= N && seg[res + len] < x) {\n                x -= seg[res+len];\n                res += len;\n            }\n        }\n        return res + 1;\n    }\n};\ntemplate<class N>\nstruct SegTree {\n    int lg, sz;\n    vector<N> n;\n    SegTree() {}\n    SegTree(int sz) {\n        assert(sz >= 1);\n        lg = bsr(uint(2*sz-1));\n        sz = 1<<lg;\n        this->sz = sz;\n        n = vector<N>(2*sz);\n        for (int i = 2*sz-1; i >= sz; i--) {\n            n[i] = N();\n        }\n        for (int i = sz-1; i >= 1; i--) {\n            n[i] = N(n[2*i], n[2*i+1]);\n        }\n    }\n    void all_update() {\n        for (int i = 1; i <= sz-1; i++) {\n            n[i].push();\n        }\n        for (int i = sz-1; i >= 1; i--) {\n            n[i].update(n[2*i], n[2*i+1]);\n        }\n    }\n    template<class Q>\n    Q single(int idx, Q q) {\n        if (idx < 0 || sz <= idx) return q;\n        idx += sz;\n        for (int i = lg; i >= 1; i--) {\n            int k = idx>>i;\n            n[k].push(n[2*k], n[2*k+1]);\n        }\n        q += n[idx];\n        if (q.update()) {\n            for (int i = 1; i <= lg; i++) {\n                int k = idx>>i;\n                n[k].update(n[2*k], n[2*k+1]);\n            }\n        }\n        return q;\n    }\n    template<class Q>\n    void query(int a, int b, Q &q, int k, int sz) {\n        if (a <= 0 && sz <= b) {\n            q += n[k];\n            return;\n        }\n        n[k].push(n[2*k], n[2*k+1]);\n        if (a < sz/2) query(a, b, q, 2*k, sz/2);\n        if (sz/2 < b) query(a-sz/2, b-sz/2, q, 2*k+1, sz/2);\n        if (q.update()) n[k].update(n[2*k], n[2*k+1]);\n    }\n    template<class Q>\n    Q query(int a, int b, Q q) {\n        if (a < sz && 0 < b) query(a, b, q, 1, sz);\n        return q;\n    }\n    struct NodeQuery {\n        N n;\n        static constexpr bool update() { return false; }\n        void operator+=(N &r) { N nn; nn.update(n, r); n = nn; }\n    };\n};\n\nusing P = pair<int, int>;\nstruct Node {\n    P mi;\n    int lz;\n    void init() {\n        mi = P(TEN(9), -1);\n        lz = 0;\n    }\n    Node() { init(); } // leaf\n    Node(Node &l, Node &r) { init(); update(l, r); }\n    void update(const Node &l, const Node &r) {\n        mi = min(l.mi, r.mi);\n    }\n    void push(Node &l, Node &r) {\n        if (lz) {\n            l.lzdata(lz);\n            r.lzdata(lz);\n            lz = 0;\n        }\n    }\n    void lzdata(ll x) {\n        mi.first += x;\n        lz += x;\n    }\n    // query\n    struct MinQuery {\n        P mi = P(TEN(9), -1);\n        static constexpr bool update() { return false; }\n        void operator+=(Node &r) { mi = min(mi, r.mi); }\n    };\n    struct AddQuery {\n        int x;\n        static constexpr bool update() { return true; }\n        void operator+=(Node &n) { n.lzdata(x); }\n    };\n    struct SetQuery {\n        P x;\n        static constexpr bool update() { return true; }\n        void operator+=(Node &n) { n.mi = x; }\n    };    \n};\n\n\nconst int MN = 500500;\nint n;\nint base[MN];\nint idx[MN];\n\nvoid main2() {\n/*    for (int i = 0; i < n; i++) {\n        cout << base[i] << "" "";\n    }\n    cout << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << idx[i] << "" "";\n    }\n    cout << endl;*/\n    Fenwick<int> fw(n);\n//    FastSet mid(n);\nset<int> mid;\n    SegTree<Node> plus(n), minus(n);\n    for (int ph = 0; ph < n; ph++) {\n        int i = idx[ph];\n        int h = fw.sum(0, i);\n        if (h == base[i]) {\n//            mid.set(i);\nmid.insert(i);\n        } else {\n            bool isAdd = h < base[i];\n            int dif = abs(base[i] - h);\n//            int lm = mid.next(i);\nauto it = mid.lower_bound(i); int lm = (it == mid.end() ? n : *it);\n            P buf;\n            if (isAdd) {\n                //add\n                buf = plus.query(i, n, Node::MinQuery{}).mi;\n            } else {\n                //dec\n                buf = minus.query(i, n, Node::MinQuery{}).mi;\n            }\n            int lz = (buf.first == 0) ? buf.second : n;\n//            cout << lm << "" "" << lz << endl;\n            int L = i, R = min(lm, lz);\n            if (R < n) {\n                if (lm < lz) {\n                    //mid\n//                    mid.clear(lm);\nmid.erase(lm);\n                    if (isAdd) {\n                        minus.single(R, Node::SetQuery{P(0, R)});\n                        fw.add(R, -1);\n                    } else {\n                        plus.single(R, Node::SetQuery{P(0, R)});\n                        fw.add(R, 1);\n                    }\n                } else {\n                    //zero\n//                    mid.set(R);\nmid.insert(R);\n                    if (isAdd) {\n                        plus.single(R, Node::SetQuery{P(TEN(9), -1)});\n                        fw.add(R, -1);\n                    } else {\n                        minus.single(R, Node::SetQuery{P(TEN(9), -1)});\n                        fw.add(R, 1);\n                    }\n                }\n            }\n\n            if (isAdd) {\n                plus.single(i, Node::SetQuery{P(dif, i)});\n                plus.query(L, R, Node::AddQuery{-1});\n                minus.query(L, R, Node::AddQuery{1});\n                fw.add(i, 1);\n            } else {\n                plus.query(L, R, Node::AddQuery{1});\n                minus.single(i, Node::SetQuery{P(dif, i)});\n                minus.query(L, R, Node::AddQuery{-1});\n                fw.add(i, -1);\n            }\n        }\nprintf(""%d\\n"", fw.sum(0, n));\n    }\n}\n\nint main() {\nscanf(""%d"", &n);\n    using P = pair<int, int>;\n    V<P> v(n);\n    for (int i = 0; i < n; i++) {\nscanf(""%d"", &(v[i].first));\n        v[i].second = i;\n    }\n    sort(begin(v), end(v));\n    for (int i = 0; i < n; i++) {\n        base[i] = v[i].first;\n        idx[v[i].second] = i;\n    }\n    main2();\n    return 0;\n}']",,,['data structures'],3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Blog Post Rating.json,https://codeforces.com//blog/entry/51883,There are several different solutions to this problem I ll describe one of them First we have to determine the optimal rating order for a set of users Using an exchange argument it can be shown that to maximize the final community rating the users should rate the blog post in non decreasing order of their estimated ratings Indeed consider an optimal rating order consider two users with estimated ratings and next to each other in this order and assume that Let s denote the community rating before these two users rate the blog post by Then here is what happens if these two users rate this blog post in the current and the reverse order We can see that the order is never better than That means we can swap these two users in the order and the result won t become worse We can continue swapping all such pairs of users until we obtain a non decreasing order Now suppose users with estimated ratings rate a newly created blog post For some the first users will rate it with 1 It can be seen that the following property will hold for the rest of the users their estimated ratings will not be lower than the community rating of the blog post at the moment of viewing the page Thus all remaining users will rate the blog post with 1 or 0 Let s sort all users according to their estimated rating and maintain a segment tree which contains for each user in this order the difference between his estimated rating and the community rating after his view Initially all users are inactive and it looks like they rate the blog post with 0 Then we ll make users active one by one in order of input We ll also maintain three sets of active users those who rate the blog post with 1 0 and 1 respectively To make a user active first we find how he rates the blog post Then there are three cases If he rates the blog post for 0 there is no need to do anything else If he rates the blog post for 1 the rightmost 1 might change to 0 If it does we are done Otherwise the community rating before users in the 1 and 0 group has decreased by 1 Thus the leftmost 0 if it exists changes to 1 and we re done If he rates the blog post for 1 then either there s a user to the right of him whose value in the segment tree becomes negative in which case the leftmost of these users now rates the blog post for 0 instead of 1 or there s no such user in which case nothing else changes All operations above can be performed using queries to our sets of users and segment tree For example when a user appears who rated the blog post with 1 we have to insert him into the 1 set and make a query to the segment tree to decrease the value by 1 in the range from this user to the last user The answer that is the maximum possible community rating after the first users is the size of the 1 set minus the size of the 1 set 
https://codeforces.com//contest/572/problem/B,33727,B,572B,572,B. Order Book,In this task you need to process a set of stock exchange orders and use them to create An is an instruction of some participant to buy or sell stocks on stock exchange The order number has price direction buy or sell and integer This means that the participant is ready to buy or sell stocks at price for one stock A value is also known as a of an order All orders with the same price and direction are merged into one order with price and direction The volume of such order is a sum of volumes of the initial orders An order book is a list of aggregated orders the first part of which contains sell orders sorted by price in descending order the second contains buy orders also sorted by price in descending order An order book of depth contains best aggregated orders for each direction A buy order is better if it has higher price and a sell order is better if it has lower price If there are less than aggregated orders for some direction then all of them will be in the final order book You are given stock exhange orders Your task is to print order book of depth for these orders ,"['#include <iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\n#include <queue>\npriority_queue<pii, vector<pii>, greater<pii> > sell;\npriority_queue<pii> buy;\nint n, s;\nchar bors;\npii sellbook[50];\npii buybook[50];\nint sellcount=-1;\nint buycount=-1;\nint main()\n{\n    cin >> n >> s;\n    int p, q;\n    for (int i=0; i<n; i++)\n        {\n            cin >> bors;\n            cin >> p >> q;\n            if (bors==\'B\') buy.push(pii (p, q));\n            else\n                sell.push(pii (p, q));\n        }\n    if (!sell.empty())\n    {\n        sellcount++;\n        sellbook[sellcount]=sell.top();\n        sell.pop();\n        while(!sell.empty())\n        {\n            if (sellbook[sellcount].first==sell.top().first)\n            {\n                sellbook[sellcount].second+=sell.top().second;\n                sell.pop();\n            }\n            else if (sellcount+1<s)\n            {\n                sellcount++;\n                sellbook[sellcount]=sell.top();\n                sell.pop();\n\n            }\n            else\n                break;\n        }\n    }\n    if (!buy.empty())\n    {\n        buycount++;\n        buybook[buycount]=buy.top();\n        buy.pop();\n        while(!buy.empty())\n        {\n            if (buybook[buycount].first==buy.top().first)\n            {\n                buybook[buycount].second+=buy.top().second;\n                buy.pop();\n            }\n            else if (buycount+1<s)\n            {\n                buycount++;\n                buybook[buycount]=buy.top();\n                buy.pop();\n\n            }\n            else\n                break;\n        }\n    }\n    for (int i=sellcount; i>=0; i--)\n    {\n        cout << ""S"" << "" "" << sellbook[i].first << "" "" << sellbook[i].second << endl;\n    }\n    for (int i=0; i<=buycount; i++)\n    {\n        cout << ""B"" << "" "" << buybook[i].first << "" "" << buybook[i].second << endl;\n    }\n}\n']",,,"['data structures', 'greedy', 'implementation', 'sortings']",1300,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Order Book.json,https://codeforces.com//blog/entry/19923,First of all the problem may be solved for buy orders and sell orders separately The easiest soultion is to use structure like std map or java lang TreeMap To aggregate orders we just add volume to the corresponding map element aggregated price volume After that we should extract lowest or largest element from map times or while it s not empty Complexity of this solution is It is also possible to solve the problem without data structres other than an array You should just maintain at most best orders in sorted order and when adding another order you insert it in appropriate place and move worse elements in linear time of Complexity of this solution is Problem authors and developers ArtDitel yarrr Solution code 12873385 
https://codeforces.com//contest/1893/problem/E,2312789,E,1893E,1893,E. Cacti Symphony,You are given an undirected connected graph in which any two distinct simple cycles common vertices Since the graph can be very large it is given to you in a compressed form for each edge you are also given a number d which indicates that there are d additional vertices on this edge You need to assign a weight to each vertex and each edge of the graph an integer from 1 to 3 An edge of the graph is called if the bitwise XOR of the weights of its adjacent vertices is 0 and the weight of that edge Similarly a vertex of the graph is called if the bitwise XOR of the weights of its adjacent edges is 0 and the weight of that vertex You need to determine how many ways there are to assign weights to the vertices and edges of the graph so that all vertices and edges are Since the answer can be quite large you need to calculate the remainder of the answer divided by 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n//KUPC 2020 C\n//XXII Opencup GP of Gomel E\n//非連結な場合はverifyされてない\n\n//多重辺なしの cactus を分解する\n//cs にサイクルに使われた辺の集合が入る\n//順番は，dfs 木を下る->後退辺で上がる，の順\n//cs のサイズが 2 のときはシンプルに辺があるだけ\n//連結性を仮定せず\ntemplate<class E>\nstruct cactus{\n\tconst vvc<E>&g;\n\tconst int n;\n\tvvc<E> cs;\n\tvi vis,par,u;\n\tvc<E> come;\n\tvc<bool> done;\n\tvoid dfs(int v,int p,E co){\n\t\tassert(vis[v]==0);\n\t\tvis[v]=1;\n\t\tpar[v]=p;\n\t\tcome[v]=co;\n\t\tE gopar;\n\t\tfor(auto e:g[v]){\n\t\t\tif(e==p){\n\t\t\t\tgopar=e;\n\t\t\t}else if(vis[e]==0){\n\t\t\t\tdfs(e,v,e);\n\t\t\t}else if(vis[e]==1){\n\t\t\t\tint x=v;\n\t\t\t\tvc<E> z{e};\n\t\t\t\twhile(x!=e){\n\t\t\t\t\tassert(!done[x]);\n\t\t\t\t\tdone[x]=true;\n\t\t\t\t\tz.pb(come[x]);\n\t\t\t\t\tx=par[x];\n\t\t\t\t}\n\t\t\t\treverse(all(z));\n\t\t\t\tcs.pb(z);\n\t\t\t}\n\t\t}\n\t\tif(p!=-1&&!done[v]){\n\t\t\tdone[v]=true;\n\t\t\tcs.pb({co,gopar});\n\t\t}\n\t\tvis[v]=2;\n\t}\n\tcactus(const vvc<E>&gg):g(gg),n(g.size()),vis(n),par(n),u(n),come(n),done(n){\n\t\trep(i,n)if(!vis[i])\n\t\t\tdfs(i,-1,E());\n\t}\n};\nstruct E{\n\tint to,dist;\n\toperator int()const{return to;}\n};\n\nbool dbg=false;\n\nconst int D=40000;\nmint transA[4][D+1][4];\nmint transB[4][D+1][4];\nvoid inittrans(){\n\trng(init,1,4){\n\t\ttransA[init][0][init]=1;\n\t\trep(i,D){\n\t\t\trng(j,1,4)rng(k,1,4)if(j!=k){\n\t\t\t\ttransA[init][i+1][k]+=transA[init][i][j];\n\t\t\t}\n\t\t}\n\t}\n\trng(init,1,4){\n\t\ttransB[init][0][init]=1;\n\t\trep(i,D){\n\t\t\trng(j,1,4)rng(k,1,4){\n\t\t\t\ttransB[init][i+1][k]+=transB[init][i][j]*transA[j][D][k];\n\t\t\t}\n\t\t}\n\t}\n}\n\nmint trans(int init,int d,int to){\n\tint u=d/D,v=d%D;\n\tmint res;\n\trng(k,1,4)res+=transB[init][u][k]*transA[k][v][to];\n\treturn res;\n}\n\nusing A=array<array<mint,4>,4>;\n\nA mg(const A&a,const A&b){\n\tA res{};\n\trng(x,1,4)rep(y,4)rep(z,4){\n\t\tres[x][y^z]+=a[x][y]*b[x][z];\n\t}\n\treturn res;\n}\n\nA up(const A&a,int d){\n\tA res;\n\trng(x,1,4)rep(y,4)rng(z,1,4)if(0!=(y^z)&&x!=(y^z)){\n\t\tif(z==x){\n\t\t\trng(w,1,4)rng(v,1,4)if(w!=v)\n\t\t\t\tres[v][w]+=a[x][y]*trans(z,d-1,w);\n\t\t}else{\n\t\t\trng(w,1,4)\n\t\t\t\tres[w][w]+=a[x][y]*trans(z,d-1,w);\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<E> g(n);\n\trep(i,m){\n\t\tint a,b,d;cin>>a>>b>>d;\n\t\ta--;b--;\n\t\td++;\n\t\tg[a].pb({b,d});\n\t\tg[b].pb({a,d});\n\t}\n\t\n\tcactus<E> cc(g);\n\t\n\t//int s=n+si(cc.cs);\n\t//vvc<int> t(s);\n\tvvc<int> t(n);\n\trep(i,si(cc.cs)){\n\t\t/*rep(j,si(cc.cs[i])){\n\t\t\tint v=cc.cs[i][j];\n\t\t\tif(j+1<si(cc.cs[i])-1)\n\t\t\t\tt[n+i].pb(v);\n\t\t\telse\n\t\t\t\tt[v].pb(n+i);\n\t\t}*/\n\t\tt[cc.cs[i].back()].pb(i);\n\t}\n\t\n\tauto dfs=[&](auto self,int v)->A{\n\t\tdmp(v);\n\t\tassert(v<n);\n\t\tA res;\n\t\trng(x,1,4)res[x][0]=1;\n\t\tfor(int c:t[v]){\n\t\t\tint len=si(cc.cs[c])-1;\n\t\t\tvc<A> buf(len);\n\t\t\trep(i,len)buf[i]=self(self,cc.cs[c][i]);\n\t\t\tif(len==1){\n\t\t\t\t//edge\n\t\t\t\tres=mg(res,up(buf[0],cc.cs[c][0].dist));\n\t\t\t}else if(len>=2){\n\t\t\t\tA sum{};\n\t\t\t\tint d=cc.cs[c].back().dist;\n\t\t\t\t{\n\t\t\t\t\trng(w,1,4){\n\t\t\t\t\t\tA cur{};\n\t\t\t\t\t\tper(step,len){\n\t\t\t\t\t\t\t//dmp(step);\n\t\t\t\t\t\t\tif(step==len-1){\n\t\t\t\t\t\t\t\trng(x,1,4)if(x==w)rep(y,4)cur[x][y^w]+=buf[len-1][x][y];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcur=mg(cur,buf[step]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//dmp2(cur);\n\t\t\t\t\t\t\tcur=up(cur,cc.cs[c][step].dist);\n\t\t\t\t\t\t\t//dmp2(cur);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(u,1,4)rng(x,1,4)if(u!=x)rep(y,4)\n\t\t\t\t\t\t\tsum[x][y^u]+=cur[x][y]*trans(w,d-1,u);\n\t\t\t\t\t\tdmp(sum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\trng(w,1,4){\n\t\t\t\t\t\tA cur{};\n\t\t\t\t\t\tper(step,len){\n\t\t\t\t\t\t\tif(step==len-1){\n\t\t\t\t\t\t\t\trng(x,1,4)if(x!=w)rep(y,4)cur[x][y^w]+=buf[len-1][x][y];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcur=mg(cur,buf[step]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur=up(cur,cc.cs[c][step].dist);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(u,1,4)rng(x,1,4)if(u==x)rep(y,4)\n\t\t\t\t\t\t\tsum[x][y^u]+=cur[x][y]*trans(w,d-1,u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdmp(sum);\n\t\t\t\tres=mg(res,sum);\n\t\t\t}else{\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t};\n\tA ans=dfs(dfs,0);\n\t\n\tmint res=0;\n\trng(x,1,4)rng(y,1,4)if(x!=y)res+=ans[x][y];\n\tprint(res);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinittrans();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']",,,"['combinatorics', 'dfs and similar', 'dp', 'graphs']",3500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\E. Cacti Symphony.json,https://codeforces.com//blog/entry/122074,First observation for each edge the vertices connected by it have different weights otherwise the XOR of the weights of the adjacent vertices of this edge is equal to Second observation for each edge one of its adjacent vertices has a weight equal to the weight of the edge since From these two observations it follows that each edge has the same weight as one of the vertices it is connected to Let s say that a vertex all the adjacent edges with the same weight Then each edge is controlled by exactly one vertex Third observation if a vertex has an even degree then the number of edges controlled by it must be odd and this is a sufficient condition for the vertex to be good Fourth observation if a vertex has an odd degree then the number of edges controlled by it must be even and this is a sufficient condition for the vertex to be good Therefore in order for all vertices to be good it is necessary to choose who controls each edge in such a way that the parity of the vertex degree and the parity of the number of edges controlled by it are different And in order for all edges to be good it is necessary to assign weights from to to the vertices in such a way that no two adjacent vertices have the same weight The weight of each edge will then be equal to the weight of the vertex it is controlled by Now the problem is divided into two independent parts finding the number of ways to assign weights to the vertices and finding the number of ways to orient the edges The answer to the original problem will be the product of the answers to these two parts How many ways are there to color the vertices with colors such that two adjacent vertices are colored differently How many ways are there to orient the edges such that a vertex with an even degree has an odd number of outgoing edges and a vertex with an odd degree has an even number of outgoing edges Solution to problem 1 note that if there is a bridge in the graph and it divides the graph into graphs and then the answer for is the product of the answers for and multiplied by Then we can identify all the bridges and since the graph is a vertex cactus after removing the bridges the graph will be divided into cycle components For a cycle of length the number of ways to color the vertices can be calculated using simple dynamic programming To prove this dynamic programming consider any two vertices that are one apart in a cycle of length If they have the same color then the vertex between them has possible colors and the rest have possibilities If they have different colors then there are possibilities Knowing the transition formula we can notice that This formula can be trivially proved by induction Solution to problem 2 we will solve the same problem but requiring that each vertex has an odd number of outgoing edges if we invert all the edges in such a graph we will get what is required If and have different parity then the answer is since the sum of odd numbers which are the degrees of the vertices must be equal to Otherwise the answer is At any moment we can remove any leaf as it does not solve anything We will remove the leaves as long as they exist After this one of the cycles in the graph will be a leaf connected only to one other cycle For all vertices of this cycle the necessary parities of the degrees are known Choose any edge of the cycle and orient it there are ways to orient it both will work After that all other edges in the cycle are oriented uniquely After that the bridge between this cycle and the other one is also uniquely oriented Now we have one less cycle and we also know all the necessary parities of the vertices the parity changes for the vertex where the bridge came in In this way we can gradually reduce the number of cycles With each removal of a cycle the answer is multiplied by since there are ways to orient the edge in the cycle In the end we get ways The final answer to the problem if and have same parity is where are the sizes of cycles cycle can be a single vertice if it did not lie on any other cycle and in this case 
https://codeforces.com//contest/1343/problem/E,599892,E,1343E,1343,E. Weights Distributing,You are given an undirected unweighted graph consisting of n vertices and m edges which represents the map of Bertown and the array of prices p of length m It is guaranteed that there is a path between each pair of vertices districts Mike has planned a trip from the vertex district a to the vertex district b and then from the vertex district b to the vertex district c He can visit the same district twice or more But there is one issue authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road The list of prices that will be used p is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road You are a good friend of Mike and suddenly a mayor of Bertown and want to help him to make his trip as cheap as possible So your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the possible You have to answer t independent test cases ,"['#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=200000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<\'0\') || (ch>\'9\')) {if (ch==\'-\') f=-1;ch=getchar();}\n    while ((ch>=\'0\') && (ch<=\'9\')) {x=x*10+(ch-\'0\');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nstruct node{int to,nxt;}sq[N<<1];\nint all=0,head[N];\nint n,m,a,b,c,dis[3][N];\nbool vis[N];\nll w[N];\nstruct hnode{int u,dis;};\nbool operator <(hnode p,hnode q) {return p.dis>q.dis;}\npriority_queue<hnode> q;\n\nvoid addedge(int u,int v)\n{\n\t//cout << ""edge "" << u << "" "" << v << endl;\n\tall++;sq[all].to=v;sq[all].nxt=head[u];head[u]=all;\n}\n\nvoid dij(int st,int *dis)\n{\n\t//cout << ""start "" << st << endl;\n\trep(i,1,n) dis[i]=maxd,vis[i]=0;\n\tq.push((hnode){st,0});dis[st]=0;\n\t//rep(i,1,n) cout << dis[i] <<"" "";cout << endl;\n\twhile (!q.empty())\n\t{\n\t\tint u=q.top().u;q.pop();\n\t\tif (vis[u]) continue;vis[u]=1;\n\t\t//cout << ""now "" << u << endl;\n\t\tgo(u,i)\n\t\t{\n\t\t\t//cout << ""towards "" << v << endl;\n\t\t\tif (dis[v]>dis[u]+1)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tif (!vis[v]) q.push((hnode){v,dis[v]});\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i,1,n) cout << dis[i] << "" "";cout << endl;\n}\n\nll calc(int l,int r) \n{\n\tif (r>m) return 1e18;\n\telse return w[r]-w[l-1];\n}\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();m=read();a=read();b=read();c=read();\n\t\trep(i,1,m) w[i]=read();\n\t\tsort(w+1,w+1+m);\n\t\trep(i,1,m) w[i]+=w[i-1];\n\t\trep(i,1,m)\n\t\t{\n\t\t\tint u=read(),v=read();\n\t\t\taddedge(u,v);addedge(v,u);\n\t\t}\n\t\tdij(b,dis[0]);dij(a,dis[1]);dij(c,dis[2]);\n\t\t//rep(i,1,n) cout << dis[0][i] << "" "";\n\t\t//cout << endl;\n\t\tll ans=1e18;\n\t\trep(i,1,n)\n\t\t{\n\t\t\tint x=dis[0][i],y=dis[1][i],z=dis[2][i];\n\t\t\t//cout << i << "" "" << x << "" ""<< y << "" ""<< z << endl;\n\t\t\tll now=calc(1,x)*2+calc(x+1,x+y)+calc(x+y+1,x+y+z);\n\t\t\t//cout << now << endl;\n\t\t\tans=min(ans,now);\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t\trep(i,1,n) head[i]=0;all=0;\n\t}\n\treturn 0;\n}\n\n\n\n']",,,"['brute force', 'graphs', 'greedy', 'shortest paths', 'sortings']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\E. Weights Distributing.json,https://codeforces.com//blog/entry/76352,If we distribute costs optimally then this pair of paths and can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point The first case is basically a subcase of the second one with the intersection point or So if we fix the intersection point then these two paths and become four paths and We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from to be Then it is obvious that for the fixed intersection point we don t need to use more than smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from to is used twice so it is more optimally to distribute the smallest costs along this part So let be the sum of the first smallest costs just prefix sums on the sorted array Then for the intersection point the answer is if We can calculate distances from and to each vertex with three runs of bfs Time complexity 
https://codeforces.com//contest/1419/problem/F,729813,F,1419F,1419,F. Rain of Fire,There are n detachments on the surface numbered from 1 to n the i th detachment is placed in a point with coordinates x i y i All detachments are placed in different points Brimstone should visit each detachment at least once You can choose the detachment where Brimstone starts To move from one detachment to another he should first choose one of four directions of movement up right left or down and then start moving with the constant speed of one unit interval in a second until he comes to a detachment After he reaches an arbitrary detachment he can repeat the same process Each t seconds an orbital strike covers the whole surface so at that moment Brimstone should be in a point where some detachment is located He can stay with any detachment as long as needed Brimstone is a good commander that s why he can create detachment and place it in any empty point with integer coordinates he wants before his trip Keep in mind that Brimstone will need to visit this detachment too Help Brimstone and find such minimal t that it is possible to check each detachment If there is no such t report about it ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#pragma GCC optimize(""Ofast"")\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e3 + 5;\nstruct Node {\n\tint x, y;\n}a[MAXN], b[MAXN];\nint n, dx[MAXN], dy[MAXN], tx, ty;\nvector < int > row[MAXN], clm[MAXN];\nbool cmp1(int i, int j) {return a[i].y < a[j].y;}\nbool cmp2(int i, int j) {return a[i].x < a[j].x;}\n\nint f[MAXN], siz[MAXN];\ninline int find(int x) {\n\twhile(x != f[x]) x = f[x];\n\treturn x;\n}\nstruct Tri {\n\tint x, y, r, w;\n};\nstack < Tri > s;\ninline int merge(int x, int y, int opt = 0) {\n\tx = find(x), y = find(y);\n\tif(x == y) return 0;\n\tif(siz[x] < siz[y]) swap(x, y);\n\tif(opt) s.push((Tri) {y, f[y], x, siz[x]});\n\tf[y] = x; siz[x] += siz[y]; return 1;\n}\ninline void back() {\n\twhile(s.size()) {\n\t\tf[s.top().x] = s.top().y; siz[s.top().r] = s.top().w;\n\t\ts.pop();\n\t}\n}\nbool check(int mid) {\n//\tcerr << mid << "":"" << endl;\n\tFor(i, 1, tx) row[i].clear(); tx = 0;\n\tFor(i, 1, ty) clm[i].clear(); ty = 0;\n\tFor(i, 1, n) a[i] = b[i];\n\tFor(i, 1, n) dx[++tx] = a[i].x, dx[++tx] = a[i].x - mid, dx[++tx] = a[i].x + mid; \n\tFor(i, 1, n) dy[++ty] = a[i].y, dy[++ty] = a[i].y - mid, dy[++ty] = a[i].y + mid; \n\tsort(dx + 1, dx + 1 + tx); sort(dy + 1, dy + 1 + ty); tx = unique(dx + 1, dx + 1 + tx) - dx - 1, ty = unique(dy + 1, dy + 1 + ty) - dy - 1;\n//\tcerr << tx << \' \' << ty << endl;\n    For(i, 1, n) row[a[i].x = lower_bound(dx + 1, dx + 1 + tx, a[i].x) - dx].pb(i), clm[a[i].y = lower_bound(dy + 1, dy + 1 + ty, a[i].y) - dy].pb(i);\n\tFor(i, 1, tx) sort(row[i].begin(), row[i].end(), cmp1);\n\tFor(i, 1, ty) sort(clm[i].begin(), clm[i].end(), cmp2);\n\t\n\tFor(i, 1, n + 1) f[i] = i, siz[i] = 1;\n\twhile(s.size()) s.pop();\n\tFor(i, 1, tx) {\n\t\tfor(rint j = 1; j < row[i].size(); j++) {\n\t\t\tif(dy[a[row[i][j]].y] - dy[a[row[i][j-1]].y] <= mid) {\n\t\t\t\tmerge(row[i][j], row[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tFor(i, 1, ty) {\n\t\tfor(rint j = 1; j < clm[i].size(); j++) {\n\t\t\tif(dx[a[clm[i][j]].x] - dx[a[clm[i][j-1]].x] <= mid) {\n\t\t\t\tmerge(clm[i][j], clm[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(siz[find(1)] == n) return 1;\n\tFor(x, 1, tx) {\n\t\tFor(y, 1, ty) {\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tfor(int j = 0; j < row[x].size(); j++) {\n\t\t\t\tif(abs(dy[a[row[x][j]].y] - dy[y]) <= mid) {\n//\t\t\t\t\tcerr << x << \' \' << y << \' \' << row[x][j] << \' \' << dy[a[row[x][j]].y]  << \' \' << dy[y] << endl;\n\t\t\t\t\tmerge(row[x][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < clm[y].size(); j++) {\n\t\t\t\tif(abs(dx[a[clm[y][j]].x] - dx[x]) <= mid) {\n//\t\t\t\t\tcerr << x << \' \' << y << \' \' << clm[y][j] << \' \' << dx[a[clm[y][j]].x] << \' \' << dx[x] << endl;\n\t\t\t\t\tmerge(clm[y][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tif(siz[find(1)] == n + 1) return 1;\n\t\t\tback();\n\t\t}\n\t}\n\treturn 0;\n}\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    cin >> n;\n    For(i, 1, n) cin >> a[i].x >> a[i].y, b[i] = a[i];\n    \n\tll l = 1, r = 2e9, res = -1;\n\twhile(l <= r) {\n//\t\tcerr << l << \' \' << r << endl;\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid)) {\n\t\t\tr = mid - 1, res = mid;\n\t\t} else l = mid + 1;\n\t}\n\tcout << res << endl;\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']",,,"['binary search', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'implementation']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\F. Rain of Fire.json,https://codeforces.com//blog/entry/82817,We can consider a graph where vertices are the points detachments and there is an edge between two points if it s possible to move from one point to another It is possible if these points are on the same line or and the distance between them is Now we can check whether current value is good whether it is possible to check all detachments It is easy to see that it is only possible when the graph is connected This means that we can make a binary search for Let s now learn how to check whether it is possible to add at most one point to make the graph connected If there is component then the graph is already connected If there are components then we can search through all such pairs of points that one point is from the first component and another point is from the second component We can connect these points if they are on one line and the distance between them is or the differences and If are three components then we should consider triples of points Two of these points should be on the same line The added point should be on a segment between these two points and there are such segments Now let s search through all such pairs segment point and check whether it is possible to place a point on the segment and connect it with the point from the pair If there are components then you can search trough pairs segment segment so that one segment is horizontal and another one is vertical they should make a cross Now we just need to check whether it is possible to connect their intersection point with all 4 endpoints of the segments If there are more than components then it is not possible to connect them adding only one point because there are 4 movement directions If your binary search did not find the answer even for then the answer is because the maximal distance between any two points is 
https://codeforces.com//contest/827/problem/B,113846,B,827B,827,B. High Load,Arkady needs your help again This time he decided to build his own high speed Internet exchange point It should consist of nodes connected with minimum possible number of wires into one network a wire directly connects two nodes Exactly of the nodes should be exit nodes that means that each of them should be connected to exactly one other node of the network while all other nodes should be connected to at least two nodes in order to increase the system stability Arkady wants to make the system as fast as possible so he wants to minimize the maximum distance between two exit nodes The distance between two nodes is the number of wires a package needs to go through between those two nodes Help Arkady to find such a way to build the network that the distance between the two most distant exit nodes is as small as possible ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nVI ex,ey;\nin co(in n, in k){\n  if(n==1)\n    return 0;\n  if(n==2){\n    ex.PB(0);\n    ey.PB(1);\n    return 1;\n  }\n  k=min(k,n-1);\n  assert(k>=2);\n  if(n==k+1){\n    for(in i=n-1;i>=n-k;--i){\n      ex.PB(0);\n      ey.PB(i);\n    }\n    return 2;\n  }\n  if(n==k+2){\n    ex.PB(0);\n    ey.PB(2);\n    ex.PB(0);\n    ey.PB(1);\n    for(in i=3;i<n;++i){\n      ex.PB(1);\n      ey.PB(i);\n    }\n    return 3;\n  }\n  in sf=co(n-k,k);\n  in nxtu=n-k-1;\n  for(in i=nxtu+1;i<n;++i){\n    ex.PB(nxtu--);\n    if(nxtu<0)\n      nxtu=0;\n    ey.PB(i);\n  }\n  return 2+sf;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,k;\n  cin>>n>>k;\n  cout<<co(n,k)<<""\\n"";\n  forv(i,ex){\n    cout<<ex[i]+1<<"" ""<<ey[i]+1<<""\\n"";\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'greedy', 'implementation', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. High Load.json,https://codeforces.com//blog/entry/53268,one of the optimal solutions is a star like tree one center node with paths with lengths difference at most one let the optimal answer be something different from the structure described If it is a star with paths but the lengths differ by more than one we can shorten the longest one and lengthen the shortest one and the answer won t become greater So doing this operation once or more we eventually get the described structure that means that our answer is optimal If the optimal answer is not a star let s hang it on one of its centers and let the diameter be Then the depths of all leaves are not greater than Suppose there is some edge from the root that has more than one leaf in its subtree Let be some leaf in this subtree and its depth be Let s take the path from leaf all the way up to some vertex with degree more than and rehang this path to the root The tree is now more star like and we are going to prove that the answer didn t become larger Obviously we re only interested in distances between and other leaves Moreover we can see that the current depth of is smaller than and the distance between and other leaves doesn t exceed It is proved now 
https://codeforces.com//contest/837/problem/C,116709,C,837C,837,C. Two Seals,One very important person has a piece of paper in the form of a rectangle Also he has seals Each seal leaves an impression on the paper in the form of a rectangle of the size Each impression must be parallel to the sides of the piece of paper but seal can be rotated by 90 degrees A very important person wants to choose two different seals and put them two impressions Each of the selected seals puts exactly one impression Impressions should not overlap but they can touch sides and the total area occupied by them should be the largest possible What is the largest area that can be occupied by two seals ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nbool isValid(int a, int b, int c, int d) {\n\tif (a <= c && b <= d) return true;\n\tswap(a, b);\n\treturn a <= c && b <= d;\n}\n\nint in[105][2];\nint main() {\n\tint N, A, B, i, j, k;\n\tscanf(""%d %d %d"", &N, &A, &B);\n\tfor (i = 1; i <= N; i++) scanf(""%d %d"", &in[i][0], &in[i][1]);\n\n\tint ans = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tfor (k = 1; k < A; k++) if (isValid(in[i][0], in[i][1], k, B) && isValid(in[j][0], in[j][1], A - k, B)) break;\n\t\t\tif (k < A) ans = max(ans, in[i][0] * in[i][1] + in[j][0] * in[j][1]);\n\t\t\tfor (k = 1; k < B; k++) if (isValid(in[i][0], in[i][1], A, k) && isValid(in[j][0], in[j][1], A, B - k)) break;\n\t\t\tif (k < B) ans = max(ans, in[i][0] * in[i][1] + in[j][0] * in[j][1]);\n\t\t}\n\t}\n\treturn !printf(""%d\\n"", ans);\n}']",,,"['brute force', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Two Seals.json,https://codeforces.com//blog/entry/53662,If you can place two rectangles in some way without rotations then it s always possible to move one of them to the top left corner and stick the other either to the bottom of the first and push it all the way to the left or to the right of it and push it all the way to the top Now let s try all possible reorderings and rotations for every pair of seals If there is at least one correct reordering then update the answer Overall complexity 
https://codeforces.com//contest/914/problem/G,148493,G,914G,914,G. Sum the Fibonacci,You are given an array of non negative integers A 5 tuple of integers is said to be valid if it satisfies the following conditions for some integer Here is the bitwise OR is the bitwise AND and is the bitwise XOR operation Find the sum of over all valid 5 tuples where is the th Fibonnaci number Since answer can be is huge output it modulo ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int P=1000000007;\ninline int Pow(int a,int b){\n\tint c=1;\n\tfor(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;\n\treturn c;\n}\ninline void FWT(int *A,int f,int N){\n    int p2=Pow(2,P-2);\n    for(int i=1;i<N;i<<=1)\n    for(int j=0;j<N;j+=(i<<1))\n    for(int k=0;k<i;k++){\n        int x0=A[j+k];int x1=A[i+j+k];\n        if(f==0){\n            A[j+k]=(x0-x1+P)%P;\n            A[i+j+k]=(x0+x1)%P;\n        }\n        else{\n            A[j+k]=(x0+x1)*1ll*p2%P;\n            A[i+j+k]=(x1-x0)*1ll*p2%P;\n            if(A[i+j+k]<0)A[i+j+k]+=P;\n        }\n    }\n}\nconst int N=1<<17;\nint cnt[N];\nint ss;\nint n=17;\nint f[N][18];\nint bit[N];\nint gt[18];\nint p1[N];\nint p2[N];\n\nint p3[N];\n\nint fib[N];\nvoid tr(int *a){\n\trep(i,0,n-1)per(S,(1<<n)-1,0)if(!(S&(1<<i)))a[S]=(a[S]+a[S^(1<<i)])%P;\n}\nvoid ntr(int *a){\n\tper(i,n-1,0)rep(S,0,(1<<n)-1)if(!(S&(1<<i)))a[S]=(a[S]+P-a[S^(1<<i)])%P;\n}\nint main(){\n\tscanf(""%d"",&ss);\n\trep(i,1,(1<<n)-1)bit[i]=bit[i>>1]+(i&1);\n\tfib[0]=0;fib[1]=1;\n\trep(i,2,(1<<n)-1)fib[i]=(fib[i-1]+fib[i-2])%P;\n\twhile(ss--){\n\t\tint x;scanf(""%d"",&x);\n\t\tcnt[x]++;\n\t}\n\trep(i,0,(1<<n)-1){\n\t\tf[i][bit[i]]=cnt[i];\n\t}\n\trep(i,0,n-1)rep(S,0,(1<<n)-1)if(S&(1<<i))rep(j,0,n)f[S][j]=(f[S][j]+f[S^(1<<i)][j])%P;\n\trep(S,0,(1<<n)-1){\n\t\tmemset(gt,0,sizeof gt);\n\t\trep(i,0,n)rep(j,0,n-i)gt[i+j]=(gt[i+j]+f[S][i]*1ll*f[S][j])%P;\n\t\trep(i,0,n)f[S][i]=gt[i];\n\t}\n\tper(i,n-1,0)per(S,(1<<n)-1,0)if(S&(1<<i))rep(j,0,n)f[S][j]=(f[S][j]+P-f[S^(1<<i)][j])%P;\n\trep(S,0,(1<<n)-1)p1[S]=f[S][bit[S]]*1ll*fib[S]%P;\n\trep(S,0,(1<<n)-1)p2[S]=cnt[S]*1ll*fib[S]%P;\n\n\trep(S,0,(1<<n)-1)p3[S]=cnt[S];\n\n\tFWT(p3,0,1<<n);\n\trep(S,0,(1<<n)-1)p3[S]=p3[S]*1ll*p3[S]%P;\n\tFWT(p3,1,1<<n);\n\trep(S,0,(1<<n)-1)p3[S]=p3[S]*1ll*fib[S]%P;\n\n\ttr(p1);tr(p2);tr(p3);\n\trep(i,0,(1<<n)-1)p1[i]=(p1[i]*1ll*p2[i]%P)*1ll*p3[i]%P;\n\tntr(p1);\n\tint ans=0;\n\trep(i,0,n-1)ans=(ans+p1[1<<i])%P;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n\n\n\n\n']",,,"['bitmasks', 'divide and conquer', 'dp', 'fft', 'math']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\G. Sum the Fibonacci.json,https://codeforces.com//blog/entry/57250,Apologies we didn t expect an solution The expected solution was as follows Let be the number of pairs in the array such that their bitwise OR is and multiplied by This can be done using subset convolution Let be the count of each element in array multiplied by Let be the number of pairs such that their bitwise xor is multiplied by This can be done using Xor convolution Let be the And Convolution of and Then the answer is given by the expression Complexity 
https://codeforces.com//contest/947/problem/D,164140,D,947D,947,D. Picking Strings,Alice has a string consisting of characters and Bob can use the following transitions on any substring of our string in any order any number of times empty string Note that a substring is one or more consecutive characters For given queries determine whether it is possible to obtain the target string from source ,"['#include<bits/stdc++.h>\n#define N 200010\nusing namespace std;\nchar s1[N],s2[N];\nint n,m,i,g[N],f[N],G[N],F[N],a,b,c,q,d;\nchar ans[N];\nint count(int B,int A,int D,int C){\n\t//printf(""%d %d %d %d\\n"",A,B,C,D);\n\tif(!A){\n\t\tif(!C){\n\t\t\tif(B>=D&&(B-D)%3==0)return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif(B==D)return 0;\n\t}\n\tif(B<D)return 0;\n\tA+=2*((B-D)%3!=0);\n\tif(A>C||(C-A)%2)return 0;\n\treturn 1;\n}\nint main(){\n\tscanf(""%s%s"",s1+1,s2+1);\n\tn=strlen(s1+1);\n\tm=strlen(s2+1);\n\tfor(i=1;i<=n;i++){\n\t\tg[i]=g[i-1];\n\t\tif(s1[i]==\'A\')f[i]=f[i-1]+1;\n\t\telse g[i]++;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tG[i]=G[i-1];\n\t\tif(s2[i]==\'A\')F[i]=F[i-1]+1;\n\t\telse G[i]++;\n\t}\n\tscanf(""%d"",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(""%d%d%d%d"",&a,&b,&c,&d);\n\t\tans[i]=\'0\'+count(min(b-a+1,f[b]),g[b]-g[a-1],min(d-c+1,F[d]),G[d]-G[c-1]);\n\t}\n\tprintf(""%s\\n"",ans);\n}']",,,"['constructive algorithms', 'implementation', 'strings']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Picking Strings.json,https://codeforces.com//blog/entry/58286,First note that B can be always changed to C and vice versa Hence we can replace all C s with B s Furthermore see that The above implies the set of following rules We can translate these rules to the following the number of Bs can be increased by any non negative even number the number of As before any B may change arbitrarily The only remaining thing is to determine what should happen to the number of trailing A s There are three cases The number of B s is the same in the source and target the number of trailing A s can decrease by any non negative multiple of 3 as no application of the first rule occurs and the second and third rule cannot affect trailing A s There are some B s in the source and the number of B s increases the number of trailing A s can decrease by any non negative number To decrease the number to k just morph the k 1 th A from the end to BB To keep it the same morph any B to AB and then to BBB to introduce extra B s as needed There are no B s in the source but some B s in the target the number of trailing A s has to decrease by any positive integer It is now easy to calculate prefix sums of the B and C occurrences and calculate the number of trailing A s for every end position The rest is just casework 
https://codeforces.com//contest/978/problem/C,182878,C,978C,978,C. Letters,There are n dormitories in Berland State University they are numbered with integers from 1 to n Each dormitory consists of rooms there are a i rooms in i th dormitory The rooms in i th dormitory are numbered from 1 to a i A postman delivers letters Sometimes there is no specific dormitory and room number in it on an envelope Instead of it only a room number among all rooms of all n dormitories is written on an envelope In this case assume that all the rooms are numbered from 1 to a 1 a 2 dots a n and the rooms of the first dormitory go first the rooms of the second dormitory go after them and so on For example in case n 2 a 1 3 and a 2 5 an envelope can have any integer from 1 to 8 written on it If the number 7 is written on an envelope it means that the letter should be delivered to the room number 4 of the second dormitory For each of m letters by the room number among all n dormitories determine the particular dormitory and the room number in a dormitory where this letter should be delivered ,"[""#include <bits/stdc++.h>\n#define DIM 200007\nusing namespace std;\n\nlong long n,m,a[DIM],p[DIM];\n\n\nint main()\n{\n    cin>>n>>m;\n\n    for(int i = 1; i <= n; ++i)\n    {\n        cin>>a[i];\n        p[i] = p[i-1] + a[i];\n    }\n\n    for(int i = 1; i <= m; ++i)\n    {\n        long long b;\n        cin>>b;\n        int pos = lower_bound(p+1,p+1+n,b) - p;\n        cout<<pos<<' '<<b-p[pos-1]<<endl;\n    }\n    return 0;\n\n}\n""]",,,"['binary search', 'implementation', 'two pointers']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Letters.json,https://codeforces.com/blog/entry/59430,We should use that the letter queries are given in increasing order of room numbers We will store in a variable the number of rooms in already considered dormitories this variable should have 64 bit type and in a variable we will store the minimum number of dormitory where the room from the current letter possibly is Initially and We will iterate through the letters Let the current letter should be delivered to the room While we increase by and increase by one So we got the dormitory number where room is It only remains to print two integers the dormitory number and the room number in this dormitory 
https://codeforces.com//contest/1846/problem/G,1999908,G,1846G,1846,G. Rudolf and CodeVid-23,A new virus called CodeVid 23 has spread among programmers Rudolf being a programmer was not able to avoid it There are n symptoms numbered from 1 to n that can appear when infected Initially Rudolf has some of them He went to the pharmacy and bought m medicines For each medicine the number of days it needs to be taken is known and the set of symptoms it removes Unfortunately medicines often have side effects Therefore for each medicine the set of symptoms that appear when taking it is also known After reading the instructions Rudolf realized that taking more than one medicine at a time is very unhealthy Rudolph wants to be healed as soon as possible Therefore he asks you to calculate the minimum number of days to remove all symptoms or to say that it is impossible ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\n// xise me marko\n\n\nint xino()\n{\n\tstring s;\n\tcin >> s;\n\tint val = 0;\n\tfor (int i=0; i<s.size(); ++i)\n    {\n\t\tif (s[i] == '1')\n\t\tval += (1<<i);\n\t}\n\treturn val;\n}\n\nvoid solve()\n{\n\n  // νταικστρααα kratao left right bit\n    int n, m;\n\tcin >> n >> m;\n\tint start = xino();\n\tvector<int> d(m), rm(m), ad(m);\n\tfor (int i=0; i<m; ++i)\n    {\n\t\tcin >> d[i];\n\t\trm[i] = ~xino();\n\t\tad[i] = xino();\n\t}\n\tvector<int> dist((1<<n), -1);\n\tdist[start] = 0;\n\tset<pair<int, int> > st;\n\tst.emplace(0, start);\n\twhile (!st.empty())\n    {\n\t\tint val = st.begin()->second;\n\t\tst.erase(st.begin());\n\t\tfor (int i=0; i<m; ++i)\n\t\t{\n\t\t\tint val2 = val;\n\t\t\tval2 &= rm[i];\n\t\t\tval2 |= ad[i];\n\t\t\tif (dist[val2] == -1 || dist[val2] > dist[val] + d[i])\n\t\t\t{\n\t\t\t\tst.erase(make_pair(dist[val2], val2));\n\t\t\t\tdist[val2] = dist[val] + d[i];\n\t\t\t\tst.emplace(dist[val2], val2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[0] << endl;\n\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n""]",,,"['bitmasks', 'dp', 'graphs', 'greedy', 'shortest paths']",1900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\G. Rudolf and CodeVid-23.json,https://codeforces.com//blog/entry/118044,Let s denote Rudolf s state as a binary mask of length consisting of and similar to how it is given in the input data Then each medicine transforms Rudolf from one state to another Let s construct a weighted directed graph where the vertices will represent all possible states of Rudolf There will be such vertices Two vertices will be connected by an edge if there exists a medicine that transforms Rudolf from the state corresponding to the first vertex to the state corresponding to the second vertex The weight of the edge will be equal to the number of days that this medicine needs to be taken Note that in this case we simply need to find the shortest path in this graph from the vertex corresponding to the initial state of Rudolf to the vertex corresponding to the state without symptoms To find the shortest path in a weighted graph we will use Dijkstra s algorithm We will run it from the vertex and if as a result we visit the vertex output the distance to it otherwise The time complexity is 
https://codeforces.com//contest/1358/problem/E,630279,E,1358E,1358,E. Are You Fired ,Levian works as an accountant in a large company Levian knows how much the company has earned in each of the n consecutive months in the i th month the company had income equal to a i positive income means profit negative income means loss zero income means no change Because of the general self isolation the first lceil tfrac n 2 rceil months income might have been completely unstable but then everything stabilized and for the last lfloor tfrac n 2 rfloor months Levian decided to tell the directors n k 1 numbers the total income of the company for each k consecutive months In other words for each i between 1 and n k 1 he will say the value a i a i 1 ldots a i k 1 For example if a 1 0 1 2 2 and k 3 he will say the numbers 0 3 5 Unfortunately if at least one total income reported by Levian is not a profit income le 0 the directors will get angry and fire the failed accountant Save Levian s career find any such k that for each k months in a row the company had made a profit or report that it is impossible ,"['#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int MN = 500005;\n\nint N;\nLL val, A[MN], S[MN];\n\nint main() {\n\tscanf(""%d"", &N);\n\tfor (int i = 1; i <= (N + 1) / 2; ++i) scanf(""%lld"", &A[i]), S[i] = S[i - 1] + A[i];\n\tscanf(""%lld"", &val);\n\tfor (int i = (N + 3) / 2; i <= N; ++i) A[i] = val, S[i] = S[i - 1] + A[i];\n\tif (val >= 0) return printf(""%d\\n"", S[N] > 0 ? N : -1), 0;\n\tint mid = (N + 1) / 2, maxlen = N;\n\tfor (int i = 1; i <= mid; ++i) {\n\t\tif (S[mid] - S[i - 1] <= 0) return puts(""-1""), 0;\n\t\tLL num = (S[mid] - S[i - 1] - 1) / -val;\n\t\tint nlen = std::min(mid + num, (LL)N) - i + 1;\n//\t\tprintf(""(i, nlen) = (%d, %d)\\n"", i, nlen);\n\t\tmaxlen = std::min(maxlen, nlen);\n\t\tif (N - i + 1 <= maxlen) return printf(""%d\\n"", N - i + 1), 0;\n\t}\n\tputs(""-1"");\n\treturn 0;\n}\n']",,,"['constructive algorithms', 'data structures', 'greedy', 'implementation']",2400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Are You Fired .json,https://codeforces.com//blog/entry/77869,Let s call the value of all elements in the second half of the array Let the reported incomes Pretend there exists such a that Consider the following reported incomes and Notice that if we double the th reported income will be equal to and imply It means that after doubling the new value will still be correct if some exists there s also Now let s notice that It means we can think of as prefix sums of the following array As holds for so actually How is this array changed when we increment by 1 which equals So when you increase by 1 the first element is changed and the last element is removed and that s it Recall that Notice that the minimum reported income some number from doesn t depend on the first element of because it s a term of all sums For example if is increased by all are increased by too So let s calculate the following array This can be done in Notice that this array is the same for all except its size So it s obvious that the minimum reported income for a particular is So we can just check if this number is greater than for some We can calculate prefix sums and in so the overall complexity is 
https://codeforces.com//contest/270/problem/A,2572,A,270A,270,A. Fancy Fence,Emuskald needs a fence around his farm but he is too lazy to build it himself So he purchased a fence building robot He wants the fence to be a regular polygon The robot builds the fence along a single path but it can only make fence corners at a single angle Will the robot be able to build the fence Emuskald wants In other words is there a regular polygon which angles are equal to ,"['#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fo(i,n) for(int i=1;i<=n;i++)\n#define fe(i,n) for(__typeof(n.begin()) i=n.begin();i!=n.end();i++)\nint t;\nint n;\nint main()\n{\n\tcin>>t;\n\tfor(int i=0;i<t;i++)\n\t{\n\t\tcin>>n;\n\t\tn=180-n;\n\t\tputs(360%n==0?""YES"":""NO"");\n\t}\n}']",,,"['geometry', 'implementation', 'math']",1100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Fancy Fence.json,https://codeforces.com//blog/entry/6596,Problem The problem is to tell whether there exists a regular polygon with angle equal to a Solution Consider all supplementary angles of the regular n polygon with angle a which are equal to Their sum is equal to because the polygon is convex Then the following equality holds n 180 a 360 which means that there is an answer if and only if 
https://codeforces.com//contest/1261/problem/D1,479749,D1,1261D1,1261,D1. Wrong Answer on test 233  Easy Version ,Your program fails again This time it gets The problem is about a test containing n one choice questions Each of the questions contains k options and only one of them is correct The answer to the i th question is h i and if your answer of the question i is h i you earn 1 point otherwise you earn 0 points for this question The values h 1 h 2 dots h n are known to you in this problem However you have a mistake in your program It moves the answer clockwise Consider all the n answers are written in a circle Due to the mistake in your program they are shifted by one cyclically Formally the mistake moves the answer for the question i to the question i bmod n 1 So it moves the answer for the question 1 to question 2 the answer for the question 2 to the question 3 the answer for the question n to the question 1 We call all the n answers together an There are k n possible answer suits in total You re wondering how many answer suits satisfy the following condition You need to find the answer modulo 998 244 353 For example if n 5 and your answer suit is a 1 2 3 4 5 it will submitted as a 5 1 2 3 4 because of a mistake If the correct answer suit is h 5 2 2 3 4 the answer suit a earns 1 point and the answer suite a earns 4 points Since 4 1 the answer suit a 1 2 3 4 5 should be counted ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nint inverse(int a, int m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  int b = m, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nusing num = modnum<998244353>;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  num m;\n  cin >> n >> m;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  a.push_back(a[0]);\n  int eq = 0;\n  int neq = 0;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] == a[i + 1]) {\n      eq++;\n    } else {\n      neq++;\n    }\n  }\n  vector<num> fact(n + 1), inv_fact(n + 1);\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = fact[i - 1] * i;\n    inv_fact[i] = inv_fact[i - 1] / i;\n  }\n  auto binom = [&](int x, int y) {\n    return fact[x] * inv_fact[y] * inv_fact[x - y];\n  };\n  num cur = 0;\n  for (int i = 0; i <= neq / 2; ++i) {\n    cur += binom(neq, i);\n  }\n  num ans = 0;\n  for (int i = 0, j = neq; i < neq; ++i, --j) {\n    ans += power(m - 2, i) * (power(num(2), j) - cur) * binom(neq, i);\n    if (j % 2 == 0) {\n      cur -= binom(j, j / 2);\n    }\n    cur += binom(j - 1, (j - 1) / 2);\n    cur /= 2;\n  }\n  cout << ans * power(m, eq) << ""\\n"";\n  return 0;\n}\n']",,,"['combinatorics', 'dp']",2200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D1. Wrong Answer on test 233  Easy Version .json,https://codeforces.com/blog/entry/71740,First of all special judge for where the answer is zero Let be the difference between the points for latest answer suit and the previous one An valid answer suit means For positions satisfying the answer for this position will not affect Assume there s positions which For a fixed position which let your answer for this position is If then the value will decrease by 1 We call this kind of position as a If then the value increase by 1 We call this kind of position as a Otherwise value will not be affected we call this kind of position Obviously the number of increasing position should be exact larger then the decreasing position So let s enumerate the number of zero positions We can find the answer is equal to represent the number of zero positions and represent the number of increasing positions The only problem is how to calculate quickly Due to we can tell that when is odd Otherwise it is equal to 
https://codeforces.com//contest/1620/problem/B,1233289,B,1620B,1620,B. Triangles on a Rectangle,A rectangle with its opposite corners in 0 0 and w h and sides parallel to the axes is drawn on a plane You are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner Also there are at least two points on every side of a rectangle Your task is to choose three points in such a way that exactly two of them belong to the same side of a rectangle the area of a triangle formed by them is maximum possible Print the doubled area of this triangle It can be shown that the doubled area of any triangle formed by lattice points is always an integer ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int64_t W, H;\n    cin >> W >> H;\n    int64_t most = 0;\n\n    for (int d = 0; d < 2; d++)\n        for (int s = 0; s < 2; s++) {\n            int k;\n            cin >> k;\n            vector<int64_t> X(k);\n\n            for (auto &x : X)\n                cin >> x;\n\n            most = max(most, (X.back() - X.front()) * (d == 0 ? H : W));\n        }\n\n    cout << most << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['geometry', 'greedy', 'math']",1000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\B. Triangles on a Rectangle.json,https://codeforces.com//blog/entry/98061,The area of a triangle is equal to its base multiplied by its height divided by Let the two points that have to be on the same side of a rectangle form its base To maximize it let s choose such two points that are the most apart from each other the first and the last in the list Then the height will be determined by the distance from that side to the remaining point Since there are points on all sides the points on the opposite side are the furthest Thus the height is always one of or depending on whether we picked the horizontal or the vertical side So we have to check four options to pick the side and choose the best answer among them 
https://codeforces.com//contest/676/problem/B,60897,B,676B,676,B. Pyramid of Glasses,Mary has just graduated from one well known University and is now attending celebration party Students like to dream of a beautiful life so they used champagne glasses to construct a small pyramid The height of the pyramid is The top level consists of only glass that stands on glasses on the second level counting from the top then glasses on the third level and so on The bottom level consists of glasses Vlad has seen in the movies many times how the champagne beautifully flows from top levels to bottom ones filling all the glasses simultaneously So he took a bottle and started to pour it in the glass located at the top of the pyramid Each second Vlad pours to the top glass the amount of champagne equal to the size of exactly one glass If the glass is already full but there is some champagne flowing in it then it pours over the edge of the glass and is equally distributed over two glasses standing under If the overflowed glass is at the bottom level then the champagne pours on the table For the purpose of this problem we consider that champagne is distributed among pyramid glasses immediately Vlad is interested in the number of completely full glasses if he stops pouring champagne in seconds Pictures below illustrate the pyramid consisting of three levels ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ndouble M[15][15];\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""data.in"",""r"",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,t;\n\tcin>>n>>t;\n\tdouble x;\n\n\twhile(t--) {\n\t\tM[1][1] += 1;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=i;++j) {\n\t\t\t\tif(M[i][j] > 1) {\n\t\t\t\t\tx = M[i][j] - 1;\n\t\t\t\t\tM[i][j] = 1;\n\t\t\t\t\tM[i+1][j] += x/2;\n\t\t\t\t\tM[i+1][j+1] += x/2;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tx = 0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tif(M[i][j] == 1)\n\t\t\t\t++x;\n\n\tcout<<x<<""\\n"";\n\n\treturn 0;\n}\n']",,,"['implementation', 'math', 'math']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\B. Pyramid of Glasses.json,https://codeforces.com/blog/entry/45018,The restrictions in this problem allow to simulate the process Let the volume of one wineglass equals to conventional units So the volume of the champagne surpluses which will stream to bottom level will always integer number So let s pour in the top wineglass units of champagne and then we have following case if in the current wineglass is more champagne than its volume let s make and add of champagne in each of the two bottom wineglasses Asymptotic behavior 
https://codeforces.com//contest/1603/problem/B,1163970,B,1603B,1603,B. Moderate Modular Mode,YouKn0wWho has two integers x and y Help him to find an integer n such that 1 le n le 2 cdot 10 18 and n bmod x y bmod n Here a bmod b denotes the remainder of a after division by b If there are multiple such integers output any It can be shown that such an integer always exists under the given constraints ,"[""/**\n *    author:  tourist\n *    created: 30.10.2021 17:38:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long x, y;\n    cin >> x >> y;\n    if (y < x) {\n      cout << y + x << '\\n';\n      continue;\n    }\n    if (y == x) {\n      cout << x << '\\n';\n      continue;\n    }\n    cout << y - y % x / 2 << '\\n';\n  }\n  return 0;\n}\n""]",,,"['constructive algorithms', 'math', 'number theory']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Moderate Modular Mode.json,https://codeforces.com//blog/entry/96460,If then works as and The challenge arrives when The later part of the editorial assumes that can t be less than Assume that for some is satisfied Then but So can t be equal to which is a contradiction can t be greater than Assume that for some is satisfied Then but So can t be equal to which is a contradiction So should be in between and But what is the exact value of Let s solve this intuitively Consider a line on the axis Imagine you are at position You will start jumping from to with a step of length So there will be a position from where if you jump one more time it will exceed This position is From this position let s go to in exactly steps Notice that is guaranteed to be even as and both are even So we need to jump with a length of and we will jump to the position And voila is our desired because and To be precise Here is a cute illustration for you 
https://codeforces.com//contest/75/problem/D,400,D,75D,75,D. Big Maximum Sum,Ahmed and Mostafa used to compete together in many programming contests for several years Their coach Fegla asked them to solve one challenging problem of course Ahmed was able to solve it but Mostafa couldn t This problem is similar to a standard problem but it has a different format and constraints In the standard problem you are given an array of integers and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum But in this problem you are given small arrays and you will create one big array from the concatenation of one or more instances of the small arrays each small array could occur more than once The big array will be given as an array of indexes 1 based of the small arrays and the concatenation should be done in the same order as in this array Then you should apply the standard problem mentioned above on the resulting big array For example let s suppose that the small arrays are 1 6 2 3 3 and 5 1 And the indexes in the big array are 2 3 1 3 So the actual values in the big array after formatting it as concatenation of the small arrays will be 3 3 5 1 1 6 2 5 1 In this example the maximum sum is 9 Can you help Mostafa solve this problem ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <map>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nlong long n, m;\n\nvector <long long> a[100];\nlong long sum[100], maxp[100], maxs[100], aa[100];\nlong long b[300000];\nlong long k , x;\nint main() {\n  //freopen (""input.txt"", ""r"", stdin);\n  //freopen (""output.txt"", ""w"", stdout);\n  cin >> n >> m;\n  for (long long i = 0; i < n; ++i) {\n    cin >> k;\n    for (long long j = 0; j < k; ++j) {\n      cin >> x;\n      a[i].push_back(x);\n    }\n  }\n  for (long long i = 0; i < m; ++i) {\n    cin >> b[i];\n    b[i]--;\n  }\n  for (long long i = 0; i < n; ++i) {\n    sum[i] = 0;\n    maxp[i] = a[i][0];\n    maxs[i] = a[i][a[i].size() - 1];\n    aa[i] = a[i][0];\n    long long ct = aa[i];\n    for (long long j = 1; j < a[i].size(); ++j) {\n      if (a[i][j] > ct + a[i][j]) {\n        ct = a[i][j];\n      } else\n       ct += a[i][j];\n      if (ct > aa[i])\n        aa[i] = ct;\n    }\n    for (long long j = 0; j < a[i].size(); ++j) {\n      sum[i] += a[i][j];\n      if (sum[i] > maxp[i])\n      maxp[i] = sum[i];\n    }\n    long long uu = 0;\n    for (long long j = a[i].size() - 1; j >= 0; --j) {\n      uu += a[i][j];\n      if (uu >= maxs[i])\n        maxs[i] = uu;\n    }\n  }\n  long long ans = aa[b[0]];\n  long long ee = maxs[b[0]];\n  for (long long i = 1; i < m; ++i) {\n    if (ans < aa[b[i]])\n      ans = aa[b[i]];\n    if (ee + maxp[b[i]] > ans)\n      ans = ee + maxp[b[i]];\n    if (ee + sum[b[i]] > ans)\n      ans = ee + sum[b[i]];\n    if (ee + sum[b[i]] > maxs[b[i]])\n      ee = ee + sum[b[i]];\n    else\n      ee = maxs[b[i]];\n\n  }\n  if (ee > ans)\n    ans = ee;\n  cout << ans;\n  return 0;\n}']",,,"['data structures', 'dp', 'greedy', 'implementation', 'math', 'trees']",2000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Big Maximum Sum.json,https://codeforces.com//blog/entry/1715,This problem is my favorite one in this problem set Maybe it will be easier to solve this problem if you know how to solve the standard one But because we can t construct the big array so we can t apply the standard solution for this problem Let s see first how to solve the standard problem the following code solves it for a given array arr with length len Now let s solve the big array problem the first step is to calculate 4 values for each small array 1 The total sum of it let s call it tot 2 The maximum sum of 0 or more consecutive elements starting from the first element in the array let s call it lft 3 The maximum sum of 0 or more consecutive elements ending at the last element in the array let s call it rght 4 The maximum sum of 1 or more consecutive elements let s call it gen The final result will be 1 of 2 cases 1 The consecutive elements with the maximum sum will start and end inside the same small array 2 The consecutive elements with the maximum sum will start and end inside different small arrays For the first case we can simply pick the maximum gen for all small arrays which exist in the big array For the second case we can apply something similar to the standard solution we will keep a variable called sum and it s initialized to 0 this will be the maximum sum of 0 or more consecutive elements ending at the last element in the previous small array Now for each small array if the maximum possible sum will end in this small array so it will be sum lft and maximize over this value make sure this will be for 1 or more elements And we need to update sum to be the maximum of the following 3 values 1 sum tot we will include all elements of this small array to the old sum 2 rght we will take the maximum sum ending at the last element in the current small array 3 0 we will not take any elements in sum The running time for this solution will be just for reading the input in my solutions I have no iterations except for reading the input 
https://codeforces.com//contest/1654/problem/C,1337000,C,1654C,1654,C. Alice and the Cake,Alice has a cake and she is going to cut it She will perform the following operation n 1 times choose a piece of the cake initially the cake is all one piece with weight w ge 2 and cut it into two smaller pieces of weight lfloor frac w 2 rfloor and lceil frac w 2 rceil lfloor x rfloor and lceil x rceil denote floor and ceiling functions respectively After cutting the cake in n pieces she will line up these n pieces on a table in an arbitrary order Let a i be the weight of the i th piece in the line You are given the array a Determine whether there exists an initial weight and sequence of operations which results in a ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<long long> a(n);\n\tgenerate(all(a), nxt);\n\tlong long s = accumulate(all(a), 0ll);\n\tmultiset<long long> S(all(a));\n\tvector<long long> cur = {s};\n\tint rem = n - 1;\n\twhile (!cur.empty()) {\n\t\tauto x = cur.back();\n\t\tcur.pop_back();\n\t\tif (auto it = S.find(x); it != S.end()) {\n\t\t\tS.erase(it);\n\t\t} else if (rem == 0 || x == 1) {\n\t\t\tcout << ""No\\n"";\n\t\t\treturn;\n\t\t} else {\n\t\t\tcur.push_back(x / 2);\n\t\t\tcur.push_back((x + 1) / 2);\n\t\t\t--rem;\n\t\t}\n\t}\n\tcout << ""Yes\\n"";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']",,,"['data structures', 'greedy', 'implementation', 'sortings']",1400,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Alice and the Cake.json,https://codeforces.com//blog/entry/100127,SolutionFirst let s find the initial weight When a piece of cake is split the sum of weights is if is even if is odd Therefore the sum of weights is constant and the initial weight is the sum of the final weights Now let s start from a cake of weight split it into pieces of weight and try to make it equal to At any moment it s convenient to consider the largest because you can determine if you can split it or not More specifically if is not in you have to split it if for some you can only match with or with a such that because there doesn t exist any larger that s equivalent to removing and from respectively Notice that if at any moment the maximum element of is smaller than the maximum element of the answer is NO If can keep and in any data structure that supports inserting an integer asking for the maximum and removing the maximum e g multiset or priority queue the following algorithm works While either or is not empty if the maximum element of is smaller than the maximum element of print NO and break if the maximum element of is equal to the maximum element of remove it from both and if the maximum element of is larger than the maximum element of remove it from and split the piece of cake i e insert and into If or are both empty at the end the answer is YES Complexity 
https://codeforces.com//contest/1838/problem/E,1951238,E,1838E,1838,E. Count Supersequences,You are given an array a of n integers where all elements a i lie in the range 1 k How many different arrays b of m integers where all elements b i lie in the range 1 k contain a as a subsequence Two arrays are considered different if they differ in at least one position A sequence x is a subsequence of a sequence y if x can be obtained from y by the deletion of several possibly zero or all elements Since the answer may be large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll MOD = 1e9+7;\n\nll bp(ll a, int b) {\n    ll c = 1;\n    for (; b > 0; b /= 2) {\n        if (b & 1) {\n            c *= a; c %= MOD;\n        }\n        a *= a; a %= MOD;\n    }\n    return c;\n}\n\nll inv(ll a) {\n    return bp(a, MOD-2);\n}\n\nll mod(ll a) {\n    return (a%MOD+MOD)%MOD;\n}\n\nint main() {\n    int t; cin>>t;\n    for (int ti = 0; ti < t; ++ti) {\n        int n,m,k; cin>>n>>m>>k;\n        for (int i = 0; i < n; ++i) {\n            int a; cin>>a;\n        }\n        ll ans = bp(k,m);\n        ll c = 1, p = bp(k-1,m);\n        for (int i = 0; i < n; ++i) {\n            ans = mod(ans-c*p);\n            c = c*(m-i)%MOD*inv(i+1)%MOD;\n            p *= inv(k-1); p %= MOD;\n        }\n        cout << ans << ""\\n"";\n    }\n}\n']",,,"['combinatorics', 'dp', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Count Supersequences.json,https://codeforces.com//blog/entry/116995,Let s first consider a DP solution Let be the number of arrays of length such that the longest prefix of that appears as a subsequence of the array is of length To compute this DP consider some cases Let be the subarray of the first elements of and be the subarray of the first elements of Every subsequence of that equals includes position of In this case position must be part of the subsequence This gives us solutions At least one subsequence of that equals doesn t include position and In this case the value in position can be anything except for because that would create a subsequence of length So this gives us solutions At least one subsequence of that equals doesn t include position and This is the same as the previous case except we don t have a next element to worry about so anything can go in position and there are solutions So the final equation for the DP comes out toThis would be to compute so it will TLE However we can notice that the DP does not depend on This means we can change the values to anything we want and it won t change the answer To simplify the problem let all Now the problem becomes how many arrays of size consisting of the values contain at least ones To compute this let s find the number of arrays of size that contain less than ones and subtract it from the total number of arrays There are arrays that contain exactly ones so the answer isWe use fast exponentiation to compute the powers of and to compute the values we use the fact that and for So we can compute the first values within the time limit Complexity where 
https://codeforces.com//contest/1811/problem/D,1864326,D,1811D,1811,D. Umka and a Long Flight,The girl Umka loves to travel and participate in math olympiads One day she was flying by plane to the next olympiad and out of boredom explored a huge checkered sheet of paper Denote the n th Fibonacci number as F n begin cases 1 n 0 1 n 1 F n 2 F n 1 n ge 2 end cases A checkered rectangle with a height of F n and a width of F n 1 is called a Fibonacci rectangle n Umka has a Fibonacci rectangle n Someone colored a cell in it at the intersection of the row x and the column y It is necessary to cut this rectangle into n 1 squares in such way that the painted cell was in a square with a side of 1 there was pair of squares with equal sides the side of each square was equal to a Fibonacci number Will Umka be able to cut this rectangle in that way ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint64_t f[55];\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n  f[0] = f[1] = 1;\n  for (int i = 2; i <= 50; i++) {\n    f[i] = f[i - 1] + f[i - 2];\n  }\n  int tt; cin >> tt;\n  while (tt--) {\n    int n;\n    int64_t x, y;\n    cin >> n >> x >> y;\n    bool ok = true;\n    for (int i = n; i >= 1; i--) {\n      int64_t need = f[i + 1] - f[i];\n      y = min(y, f[i + 1] - y + 1);\n      if (y > need) {\n        ok = false;\n        break;\n      }\n      swap(x, y);\n    }\n    cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n  }\n  return 0;\n}\n']",,,"['constructive algorithms', 'implementation', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\D. Umka and a Long Flight.json,https://codeforces.com//blog/entry/114788, which can be proved by induction If the partition exists it has the form since the area of the rectangle with another partition will be greater than We will cut the rectangles in the order Denote the coordinates of the colored cell at the step as If and then there is no partition since the square at any location overlaps the colored cell Cut off the square from the right or left edge depending on the location of the colored cell that is or Suppose that it was advantageous to cut it not from the edge then it is necessary to cut the rectangles and where using the set Then will not enter the partition but so We came to a contradiction 
https://codeforces.com//contest/1762/problem/A,1695270,A,1762A,1762,A. Divide and Conquer,An array b is if the sum of elements of b is even You are given an array a consisting of n positive integers In one operation you can select an index i and change a i lfloor frac a i 2 rfloor daggerFind the minimum number of operations possibly 0 needed to make a good It can be proven that it is possible to make a good dagger lfloor x rfloor denotes the floor function the largest integer less than or equal to x For example lfloor 2 7 rfloor 2 lfloor pi rfloor 3 and lfloor 5 rfloor 5 ,"['#include<bits/stdc++.h>\nusing namespace std;\nint make(int x)\n{\n    int d = (x & 1);\n    int ans = 0;\n    while((x & 1) == d) {\n        x >>= 1;ans++;\n    }\n    return ans;\n}\nvoid solve()\n{\n    int n;int a[55];\n    scanf(""%d"",&n);\n    int t = 0;\n    int d = 1e9;\n    for(int i = 1;i <= n;i++) scanf(""%d"",&a[i]) , t ^= (a[i] & 1) , d = min(d , make(a[i]));\n    printf(""%d\\n"",t * d);\n}\nint main() {\n    // freopen(""in.txt"",""r"",stdin);\n    int t;scanf(""%d"",&t);\n    while(t--) solve();\n    return 0;\n}\n']",,,"['greedy', 'math', 'number theory']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Divide and Conquer.json,https://codeforces.com//blog/entry/110169,Solution We are assuming initial sum is odd Suppose gives the minimum number of operations needed to change parity of Iterate from to and calculate for each Answer is minimum among all the calculated values Time complexity is 
https://codeforces.com//contest/1059/problem/C,231522,C,1059C,1059,C. Sequence Transformation,Let s call the following process a transformation of a sequence of length n If the sequence is empty the process ends Otherwise append the greatest common divisor GCD of all the elements of the sequence to the result and remove one arbitrary element from the sequence Thus when the process ends we have a sequence of n integers the greatest common divisors of all the elements in the sequence before each deletion You are given an integer sequence 1 2 dots n Find the lexicographically maximum result of its transformation A sequence a 1 a 2 ldots a n is lexicographically larger than a sequence b 1 b 2 ldots b n if there is an index i such that a j b j for all j i and a i b i ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(3)\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC target(""sse3"",""sse2"",""sse"")\n#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")\n#pragma GCC target(""f16c"")\n#pragma GCC optimize(""inline"",""fast-math"",""unroll-loops"",""no-stack-protector"")\n#pragma GCC diagnostic error ""-fwhole-program""\n#pragma GCC diagnostic error ""-fcse-skip-blocks""\n#pragma GCC diagnostic error ""-funsafe-loop-optimizations""\n#pragma GCC diagnostic error ""-std=c++14""\n#include ""bits/stdc++.h""\n//#include ""ext/pb_ds/tree_policy.hpp""\n//#include ""ext/pb_ds/assoc_container.hpp""\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == \'-\') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - \'0\';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\n\nVI f(int n){\n    VI ans;\n    if(n == 0){\n        return ans;\n    }\n    if(n == 1){\n        ans.PB(1);\n        return ans;\n    }\n    if(n == 2){\n        ans.PB(1);\n        ans.PB(2);\n        return ans;\n    }\n    if(n == 3){\n        ans.PB(1);\n        ans.PB(1);\n        ans.PB(3);\n        return ans;\n    }\n    REP(i,1,n+1){\n        if(i%2 == 1){\n            ans.PB(1);\n        }\n    }\n    auto tmp = f(n/2);\n    for(auto& i:tmp)ans.PB(i*2);\n    return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    fr(""/Users/zhangqingchuan/Desktop/cp/cp/input.txt"");\n    fw(""/Users/zhangqingchuan/Desktop/cp/cp/output.txt"");\n#endif\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    SOLVE::main();\n    \n    \n    int n;in(n);\n    auto v = f(n);\n    for(auto i:v)printf(""%d "",i);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n']",,,"['constructive algorithms', 'math']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Sequence Transformation.json,https://codeforces.com//blog/entry/62238,The answers for are given in the samples Now suppose that The maximum result must have the earliest appearance of an integer different from If the earliest integer that may appear is So initially we must remove all odd integers and for each of them append to the answer But now the rest of the answer is simply the answer for multiplied by That gives us an solution 
https://codeforces.com//contest/1795/problem/C,1785699,C,1795C,1795,C. Tea Tasting,A tea manufacturer decided to conduct a massive tea tasting n sorts of tea will be tasted by n tasters Both the sorts of tea and the tasters are numbered from 1 to n The manufacturer prepared a i milliliters of the i th sort of tea The j th taster can drink b j milliliters of tea at once The tasting will be conducted in steps During the first step the i th taster tastes the i th sort of tea The i th taster drinks min a i b i tea how much is available of the i th sort and how much the i th taster can drink a i also decreases by this amount Then all tasters move to the previous sort of tea Thus during the second step the i th taster tastes the i 1 st sort of tea The i th taster drinks min a i 1 b i tea The 1 st person ends the tasting During the third step the i th taster tastes the i 2 nd sort of tea The 2 nd taster ends the tasting This goes on until everyone ends the tasting Take a look at the tasting process for n 3 a 10 20 15 b 9 8 6 In the left row there are the current amounts of each sort of tea In the right column there are current amounts of tea each taster has drunk in total The arrow tells which taster each tea goes to on the current step The number on the arrow is the amount minimum of how much is available of the sort of tea and how much the taster can drink For each taster print how many milliliters of tea he she will drink in total ,"['/**\n *    author:  tourist\n *    created: 16.02.2023 18:38:42       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) { \n      cin >> a[i];\n    }\n    vector<long long> b(n);\n    for (int i = 0; i < n; i++) { \n      cin >> b[i];\n    }\n    multiset<long long> s;\n    long long delta = 0;\n    for (int i = 0; i < n; i++) {\n      s.insert(a[i] - delta);\n      long long ans = 0;\n      while (!s.empty() && *s.begin() + delta <= b[i]) {\n        ans += *s.begin() + delta;\n        s.erase(s.begin());\n      }\n      ans += (long long) s.size() * b[i];\n      delta -= b[i];\n      cout << ans << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']",,,"['binary search', 'data structures', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Tea Tasting.json,https://codeforces.com//blog/entry/112963,Consider how each sort of tea affects the tasters The th sort makes testers for some drink to their limit and the th taster drink the remaining tea Sometimes there is no such th taster but we ll explore the general case Let s add the remaining tea straight to the th taster answer And for each taster from to we ll add into the value denoting how many times they drank at their limit If we have these calculated we can obtain the answer by adding and In order to find we can use prefix sums Build over the sequence Now you want to find the largest such that Rewrite it as You can do this with a binary search In particular with an upper bound call The amount of the remaining tea can also be calculated from prefix sums To add on a range you can use a technique called delta encoding Add to Subtract from After everything is added propagate this values via a prefix sum This way if both and happened non strictly to the left or strictly to the right of it doesn t affect at all the segment either closes before or opens after Otherwise it adds exactly to Overall complexity per testcase 
https://codeforces.com//contest/1051/problem/E,222361,E,1051E,1051,E. Vasya and Big Integers,Vasya owns three big integers a l r Let s define a partition of x such a sequence of strings s 1 s 2 dots s k that s 1 s 2 dots s k x where is a concatanation of strings s i is the i th element of the partition For example number 12345 has the following partitions and lots of others Let s call some partition of a if each of its elements Vasya want to know the number of partitions of number a which has each of s i satisfy the condition l le s i le r Note that the comparison is the integer comparison not the string one Help Vasya to count the amount of partitions of number a such that they match all the given requirements The result can be rather big so print it modulo 998244353 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\n\nstring A,L,R,LA,RA;\nint NA,NL,NR,LS,RS;;\nvector<int> LZ,RZ;\n\nll mo=998244353;\nll bt[2020202];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>A>>L>>R;\n\tNA=A.size();\n\tNL=L.size();\n\tNR=R.size();\n\t\n\tLA=L+""@""+A;\n\tRA=R+""@""+A;\n\tLZ=Zalgo(LA);\n\tRZ=Zalgo(RA);\n\t\n\t\n\tbt[0]=1;\n\tbt[1]=mo-1;\n\tFOR(i,NA) {\n\t\tif(i) (bt[i]+=bt[i-1])%=mo;\n\t\tll now=bt[i];\n\t\tif(A[i]==\'0\') {\n\t\t\tif(L[0]==\'0\') {\n\t\t\t\t(bt[i+1]+=now)%=mo;\n\t\t\t\t(bt[i+2]+=mo-now)%=mo;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tx=min(NA-i,NL);\n\t\tif(x<NL) continue;\n\t\tif(LZ[NL+1+i]<x && A[i+LZ[NL+1+i]]<L[LZ[NL+1+i]]) x++;\n\t\ty=min(NA-i,NR);\n\t\tif(y==NR && RZ[NR+1+i]<y && A[i+RZ[NR+1+i]]>R[RZ[NR+1+i]]) y--;\n\t\t\n\t\tif(x<=y) {\n\t\t\t(bt[i+x]+=now)%=mo;\n\t\t\t(bt[i+y+1]+=mo-now)%=mo;\n\t\t}\n\t\t\n\t}\n\tcout<<((bt[NA]+bt[NA-1])%mo)<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n']",,,"['binary search', 'data structures', 'dp', 'hashing', 'strings']",2600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\E. Vasya and Big Integers.json,https://codeforces.com//blog/entry/61969,Let s use dynamic programming to solve the problem Let be the number of correct partitions for the long integer It s easy to see that if we have two big integers without leading zeroes we know the lengths of these integers and these lengths are not equal then we can determine which integer is greater in We will calculate the answers in the following order Suppose we want to calculate Let be the minimum position such that the number meets the following condition Let be the maximum position such that the number meets the following condition Initially let s consider will be less if will be less if To determine which of the numbers and is greater let s calculate z function for the string where is any character that doesn t occur in and After calculating z function we can easily find the first non equal character in and and this character will determine which number is greater To compare and we can act the same All that s left is to set to the sum of values from to This can be done by maintaining suffix sums There is a corner case which applies when If then because we cannot afford any leading zeroes Otherwise 
https://codeforces.com//contest/1286/problem/B,509640,B,1286B,1286,B. Numbers on Tree,Evlampiy was gifted a rooted tree The vertices of the tree are numbered from 1 to n Each of its vertices also has an integer a i written on it For each vertex i Evlampiy calculated c i the number of vertices j in the subtree of vertex i such that a j a i Illustration for the second example the first integer is a i and the integer in parentheses is c iAfter the new year Evlampiy could not remember what his gift was He remembers the tree and the values of c i but he completely forgot which integers a i were written on the vertices Help him to restore initial integers ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[2010];\nint w[2010], root, n, Num[2010], ord[2010], cnt, vis[2010], Res[2010], Rank[2010], Ed[2010], inp[2010];\nvoid DFS(int a, int pp) {\n\tNum[a] = ++cnt;\n\tord[cnt] = a;\n\tfor (auto &x : E[a]) {\n\t\tDFS(x, a);\n\t}\n\tEd[a] = cnt;\n}\nint main() {\n\tint i, a, j;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a);\n\t\tif (a) {\n\t\t\tE[a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\troot = i;\n\t\t}\n\t\tscanf(""%d"", &w[i]);\n\t\tinp[i] = w[i];\n\t}\n\tDFS(root, 0);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (!vis[ord[j]] && !w[ord[j]])break;\n\t\t}\n\t\tif (j == n + 1) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t\tint x = ord[j];\n\t\tvis[x] = 1;\n\t\tRes[i] = x;\n\t\tRank[x] = i;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[j] < Num[x] && Num[x] <= Ed[j] && !vis[j]) {\n\t\t\t\tw[j]--;\n\t\t\t\tif (w[j] < 0) {\n\t\t\t\t\tputs(""NO"");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint c = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[i] < Num[j] && Num[j] <= Ed[i]) {\n\t\t\t\tif (Rank[i] > Rank[j])c++;\n\t\t\t}\n\t\t}\n\t\tif (c != inp[i]) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""YES"");\n\tfor (i = 1; i <= n; i++)printf(""%d "", Rank[i]);\n}']",,,"['constructive algorithms', 'data structures', 'dfs and similar', 'graphs', 'greedy', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\B. Numbers on Tree.json,https://codeforces.com//blog/entry/72867,There are several approaches to this problem We will tell one of them Note that if for some vertex is greater than the number of vertices in its subtree then there is no answer Now we prove that we can always build the answer so that all will be numbers from to On those numbers let s build some structure that supports deleting elements and searching for k th element Let s denote by the number of vertices in the subtree of vertex Now iterate over the subtree of in the order of the depth first search Then let s set th element in our structure and after that delete this element Firstly such an element will always exist This is true because when we examine the vertex all vertices in the subtree of this vertex are not yet considered since in our structure there are at least elements Secondly the set of all values in the subtree will be a prefix of our structure If this is true then the condition that the subtree contains exactly elements smaller than ours is guaranteed to be satisfied because all elements from our structure that are smaller than ours are there and we specifically took the th element Let us prove this fact by induction on the size of the tree For a tree of size this is obvious we always take the first element Now for size we have the root on which the number is written Then when we throw out and then throw out all the vertices in the subtree we will remove the prefix of at least vertices which means that we will drop all the vertices up to as well as some prefix of vertices after it thus in total we ll throw out some prefix of vertices Now we have reduced the problem to dfs and searching for k order statistics This can be done in a variety of ways segment tree Fenwick tree sqrt decomposition Cartesian tree or a built in c tree Code of the author solution with this tree 
https://codeforces.com//contest/1296/problem/C,531584,C,1296C,1296,C. Yet Another Walking Robot,There is a robot on a coordinate plane Initially the robot is located at the point 0 0 Its path is described as a string s of length n consisting of characters Each of these characters corresponds to some move left means that the robot moves from the point x y to the point x 1 y right means that the robot moves from the point x y to the point x 1 y up means that the robot moves from the point x y to the point x y 1 down means that the robot moves from the point x y to the point x y 1 The company that created this robot asked you to optimize the path of the robot somehow To do this you can remove of the path But this company doesn t want their customers to notice the change in the robot behavior It means that if before the optimization the robot ended its path at the point x e y e then after optimization i e removing some single substring from s the robot also ends its path at the point x e y e This optimization is a low budget project so you need to remove possible substring to optimize the robot s path such that the endpoint of his path doesn t change It is possible that you can t optimize the path Also it is possible that after the optimization the target path is an empty string i e deleted substring is the whole string s Recall that the substring of s is such string that can be obtained from s by removing some amount of characters possibly zero from the prefix and some amount of characters possibly zero from the suffix For example the substrings of are but not and You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;char a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int x=0,y=0;\n        map<PII,int>mp;\n        mp[PII(0,0)]=0;\n        scanf(""%d"",&n);\n        scanf(""%s"",a+1);\n        int ans=INF;\n        int l=0;\n        for(int i=1;i<=n;i++){\n            if(a[i]==\'L\')x++;\n            if(a[i]==\'R\')x--;\n            if(a[i]==\'U\')y++;\n            if(a[i]==\'D\')y--;\n            if(mp.count(PII(x,y))){\n                int k=mp[PII(x,y)];\n                if(i-k<ans)ans=i-k,l=k+1;\n            }\n            mp[PII(x,y)]=i;\n        }\n        if(l==0)printf(""-1\\n"");\n        else printf(""%d %d\\n"",l,l+ans-1);\n    }\n    return 0;\n}\n/*\n*/\n']",,,"['data structures', 'implementation']",1500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\C. Yet Another Walking Robot.json,https://codeforces.com//blog/entry/73627,Formally the problem asks you to remove the shortest cycle from the robot s path Because the endpoint of the path cannot be changed the number of s should be equal to the number of s and the same with and How to find the shortest cycle Let s create the associative array for C which will say for each point of the path the maximum number of operations such that if we apply first operations we will stay at this point Initially this array will contain only the point with the value Let s go over all characters of in order from left to right Let the current point be we applied first operations indexed If this point is in the array already let s try to update the answer with the value and left and right borders with values and correspondingly Then let s assign and continue If there were no updates of the answer the answer is Otherwise you can print any substring you found Time complexity per test case 
https://codeforces.com//contest/580/problem/A,35995,A,580A,580,A. Kefa and First Steps,Kefa decided to make some money doing business on the Internet for exactly days He knows that on the th day he makes money Kefa loves progress that s why he wants to know the length of the maximum non decreasing subsegment in sequence Let us remind you that the subsegment of the sequence is its continuous fragment A subsegment of numbers is called non decreasing if all numbers in it follow in the non decreasing order Help Kefa cope with this task ,"['#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\n#include<bitset>\n\nusing namespace std;\ntypedef long long LL;\nint a[200000];\nint main() {\n    int n;\n    a[0]=-1;\n    int ans=0;\n    int s=0;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(""%d"",&a[i]);\n        if (a[i]>=a[i-1]) s++;\n        else\n        {\n            s=1;\n        }\n        ans=max(ans,s);\n    }\n    cout<<ans<<endl;\n    return 0;\n}']",,,"['brute force', 'dp', 'implementation']",900,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\A. Kefa and First Steps.json,https://codeforces.com//blog/entry/20468,Note that if the array has two intersecting continuous non decreasing subsequence they can be combined into one Therefore you can just pass the array from left to right If the current subsequence can be continued using the th element then we do it otherwise we start a new one The answer is the maximum subsequence of all the found ones Asymptotics Solution 
https://codeforces.com//contest/1693/problem/D,1430891,D,1693D,1693,D. Decinc Dividing,Let s call an array a of m integers a 1 a 2 ldots a m if a can be made increasing by removing a decreasing subsequence possibly empty from it For example if a 3 2 4 1 5 we can remove the decreasing subsequence a 1 a 4 from a and obtain a 2 4 5 which is increasing You are given a permutation p of numbers from 1 to n Find the number of pairs of integers l r with 1 le l le r le n such that p l ldots r the subarray of p from l to r is a array ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nint nastwie[nax];\nint nastmie[nax];\n\nll wyn;\n\nint dolny[nax];\nint nd[nax];\nint ng[nax];\n\nint pd[nax];\nint pg[nax];\n\nint spokdal[nax];\n\nint lecimy[nax];\n\nmap<pii,int> mapa;\n\nint dive(int d, int g)\n{\n\tif (mapa.count({d, g}))\n\t\treturn mapa[{d, g}];\n\tint x=max(d, g);\n\tif (x==n)\n\t\treturn mapa[{d, g}]=n;\n\tx++;\n\tif (tab[x]>tab[d])\n\t\treturn mapa[{d, g}]=dive(x, g);\n\tif (tab[x]<tab[g])\n\t\treturn mapa[{d, g}]=dive(d, x);\n\treturn mapa[{d, g}]=x-1;\n}\n\nint check(int a, int b)\n{\n\tif (spokdal[a]>=b)\n\t\treturn 1;\n\tint x=spokdal[a];\n\tint g=pg[x];\n\tint d=pd[x];\n\tassert(g && d);\n\treturn dive(d, g)>=b;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\t\t//~ tab[i]=i;\n\t//~ {\n\t\t//~ if (i&1)\n\t\t\t//~ tab[i]=(i+1)/2;\n\t\t//~ else\n\t\t\t//~ tab[i]=n-(i-1)/2;\n\t//~ }\n\t//~ shandom_ruffle(tab+1, tab+1+n);\n\tfor (int i=n; i; i--)\n\t{\n\t\tnastwie[i]=nastmie[i]=i+1;\n\t\twhile(nastwie[i]<=n && tab[nastwie[i]]<tab[i])\n\t\t\tnastwie[i]=nastwie[nastwie[i]];\n\t\twhile(nastmie[i]<=n && tab[nastmie[i]]>tab[i])\n\t\t\tnastmie[i]=nastmie[nastmie[i]];\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tif (tab[i+1]>tab[i])\n\t\t\tdolny[i]=1;\n\t}\n\tnd[n+1]=ng[n+1]=n+1;\n\tfor (int i=n; i; i--)\n\t{\n\t\tnd[i]=nd[i+1];\n\t\tng[i]=ng[i+1];\n\t\tif (dolny[i])\n\t\t\tnd[i]=i;\n\t\telse\n\t\t\tng[i]=i;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpd[i]=pd[i-1];\n\t\tpg[i]=pg[i-1];\n\t\tif (dolny[i])\n\t\t\tpd[i]=i;\n\t\telse\n\t\t\tpg[i]=i;\n\t}\n\tspokdal[n+1]=n;\n\tfor (int i=n; i; i--)\n\t{\n\t\tspokdal[i]=spokdal[i+1];\n\t\tif (dolny[i])\n\t\t{\n\t\t\tint x=nd[i+1];\n\t\t\tif (x<=n && tab[x]<tab[i])\n\t\t\t\tspokdal[i]=min(spokdal[i], x-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=ng[i+1];\n\t\t\tif (x<=n && tab[x]>tab[i])\n\t\t\t\tspokdal[i]=min(spokdal[i], x-1);\n\t\t}\n\t}\n\tint w=n;\n\tll wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\twhile(!check(i, w))\n\t\t\tw--;\n\t\twyn+=w-i+1;\n\t}\n\tprintf(""%lld\\n"", wyn);\n\t//~ lecimy[n]=n;\n\t//~ for (int i=n-1; i; i--)\n\t//~ {\n\t\t//~ if (!pd[i] || !pg[i])\n\t\t//~ {\n\t\t\t//~ lecimy[i]=lecimy[i+1];\n\t\t\t//~ continue;\n\t\t//~ }\n\t\t//~ int d=pd[i];\n\t\t//~ int g=pg[i];\n\t\t//~ assert(d==i || g==i);\n\t\t//~ if (tab[i+1]>=tab[g])\n\t\t//~ {\n\t\t\t\n\t\t//~ }\n\t//~ }\n\t//~ debug() << range(spokdal+1, spokdal+1+n);\n\t//~ debug() << range(dolny+1, dolny+1+n);\n\treturn 0;\n}\n']",,,"['brute force', 'data structures', 'divide and conquer', 'dp', 'greedy']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1\D. Decinc Dividing.json,https://codeforces.com//blog/entry/103952,Let s solve the problem for a single subarray Assume the th element belongs to the increasing subsequence Define for the interval as the maximum value the last element of the decreasing subsequence can have It s in case the decreasing subsequence is empty It s if the array is not possible Assume the th element belongs to the decreasing subsequence Define for the interval as the minimum value the last element of the increasing subsequence can have It s in case the increasing subsequence is empty It s if the array is not possible The interval is not if and only if and Iterate over from to and keep the and values updated shown in the implementation We claim that each or value will change at most three times throughout the algorithm For some index assume is the largest index smaller than such that can only be one of these four values Because the last element of the decreasing subsequence can t be before the th element And if it s some that lies on the interval you can simply move it to the increasing subsequence since both th and th elements belong to the increasing subsequence The same applies for So the function is called times in total Time complexity 
https://codeforces.com//contest/1016/problem/C,204438,C,1016C,1016,C. Vasya And The Mushrooms,Vasya s house is situated in a forest and there is a mushroom glade near it The glade consists of two rows each of which can be divided into consecutive cells For each cell Vasya knows how fast the mushrooms grow in this cell more formally how many grams of mushrooms grow in this cell each minute Vasya spends exactly one minute to move to some adjacent cell Vasya cannot leave the glade Two cells are considered adjacent if they share a common side When Vasya enters some cell he instantly collects all the mushrooms growing there Vasya begins his journey in the left upper cell Every minute Vasya must move to some adjacent cell he cannot wait for the mushrooms to grow He wants to visit all the cells and maximize the total weight of the collected mushrooms Initially all mushrooms have a weight of Note that Vasya doesn t need to return to the starting cell Help Vasya Calculate the maximum total weight of mushrooms he can collect ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=303030;\nLL n, a[2][N], sa[2][N];\nLL rgt[2][N], lft[2][N];\nLL sum_to_rgt(int row, int li, int ri, int til){\n  if(li > ri) return 0;\n  LL ret=rgt[row][li]-rgt[row][ri+1];\n  //LL ret=rgt[row][ri]-rgt[row][li-1];\n  ret-=(n+n-til)*(sa[row][ri]-sa[row][li-1]);\n  return ret;\n}\nLL sum_to_lft(int row, int li, int ri, int til){\n  if(li > ri) return 0;\n  LL ret=lft[row][ri]-lft[row][li-1];\n  ret-=(n+1-til)*(sa[row][ri]-sa[row][li-1]);\n  return ret;\n}\nint main(){\n  scanf(""%lld"", &n);\n  for(int i=0; i<2; i++)\n    for(int j=1; j<=n; j++){\n      scanf(""%lld"", &a[i][j]);\n      sa[i][j]=sa[i][j-1]+a[i][j];\n    }\n  for(int i=0; i<2; i++)\n    for(int j=n, bns=n+n; j>=1; j--, bns--)\n      rgt[i][j]=rgt[i][j+1]+bns*a[i][j];\n  for(int i=0; i<2; i++)\n    for(int j=1, bns=n+n; j<=n; j++, bns--)\n      lft[i][j]=lft[i][j-1]+bns*a[i][j];\n  LL ans=0, pre=0;\n  for(int i=1, bns=0; i<=n; i++, bns+=2){\n    if(i&1){\n      {\n        LL tans=pre;\n        tans+=sum_to_rgt(0, i, n, bns+n-i);\n        tans+=sum_to_lft(1, i, n, bns+n-i+1);\n        ans=max(ans, tans);\n      }\n      pre+=a[0][i]*bns;\n      pre+=a[1][i]*(bns+1);\n    }else{\n      {\n        LL tans=pre;\n        tans+=sum_to_rgt(1, i, n, bns+n-i);\n        tans+=sum_to_lft(0, i, n, bns+n-i+1);\n        ans=max(ans, tans);\n      }\n      pre+=a[1][i]*bns;\n      pre+=a[0][i]*(bns+1);\n    }\n  }\n  ans=max(ans, pre);\n  printf(""%lld\\n"", ans);\n}\n']",,,"['dp', 'implementation']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. Vasya And The Mushrooms.json,https://codeforces.com/blog/entry/61015,A route visiting each cell exactly once can always be denoted as follows several possibly zero first columns of the glade are visited in a zigzag pattern then Vasya goes to the right until the end of the glade makes one step up or down and goes left until he visits all remaining cells There are such routes To calculate the weight of collected mushrooms quickly we will precompute three arrays for the first row of the glade and will be used to compute the weight of mushrooms collected when Vasya moves to the right until the last column of the glade when Vasya moves to the left from the last column and to handle the growth of mushrooms Also we have to compute the same arrays for the second row of the glade Let s iterate on the number of columns Vasya will pass in a zigzag pattern and maintain the weight of mushrooms he will collect while doing so Then we have to add the weight of the mushrooms Vasya will gather while moving to the right and then while moving to the left The first can be handled by arrays and the second by arrays and 
https://codeforces.com//contest/371/problem/D,4154,D,371D,371,D. Vessels,There is a system of vessels arranged one above the other as shown in the figure below Assume that the vessels are numbered from 1 to in the order from the highest to the lowest the volume of the th vessel is liters Initially all the vessels are empty In some vessels water is poured All the water that overflows from the th vessel goes to the th one The liquid that overflows from the th vessel spills on the floor Your task is to simulate pouring water into the vessels To do this you will need to handle two types of queries Add liters of water to the th vessel Print the number of liters of water in the th vessel When you reply to the second request you can assume that all the water poured up to this point has already overflown between the vessels ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname """"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define sz size()\nconst int N = 200500;\n\nint t[4 * N], nn = 1;\n\nvoid upd(int v) {\n\tv += nn - 1;\n\tt[v] = 0;\n\tv >>= 1;\n\twhile (v) {\n\t\tt[v] = t[v + v] + t[v + v + 1];\n\t\tv >>= 1;\n\t}\n}\n\nint get(int l, int r) {\n\tint res = 0;\n\tl += nn - 1;\n\tr += nn - 1;\n\twhile (l < r) {\n\t\tif (l & 1) res += t[l], l++;\n\t\tif (!(r & 1)) res += t[r], r--;\n\t\tl >>= 1, r >>= 1;\n\t}\n\tif (l == r) res += t[l];\n\treturn res;\n}\n\nint n, a[N], b[N], l[N], r[N], m, type, x, p;\nint main ()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen (fname""in"",""r"",stdin);\n\tfreopen (fname""out"",""w"",stdout);\n\t#endif\n\n\tscanf (""%d"", &n);\n\t\n\twhile (nn < n) nn += nn;\n\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tscanf (""%d"", &b[i]);\n\t\tt[i + nn - 1] = 1;\n\t}\n\tfor (int i = nn - 1; i > 0; -- i) t[i] = t[i + i] + t[i + i + 1];\n\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tif (i > 1) l[i] = i - 1;\n\t\tif (i < n) r[i] = i + 1;\n\t}\n\n\tscanf (""%d"", &m);\n\n\tfor (int i = 1; i <= m; ++ i) {\n\t\tscanf (""%d"", &type);\n\t\tif (type == 1) {\n\t\t\tscanf (""%d%d"", &p, &x);\n\t\t\tint L = p, R = n, id = n + 1;\n\t\t\twhile (L <= R) {\n\t\t\t\tint mid = (L + R) >> 1;\n\t\t\t\tif (get(p, mid) >= 1) {\n\t\t\t\t\tid = min(id, mid);\n\t\t\t\t\tR = mid - 1;\n\t\t\t\t}\n\t\t\t\telse L = mid + 1;\n\t\t\t}\n\t\t\tif (id == n + 1) continue;\n\n\t\t\twhile (id > 0) {\n\t\t\t\tif (a[id] + x >= b[id]) {\n\t\t\t\t\tx -= (b[id] - a[id]);\n\t\t\t\t\ta[id] = b[id];\n\t\t\t\t\tupd(id);\n\t\t\t\t\tr[l[id]] = r[id];\n\t\t\t\t\tl[r[id]] = l[id];\n\t\t\t\t\tint nxt = r[id];\n\t\t\t\t\tl[id] = r[id] = 0;\n\t\t\t\t\tid = nxt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[id] += x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tscanf (""%d"", &p);\n\t\t\tprintf(""%d\\n"", a[p]);\n\t\t}\n\t}\n\n\treturn 0;\n}']",,,"['data structures', 'dsu', 'implementation', 'trees']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Vessels.json,https://codeforces.com//blog/entry/9876,The naive solution for this problem will work like this Let us store an amount of water in each vessel in some array If we need to know how much water is in some vessel we just take the number from the array If we need to pour units of water into vessel number we must follow the simple procedure 1 If then all water is poured and we must end the procedure 2 If Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX In the worst case scenario such procedure can iterate through all vessels each time For example if there are vessels and each vessels have capacity of one unit of water each query like Unable to parse markup type CF TEX To make this solution faster we should notice that once completely filled vessel can be skipped during the algorithm above because it can not consume any more water So instead of Unable to parse markup type CF TEX Unable to parse markup type CF TEX To implement this function we can use different structures For example we can use sorted set of numbers set in C TreeSet in Java Let store the set of indices of unfilled vessels So to find next not filled vessel from th vessel we must find smallest number that is contained in set and is strictly greater than There are built in methods for it upper bound in C higher in Java Also each time we fill the vessel we must erase corresponding index from the set So now we can see that algorithm can not complete more that Unable to parse markup type CF TEX Unable to parse markup type CF TEX Unable to parse markup type CF TEX 
https://codeforces.com//contest/1000/problem/G,193660,G,1000G,1000,G. Two-Paths,You are given a weighted tree undirected connected graph with no cycles loops or multiple edges with n vertices The edge u j v j has weight w j Also each vertex i has its own value a i assigned to it Let s call a path starting in vertex u and ending in vertex v where each edge can appear no more than twice regardless of direction a Vertices can appear in the 2 path multiple times even start and end vertices For some 2 path p profit text Pr p sum limits v in text distinct vertices in p a v sum limits e in text distinct edges in p k e cdot w e where k e is the number of times edge e appears in p That is vertices are counted once but edges are counted the number of times they appear in p You are about to answer m queries Each query is a pair of vertices qu qv For each query find 2 path p from qu to qv with maximal profit text Pr p ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 300300;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint tim;\nint dip[N];\nint tin[N];\nint tout[N];\nlong long s[N];\nlong long A[N];\nlong long B[N];\nlong long a[N];\nlong long e[N];\nlong long d[N];\nlong long u[N];\nlong long f[N];\nlong long er[N];\nint up[N][20];\nvector < int > v[N];\n\nvoid dfs(int x, int p)\n{\n        tin[x] = ++tim;\n        up[x][0] = p;\n        for(int i = 1; i < 20; i++){\n                up[x][i] = up[up[x][i - 1]][i - 1];\n        }\n        d[x] = a[x];\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                dip[y] = dip[x] + 1;\n                s[y] = s[x] - e[h];\n                dfs(y, x);\n                d[x] += max(0ll, d[y] - e[h] - e[h]);\n        }\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                f[y] = d[x] - max(0ll, d[y] - e[h] - e[h]);\n                er[y] = max(0ll, d[y] - e[h] - e[h]);\n        }\n        tout[x] = ++tim;\n}\n\nvoid go(int x, int p)\n{\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                u[y] = max(0ll, u[x] + f[y] - e[h] - e[h]);\n                f[y] += f[x];\n                go(y, x);\n        }\n}\n\nbool is(int x, int y)\n{\n        return tin[x] <= tin[y] && tout[x] >= tout[y];\n}\n\nint lca(int x, int y)\n{\n        if(is(x, y)){\n             return x;\n        }\n        if(is(y, x)){\n                return y;\n        }\n        for(int i = 19; i >= 0; i--){\n                if(!is(up[x][i], y)){\n                        x = up[x][i];\n                }\n        }\n        return up[x][0];\n}\n\nint go_up(int x, int g)\n{\n        for(int i = 19; i >= 0; i--){\n                if(g >= (1 << i)){\n                        g -= (1 << i);\n                        x = up[x][i];\n                }\n        }\n        return x;\n}\n\nlong long get(int x, int y)\n{\n        long long profit = 0;\n        int p = lca(x, y);\n        profit += d[p];\n        if(x != p){\n                int g = go_up(x, dip[x] - dip[p] - 1);\n                profit += f[x] - f[g];\n                profit += d[x] - er[g];\n        }\n        if(y != p){\n                int g = go_up(y, dip[y] - dip[p] - 1);\n                profit += f[y] - f[g];\n                profit += d[y] - er[g];\n        }\n        profit += s[x] + s[y] - s[p] - s[p];\n        profit += u[p];\n        return profit;\n}\n\nvoid solve()\n{\n        int q;\n        cin >> n >> q;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        for(int i = 1; i < n; i++){\n                cin >> A[i] >> B[i] >> e[i];\n                v[A[i]].push_back(i);\n                v[B[i]].push_back(i);\n        }\n        dfs(1, 1);\n        go(1, 1);\n        for(int i = 1; i <= q; i++){\n                int x, y;\n                cin >> x >> y;\n                cout << get(x, y) << ""\\n"";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']",,,"['data structures', 'dp', 'trees']",2700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\G. Two-Paths.json,https://codeforces.com/blog/entry/60288,Let s solve this task in several steps Step 1 Calculate for each vertex Let be maximal profit of some 2 path starting at and finishing at If vertex is a root of the tree then equivalent to where maximal profit of 2 path when we can go only in subtree of The can be calculated with next approach To calculate we can use next technique Let s manage next invariant when processing vertex all its neighbours even parent will hold as if its parent Then After that we can proceed with each child of but before moving to it we must change value since we must keep invariant true To keep it true it s enough to set Also let s memorize value as Step 2 Processing queries Let simple path be If then answer is Otherwise each edge on this simple path must be used exactly once But while travelling from to using this simple path at each vertex we can go somewhere and return to the only condition is not use edges from simple path And we can do it using precalculated values and So if we want to find max profit of 2 path with prohibited edges so we can use value Finally to process queries let s find divide it on two queries Now we can handle all queries offline travelling on tree in dfs order Let s manage some data structure on current path from current vertex to the root this DS can be based on array of depths Then when we come to vertex just add value to DS in position and erase it before exit Each query becomes a query of sum to some subsegment in DS don t forget carefully handle value in lca And before moving from to you need subtract from current value of here you can at once subtract weight of edge Don t forget to return each change in DS when it needed As we can see DS is just a BIT with sum on segment and change in position Result complexity is Fast IO are welcome 
https://codeforces.com//contest/1353/problem/A,620787,A,1353A,1353,A. Most Unstable Array,You are given two integers n and m You have to construct the array a of length n consisting of i e integers greater than or equal to zero such that the sum of elements of this array is m and the value sum limits i 1 n 1 a i a i 1 is the maximum possible Recall that x is the absolute value of x In other words you have to maximize the sum of absolute differences between adjacent consecutive elements For example if the array a 1 3 2 5 5 0 then the value above for this array is 1 3 3 2 2 5 5 5 5 0 2 1 3 0 5 11 Note that this example but it shows how the required value for some array is calculated You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,b;\n           cin>>a>>b;\n           if (a==1) {cout<<""0\\n""; return; }\n           if (a==2) {cout<<b<<""\\n""; return; }\n           cout<<2*b<<""\\n""; return; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']",,,"['constructive algorithms', 'greedy', 'math']",800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV3\A. Most Unstable Array.json,https://codeforces.com//blog/entry/77373,If then the answer is Otherwise the best way is to construct the array For we can t reach answer more than and for we can t reach the answer more than because each unit can t be used more than twice So the answer can be represented as 
https://codeforces.com//contest/1731/problem/D,1711454,D,1731D,1731,D. Valiant s New Map,Game studio DbZ Games wants to introduce another map in their popular game Valiant This time the map named Panvel will be based on the city of Mumbai Mumbai can be represented as n times m cellular grid Each cell i j 1 le i le n 1 le j le m of the grid is occupied by a cuboid building of height a i j This time DbZ Games want to make a map that has perfect vertical gameplay That s why they want to choose an l times l square inside Mumbai such that each building inside the square has a height of at least l Can you help DbZ Games find such a square of the maximum possible size l ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n>>m;\n\t\tvector a(n,vector(m,0));\n\t\tcin>>a;\n\t\tint l=0,r=n;\n\t\twhile (l<r)\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tauto ck=[&](int mid)\n\t\t\t{\n\t\t\t\tint i,j;\n\t\t\t\tvector s(n+1,vector(m+1,0));\n\t\t\t\tfor (i=0; i<n; i++) for (j=0; j<m; j++) s[i+1][j+1]=s[i][j+1]+s[i+1][j]-s[i][j]+(a[i][j]>=mid);\n\t\t\t\tfor (i=mid; i<=n; i++) for (j=mid; j<=m; j++) if (s[i][j]+s[i-mid][j-mid]-s[i][j-mid]-s[i-mid][j]==mid*mid) return 1;\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\tif (ck(mid)) l=mid; else r=mid-1;\n\t\t}\n\t\tcout<<l<<\'\\n\';\n\t}\n}\n']",,,"['binary search', 'brute force', 'data structures', 'dp', 'two pointers']",1700,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\D. Valiant s New Map.json,https://codeforces.com//blog/entry/110630,The basic brute force solution for this problem was to just iterate through all the values of sides possible Note that the value of sides can range only from to as product of can t exceed so there can t be a cube having all sides greater than After setting side length let s say we look into all possible submatrices of dimensions and see if we can form a cube from any one of those This could only be possible if there exists a submatrix with its minimum Now we need to do all these operations efficiently looking at the constraints The main thing that we need to do is Binary search on the answer As obviously it is possible to make a cube with a smaller side if it is possible to make the one with the current side length For a particular side check for all submatrices of size if their minimum is greater than equal to If you find any such submatrix then this value of side is possible A minimum can be calculated in using sparse tree You might have tried using segment tree which takes time per query But it may not to pass with these constraints So the time complexity to solve this problem is It would pass these constraints Another solution where you don t use binary search is also there but would fail with these constraints The segment tree solution takes So only sparse tree can be used This is a much simpler solution First we create another matrix let s say Now for a particular side length we take all the indices where the building heights are greater than equal to and set the elements of at those indices to Other elements are set to Now we precalculate the prefix sum for this matrix Then for each index of the matrix we check if the square starting from that index has a prefix sum equal to If anyone of it does then this side length for the cube is possible Time Complexity is again 
https://codeforces.com//contest/1976/problem/F,2672922,F,1976F,1976,F. Remove Bridges,You are given a rooted tree consisting of n vertices numbered from 1 to n Vertex 1 is the root Additionally the root only has one child You are asked to add exactly k edges to the tree possibly multiple edges and or edges already existing in the tree Recall that a bridge is such an edge that after you remove it the number of connected components in the graph increases So initially all edges of the tree are bridges After k edges are added some original edges of the tree are still bridges and some are not anymore You want to satisfy two conditions for every bridge all tree edges in the subtree of the lower vertex of that bridge should also be bridges the number of bridges is as small as possible Solve the task for all values of k from 1 to n 1 and output the smallest number of bridges ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--, v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        std::vector<int> a;    auto dfs = [&](auto &&self, int x, int p) -> int {        int h = 0;        for (auto y : adj[x]) {            if (y == p) {                continue;            }            int v = self(self, y, x) + 1;            if (v > h) {                std::swap(v, h);            }            if (v > 0) {                a.push_back(v);            }        }        return h;    };    a.push_back(dfs(dfs, 0, -1));        std::sort(a.begin(), a.end(), std::greater());        int ans = n - 1;    for (int i = 1, j = 0; i < n; i++) {        while (j < 2 * i - 1 && j < a.size()) {            ans -= a[j];            j++;        }        std::cout << ans << "" \\n""[i == n - 1];    }}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']",,,"['data structures', 'dfs and similar', 'dp', 'greedy', 'sortings', 'trees']",2800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Remove Bridges.json,https://codeforces.com//blog/entry/129992,What does an extra edge change in the configuration of the bridges Well all tree edges on the path between the two vertices that an extra edge connects stop being bridges So the task can be restated as follows choose pairs of distinct vertices such that a root is present in at least one pair the number of edges in the union of the paths between the vertices of all pairs is as large as possible there is no vertex covered by at least one path such that an edge to its parent is not a part of any path The next idea is quite intuitive It only makes sense to choose a root or the leaves of the tree into the pairs If any pair has a non leaf vertex you can safely prolong the path until any of the leaves in its subtree and the union of the paths will not become smaller Now for the tricky idea Instead of choosing pairs of root leaves you can actually just take a root and leaves and there will always be a way to split them into pairs to satisfy all conditions Let s show that Traverse the tree with a DFS and record the order you visit the leaves Pair up a root with the middle leaf in that order Then pair up leaves and and and so on This way the path for every pair includes a vertex on the path of the first pair the one that includes the root Thus the union of the paths is the same as the union of all vertical paths from the leaves to the root That obviously satisfies the condition on the connectedness of the bridges Notice how that union of the paths is also the largest possible on that set of leaves Every path between the leaves can be viewed at as two vertical paths from each leaf The longest vertical path from each leaf is the one going to the root And we have exactly the union of these vertical paths as our solution Thus the task actually becomes as follows choose leaves in such a way that the union of their paths to the root is as large as possible That can actually be done greedily Take a leaf with the longest path to the root Then keep taking leaves that add as many new edges into the union as possible That idea can be implemented as follows For every vertex calculate the longest path that starts in it and ends in some leaf Can be done with a single DFS Maintain a set of all vertices sorted by their longest paths On each step take a vertex with the largest value and remove all vertices on that path any path of the maximum length if there are multiple from the set Overall complexity per testcase 
https://codeforces.com//contest/1553/problem/C,1054395,C,1553C,1553,C. Penalty,Consider a simplified penalty phase at the end of a football match A penalty phase consists of at most 10 kicks the first team takes the first kick the second team takes the second kick then the first team takes the third kick and so on The team that scores more goals wins if both teams score the same number of goals the game results in a tie The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks For example if after the 7 th kick the first team has scored 1 goal and the second team has scored 3 goals the penalty phase ends the first team cannot reach 3 goals You know which player will be taking each kick so you have your predictions for each of the 10 kicks These predictions are represented by a string s consisting of 10 characters Each character can either be or This string represents your predictions in the following way if s i is then the i th kick will definitely score a goal if s i is then the i th kick definitely won t score a goal if s i is then the i th kick could go either way Based on your predictions you have to calculate the minimum possible number of kicks there can be in the penalty phase that means the earliest moment when the penalty phase is stopped considering all possible ways it could go Note that you may know that some kick will won t be scored but the referee doesn t ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nint test(str S) {\n\tAR<int,2> score{};\n\tF0R(i,sz(S)) {\n\t\t{\n\t\t\tAR<int,2> tmp = score;\n\t\t\tFOR(j,i,sz(S)) {\n\t\t\t\tif (j&1) ++tmp[1];\n\t\t\t}\n\t\t\tif (tmp[1] < tmp[0]) return i;\n\t\t}\n\t\t{\n\t\t\tAR<int,2> tmp = score;\n\t\t\tFOR(j,i,sz(S)) {\n\t\t\t\tif (!(j&1)) ++tmp[0];\n\t\t\t}\n\t\t\tif (tmp[0] < tmp[1]) return i;\n\t\t}\n\t\tscore[i&1] += S[i]-\'0\';\n\t}\n\treturn sz(S);\n}\n\nvoid solve(int tc) {\n\tstr S; re(S);\n\tint ans = MOD;\n\t{\n\t\tstr A = S;\n\t\tF0R(i,sz(A)) if (A[i] == \'?\') {\n\t\t\tif (i&1) A[i] = \'1\';\n\t\t\telse A[i] = \'0\';\n\t\t}\n\t\tckmin(ans,test(A));\n\t}\n\t{\n\t\tstr A = S;\n\t\tF0R(i,sz(A)) if (A[i] == \'?\') {\n\t\t\tif (i&1) A[i] = \'0\';\n\t\t\telse A[i] = \'1\';\n\t\t}\n\t\tckmin(ans,test(A));\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']",,,"['bitmasks', 'brute force', 'dp', 'greedy']",1200,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\C. Penalty.json,https://codeforces.com//blog/entry/93105,After you have fixed the values of you can easily find the number of kicks needed to decide the winners in constant time If you iterate over all possible values of you can get solution which works in for one testcase which is enough to pass The other possible solution is to notice that it s optimal to change of one team to and to for other So you only have two candidates to check 
https://codeforces.com//contest/766/problem/E,92735,E,766E,766,E. Mahmoud and a xor trip,Mahmoud and Ehab live in a country with cities numbered from to and connected by undirected roads It s guaranteed that you can reach any city from any other using these roads Each city has a number attached to it We define the distance from city to city as the of numbers attached to the cities on the path from to In other words if values attached to the cities on the path from to form an array of length then the distance between them is where is bitwise operation Mahmoud and Ehab want to choose two cities and make a journey from one to another The index of the start city is always less than or equal to the index of the finish city they may start and finish in the same city and in this case the distance equals the number attached to that city They can t determine the two cities so they try every city as a start and every city with greater index as a finish They want to know the total distance between all pairs of cities ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nll n, a[100100], b[100100];\nll cnt[100100][2];\nll sum;\nvector <int> g[100100];\n\nvoid dfs(int v, int pr = -1){\n    cnt[v][0] = cnt[v][1] = 0;\n    cnt[v][b[v]]++;\n    for(int i = 0; i < g[v].size(); ++i){\n        int to = g[v][i];\n        if(to != pr){\n            dfs(to, v);\n            sum += cnt[to][0] * cnt[v][1] + cnt[to][1] * cnt[v][0];\n            cnt[v][b[v]] += cnt[to][0];\n            cnt[v][b[v] ^ 1] += cnt[to][1];\n        }\n    }\n    sum += b[v];\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n    }\n    for(int i = 2, u, v; i <= n; ++i){\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll ans = 0;\n    for(int i = 0; i <= 20; ++i){\n        sum = 0;\n        for(int j = 1; j <= n; ++j){\n            if(a[j] & (1 << i)){\n                b[j] = 1;\n            }else{\n                b[j] = 0;\n            }\n        }\n        dfs(1);\n        ans += (sum << i);\n    }\n    cout << ans << endl;\n}\n']",,,"['bitmasks', 'constructive algorithms', 'data structures', 'dfs and similar', 'dp', 'math', 'trees']",2100,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Mahmoud and a xor trip.json,https://codeforces.com//blog/entry/50294,If we have an array which represents the number of paths that makes the bit sit to Our answer will be Let be the binary value of the bit of the number attached to node just to make work easier There are 2 types of paths from node to node where is less in depth than or equal to Paths going down which are paths with and other paths Let s root the tree at node and dfs let current node be Let be the number of paths going down from node that makes the bit s value equal to A path going down from node is a path going down from a child of with node concatenated to it so let s calculate our A path that isn t going down is a concatenation of 2 paths which are going down from Now we can calculate See the code for formulas Code http pastebin com n2a3kijD Time complexity Problem author me Solution author me Tester mahmoudbadawy 
https://codeforces.com//contest/845/problem/F,119176,F,845F,845,F. Guards In The Storehouse,Polycarp owns a shop in the capital of Berland Recently the criminal activity in the capital increased so Polycarp is thinking about establishing some better security in the storehouse of his shop The storehouse can be represented as a matrix with rows and columns Each element of the matrix is either an empty space or a wall Polycarp wants to hire some guards possibly zero to watch for the storehouse Each guard will be in some cell of matrix and will protect every cell to the right of his own cell and every cell to the bottom of his own cell until the nearest wall More formally if the guard is standing in the cell then he protects cell if all these conditions are met is an empty cell either and or and there are no walls between cells and Guards can be placed only in empty cells and can protect only empty cells The of placing the guards is some set of cells where guards will be placed of course two plans are different if there exists at least one cell that is included in the first plan but not included in the second plan or vice versa Polycarp calls a plan if there is empty cell that is not protected Polycarp wants to know the number of suitable plans Since it can be very large you have to output it modulo ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\ninline void add(int &x,int y)\n{\n    x+=y;\n    x=(x>=Mod ? x-Mod : x);\n}\nchar s[255][255],t[255][255];\nint dp[2][(1<<15)+5][2][2];\nint main()\n{\n    int n,m;\n    scanf(""%d%d"",&n,&m);\n    for(int i=0;i<n;i++)\n        scanf(""%s"",s[i]);\n    if(n<m)\n    {\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                t[j][i]=s[i][j];\n        memcpy(s,t,sizeof(t));\n        swap(n,m);\n    }\n    int now=0,la=1;\n    dp[now][0][0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        {\n            swap(now,la);\n            memset(dp[now],0,(1<<m)*sizeof(dp[now][0]));\n            for(int mask=0;mask<(1<<m);mask++)\n                for(int k=0;k<2;k++)\n                    for(int l=0;l<2;l++)\n                    {\n                        if(s[i][j]==\'x\')\n                            add(dp[now][mask&(~0^(1<<j))][0][l],dp[la][mask][k][l]);\n                        else\n                        {\n                            int gg=(~mask>>j&1) && (k==0 || j==0);\n                            if(gg+l<2)add(dp[now][mask][k&(j>0)][gg+l],dp[la][mask][k][l]);\n                            add(dp[now][mask|(1<<j)][1][l],dp[la][mask][k][l]);\n                        }\n                    }\n        }\n    int res=0;\n    for(int mask=0;mask<(1<<m);mask++)\n        for(int k=0;k<2;k++)\n            for(int l=0;l<2;l++)\n                add(res,dp[now][mask][k][l]);\n    return 0*printf(""%d\\n"",res);\n}\n']",,,"['bitmasks', 'dp']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\F. Guards In The Storehouse.json,https://codeforces.com//blog/entry/53986,This problem can be solved using dynamic programming with broken profile First of all we have to make the number of rows not larger than if it is larger then we can just rotate the given matrix Let s fill the matrix from left to right and in each column from top to bottom Let be the number of ways to achieve the following situation we now want to fill cell with index denotes the rows which are already protected in this column so there is a wall in this row or there is a guard to the left is a flag that denotes if current cell is protected by some guard above and is a flag that denotes if there was a cell that was not protected When advancing from one column to another we have to change the mask so we update the rows that are currently protected The rows such that in the previous column there was a wall in this row become un protected and the rows such that there is a wall in current column in this row become protected And of course becomes zero When we place a guard we set to one and make the corresponding row protected And when we are at the wall we have to set to zero so the guard from above doesn t protect next cell The answer is the sum of all values 
https://codeforces.com//contest/1620/problem/C,1233290,C,1620C,1620,C. BA-String,You are given an integer k and a string s that consists only of characters a a lowercase Latin letter and an asterisk Each asterisk should be replaced with several from 0 to k inclusive lowercase Latin letters b Different asterisk can be replaced with different counts of letter b The result of the replacement is called a Two strings a and b are different if they either have different lengths or there exists such a position i that a i neq b i A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b Now consider all different BA strings and find the x th lexicographically smallest of them ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T, typename T_iterable>\nvector<pair<T, int>> run_length_encoding(const T_iterable &items) {\n    vector<pair<T, int>> encoding;\n    T previous;\n    int count = 0;\n\n    for (const T &item : items)\n        if (item == previous) {\n            count++;\n        } else {\n            if (count > 0)\n                encoding.emplace_back(previous, count);\n\n            previous = item;\n            count = 1;\n        }\n\n    if (count > 0)\n        encoding.emplace_back(previous, count);\n\n    return encoding;\n}\n\n\nvoid run_case() {\n    int N, K;\n    int64_t X;\n    string S;\n    cin >> N >> K >> X >> S;\n    X--;\n    vector<pair<char, int>> encoding = run_length_encoding<char>(S);\n    dbg(encoding);\n    vector<int64_t> bases;\n\n    for (auto &pr : encoding)\n        if (pr.first == \'*\')\n            bases.push_back(pr.second * K + 1);\n\n    dbg(bases);\n    vector<int64_t> B;\n\n    while (!bases.empty()) {\n        B.push_back(X % bases.back());\n        X /= bases.back();\n        bases.pop_back();\n    }\n\n    dbg(B);\n    string ans;\n\n    for (auto &pr : encoding)\n        if (pr.first == \'*\') {\n            ans += string(B.back(), \'b\');\n            B.pop_back();\n        } else {\n            ans += string(pr.second, pr.first);\n        }\n\n    cout << ans << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']",,,"['brute force', 'dp', 'greedy', 'implementation', 'math']",1800,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\EDUCATIONAL\C. BA-String.json,https://codeforces.com//blog/entry/98061,Find all segments of asterisks in the string Let there be of them and the number of asterisks in them be That tells us that the th segment of asterisks can be replaced with at most letters b Notice that we can compare two strings lexicographically using just the number of letters b that replace each of segments of asterisks Let that sequence for some string be and that sequence for some string be Then if and only if That is there exists such position that The proof is trivial So we can actually look at the sequence as some kind of number in a mixed base The lowest digit can be of one of values from to The second lowest one of And so on Then comparison of two strings is the same as comparison of these two mixed base numbers Thus the task is to convert number to this mixed base Turns out it s not that hard In base for example the lowest digit can be determined as the remainder of the number of dividing by Here it will be the remainder of dividing by After that divide and floor the number and proceed to the next digit After steps are done the digits of that mixed base number tell exactly how many letters b should replace each segment of asterisks Overall complexity per testcase to recover the string to print it 
https://codeforces.com//contest/1842/problem/H,1978972,H,1842H,1842,H. Tenzing and Random Real Numbers,There are n uniform random real variables between 0 and 1 inclusive which are denoted as x 1 x 2 ldots x n Tenzing has m conditions Each condition has the form of x i x j le 1 or x i x j ge 1 Tenzing wants to know the probability that all the conditions are satisfied modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output the integer x that 0 le x M and x cdot q equiv p pmod M ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:56:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> m0(n);\n  vector<int> m1(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, w;\n    cin >> w >> x >> y;\n    --x; --y;\n    if (w == 0) {\n      m0[x] |= (1 << y);\n      m0[y] |= (1 << x);\n    } else {\n      m1[x] |= (1 << y);\n      m1[y] |= (1 << x);\n    }\n  }\n  vector<Mint> dp(1 << n);\n  dp[0] = 1;\n  for (int t = 0; t < (1 << n); t++) {\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int nt = t | (1 << i);\n      int v0 = m0[i] & nt;\n      int v1 = m1[i] & nt;\n      int ways = (int) (v0 == 0) + (int) (v1 == 0);\n      dp[nt] += dp[t] * ways;\n    }\n  }\n  Mint ans = dp.back();\n  for (int i = 1; i <= n; i++) {\n    ans /= 2 * i;\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']",,,"['bitmasks', 'dp', 'graphs', 'math', 'probabilities']",3000,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV1&2\H. Tenzing and Random Real Numbers.json,https://codeforces.com//blog/entry/117606,TutorialSuppose no variable equals because the probability of being equal to is variables less than are called white vertices and those greater than are called black vertices Each black and white coloring is equiprobable so we can calculate the probability that satisfies all conditions for each black and white coloring and then take the average For two variables less than the condition of is always satisfied and the condition of is never satisfied Therefore we do not need to consider the conditions between same colored points The condition between white vertex and black vertex is satisfied only when Let then can be regarded as a random variable in for condition the white vertex s must be less than or equal to the black vertex s so we add an edge from the white vertex to the black vertex for condition we add an edge from the black vertex to the white vertex We get a directed graph that restricts the size relationship of Suppose that sorting from small to large is then each permutation is equiprobable and this contributes if and only if it is a topological sort so the probability that satisfies all conditions is the number of topological sorts divided by Now the problem has been transformed into a counting problem For each coloring count the total number of topological sorts Now we do not enumerate coloring directly but enumerate topological sorts directly by enumerating a permutation such that and count the number of colorings that satisfy the conditions It can be found that condition limits variablesin in the front position of to be less than and condition limits variables in the front position of to be greater than Then we can use bit mask DP Let represent that we have added all vertices in mask into topological sort We enumerate new added vertex u for transition If all variables with conditions between it are included in mask it can be colored black if all variables with conditions between it are included in mask it can be colored white Time complexit is 
https://codeforces.com//contest/570/problem/C,33019,C,570C,570,C. Replacement,Daniel has a string consisting of lowercase English letters and period signs characters Let s define the operation of as the following sequence of steps find a substring two consecutive periods in string of all occurrences of the substring let s choose the first one and replace this substring with string In other words during the replacement operation the first two consecutive periods are replaced by one If string contains no two consecutive periods then nothing happens Let s define as the minimum number of operations of to perform so that the string does not have any two consecutive periods left You need to process queries the th results in that the character at position of string is assigned value After each operation you have to calculate and output the value of Help Daniel to process all queries ,"['#include <cstdio>\n#include <algorithm>\n\n#define MAXN 300005\n\nint n,m;\n\nstruct data {\n\tint l,r,size;\n};\n\ninline data operator + (const data &a,const data &b) {\n\treturn (data){a.l==a.size ? a.size+b.l : a.l,b.r==b.size ? b.size+a.r : b.r,a.size+b.size};\n}\n\nchar a[MAXN];\n\nstruct segnode {\n\tsegnode *l,*r;\n\tdata x;\n\t\n\tinline void update() {\n\t\tx=l->x+r->x;\n\t}\n};\n\nsegnode seg[MAXN*2],*segtot=seg;\n\ninline segnode * build(int l,int r) {\n\tsegnode *ret=++segtot;\n\tif (l==r) {\n\t\tret->x=(data){0,0,1};\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tret->l=build(l,mid);\n\t\tret->r=build(mid+1,r);\n\t\tret->update();\n\t}\n\treturn ret;\n}\n\ninline data query(segnode *a,int l,int r,int L,int R) {\n\tif (l==L && r==R) return a->x;\n\tint mid=(L+R)>>1;\n\tif (r<=mid) {\n\t\treturn query(a->l,l,r,L,mid);\n\t} else if (l>mid) {\n\t\treturn query(a->r,l,r,mid+1,R);\n\t} else {\n\t\treturn query(a->l,l,mid,L,mid)+query(a->r,mid+1,r,mid+1,R);\n\t}\n}\n\ninline void mod(segnode *a,int pos,data x,int L,int R) {\n\tif (L==R) {\n\t\ta->x=x;\n\t} else {\n\t\tint mid=(L+R)>>1;\n\t\tif (pos<=mid) {\n\t\t\tmod(a->l,pos,x,L,mid);\n\t\t} else {\n\t\t\tmod(a->r,pos,x,mid+1,R);\n\t\t}\n\t\ta->update();\n\t}\n}\n\nint ans;\n\nsegnode *root;\n\ninline void modify(int pos,char x) {\n\tif (x!=\'.\') x=0;\n\tif (x==a[pos]) return;\n\ta[pos]=x;\n\tif (x==\'.\') {\n\t\tdata L,R;\n\t\tL=R=(data){0,0,0};\n\t\tif (pos>1) L=query(root,1,pos-1,1,n);\n\t\tif (pos<n) R=query(root,pos+1,n,1,n);\n\t\tans-=std::max(L.r-1,0)+std::max(R.l-1,0);\n\t\tans+=L.r+R.l;\n\t\tmod(root,pos,(data){1,1,1},1,n);\n\t} else {\n\t\tdata L,R;\n\t\tL=R=(data){0,0,0};\n\t\tif (pos>1) L=query(root,1,pos-1,1,n);\n\t\tif (pos<n) R=query(root,pos+1,n,1,n);\n\t\tans+=std::max(L.r-1,0)+std::max(R.l-1,0);\n\t\tans-=L.r+R.l;\n\t\tmod(root,pos,(data){0,0,1},1,n);\n\t}\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\tscanf(""%s"",a+1);\n\troot=build(1,n);\n\tint i;\n\tfor (i=1;i<=n;i++) {\n\t\tchar t=a[i];\n\t\ta[i]=0;\n\t\tmodify(i,t);\n\t}\n\tfor (i=1;i<=m;i++) {\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tchar ch=getchar();\n\t\twhile (ch<=32) ch=getchar();\n\t\tmodify(x,ch);\n\t\tprintf(""%d\\n"",ans);\n\t}\n}']",,,"['constructive algorithms', 'data structures', 'implementation']",1600,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\C. Replacement.json,https://codeforces.com//blog/entry/19770,Lets find how replacements occur If we have segment of points with length we need operations and stop replacements for this segment If we sum lenghts of all segments and its quantity then answer will be total length of segments quantity of segments After change of one symbol length changes by 1 Quantity of segments can be supported by array Consider events of merging dividing creation and deletion of segments For merging we need to find if both of neighbors right and left are points then merging occured and quantity of segments reduced by 1 Other cases can be cosidered similarly Solutions 
https://codeforces.com//contest/1823/problem/E,1896871,E,1823E,1823,E. Removing Graph,Alice and Bob are playing a game on a graph They have an undirected graph without self loops and multiple edges All vertices of the graph have The graph may consist of several components Note that if such graph has n vertices it will have exactly n edges Alice and Bob take turn Alice goes first In each turn the player can choose k l le k le r l r vertices that form and erase these vertices from the graph including all incident edges The player who can t make a step loses For example suppose they are playing on the given graph with given l 2 and r 3 A valid vertex set for Alice to choose at the first move is one of the following 1 2 1 3 2 3 4 5 4 6 5 6 1 2 3 4 5 6 Suppose Alice chooses subgraph 4 6 Then a valid vertex set for Bob to choose at the first move is one of the following 1 2 1 3 2 3 1 2 3 Suppose Bob chooses subgraph 1 2 3 Alice can t make a move so she loses You are given a graph of size n and integers l and r Who will win if both Alice and Bob play optimally ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,mod=998244353;\nint add(int x, int y){x+=y; if(x>=mod) x-=mod; return x;}\nint sub(int x, int y){x-=y; if(x<0) x+=mod; return x;}\nint mul(int x, int y){return ((ll)x)*y%mod;}\nint Pow(int x, ll y=mod-2){int res=1; for(; y; x=mul(x,x),y>>=1) if(y&1) res=mul(res,x); return res;}\n\nint n,l,r;\nvector<int> adj[N];\nbool vis[N];\n\nint cnt;\nvoid dfs(int u){\n    cnt++;\n    vis[u]=1;\n    for(auto v: adj[u]) if(!vis[v]) dfs(v);\n}\n\nvoid ldc(){\n    cin >> n >> l >> r;\n    for(int i=0; i<n; ++i){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    int res=0;\n    for(int i=0; i<n; ++i) if(!vis[i]){\n        cnt=0;\n        dfs(i);\n        if(cnt<l+r) res^=cnt/l;\n    }\n    cout << (res?""Alice"":""Bob"") << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    t=1;\n    while(t--) ldc();\n}']",,,"['brute force', 'dp', 'games', 'graphs', 'math']",2500,D:\scoala\RESEARCH\MLCP\01_CODEFORCES_DATASET\DIV2\E. Removing Graph.json,https://codeforces.com//blog/entry/115465,The solution requires knowledge of the Sprague Grundy theory Recall that means the operation and is equal to the minimum non negative number that is not in the set The given graph is a set of cycles and the game runs independently in each cycle If we can calculate nim value for a cycle of each size then nim value of the whole game is equal to of these values To calculate nim value for the cycle of length we need to take of nim values from all transitions But since all transitions transform a cycle to a chain then we will calculate nim values for chains as well or To calculate nim value for the chain we need to consider all possible transitions We can either cut off from the end of the chain or from the middle of the chain In either case we end up with two smaller chains maybe one of them is empty which are themselves independent games so Implementing this directly requires time A more accurate implementation with recalculations requires time For a complete solution something needs to be noticed in nim values Consider an example Let index0123456789101112131415161718190000111122223333444400001111222233334400 on is obviously equal to on segment proof is below for all since you can always split the chain in two equal chains This transition adds nim value into that s why is equal to up to it s because is equal to for it s because for So if then otherwise We have to calculate the sizes of all cycles in the graph and calculate of those values If it is zero the winner is Bob otherwise winner is Alice Let s prove that on segment there are transitions to pairs of chains where and is any number from Their nim value is equal to so is exactly equal to we can prove that for any pair of chains with value 
